window.TOOLS = {};
window.PLUGINS = {};
window.OBJECTS = {};
window.SERVICES = {};
window.COMMANDS = {};
window.ACCESSORIES = {};
window.DIALOGS = {};
window.PANELS = {};
window.MENUS = {};
window.WINDOWS = {};

class XOS {

    static setTransferData(_object) {
        window.TRANSFER_DATA = _object;
    }

    static getTransferData() {
        return window.TRANSFER_DATA;
    }

    // I generate the UID from two parts here
    // to ensure the random number provide enough bits.
    static createUniqueIDI(_preText) {
        _preText = _preText || 'IDI';
        window.COUNTER_IDI = window.COUNTER_IDI || 0;
        window.COUNTER_IDI++;

        let firstPart = (Math.random() * 46656) | 0;
        let secondPart = (Math.random() * 46656) | 0;
        firstPart = ("000" + firstPart.toString(36)).slice(-3);
        secondPart = ("000" + secondPart.toString(36)).slice(-3);
        return _preText + '_' + window.COUNTER_IDI + firstPart + secondPart;
    }

    static initDragFunctions(_delegate, _startEvent, _onBeforeStartDragFunction, _activationDistance = 20) {
        window.DRAGGING_PROCESS = true;
        let isDragging = false;
        const startPageX = _startEvent.pageX;
        const startPageY = _startEvent.pageY;

        function dragStart(_e) {
            if (_onBeforeStartDragFunction)
                _onBeforeStartDragFunction(_e);
            if (_delegate.onDragStart)
                _delegate.onDragStart(_e);
        }

        function drag(_e) {
            _e.stopPropagation();
            _e.preventDefault();

            if (isDragging === true) {
                _delegate.onDrag(_e);
            } else {
                const _x = _e.pageX - startPageX;
                const _y = _e.pageY - startPageY;
                const distance = Math.sqrt((_x * _x) + (_y * _y));
                if (distance > _activationDistance) {
                    isDragging = true;
                    dragStart(_e);
                    _delegate.onDrag(_e);
                }
            }
        }

        function dragEnd(_e) {
            if (isDragging === true) {
                _e.stopPropagation();
                _e.preventDefault();
                //console.log('dragEnd');
                if (_delegate.onDragEnd)
                    _delegate.onDragEnd(_e);
            } else {
                if (_delegate.onUndragged)
                    _delegate.onUndragged(_e);
            }

            isDragging = false;
            document.removeEventListener('mousemove', drag, true);
            document.removeEventListener('mouseup', dragEnd, true);

            window.DRAGGING_PROCESS = false;

        }

        document.addEventListener('mousemove', drag, true);
        document.addEventListener('mouseup', dragEnd, true);
    }

    // static initDragFunctions( _delegate, _startPageX, _startPageY, _activationDistance = 5 )
    // {
    //     window.DRAGGING_PROCESS = true;
    //     let isDragging = false;
    //
    //     function dragStart(_e){
    //         if(_delegate.onDragStart) _delegate.onDragStart(_e);
    //     }
    //
    //     function drag(_e)
    //     {
    //         _e.stopPropagation();
    //         _e.preventDefault();
    //
    //         if(isDragging===true)
    //         {
    //             _delegate.onDrag(_e);
    //         }
    //         else
    //         {
    //             const _x = _e.pageX - _startPageX;
    //             const _y = _e.pageY - _startPageY;
    //             const distance =  Math.sqrt((_x*_x)+(_y*_y));
    //             if( distance > _activationDistance )
    //             {
    //                 isDragging = true;
    //                 dragStart(_e);
    //                 _delegate.onDrag(_e);
    //             }
    //         }
    //     }
    //
    //     function dragEnd(_e)
    //     {
    //         if(isDragging===true)
    //         {
    //             _e.stopPropagation();
    //             _e.preventDefault();
    //             if(_delegate.onDragEnd) _delegate.onDragEnd(_e);
    //         }else
    //         {
    //             if(_delegate.onUndragged) _delegate.onUndragged(_e);
    //         }
    //
    //
    //         isDragging = false;
    //         document.removeEventListener('mousemove', drag,true);
    //         document.removeEventListener('mouseup', dragEnd, true);
    //
    //         window.DRAGGING_PROCESS = false;
    //
    //     }
    //
    //     document.addEventListener('mousemove', drag, true);
    //     document.addEventListener('mouseup', dragEnd,true);
    // }

    static connectEvent(_eventName, _elementList, _functionListener, _bindTarget, _capturingPhase) {

        if (!_elementList) {
            console.log('connectEvent', _elementList);
            console.warn('XOS.connectEvent - The _elementList parameter must be an Array of DOM elements or a NodeList');
            return;
        }

        if (!(_elementList instanceof Array) && !(_elementList instanceof NodeList))
            _elementList = [_elementList];

        if (_bindTarget)
            _functionListener = XOS.bindFunction(_bindTarget, _functionListener);

        _capturingPhase = _capturingPhase || false;

        let element;
        let max = _elementList.length;

        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            if (element.addEventListener) {
                if (window.MANAGE_TOUCH_EVENTS) {
                    switch (_eventName) {
                    case "mousedown":
                        _eventName = "touchstart";
                        break;
                    case "mousemove":
                        _eventName = "touchmove";
                        break;
                    case "mouseup":
                        _eventName = "touchend";
                        break;
                    }
                }
                element.addEventListener(_eventName, _functionListener, _capturingPhase);
            }
        }

        return _functionListener;
    }

    static disconnectEvent(_eventName, _elementList, _functionListener, _capturingPhase) {
        if (!(_elementList.length))
            _elementList = [_elementList];
        let element;
        let max = _elementList.length;

        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            if (element.removeEventListener) {
                if (window.MANAGE_TOUCH_EVENTS) {
                    switch (_eventName) {
                    case "mousedown":
                        _eventName = "touchstart";
                        break;
                    case "mousemove":
                        _eventName = "touchmove";
                        break;
                    case "mouseup":
                        _eventName = "touchend";
                        break;
                    }
                }
                console.log('removeEventListener', _eventName, _functionListener);
                element.removeEventListener(_eventName, _functionListener, _capturingPhase);
            }
        }
    }

    static connectDomEvents(elementList, _eventManager, _controlledElements, _attributeDataEventName) {
        let eventList,
        eventData,
        eventName,
        functionName,
        functionListener,
        element;
        let connectedElements = _controlledElements || {}; // dove vengono inseriti gli elementi per nome
        let undefinedEventListeners = [];
        _attributeDataEventName = _attributeDataEventName || 'data-event';
        for (let id = 0; id < elementList.length; id++) {
            element = elementList[id];
            if (!element.hasAttribute(_attributeDataEventName))
                continue;
            if (element.getAttribute(_attributeDataEventName) === '')
                continue;

            eventList = element.getAttribute(_attributeDataEventName).split(',');

            if (eventList.length > 0) {
                for (let idEvent = 0; idEvent < eventList.length; idEvent++) {
                    eventData = eventList[idEvent].split(':');
                    eventName = eventData[0].trim();
                    functionName = eventData[1].trim();
                    let eventManager = _eventManager;
                    if (element.dataset.eventManagerPath) {
                        eventManager = XOS.evalPath(element.dataset.eventManagerPath);
                        // console.log('element',element);
                        // console.log('eventManager',eventManager);
                    }

                    functionListener = eventManager[functionName];
                    if (functionListener) {
                        XOS.connectEvent(eventName, element, functionListener, eventManager);
                    } else {
                        console.log('undefined event listener:' + functionName + ' for element', element, element.getAttribute(_attributeDataEventName));
                        //undefinedEventListeners.push( '_.'+functionName+' = function(_e){\n};' );
                        undefinedEventListeners.push(functionName + '(_e){\n}');
                    }
                }

                if (element.hasAttribute('name')) {
                    connectedElements[element.getAttribute('name')] = element;
                } else if (element.hasAttribute('id')) {
                    connectedElements[element.getAttribute('id')] = element;
                }

            }
        }

        if (undefinedEventListeners.length > 0) {
            // console.warn("Undefined methods in element/class:" , _eventManager);
            // console.log(undefinedEventListeners.join('\n\n'));
        }

        return connectedElements;
    };

    static bindFunction(scope, fn) {
        if (!fn) {
            console.warn('XOS.bind - The parameter must be a function');
            return null;
        }
        return function () {
            return fn.apply(scope, arguments);
        };
    }

    static showElement(_element, _mode) {
        _element.applyClass('showed', _mode);
    }

    static hideElement(_element, _mode) {
        _element.removeClass('showed');
    }

    static hideElementChildren(_element) {
        _element.removeAppliedClassFromChildren('showed');
    }

    static selectElement(_element, _mode) {
        _element.applyClass('selected', _mode);
    }

    static deselectElement(_element) {
        _element.removeClass('selected');
    }

    static deselectElementChildren(_element) {
        _element.removeAppliedClassFromChildren('selected');
    }

    //get the specified property or nested property of an object
    static evalPath(path, obj, fallback = 'evalPath object not found') {
        obj = obj || window;
        //return path.split('.').reduce((res, key) => res[key] || fallback, obj);
        return path.split('.').reduce(
            function (res, key) {
            if (res[key] !== undefined || res[key] === "")
                return res[key];
            return fallback;
        }, obj);
    }

    static loadJsonData(_remoteDataUrl, _callback) {
        fetch(_remoteDataUrl).then((response) => response.json()).then((data) => {
            console.log('Success _remoteDataUrl:', data);
            _callback(data);
        }).catch((error) => {
            console.error('Error:', error);
        });
    }

    static bindData(_sourceObjectData, _fromNode, _bindFunctions, _dataBindSettingAttribute) {
        _dataBindSettingAttribute = _dataBindSettingAttribute || 'data-bind';

        const bindingTargetElementList = _fromNode.querySelectorAll(':scope *[' + _dataBindSettingAttribute + ']');
        const max = bindingTargetElementList.length;
        let elementTarget,
        sourceText,
        bindingPathList;
        let targetPropertyName,
        targetObjectPath,
        targetObject;

        for (let i = 0; i < max; i++) {
            elementTarget = bindingTargetElementList[i];
            sourceText = elementTarget.getAttribute(_dataBindSettingAttribute);
            if (sourceText.length > 0) {
                bindingPathList = sourceText.split(',');
                for (let ip = 0; ip < bindingPathList.length; ip++) {
                    const splittedPathKeys = bindingPathList[ip].split(':');
                    const pathOfTargetProperty = String(splittedPathKeys[0]);
                    const pathOfSourceValue = splittedPathKeys[1];

                    let splittedTargetPathProperty = pathOfTargetProperty.split('.');
                    if (splittedTargetPathProperty.length === 1) {
                        targetPropertyName = splittedTargetPathProperty[0];
                        targetObjectPath = 'this';
                        targetObject = elementTarget;
                    } else {
                        targetPropertyName = splittedTargetPathProperty.pop();
                        targetObjectPath = splittedTargetPathProperty.join('.');
                        targetObject = XOS.evalPath(targetObjectPath, elementTarget);
                    }

                    let value = XOS.evalPath(pathOfSourceValue, _sourceObjectData);

                    if (elementTarget.dataset.bindFunction && _bindFunctions[elementTarget.dataset.bindFunction])
                        value = _bindFunctions[elementTarget.dataset.bindFunction](value);

                    // if(targetObject.dataset.propertyType==='percent') value+='%';
                    // if(targetObject.dataset.propertyType==='px') value+='px';
                    // if(targetObject.dataset.propertyType==='angle') value+='deg';

                    targetObject[targetPropertyName] = value;
                }
            }

        }

    }

    static dispatchEvent(_eventName, _eventData, _fromNode) {
        _fromNode = _fromNode || document;
        const listenerList = _fromNode.querySelectorAll('[data-event-listener*="' + _eventName + '"]');
        console.log('listenerList', listenerList);
        let elementTarget,
        functionPath;

        for (let i = 0; i < listenerList.length; i++) {
            elementTarget = listenerList[i];
            functionPath = elementTarget.getAttribute('data-event-listener').split(_eventName + ':')[1].split(',')[0];
            console.log('functionPath', functionPath);
            XOS.evalPath(functionPath, elementTarget).apply(elementTarget, _eventData);
        }
    }

    static getFilteredElementListByNodeName(_elementList, _nodeNames) {
        const resultList = [];
        const validNodeNames = _nodeNames.split(',');
        const max = _elementList.length;
        for (let i = 0; i < max; i++) {
            if (validNodeNames.indexOf(_elementList[i].nodeName) > -1)
                resultList.push(_elementList[i]);
        }
        return resultList;
    }

    static removeElementList(_elementList) {
        for (let i = 0; i < _elementList.length; i++)
            _elementList[i].parentNode.removeChild(_elementList[i]);
    };

    static includeCSS(_url, _onLoadCallback, _onErrorCallback) {
        // se è già incluso ritorna
        if (document.head.querySelector('link[href="' + _url + '"]')) {
            if (_onLoadCallback)
                _onLoadCallback();
            return;
        }

        var head = document.getElementsByTagName('head')[0];
        var css = document.createElement("link");
        css.setAttribute("rel", "stylesheet");
        css.setAttribute("type", "text/css");
        css.setAttribute("href", _url);
        head.appendChild(css);

        if (typeof css.addEventListener !== 'undefined') {
            if (_onLoadCallback)
                css.addEventListener('load', _onLoadCallback, false);
            if (_onErrorCallback)
                css.addEventListener('error', _onErrorCallback, false);
        }

        return css;
    }

    static includeJS(_url, _onLoadScriptCallback, _checkBeforeLoad) {
        let script;

        if (_checkBeforeLoad) {
            script = document.querySelector('[src=' + _url + ']');
            if (script)
                return;
        }

        const head = document.getElementsByTagName('head')[0];
        script = document.createElement('script');
        script.src = _url;
        script.type = "text/javascript";

        if (_onLoadScriptCallback) {
            script.onload = function (_e) {
                script.loaded = true;
                _onLoadScriptCallback(script);
            };
        }

        head.appendChild(script);
        return script;
    }

    static includeTemplates(_document, _onCompleteCallback) {

        function loadTemplate(_includeTag) {
            function onLoad(_e) {
                const fragment = _document.createDocumentFragment();
                const loadFragmentBody = _e.target.responseXML.querySelector('body');
                while (loadFragmentBody.children.length)
                    fragment.appendChild(loadFragmentBody.children[0]);
                _includeTag.parentElement.replaceChild(fragment, _includeTag);
                _document.loadedIncludeHtmlNum++;
                if (_document.loadedIncludeHtmlNum === _document.maxIncludeHtmlNum)
                    XOS.includeTemplates(_document, _onCompleteCallback);
            }
            const xhr = XOS.sendAndLoad(_includeTag.getAttribute('src'), 'GET', null, onLoad);
            xhr.responseType = "document";
            _includeTag.removeAttribute('src');
        }

        const includeHtmlList = _document.querySelectorAll('xos-include[src]');

        //if(includeHtmlList.length===0) _onCompleteCallback( _document.documentElement.innerHTML );
        if (includeHtmlList.length === 0)
            _onCompleteCallback(_document);

        _document.maxIncludeHtmlNum = 0;
        _document.loadedIncludeHtmlNum = 0;

        for (let i = 0; i < includeHtmlList.length; i++) {
            _document.maxIncludeHtmlNum++;
            loadTemplate(includeHtmlList[i]);
        }
    }

    // static compileJS(  _document , _onCompleteCallback )
    // {
    //     _document.maxScriptNum = 0;
    //     _document.loadedScriptNum = 0;
    //     const scriptList = _document.querySelectorAll('script:not([no-compile])');
    //
    //     function joinScriptText ()
    //     {
    //         let allScriptText='';
    //         for( let i=0; i<scriptList.length; i++ ) allScriptText += '\n\n'+scriptList[i].scriptText;
    //         _onCompleteCallback( allScriptText );
    //     }
    //
    //     function loadScriptText( _scriptTag )
    //     {
    //         function onLoad(_e)
    //         {
    //             _scriptTag.scriptText = _e.target.responseText;
    //             _document.loadedScriptNum++;
    //             if( _document.loadedScriptNum === _document.maxScriptNum )
    //             {
    //                 joinScriptText();
    //             }
    //         }
    //         XOS.sendAndLoad( _scriptTag.getAttribute('src') , 'GET' , null , onLoad );
    //     }
    //
    //     for(let i=0; i< scriptList.length; i++)
    //     {
    //         _document.maxScriptNum++;
    //         loadScriptText(  scriptList[i] );
    //         scriptList[i].remove();
    //     }
    // }

    static compileJS(_document, _onCompleteCallback) {
        _document.maxScriptNum = 0;
        _document.loadedScriptNum = 0;
        const scriptList = _document.querySelectorAll('script:not([no-compile])');

        function joinScriptText() {
            let allScriptText = '';
            for (let i = 0; i < scriptList.length; i++)
                allScriptText += '\n\n' + scriptList[i].scriptText;
            _onCompleteCallback(allScriptText);
        }

        function loadScriptText(_scriptTag) {
            function onLoad(_e) {
                _scriptTag.scriptText = _e.target.responseText;
                _document.loadedScriptNum++;
                if (_document.loadedScriptNum === _document.maxScriptNum) {
                    joinScriptText();
                }
            }
            XOS.sendAndLoad(_scriptTag.getAttribute('src'), 'GET', null, onLoad);
        }

        for (let i = 0; i < scriptList.length; i++) {
            _document.maxScriptNum++;
            loadScriptText(scriptList[i]);
            scriptList[i].parentElement.removeChild(scriptList[i]);
        }
    }

    static compileDocument(_documentUrl, _compileScript = true, _compileHTML = true, _onCompileJS, _onCompileHTML) {
        _documentUrl = _documentUrl || window.location;
        function onLoad(_e) {
            const loadedDocument = _e.target.responseXML;
            if (_compileScript)
                XOS.compileJS(loadedDocument, _onCompileJS);
            if (_compileHTML)
                XOS.includeTemplates(loadedDocument, _onCompileHTML);
        }
        const xhr = XOS.sendAndLoad(_documentUrl, 'GET', null, onLoad);
        xhr.responseType = "document";
    }

    static stripHtml(html) {
        let tmp = document.createElement("DIV");
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || "";
    }

    static sendAndLoadJson(_url, _callback, _jsonToSend = {}) {
        fetch(_url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(_jsonToSend)
        }).then((response) => response.json()).then((data) => {
            _callback(data);
        }).catch((error) => {
            console.error('Error:', error);
        });
    }

    static sendAndLoad(_serviceUrl, _sendMethod, _dataToSend, _onLoadListener, _onErrorListener, _onLoadProgressListener, _onUploadProgressListener, _onAbortListener, _onBeforeSendCallback) {
        let xhr = new XMLHttpRequest();

        if (_onLoadListener)
            xhr.onload = _onLoadListener;
        if (_onErrorListener)
            xhr.onerror = _onErrorListener;
        if (_onLoadProgressListener)
            xhr.onprogress = _onLoadProgressListener;
        if (_onUploadProgressListener)
            xhr.upload.onprogress = _onUploadProgressListener;
        if (_onAbortListener)
            xhr.onabort = _onAbortListener;

        _sendMethod = _sendMethod || 'GET';

        let data = '';

        if (_dataToSend) {
            if (((typeof(_dataToSend) === 'string') || (_dataToSend instanceof String)) || (_dataToSend instanceof FormData) || (_dataToSend instanceof Blob)) {
                data = _dataToSend;
            } else if (_dataToSend instanceof HTMLFormElement) {
                data = new FormData(_dataToSend);
            } else {
                data = new FormData();
                for (let name in _dataToSend)
                    data.append(name, _dataToSend[name]);
            }
        }

        xhr.open(_sendMethod, _serviceUrl, true);

        if (_onBeforeSendCallback)
            _onBeforeSendCallback(xhr);

        xhr.send(data);

        return xhr;
    }

    static extractUrlVars(_url) {
        _url = _url || window.location.href;
        const vars = {};
        const locationUrl = decodeURIComponent(_url);
        const parts = locationUrl.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
            vars[key] = value;
        });
        return vars;
    }
}

Node.prototype.applyClass = function (_className, _mode = 'unique') {
    if (_mode === 'unique') {
        this.parentElement.removeAppliedClassFromChildren(_className);
        this.classList.add(_className);
        this.onApplyClass(_className);
    } else if (_mode === 'toggle') {
        this.classList.toggle(_className);
        if (this.classList.contains(_className))
            this.onApplyClass();
    } else if (_mode === 'add') {
        this.classList.add(_className);
        this.onApplyClass(_className);
    }
};

Node.prototype.onApplyClass = function (_className) {
    //console.log('onApplyClass' , _className );
};

Node.prototype.onRemoveClass = function (_className) {
    //console.log('onRemoveClass' , _className );
};

Node.prototype.removeClass = function (_className) {
    this.classList.remove(_className);
    this.onRemoveClass(_className);
};

Node.prototype.removeAppliedClassFromChildren = function (_className) {
    const elementList = this.querySelectorAll(':scope > .' + _className);
    //const elementList = this.querySelectorAll(':scope  .'+_className );
    const max = elementList.length;
    for (let i = 0; i < max; i++) {
        elementList[i].classList.remove(_className);
        elementList[i].onRemoveClass(_className);
    }
    // for(let i= 0, max=this.children.length; i<max; i++)
    // {
    //     if(this.children[i].classList.contains(_className))
    //     {
    //         this.children[i].classList.remove(_className);
    //         this.children[i].onRemoveClass(_className );
    //     }
    // }
};

Node.prototype.remove = function () {
    return this.parentNode.removeChild(this);
};

Node.prototype.removeChildren = function () {
    let myNode = this;
    while (myNode.firstChild) {
        myNode.removeChild(myNode.firstChild);
    }
};

Node.prototype.cloneChildrenTo = function (_elementTarget) {
    _elementTarget.removeChildren();
    const max = this.children.length;
    for (let id = 0; id < max; id++)
        _elementTarget.appendChild(this.children[id].cloneNode(true));
};

Node.prototype.moveChildrenTo = function (_elementTarget) {
    while (this.firstChild) {
        _elementTarget.appendChild(this.firstChild);
    }
};

Node.prototype.bringToFront = function () {
    this.parentNode.appendChild(this);
};

Node.prototype.sendToBack = function () {
    this.parentNode.insertBefore(this, this.parentNode.childNodes[0]);
};

Node.prototype.bringUp = function () {
    if (!this.nextElementSibling)
        return;
    if (this.nextElementSibling.nextElementSibling) {
        this.parentNode.insertBefore(this, this.nextElementSibling.nextElementSibling);
    } else {
        this.parentNode.appendChild(this);
    }
};

Node.prototype.sendDown = function () {
    if (!this.previousElementSibling)
        return;
    this.parentNode.insertBefore(this, this.previousElementSibling);
};

String.prototype.containsWords = function (_wordArray, _operator) {
    _operator = _operator || 'AND';

    var i,
    len = _wordArray.length,
    stringValues = this.split(/\s+/);

    if (_operator === 'AND') {
        for (i = 0; i < len; i++) {
            if (stringValues.indexOf(_wordArray[i]) === -1)
                return false;
        }
        return true;
    } else if (_operator === 'OR') {
        for (i = 0; i < len; i++) {
            if (stringValues.indexOf(_wordArray[i]) === -1)
                return true;
        }
        return false;
    }
};

String.prototype.splice = function (idx, rem, str) {
    str = str || "";
    return this.slice(0, idx) + str + this.slice(idx + Math.abs(rem));
};

/* ARRAY UTILS */

Array.prototype.clone = function () {
    return this.slice(0);
};

Array.prototype.add = Array.prototype.push;

Array.prototype.addAt = function (_item, _id) {
    this.splice(_id, 0, _item);
};

Array.prototype.replaceAt = function (_item, _id) {
    const removedItem = this[_id];
    this.splice(_id, 1, _item);
    return removedItem;
};

Array.prototype.remove = function (_item) {
    const index = this.indexOf(_item);
    if (index > -1) {
        this.splice(index, 1);
        return _item;
    }

    return null;
};

Array.prototype.removeAt = function (_id) {
    const removedItem = this[_id];
    this.splice(_id, 1);
    return removedItem;
};

Array.prototype.sortOn = function (key) {
    this.sort(function (a, b) {
        if (a[key] < b[key]) {
            return -1;
        } else if (a[key] > b[key]) {
            return 1;
        }
        return 0;
    });
};

Array.prototype.sortByStringOn = function (key) {
    this.sort(function (a, b) {
        return a[key].toLowerCase().localeCompare(b[key].toLowerCase());
    });
};

Math.evalExpression = function (_expression) {
    _expression = _expression.replace(',', '.');
    return parseFloat(_expression);
};

class DocumentsManager_cmp extends HTMLElement {

    constructor() {
        super();
        // activeApplication.documentsManager = this;
    }

    setActiveDocument(_document) {
        if (activeApplication.activeDocument && activeApplication.activeDocument.activePage) {
            activeApplication.activeDocument.exitFrom_AllIsolateLayerEditing();
        }

        activeApplication.activeDocument = _document;

        XOS.showElement(activeApplication.activeDocument);
        if (activeApplication.activeDocument.activePage) {
            console.log('SI')
            activeApplication.editingView.update();
            //activeApplication.editingView.redrawRulersAndGrid();
            activeApplication.workspace.snapInteraction2D.reset();
            WINDOWS['layersWindow'].update();
            activeApplication.workspace.update();
            activeApplication.workspace.updatePageBackground();
        }

        //this.propertyPanels['page-list-inspector'].drawPageList();
    }

    createDocument(_documentName = 'Untitled.svg', _fileHandle) {
        const newDocument = document.createElement('document-2d');
        newDocument.fileHandle = _fileHandle || {
            name: _documentName,
            isNew: true
        };
        newDocument.setAttribute('id', XOS.createUniqueIDI('document'));
        this.appendChild(newDocument);
        return newDocument;
    }

    newDocument() {
        //if(this.activeDocument && this.activeDocument.activePage)this.activeDocument.activePage.exitFrom_AllIsolateLayerEditing();
        const newDocument = this.createDocument();
        this.setActiveDocument(newDocument);

        const svgDocAsString = localStorage.getItem('janvas-default-document-6.4');
        if (svgDocAsString) {
            //console.log('svgDocAsString',svgDocAsString);
            const parser = new DOMParser();
            const svgDocument = parser.parseFromString(svgDocAsString, "image/svg+xml").documentElement;
            this.unserializeDocument(svgDocument);
        } else {
            const newPage = newDocument.createNewPage();
            newDocument.setActivePage(newPage);
        }

        activeApplication.documentTabBar.update();
        activeApplication.workspace.update();

        return newDocument;
    }

    closeDocument() {
        const documentToClose = activeApplication.activeDocument;
        const self = this;
        if (documentToClose.isChanged) {
            const confirmDialog = DIALOGS['confirmDialog'];

            function onConfirm_Ok() {
                self.removeDocument(documentToClose);
                this.close();
            }

            confirmDialog.open(localString('Exit without Save ?'), localString('Do you want close the document without save changes?'), onConfirm_Ok, null, '../XOS/icons/sys-dialog-icons.svg#alert-icon');
        } else {
            this.removeDocument(documentToClose);
        }
    }

    removeDocument(_documentToRemove) {
        const documentToActivate = _documentToRemove.nextElementSibling || _documentToRemove.previousElementSibling;
        _documentToRemove.remove();
        if (documentToActivate) {
            this.setActiveDocument(documentToActivate);
            activeApplication.documentTabBar.update();
        } else {
            this.newDocument()
        }
    }

    async chooseDocument(_options) {
        const self = this;
        if ('showOpenFilePicker' in window) {
            const fileHandle = await NativeFileSystemAPIUtils.chooseFile([{
                            multiple: false,
                            description: 'Janvas SVG',
                            accept: {
                                'image/svg+xml': ['.svg']
                            }
                        }
                    ]);
            await self.openDocument(fileHandle[0], _options);
        } else {
            LOCAL_FILE_SYSTEM.chooseFile("image/svg+xml", function (_e) {
                self.openDocument_NoNativeFileSystemApi(_e.target.files[0], _options);
            });
        }
    }

    async openDocument(_fileHandle, _options) {
        console.log('openDocument', _fileHandle);

        _options = _options || {};

        if (!_options.import) {
            const openedDocument = await this.getDocumentByFileHandle(_fileHandle);
            if (openedDocument) {
                this.setActiveDocument(openedDocument);
                activeApplication.documentTabBar.update();
                return;
            }
            const newDocument = this.createDocument(_fileHandle.name || _options.name || localString('Untitled'), _fileHandle || null);
            this.setActiveDocument(newDocument);
            activeApplication.documentTabBar.update();
        }

        const fileExtension = NativeFileSystemAPIUtils.pathInfo(_fileHandle.name).fileExtension;
        if (fileExtension !== 'svg')
            return;

        const file = await _fileHandle.getFile();
        const contents = await file.text();
        const parser = new DOMParser();
        const xmlDocument = parser.parseFromString(contents, "image/svg+xml").documentElement;
        this.unserializeDocument(xmlDocument, _options);
    }

	//DA BUTTARE
    openDocumentDirect(_fileHandle, _options) {
        console.log('openDocumentDirect', _fileHandle);

        //_options = _options || {};

		var self = this;

        //const contents = await file.text();
		//fetch('/PROVACAD.svg').then(response => response.text())
		const queryString = window.location.search;
		const urlParams = new URLSearchParams(queryString);
		const filename = urlParams.get('namefile');
		fetch(filename).then(response => response.text())
		.then(
			(contents) => {
			    const parser = new DOMParser();
				const xmlDocument = parser.parseFromString(contents, "image/svg+xml").documentElement;
				//self.unserializeDocument(xmlDocument, _options);
				activeApplication.documentsManager.unserializeDocument(xmlDocument, {
						import: true,
						importPagesBehaviourAction: 'end',  //options: start, end, afterActivePage
						centerInView: true,
						//defsBehaviourAction: 'defsMantainTarget',
				});
			}
		)
    }

    openDocument_NoNativeFileSystemApi(_fileHandle, _options) {
        const self = this;
        LOCAL_FILE_SYSTEM.readXMLFile(_fileHandle, async function (xmlDocument) {

            _options = _options || {};

            if (!_options.import) {
                const openedDocument = await self.getDocumentByFileHandle(_fileHandle);
                if (openedDocument) {
                    console.log('openedDocument', openedDocument);
                    console.log('xmlDocument', xmlDocument);
                    self.setActiveDocument(openedDocument);
                    activeApplication.documentTabBar.update();
                    return;
                }
                const newDocument = self.createDocument(_fileHandle.name || _options.name || localString('Untitled'), _fileHandle || null);
                self.setActiveDocument(newDocument);
                activeApplication.documentTabBar.update();
            }

            self.unserializeDocument(xmlDocument, _options);
        });
    }

    async saveDocument() {
        const documentToSave = activeApplication.activeDocument;

        if (documentToSave.fileHandle.isNew) {
            await this.saveDocumentAs();
            return;
        }

        if ('showOpenFilePicker' in window) {
            await NativeFileSystemAPIUtils.writeFile(documentToSave.fileHandle, this.serializeDocument());
        } else {
            LOCAL_FILE_SYSTEM.saveLocalFile(documentToSave.fileHandle.name, this.serializeDocument(), 'image/svg+xml');
        }
        this.onDocumentSaved();
    }

    async saveDocumentAs() {
        const documentToSave = activeApplication.activeDocument;

        if ('showOpenFilePicker' in window) {
            const newFileHandle = await NativeFileSystemAPIUtils.createNewFile(documentToSave.fileHandle.name, [{
                            description: 'Janvas SVG',
                            accept: {
                                'image/svg+xml': ['.svg']
                            }
                        }
                    ]);
            await NativeFileSystemAPIUtils.writeFile(newFileHandle, this.serializeDocument());
            documentToSave.fileHandle = newFileHandle;
        } else {
            LOCAL_FILE_SYSTEM.saveLocalFile(documentToSave.fileHandle.name, this.serializeDocument(), 'image/svg+xml');
        }

        this.onDocumentSaved();
    }

    saveDocumentAsDefault() {
        const confirmDialog = DIALOGS['confirmDialog'];
        const self = this;
        function onConfirm_Ok() {
            localStorage.setItem('janvas-default-document-6.4', self.serializeDocument());
            this.close();
        }

        confirmDialog.open(localString('Save document as default'), localString('Do you want to use the current document as default document?'), onConfirm_Ok, null, '../XOS/icons/sys-dialog-icons.svg#alert-icon');
    }

    removeDefaultDocument() {
        const alertDialog = DIALOGS['alertDialog'];
        const confirmDialog = DIALOGS['confirmDialog'];

        if (!localStorage.getItem('janvas-default-document-6.4')) {
            alertDialog.open(localString('Default document is not set'), localString('The local storage do not contains a default document.'));
            return;
        }

        function onConfirm_Ok() {
            localStorage.removeItem('janvas-default-document-6.4');
            this.close();
        }
        confirmDialog.open(localString('Remove default document'), localString('Do you want to remove the current default document?'), onConfirm_Ok, null, '../XOS/icons/sys-dialog-icons.svg#alert-icon');

    }

    onDocumentSaved() {
        const savedDocument = activeApplication.activeDocument;
        savedDocument.isChanged = false;
        activeApplication.documentTabBar.update();
    }

    async getDocumentByFileHandle(_fileHandle) {
        const documentList = this.children;
        let openedDocument;
        for (let i = 0; i < documentList.length; i++) {
            openedDocument = documentList[i];
            if ((_fileHandle && openedDocument.fileHandle && _fileHandle.isSameEntry && openedDocument.fileHandle.isSameEntry)) {
                if (await _fileHandle.isSameEntry(openedDocument.fileHandle) === true)
                    return openedDocument;
            } // nativeFileSystem
            else if (_fileHandle.fullPath && openedDocument.fileHandle && (_fileHandle.fullPath === openedDocument.fileHandle.fullPath))
                return openedDocument; // google drive
        }

        return null;
    }

    // se options non contiene import=true allora verrà sostituito l'intero contenuto del documento
    unserializeDocument(xmlDocument, _options, _callback) {
        //this.classList.add('locked-state');
        const unserializer = new DocumentUnserializer();
        unserializer.parse(xmlDocument, _options || {}, _callback);
        //this.classList.remove('locked-state');
    }

    serializeDocument(svgDocument) {
        return new XMLSerializer().serializeToString(new DocumentSerializer().serialize(svgDocument || activeApplication.activeDocument));
    }

    // remote document


    async openRemoteDocument(_url, _fileHandle, _options, _accessToken) {
        console.log('openRemoteDocument', _fileHandle);

        _options = _options || {};

        if (!_options.import) {
            const openedDocument = await this.getDocumentByFileHandle(_fileHandle);
            if (openedDocument) {
                this.setActiveDocument(openedDocument);
                activeApplication.documentTabBar.update();
                return;
            }
            const newDocument = this.createDocument(_fileHandle.name || _options.name || localString('Untitled'), _fileHandle || null);
            this.setActiveDocument(newDocument);
            activeApplication.documentTabBar.update();
        }

        const self = this;
        function onLoadingError(_e) {
            DIALOGS['alert-dialog'].open(window.localString('Error'), window.localString("An error occured during loading file."));
        }

        const progressWindow = WINDOWS['progressWindow'];
        progressWindow.open(true).setProgressBarValue(1).startVirtualProgress(100000);

        function onLoadSVG(_e) {
            progressWindow.endVirtualProgress();
            if (!_e.target.responseXML)
                return;
            const xmlDocument = _e.target.responseXML.querySelector('svg');
            if (!xmlDocument)
                return;
            self.unserializeDocument(xmlDocument, _options);
        }

        const xhr = new XMLHttpRequest();
        xhr.open("GET", _url, true);
        if (_accessToken)
            xhr.setRequestHeader('Authorization', 'Bearer ' + _accessToken);
        xhr.onload = onLoadSVG;
        xhr.onerror = onLoadingError;
        xhr.send();

    }

    saveRemoteDocument(_url, _method, _contentToSave, _mimeType, _accessToken, _successCallback) {
        const progressWindow = WINDOWS['progressWindow'];
        progressWindow.setProgressBarValue(1);
        progressWindow.open(true);

        function onSaveComplete(_e) {
            progressWindow.close();
            if (_successCallback)
                _successCallback();
        }

        function onSaveProgress(_e) {
            progressWindow.setProgressValues(_e.total, _e.loaded);
        }

        function onSaveError(_e) {
            DIALOGS['alert-dialog'].open(localString('Error'), localString("An error occured during saving file."));
        }

        const xhr = new XMLHttpRequest();
        xhr.responseType = 'json';
        xhr.onreadystatechange = function () {
            if (xhr.readyState !== XMLHttpRequest.DONE) {
                return;
            }

            if ((!xhr.response) || xhr.response.error) {
                onSaveError(xhr);
                return;
            }

            onSaveComplete(xhr.response);
        };

        xhr.open(_method, _url);
        if (_accessToken)
            xhr.setRequestHeader('Authorization', 'Bearer ' + _accessToken);
        xhr.setRequestHeader('Content-Type', _mimeType);
        xhr.upload.addEventListener("progress", function (e) {
            onSaveProgress(e);
        }, false);
        xhr.send(_contentToSave);
    }

    // saveRemoteDocumentAs()
    // {
    //
    // }


}

customElements.define("documents-manager", DocumentsManager_cmp);

class DocumentTabBar_cmp extends HTMLElement {

    constructor() {
        super();
        this.itemTemplate = this.firstElementChild;
        this.itemTemplate.remove();
        // activeApplication.documentTabBar = this;
        XOS.connectEvent('click', this, this.onClickOnTabItem, this)
    }

    update() {
        this.removeChildren();
        const documentList = activeApplication.documentsManager.children;

        for (let i = 0; i < documentList.length; i++) {
            const doc = documentList[i];
            const item = this.itemTemplate.cloneNode(true);
            item.documentRef = doc;
            doc.tabItemRef = item;
            item.querySelector('.label').textContent = doc.fileHandle.name;
            if (doc.isChanged)
                item.classList.add('changed');
            if (doc.classList.contains('showed'))
                item.classList.add('selected');
            this.appendChild(item);
        }

    }

    onClickOnTabItem(_e) {
        //console.log('onClickOnTabItem',_e.target);
        const item = _e.target.parentElement;
        const doc = item.documentRef;
        XOS.selectElement(item);
        activeApplication.documentsManager.setActiveDocument(doc);

        if (_e.target.classList.contains('close-button')) {
            activeApplication.documentsManager.closeDocument();
            // if(doc.isChanged){
            //     console.log('il document è cambiato chiedere se lo si vuole salvare');
            //     const confirmDialog = DIALOGS['confirmDialog'];
            //
            //     function onConfirm_Ok()
            //     {
            //         activeApplication.documentsManager.removeDocument();
            //         this.close();
            //     }
            //
            //     confirmDialog.open(localString('Exit without Save ?'),localString('Do you want close the document without save changes?'), onConfirm_Ok ,null,'../XOS/icons/sys-dialog-icons.svg#alert-icon');
            //     return;
            // }
            //
            // activeApplication.documentsManager.removeDocument();
            // return;
        }

        //activeApplication.documentsManager.setActiveDocument(doc);
    }

}

customElements.define("document-tab-bar", DocumentTabBar_cmp);

const LANGUAGE = 'IT';
const WEBSITE_ROOT = '';
var ParentEventField = '';
var ParentEventPanel = '';
var ParentProcessIdField = '';

function displayMessage (ev) {
	var message;
	const msg = JSON.parse(ev.data);
	//	" from " + ev.origin;

	//this.setActiveTool('selection-tool');
	//this.documentsManager.newDocument();
	//this.querySelector('filling-inspector').onDomReady();

	//this.loadPlugins();
	
	//load file
	var filename =  msg.src;
	if ((filename != null) && (filename != '')){
		fetch(filename)
			.then(response => response.text())
			.then(
				(contents) => {
					const parser = new DOMParser();
					const xmlDocument = parser.parseFromString(contents, "image/svg+xml").documentElement;
					//self.unserializeDocument(xmlDocument, _options);
					activeApplication.documentsManager.unserializeDocument(xmlDocument, {
						importPagesBehaviourAction: 'start',  //options: start, end, afterActivePage
						import: true,
						centerInView: true,
						//defsBehaviourAction: 'defsMantainTarget'
					});
				}
			)
	}

	//event in field
	var fieldPoint =  msg.fieldPointSVG;
	if ((fieldPoint != null) && (fieldPoint != '')){
		ParentEventField = fieldPoint;
	}
    
	//event in panel
	var panelPoint =  msg.panelPointSVG;
	if ((panelPoint != null) && (panelPoint != '')){
		ParentEventPanel = panelPoint;
	}
	
	//event in process
	var processPoint =  msg.processPointSVG;
	if ((processPoint != null) && (processPoint != '')){
		ParentProcessIdField = processPoint;
	}
}
if (window.addEventListener) {
	// For standards-compliant web browsers
	window.addEventListener("message", displayMessage, false);
}
else {
	window.attachEvent("onmessage", displayMessage);
}

window.localString = function (_str) {
    return _str;
}

class Janvas_app extends HTMLElement {

    constructor() {
        super();
        window.activeApplication = this;
        XOS.connectDomEvents(this.querySelectorAll(':scope>.header>.button-bar>[data-event],:scope>.footer>.button-bar>[data-event]'), this);
        this.initRuntimeSettings();
        this.showPressedKeys = false;
        this.editingView = this.querySelector('editing-view');
        this.toolbar = this.querySelector('main-tool-bar');
        this.workspace = this.querySelector('work-space');
        this.documentTabBar = this.querySelector('document-tab-bar');
        this.documentsManager = this.querySelector('documents-manager');
        //this.pluginsManager = new PluginsManager();
        this.footer = this.querySelector('.footer');
        this.activeDocument = null;
        window.addEventListener('resize', XOS.bindFunction(this, this.onResize));
        window.addEventListener("message", XOS.bindFunction(this, this.onMessage), false);
        // window.addEventListener('beforeprint',  XOS.bindFunction( this, this.onBeforePrint ));
        // window.addEventListener('unload',  XOS.bindFunction( this, this.onQuit ));
        window.onbeforeunload = XOS.bindFunction(this, this.onBeforeQuit);
        const self = this;
        window.addEventListener('DOMContentLoaded', (event) => {
            XOS.includeTemplates(document, function () {
                self.onDomReady();
                setTimeout(function () {
                    XOS.hideElement(document.querySelector('#ABOUT_DIALOG'));
                }, 2000);
            });
        });
    }

    onDomReady() {
        this.workspace.onDomReady();
        this.setActiveTool('selection-tool');
        this.documentsManager.newDocument();
        //this.querySelector('filling-inspector').onDomReady();
        //this.loadPlugins();
        //this.pluginsManager.createPlugins();
    }
	
    initRuntimeSettings() {
        document.documentElement.setAttribute('data-platform', navigator.platform);
        document.documentElement.setAttribute('data-nfs-api', ('showOpenFilePicker' in window));
        document.documentElement.className += ((('ontouchstart' in window) || ('onmsgesturechange' in window)) ? ' touch' : '');
    }

    // onBeforePrint()
    // {
    //     COMMANDS.printDocument.onExecute();
    // }

    onBeforeQuit(_e) {
        if (this.activeDocument.isChanged) {
            return localString('Are you sure to Exit without saving changes?');
        } else {
            return localString('Are you sure to Exit from the application?');
        }
    }

    // onQuit( _e )
    // {
    // }
	
    loadPlugins() {
        const self = this;
        XOS.sendAndLoadJson('/svgeditor/plugins/plugins.json', function (_jsonData) {

            if (_jsonData.type === 'object-plugins') {
                //const win = self.createWindow({title:_jsonData.title, templateName:'TOOLS-WINDOW'} );
                const win = self.createWindow(_jsonData);
                const items = _jsonData.items;
                for (let i = 0; i < items.length; i++) {
                    const itemData = items[i];
                    win.addToolObject({
                        name: itemData.toolName,
                        objectId: itemData.objectId,
                        iconUrl: itemData.toolIconUrl
                    });
                    XOS.includeJS(itemData.url);
                }
            }
        });
    }

    checkLicense(_targetAction) {
		_targetAction();
		/*
        XOS.sendAndLoad(WEBSITE_ROOT + '/en/services/app-licence-check-service.php', null, null,
            function (_xhr) {
            if (_xhr.target.responseText === 'OK') {
                _targetAction();
            } else {
                document.querySelector('login-dialog').show();
            }
        });
		*/
    }

    onResize(_e) {
        //console.log('Janvas_app onResize');
        this.editingView.onResize();
        this.workspace.onResize();
        this.activeDocument.onResize();
    }

    executeCommand(_e) {
        //console.log('executeCommand');
        const item = _e.target.closest('[data-cmd]');
        const cmd = COMMANDS[item.dataset.cmd];
        if (cmd)
            cmd.execute({
                target: item
            });
    }

    setActiveTool(_toolName) {
        if (TOOLS.activeTool) {
            TOOLS.activeTool.onDeactivate();
            //TOOLS.lastActiveTool =  TOOLS.activeTool;
        }
        const tool = TOOLS[_toolName];
        if (!tool) {
            //console.log('tool: '+_toolName+' - activation failed');
            return;
        }

        TOOLS.activeTool = tool;
        this.setAttribute('active-tool', _toolName);

        tool.onActivate();

        const activeToolButton = document.querySelector('.active-tool');
        activeToolButton.removeClass('active-tool');

        const toolButton = document.querySelector('[data-tool-name="' + _toolName + '"]');
        const toolPanelContainer = toolButton.closest('.tools-panel');

        if (toolPanelContainer) {
            const buttonActivatorPanel = document.querySelector('[data-panel-target="' + toolPanelContainer.id + '"]');
            buttonActivatorPanel.setAttribute('data-tool-name', toolButton.getAttribute('data-tool-name'));
            const iconLink = toolButton.querySelector('svg>use').getAttribute('xlink:href');
            buttonActivatorPanel.querySelector('svg>use').setAttribute('xlink:href', iconLink);
            buttonActivatorPanel.applyClass('active-tool');
        } else {
            toolButton.applyClass('active-tool');
        }

        return tool;
    }

    showTip(_message) {
        this.footer.innerHTML = _message;
    }

    createWindow(_properties = {}) {
        const templateName = _properties.templateName || 'TOOLS-WINDOW';
        const newWindow = document.getElementById(templateName).content.querySelector('.window').cloneNode(true);
        newWindow.setAttribute('id', _properties.id || XOS.createUniqueIDI());
        if (_properties.windowWidth)
            newWindow.style.width = _properties.windowWidth + 'px';
        if (_properties.windowMaxWidth)
            newWindow.style.maxWidth = _properties.windowMaxWidth + 'px';
        if (_properties.windowMinWidth)
            newWindow.style.minWidth = _properties.windowMinWidth + 'px';
        document.querySelector('#FLOATING_WINDOWS').appendChild(newWindow);
        newWindow.setTitle(_properties.title || 'win');
        return newWindow;
    }

    onMessage(_e) {
        //console.log('onMessage' , _e );
        //console.log('document.getElementById(_e.data.serviceId )' , document.getElementById( _e.data.serviceId ) );
        const service = document.getElementById(_e.data.serviceId);
        if (service)
            service.onReceiveMessageFromIframe(_e.data);
    }

    // onMessage( _e )
    // {
    //     console.log('onMessage' , _e );
    //     //console.log('onMessage _e.source' , _e.source );
    //     const toolPlugin = PLUGINS[ _e.data.id ];
    //     toolPlugin.onWorkerEvent( _e.data );
    // }
}

customElements.define("janvas-app", Janvas_app);

class LocalFileSystem{
    constructor() {
        this.objectUrlList = {};
        this.inputFile = document.createElement('input');
        //document.body.appendChild(this.inputFile);
        this.inputFile.type = 'file';
        this.inputFile.callback = null;
        this.inputFile.addEventListener("change", function (_e) {
            this.callback(_e);
            this.value = null;
        }, false);
    }

    chooseFile(_acceptTypes, _onOpenCallback) {
        this.inputFile.setAttribute('accept', _acceptTypes);
        this.inputFile.click();
        this.inputFile.callback = _onOpenCallback;
    };

    fileNameAndExtensionByMimeType(_fileName, _mimeType) {
        const fileExtensionList = {
            'image/png': 'png',
            'image/jpeg': 'jpg',
            'image/svg+xml': 'svg',
            'text/html': 'html',
            'text/javascript': 'js',
            'text/csv;charset=utf-8;': 'csv'
        };
        const splittedName = _fileName.split('.');
        if (splittedName.length > 1)
            splittedName.pop();
        splittedName.push(fileExtensionList[_mimeType]);
        return splittedName.join('.');
    };

    saveLocalFile(_fileName, _data, _mimeType) {
        _mimeType = _mimeType || 'text/plain';

        const _anchorElement = document.createElement('a'); // per firefox deve essere aggiunto al dom

        document.body.appendChild(_anchorElement);

        const fileExtensionList = {
            'image/png': 'png',
            'image/jpeg': 'jpg',
            'image/svg+xml': 'svg',
            'text/html': 'html',
            'text/javascript': 'js',
            'text/csv;charset=utf-8;': 'csv'
        };

        _fileName = _fileName.split('.')[0] + '.' + fileExtensionList[_mimeType];

        _anchorElement.download = _fileName;

        if (_mimeType === 'image/png' || _mimeType === 'image/jpeg') {
            _anchorElement.href = _data;
        } else {
            _anchorElement.href = window.URL.createObjectURL(new Blob([_data], {
                        type: _mimeType
                    }));
            _anchorElement.dataset.downloadurl = [_mimeType, _anchorElement.download, _anchorElement.href].join(':');
        }

        _anchorElement.click();

        document.body.removeChild(_anchorElement);
    };

    getFileEntryAsObjectURL(_fileEntry, _callback) {
        const self = this;
        _fileEntry.file(function (file) {
            const objectURL = window.URL.createObjectURL(file);
            self.objectUrlList[_fileEntry.fullPath] = objectURL;
            _callback(objectURL);
            //window.URL.revokeObjectURL(objectURL);
        });
    };

    readXMLFile(_file, _callback) {
        const reader = new FileReader();

        reader.onload = function (_e) {
            const parser = new DOMParser();
            //const xmlDocument = parser.parseFromString( _e.target.result,"text/xml").documentElement;
            const xmlDocument = parser.parseFromString(_e.target.result, "image/svg+xml").documentElement;
            _callback(xmlDocument);
        };

        reader.readAsText(_file);
    };

    readTextFile(_file, _callback) {
        const reader = new FileReader();

        reader.onload = function (_e) {
            _callback(_e.target.result);
        };

        reader.readAsText(_file);
    };

    readImageFileAsDataUrl(_file, _onloadCallback) {
        if (_file && window.File && window.FileReader && window.FileList && window.Blob) {
            const reader = new FileReader();
            reader.onload = function (_e) {
                _onloadCallback(_e.target.result)
            };
            reader.readAsDataURL(_file);
        }
    };

}

const LOCAL_FILE_SYSTEM = new LocalFileSystem();

class NativeFileSystemAPIUtils{
    //static objectUrlList={};


    static fileNameAndExtensionByMimeType(_fileName, _mimeType) {
        const fileExtensionList = {
            'image/png': 'png',
            'image/jpeg': 'jpg',
            'image/svg+xml': 'svg',
            'text/html': 'html',
            'text/javascript': 'js',
            'text/csv;charset=utf-8;': 'csv'
        };
        const splittedName = _fileName.split('.');
        if (splittedName.length > 1)
            splittedName.pop();
        splittedName.push(fileExtensionList[_mimeType]);
        return splittedName.join('.');
    };

    // static async chooseFile( _extensions, _mimeTypes, _onChooseLocalFileCallback )
    // {
    //     _extensions = _extensions || ['txt'];
    //     _mimeTypes = _mimeTypes || ['text/plain'];
    //     const opts = {
    //         //type: 'openFile',
    //         type: 'open-file',
    //         accepts: [{
    //             description: 'Open file',
    //             extensions: _extensions,
    //             mimeTypes: _mimeTypes,
    //         }]
    //     };
    //     const fileHandle = await window.chooseFileSystemEntries( opts );
    //     // const file = await fileHandle.getFile();
    //    _onChooseLocalFileCallback(fileHandle);
    //     // const contents = await file.text();
    //     // console.log('contents', contents);
    // }


    static async chooseFile(_types, _onChooseLocalFileCallback) {

        const types = _types || [{
                    description: 'Text Files',
                    accept: {
                        'text/plain': ['.txt', '.text'],
                        'text/html': ['.html', '.htm']
                    }
                }
            ];

        return window.showOpenFilePicker({
            'types': types
        });

    }

    static async getDirectoryChildren(_directoryHandle) {
        const entries = await _directoryHandle.getEntries();
        const directoryList = [];
        const fileList = [];

        for await(const entry of entries) {
            entry.parent = _directoryHandle;
            entry.fullPath = _directoryHandle.fullPath + '/' + entry.name;
            if (entry.isDirectory) {
                directoryList.push(entry);
            } else {
                fileList.push(entry);
            }
        }

        directoryList.sort((a, b) => (a.name > b.name) ? 1 : -1);
        fileList.sort((a, b) => (a.name > b.name) ? 1 : -1);

        return directoryList.concat(fileList);
    }

    static async writeFile(fileHandle, fileContent) {
        console.log('writeFile', fileHandle);
        // Create a writer (request permission if necessary).
        //const writer = await fileHandle.createWriter();
        // const writer = await fileHandle.createWritable();
        // // Make sure we start with an empty file
        // await writer.truncate(0);
        // // Write the full length of the fileContent
        // await writer.write(0, fileContent);
        // // Close the file and write the fileContent to disk
        // await writer.close();

        // Create a FileSystemWritableFileStream to write to.
        const writable = await fileHandle.createWritable();
        // Write the contents of the file to the stream.
        await writable.write(fileContent);
        // Close the file and write the contents to disk.
        await writable.close();
    }

    // static  createNewFile(_fileName , _mimeType , contents ) {
    //     const opts = {
    //         type: 'saveFile',
    //         accepts: [{
    //             description: 'Text file',
    //             extensions: ['txt'],
    //             mimeTypes: ['text/plain'],
    //         }],
    //     };
    //     return window.chooseFileSystemEntries(opts);
    // }

    // static  createNewFile(_fileName , _accepts  ) {
    //     _accepts = _accepts ||  [{  description: 'Text file',  extensions: ['txt'], mimeTypes: ['text/plain'] }];
    //     //const opts = { type: 'saveFile', accepts: _accepts};
    //     const opts = { type: 'save-file', accepts: _accepts};
    //     return window.chooseFileSystemEntries(opts);
    // }


    static createNewFile(_fileName, _types) {

        const types = _types || [{
                    description: 'Text Files',
                    accept: {
                        'text/plain': ['.txt', '.text'],
                        'text/html': ['.html', '.htm']
                    }
                }
            ];

        return window.showSaveFilePicker({
            'types': types
        });
    }

    static async createFile(_fileName, _parentDirHandle) {

        return await _parentDirHandle.getFile(_fileName, {
            create: true
        });
    }

    static async createDirectory(_dirName, _parentDirHandle) {

        return await _parentDirHandle.getDirectory(_dirName, {
            create: true
        });

        // const opts = {
        //     type: 'saveFile',
        //     accepts: [{
        //         description: 'Text file',
        //         extensions: ['txt'],
        //         mimeTypes: ['text/plain'],
        //     }],
        // };
        // return window.chooseFileSystemEntries(opts);
    }

    static pathInfo(_filePath) {
        let splittedPath = _filePath.split('/');
        let fileName = splittedPath[splittedPath.length - 1];
        let dir = '';
        if (splittedPath.length > 1) {
            splittedPath.pop();
            dir = splittedPath.join('/');
        }
        let splittedName = fileName.split('.');
        let fileNameNoExtension = splittedName[0];
        let fileExtension = '';
        if (splittedName.length > 1) {
            fileExtension = splittedName.pop();
            fileNameNoExtension = splittedName.join('.');
        }
        return {
            dir: dir,
            fileName: fileName,
            fileNameNoExtension: fileNameNoExtension,
            fileExtension: fileExtension
        };
    }

    static GetRelativeFilePathFromBaseFilePath(_basePath, _absolutePath) {

        let splittedBasePath = _basePath.split('/');
        let splittedPath = _absolutePath.split('/');
        let relativePath = _absolutePath.split('/');
        for (let i = 0; i < splittedBasePath.length; i++) {
            if (i == splittedPath.length)
                break;

            if (splittedBasePath[i] == splittedPath[i]) {
                relativePath.shift();
            } else {
                relativePath.unshift('..');
            }

        }

        relativePath.shift();

        let relativeFilePath = relativePath.join('/');

        return relativeFilePath;

    }

    static GetAbsoluteFilePathFromBaseFilePath(_basePath, _relativePath) {
        let splittedBasePath = _basePath.split('/');
        splittedBasePath.pop();

        let splittedRelativePath = _relativePath.split('../');

        if (splittedRelativePath.length > 1) {
            for (let i = 0; i < splittedRelativePath.length; i++) {
                splittedRelativePath.shift();
                splittedBasePath.pop();
            }
        }

        let absoluteFilePath = splittedBasePath.concat(splittedRelativePath).join('/');

        return absoluteFilePath;
    }

    static getFileEntryAsObjectURL(_fileEntry, _callback) {
        _fileEntry.file(function (file) {
            const objectURL = window.URL.createObjectURL(file);
            NativeFileSystemAPIUtils.objectUrlList[_fileEntry.fullPath] = objectURL;
            _callback(objectURL);
            //window.URL.revokeObjectURL(objectURL);
        });
    }

    static readXMLFile(_file, _callback) {
        const reader = new FileReader();

        reader.onload = function (_e) {
            const parser = new DOMParser();
            // const xmlDocument = parser.parseFromString(reader.result,"text/xml").documentElement;
            const xmlDocument = parser.parseFromString(_e.target.result, "image/svg+xml").documentElement;
            _callback(xmlDocument);
        };

        reader.readAsText(_file);
    }

    static readImageFile(_file, _onloadCallback) {
        if (_file && window.File && window.FileReader && window.FileList && window.Blob) {
            const reader = new FileReader();
            reader.onload = function (_e) {
                _onloadCallback(_e.target.result)
            };
            reader.readAsDataURL(_file);
        }
    }

}

function ColorUtils() {}

_ = ColorUtils; // tutti i metodi saranno statici


/*
_.hexToRgb = function(hex) {
var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
return result ? {
r: parseInt(result[1], 16),
g: parseInt(result[2], 16),
b: parseInt(result[3], 16),
a:1
} : null;
};
 */

_.hexToRgb = function (hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
        return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 1
    }
     : null;
};

//  _.hexToRgb = function(hex) {
//     // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
//     var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
//     hex = hex.replace(shorthandRegex, function(m, r, g, b) {
//         return r + r + g + g + b + b;
//     });
//
//     var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
//     return result ? {
//         r: parseInt(result[1], 16),
//         g: parseInt(result[2], 16),
//         b: parseInt(result[3], 16)
//     } : null;
// };


/*
_.rgbToHex = function (r, g, b)
{
function componentToHex(c) {
var hex = c.toString(16);
return hex.length == 1 ? "0" + hex : hex;
}

return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
};


_.parseColorString = function ( _color )
{
var colorValues;
var rgba={r:0,g:0,b:0,a:1};

_color = _color.trim();

if(_color.indexOf('#')==0)
{
rgba = this.hexToRgb(_color);
}
else if( _color.indexOf('rgb(') > -1 ) {
colorValues = _color.split('rgb(')[1].split(')')[0].split(',');
rgba.r = 1/255 * parseInt(colorValues[0]);
rgba.g = 1/255 * parseInt(colorValues[1]);
rgba.b = 1/255 * parseInt(colorValues[2]);
}
else if( _color.indexOf('rgba(') > -1 ) {
colorValues = _color.split('rgba(')[1].split(')')[0].split(',');
rgba.r = 1/255 * parseInt(colorValues[0]);
rgba.g = 1/255 * parseInt(colorValues[1]);
rgba.b = 1/255 * parseInt(colorValues[2]);
rgba.a = parseFloat(colorValues[3]);
}
else {
rgba = this.hexToRgb( this.colorNameToHex(_color) );
}

return rgba;
};
 */

_.rgbToHex = function (r, g, b) {
    r = Math.round(r * 255);
    g = Math.round(g * 255);
    b = Math.round(b * 255);

    r = r.toString(16);
    if (r.length == 1)
        r = '0' + r;
    g = g.toString(16);
    if (g.length == 1)
        g = '0' + g;
    b = b.toString(16);
    if (b.length == 1)
        b = '0' + b;

    return ('#' + r + g + b).toUpperCase();
};

_.rgbaToHtmlString = function (_r, _g, _b, _a) {
    return 'rgba(' + Math.round(_r * 255) + ',' + Math.round(_g * 255) + ',' + Math.round(_b * 255) + ',' + _a + ')';
};

// _.rgbToHex = function (r, g, b)
// {
//     function componentToHex(c) {
//         var hex = c.toString(16);
//         return hex.length == 1 ? "0" + hex : hex;
//     }
//
//     return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
// };


_.parseColorString = function (_color) {
    var colorValues;
    var rgba = {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    };

    _color = _color.trim();

    if (_color.indexOf('#') == 0) {
        rgba = ColorUtils.hexToRgb(_color);
        rgba.r *= 1 / 255;
        rgba.g *= 1 / 255;
        rgba.b *= 1 / 255;
    } else if (_color.indexOf('rgb(') > -1) {
        colorValues = _color.split('rgb(')[1].split(')')[0].split(',');
        rgba.r = 1 / 255 * parseInt(colorValues[0]);
        rgba.g = 1 / 255 * parseInt(colorValues[1]);
        rgba.b = 1 / 255 * parseInt(colorValues[2]);
    } else if (_color.indexOf('rgba(') > -1) {
        colorValues = _color.split('rgba(')[1].split(')')[0].split(',');
        rgba.r = 1 / 255 * parseInt(colorValues[0]);
        rgba.g = 1 / 255 * parseInt(colorValues[1]);
        rgba.b = 1 / 255 * parseInt(colorValues[2]);
        rgba.a = parseFloat(colorValues[3]);
    } else {
        rgba = ColorUtils.hexToRgb(ColorUtils.colorNameToHex(_color));
        rgba.r *= 1 / 255;
        rgba.g *= 1 / 255;
        rgba.b *= 1 / 255;
    }

    return rgba;
};

_.colorNameToHex = function (colorName) {
    var colorList = {
        "aliceblue": "#f0f8ff",
        "antiquewhite": "#faebd7",
        "aqua": "#00ffff",
        "aquamarine": "#7fffd4",
        "azure": "#f0ffff",
        "beige": "#f5f5dc",
        "bisque": "#ffe4c4",
        "black": "#000000",
        "blanchedalmond": "#ffebcd",
        "blue": "#0000ff",
        "blueviolet": "#8a2be2",
        "brown": "#a52a2a",
        "burlywood": "#deb887",
        "cadetblue": "#5f9ea0",
        "chartreuse": "#7fff00",
        "chocolate": "#d2691e",
        "coral": "#ff7f50",
        "cornflowerblue": "#6495ed",
        "cornsilk": "#fff8dc",
        "crimson": "#dc143c",
        "cyan": "#00ffff",
        "darkblue": "#00008b",
        "darkcyan": "#008b8b",
        "darkgoldenrod": "#b8860b",
        "darkgray": "#a9a9a9",
        "darkgreen": "#006400",
        "darkkhaki": "#bdb76b",
        "darkmagenta": "#8b008b",
        "darkolivegreen": "#556b2f",
        "darkorange": "#ff8c00",
        "darkorchid": "#9932cc",
        "darkred": "#8b0000",
        "darksalmon": "#e9967a",
        "darkseagreen": "#8fbc8f",
        "darkslateblue": "#483d8b",
        "darkslategray": "#2f4f4f",
        "darkturquoise": "#00ced1",
        "darkviolet": "#9400d3",
        "deeppink": "#ff1493",
        "deepskyblue": "#00bfff",
        "dimgray": "#696969",
        "dodgerblue": "#1e90ff",
        "firebrick": "#b22222",
        "floralwhite": "#fffaf0",
        "forestgreen": "#228b22",
        "fuchsia": "#ff00ff",
        "gainsboro": "#dcdcdc",
        "ghostwhite": "#f8f8ff",
        "gold": "#ffd700",
        "goldenrod": "#daa520",
        "gray": "#808080",
        "green": "#008000",
        "greenyellow": "#adff2f",
        "honeydew": "#f0fff0",
        "hotpink": "#ff69b4",
        "indianred ": "#cd5c5c",
        "indigo": "#4b0082",
        "ivory": "#fffff0",
        "khaki": "#f0e68c",
        "lavender": "#e6e6fa",
        "lavenderblush": "#fff0f5",
        "lawngreen": "#7cfc00",
        "lemonchiffon": "#fffacd",
        "lightblue": "#add8e6",
        "lightcoral": "#f08080",
        "lightcyan": "#e0ffff",
        "lightgoldenrodyellow": "#fafad2",
        "lightgrey": "#d3d3d3",
        "lightgreen": "#90ee90",
        "lightpink": "#ffb6c1",
        "lightsalmon": "#ffa07a",
        "lightseagreen": "#20b2aa",
        "lightskyblue": "#87cefa",
        "lightslategray": "#778899",
        "lightsteelblue": "#b0c4de",
        "lightyellow": "#ffffe0",
        "lime": "#00ff00",
        "limegreen": "#32cd32",
        "linen": "#faf0e6",
        "magenta": "#ff00ff",
        "maroon": "#800000",
        "mediumaquamarine": "#66cdaa",
        "mediumblue": "#0000cd",
        "mediumorchid": "#ba55d3",
        "mediumpurple": "#9370d8",
        "mediumseagreen": "#3cb371",
        "mediumslateblue": "#7b68ee",
        "mediumspringgreen": "#00fa9a",
        "mediumturquoise": "#48d1cc",
        "mediumvioletred": "#c71585",
        "midnightblue": "#191970",
        "mintcream": "#f5fffa",
        "mistyrose": "#ffe4e1",
        "moccasin": "#ffe4b5",
        "navajowhite": "#ffdead",
        "navy": "#000080",
        "oldlace": "#fdf5e6",
        "olive": "#808000",
        "olivedrab": "#6b8e23",
        "orange": "#ffa500",
        "orangered": "#ff4500",
        "orchid": "#da70d6",
        "palegoldenrod": "#eee8aa",
        "palegreen": "#98fb98",
        "paleturquoise": "#afeeee",
        "palevioletred": "#d87093",
        "papayawhip": "#ffefd5",
        "peachpuff": "#ffdab9",
        "peru": "#cd853f",
        "pink": "#ffc0cb",
        "plum": "#dda0dd",
        "powderblue": "#b0e0e6",
        "purple": "#800080",
        "red": "#ff0000",
        "rosybrown": "#bc8f8f",
        "royalblue": "#4169e1",
        "saddlebrown": "#8b4513",
        "salmon": "#fa8072",
        "sandybrown": "#f4a460",
        "seagreen": "#2e8b57",
        "seashell": "#fff5ee",
        "sienna": "#a0522d",
        "silver": "#c0c0c0",
        "skyblue": "#87ceeb",
        "slateblue": "#6a5acd",
        "slategray": "#708090",
        "snow": "#fffafa",
        "springgreen": "#00ff7f",
        "steelblue": "#4682b4",
        "tan": "#d2b48c",
        "teal": "#008080",
        "thistle": "#d8bfd8",
        "tomato": "#ff6347",
        "turquoise": "#40e0d0",
        "violet": "#ee82ee",
        "wheat": "#f5deb3",
        "white": "#ffffff",
        "whitesmoke": "#f5f5f5",
        "yellow": "#ffff00",
        "yellowgreen": "#9acd32"
    };

    if (typeof colorList[colorName.toLowerCase()] != 'undefined')
        return colorList[colorName.toLowerCase()];

    return '#000000';
};

_.hsvToRgb = function (hue, saturation, value) {
    var red;
    var green;
    var blue;
    if (value == 0.0) {
        red = 0;
        green = 0;
        blue = 0;
    } else {
        var i = Math.floor(hue * 6);
        var f = (hue * 6) - i;
        var p = value * (1 - saturation);
        var q = value * (1 - (saturation * f));
        var t = value * (1 - (saturation * (1 - f)));
        switch (i) {
        case 1:
            red = q;
            green = value;
            blue = p;
            break;
        case 2:
            red = p;
            green = value;
            blue = t;
            break;
        case 3:
            red = p;
            green = q;
            blue = value;
            break;
        case 4:
            red = t;
            green = p;
            blue = value;
            break;
        case 5:
            red = value;
            green = p;
            blue = q;
            break;
        case 6: // fall through
        case 0:
            red = value;
            green = t;
            blue = p;
            break;
        }
    }
    return {
        r: red,
        g: green,
        b: blue
    };
};

_.rgbToHsv = function (red, green, blue) {
    var max = Math.max(Math.max(red, green), blue);
    var min = Math.min(Math.min(red, green), blue);
    var hue;
    var saturation;
    var value = max;
    if (min == max) {
        hue = 0;
        saturation = 0;
    } else {
        var delta = (max - min);
        saturation = delta / max;
        if (red == max) {
            hue = (green - blue) / delta;
        } else if (green == max) {
            hue = 2 + ((blue - red) / delta);
        } else {
            hue = 4 + ((red - green) / delta);
        }
        hue /= 6;
        if (hue < 0) {
            hue += 1;
        }
        if (hue > 1) {
            hue -= 1;
        }
    }
    return {
        h: hue,
        s: saturation,
        v: value
    };
};

_.rgbToCmyk = function (r, g, b) {
    let computedC = 0;
    let computedM = 0;
    let computedY = 0;
    let computedK = 0;

    // BLACK
    if (r === 0 && g === 0 && b === 0)
        return {
            c: 0,
            m: 0,
            y: 0,
            k: 1
        };

    computedC = 1 - r;
    computedM = 1 - g;
    computedY = 1 - b;

    const minCMY = Math.min(computedC, Math.min(computedM, computedY));
    computedC = (computedC - minCMY) / (1 - minCMY);
    computedM = (computedM - minCMY) / (1 - minCMY);
    computedY = (computedY - minCMY) / (1 - minCMY);
    computedK = minCMY;

    return {
        c: computedC,
        m: computedM,
        y: computedY,
        k: computedK
    };
};

_.cmykToRGB = function (C, M, Y, K) {
    const r = (1 - C) * (1 - K);
    const g = (1 - M) * (1 - K);
    const b = (1 - Y) * (1 - K);
    return {
        r: r,
        g: g,
        b: b
    };
};

_.rainbow = function (numOfSteps, step) {
    // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
    // Adam Cole, 2011-Sept-14
    // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
    var r,
    g,
    b;
    var h = step / numOfSteps;
    var i = ~~(h * 6);
    var f = h * 6 - i;
    var q = 1 - f;
    switch (i % 6) {
    case 0:
        r = 1;
        g = f;
        b = 0;
        break;
    case 1:
        r = q;
        g = 1;
        b = 0;
        break;
    case 2:
        r = 0;
        g = 1;
        b = f;
        break;
    case 3:
        r = 0;
        g = q;
        b = 1;
        break;
    case 4:
        r = f;
        g = 0;
        b = 1;
        break;
    case 5:
        r = 1;
        g = 0;
        b = q;
        break;
    }
    var c = "#" + ("00" + (~~(r * 255)).toString(16)).slice(-2) + ("00" + (~~(g * 255)).toString(16)).slice(-2) + ("00" + (~~(b * 255)).toString(16)).slice(-2);
    return (c);
};

_.mixColorChannel = function (colorChannelA, colorChannelB, amountToMix) {
    var channelA = colorChannelA * amountToMix;
    var channelB = colorChannelB * (1 - amountToMix);
    return channelA + channelB;
};

_.mixColors = function (rgbA, rgbB, amountToMix) {
    var r = this.mixColorChannel(rgbA[0], rgbB[0], amountToMix);
    var g = this.mixColorChannel(rgbA[1], rgbB[1], amountToMix);
    var b = this.mixColorChannel(rgbA[2], rgbB[2], amountToMix);
    return "rgb(" + r + "," + g + "," + b + ")";
};

// _.mixColorChannel = function ( colorChannelA, colorChannelB, amountToMix )
// {
//     var channelA = colorChannelA*amountToMix;
//     var channelB = colorChannelB*(1-amountToMix);
//     return parseInt(channelA+channelB);
// };
//
// _.mixColors = function ( rgbA, rgbB, amountToMix )
// {
//     var r = this.mixColorChannel(rgbA[0],rgbB[0],amountToMix);
//     var g = this.mixColorChannel(rgbA[1],rgbB[1],amountToMix);
//     var b = this.mixColorChannel(rgbA[2],rgbB[2],amountToMix);
//     return "rgb("+r+","+g+","+b+")";
// };

//
// //colorChannelA and colorChannelB are ints ranging from 0 to 255
// function colorChannelMixer(colorChannelA, colorChannelB, amountToMix){
//     var channelA = colorChannelA*amountToMix;
//     var channelB = colorChannelB*(1-amountToMix);
//     return parseInt(channelA+channelB);
// }
// //rgbA and rgbB are arrays, amountToMix ranges from 0.0 to 1.0
// //example (red): rgbA = [255,0,0]
// function colorMixer(rgbA, rgbB, amountToMix){
//     var r = colorChannelMixer(rgbA[0],rgbB[0],amountToMix);
//     var g = colorChannelMixer(rgbA[1],rgbB[1],amountToMix);
//     var b = colorChannelMixer(rgbA[2],rgbB[2],amountToMix);
//     return "rgb("+r+","+g+","+b+")";
// }

class Graph {

    constructor() {
        this.connections = [];
    }

    addNodeConnection(_fromNode, _fromPointName, _toNode, _toPointName) {
        this.connections.push({
            fromNode: _fromNode,
            fromPointName: _fromPointName,
            toNode: _toNode,
            toPointName: _toPointName
        });
        console.log('this.connections', this.connections);
    }

    getNodeConnectionList(_node) {
        const result = [];
        let connection = null;
        for (let i = 0; i < this.connections.length; i++) {
            connection = this.connections[i];
            if (connection.fromNode === _node || connection.toNode === _node)
                result.push(connection);
        }
        return result;
    }

    getNodeConnection(_node, _pointName) {
        const connectionList = this.getNodeConnectionList(_node);
        let connection = null;
        for (let i = 0; i < connectionList.length; i++) {
            connection = this.connections[i];
            if (connection.fromPointName === _pointName || connection.toPointName === _pointName)
                return connection;
        }
    }
}

class KeyboardManager {

    constructor(/*_focusedContainer = window*/) {
        this.KEY_NAME_TO_CODE = {
            'ZERO': 48,
            'ONE': 49,
            'TWO': 50,
            'THREE': 51,
            'FOUR': 52,
            'FIVE': 53,
            'SIX': 54,
            'SEVEN': 55,
            'EIGHT': 56,
            'NINE': 57,
            'A': 65,
            'B': 66,
            'C': 67,
            'D': 68,
            'E': 69,
            'F': 70,
            'G': 71,
            'H': 72,
            'I': 73,
            'J': 74,
            'K': 75,
            'L': 76,
            'M': 77,
            'N': 78,
            'O': 79,
            'P': 80,
            'Q': 81,
            'R': 82,
            'S': 83,
            'T': 84,
            'U': 85,
            'V': 86,
            'W': 87,
            'X': 88,
            'Y': 89,
            'Z': 90,
            'ENTER': 13,
            'SHIFT': 16,
            'ESC': 27,
            'SPACE': 32,
            'PAGEUP': 33,
            'PAGEDOWN': 34,
            'END': 35,
            'HOME': 36,
            'LEFT': 37,
            'UP': 38,
            'RIGHT': 39,
            'DOWN': 40,
            'BACKSPACE': 8,
            'DELETE': 46,
            'TAB': 9,
            'TILDE': 192
        };
        this.KEY_CODE_TO_NAME = {};
        for (let key in this.KEY_NAME_TO_CODE)
            this.KEY_CODE_TO_NAME[String(this.KEY_NAME_TO_CODE[key])] = key;

        this.shiftKeyPressed = this.altKeyPressed = this.cmdKeyPressed = this.spaceKeyPressed = false;

        XOS.connectEvent("keydown", document, this.__onKeyDown, this);
        XOS.connectEvent("keyup", document, this.__onKeyUp, this);

        XOS.connectEvent("paste", document, this.onPaste, this);
        XOS.connectEvent("copy", document, this.onCopy, this);
        XOS.connectEvent("cut", document, this.onCut, this);

        XOS.connectEvent("blur", window, this.onBlur, this);

        //this.pressedCharKeyDisplay = document.querySelector('#pressed-keys .char-key .key-button');

    }

    __onKeyDown(_e) {
        this.cmdKeyPressed = _e.ctrlKey || _e.metaKey;
        this.shiftKeyPressed = _e.shiftKey;
        this.altKeyPressed = _e.altKey;
        if (_e.keyCode === this.KEY_NAME_TO_CODE.SPACE) {
            this.spaceKeyPressed = true;
        } else {
            if (!this.shiftKeyPressed)
                this.charKeyPressed = true;
        }

        this.updateKeysState(_e);
        this.onKeyDown(_e);
    }

    __onKeyUp(_e) {
        this.cmdKeyPressed = _e.ctrlKey || _e.metaKey;
        this.shiftKeyPressed = _e.shiftKey;
        this.altKeyPressed = _e.altKey;
        this.spaceKeyPressed = false;
        this.charKeyPressed = false;
        this.updateKeysState(_e);
        this.onKeyUp(_e);
    }

    // chiamato dal mouseUp sul documento
    onMouseUp(_e) {
        this.cmdKeyPressed = _e.ctrlKey || _e.metaKey;
        this.shiftKeyPressed = _e.shiftKey;
        this.altKeyPressed = _e.altKey;
        this.spaceKeyPressed = false;
        this.charKeyPressed = false;
        this.updateKeysState(_e);
    }

    onBlur(_e) {
        this.shiftKeyPressed = this.altKeyPressed = this.cmdKeyPressed = this.spaceKeyPressed = this.charKeyPressed = false;
        this.updateKeysState(_e);

        window.preventCopy = true;
        document.execCommand('copy');
        window.preventCopy = false;

        //_e.clipboardData.setData( 'text/plain', 'jango' ); // evita che qualciuno porti fuori svg
        //window.clipboardData.setData ("Text", 'jango');
        //this.copyTextToClipboard('django');
    }

    updateKeysState(_e) {
        if (this.cmdKeyPressed) {
            document.documentElement.classList.add('cmd-key');
        } else {
            document.documentElement.classList.remove('cmd-key');
        }
        if (this.shiftKeyPressed) {
            document.documentElement.classList.add('shift-key');
        } else {
            document.documentElement.classList.remove('shift-key');
        }
        if (this.altKeyPressed) {
            document.documentElement.classList.add('alt-key');
        } else {
            document.documentElement.classList.remove('alt-key');
        }
        if (this.spaceKeyPressed) {
            document.documentElement.classList.add('space-key');
        } else {
            document.documentElement.classList.remove('space-key');
        }
        // if(this.charKeyPressed) {
        //     const charName = this.KEY_CODE_TO_NAME[_e.keyCode];
        //
        //     if (charName) {
        //         document.documentElement.classList.add('char-key');
        //         if (this.pressedCharKeyDisplay) this.pressedCharKeyDisplay.setAttribute('data-char-key', charName);
        //         return;
        //     }
        //
        //     document.documentElement.classList.remove('char-key');
        //     if (this.pressedCharKeyDisplay) this.pressedCharKeyDisplay.setAttribute('data-char-key', '');
        // }else
        // {
        //     document.documentElement.classList.remove('char-key');
        //     if (this.pressedCharKeyDisplay) this.pressedCharKeyDisplay.setAttribute('data-char-key', '');
        // }

    }

    onKeyDown(_e) {}

    onKeyUp(_e) {}

    onPaste(_e) {}

    onCopy(_e) {}

    onCut(_e) {}

}

class PopUpPanel extends HTMLElement {

    constructor(_shortcut) {
        super();
        this.shortcut = _shortcut;
        this.init();
    }

    init() {
        if (this.hasAttribute('id')) {
            PANELS[this.getAttribute('id')] = this;
        } else {
            PANELS[this.nodeName.toLowerCase()] = this;
        }

        XOS.connectEvent("mousedown", this, this.onMouseDown, this);
        if (this.dataset.closeLeaving === 'true')
            XOS.connectEvent("mouseleave", this, this.onMouseLeave, this);
        //if( this.dataset.manageEvents==='true') XOS.connectDomEvents( this.querySelectorAll('[data-event]'), this );
    };

    onMouseLeave(_e) {
        //console.log('onMouseLeave');
        PopUpPanel.deactivateAllPopUpPanels();
    }

    onMouseDown(_e) {
        //console.log('onMouseDown');
        this.removeAllNextVisible();
        _e.isClickOnPopUpPanel = true;
        return false;
    }

    removeAllNextVisible() {
        let nextMenu = this.nextElementSibling;

        // nascondo tutti i menu successivi a questo
        while (nextMenu) {
            nextMenu.classList.remove('showed');
            nextMenu = nextMenu.nextElementSibling;
        }
    }

    // quando il menu viene attivato da un click su un elemento
    // activateBy( _activatorElement , _mode , _selectActivator=true )
    // {
    //     if(_selectActivator)_activatorElement.applyClass('highlighted');
    //
    //     this.update();
    //     const rect = _activatorElement.getBoundingClientRect();
    //     this.style.top =  rect.bottom  + 'px';
    //     this.style.left = rect.left + 'px';
    //     XOS.showElement( this, _mode );
    //
    //     this.parentElement.appendChild( this ); //lo porto sopra tutti gli altri contextPanel
    //
    //     if( (parseInt(this.style.left)+this.offsetWidth+2) > window.innerWidth ) this.style.left =  window.innerWidth - this.offsetWidth-2 + 'px';
    //
    //     //PopUpPanel.POP_UP_PANELS.classList.add('locked');
    //
    //     this.adjustPosition();
    // }


    activateBy(_activatorElement, _mode, _selectActivator = true, _horizontalPlacement = 'right', _verticalPlacement = 'bottom') {
        if (_selectActivator)
            _activatorElement.applyClass('highlighted');

        const rect = _activatorElement.getBoundingClientRect();
        const left = rect.left;
        const top = rect.top;

        this.style.top = rect.bottom + 'px';
        this.style.left = rect.left + 'px';
        XOS.showElement(this, _mode);
        this.update();

        // this.parentElement.appendChild( this ); //lo porto sopra tutti gli altri contextPanel

        const self = this;
        setTimeout(function () {
            switch (_horizontalPlacement) {
            case "center":
                //console.log('center');
                self.style.left = (left - self.offsetWidth / 2) + 'px';
                break
            case "left":
                self.style.left = (left - self.offsetWidth) + 'px';
                break
            }
            switch (_verticalPlacement) {
            case "center":
                self.style.top = (top - self.offsetHeight / 2) + 'px';
                break
            case "top":
                self.style.top = (top - self.offsetHeight) + 'px';
                break
            }
            self.parentElement.appendChild(self); //lo porto sopra tutti gli altri contextPanel
            self.adjustPosition();
        }, 10);

        //PopUpPanel.POP_UP_PANELS.classList.add('locked');

        // this.adjustPosition();
    }

    activateAt(_left, _top, _horizontalPlacement = 'right', _verticalPlacement = 'bottom') {

        this.style.left = _left + 'px';
        this.style.top = _top + 'px';
        XOS.showElement(this);
        this.update();

        const self = this;
        setTimeout(function () {
            switch (_horizontalPlacement) {
            case "center":
                console.log('center');
                self.style.left = (_left - self.offsetWidth / 2) + 'px';
                break
            case "left":
                self.style.left = (_left - self.offsetWidth) + 'px';
                break
            }
            switch (_verticalPlacement) {
            case "center":
                self.style.top = (_top - self.offsetHeight / 2) + 'px';
                break
            case "top":
                self.style.top = (_top - self.offsetHeight) + 'px';
                break
            }
            self.adjustPosition();
        }, 10);

        //this.parentElement.classList.add('locked');

        // this.adjustPosition();
    }

    update() {
        // must be redefined
    }

    adjustPosition() {
        //this.classList.remove('scrollable');

        if (parseInt(this.style.left) < 2)
            this.style.left = 2 + 'px';

        if ((parseInt(this.style.left) + this.offsetWidth + 2) > window.innerWidth)
            this.style.left = window.innerWidth - this.offsetWidth - 2 + 'px';

        if ((parseInt(this.style.top) + this.offsetHeight + 2) > window.innerHeight) {
            let y = window.innerHeight - (this.offsetHeight + 2);
            if (y < 27)
                y = 27;
            this.style.top = y + 'px';
        }

        // if(this.offsetHeight>(window.innerHeight-27))
        // {
        //     this.classList.add('scrollable');
        // }
    }

    static deactivateAllPopUpPanels() {

        //PopUpPanel.POP_UP_PANELS.classList.remove('locked');
        XOS.hideElementChildren(PopUpPanel.POP_UP_PANELS);

        //const activatorButton = document.querySelector('[data-panel-activator].highlighted'  );
        const activatorButton = document.querySelector('[data-panel-target].highlighted');
        if (activatorButton) {
            activatorButton.classList.remove('highlighted');
        }
    }

}

customElements.define("pop-up-panel", PopUpPanel);

PopUpPanel.POP_UP_PANELS = document.querySelector('#POP_UP_PANELS');

XOS.connectEvent("mousedown", window, function (_e) {
    if (_e.isClickOnPopUpPanel)
        return;
    //console.log('target',_e.isClickOnPopUpPanel);
    PopUpPanel.deactivateAllPopUpPanels();
});

//XOS.connectEvent ( "click" , document.querySelector('#POP_UP_PANELS') , function(_e){   if( _e.target===this ) PopUpPanel.deactivateAllPopUpPanels(); } );

class MenuBar extends HTMLElement {

    constructor() {
        super();
        XOS.connectEvent("mouseover", this, this.onMouseOver, this);
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onMouseOver(_e) {
        //console.log('onMouseOver', _e.target);
        if (this.classList.contains('active'))
            this.activateMenu(_e);
    }

    activateMenu(_e) {
        const activatorElement = _e.target;
        if (activatorElement.parentElement.classList.contains('menu-bar'))
            activatorElement.parentElement.classList.add('active');
        const menuToActivate = document.querySelector('#POP_UP_MENUS>#' + activatorElement.dataset.menuActivator);
        if (menuToActivate)
            menuToActivate.activateBy(activatorElement);
    }

}

customElements.define("menu-bar", MenuBar);

class PopUpMenu extends PopUpPanel {

    constructor(_shortcut) {
        super(_shortcut);
    }

    init() {
        // MENUS[ this.getAttribute('id') || this.nodeName.toLowerCase() ] = this;

        if (this.hasAttribute('id')) {
            MENUS[this.getAttribute('id')] = this;
        } else {
            MENUS[this.nodeName.toLowerCase()] = this;
        }

        XOS.connectEvent("mouseover", this, this.onMouseOver, this);
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'));
    }

    onMouseOver(_e) {
        this.removeAllNextVisible();
        const activatorElement = _e.target;
        XOS.deselectElementChildren(this);
        // se il target del mouseover è un elemento che ha un subMenu allora lo attivo
        if (activatorElement.hasAttribute('data-menu-activator'))
            this.activateSubMenuBy(activatorElement);
    }

    // quando il menu viene attivato da un click su un elemento
    activateBy(_activatorElement) {
        this.parentElement.classList.add('locked'); // solo i popup menu bloccano il system
        XOS.deselectElementChildren(this);
        super.activateBy(_activatorElement);
    }

    // quando il menu è un context menu
    activateAt(_left, _top) {
        this.parentElement.classList.add('locked'); // solo i popup menu bloccano il system
        XOS.deselectElementChildren(this);
        super.activateAt(_left, _top);
    }

    activateSubMenuBy(_activatorElement) {
        XOS.selectElement(_activatorElement);
        const rect = _activatorElement.getBoundingClientRect();
        //const subMenuToActivate =  document.querySelector('#POP_UP_MENUS>#'+ _activatorElement.dataset.menuActivator ) ;
        const subMenuToActivate = _activatorElement.closest('.pop-up-container').querySelector('#' + _activatorElement.dataset.menuActivator);
        XOS.deselectElementChildren(subMenuToActivate);
        XOS.showElement(subMenuToActivate, 'add');

        subMenuToActivate.style.top = rect.top + 'px';
        subMenuToActivate.style.left = rect.right + 'px';

        // if( (parseInt(subMenuToActivate.style.left)+subMenuToActivate.offsetWidth+2) > window.innerWidth )
        // {
        //     subMenuToActivate.style.left = rect.left - subMenuToActivate.offsetWidth + 'px';
        // }

        subMenuToActivate.adjustPosition();
        this.parentElement.insertBefore(subMenuToActivate, this.nextElementSibling);
    }

    adjustPosition() {
        this.classList.remove('scrollable');

        super.adjustPosition();

        if (this.offsetHeight > (window.innerHeight - 27)) {
            this.classList.add('scrollable');
        }
    }

    static deactivateAllPopUpMenus(_e) {
        const POP_UP_MENUS = PopUpMenu.POP_UP_MENUS;
        XOS.hideElementChildren(POP_UP_MENUS);
        POP_UP_MENUS.classList.remove('locked');
        // const menuActivator = document.querySelector('[data-menu-activator].selected'  );
        // if( menuActivator ) menuActivator.classList.remove('selected') ;
        const menuActivator = document.querySelector('[data-menu-activator].highlighted');
        if (menuActivator)
            menuActivator.classList.remove('highlighted');
        const activeMenuBar = document.querySelector('.menu-bar.active');
        if (activeMenuBar)
            activeMenuBar.classList.remove('active');
        const scrollableMenuList = POP_UP_MENUS.querySelectorAll('.scrollable');
        for (let i = 0; i < scrollableMenuList.length; i++)
            scrollableMenuList[i].classList.remove('scrollable');
    }
}

customElements.define("pop-up-menu", PopUpMenu);

PopUpMenu.POP_UP_MENUS = document.querySelector('#POP_UP_MENUS');

XOS.connectEvent("click", PopUpMenu.POP_UP_MENUS, function (_e) {
    PopUpMenu.deactivateAllPopUpMenus();
    // disabilitati perchè non funziona il link manage files in google drive ( valutaere se ci sono problemi )
    // _e.preventDefault();
    // _e.stopPropagation();
    // return false;
});

class ColorPicker_cmp extends HTMLElement {

    constructor() {
        super();
        //window.colorPicker = this;
        this.hsv = {
            h: 0,
            s: 1,
            v: 1
        };
        this.alpha = 1;

        this.hexColor_input = this.querySelector('[name="color_hex"]');
        this.hue_point = this.querySelector('.hue-point');
        this.saturation_point = this.querySelector('.saturation-point');
        this.alpha_point = this.querySelector('.alpha-point');

        this.controlledElement = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);

        this.onChangeStartFunction = this.onChangeFunction = this.onChangeEndFunction = this.mousePanelTarget = null;
        const self = this;
        setTimeout(function () {
            self.update()
        }, 100);

        this.filterFunctions = {};
        this.filterFunctions['colorToString'] = function (_value) {
            _value.a = _value.a || "1.0";
            //console.log('colorToString',"rgba("+Math.round(_value.r*255)+','+Math.round(_value.g*255)+','+Math.round(_value.b*255)+','+_value.a+" )");
            return "rgba(" + Math.round(_value.r * 255) + ',' + Math.round(_value.g * 255) + ',' + Math.round(_value.b * 255) + ',' + _value.a + " )";
        }
        this.filterFunctions['toPercent'] = function (_value) {
            return Math.round(_value * 100);
        }
        this.filterFunctions['to255'] = function (_value) {
            return Math.round(_value * 255);
        }
        this.filterFunctions['to360'] = function (_value) {
            return Math.round(_value * 360);
        }
        this.filterFunctions['fromPercentToFloat'] = function (_value) {
            return Number(1 / 100 * _value);
        }
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    onChangeStart() {
        if (this.onChangeStartFunction)
            this.onChangeStartFunction(this);
        this.onChange();
    }

    onChange() {
        if (this.onChangeFunction)
            this.onChangeFunction(this);
    }

    onChangeEnd() {
        //console.log('onChangeEnd function',this.onChangeEndFunction);
        if (this.onChangeEndFunction)
            this.onChangeEndFunction(this);
        this.mousePanelTarget = null;
    }

    onMouseDown_pickingArea(_e) {
        // this.onChangeStart();
        this.mousePanelTarget = _e.target;
        this.dragLimitsRect = _e.target.getBoundingClientRect();
        this.initDragFunctions();
        this.mouseEventCoordsToPanelTarget(_e);
        this.onChangeStart();
    }

    initDragFunctions(_e) {
        const self = this;
        function dragFunction(_e) {
            self.onDrag(_e);
        }
        function endDragFunction(_e) {
            //console.log('endDragFunction');
            document.removeEventListener('mousemove', dragFunction);
            document.removeEventListener('mouseup', endDragFunction);
            self.onDragEnd(_e);
        }
        //console.log('startDragFunction');
        document.addEventListener('mousemove', dragFunction);
        document.addEventListener('mouseup', endDragFunction);
    }

    onDrag(_e) {

        this.mouseEventCoordsToPanelTarget(_e);
        this.onChange();
    }

    onDragEnd(_e) {
        this.onChangeEnd();
    }

    mouseEventCoordsToPanelTarget(_e) {
        //console.log('mouseEventCoordsToPanelTarget',_e);
        let x = _e.clientX - this.dragLimitsRect.left; //x position within the element.
        let y = _e.clientY - this.dragLimitsRect.top; //y position within the element.
        if (x < 0) {
            x = 0;
        } else if (x > this.dragLimitsRect.width) {
            x = this.dragLimitsRect.width;
        }

        if (this.mousePanelTarget.id === 'ALPHA_PANEL') {
            this.alpha = x / this.dragLimitsRect.width;
        } else if (this.mousePanelTarget.id === 'HUE_PANEL') {
            this.hsv.h = x / this.dragLimitsRect.width;
            if (this.hsv.s === 0)
                this.hsv.s = 1; // se si è sul nero o grigio
            if (this.hsv.v === 0)
                this.hsv.v = 1; // se si è sul nero o grigio
        } else if (this.mousePanelTarget.id === 'SATURATION_PANEL') {
            if (y < 0) {
                y = 0;
            } else if (y > this.dragLimitsRect.height) {
                y = this.dragLimitsRect.height;
            }
            this.hsv.s = x / this.dragLimitsRect.width;
            this.hsv.v = 1 - (y / this.dragLimitsRect.height);
        }

        this.update();
    }

    setOnChangeEvents(_onChangeEndFunction, _onChangeFunction, _onChangeStartFunction) {
        this.onChangeFunction = _onChangeFunction;
        this.onChangeStartFunction = _onChangeStartFunction;
        this.onChangeEndFunction = _onChangeEndFunction;
    }

    setColor(_hexColor, _alpha) {
        const rgba = ColorUtils.parseColorString(_hexColor);
        this.alpha = _alpha || rgba.a || 1;
        this.hsv = ColorUtils.rgbToHsv(rgba.r, rgba.g, rgba.b);
        this.update();
    }

    update(_e) {
        this.rgb = ColorUtils.hsvToRgb(this.hsv.h, this.hsv.s, this.hsv.v);
        this.hex = ColorUtils.rgbToHex(this.rgb.r, this.rgb.g, this.rgb.b);
        this.cmyk = ColorUtils.rgbToCmyk(this.rgb.r, this.rgb.g, this.rgb.b);

        this.hue_point.style.left = (this.hsv.h * 150) + 'px';
        this.saturation_point.style.left = this.hsv.s * 150 + 'px';
        this.saturation_point.style.top = (1 - this.hsv.v) * 150 + 'px';
        this.alpha_point.style.left = (this.alpha * 150) + 'px';
        this.alpha_point.previousElementSibling.style.background = "linear-gradient( to right, rgba( 0 , 0 , 0 , 0), " + this.hex + " )";

        //change text color to white if the background color is to dark
        if (((this.rgb.r * 100 + this.rgb.g * 100 + this.rgb.b * 100) / 3) < 65)
            this.hexColor_input.style.color = "#FFFFFF";
        else
            this.hexColor_input.style.color = "#000000";

        const rgb = ColorUtils.hsvToRgb(this.hsv.h, 1, 1);
        this.saturation_point.parentElement.style.backgroundColor = ColorUtils.rgbToHex(rgb.r, rgb.g, rgb.b);

        this.controlledElement.h.value = this.filterFunctions.to360(this.hsv.h);
        this.controlledElement.s.value = this.filterFunctions.toPercent(this.hsv.s);
        this.controlledElement.v.value = this.filterFunctions.toPercent(this.hsv.v);

        this.controlledElement.r.value = this.filterFunctions.to255(this.rgb.r);
        this.controlledElement.g.value = this.filterFunctions.to255(this.rgb.g);
        this.controlledElement.b.value = this.filterFunctions.to255(this.rgb.b);

        this.controlledElement.c.value = this.filterFunctions.toPercent(this.cmyk.c);
        this.controlledElement.m.value = this.filterFunctions.toPercent(this.cmyk.m);
        this.controlledElement.y.value = this.filterFunctions.toPercent(this.cmyk.y);
        this.controlledElement.k.value = this.filterFunctions.toPercent(this.cmyk.k);

        this.controlledElement.alpha.value = this.filterFunctions.toPercent(this.alpha);

        this.controlledElement.color_hex.value = this.hex;
        this.controlledElement.color_hex.style.backgroundColor = this.hex;

        // const propertyContainers = this.querySelectorAll('property-container');
        //
        // for (let i=0; i<propertyContainers.length;i++) propertyContainers[i].update();
    }

    onChange_HSV(_e) {
        //console.log('onChange_HSV');
        const propertyName = _e.target.getAttribute('name');
        if (propertyName === "h") {
            this.hsv.h = Number(1 / 360 * _e.target.value);
        } else {
            this.hsv[_e.target.getAttribute('name')] = Number(1 / 100 * _e.target.value);
        }
        this.update();
    }

    onChange_RGB(_e) {
        //console.log('onChange_RGB');
        this.rgb[_e.target.getAttribute('name')] = Number(1 / 255 * _e.target.value);
        this.hsv = ColorUtils.rgbToHsv(this.rgb.r, this.rgb.g, this.rgb.b);
        this.update();
    }

    onChange_CMYK(_e) {
        this.cmyk[_e.target.getAttribute('name')] = Number(1 / 100 * _e.target.value);
        //console.log('onChange_CMYK',this.cmyk);
        this.rgb = ColorUtils.cmykToRGB(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k);
        //console.log('this.rgb',this.rgb);
        this.hsv = ColorUtils.rgbToHsv(this.rgb.r, this.rgb.g, this.rgb.b);
        this.update();
    }

    onChange_alpha(_e) {
        //console.log('onChange_CMYK');
        this.alpha = Number(1 / 100 * _e.target.value);
        this.update();
    }

    onChange_hex(_e) {
        this.setColor(_e.target.value, 1);
    }

}
customElements.define("color-picker", ColorPicker_cmp);

class Spreadsheet_cmp extends HTMLElement {

    constructor() {
        super();
        this.tableArray = [
            ['Month', 'Bolivia', 'Ecuador', 'Madagascar', 'Papua New Guinea', 'Rwanda', 'Average'],
            ['2004/05', 165, 938, 522, 998, 450, 614.6],
            ['2005/06', 135, 1120, 599, 1268, 288, 682],
            ['2006/07', 157, 1167, 587, 807, 397, 623],
            ['2007/08', 139, 1110, 615, 968, 215, 609.4],
            ['2008/09', 136, 691, 629, 1026, 366, 569.6]
        ];
        this.draw();
    }

    draw() {
        this.tableElement = document.createElement("table");

        const tableHead = document.createElement("thead");
        this.tableElement.appendChild(tableHead);
        tableHead.appendChild(this.drawTableRow(this.tableArray[0], 'th'));

        const tableBody = document.createElement("tbody");
        this.tableElement.appendChild(tableBody);

        const max = this.tableArray.length;
        for (let i = 1; i < max; i++)
            tableBody.appendChild(this.drawTableRow(this.tableArray[i]));

        this.appendChild(this.tableElement);
        XOS.connectEvent('mousedown', this.tableElement, this.onMouseDownOnTable, this);
        XOS.connectEvent('dblclick', this.tableElement, this.onDoubleClickOnTable, this);
        // XOS.connectEvent('blur', this.tableElement, this.onBlur, this );

    }

    drawTableRow(_rowDataArray, _cellTag = 'td') {
        const tableRow = document.createElement("tr");
        let tableTh,
        cellText;
        const max = _rowDataArray.length;
        for (let i = 0; i < max; i++) {
            tableTh = document.createElement(_cellTag);
            cellText = document.createTextNode(_rowDataArray[i]);
            tableTh.appendChild(cellText);
            tableRow.appendChild(tableTh);
        }

        return tableRow;
    }

    onMouseDownOnTable(_e) {
        const cell = _e.target.closest('td');
        if (cell.classList.contains('selected'))
            return;
        this.deselectAll();
        if (cell)
            XOS.selectElement(cell);
        //if(this.activeEditableCell) this.activeEditableCell.removeAttribute('contenteditable');
        //if(this.activeEditableCell) this.activeEditableCell.exitFromEditing();
    }

    deselectAll() {
        const elementList = this.tableElement.querySelectorAll(':scope  .selected');
        const max = elementList.length;
        for (let i = 0; i < max; i++)
            elementList[i].classList.remove('selected');
    }

    onDoubleClickOnTable(_e) {
        const cell = _e.target.closest('td');
        this.editCellContent(cell);
    }

    // onBlur(_e)
    // {
    //     if(this.activeEditableCell) this.activeEditableCell.exitFromEditing();
    // }

    editCellContent(_cellElement) {
        console.log('_cellElement', _cellElement);
        _cellElement.setAttribute('contenteditable', 'true');
        this.activeEditableCell = _cellElement;
        this.activeEditableCell.focus();
        selectText(this.activeEditableCell.firstChild);

        const self = this;
        function onKeyDown(_e) {
            if (_e.keyCode === 13) {
                //don't automatically put in divs
                _e.preventDefault();
                _e.stopPropagation();
                //insert newline
                insertTextAtSelection(_cellElement, "\n");
            }
        }

        _cellElement.addEventListener("keydown", onKeyDown);

        function onPaste(_e) {
            //cancel paste
            _e.preventDefault();
            //get plaintext from clipboard
            const text = (_e.originalEvent || _e).clipboardData.getData('text/plain');
            //insert text manually
            insertTextAtSelection(_cellElement, text);
        }

        //override paste
        _cellElement.addEventListener("paste", onPaste);

        function selectText(node) {
            //node = document.getElementById(node);

            if (document.body.createTextRange) {
                const range = document.body.createTextRange();
                range.moveToElementText(node);
                range.select();
            } else if (window.getSelection) {
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNodeContents(node);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                console.warn("Could not select text in node: Unsupported browser.");
            }
        }

        function insertTextAtSelection(_element, txt) {
            //get selection area so we can position insert
            const sel = window.getSelection();
            const text = _element.textContent;
            let before = Math.min(sel.focusOffset, sel.anchorOffset);
            let after = Math.max(sel.focusOffset, sel.anchorOffset);
            //ensure string ends with \n so it displays properly
            let afterStr = text.substring(after);
            if (afterStr === "")
                afterStr = "\n";
            //insert content
            _element.textContent = text.substring(0, before) + txt + afterStr;
            //restore cursor at correct position
            sel.removeAllRanges();
            const range = document.createRange();
            //childNodes[0] should be all the text
            range.setStart(_element.childNodes[0], before + txt.length);
            range.setEnd(_element.childNodes[0], before + txt.length);
            sel.addRange(range);

            console.log(_element.innerHTML);
        }

        // _cellElement.exitFromEditing = function ()
        // {
        //     console.log('exitFromEditing');
        //     _cellElement.removeAttribute('contenteditable');
        //     _cellElement.removeEventListener( "keydown", onKeyDown );
        //     _cellElement.removeEventListener( "paste", onPaste );
        //     self.activeEditableCell = null;
        // }

        function exitFromEditing() {
            console.log('exitFromEditing');
            _cellElement.removeAttribute('contenteditable');
            _cellElement.removeEventListener("keydown", onKeyDown);
            _cellElement.removeEventListener("paste", onPaste);
            self.activeEditableCell = null;
        }

        _cellElement.addEventListener("blur", exitFromEditing);

    }

}

customElements.define("spread-sheet", Spreadsheet_cmp);

class WindowBase extends HTMLElement{

    constructor() {
        super();
        //this.initEvents();
        WINDOWS[this.getAttribute('id') || this.nodeName.toLowerCase()] = this;

        XOS.connectEvent("mousedown", this, this.placeInFront, this);
        XOS.connectEvent("mousedown", this.querySelector(':scope > .head'), this.onClickOnHead, this);
        XOS.connectEvent("dblclick", this.querySelector(':scope > .head'), this.onDoubleClickOnHead, this);
        XOS.connectEvent("click", this.querySelector(':scope > .close-button'), this.close, this);
        XOS.connectEvent("click", this.querySelector(':scope > .collapse-button'), this.onClickOnCollapseButton, this);
        //XOS.connectEvent ( "click" , this.querySelector(':scope > .full-screen-button') , this.onClickOnFullScreenButton, this );
        XOS.connectEvent("mousedown", this.querySelector(':scope > .resize-button'), this.onMouseDownOnResizeButton, this);

    }

    connectedCallback() {}

    // initEvents()
    // {
    //     console.warn('initEvents di base window', this.querySelector(':scope > .head'))
    //     //const id = this.getAttribute('id');
    //     //XOS.connectEvent ( "click" , this , this.placeInFront, this );
    //     XOS.connectEvent ( "mousedown" , this , this.placeInFront, this );
    //     XOS.connectEvent ( "mousedown" , this.querySelector(':scope > .head') , this.onClickOnHead, this );
    //     XOS.connectEvent ( "dblclick" , this.querySelector(':scope > .head') , this.onDoubleClickOnHead, this );
    //     XOS.connectEvent ( "click" , this.querySelector(':scope > .close-button') , this.close, this );
    //     XOS.connectEvent ( "click" , this.querySelector(':scope > .collapse-button') , this.onClickOnCollapseButton, this );
    //     XOS.connectEvent ( "click" , this.querySelector(':scope > .full-screen-button') , this.onClickOnFullScreenButton, this );
    //     XOS.connectEvent ( "mousedown" , this.querySelector(':scope > .resize-button') , this.onMouseDownOnResizeButton, this );
    // }


    // CONNECT EVENTS
    // initEvents( _title )
    // {
    //     const id = this.getAttribute('id');
    //     //XOS.connectEvent ( "click" , this , this.placeInFront, this );
    //     XOS.connectEvent ( "mousedown" , this , this.placeInFront, this );
    //     XOS.connectEvent ( "mousedown" , this.parentElement.querySelector('#'+id + ' > .head') , this.onClickOnHead, this );
    //     XOS.connectEvent ( "dblclick" , this.parentElement.querySelector('#'+id + ' > .head') , this.onDoubleClickOnHead, this );
    //     XOS.connectEvent ( "click" , this.parentElement.querySelector('#'+id + ' > .close-button') , this.close, this );
    //     XOS.connectEvent ( "click" , this.parentElement.querySelector('#'+id + ' > .collapse-button') , this.onClickOnCollapseButton, this );
    //     XOS.connectEvent ( "click" , this.parentElement.querySelector('#'+id + ' > .full-screen-button') , this.onClickOnFullScreenButton, this );
    //     XOS.connectEvent ( "mousedown" , this.parentElement.querySelector('#'+id + ' > .resize-button') , this.onMouseDownOnResizeButton, this );
    // }


    setTitle(_title) {
        //this.querySelector('.head>.title').innerHTML = _title;
        this.querySelector('.head>.title').textContent = _title;
    }

    close(_e) {
        if (this.classList.contains('closed'))
            return;

        if (_e && _e.altKey) {
            let panel,
            panelList = this.parentElement.querySelectorAll('div.window');
            for (let i = 0; i < panelList.length; i++) {
                panel = panelList[i];
                if (!panel.classList.contains('no-closable'))
                    panel.close(null);
            }
            return;
        }

        this.onClose();
        this.classList.add('closed');
    }

    onClose() {}

    onClickOnFullScreenButton() {
        this.classList.remove('collapsed');
        this.classList.toggle('full-screen');
    }

    // OPEN
    open(_centered) {
        if (!this.classList.contains('closed'))
            return;

        this.onOpen();

        this.classList.remove('closed');

        if (_centered === true) {

            const screenSize = {
                x: window.innerWidth,
                y: window.innerHeight
            };
            const winSize = {
                x: this.offsetWidth,
                y: this.offsetHeight
            };
            this.style.left = (screenSize.x / 2 - winSize.x / 2) + 'px';
            this.style.top = (screenSize.y / 2 - winSize.y / 2) + 'px';
        }

        this.placeInFront();
    }

    onOpen() {}

    // BRING TO FRONT
    placeInFront(_e) {

        if (!this.parentNode.maxLevel)
            this.parentNode.maxLevel = 10;
        this.parentNode.maxLevel++;
        this.style.zIndex = this.parentNode.maxLevel;

        //this.style.zIndex='110';


        // if(this.parentElement.lastElementChild === this ) return;
        // this.parentElement.appendChild(this);
    }

    expand() {
        this.classList.remove('collapsed');
        this.onExpand();
    }

    collapse() {
        this.classList.add('collapsed');
        this.onCollapse();
    }

    onClickOnHead(_e) {
        this.dragAction = 'DRAG_WIN';
        const winPos = {
            x: this.offsetLeft,
            y: this.offsetTop
        };
        this.dragOffset = {
            x: 0,
            y: 0
        };
        this.dragOffset.x = _e.pageX - winPos.x;
        this.dragOffset.y = _e.pageY - winPos.y;
        XOS.initDragFunctions(this, _e);
        //this.initDragFunctions();
        //gPOINTER.delegate = this;
    }

    onDoubleClickOnHead(_e) {
        if (_e.target.classList.contains('title')) {
            this.onClickOnCollapseButton();
        }
    }

    // initDragFunctions(_e)
    // {

    // const self=this;
    // function dragFunction(_e){ self.onDrag(_e); }
    // function endDragFunction(_e){
    //     console.log('endDragFunction');
    //     document.removeEventListener('mousemove', dragFunction);
    //     document.removeEventListener('mouseup', endDragFunction);
    //     self.onDragEnd(_e);
    // }
    // console.log('startDragFunction');
    // document.addEventListener('mousemove', dragFunction);
    // document.addEventListener('mouseup', endDragFunction);
    // }


    onMouseDownOnResizeButton(_e) {
        this.dragAction = 'RESIZE_WIN';
        const winPos = {
            x: this.offsetLeft,
            y: this.offsetTop
        };
        const winSize = {
            x: this.offsetWidth,
            y: this.offsetHeight
        };
        this.dragOffset = {
            x: 0,
            y: 0
        };
        this.dragOffset.x = winPos.x + winSize.x - _e.pageX;
        this.dragOffset.y = winPos.y + winSize.y - _e.pageY;
        //gPOINTER.delegate = this;
        // this.initDragFunctions();
        XOS.initDragFunctions(this, _e);
    }

    onClickOnCollapseButton() {
        if (this.classList.contains('collapsed')) {
            this.expand();
        } else {
            this.collapse();
        }

        //this.classList.toggle('collapsed');
    }

    onExpand() {}

    onCollapse() {}

    onDragStart() {
        this.parentElement.classList.add('dragging');
    }

    onDragEnd() {
        this.dragAction = null;
        this.parentElement.classList.remove('dragging');
    }

    onDrag(_e) {
        _e.preventDefault();
        _e.stopPropagation();

        if (this.dragAction === 'DRAG_WIN') {
            var newX = _e.pageX - this.dragOffset.x;
            var newY = _e.pageY - this.dragOffset.y;
            if (newX < 1)
                newX = 1;
            if (newY < 27)
                newY = 27;

            var screenSize = {
                x: window.innerWidth,
                y: window.innerHeight
            };
            var panelSize = {
                x: this.offsetWidth,
                y: this.offsetHeight
            };

            if ((newX + panelSize.x) > screenSize.x)
                newX = screenSize.x - panelSize.x;
            if ((newY + panelSize.y) > screenSize.y)
                newY = screenSize.y - panelSize.y;

            this.style.left = newX + 'px';
            this.style.top = newY + 'px';

        } else if (this.dragAction === 'RESIZE_WIN') {
            var winPos = {
                x: this.offsetLeft,
                y: this.offsetTop
            };
            var newSizeX = _e.pageX - winPos.x + this.dragOffset.x;
            var newSizeY = _e.pageY - winPos.y + this.dragOffset.y;
            this.style.width = newSizeX + 'px';
            this.style.height = newSizeY + 'px';
        }
    }

}

customElements.define("xos-window", WindowBase);

class ProgressWindow extends WindowBase {

    constructor() {
        super();
        this.progressBar = this.querySelector('#BAR');
        this.progressLabel = this.querySelector('#LABEL');
        this.progressInfo = 'progress state';
        this.total = 0;
        this.loaded = 0;
        this.progressBar.max = 100;
        /* per google drive virtual progress  */
        this.uploadBytePerSeconds = 20000; // default bytes upload velocity 20k ( verrà modificato automaticamente ogni volta che si salva un file )
        this.progressListenerList = [];
    }

    reset() {
        this.total = 0;
        this.loaded = 0;
        this.progressListenerList = [];
    }

    onClose() {
        this.reset();
    }

    open(_center) {
        super.open(_center);
        this.style.top = '50px';
        return this;
    }

    setProgressInfo(_text) {
        this.progressInfo = _text;
    }

    setProgressBarValue(_percent) {
        this.progressLabel.innerHTML = this.progressInfo + ' ' + _percent + '%';
        this.progressBar.value = _percent;
        return this;
    }

    setProgressValues(_total, _loaded) {
        if (_total === 0)
            return;
        const percent = Math.round((_loaded / _total) * 100);

        this.setProgressBarValue(percent);

        if (percent === 100) {
            this.close();
            this.reset();
        } else {
            this.open(true);
        }
    }

    onLoadingProgress(_e) {
        if (!_e.lengthComputable)
            return;

        if (this.progressListenerList.indexOf(_e.target) === -1) {
            this.progressListenerList.push(_e.target);
            this.total += _e.total;
            _e.target.lastLoaded = 0;
        }

        this.loaded += (_e.loaded - _e.target.lastLoaded);
        _e.target.lastLoaded = _e.loaded;
        this.setProgressValues(this.total, this.loaded);
    }

    // usati per google drive

    startVirtualProgress(_total) {
        this.progressState = 'progress';
        this.loaded = 0;
        this.total = _total;
        this.startVirtualProgressTime = new Date().getTime();
        this.onVirtualProgress();
        return this;
    }

    endVirtualProgress() {
        this.progressState = 'end';
        this.endVirtualProgressTime = new Date().getTime();
        this.uploadBytePerSeconds = this.total / ((this.endVirtualProgressTime - this.startVirtualProgressTime) / 200);
        this.setProgressBarValue(100);
        const self = this;
        setTimeout(function () {
            self.close();
            self.reset();
        }, 500);
    }

    onVirtualProgress() {
        if (this.progressState !== 'progress')
            return;

        if ((this.loaded + this.uploadBytePerSeconds) < this.total) {
            this.loaded += this.uploadBytePerSeconds;
        } else {
            this.loaded -= this.uploadBytePerSeconds;
            if (this.loaded < 0)
                this.loaded = 0;
        }
        this.setProgressValues(this.total, this.loaded);
        const self = this;
        setTimeout(function () {
            self.onVirtualProgress();
        }, 200);
    }
}

customElements.define("progress-window", ProgressWindow);

class SysDialog extends HTMLElement {
    constructor() {
        super();
        this.callback_OK = null;
        this.callback_CANCEL = null;
        this.defaultIconName = '../XOS/icons/sys-dialog-icons.svg#alert-icon';
        //activeApplication.dialogs[ this.getAttribute('id') || this.nodeName.toLowerCase() ] = this;
        DIALOGS[this.getAttribute('id') || this.nodeName.toLowerCase()] = this;
        this.controlledElements = null;
        this.createEventHandlers();
    }

    createEventHandlers() {
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    setTitle(_title) {
        this.querySelector('.title').innerHTML = _title;
    }

    setDescription(_description) {
        this.querySelector('.description').innerHTML = _description;
    }

    setIcon(_iconUrl) {
        this.querySelector('use').setAttribute('xlink:href', _iconUrl);
    }

    close() {
        this.classList.remove('showed');
    }

    open(_title, _description, _callback_OK, _callback_CANCEL, _iconName) {
        if (_title)
            this.setTitle(_title);
        if (_description)
            this.setDescription(_description);
        this.setIcon(_iconName || this.defaultIconName);
        this.callback_OK = _callback_OK;
        this.callback_CANCEL = _callback_CANCEL;
        this.classList.add('showed');
    }

    onClick_ok(_e) {
        if (this.callback_OK) {
            this.callback_OK();
        } else {
            this.close();
        }
    }

    onClick_cancel(_e) {
        this.close();
        if (this.callback_CANCEL)
            this.callback_CANCEL();
    }

}

customElements.define("sys-dialog", SysDialog);

class AlertDialog extends SysDialog {
    constructor() {
        super();
        this.defaultIconName = '../XOS/icons/sys-dialog-icons.svg#alert-icon';
    }

    open(_title, _description, _iconName) {
        if (_title)
            this.setTitle(_title);
        if (_description)
            this.setDescription(_description);
        this.setIcon(_iconName || this.defaultIconName);
        this.classList.add('showed');
    }
}
customElements.define("alert-dialog", AlertDialog);

class PromptDialog extends SysDialog {
    constructor() {
        super();
        this.defaultIconName = '../XOS/icons/sys-dialog-icons.svg#message-icon';
    }

    onKeyUp_promptValue(_e) {
        if (_e.keyCode === 13) {
            this.onClick_ok(_e);
            return false;
        }

        if (this.inputPattern)
            _e.target.value = _e.target.value.match(this.inputPattern);
    };

    getPromptValue() {
        return this.querySelector('.prompt-value').value;
    };

    setPromptValue(_value, _placeholder, _pattern) {
        const promptTextfield = this.querySelector('.prompt-value');

        _placeholder = _placeholder || '';
        this.inputPattern = _pattern || null;

        promptTextfield.setAttribute('placeholder', _placeholder);
        promptTextfield.value = _value;
        promptTextfield.focus();
    };

}

customElements.define("prompt-dialog", PromptDialog);

class ConfirmDialog extends SysDialog {
    constructor() {
        super();
        this.defaultIconName = '../XOS/icons/sys-dialog-icons.svg#message-icon';
    }

}
customElements.define("confirm-dialog", ConfirmDialog);

class IFrameServiceDialog_cmp extends HTMLElement{
    constructor() {
        super();
        this.iframeElement = this.querySelector('iframe');
        DIALOGS[this.getAttribute('id')] = this;
    }

    // chiamato dal servizio caricato
    // oppure tramite post message dall'iframe
    onServiceReady() {
        console.log('IFrameServiceDialog_cmp ----onServiceReady----');
        this.doServiceAction(this.currentActionRequest);
    }

    doServiceAction(_action) {
        this.currentActionRequest = _action || null;

        if (this.iframeElement.getAttribute('src') !== this.dataset.urlService) {
            this.iframeElement.setAttribute('src', this.dataset.urlService);
            this.open();
        } else {
            if (this.currentActionRequest) {
                this.iframeElement.contentWindow.doAction(this.currentActionRequest);
                this.currentActionRequest = null;
            } // stesso dominio

        }
    }

    // ancora non sono stati usati
    sendMessageToIframe(_messageData) {
        this.iframeElement.contentWindow.postMessage(_messageData, "*");
    }

    onReceiveMessageFromIframe(_messageData) {
        if (_messageData.event === 'serviceReady')
            this.onServiceReady();
    }

    open() {
        XOS.showElement(this);
    }

    close() {
        XOS.hideElement(this);
    }
}

customElements.define("iframe-service-dialog", IFrameServiceDialog_cmp);

class LoginDialog_cmp extends HTMLElement {
    constructor() {
        super();
        //DIALOGS[ this.nodeName.toLowerCase() ] = this;
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    show() {
        this.classList.add('showed');
    }

    onClick_send() {
        this.doLogin();
    }

    onClick_close() {
        this.classList.remove('showed');
    }

    doLogin() {
        //console.log('doLogin');
        const alertDialog = DIALOGS['alert-dialog'];
        const self = this;
        const email = this.querySelector('input[name="email"]').value;
        const password = this.querySelector('input[name="password"]').value;
        const acceptTerms = this.querySelector('input[name="accept-terms"]');

        //console.log('acceptTerms',acceptTerms.checked);
/*
        if (acceptTerms.checked !== true) {
            //console.log('alertDialog',localString('Accept terms.'));
            alertDialog.open(localString('Accept terms.'), localString('You must accept the terms of use.'));
            return;
        }

        XOS.sendAndLoad(WEBSITE_ROOT + '/en/services/app-login-service.php', 'POST', {
            email: email,
            password: password
        },
            function (_xhr) {

            //console.log('doLogin', _xhr.target.responseText);
            if (_xhr.target.responseText === 'OK') {
                alertDialog.open(localString('Login success.'), localString('Now you can save your documents.'), null, null, 'resources/icons/janvas-app-icons.svg#user_icon');
            } else if (_xhr.target.responseText === 'EXPIRED') {
                alertDialog.open(localString('Plan expired!'), localString('Your plan is expired. Go to Janvas website to purchase a new plan.'), null, null, 'resources/icons/janvas-app-icons.svg#user_icon');
            } else {
                self.classList.add('showed');
            }
        });
*/
        this.classList.remove('showed');
    }

}

customElements.define("login-dialog", LoginDialog_cmp);

class UndoRedoHistory {

    constructor(_historyOwner) {
        this.actionList = [];
        this.ID = -1;
        this.historyOwner = _historyOwner;
    }

    addUndoRedoActions(undoAction, redoAction) {
        if (!undoAction || !redoAction) {
            console.warn('Undo/Redo actions must be set!');
            return;
        }

        if (this.ID < (this.actionList.length - 1))
            this.actionList.splice(this.ID + 1);
        this.actionList.push({
            undoAction: undoAction,
            redoAction: redoAction
        });
        this.ID = this.actionList.length - 1;
        this.historyOwner.onChange();
    }

    undo() {
        if (this.ID > -1) {

            if (!this.actionList[this.ID]) {
                console.warn('Undo history error');
            }

            this.actionList[this.ID].undoAction.execute();
            this.ID--;
        }
    }

    redo() {
        if (this.ID < (this.actionList.length - 1)) {
            this.ID++;
            if (!this.actionList[this.ID]) {
                console.warn('Redo history error');
            }
            this.actionList[this.ID].redoAction.execute();
        }
    }
}

class UndoRedoAction{
    constructor(_name) {
        this.snapshotDataList = [];
        this.onExecuteEnd = null;
        this.name = _name || "";
    }

    execute() {
        this.snapshotDataList.forEach(function (snapshotRecord) {
            if (snapshotRecord.type === "attributes") {
                let attributeValue;
                for (let attributeName in snapshotRecord.attributes) {
                    attributeValue = snapshotRecord.attributes[attributeName];

                    if (attributeValue === null || attributeValue === undefined) {
                        snapshotRecord.target.removeAttribute(attributeName);
                    } else {
                        snapshotRecord.target.setAttribute(attributeName, attributeValue);
                    }

                }
            } else if (snapshotRecord.type === "node") {
                if (snapshotRecord.action === 'delete') {
                    snapshotRecord.target.parentElement.removeChild(snapshotRecord.target);
                } else if (snapshotRecord.action === 'insert') {
                    snapshotRecord.parentNode.insertBefore(snapshotRecord.target, snapshotRecord.nextSibling);
                }
            } else if (snapshotRecord.type === "properties") {
                let propertyValue;
                for (let propertyName in snapshotRecord.properties) {
                    propertyValue = snapshotRecord.properties[propertyName];

                    if (propertyValue === undefined) {
                        delete snapshotRecord.target[propertyName];
                    } else {
                        snapshotRecord.target[propertyName] = propertyValue;
                    }

                }
            }
        });

        if (this.onExecuteEnd)
            this.onExecuteEnd(this);
    }

    createPropertySnapshot(_elementList, _propertyNames) {
        let element,
        propertyName;
        const propertyNameList = _propertyNames.split(',');
        let snapshotRecord;
        const max = _elementList.length;
        const maxp = propertyNameList.length;
        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            snapshotRecord = {
                type: 'properties',
                target: element,
                properties: {}
            };
            this.snapshotDataList.push(snapshotRecord);
            for (let ip = 0; ip < maxp; ip++) {
                propertyName = propertyNameList[ip];
                snapshotRecord.properties[propertyName] = element[propertyName];
            }
        }

        return this.snapshotDataList;
    }

    createAttributeSnapshot(_elementList, _attributeNames) {
        if (_elementList.length === 1 && _elementList[0].nodeName === 'text' && _elementList[0].hasAttribute('contenteditable') && _elementList[0].dataset.useRichText === "true") {
            this.createInnerTextAttributeSnapshot(_elementList, _attributeNames);
            return;
        }

        let element,
        attributeName;
        const attributeNameList = _attributeNames.split(',');
        let snapshotRecord;
        const max = _elementList.length;
        const maxp = attributeNameList.length;
        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            snapshotRecord = {
                type: 'attributes',
                target: element,
                attributes: {}
            };
            this.snapshotDataList.push(snapshotRecord);
            for (let ip = 0; ip < maxp; ip++) {
                attributeName = attributeNameList[ip];
                if (SVG_TAG_ATTRIBUTES[element.localName]) {
                    if (SVG_TAG_ATTRIBUTES[element.localName].indexOf(attributeName) > -1 || SVG_TAG_ATTRIBUTES['*'].indexOf(attributeName) > -1) {
                        snapshotRecord.attributes[attributeName] = element.getAttribute(attributeName);
                    }
                } else {
                    snapshotRecord.attributes[attributeName] = element[attributeName];
                }
            }
        }

        return this.snapshotDataList;
    }

    createInnerTextAttributeSnapshot(_textElement, _attributeNames) {
        // var textDataStartOffset =  _textElement.storedTextSelectionRange.textDataStartOffset;
        // var textDataEndOffset =  _textElement.storedTextSelectionRange.textDataEndOffset ;
        //
        // undoAction = new SetTextDataStyle_action( this );
        // undoAction.setTextDataStyleRange(_textElement , textDataStartOffset , textDataEndOffset);
        // this.setAttributeElementList( [_textElement], _keyValues );
        // redoAction = new SetTextDataStyle_action( this );
        // redoAction.setTextDataStyleRange(_textElement , textDataStartOffset , textDataEndOffset );
        // this.history.addUndoRedoActions( undoAction , redoAction  );
    }

    createDomNodeSnapshot(_elementList, _action) {
        let element;
        let snapshotRecord;
        const max = _elementList.length;

        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            snapshotRecord = {
                type: 'node',
                target: element,
                nextSibling: element.nextElementSibling,
                parentNode: element.parentElement,
                action: _action
            };
            this.snapshotDataList.push(snapshotRecord);
        }
        return this.snapshotDataList;
    }

}

function GoogleFonts_utils() {
    this.fontCategories = null;
    this.defaultFontFamilyNames = ['Roboto', 'Montserrat', 'Rubik', 'Archivo Narrow', 'Lato', 'Oswald', 'Playfair Display', 'Indie Flower', 'Pacifico', 'Abril Fatface'];
    this.defaultFontFamilyList = [];
    this.init();
}

_ = GoogleFonts_utils.prototype;

_.init = function () {
    var self = this;

    window.onLoadGoogleFontFamilies = function (_jsonData) {
        var fontCategories = {};
        var fontItem,
        items = _jsonData.items;
        var i,
        max = items.length;
        for (i = 0; i < max; i++) {
            fontItem = items[i];
            if (!fontCategories[fontItem.category])
                fontCategories[fontItem.category] = [];
            fontCategories[fontItem.category].push(fontItem);
        }

        self.fontCategories = fontCategories;
        self.allFontList = items;
        self.createDefaultFontFamilyList();
    };

};

_.createDefaultFontFamilyList = function () {
    var i,
    max = this.defaultFontFamilyNames.length;
    for (i = 0; i < max; i++) {

        this.defaultFontFamilyList.push(this.getGoogleFontObjectByFamilyName(this.defaultFontFamilyNames[i]));
    }
};

_.selectFontByFamilyName = function (_fontFamilyName) {
    _fontFamilyName = _fontFamilyName.toLowerCase();
    var allFontList = GoogleFonts.allFontList;
    var i,
    max = allFontList.length;
    for (i = 0; i < max; i++) {
        if (allFontList[i].family.toLowerCase() == _fontFamilyName)
            allFontList[i].isSelected = true;
    }
};

_.getSelectedFontList = function () {
    var selectedFontList = [];
    var allFontList = GoogleFonts.allFontList;
    var i,
    max = allFontList.length;
    for (i = 0; i < max; i++) {
        if (allFontList[i].isSelected)
            selectedFontList.push(allFontList[i]);
    }

    return selectedFontList;
};

_.findFontList = function (_fontFamilyName) {
    _fontFamilyName = _fontFamilyName.toLowerCase();
    var findedFontList = [];
    var allFontList = GoogleFonts.allFontList;
    var i,
    max = allFontList.length;
    for (i = 0; i < max; i++) {
        if (allFontList[i].family.toLowerCase().indexOf(_fontFamilyName) > -1)
            findedFontList.push(allFontList[i]);
    }

    return findedFontList;
};

_.getGoogleFontObjectByFamilyName = function (_familyName)
// window.getGoogleFontObjectByFamilyName = function ( _familyName )
{
    for (var categoryName in this.fontCategories) {
        var items = this.fontCategories[categoryName];
        var i,
        max = items.length;
        for (i = 0; i < max; i++) {
            if (items[i].family == _familyName)
                return items[i];
        }
    }

    return null;
};

_.getFontUrlByFontFamilyStyleAndWeight = function (_fontFamily, _fontStyle, _fontWeight, _subset)
// window.getFontUrlByFontFamilyStyleAndWeight = function ( _fontFamily , _fontStyle, _fontWeight, _subset )
{
    _subset = _subset || 'latin';
    var fontVariant = this.getGoogleFontVariantNameByStyleAndWeight(_fontStyle, _fontWeight);
    return 'https://fonts.googleapis.com/css?family=' + _fontFamily.replace(/ /g, '+') + ':' + fontVariant + '&subset=' + _subset;
};

_.loadGoogleFont = function (_fontObject, _variant, _subset, _callback)
// window.loadGoogleFont = function ( _fontObject, _variant , _subset , _callback )
{

    //this.getGoogleFontObjectByFamilyName( _fontFamily );

    if (!_variant) {
        if (_fontObject.variants.indexOf('regular') > -1) {
            _variant = 'regular';
        } else {
            _variant = _fontObject.variants[0];
        }
    }

    if (!_subset) {
        if (_fontObject.subsets.indexOf('latin') > -1) {
            _subset = 'latin';
        } else {
            _subset = _fontObject.subsets[0];
        }
    }

    var fontUrl = 'https://fonts.googleapis.com/css?family=' + _fontObject.family.replace(/ /g, '+') + ':' + _variant + '&subset=' + _subset;

    function onLoadGoogleFont(_e) {
        if (_callback)
            _callback();
    }

    XOS.includeCSS(fontUrl, onLoadGoogleFont);
};

_.getGoogleFontVariantNameByStyleAndWeight = function (_fontStyle, _fontWeight)

// window.getGoogleFontVariantNameByStyleAndWeight = function ( _fontStyle, _fontWeight )
{
    var variant;
    if (_fontStyle == 'italic') {
        variant = 'italic';
        if (_fontWeight != "400")
            variant = _fontWeight + variant;
    } else {
        variant = 'regular';
        if (_fontWeight != '' && _fontWeight != "400")
            variant = _fontWeight;
    }

    return variant;
};

_.getGoogleFontStyleAndWeightByVariantName = function (_variant)
// window.getGoogleFontStyleAndWeightByVariantName = function ( _variant )
{
    var result = {
        name: 'Regular',
        'font-style': 'regular',
        'font-weight': 400
    };
    switch (_variant) {
    case 'regular':
        result = {
            name: 'Regular',
            'font-style': 'normal',
            'font-weight': 400
        };
        break;
    case 'italic':
        result = {
            name: 'Italic',
            'font-style': 'italic',
            'font-weight': 400
        };
        break;
    case '100':
        result = {
            name: 'Thin',
            'font-style': 'normal',
            'font-weight': 100
        };
        break;
    case '200':
        result = {
            name: 'Extra Light',
            'font-style': 'normal',
            'font-weight': 200
        };
        break;
    case '300':
        result = {
            name: 'Light',
            'font-style': 'normal',
            'font-weight': 300
        };
        break;
    case '400':
        result = {
            name: 'Regular',
            'font-style': 'normal',
            'font-weight': 400
        };
        break;
    case '500':
        result = {
            name: 'Medium',
            'font-style': 'normal',
            'font-weight': 500
        };
        break;
    case '600':
        result = {
            name: 'Semi Bold',
            'font-style': 'normal',
            'font-weight': 600
        };
        break;
    case '700':
        result = {
            name: 'Bold',
            'font-style': 'normal',
            'font-weight': 700
        };
        break;
    case '800':
        result = {
            name: 'Extra Bold',
            'font-style': 'normal',
            'font-weight': 800
        };
        break;
    case '900':
        result = {
            name: 'Black',
            'font-style': 'normal',
            'font-weight': 900
        };
        break;

    case '100italic':
        result = {
            name: 'Thin - italic',
            'font-style': 'italic',
            'font-weight': 100
        };
        break;
    case '200italic':
        result = {
            name: 'Extra Light - italic',
            'font-style': 'italic',
            'font-weight': 200
        };
        break;
    case '300italic':
        result = {
            name: 'Light - italic',
            'font-style': 'italic',
            'font-weight': 300
        };
        break;
    case '400italic':
        result = {
            name: 'Regular - italic',
            'font-style': 'italic',
            'font-weight': 400
        };
        break;
    case '500italic':
        result = {
            name: 'Medium - italic',
            'font-style': 'italic',
            'font-weight': 500
        };
        break;
    case '600italic':
        result = {
            name: 'Semi Bold - italic',
            'font-style': 'italic',
            'font-weight': 600
        };
        break;
    case '700italic':
        result = {
            name: 'Bold - italic',
            'font-style': 'italic',
            'font-weight': 700
        };
        break;
    case '800italic':
        result = {
            name: 'Extra Bold - italic',
            'font-style': 'italic',
            'font-weight': 800
        };
        break;
    case '900italic':
        result = {
            name: 'Black - italic',
            'font-style': 'italic',
            'font-weight': 900
        };
        break;
    }

    return result;
};

window.GoogleFonts = new GoogleFonts_utils();

onLoadGoogleFontFamilies({
    "kind": "webfonts#webfontList",
    "items": [{
            "kind": "webfonts#webfont",
            "family": "ABeeZee",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/abeezee/v9/mE5BOuZKGln_Ex0uYKpIaw.ttf",
                "italic": "//fonts.gstatic.com/s/abeezee/v9/kpplLynmYgP0YtlJA3atRw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Abel",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/abel/v6/RpUKfqNxoyNe_ka23bzQ2A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Abril Fatface",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/abrilfatface/v8/X1g_KwGeBV3ajZIXQ9VnDojjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Aclonica",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/aclonica/v6/M6pHZMPwK3DiBSlo3jwAKQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Acme",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/acme/v5/-J6XNtAHPZBEbsifCdBt-g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Actor",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/actor/v6/ugMf40CrRK6Jf6Yz_xNSmQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Adamina",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/adamina/v8/RUQfOodOMiVVYqFZcSlT9w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Advent Pro",
            "category": "sans-serif",
            "variants": [
                "100",
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/adventpro/v4/87-JOpSUecTG50PBYK4ysi3USBnSvpkopQaUR-2r7iU.ttf",
                "200": "//fonts.gstatic.com/s/adventpro/v4/URTSSjIp0Wr-GrjxFdFWnGeudeTO44zf-ht3k-KNzwg.ttf",
                "300": "//fonts.gstatic.com/s/adventpro/v4/sJaBfJYSFgoB80OL1_66m0eOrDcLawS7-ssYqLr2Xp4.ttf",
                "500": "//fonts.gstatic.com/s/adventpro/v4/7kBth2-rT8tP40RmMMXMLJp-63r6doWhTEbsfBIRJ7A.ttf",
                "600": "//fonts.gstatic.com/s/adventpro/v4/3Jo-2maCzv2QLzQBzaKHV_pTEJqju4Hz1txDWij77d4.ttf",
                "700": "//fonts.gstatic.com/s/adventpro/v4/M4I6QiICt-ey_wZTpR2gKwJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/adventpro/v4/1NxMBeKVcNNH2H46AUR3wfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Aguafina Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/aguafinascript/v5/65g7cgMtMGnNlNyq_Z6CvMxLhO8OSNnfAp53LK1_iRs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Akronim",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/akronim/v5/qA0L2CSArk3tuOWE1AR1DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Aladin",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/aladin/v5/PyuJ5cVHkduO0j5fAMKvAA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Aldrich",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/aldrich/v6/kMMW1S56gFx7RP_mW1g-Eg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alef",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "hebrew"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/alef/v6/VDgZJhEwudtOzOFQpZ8MEA.ttf",
                "regular": "//fonts.gstatic.com/s/alef/v6/ENvZ_P0HBDQxNZYCQO0lUA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alegreya",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/alegreya/v7/5oZtdI5-wQwgAFrd9erCsaCWcynf_cDxXwCLxiixG1c.ttf",
                "900": "//fonts.gstatic.com/s/alegreya/v7/oQeMxX-vxGImzDgX6nxA7KCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/alegreya/v7/62J3atXd6bvMU4qO_ca-eA.ttf",
                "italic": "//fonts.gstatic.com/s/alegreya/v7/cbshnQGxwmlHBjUil7DaIfesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/alegreya/v7/IWi8e5bpnqhMRsZKTcTUWgJKKGfqHaYFsRG-T3ceEVo.ttf",
                "900italic": "//fonts.gstatic.com/s/alegreya/v7/-L71QLH_XqgYWaI1GbOVhp0EAVxt0G0biEntp43Qt6E.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alegreya SC",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/alegreyasc/v6/M9OIREoxDkvynwTpBAYUq3e1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "900": "//fonts.gstatic.com/s/alegreyasc/v6/M9OIREoxDkvynwTpBAYUqyenaqEuufTBk9XMKnKmgDA.ttf",
                "regular": "//fonts.gstatic.com/s/alegreyasc/v6/3ozeFnTbygMK6PfHh8B-iqCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/alegreyasc/v6/GOqmv3FLsJ2r6ZALMZVBmkeOrDcLawS7-ssYqLr2Xp4.ttf",
                "700italic": "//fonts.gstatic.com/s/alegreyasc/v6/5PCoU7IUfCicpKBJtBmP6c_zJjSACmk0BRPxQqhnNLU.ttf",
                "900italic": "//fonts.gstatic.com/s/alegreyasc/v6/5PCoU7IUfCicpKBJtBmP6U_yTOUGsoC54csJe1b-IRw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alegreya Sans",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v3",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/alegreyasans/v3/TKyx_-JJ6MdpQruNk-t-PJFGFO4uyVFMfB6LZsii7kI.ttf",
                "300": "//fonts.gstatic.com/s/alegreyasans/v3/11EDm-lum6tskJMBbdy9acB1LjARzAvdqa1uQC32v70.ttf",
                "500": "//fonts.gstatic.com/s/alegreyasans/v3/11EDm-lum6tskJMBbdy9aQqQmZ7VjhwksfpNVG0pqGc.ttf",
                "700": "//fonts.gstatic.com/s/alegreyasans/v3/11EDm-lum6tskJMBbdy9aVCbmAUID8LN-q3pJpOk3Ys.ttf",
                "800": "//fonts.gstatic.com/s/alegreyasans/v3/11EDm-lum6tskJMBbdy9acxnD5BewVtRRHHljCwR2bM.ttf",
                "900": "//fonts.gstatic.com/s/alegreyasans/v3/11EDm-lum6tskJMBbdy9aW42xlVP-j5dagE7-AU2zwg.ttf",
                "100italic": "//fonts.gstatic.com/s/alegreyasans/v3/gRkSP2lBpqoMTVxg7DmVn2cDnjsrnI9_xJ-5gnBaHsE.ttf",
                "300italic": "//fonts.gstatic.com/s/alegreyasans/v3/WfiXipsmjqRqsDBQ1bA9CnfqlVoxTUFFx1C8tBqmbcg.ttf",
                "regular": "//fonts.gstatic.com/s/alegreyasans/v3/KYNzioYhDai7mTMnx_gDgn8f0n03UdmQgF_CLvNR2vg.ttf",
                "italic": "//fonts.gstatic.com/s/alegreyasans/v3/TKyx_-JJ6MdpQruNk-t-PD4G9C9ttb0Oz5Cvf0qOitE.ttf",
                "500italic": "//fonts.gstatic.com/s/alegreyasans/v3/WfiXipsmjqRqsDBQ1bA9Cs7DCVO6wo6i5LKIyZDzK40.ttf",
                "700italic": "//fonts.gstatic.com/s/alegreyasans/v3/WfiXipsmjqRqsDBQ1bA9CpF66r9C4AnxxlBlGd7xY4g.ttf",
                "800italic": "//fonts.gstatic.com/s/alegreyasans/v3/WfiXipsmjqRqsDBQ1bA9CicOAJ_9MkLPbDmrtXDPbIU.ttf",
                "900italic": "//fonts.gstatic.com/s/alegreyasans/v3/WfiXipsmjqRqsDBQ1bA9ChRaDUI9aE8-k7PrIG2iiuo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alegreya Sans SC",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v3",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/alegreyasanssc/v3/trwFkDJLOJf6hqM93944kVnzStfdnFU-MXbO84aBs_M.ttf",
                "300": "//fonts.gstatic.com/s/alegreyasanssc/v3/AjAmkoP1y0Vaad0UPPR46-1IqtfxJspFjzJp0SaQRcI.ttf",
                "500": "//fonts.gstatic.com/s/alegreyasanssc/v3/AjAmkoP1y0Vaad0UPPR46_hHTluI57wqxl55RvSYo3s.ttf",
                "700": "//fonts.gstatic.com/s/alegreyasanssc/v3/AjAmkoP1y0Vaad0UPPR4600aId5t1FC-xZ8nmpa_XLk.ttf",
                "800": "//fonts.gstatic.com/s/alegreyasanssc/v3/AjAmkoP1y0Vaad0UPPR46wQgSHD3Lo1Mif2Wkk5swWA.ttf",
                "900": "//fonts.gstatic.com/s/alegreyasanssc/v3/AjAmkoP1y0Vaad0UPPR461Rf9EWUSEX_PR1d_gLKfpM.ttf",
                "100italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/qG3gA9iy5RpXMH4crZboqqakMVR0XlJhO7VdJ8yYvA4.ttf",
                "300italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/0VweK-TO3aQgazdxg8fs0CnTKaH808trtzttbEg4yVA.ttf",
                "regular": "//fonts.gstatic.com/s/alegreyasanssc/v3/6kgb6ZvOagoVIRZyl8XV-EklWX-XdLVn1WTiuGuvKIU.ttf",
                "italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/trwFkDJLOJf6hqM93944kTfqo69HNOlCNZvbwAmUtiA.ttf",
                "500italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/0VweK-TO3aQgazdxg8fs0NqVvxKdFVwqwzilqfVd39U.ttf",
                "700italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/0VweK-TO3aQgazdxg8fs0IBYn3VD6xMEnodOh8pnFw4.ttf",
                "800italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/0VweK-TO3aQgazdxg8fs0HStmCm6Rs90XeztCALm0H8.ttf",
                "900italic": "//fonts.gstatic.com/s/alegreyasanssc/v3/0VweK-TO3aQgazdxg8fs0IvtwEfTCJoOJugANj-jWDI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alex Brush",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/alexbrush/v6/ooh3KJFbKJSUoIRWfiu8o_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alfa Slab One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/alfaslabone/v5/Qx6FPcitRwTC_k88tLPc-Yjjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alice",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/alice/v7/wZTAfivekBqIg-rk63nFvQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alike",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/alike/v8/Ho8YpRKNk_202fwDiGNIyw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Alike Angular",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/alikeangular/v6/OpeCu4xxI3qO1C7CZcJtPT3XH2uEnVI__ynTBvNyki8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Allan",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/allan/v7/zSxQiwo7wgnr7KkMXhSiag.ttf",
                "regular": "//fonts.gstatic.com/s/allan/v7/T3lemhgZmLQkQI2Qc2bQHA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Allerta",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/allerta/v7/s9FOEuiJFTNbMe06ifzV8g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Allerta Stencil",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/allertastencil/v7/CdSZfRtHbQrBohqmzSdDYFf2eT4jUldwg_9fgfY_tHc.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Allura",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/allura/v4/4hcqgZanyuJ2gMYWffIR6A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Almendra",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/almendra/v8/ZpLdQMj7Q2AFio4nNO6A76CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/almendra/v8/PDpbB-ZF7deXAAEYPkQOeg.ttf",
                "italic": "//fonts.gstatic.com/s/almendra/v8/CNWLyiDucqVKVgr4EMidi_esZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/almendra/v8/-tXHKMcnn6FqrhJV3l1e3QJKKGfqHaYFsRG-T3ceEVo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Almendra Display",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/almendradisplay/v6/2Zuu97WJ_ez-87yz5Ai8fF6uyC_qD11hrFQ6EGgTJWI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Almendra SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/almendrasc/v6/IuiLd8Fm9I6raSalxMoWeaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amarante",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/amarante/v4/2dQHjIBWSpydit5zkJZnOw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amaranth",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/amaranth/v6/j5OFHqadfxyLnQRxFeox6qCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/amaranth/v6/7VcBog22JBHsHXHdnnycTA.ttf",
                "italic": "//fonts.gstatic.com/s/amaranth/v6/UrJlRY9LcVERJSvggsdBqPesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/amaranth/v6/BHyuYFj9nqLFNvOvGh0xTwJKKGfqHaYFsRG-T3ceEVo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amatic SC",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/amaticsc/v8/IDnkRTPGcrSVo50UyYNK7y3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/amaticsc/v8/MldbRWLFytvqxU1y81xSVg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amatica SC",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "700": "//fonts.gstatic.com/s/amaticasc/v1/nFmSxyAMfCP_5xGDJ4j5TgJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/amaticasc/v1/f9SWSy9DLsJV2etvm5rwGPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amethysta",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/amethysta/v4/1jEo9tOFIJDolAUpBnWbnA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amiko",
            "category": "sans-serif",
            "variants": [
                "regular",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "600": "//fonts.gstatic.com/s/amiko/v1/BaZst4RZ4sDyD3mH-BfVaA.ttf",
                "700": "//fonts.gstatic.com/s/amiko/v1/6syx43mQ07VvOmpFc0G9Lg.ttf",
                "regular": "//fonts.gstatic.com/s/amiko/v1/A7bjc3cOLJtGgpPGnxyHsw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amiri",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/amiri/v7/WQsR_moz-FNqVwGYgptqiA.ttf",
                "regular": "//fonts.gstatic.com/s/amiri/v7/ATARrPmSew75SlpOw2YABQ.ttf",
                "italic": "//fonts.gstatic.com/s/amiri/v7/3t1yTQlLUXBw8htrqlXBrw.ttf",
                "700italic": "//fonts.gstatic.com/s/amiri/v7/uF8aNEyD0bxMeTBg9bFDSPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Amita",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/amita/v1/cIYA2Lzp7l2pcGsqpUidBg.ttf",
                "regular": "//fonts.gstatic.com/s/amita/v1/RhdhGBXSJqkHo6g7miTEcQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Anaheim",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/anaheim/v4/t-z8aXHMpgI2gjN_rIflKA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Andada",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/andada/v7/rSFaDqNNQBRw3y19MB5Y4w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Andika",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/andika/v7/oe-ag1G0lcqZ3IXfeEgaGg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Annie Use Your Telescope",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/annieuseyourtelescope/v6/2cuiO5VmaR09C8SLGEQjGqbp7mtG8sPlcZvOaO8HBak.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Anonymous Pro",
            "category": "monospace",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/anonymouspro/v9/WDf5lZYgdmmKhO8E1AQud--Cz_5MeePnXDAcLNWyBME.ttf",
                "regular": "//fonts.gstatic.com/s/anonymouspro/v9/Zhfjj_gat3waL4JSju74E-V_5zh5b-_HiooIRUBwn1A.ttf",
                "italic": "//fonts.gstatic.com/s/anonymouspro/v9/q0u6LFHwttnT_69euiDbWKwIsuKDCXG0NQm7BvAgx-c.ttf",
                "700italic": "//fonts.gstatic.com/s/anonymouspro/v9/_fVr_XGln-cetWSUc-JpfA1LL9bfs7wyIp6F8OC9RxA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Antic",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/antic/v7/hEa8XCNM7tXGzD0Uk0AipA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Antic Didone",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/anticdidone/v4/r3nJcTDuOluOL6LGDV1vRy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Antic Slab",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/anticslab/v4/PSbJCTKkAS7skPdkd7AKEvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Anton",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/anton/v7/XIbCenm-W0IRHWYIh7CGUQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arapey",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/arapey/v5/dqu823lrSYn8T2gApTdslA.ttf",
                "italic": "//fonts.gstatic.com/s/arapey/v5/pY-Xi5JNBpaWxy2tZhEm5A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arbutus",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/arbutus/v5/Go_hurxoUsn5MnqNVQgodQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arbutus Slab",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/arbutusslab/v4/6k3Yp6iS9l4jRIpynA8qMy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Architects Daughter",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/architectsdaughter/v6/RXTgOOQ9AAtaVOHxx0IUBMCy0EhZjHzu-y0e6uLf4Fg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Archivo Black",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/archivoblack/v4/WoAoVT7K3k7hHfxKbvB6B51XQG8isOYYJhPIYAyrESQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Archivo Narrow",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/archivonarrow/v5/M__Wu4PAmHf4YZvQM8tWsMLtdzs3iyjn_YuT226ZsLU.ttf",
                "regular": "//fonts.gstatic.com/s/archivonarrow/v5/DsLzC9scoPnrGiwYYMQXppTvAuddT2xDMbdz0mdLyZY.ttf",
                "italic": "//fonts.gstatic.com/s/archivonarrow/v5/vqsrtPCpTU3tJlKfuXP5zUpmlyBQEFfdE6dERLXdQGQ.ttf",
                "700italic": "//fonts.gstatic.com/s/archivonarrow/v5/wG6O733y5zHl4EKCOh8rSTg5KB8MNJ4uPAETq9naQO8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arima Madurai",
            "category": "display",
            "variants": [
                "100",
                "200",
                "300",
                "regular",
                "500",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v2",
            "lastModified": "2016-08-22",
            "files": {
                "100": "//fonts.gstatic.com/s/arimamadurai/v2/Q0tjl46beRRcUe3RlWWNrdyXLlNBCUjoM1yKFfVCFUI.ttf",
                "200": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4rArwWuxcSSKq67BdR6k5Rg.ttf",
                "300": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4joJ52uD-1fmXmi8u0n_zsc.ttf",
                "500": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4v_2zpxNHQ3utWt_82o9dAo.ttf",
                "700": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4qiiXuG_rGcOxkuidirlnJE.ttf",
                "800": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4khKLu0CevfTHM1eXjGnvQo.ttf",
                "900": "//fonts.gstatic.com/s/arimamadurai/v2/EsCGNPwBfkMk17-w_DTJ4kZ0oshA7r_PlGegwiHddT8.ttf",
                "regular": "//fonts.gstatic.com/s/arimamadurai/v2/8fNfThKRw_pr7MwgNdcHiW_MnNA9OgK8I1F23mNWOpE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arimo",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "hebrew",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/arimo/v9/ZItXugREyvV9LnbY_gxAmw.ttf",
                "regular": "//fonts.gstatic.com/s/arimo/v9/Gpeo80g-5ji2CcyXWnzh7g.ttf",
                "italic": "//fonts.gstatic.com/s/arimo/v9/_OdGbnX2-qQ96C4OjhyuPw.ttf",
                "700italic": "//fonts.gstatic.com/s/arimo/v9/__nOLWqmeXdhfr0g7GaFePesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arizonia",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/arizonia/v6/yzJqkHZqryZBTM7RKYV9Wg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Armata",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/armata/v6/1H8FwGgIRrbYtxSfXhOHlQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Artifika",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/artifika/v6/Ekfp4H4QG7D-WsABDOyj8g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arvo",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/arvo/v9/OB3FDST7U38u3OjPK_vvRQ.ttf",
                "regular": "//fonts.gstatic.com/s/arvo/v9/vvWPwz-PlZEwjOOIKqoZzA.ttf",
                "italic": "//fonts.gstatic.com/s/arvo/v9/id5a4BCjbenl5Gkqonw_Rw.ttf",
                "700italic": "//fonts.gstatic.com/s/arvo/v9/Hvl2MuWoXLaCy2v6MD4Yvw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Arya",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/arya/v1/N13tgOvG7VTXawiI-fJiQA.ttf",
                "regular": "//fonts.gstatic.com/s/arya/v1/xEVqtU3v8QLospHKpDaYEw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Asap",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/asap/v4/o5RUA7SsJ80M8oDFBnrDbg.ttf",
                "regular": "//fonts.gstatic.com/s/asap/v4/2lf-1MDR8tsTpEtvJmr2hA.ttf",
                "italic": "//fonts.gstatic.com/s/asap/v4/mwxNHf8QS8gNWCAMwkJNIg.ttf",
                "700italic": "//fonts.gstatic.com/s/asap/v4/_rZz9y2oXc09jT5T6BexLQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Asar",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/asar/v2/mSmn3H5CcMA84CZ586X7WQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Asset",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/asset/v6/hfPmqY-JzuR1lULlQf9iTg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Assistant",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "hebrew"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/assistant/v1/xXstfiHQzjB9j5ZxYTBoZy3USBnSvpkopQaUR-2r7iU.ttf",
                "300": "//fonts.gstatic.com/s/assistant/v1/vPC3tCw3LOzCSeGCtVp5Wi3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/assistant/v1/Y4UC5nQA69lWpfV0itoWLi3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/assistant/v1/dZywGH4pMxP6OVyrppOJxy3USBnSvpkopQaUR-2r7iU.ttf",
                "800": "//fonts.gstatic.com/s/assistant/v1/-mTR0sX8a0RsadH4AMDT8C3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/assistant/v1/2iDwv6DBtyixlK5YHngp1w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Astloch",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/astloch/v6/aPkhM2tL-tz1jX6aX2rvo_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/astloch/v6/fmbitVmHYLQP7MGPuFgpag.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Asul",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/asul/v5/uO8uNmxaq87-DdPmkEg5Gg.ttf",
                "regular": "//fonts.gstatic.com/s/asul/v5/9qpsNR_OOwyOYyo2N0IbBw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Athiti",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/athiti/v1/Ge5skdKwzxRPajVLdOJuIg.ttf",
                "300": "//fonts.gstatic.com/s/athiti/v1/OoT7lj4AaSp1JpGJLKn3CA.ttf",
                "500": "//fonts.gstatic.com/s/athiti/v1/W3pP-ANXfsMOVOG-cqqMFw.ttf",
                "600": "//fonts.gstatic.com/s/athiti/v1/kYx3dtUYNEuUlzWczYzsmQ.ttf",
                "700": "//fonts.gstatic.com/s/athiti/v1/tyXFOxQyZGXfqHhtqSikdw.ttf",
                "regular": "//fonts.gstatic.com/s/athiti/v1/e7eiIKP18Iz9Kg1xat6AYw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Atma",
            "category": "display",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "bengali",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/atma/v1/noxn2r6cT3JgmEDt6Ip5pQ.ttf",
                "500": "//fonts.gstatic.com/s/atma/v1/Htksg3ZXeAEbSvUdTQX-uw.ttf",
                "600": "//fonts.gstatic.com/s/atma/v1/EGUwD65ZZn9IIHp5Y36b4A.ttf",
                "700": "//fonts.gstatic.com/s/atma/v1/-fkXl3wADUHjobbwO9d-Wg.ttf",
                "regular": "//fonts.gstatic.com/s/atma/v1/dkXPrLoE_uqcgUFj4JdfRQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Atomic Age",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/atomicage/v7/WvBMe4FxANIKpo6Oi0mVJ_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Aubrey",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/aubrey/v8/zo9w8klO8bmOQIMajQ2aTA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Audiowide",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/audiowide/v4/yGcwRZB6VmoYhPUYT-mEow.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Autour One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/autourone/v5/2xmQBcg7FN72jaQRFZPIDvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Average",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/average/v4/aHUibBqdDbVYl5FM48pxyQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Average Sans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/averagesans/v4/dnU3R-5A_43y5bIyLztPsS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Averia Gruesa Libre",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/averiagruesalibre/v4/10vbZTOoN6T8D-nvDzwRFyXcKHuZXlCN8VkWHpkUzKM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Averia Libre",
            "category": "display",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/averialibre/v4/r6hGL8sSLm4dTzOPXgx5XacQoVhARpoaILP7amxE_8g.ttf",
                "700": "//fonts.gstatic.com/s/averialibre/v4/r6hGL8sSLm4dTzOPXgx5XUD2ttfZwueP-QU272T9-k4.ttf",
                "300italic": "//fonts.gstatic.com/s/averialibre/v4/I6wAYuAvOgT7el2ePj2nkina0FLWfcB-J_SAYmcAXaI.ttf",
                "regular": "//fonts.gstatic.com/s/averialibre/v4/rYVgHZZQICWnhjguGsBspC3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/averialibre/v4/1etzuoNxVHR8F533EkD1WfMZXuCXbOrAvx5R0IT5Oyo.ttf",
                "700italic": "//fonts.gstatic.com/s/averialibre/v4/I6wAYuAvOgT7el2ePj2nkvAs9-1nE9qOqhChW0m4nDE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Averia Sans Libre",
            "category": "display",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/averiasanslibre/v4/_9-jTfQjaBsWAF_yp5z-V4CP_KG_g80s1KXiBtJHoNc.ttf",
                "700": "//fonts.gstatic.com/s/averiasanslibre/v4/_9-jTfQjaBsWAF_yp5z-V8QwVOrz1y5GihpZmtKLhlI.ttf",
                "300italic": "//fonts.gstatic.com/s/averiasanslibre/v4/o7BEIK-fG3Ykc5Rzteh88YuyGu4JqttndUh4gRKxic0.ttf",
                "regular": "//fonts.gstatic.com/s/averiasanslibre/v4/yRJpjT39KxACO9F31mj_LqV8_KRn4epKAjTFK1s1fsg.ttf",
                "italic": "//fonts.gstatic.com/s/averiasanslibre/v4/COEzR_NPBSUOl3pFwPbPoCZU2HnUZT1xVKaIrHDioao.ttf",
                "700italic": "//fonts.gstatic.com/s/averiasanslibre/v4/o7BEIK-fG3Ykc5Rzteh88bXy1DXgmJcVtKjM5UWamMs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Averia Serif Libre",
            "category": "display",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/averiaseriflibre/v5/yvITAdr5D1nlsdFswJAb8SmC4gFJ2PHmfdVKEd_5S9M.ttf",
                "700": "//fonts.gstatic.com/s/averiaseriflibre/v5/yvITAdr5D1nlsdFswJAb8Q50KV5TaOVolur4zV2iZsg.ttf",
                "300italic": "//fonts.gstatic.com/s/averiaseriflibre/v5/YOLFXyye4sZt6AZk1QybCG2okl0bU63CauowU4iApig.ttf",
                "regular": "//fonts.gstatic.com/s/averiaseriflibre/v5/fdtF30xa_Erw0zAzOoG4BZqY66i8AUyI16fGqw0iAew.ttf",
                "italic": "//fonts.gstatic.com/s/averiaseriflibre/v5/o9qhvK9iT5iDWfyhQUe-6Ru_b0bTq5iipbJ9hhgHJ6U.ttf",
                "700italic": "//fonts.gstatic.com/s/averiaseriflibre/v5/YOLFXyye4sZt6AZk1QybCNxohRXP4tNDqG3X4Hqn21k.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bad Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/badscript/v5/cRyUs0nJ2eMQFHwBsZNRXfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloo/v1/uFkbq9GEAWUcT0XNeptJ1Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Bhai",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloobhai/v1/FQvpC-04bh2QINuWAdnNW_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Bhaina",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese",
                "oriya"
            ],
            "version": "v1",
            "lastModified": "2016-08-19",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloobhaina/v1/HxxbxOVf9WQem_hKo1MXSi3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Chettan",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "malayalam",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-08-19",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloochettan/v1/ODsFofLybGVOJ90e_EwdFbyYXtM25qb63HASTPtoTFA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Da",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "bengali",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/balooda/v1/RAJ0l2eJl_HDURCVxRE1iQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Paaji",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese",
                "gurmukhi"
            ],
            "version": "v1",
            "lastModified": "2016-08-19",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloopaaji/v1/KeqAjVRzso6QUEfpMLQ-7KCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Tamma",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "kannada",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-08-19",
            "files": {
                "regular": "//fonts.gstatic.com/s/balootamma/v1/-FKAYy14SAfG8Gc6YAAaMaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baloo Thambi",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/baloothambi/v1/qXK3dZIeU-O-HruaN5cK0y3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Balthazar",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/balthazar/v5/WgbaSIs6dJAGXJ0qbz2xlw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bangers",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bangers/v8/WAffdge5w99Xif-DLeqmcA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Basic",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/basic/v6/hNII2mS5Dxw5C0u_m3mXgA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Baumans",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/baumans/v5/o0bFdPW1H5kd5saqqOcoVg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Belgrano",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/belgrano/v6/iq8DUa2s7g6WRCeMiFrmtQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Belleza",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/belleza/v4/wchA3BWJlVqvIcSeNZyXew.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "BenchNine",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/benchnine/v4/ah9xtUy9wLQ3qnWa2p-piS3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/benchnine/v4/qZpi6ZVZg3L2RL_xoBLxWS3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/benchnine/v4/h3OAlYqU3aOeNkuXgH2Q2w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bentham",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/bentham/v6/5-Mo8Fe7yg5tzV0GlQIuzQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Berkshire Swash",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/berkshireswash/v4/4RZJjVRPjYnC2939hKCAimKfbtsIjCZP_edQljX9gR0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bevan",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/bevan/v7/Rtg3zDsCeQiaJ_Qno22OJA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bigelow Rules",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bigelowrules/v4/FEJCPLwo07FS-6SK6Al50X8f0n03UdmQgF_CLvNR2vg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bigshot One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bigshotone/v6/wSyZjBNTWDQHnvWE2jt6j6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bilbo",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bilbo/v6/-ty-lPs5H7OIucWbnpFrkA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bilbo Swash Caps",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bilboswashcaps/v7/UB_-crLvhx-PwGKW1oosDmYeFSdnSpRYv5h9gpdlD1g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "BioRhyme",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/biorhyme/v1/bj-6g_1gJHCc9xQZtLWL36CWcynf_cDxXwCLxiixG1c.ttf",
                "300": "//fonts.gstatic.com/s/biorhyme/v1/jWqHmLFlu30n7xp12uZd8qCWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/biorhyme/v1/36KN76U1iKt5TFDm2lBz0KCWcynf_cDxXwCLxiixG1c.ttf",
                "800": "//fonts.gstatic.com/s/biorhyme/v1/k6bYbUnESjLYnworWvSTL6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/biorhyme/v1/n6v5UkVPy_CjbP3fvsu1CA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "BioRhyme Expanded",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/biorhymeexpanded/v2/FKL4Vyxmq2vsiDrSOzz2sC7oxZzNh3ej55UHm-HviBI.ttf",
                "300": "//fonts.gstatic.com/s/biorhymeexpanded/v2/FKL4Vyxmq2vsiDrSOzz2sFu4cYPPksG4MRjB5UiYPPw.ttf",
                "700": "//fonts.gstatic.com/s/biorhymeexpanded/v2/FKL4Vyxmq2vsiDrSOzz2sMVisRVfPEfQ0jijOMQbr0Q.ttf",
                "800": "//fonts.gstatic.com/s/biorhymeexpanded/v2/FKL4Vyxmq2vsiDrSOzz2sIv1v1eCT6RPbcYZYQ1T1CE.ttf",
                "regular": "//fonts.gstatic.com/s/biorhymeexpanded/v2/hgBNpgjTRZzGmZxqN5OuVjndr_hij4ilAk2n1d1AhsE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Biryani",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/biryani/v1/Xx38YzyTFF8n6mRS1Yd88vesZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/biryani/v1/u-bneRbizmFMd0VQp5Ze6vesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/biryani/v1/1EdcPCVxBR2txgjrza6_YPesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/biryani/v1/qN2MTZ0j1sKSCtfXLB2dR_esZW2xOQ-xsNqO47m55DA.ttf",
                "800": "//fonts.gstatic.com/s/biryani/v1/DJyziS7FEy441v22InYdevesZW2xOQ-xsNqO47m55DA.ttf",
                "900": "//fonts.gstatic.com/s/biryani/v1/trcLkrIut0lM_PPSyQfAMPesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/biryani/v1/W7bfR8-IY76Xz0QoB8L2xw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bitter",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/bitter/v8/4dUtr_4BvHuoRU35suyOAg.ttf",
                "regular": "//fonts.gstatic.com/s/bitter/v8/w_BNdJvVZDRmqy5aSfB2kQ.ttf",
                "italic": "//fonts.gstatic.com/s/bitter/v8/TC0FZEVzXQIGgzmRfKPZbA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Black Ops One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/blackopsone/v7/2XW-DmDsGbDLE372KrMW1Yjjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bonbon",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bonbon/v7/IW3u1yzG1knyW5oz0s9_6Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Boogaloo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/boogaloo/v6/4Wu1tvFMoB80fSu8qLgQfQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bowlby One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bowlbyone/v7/eKpHjHfjoxM2bX36YNucefesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bowlby One SC",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bowlbyonesc/v8/8ZkeXftTuzKBtmxOYXoRedDkZCMxWJecxjvKm2f8MJw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Brawler",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/brawler/v6/3gfSw6imxQnQxweVITqUrg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bree Serif",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/breeserif/v5/5h9crBVIrvZqgf34FHcnEfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bubblegum Sans",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bubblegumsans/v5/Y9iTUUNz6lbl6TrvV4iwsytnKWgpfO2iSkLzTz-AABg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Bubbler One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/bubblerone/v4/e8S0qevkZAFaBybtt_SU4qCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Buda",
            "category": "display",
            "variants": [
                "300"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/buda/v6/hLtAmNUmEMJH2yx7NGUjnA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Buenard",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/buenard/v7/yUlGE115dGr7O9w9FlP3UvesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/buenard/v7/NSpMPGKAUgrLrlstYVvIXQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Butcherman",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/butcherman/v7/bxiJmD567sPBVpJsT0XR0vesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Butterfly Kids",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/butterflykids/v4/J4NTF5M25htqeTffYImtlUZaDk62iwTBnbnvwSjZciA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cabin",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/cabin/v9/HgsCQ-k3_Z_uQ86aFolNBg.ttf",
                "600": "//fonts.gstatic.com/s/cabin/v9/eUDAvKhBtmTCkeVBsFk34A.ttf",
                "700": "//fonts.gstatic.com/s/cabin/v9/4EKhProuY1hq_WCAomq9Dg.ttf",
                "regular": "//fonts.gstatic.com/s/cabin/v9/XeuAFYo2xAPHxZGBbQtHhA.ttf",
                "italic": "//fonts.gstatic.com/s/cabin/v9/0tJ9k3DI5xC4GBgs1E_Jxw.ttf",
                "500italic": "//fonts.gstatic.com/s/cabin/v9/50sjhrGE0njyO-7mGDhGP_esZW2xOQ-xsNqO47m55DA.ttf",
                "600italic": "//fonts.gstatic.com/s/cabin/v9/sFQpQDBd3G2om0Nl5dD2CvesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/cabin/v9/K83QKi8MOKLEqj6bgZ7LrfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cabin Condensed",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/cabincondensed/v8/Ez4zJbsGr2BgXcNUWBVgEARL_-ABKXdjsJSPT0lc2Bk.ttf",
                "600": "//fonts.gstatic.com/s/cabincondensed/v8/Ez4zJbsGr2BgXcNUWBVgELS5sSASxc8z4EQTQj7DCAI.ttf",
                "700": "//fonts.gstatic.com/s/cabincondensed/v8/Ez4zJbsGr2BgXcNUWBVgEMAWgzcA047xWLixhLCofl8.ttf",
                "regular": "//fonts.gstatic.com/s/cabincondensed/v8/B0txb0blf2N29WdYPJjMSiQPsWWoiv__AzYJ9Zzn9II.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cabin Sketch",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cabinsketch/v9/ki3SSN5HMOO0-IOLOj069ED2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/cabinsketch/v9/d9fijO34zQajqQvl3YHRCS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Caesar Dressing",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/caesardressing/v5/2T_WzBgE2Xz3FsyJMq34T9gR43u4FvCuJwIfF5Zxl6Y.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cagliostro",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cagliostro/v5/i85oXbtdSatNEzss99bpj_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cairo",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "600",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/cairo/v1/9BU6Hrio9syG9zwo_CNPXg.ttf",
                "300": "//fonts.gstatic.com/s/cairo/v1/mpy3SIEJVOIfFnVLujcRDg.ttf",
                "600": "//fonts.gstatic.com/s/cairo/v1/Ct_3a0tcTEyNNSnuZKDd7g.ttf",
                "700": "//fonts.gstatic.com/s/cairo/v1/ONxTSBYfmg-V5CkIwS_5gQ.ttf",
                "900": "//fonts.gstatic.com/s/cairo/v1/Fm-hIVCp5OI5mO4Ec71jcw.ttf",
                "regular": "//fonts.gstatic.com/s/cairo/v1/-tPnHq7mmAjcjJRSjsuZGA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Calligraffitti",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/calligraffitti/v7/vLVN2Y-z65rVu1R7lWdvyDXz_orj3gX0_NzfmYulrko.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cambay",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cambay/v1/jw9niBxa04eEhnSwTWCEgw.ttf",
                "regular": "//fonts.gstatic.com/s/cambay/v1/etU9Bab4VuhzS-OKsb1VXg.ttf",
                "italic": "//fonts.gstatic.com/s/cambay/v1/ZEz9yNqpEOgejaw1rBhugQ.ttf",
                "700italic": "//fonts.gstatic.com/s/cambay/v1/j-5v_uUr0NXTumWN0siOiaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cambo",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cambo/v5/PnwpRuTdkYCf8qk4ajmNRA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Candal",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/candal/v6/x44dDW28zK7GR1gGDBmj9g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cantarell",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/cantarell/v6/Yir4ZDsCn4g1kWopdg-ehC3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/cantarell/v6/p5ydP_uWQ5lsFzcP_XVMEw.ttf",
                "italic": "//fonts.gstatic.com/s/cantarell/v6/DTCLtOSqP-7dgM-V_xKUjqCWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/cantarell/v6/weehrwMeZBXb0QyrWnRwFXe1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cantata One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/cantataone/v6/-a5FDvnBqaBMDaGgZYnEfqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cantora One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cantoraone/v5/oI-DS62RbHI8ZREjp73ehqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Capriola",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/capriola/v4/JxXPlkdzWwF9Cwelbvi9jA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cardo",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cardo/v8/lQN30weILimrKvp8rZhF1w.ttf",
                "regular": "//fonts.gstatic.com/s/cardo/v8/jbkF2_R0FKUEZTq5dwSknQ.ttf",
                "italic": "//fonts.gstatic.com/s/cardo/v8/pcv4Np9tUkq0YREYUcEEJQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Carme",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/carme/v7/08E0NP1eRBEyFRUadmMfgA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Carrois Gothic",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/carroisgothic/v5/GCgb7bssGpwp7V5ynxmWy2x3d0cwUleGuRTmCYfCUaM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Carrois Gothic SC",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/carroisgothicsc/v5/bVp4nhwFIXU-r3LqUR8DSJTdPW1ioadGi2uRiKgJVCY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Carter One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/carterone/v8/5X_LFvdbcB7OBG7hBgZ7fPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Catamaran",
            "category": "sans-serif",
            "variants": [
                "100",
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/catamaran/v1/ilWHBiy0krUPdlmYxDuqC6CWcynf_cDxXwCLxiixG1c.ttf",
                "200": "//fonts.gstatic.com/s/catamaran/v1/hFc-HKSsGk6M-psujei1MC3USBnSvpkopQaUR-2r7iU.ttf",
                "300": "//fonts.gstatic.com/s/catamaran/v1/Aaag4ccR7Oh_4eai-jbrYC3USBnSvpkopQaUR-2r7iU.ttf",
                "500": "//fonts.gstatic.com/s/catamaran/v1/83WSX3F86qsvj1Z4EI0tQi3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/catamaran/v1/a9PlHHnuBWiGGk0TwuFKTi3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/catamaran/v1/PpgVtUHUdnBZYNpnzGbScy3USBnSvpkopQaUR-2r7iU.ttf",
                "800": "//fonts.gstatic.com/s/catamaran/v1/6VjB_uSfn3DZ93IQv58CmC3USBnSvpkopQaUR-2r7iU.ttf",
                "900": "//fonts.gstatic.com/s/catamaran/v1/5ys9TqpQc9Q6gHqbSox6py3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/catamaran/v1/MdNkM-DU8f6R-25Nxpr_XA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Caudex",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/caudex/v6/PetCI4GyQ5Q3LiOzUu_mMg.ttf",
                "regular": "//fonts.gstatic.com/s/caudex/v6/PWEexiHLDmQbn2b1OPZWfg.ttf",
                "italic": "//fonts.gstatic.com/s/caudex/v6/XjMZF6XCisvV3qapD4oJdw.ttf",
                "700italic": "//fonts.gstatic.com/s/caudex/v6/yT8YeHLjaJvQXlUEYOA8gqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Caveat",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/caveat/v2/LkaFtQENGJry2eUMwGRTeA.ttf",
                "regular": "//fonts.gstatic.com/s/caveat/v2/8I23b6N-6rRVbh-C_Vx3yA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Caveat Brush",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/caveatbrush/v2/_d7bgsk3hfC4DXnUEeYKsy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cedarville Cursive",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/cedarvillecursive/v7/cuCe6HrkcqrWTWTUE7dw-41zwq9-z_Lf44CzRAA0d0Y.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ceviche One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cevicheone/v7/WOaXIMBD4VYMy39MsobJhKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Changa",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/changa/v2/QNWVD9FzsnhVmHzE7HryDQ.ttf",
                "300": "//fonts.gstatic.com/s/changa/v2/OKZ0H1bMg3M9EZMVzgQ9fg.ttf",
                "500": "//fonts.gstatic.com/s/changa/v2/KrXcHYf9ILB8aFWCj0Vfxg.ttf",
                "600": "//fonts.gstatic.com/s/changa/v2/6uCpqxwcsYkfV0M8Ls6WPA.ttf",
                "700": "//fonts.gstatic.com/s/changa/v2/vAXzeaPkdpxlejFN7h0ibw.ttf",
                "800": "//fonts.gstatic.com/s/changa/v2/H3IsiH2Fx0Pc4_OU4HSpng.ttf",
                "regular": "//fonts.gstatic.com/s/changa/v2/7_e8qktkj6uKM0DamZJY9Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Changa One",
            "category": "display",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/changaone/v9/dr4qjce4W3kxFrZRkVD87fesZW2xOQ-xsNqO47m55DA.ttf",
                "italic": "//fonts.gstatic.com/s/changaone/v9/wJVQlUs1lAZel-WdTo2U9y3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chango",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/chango/v5/3W3AeMMtRTH08t5qLOjBmg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chathura",
            "category": "sans-serif",
            "variants": [
                "100",
                "300",
                "regular",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/chathura/v1/7tUse0wFXIOSPewsdeNXPvesZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/chathura/v1/Gmhr6ULHnPDt9spOZrHOfKCWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/chathura/v1/BO9LvNAseMQ3n1tKWH-uTKCWcynf_cDxXwCLxiixG1c.ttf",
                "800": "//fonts.gstatic.com/s/chathura/v1/prh_X_5NSsBQefIdGi5B6KCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/chathura/v1/7hRNO-_zjRopkcP2n1rr8g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chau Philomene One",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/chauphilomeneone/v5/KKc5egCL-a2fFVoOA2x6tBFi5dxgSTdxqnMJgWkBJcg.ttf",
                "italic": "//fonts.gstatic.com/s/chauphilomeneone/v5/eJj1PY_iN4KiIuyOvtMHJP6uyLkxyiC4WcYA74sfquE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chela One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/chelaone/v5/h5O0dEnpnIq6jQnWxZybrA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chelsea Market",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/chelseamarket/v4/qSdzwh2A4BbNemy78sJLfAAI1i8fIftCBXsBF2v9UMI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cherry Cream Soda",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/cherrycreamsoda/v6/OrD-AUnFcZeeKa6F_c0_WxOiHiuAPYA9ry3O1RG2XIU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cherry Swash",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/cherryswash/v4/-CfyMyQqfucZPQNB0nvYyED2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/cherryswash/v4/HqOk7C7J1TZ5i3L-ejF0vi3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chewy",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/chewy/v7/hcDN5cvQdIu6Bx4mg_TSyw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chicle",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/chicle/v5/xg4q57Ut9ZmyFwLp51JLgg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chivo",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "900": "//fonts.gstatic.com/s/chivo/v7/JAdkiWd46QCW4vOsj3dzTA.ttf",
                "regular": "//fonts.gstatic.com/s/chivo/v7/L88PEuzS9eRfHRZhAPhZyw.ttf",
                "italic": "//fonts.gstatic.com/s/chivo/v7/Oe3-Q-a2kBzPnhHck_baMg.ttf",
                "900italic": "//fonts.gstatic.com/s/chivo/v7/LoszYnE86q2wJEOjCigBQ_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Chonburi",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/chonburi/v1/jd9PfbW0x_8Myt_XeUxvSQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cinzel",
            "category": "serif",
            "variants": [
                "regular",
                "700",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cinzel/v4/nYcFQ6_3pf_6YDrOFjBR8Q.ttf",
                "900": "//fonts.gstatic.com/s/cinzel/v4/FTBj72ozM2cEOSxiVsRb3A.ttf",
                "regular": "//fonts.gstatic.com/s/cinzel/v4/GF7dy_Nc-a6EaHYSyGd-EA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cinzel Decorative",
            "category": "display",
            "variants": [
                "regular",
                "700",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cinzeldecorative/v4/pXhIVnhFtL_B9Vb1wq2F95-YYVDmZkJErg0zgx9XuZI.ttf",
                "900": "//fonts.gstatic.com/s/cinzeldecorative/v4/pXhIVnhFtL_B9Vb1wq2F97Khqbv0zQZa0g-9HOXAalU.ttf",
                "regular": "//fonts.gstatic.com/s/cinzeldecorative/v4/fmgK7oaJJIXAkhd9798yQgT5USbJx2F82lQbogPy2bY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Clicker Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/clickerscript/v4/Zupmk8XwADjufGxWB9KThBnpV0hQCek3EmWnCPrvGRM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Coda",
            "category": "display",
            "variants": [
                "regular",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v11",
            "lastModified": "2016-05-31",
            "files": {
                "800": "//fonts.gstatic.com/s/coda/v11/6ZIw0sbALY0KTMWllZB3hQ.ttf",
                "regular": "//fonts.gstatic.com/s/coda/v11/yHDvulhg-P-p2KRgRrnUYw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Coda Caption",
            "category": "sans-serif",
            "variants": [
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "800": "//fonts.gstatic.com/s/codacaption/v9/YDl6urZh-DUFhiMBTgAnz_qsay_1ZmRGmC8pVRdIfAg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Codystar",
            "category": "display",
            "variants": [
                "300",
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/codystar/v4/EVaUzfJkcb8Zqx9kzQLXqqCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/codystar/v4/EN-CPFKYowSI7SuR7-0cZA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Coiny",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/coiny/v1/B-pC9lRxssd2RDK37Rdekw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Combo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/combo/v5/Nab98KjR3JZSSPGtzLyXNw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Comfortaa",
            "category": "display",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/comfortaa/v7/r_tUZNl0G8xCoOmp_JkSCi3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/comfortaa/v7/fND5XPYKrF2tQDwwfWZJIy3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/comfortaa/v7/lZx6C1VViPgSOhCBUP7hXA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Coming Soon",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/comingsoon/v6/Yz2z3IAe2HSQAOWsSG8COKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Concert One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/concertone/v7/N5IWCIGhUNdPZn_efTxKN6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Condiment",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/condiment/v4/CstmdiPpgFSV0FUNL5LrJA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Contrail One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/contrailone/v6/b41KxjgiyqX-hkggANDU6C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Convergence",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/convergence/v5/eykrGz1NN_YpQmkAZjW-qKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cookie",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cookie/v7/HxeUC62y_YdDbiFlze357A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Copse",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/copse/v6/wikLrtPGjZDvZ5w2i5HLWg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Corben",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/corben/v9/lirJaFSQWdGQuV--fksg5g.ttf",
                "regular": "//fonts.gstatic.com/s/corben/v9/tTysMZkt-j8Y5yhkgsoajQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant",
            "category": "serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorant/v1/diggKPcUerIA8GQWRVxsVS3USBnSvpkopQaUR-2r7iU.ttf",
                "500": "//fonts.gstatic.com/s/cormorant/v1/lwoiMb1lzDf49h802vpRUy3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/cormorant/v1/LKEtp8XimHLN0gSYqnV9qy3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/cormorant/v1/vOi7JV5F3JmPzXDgUqUwgS3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/cormorant/v1/UydD9tmk-DfLnEFRr_bBZy9-WlPSxbfiI49GsXo3q0g.ttf",
                "regular": "//fonts.gstatic.com/s/cormorant/v1/9vWr5LgrNEgvhv1P3z9uuQ.ttf",
                "italic": "//fonts.gstatic.com/s/cormorant/v1/zzcH3j00ejnIc8jicdcz6KCWcynf_cDxXwCLxiixG1c.ttf",
                "500italic": "//fonts.gstatic.com/s/cormorant/v1/UydD9tmk-DfLnEFRr_bBZ8CNfqCYlB_eIx7H1TVXe60.ttf",
                "600italic": "//fonts.gstatic.com/s/cormorant/v1/UydD9tmk-DfLnEFRr_bBZ5Z7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700italic": "//fonts.gstatic.com/s/cormorant/v1/UydD9tmk-DfLnEFRr_bBZ3e1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant Garamond",
            "category": "serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorantgaramond/v1/iEjm9hVxcattz37Y8gZwVXDeRRUpi2fYbqcTC9PsYaU.ttf",
                "500": "//fonts.gstatic.com/s/cormorantgaramond/v1/iEjm9hVxcattz37Y8gZwVSkwnhSVYGQY4MSUB3uw374.ttf",
                "600": "//fonts.gstatic.com/s/cormorantgaramond/v1/iEjm9hVxcattz37Y8gZwVVc2xdGA7R8efE0K6NwSoyI.ttf",
                "700": "//fonts.gstatic.com/s/cormorantgaramond/v1/iEjm9hVxcattz37Y8gZwVdNg01MkafbqNYmDx8wt95c.ttf",
                "300italic": "//fonts.gstatic.com/s/cormorantgaramond/v1/zuqx3k1yUEl3Eavo-ZPEAjZXe39LdglsIzDOvKnCCso.ttf",
                "regular": "//fonts.gstatic.com/s/cormorantgaramond/v1/EI2hhCO6kSfLAy-Dpd8fd7_BES7rBA-D9Lo3vCx9yHc.ttf",
                "italic": "//fonts.gstatic.com/s/cormorantgaramond/v1/eGTlzchVxDKKvK6d7drzlkVlEttMzBRhK_wsRQ4MqEE.ttf",
                "500italic": "//fonts.gstatic.com/s/cormorantgaramond/v1/zuqx3k1yUEl3Eavo-ZPEAq8qrY1CcUgPLrA3ytfr3SY.ttf",
                "600italic": "//fonts.gstatic.com/s/cormorantgaramond/v1/zuqx3k1yUEl3Eavo-ZPEAqms9Rm_p2hhD4xhClOGPEw.ttf",
                "700italic": "//fonts.gstatic.com/s/cormorantgaramond/v1/zuqx3k1yUEl3Eavo-ZPEAvEntfLz8TC-DlAIEJQEwCA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant Infant",
            "category": "serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorantinfant/v1/MYRpw6pQIf0XStsiZXQWA_alucuYFvoGqpCMGloCN2Y.ttf",
                "500": "//fonts.gstatic.com/s/cormorantinfant/v1/MYRpw6pQIf0XStsiZXQWA4PJQ8Vh-2Qw35Pq7cVYzdo.ttf",
                "600": "//fonts.gstatic.com/s/cormorantinfant/v1/MYRpw6pQIf0XStsiZXQWA9G0tNuOpbNMRdNl4S5e-n0.ttf",
                "700": "//fonts.gstatic.com/s/cormorantinfant/v1/MYRpw6pQIf0XStsiZXQWAx-3ZynwDtU_450Ho62jf_I.ttf",
                "300italic": "//fonts.gstatic.com/s/cormorantinfant/v1/PK34LKusK6SSQFR2m5-LZgNCjGMFnYSoo4kW2wZNowE.ttf",
                "regular": "//fonts.gstatic.com/s/cormorantinfant/v1/q5F0I_a42y_qtMoOtqdjagGlf-pqPDOheSBqZOVpkRo.ttf",
                "italic": "//fonts.gstatic.com/s/cormorantinfant/v1/U6OamtMgLoVs0zd53Z1pNpbq6_N3pcDBvA-VsecMIAA.ttf",
                "500italic": "//fonts.gstatic.com/s/cormorantinfant/v1/PK34LKusK6SSQFR2m5-LZq9x-au7fLBTFpfuT52_G64.ttf",
                "600italic": "//fonts.gstatic.com/s/cormorantinfant/v1/PK34LKusK6SSQFR2m5-LZkZbdnTqrL_1WMEFjxg0OwY.ttf",
                "700italic": "//fonts.gstatic.com/s/cormorantinfant/v1/PK34LKusK6SSQFR2m5-LZmKEEmz9BBHY1o7RrRAiUXQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant SC",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorantsc/v1/CCo4fI9EYzhUJcvojQ9Em6cQoVhARpoaILP7amxE_8g.ttf",
                "500": "//fonts.gstatic.com/s/cormorantsc/v1/CCo4fI9EYzhUJcvojQ9Em5MQuUSAwdHsY8ov_6tk1oA.ttf",
                "600": "//fonts.gstatic.com/s/cormorantsc/v1/CCo4fI9EYzhUJcvojQ9Em2v8CylhIUtwUiYO7Z2wXbE.ttf",
                "700": "//fonts.gstatic.com/s/cormorantsc/v1/CCo4fI9EYzhUJcvojQ9Em0D2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/cormorantsc/v1/o2HxNCgvhmwJdltu-68tzC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant Unicase",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorantunicase/v1/-0mwRHhjEGfrz-UDHJ_78TyAYAK5JX1-zBpfFXu9t3Y.ttf",
                "500": "//fonts.gstatic.com/s/cormorantunicase/v1/-0mwRHhjEGfrz-UDHJ_78WActzpz5sLElWWJpZBcHK4.ttf",
                "600": "//fonts.gstatic.com/s/cormorantunicase/v1/-0mwRHhjEGfrz-UDHJ_78U0bQT13XmwBbvkXy6Yb64Y.ttf",
                "700": "//fonts.gstatic.com/s/cormorantunicase/v1/-0mwRHhjEGfrz-UDHJ_78Z5CFeQBXku3ADXbkP2V7W8.ttf",
                "regular": "//fonts.gstatic.com/s/cormorantunicase/v1/THO7JMNV6qRoZlg7dU5RUz01TLsHlMvD1uPU3gXOh9s.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cormorant Upright",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/cormorantupright/v1/PwJT_lCdbLUyVq-tARIPhjCfCvaSiUMfec2BKBTMAaw.ttf",
                "500": "//fonts.gstatic.com/s/cormorantupright/v1/PwJT_lCdbLUyVq-tARIPhiWhx5Kr-bzfZXhgF-AnSvk.ttf",
                "600": "//fonts.gstatic.com/s/cormorantupright/v1/PwJT_lCdbLUyVq-tARIPhuDigFx2V_wQ4SOTZdg5a2s.ttf",
                "700": "//fonts.gstatic.com/s/cormorantupright/v1/PwJT_lCdbLUyVq-tARIPhuO6SP7lRr11seyd3AkK37Q.ttf",
                "regular": "//fonts.gstatic.com/s/cormorantupright/v1/0n68kajKjTOJn9EPQkf1a-ojtTJJf2MtgkoRSid3NcM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Courgette",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/courgette/v4/2YO0EYtyE9HUPLZprahpZA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cousine",
            "category": "monospace",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "hebrew",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v10",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/cousine/v10/FXEOnNUcCzhdtoBxiq-lovesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/cousine/v10/GYX4bPXObJNJo63QJEUnLg.ttf",
                "italic": "//fonts.gstatic.com/s/cousine/v10/1WtIuajLoo8vjVwsrZ3eOg.ttf",
                "700italic": "//fonts.gstatic.com/s/cousine/v10/y_AZ5Sz-FwL1lux2xLSTZS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Coustard",
            "category": "serif",
            "variants": [
                "regular",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "900": "//fonts.gstatic.com/s/coustard/v6/W02OCWO6OfMUHz6aVyegQ6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/coustard/v6/iO2Rs5PmqAEAXoU3SkMVBg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Covered By Your Grace",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/coveredbyyourgrace/v6/6ozZp4BPlrbDRWPe3EBGA6CVUMdvnk-GcAiZQrX9Gek.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Crafty Girls",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/craftygirls/v5/0Sv8UWFFdhQmesHL32H8oy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Creepster",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/creepster/v5/0vdr5kWJ6aJlOg5JvxnXzQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Crete Round",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/creteround/v5/B8EwN421qqOCCT8vOH4wJ6CWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/creteround/v5/5xAt7XK2vkUdjhGtt98unUeOrDcLawS7-ssYqLr2Xp4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Crimson Text",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "600": "//fonts.gstatic.com/s/crimsontext/v6/rEy5tGc5HdXy56Xvd4f3I2v8CylhIUtwUiYO7Z2wXbE.ttf",
                "700": "//fonts.gstatic.com/s/crimsontext/v6/rEy5tGc5HdXy56Xvd4f3I0D2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/crimsontext/v6/3IFMwfRa07i-auYR-B-zNS3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/crimsontext/v6/a5QZnvmn5amyNI-t2BMkWPMZXuCXbOrAvx5R0IT5Oyo.ttf",
                "600italic": "//fonts.gstatic.com/s/crimsontext/v6/4j4TR-EfnvCt43InYpUNDIR-5-urNOGAobhAyctHvW8.ttf",
                "700italic": "//fonts.gstatic.com/s/crimsontext/v6/4j4TR-EfnvCt43InYpUNDPAs9-1nE9qOqhChW0m4nDE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Croissant One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/croissantone/v4/mPjsOObnC77fp1cvZlOfIYjjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Crushed",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/crushed/v6/aHwSejs3Kt0Lg95u7j32jA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cuprum",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/cuprum/v7/6tl3_FkDeXSD72oEHuJh4w.ttf",
                "regular": "//fonts.gstatic.com/s/cuprum/v7/JgXs0F_UiaEdAS74msmFNg.ttf",
                "italic": "//fonts.gstatic.com/s/cuprum/v7/cLEz0KV6OxInnktSzpk58g.ttf",
                "700italic": "//fonts.gstatic.com/s/cuprum/v7/bnkXaBfoYvaJ75axRPSwVKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cutive",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cutive/v8/G2bW-ImyOCwKxBkLyz39YQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Cutive Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/cutivemono/v4/ncWQtFVKcSs8OW798v30k6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Damion",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/damion/v6/13XtECwKxhD_VrOqXL4SiA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dancing Script",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/dancingscript/v7/KGBfwabt0ZRLA5W1ywjowb_dAmXiKjTPGCuO6G2MbfA.ttf",
                "regular": "//fonts.gstatic.com/s/dancingscript/v7/DK0eTGXiZjN6yA8zAEyM2RnpV0hQCek3EmWnCPrvGRM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "David Libre",
            "category": "serif",
            "variants": [
                "regular",
                "500",
                "700"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "500": "//fonts.gstatic.com/s/davidlibre/v1/ea-623K8OFNeGhfSzdpmysCNfqCYlB_eIx7H1TVXe60.ttf",
                "700": "//fonts.gstatic.com/s/davidlibre/v1/ea-623K8OFNeGhfSzdpmyne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/davidlibre/v1/Fp_YuX4CP0pzlSUtACdOo6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dawning of a New Day",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/dawningofanewday/v7/JiDsRhiKZt8uz3NJ5xA06gXLnohmOYWQZqo_sW8GLTk.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Days One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/daysone/v6/kzwZjNhc1iabMsrc_hKBIA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dekko",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v3",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/dekko/v3/AKtgABKC1rUxgIgS-bpojw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Delius",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/delius/v6/TQA163qafki2-gV-B6F_ag.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Delius Swash Caps",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/deliusswashcaps/v8/uXyrEUnoWApxIOICunRq7yIrxb5zDVgU2N3VzXm7zq4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Delius Unicase",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/deliusunicase/v9/7FTMTITcb4dxUp99FAdTqNy5weKXdcrx-wE0cgECMq8.ttf",
                "regular": "//fonts.gstatic.com/s/deliusunicase/v9/b2sKujV3Q48RV2PQ0k1vqu6rPKfVZo7L2bERcf0BDns.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Della Respira",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/dellarespira/v4/F4E6Lo_IZ6L9AJCcbqtDVeDcg5akpSnIcsPhLOFv7l8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Denk One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/denkone/v4/TdXOeA4eA_hEx4W8Sh9wPw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Devonshire",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/devonshire/v5/I3ct_2t12SYizP8ZC-KFi_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dhurjati",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/dhurjati/v4/uV6jO5e2iFMbGB0z79Cy5g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Didact Gothic",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/didactgothic/v7/v8_72sD3DYMKyM0dn3LtWotBLojGU5Qdl8-5NL4v70w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Diplomata",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/diplomata/v8/u-ByBiKgN6rTMA36H3kcKg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Diplomata SC",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/diplomatasc/v5/JdVwAwfE1a_pahXjk5qpNi3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Domine",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/domine/v4/phBcG1ZbQFxUIt18hPVxnw.ttf",
                "regular": "//fonts.gstatic.com/s/domine/v4/wfVIgamVFjMNQAEWurCiHA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Donegal One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/donegalone/v4/6kN4-fDxz7T9s5U61HwfF6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Doppio One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/doppioone/v4/WHZ3HJQotpk_4aSMNBo_t_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dorsa",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/dorsa/v7/wCc3cUe6XrmG2LQE6GlIrw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dosis",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/dosis/v6/ztftab0r6hcd7AeurUGrSQ.ttf",
                "300": "//fonts.gstatic.com/s/dosis/v6/awIB6L0h5mb0plIKorXmuA.ttf",
                "500": "//fonts.gstatic.com/s/dosis/v6/ruEXDOFMxDPGnjCBKRqdAQ.ttf",
                "600": "//fonts.gstatic.com/s/dosis/v6/KNAswRNwm3tfONddYyidxg.ttf",
                "700": "//fonts.gstatic.com/s/dosis/v6/AEEAj0ONidK8NQQMBBlSig.ttf",
                "800": "//fonts.gstatic.com/s/dosis/v6/nlrKd8E69vvUU39XGsvR7Q.ttf",
                "regular": "//fonts.gstatic.com/s/dosis/v6/rJRlixu-w0JZ1MyhJpao_Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dr Sugiyama",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/drsugiyama/v5/S5Yx3MIckgoyHhhS4C9Tv6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Droid Sans",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/droidsans/v6/EFpQQyG9GqCrobXxL-KRMQJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/droidsans/v6/rS9BT6-asrfjpkcV3DXf__esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Droid Sans Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/droidsansmono/v7/ns-m2xQYezAtqh7ai59hJcwD6PD0c3_abh9zHKQtbGU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Droid Serif",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/droidserif/v6/QQt14e8dY39u-eYBZmppwXe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/droidserif/v6/DgAtPy6rIVa2Zx3Xh9KaNaCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/droidserif/v6/cj2hUnSRBhwmSPr9kS5890eOrDcLawS7-ssYqLr2Xp4.ttf",
                "700italic": "//fonts.gstatic.com/s/droidserif/v6/c92rD_x0V1LslSFt3-QEps_zJjSACmk0BRPxQqhnNLU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Duru Sans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/durusans/v9/xn7iYH8xwmSyTvEV_HOxTw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Dynalight",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/dynalight/v5/-CWsIe8OUDWTIHjSAh41kA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "EB Garamond",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/ebgaramond/v7/CDR0kuiFK7I1OZ2hSdR7G6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Eagle Lake",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/eaglelake/v4/ZKlYin7caemhx9eSg6RvPfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Eater",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/eater/v5/gm6f3OmYEdbs3lPQtUfBkA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Economica",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/economica/v4/UK4l2VEpwjv3gdcwbwXE9C3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/economica/v4/G4rJRujzZbq9Nxngu9l3hg.ttf",
                "italic": "//fonts.gstatic.com/s/economica/v4/p5O9AVeUqx_n35xQRinNYaCWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/economica/v4/ac5dlUsedQ03RqGOeay-3Xe1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Eczar",
            "category": "serif",
            "variants": [
                "regular",
                "500",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "500": "//fonts.gstatic.com/s/eczar/v4/Ooe4KaPp2594tF8TbMfdlQ.ttf",
                "600": "//fonts.gstatic.com/s/eczar/v4/IjQsWW0bmgkZ6lnN72cnTQ.ttf",
                "700": "//fonts.gstatic.com/s/eczar/v4/ELC8RVXfBMb3VuuHtMwBOA.ttf",
                "800": "//fonts.gstatic.com/s/eczar/v4/9Uyt6nTZLx_Qj5_WRah-iQ.ttf",
                "regular": "//fonts.gstatic.com/s/eczar/v4/uKZcAQ5JBBs1UbeXFRbBRg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "El Messiri",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "arabic"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "500": "//fonts.gstatic.com/s/elmessiri/v1/kQW9PA2krAOzditagrX75pp-63r6doWhTEbsfBIRJ7A.ttf",
                "600": "//fonts.gstatic.com/s/elmessiri/v1/HYl7TNqFfA1utGLZRWwzLPpTEJqju4Hz1txDWij77d4.ttf",
                "700": "//fonts.gstatic.com/s/elmessiri/v1/ji73glXFIetaSqMU3cz7rAJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/elmessiri/v1/dik94vfrFvHFnvdvxaX8N_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Electrolize",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/electrolize/v5/yFVu5iokC-nt4B1Cyfxb9aCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Elsie",
            "category": "display",
            "variants": [
                "regular",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "900": "//fonts.gstatic.com/s/elsie/v5/1t-9f0N2NFYwAgN7oaISqg.ttf",
                "regular": "//fonts.gstatic.com/s/elsie/v5/gwspePauE45BJu6Ok1QrfQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Elsie Swash Caps",
            "category": "display",
            "variants": [
                "regular",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "900": "//fonts.gstatic.com/s/elsieswashcaps/v4/iZnus9qif0tR5pGaDv5zdKoKBWBozTtxi30NfZDOXXU.ttf",
                "regular": "//fonts.gstatic.com/s/elsieswashcaps/v4/9L3hIJMPCf6sxCltnxd6X2YeFSdnSpRYv5h9gpdlD1g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Emblema One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/emblemaone/v5/7IlBUjBWPIiw7cr_O2IfSaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Emilys Candy",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/emilyscandy/v4/PofLVm6v1SwZGOzC8s-I3S3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Engagement",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/engagement/v5/4Uz0Jii7oVPcaFRYmbpU6vesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Englebert",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/englebert/v4/sll38iOvOuarDTYBchlP3Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Enriqueta",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/enriqueta/v5/I27Pb-wEGH2ajLYP0QrtSC3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/enriqueta/v5/_p90TrIwR1SC-vDKtmrv6A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Erica One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ericaone/v7/cIBnH2VAqQMIGYAcE4ufvQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Esteban",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/esteban/v4/ESyhLgqDDyK5JcFPp2svDw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Euphoria Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/euphoriascript/v4/c4XB4Iijj_NvSsCF4I0O2MxLhO8OSNnfAp53LK1_iRs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ewert",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ewert/v4/Em8hrzuzSbfHcTVqMjbAQg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Exo",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/exo/v4/RI7A9uwjRmPbVp0n8e-Jvg.ttf",
                "200": "//fonts.gstatic.com/s/exo/v4/F8OfC_swrRRxpFt-tlXZQg.ttf",
                "300": "//fonts.gstatic.com/s/exo/v4/SBrN7TKUqgGUvfxqHqsnNw.ttf",
                "500": "//fonts.gstatic.com/s/exo/v4/jCg6DmGGXt_OVyp5ofQHPw.ttf",
                "600": "//fonts.gstatic.com/s/exo/v4/q_SG5kXUmOcIvFpgtdZnlw.ttf",
                "700": "//fonts.gstatic.com/s/exo/v4/3_jwsL4v9uHjl5Q37G57mw.ttf",
                "800": "//fonts.gstatic.com/s/exo/v4/yLPuxBuV0lzqibRJyooOJg.ttf",
                "900": "//fonts.gstatic.com/s/exo/v4/97d0nd6Yv4-SA_X92xAuZA.ttf",
                "100italic": "//fonts.gstatic.com/s/exo/v4/qtGyZZlWb2EEvby3ZPosxw.ttf",
                "200italic": "//fonts.gstatic.com/s/exo/v4/fr4HBfXHYiIngW2_bhlgRw.ttf",
                "300italic": "//fonts.gstatic.com/s/exo/v4/3gmiLjBegIfcDLISjTGA1g.ttf",
                "regular": "//fonts.gstatic.com/s/exo/v4/eUEzTFueNXRVhbt4PEB8kQ.ttf",
                "italic": "//fonts.gstatic.com/s/exo/v4/cfgolWisMSURhpQeVHl_NA.ttf",
                "500italic": "//fonts.gstatic.com/s/exo/v4/lo5eTdCNJZQVN08p8RnzAQ.ttf",
                "600italic": "//fonts.gstatic.com/s/exo/v4/0cExa8K_pxS2lTuMr68XUA.ttf",
                "700italic": "//fonts.gstatic.com/s/exo/v4/0me55yJIxd5vyQ9bF7SsiA.ttf",
                "800italic": "//fonts.gstatic.com/s/exo/v4/n3LejeKVj_8gtZq5fIgNYw.ttf",
                "900italic": "//fonts.gstatic.com/s/exo/v4/JHTkQVhzyLtkY13Ye95TJQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Expletus Sans",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "500": "//fonts.gstatic.com/s/expletussans/v9/cl6rhMY77Ilk8lB_uYRRwAqQmZ7VjhwksfpNVG0pqGc.ttf",
                "600": "//fonts.gstatic.com/s/expletussans/v9/cl6rhMY77Ilk8lB_uYRRwCvj1tU7IJMS3CS9kCx2B3U.ttf",
                "700": "//fonts.gstatic.com/s/expletussans/v9/cl6rhMY77Ilk8lB_uYRRwFCbmAUID8LN-q3pJpOk3Ys.ttf",
                "regular": "//fonts.gstatic.com/s/expletussans/v9/gegTSDBDs5le3g6uxU1ZsX8f0n03UdmQgF_CLvNR2vg.ttf",
                "italic": "//fonts.gstatic.com/s/expletussans/v9/Y-erXmY0b6DU_i2Qu0hTJj4G9C9ttb0Oz5Cvf0qOitE.ttf",
                "500italic": "//fonts.gstatic.com/s/expletussans/v9/sRBNtc46w65uJE451UYmW87DCVO6wo6i5LKIyZDzK40.ttf",
                "600italic": "//fonts.gstatic.com/s/expletussans/v9/sRBNtc46w65uJE451UYmW8yKH23ZS6zCKOFHG0e_4JE.ttf",
                "700italic": "//fonts.gstatic.com/s/expletussans/v9/sRBNtc46w65uJE451UYmW5F66r9C4AnxxlBlGd7xY4g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fanwood Text",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fanwoodtext/v6/hDNDHUlsSb8bgnEmDp4T_i3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/fanwoodtext/v6/0J3SBbkMZqBV-3iGxs5E9_MZXuCXbOrAvx5R0IT5Oyo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Farsan",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/farsan/v1/Hdf9Y76SQ6e1X0Nqk3rHtw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fascinate",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fascinate/v5/ZE0637WWkBPKt1AmFaqD3Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fascinate Inline",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fascinateinline/v6/lRguYfMfWArflkm5aOQ5QJmp8DTZ6iHear7UV05iykg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Faster One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fasterone/v6/YxTOW2sf56uxD1T7byP5K_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fauna One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/faunaone/v4/8kL-wpAPofcAMELI_5NRnQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Federant",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/federant/v8/tddZFSiGvxICNOGra0i5aA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Federo",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/federo/v8/JPhe1S2tujeyaR79gXBLeQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Felipa",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/felipa/v4/SeyfyFZY7abAQXGrOIYnYg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fenix",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fenix/v4/Ak8wR3VSlAN7VN_eMeJj7Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Finger Paint",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/fingerpaint/v5/m_ZRbiY-aPb13R3DWPBGXy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fira Mono",
            "category": "monospace",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/firamono/v4/l24Wph3FsyKAbJ8dfExTZy3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/firamono/v4/WQOm1D4RO-yvA9q9trJc8g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fira Sans",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/firasans/v6/VTBnrK42EiOBncVyQXZ7jy3USBnSvpkopQaUR-2r7iU.ttf",
                "500": "//fonts.gstatic.com/s/firasans/v6/zM2u8V3CuPVwAAXFQcDi4C3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/firasans/v6/DugPdSljmOTocZOR2CItOi3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/firasans/v6/6s0YCA9oCTF6hM60YM-qTS9-WlPSxbfiI49GsXo3q0g.ttf",
                "regular": "//fonts.gstatic.com/s/firasans/v6/nsT0isDy56OkSX99sFQbXw.ttf",
                "italic": "//fonts.gstatic.com/s/firasans/v6/cPT_2ddmoxsUuMtQqa8zGqCWcynf_cDxXwCLxiixG1c.ttf",
                "500italic": "//fonts.gstatic.com/s/firasans/v6/6s0YCA9oCTF6hM60YM-qTcCNfqCYlB_eIx7H1TVXe60.ttf",
                "700italic": "//fonts.gstatic.com/s/firasans/v6/6s0YCA9oCTF6hM60YM-qTXe1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fjalla One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/fjallaone/v4/3b7vWCfOZsU53vMa8LWsf_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fjord One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/fjordone/v5/R_YHK8au2uFPw5tNu5N7zw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Flamenco",
            "category": "display",
            "variants": [
                "300",
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/flamenco/v6/x9iI5CogvuZVCGoRHwXuo6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/flamenco/v6/HC0ugfLLgt26I5_BWD1PZA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Flavors",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/flavors/v5/SPJi5QclATvon8ExcKGRvQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fondamento",
            "category": "handwriting",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fondamento/v5/6LWXcjT1B7bnWluAOSNfMPesZW2xOQ-xsNqO47m55DA.ttf",
                "italic": "//fonts.gstatic.com/s/fondamento/v5/y6TmwhSbZ8rYq7OTFyo7OS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fontdiner Swanky",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/fontdinerswanky/v6/8_GxIO5ixMtn5P6COsF3TlBjMPLzPAFJwRBn-s1U7kA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Forum",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/forum/v7/MZUpsq1VfLrqv8eSDcbrrQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Francois One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/francoisone/v9/bYbkq2nU2TSx4SwFbz5sCC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Frank Ruhl Libre",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/frankruhllibre/v1/y8NWif61iD8Hg8bGAmxFPOo9jvbqtCEVUIntIHarXsc.ttf",
                "500": "//fonts.gstatic.com/s/frankruhllibre/v1/y8NWif61iD8Hg8bGAmxFPC-WNtISbX_UO2d0wZPgXtk.ttf",
                "700": "//fonts.gstatic.com/s/frankruhllibre/v1/y8NWif61iD8Hg8bGAmxFPDPYiZEMiRRbPdIFMoTwDbo.ttf",
                "900": "//fonts.gstatic.com/s/frankruhllibre/v1/y8NWif61iD8Hg8bGAmxFPNRZIVFRjDx-6MOpcoWbVhA.ttf",
                "regular": "//fonts.gstatic.com/s/frankruhllibre/v1/yDLloNqBpFmakCImLv4OJkfFI6QBbouvcOFcz81E3Ek.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Freckle Face",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/freckleface/v4/7-B8j9BPJgazdHIGqPNv8y3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fredericka the Great",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/frederickathegreat/v5/7Es8Lxoku-e5eOZWpxw18nrnet6gXN1McwdQxS1dVrI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fredoka One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fredokaone/v4/QKfwXi-z-KtJAlnO2ethYqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fresca",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fresca/v5/2q7Qm9sCo1tWvVgSDVWNIw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Frijole",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/frijole/v5/L2MfZse-2gCascuD-nLhWg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fruktur",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fruktur/v8/PnQvfEi1LssAvhJsCwH__w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Fugaz One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/fugazone/v6/5tteVDCwxsr8-5RuSiRWOw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "GFS Didot",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "greek"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/gfsdidot/v6/jQKxZy2RU-h9tkPZcRVluA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "GFS Neohellenic",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/gfsneohellenic/v7/7HwjPQa7qNiOsnUce2h4448_BwCLZY3eDSV6kppAwI8.ttf",
                "regular": "//fonts.gstatic.com/s/gfsneohellenic/v7/B4xRqbn-tANVqVgamMsSDiayCZa0z7CpFzlkqoCHztc.ttf",
                "italic": "//fonts.gstatic.com/s/gfsneohellenic/v7/KnaWrO4awITAqigQIIYXKkCTdomiyJpIzPbEbIES3rU.ttf",
                "700italic": "//fonts.gstatic.com/s/gfsneohellenic/v7/FwWjoX6XqT-szJFyqsu_GYFF0fM4h-krcpQk7emtCpE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gabriela",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gabriela/v4/B-2ZfbAO3HDrxqV6lR5tdA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gafata",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/gafata/v5/aTFqlki_3Dc3geo-FxHTvQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Galada",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "bengali"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/galada/v1/xGkllHQb8OOCv9VJ6IObSA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Galdeano",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/galdeano/v6/ZKFMQI6HxEG1jOT0UGSZUg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Galindo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/galindo/v4/2lafAS_ZEfB33OJryhXDUg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gentium Basic",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/gentiumbasic/v8/2qL6yulgGf0wwgOp-UqGyLNuTeOOLg3nUymsEEGmdO0.ttf",
                "regular": "//fonts.gstatic.com/s/gentiumbasic/v8/KCktj43blvLkhOTolFn-MYtBLojGU5Qdl8-5NL4v70w.ttf",
                "italic": "//fonts.gstatic.com/s/gentiumbasic/v8/qoFz4NSMaYC2UmsMAG3lyTj3mvXnCeAk09uTtmkJGRc.ttf",
                "700italic": "//fonts.gstatic.com/s/gentiumbasic/v8/8N9-c_aQDJ8LbI1NGVMrwtswO1vWwP9exiF8s0wqW10.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gentium Book Basic",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/gentiumbookbasic/v7/T2vUYmWzlqUtgLYdlemGnaWESMHIjnSjm9UUxYtEOko.ttf",
                "regular": "//fonts.gstatic.com/s/gentiumbookbasic/v7/IRFxB2matTxrjZt6a3FUnrWDjKAyldGEr6eEi2MBNeY.ttf",
                "italic": "//fonts.gstatic.com/s/gentiumbookbasic/v7/qHqW2lwKO8-uTfIkh8FsUfXfjMwrYnmPVsQth2IcAPY.ttf",
                "700italic": "//fonts.gstatic.com/s/gentiumbookbasic/v7/632u7TMIoFDWQYUaHFUp5PA2A9KyRZEkn4TZVuhsWRM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Geo",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/geo/v8/mJuJYk5Pww84B4uHAQ1XaA.ttf",
                "italic": "//fonts.gstatic.com/s/geo/v8/8_r1wToF7nPdDuX1qxel6Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Geostar",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/geostar/v6/A8WQbhQbpYx3GWWaShJ9GA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Geostar Fill",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/geostarfill/v6/Y5ovXPPOHYTfQzK2aM-hui3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Germania One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/germaniaone/v4/3_6AyUql_-FbDi1e68jHdC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gidugu",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v3",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gidugu/v3/Ey6Eq3hrT6MM58iFItFcgw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gilda Display",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gildadisplay/v4/8yAVUZLLZ3wb7dSsjix0CADHmap7fRWINAsw8-RaxNg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Give You Glory",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/giveyouglory/v6/DFEWZFgGmfseyIdGRJAxuBwwkpSPZdvjnMtysdqprfI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Glass Antiqua",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/glassantiqua/v4/0yLrXKplgdUDIMz5TnCHNODcg5akpSnIcsPhLOFv7l8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Glegoo",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/glegoo/v5/TlLolbauH0-0Aiz1LUH5og.ttf",
                "regular": "//fonts.gstatic.com/s/glegoo/v5/2tf-h3n2A_SNYXEO0C8bKw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gloria Hallelujah",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gloriahallelujah/v8/CA1k7SlXcY5kvI81M_R28Q3RdPdyebSUyJECJouPsvA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Goblin One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/goblinone/v6/331XtzoXgpVEvNTVcBJ_C_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gochi Hand",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gochihand/v7/KT1-WxgHsittJ34_20IfAPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gorditas",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/gorditas/v4/6-XCeknmxaon8AUqVkMnHaCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/gorditas/v4/uMgZhXUyH6qNGF3QsjQT5Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Goudy Bookletter 1911",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/goudybookletter1911/v6/l5lwlGTN3pEY5Bf-rQEuIIjNDsyURsIKu4GSfvSE4mA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Graduate",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/graduate/v4/JpAmYLHqcIh9_Ff35HHwiA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Grand Hotel",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/grandhotel/v4/C_A8HiFZjXPpnMt38XnK7qCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gravitas One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/gravitasone/v6/nBHdBv6zVNU8MtP6w9FwTS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Great Vibes",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/greatvibes/v4/4Mi5RG_9LjQYrTU55GN_L6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Griffy",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/griffy/v4/vWkyYGBSyE5xjnShNtJtzw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gruppo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/gruppo/v7/pS_JM0cK_piBZve-lfUq9w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Gudea",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/gudea/v4/lsip4aiWhJ9bx172Y9FN_w.ttf",
                "regular": "//fonts.gstatic.com/s/gudea/v4/S-4QqBlkMPiiA3jNeCR5yw.ttf",
                "italic": "//fonts.gstatic.com/s/gudea/v4/7mNgsGw_vfS-uUgRVXNDSw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Habibi",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/habibi/v5/YYyqXF6pWpL7kmKgS_2iUA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Halant",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/halant/v2/dM3ItAOWNNod_Cf3MnLlEg.ttf",
                "500": "//fonts.gstatic.com/s/halant/v2/tlsNj3K-hJKtiirTDtUbkQ.ttf",
                "600": "//fonts.gstatic.com/s/halant/v2/zNR2WvI_V8o652vIZp3X4Q.ttf",
                "700": "//fonts.gstatic.com/s/halant/v2/D9FN7OH89AuCmZDLHbPQfA.ttf",
                "regular": "//fonts.gstatic.com/s/halant/v2/rEs7Jk3SVyt3cTx6DoTu1w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hammersmith One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/hammersmithone/v7/FWNn6ITYqL6or7ZTmBxRhjjVlsJB_M_Q_LtZxsoxvlw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hanalei",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/hanalei/v6/Sx8vVMBnXSQyK6Cn0CBJ3A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hanalei Fill",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/hanaleifill/v5/5uPeWLnaDdtm4UBG26Ds6C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Handlee",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/handlee/v5/6OfkXkyC0E5NZN80ED8u3A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hanuman",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "khmer"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/hanuman/v9/lzzXZ2l84x88giDrbfq76vesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/hanuman/v9/hRhwOGGmElJSl6KSPvEnOQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Happy Monkey",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/happymonkey/v5/c2o0ps8nkBmaOYctqBq1rS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Harmattan",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/harmattan/v1/xNM1nDKzsLfoCLQtMRztGA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Headland One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/headlandone/v4/iGmBeOvQGfq9DSbjJ8jDVy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Heebo",
            "category": "sans-serif",
            "variants": [
                "100",
                "300",
                "regular",
                "500",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "hebrew"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/heebo/v2/SoQODIucfpkiveZloUR6ag.ttf",
                "300": "//fonts.gstatic.com/s/heebo/v2/dg5T18yyjkKiU_9mmcbDSQ.ttf",
                "500": "//fonts.gstatic.com/s/heebo/v2/jDb70ZCwdD6JnmQU62ZQZA.ttf",
                "700": "//fonts.gstatic.com/s/heebo/v2/NsBYEn6oWei8pPqytA07yA.ttf",
                "800": "//fonts.gstatic.com/s/heebo/v2/h4CV2Qq56LKIinGGOStvsw.ttf",
                "900": "//fonts.gstatic.com/s/heebo/v2/uDfzHw3R0Bfa6HyIIcj-ow.ttf",
                "regular": "//fonts.gstatic.com/s/heebo/v2/nyHCGMPliplPNqpssbDSIA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Henny Penny",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/hennypenny/v4/XRgo3ogXyi3tpsFfjImRF6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Herr Von Muellerhoff",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/herrvonmuellerhoff/v6/mmy24EUmk4tjm4gAEjUd7NLGIYrUsBdh-JWHYgiDiMU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hind",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-02",
            "files": {
                "300": "//fonts.gstatic.com/s/hind/v6/qa346Adgv9kPDXoD1my4kA.ttf",
                "500": "//fonts.gstatic.com/s/hind/v6/2cs8RCVcYtiv4iNDH1UsQQ.ttf",
                "600": "//fonts.gstatic.com/s/hind/v6/TUKUmFMXSoxloBP1ni08oA.ttf",
                "700": "//fonts.gstatic.com/s/hind/v6/cXJJavLdUbCfjxlsA6DqTw.ttf",
                "regular": "//fonts.gstatic.com/s/hind/v6/mktFHh5Z5P9YjGKSslSUtA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hind Guntur",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "telugu",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/hindguntur/v1/Szg33M7ab5MTWe-PWAcNAi9-WlPSxbfiI49GsXo3q0g.ttf",
                "500": "//fonts.gstatic.com/s/hindguntur/v1/Szg33M7ab5MTWe-PWAcNAsCNfqCYlB_eIx7H1TVXe60.ttf",
                "600": "//fonts.gstatic.com/s/hindguntur/v1/Szg33M7ab5MTWe-PWAcNApZ7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700": "//fonts.gstatic.com/s/hindguntur/v1/Szg33M7ab5MTWe-PWAcNAne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/hindguntur/v1/MXz-KyAeVZstlFz6v-5SC6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hind Madurai",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/hindmadurai/v1/sdSJTZLdRXJhVTP92m2S66cQoVhARpoaILP7amxE_8g.ttf",
                "500": "//fonts.gstatic.com/s/hindmadurai/v1/sdSJTZLdRXJhVTP92m2S65MQuUSAwdHsY8ov_6tk1oA.ttf",
                "600": "//fonts.gstatic.com/s/hindmadurai/v1/sdSJTZLdRXJhVTP92m2S62v8CylhIUtwUiYO7Z2wXbE.ttf",
                "700": "//fonts.gstatic.com/s/hindmadurai/v1/sdSJTZLdRXJhVTP92m2S60D2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/hindmadurai/v1/pJpl47LatORZNWf8rgdiyS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hind Siliguri",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "bengali",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-02",
            "files": {
                "300": "//fonts.gstatic.com/s/hindsiliguri/v2/fBpmjMpv5Rh6S25yVfWJnzoJ52uD-1fmXmi8u0n_zsc.ttf",
                "500": "//fonts.gstatic.com/s/hindsiliguri/v2/fBpmjMpv5Rh6S25yVfWJn__2zpxNHQ3utWt_82o9dAo.ttf",
                "600": "//fonts.gstatic.com/s/hindsiliguri/v2/fBpmjMpv5Rh6S25yVfWJn-x91FDzFvnud68bXrNkpDA.ttf",
                "700": "//fonts.gstatic.com/s/hindsiliguri/v2/fBpmjMpv5Rh6S25yVfWJn6iiXuG_rGcOxkuidirlnJE.ttf",
                "regular": "//fonts.gstatic.com/s/hindsiliguri/v2/f2eEi2pbIa8eBfNwpUl0Am_MnNA9OgK8I1F23mNWOpE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Hind Vadodara",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-02",
            "files": {
                "300": "//fonts.gstatic.com/s/hindvadodara/v2/KrZ6f_YevRawHvh0qDBkTbDwfZ__Dotj_J8NiWv76DQ.ttf",
                "500": "//fonts.gstatic.com/s/hindvadodara/v2/KrZ6f_YevRawHvh0qDBkTZzEKvFIU9WyojfbAkhDb6c.ttf",
                "600": "//fonts.gstatic.com/s/hindvadodara/v2/KrZ6f_YevRawHvh0qDBkTfgXs2VXrZsRiQ1c96pXZKI.ttf",
                "700": "//fonts.gstatic.com/s/hindvadodara/v2/KrZ6f_YevRawHvh0qDBkTYGjoH95IEFGA7BjhXnx_eg.ttf",
                "regular": "//fonts.gstatic.com/s/hindvadodara/v2/9c6KKeibr6NtFqknnNxZB-Dcg5akpSnIcsPhLOFv7l8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Holtwood One SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/holtwoodonesc/v7/sToOq3cIxbfnhbEkgYNuBbAgSRh1LpJXlLfl8IbsmHg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Homemade Apple",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/homemadeapple/v6/yg3UMEsefgZ8IHz_ryz86BiPOmFWYV1WlrJkRafc4c0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Homenaje",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/homenaje/v5/v0YBU0iBRrGdVjDNQILxtA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell DW Pica",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfelldwpica/v6/W81bfaWiUicLSPbJhW-ATsA5qm663gJGVdtpamafG5A.ttf",
                "italic": "//fonts.gstatic.com/s/imfelldwpica/v6/alQJ8SK5aSOZVaelYoyT4PL2asmh5DlYQYCosKo6yQs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell DW Pica SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfelldwpicasc/v6/xBKKJV4z2KsrtQnmjGO17JZ9RBdEL0H9o5qzT1Rtof4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell Double Pica",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfelldoublepica/v6/yN1wY_01BkQnO0LYAhXdUol14jEdVOhEmvtCMCVwYak.ttf",
                "italic": "//fonts.gstatic.com/s/imfelldoublepica/v6/64odUh2hAw8D9dkFKTlWYq0AWwkgdQfsRHec8TYi4mI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell Double Pica SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfelldoublepicasc/v6/jkrUtrLFpMw4ZazhfkKsGwc4LoC4OJUqLw9omnT3VOU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell English",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellenglish/v6/xwIisCqGFi8pff-oa9uSVHGNmx1fDm-u2eBJHQkdrmk.ttf",
                "italic": "//fonts.gstatic.com/s/imfellenglish/v6/Z3cnIAI_L3XTRfz4JuZKbuewladMPCWTthtMv9cPS-c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell English SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellenglishsc/v6/h3Tn6yWfw4b5qaLD1RWvz5ATixNthKRRR1XVH3rJNiw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell French Canon",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellfrenchcanon/v6/iKB0WL1BagSpNPz3NLMdsJ3V2FNpBrlLSvqUnERhBP8.ttf",
                "italic": "//fonts.gstatic.com/s/imfellfrenchcanon/v6/owCuNQkLLFW7TBBPJbMnhRa-QL94KdW80H29tcyld2A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell French Canon SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellfrenchcanonsc/v6/kA3bS19-tQbeT_iG32EZmaiyyzHwYrAbmNulTz423iM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell Great Primer",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellgreatprimer/v6/AL8ALGNthei20f9Cu3e93rgeX3ROgtTz44CitKAxzKI.ttf",
                "italic": "//fonts.gstatic.com/s/imfellgreatprimer/v6/1a-artkXMVg682r7TTxVY1_YG2SFv8Ma7CxRl1S3o7g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "IM Fell Great Primer SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imfellgreatprimersc/v6/A313vRj97hMMGFjt6rgSJtRg-ciw1Y27JeXb2Zv4lZQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Iceberg",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/iceberg/v4/p2XVm4M-N0AOEEOymFKC5w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Iceland",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/iceland/v5/kq3uTMGgvzWGNi39B_WxGA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Imprima",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/imprima/v4/eRjquWLjwLGnTEhLH7u3kA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Inconsolata",
            "category": "monospace",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v12",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/inconsolata/v12/AIed271kqQlcIRSOnQH0yXe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/inconsolata/v12/7bMKuoy6Nh0ft0SHnIGMuaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Inder",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/inder/v5/C38TwecLTfKxIHDc_Adcrw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Indie Flower",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/indieflower/v8/10JVD_humAd5zP2yrFqw6i3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Inika",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/inika/v4/bl3ZoTyrWsFun2zYbsgJrA.ttf",
                "regular": "//fonts.gstatic.com/s/inika/v4/eZCrULQGaIxkrRoGz_DjhQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Inknut Antiqua",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVIg6hmPNSXwHGnJQCeQHKUMo.ttf",
                "500": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVIiYCDvi1XFzRnTV7qUFsNgk.ttf",
                "600": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVIjLEgY6PI0GrY6L00mykcEQ.ttf",
                "700": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVIlRhfXn9P4_QueZ7VkUHUNc.ttf",
                "800": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVInARjXVu2t2krcNTHiCb1qY.ttf",
                "900": "//fonts.gstatic.com/s/inknutantiqua/v1/CagoW52rBcslcXzHh6tVIrTsNy1JrFNT1qKy8j7W3CU.ttf",
                "regular": "//fonts.gstatic.com/s/inknutantiqua/v1/VlmmTfOrxr3HfcnhMueX9arFJ4O13IHVxZbM6yoslpo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Irish Grover",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/irishgrover/v6/kUp7uUPooL-KsLGzeVJbBC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Istok Web",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/istokweb/v10/2koEo4AKFSvK4B52O_Mwai3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/istokweb/v10/RYLSjEXQ0nNtLLc4n7--dQ.ttf",
                "italic": "//fonts.gstatic.com/s/istokweb/v10/kvcT2SlTjmGbC3YlZxmrl6CWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/istokweb/v10/ycQ3g52ELrh3o_HYCNNUw3e1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Italiana",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/italiana/v4/dt95fkCSTOF-c6QNjwSycA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Italianno",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/italianno/v6/HsyHnLpKf8uP7aMpDQHZmg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Itim",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/itim/v1/HHV9WK2x5lUkc5bxMXG8Tw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jacques Francois",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/jacquesfrancois/v4/_-0XWPQIW6tOzTHg4KaJ_M13D_4KM32Q4UmTSjpuNGQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jacques Francois Shadow",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/jacquesfrancoisshadow/v4/V14y0H3vq56fY9SV4OL_FASt0D_oLVawA8L8b9iKjbs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jaldi",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/jaldi/v2/OIbtgjjEp3aVWtjF6WY8mA.ttf",
                "regular": "//fonts.gstatic.com/s/jaldi/v2/x1vR-bPW9a1EB-BUVqttCw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jim Nightshade",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/jimnightshade/v4/_n43lYHXVWNgXegdYRIK9CF1W_bo0EdycfH0kHciIic.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jockey One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/jockeyone/v6/cAucnOZLvFo07w2AbufBCfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jolly Lodger",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/jollylodger/v4/RX8HnkBgaEKQSHQyP9itiS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Josefin Sans",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/josefinsans/v9/q9w3H4aeBxj0hZ8Osfi3d8SVQ0giZ-l_NELu3lgGyYw.ttf",
                "300": "//fonts.gstatic.com/s/josefinsans/v9/C6HYlRF50SGJq1XyXj04z6cQoVhARpoaILP7amxE_8g.ttf",
                "600": "//fonts.gstatic.com/s/josefinsans/v9/C6HYlRF50SGJq1XyXj04z2v8CylhIUtwUiYO7Z2wXbE.ttf",
                "700": "//fonts.gstatic.com/s/josefinsans/v9/C6HYlRF50SGJq1XyXj04z0D2ttfZwueP-QU272T9-k4.ttf",
                "100italic": "//fonts.gstatic.com/s/josefinsans/v9/s7-P1gqRNRNn-YWdOYnAOXXcj1rQwlNLIS625o-SrL0.ttf",
                "300italic": "//fonts.gstatic.com/s/josefinsans/v9/ppse0J9fKSaoxCIIJb33Gyna0FLWfcB-J_SAYmcAXaI.ttf",
                "regular": "//fonts.gstatic.com/s/josefinsans/v9/xgzbb53t8j-Mo-vYa23n5i3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/josefinsans/v9/q9w3H4aeBxj0hZ8Osfi3d_MZXuCXbOrAvx5R0IT5Oyo.ttf",
                "600italic": "//fonts.gstatic.com/s/josefinsans/v9/ppse0J9fKSaoxCIIJb33G4R-5-urNOGAobhAyctHvW8.ttf",
                "700italic": "//fonts.gstatic.com/s/josefinsans/v9/ppse0J9fKSaoxCIIJb33G_As9-1nE9qOqhChW0m4nDE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Josefin Slab",
            "category": "serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/josefinslab/v6/etsUjZYO8lTLU85lDhZwUsSVQ0giZ-l_NELu3lgGyYw.ttf",
                "300": "//fonts.gstatic.com/s/josefinslab/v6/NbE6ykYuM2IyEwxQxOIi2KcQoVhARpoaILP7amxE_8g.ttf",
                "600": "//fonts.gstatic.com/s/josefinslab/v6/NbE6ykYuM2IyEwxQxOIi2Gv8CylhIUtwUiYO7Z2wXbE.ttf",
                "700": "//fonts.gstatic.com/s/josefinslab/v6/NbE6ykYuM2IyEwxQxOIi2ED2ttfZwueP-QU272T9-k4.ttf",
                "100italic": "//fonts.gstatic.com/s/josefinslab/v6/8BjDChqLgBF3RJKfwHIYh3Xcj1rQwlNLIS625o-SrL0.ttf",
                "300italic": "//fonts.gstatic.com/s/josefinslab/v6/af9sBoKGPbGO0r21xJulyyna0FLWfcB-J_SAYmcAXaI.ttf",
                "regular": "//fonts.gstatic.com/s/josefinslab/v6/46aYWdgz-1oFX11flmyEfS3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/josefinslab/v6/etsUjZYO8lTLU85lDhZwUvMZXuCXbOrAvx5R0IT5Oyo.ttf",
                "600italic": "//fonts.gstatic.com/s/josefinslab/v6/af9sBoKGPbGO0r21xJuly4R-5-urNOGAobhAyctHvW8.ttf",
                "700italic": "//fonts.gstatic.com/s/josefinslab/v6/af9sBoKGPbGO0r21xJuly_As9-1nE9qOqhChW0m4nDE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Joti One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/jotione/v4/P3r_Th0ESHJdzunsvWgUfQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Judson",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/judson/v9/he4a2LwiPJc7r8x0oKCKiA.ttf",
                "regular": "//fonts.gstatic.com/s/judson/v9/znM1AAs0eytUaJzf1CrYZQ.ttf",
                "italic": "//fonts.gstatic.com/s/judson/v9/GVqQW9P52ygW-ySq-CLwAA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Julee",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/julee/v6/CAib-jsUsSO8SvVRnE9fHA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Julius Sans One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/juliussansone/v5/iU65JP9acQHPDLkdalCF7jjVlsJB_M_Q_LtZxsoxvlw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Junge",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/junge/v4/j4IXCXtxrw9qIBheercp3A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Jura",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/jura/v7/Rqx_xy1UnN0C7wD3FUSyPQ.ttf",
                "500": "//fonts.gstatic.com/s/jura/v7/16xhfjHCiaLj3tsqqgmtGg.ttf",
                "600": "//fonts.gstatic.com/s/jura/v7/iwseduOwJSdY8wQ1Y6CJdA.ttf",
                "regular": "//fonts.gstatic.com/s/jura/v7/YAWMwF3sN0KCbynMq-Yr_Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Just Another Hand",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/justanotherhand/v7/fKV8XYuRNNagXr38eqbRf99BnJIEGrvoojniP57E51c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Just Me Again Down Here",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/justmeagaindownhere/v8/sN06iTc9ITubLTgXoG-kc3M9eVLpVTSK6TqZTIgBrWQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kadwa",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/kadwa/v1/NFPZaBfekj_Io-7vUMz4Ww.ttf",
                "regular": "//fonts.gstatic.com/s/kadwa/v1/VwEN8oKGqaa0ug9kRpvSSg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kalam",
            "category": "handwriting",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/kalam/v7/MgQQlk1SgPEHdlkWMNh7Jg.ttf",
                "700": "//fonts.gstatic.com/s/kalam/v7/95nLItUGyWtNLZjSckluLQ.ttf",
                "regular": "//fonts.gstatic.com/s/kalam/v7/hNEJkp2K-aql7e5WQish4Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kameron",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/kameron/v7/rabVVbzlflqvmXJUFlKnu_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/kameron/v7/9r8HYhqDSwcq9WMjupL82A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kanit",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/kanit/v1/CYl4qOK-NWwZp3iTKW1eIA.ttf",
                "200": "//fonts.gstatic.com/s/kanit/v1/wfLWkj1C4tYl7MoiFWS3bA.ttf",
                "300": "//fonts.gstatic.com/s/kanit/v1/SM5qHynYGdOmMKEwGUFIPA.ttf",
                "500": "//fonts.gstatic.com/s/kanit/v1/GxoU_USIJyIy8WIcYSUO2g.ttf",
                "600": "//fonts.gstatic.com/s/kanit/v1/n_qoIVxojeQY0D1pvoNDhA.ttf",
                "700": "//fonts.gstatic.com/s/kanit/v1/kEGmYvO8My36j5ILmbUPRg.ttf",
                "800": "//fonts.gstatic.com/s/kanit/v1/YTp-zAuKXxwnA1YnJIF1rg.ttf",
                "900": "//fonts.gstatic.com/s/kanit/v1/1NIEkusi3bG3GgO9Hor3fQ.ttf",
                "100italic": "//fonts.gstatic.com/s/kanit/v1/NLNtc56MpXmHl1yOrop8oQ.ttf",
                "200italic": "//fonts.gstatic.com/s/kanit/v1/D8gkrAAM2bvNJ-1i4ot-1_esZW2xOQ-xsNqO47m55DA.ttf",
                "300italic": "//fonts.gstatic.com/s/kanit/v1/IePislKOKy3Bqfpb9V5VM_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/kanit/v1/L6VKvM17ZmevDynOiw7H9w.ttf",
                "italic": "//fonts.gstatic.com/s/kanit/v1/sHLq5U0-T0oSMTnwTKgv-A.ttf",
                "500italic": "//fonts.gstatic.com/s/kanit/v1/hrCiWCaNv9AaF0mDY1F2zPesZW2xOQ-xsNqO47m55DA.ttf",
                "600italic": "//fonts.gstatic.com/s/kanit/v1/9BkP85yRDoVayTWQwdGLqPesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/kanit/v1/WNo3ZZ9xtOZJknNlvHAFWfesZW2xOQ-xsNqO47m55DA.ttf",
                "800italic": "//fonts.gstatic.com/s/kanit/v1/qiTGrW5sCa9UQp841fWjc_esZW2xOQ-xsNqO47m55DA.ttf",
                "900italic": "//fonts.gstatic.com/s/kanit/v1/ogN5dFD1r4BfxNV4Nb-TXfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Karma",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/karma/v5/lH6ijJnguWR2Sz7tEl6MQQ.ttf",
                "500": "//fonts.gstatic.com/s/karma/v5/9YGjxi6Hcvz2Kh-rzO_cAw.ttf",
                "600": "//fonts.gstatic.com/s/karma/v5/h_CVzXXtqSxjfS2sIwaejA.ttf",
                "700": "//fonts.gstatic.com/s/karma/v5/smuSM08oApsQPPVYbHd1CA.ttf",
                "regular": "//fonts.gstatic.com/s/karma/v5/wvqTxAGBUrTqU0urTEoPIw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Katibeh",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/katibeh/v2/Q-SA43uWR2uu3wBIvedotA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kaushan Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kaushanscript/v5/qx1LSqts-NtiKcLw4N03IBnpV0hQCek3EmWnCPrvGRM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kavivanar",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/kavivanar/v1/VLDrdUtF1irKFc8rFWgDaw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kavoon",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kavoon/v5/382m-6baKXqJFQjEgobt6Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Keania One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/keaniaone/v4/PACrDKZWngXzgo-ucl6buvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kelly Slab",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kellyslab/v6/F_2oS1e9XdYx1MAi8XEVefesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kenia",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kenia/v8/OLM9-XfITK9PsTLKbGBrwg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Khand",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/khand/v4/072zRl4OU9Pinjjkg174LA.ttf",
                "500": "//fonts.gstatic.com/s/khand/v4/46_p-SqtuMe56nxQdteWxg.ttf",
                "600": "//fonts.gstatic.com/s/khand/v4/zggGWYIiPJyMTgkfxP_kaA.ttf",
                "700": "//fonts.gstatic.com/s/khand/v4/0I0UWaN-X5QBmfexpXKhqg.ttf",
                "regular": "//fonts.gstatic.com/s/khand/v4/HdLdTNFqNIDGJZl1ZEj84w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Khula",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/khula/v1/_1LySU5Upq-sc4OZ1b_GIw.ttf",
                "600": "//fonts.gstatic.com/s/khula/v1/4ZH86Hce-aeFDaedTnbkbg.ttf",
                "700": "//fonts.gstatic.com/s/khula/v1/UGVExGl-Jjs-YPpGv-MZ6w.ttf",
                "800": "//fonts.gstatic.com/s/khula/v1/Sccp_oOo8FWgbx5smie7xQ.ttf",
                "regular": "//fonts.gstatic.com/s/khula/v1/izcPIFyCSd16XI1Ak_Wk7Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kite One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kiteone/v4/8ojWmgUc97m0f_i6sTqLoQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Knewave",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/knewave/v5/KGHM4XWr4iKnBMqzZLkPBg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kotta One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kottaone/v4/AB2Q7hVw6niJYDgLvFXu5w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kranky",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/kranky/v6/C8dxxTS99-fZ84vWk8SDrg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kreon",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/kreon/v9/HKtJRiq5C2zbq5N1IX32sA.ttf",
                "700": "//fonts.gstatic.com/s/kreon/v9/jh0dSmaPodjxISiblIUTkw.ttf",
                "regular": "//fonts.gstatic.com/s/kreon/v9/zA_IZt0u0S3cvHJu-n1oEg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kristi",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/kristi/v7/aRsgBQrkQkMlu4UPSnJyOQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Krona One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/kronaone/v4/zcQj4ljqTo166AdourlF9w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kumar One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/kumarone/v1/YmcJD6Wky1clGYY5OD-BkQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kumar One Outline",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/kumaroneoutline/v1/hnQF47H-55qiLAGgq7C3QyxhoCTLJoiJ-y-zew8F8j0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Kurale",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/kurale/v1/rxeyIcvQlT4XAWwNbXFCfw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "La Belle Aurore",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/labelleaurore/v7/Irdbc4ASuUoWDjd_Wc3md123K2iuuhwZgaKapkyRTY8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Laila",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/laila/v2/bLbIVEZF3IWSZ-in72GJvA.ttf",
                "500": "//fonts.gstatic.com/s/laila/v2/tkf8VtFvW9g3VsxQCA6WOQ.ttf",
                "600": "//fonts.gstatic.com/s/laila/v2/3EMP2L6JRQ4GaHIxCldCeA.ttf",
                "700": "//fonts.gstatic.com/s/laila/v2/R7P4z1xjcjecmjZ9GyhqHQ.ttf",
                "regular": "//fonts.gstatic.com/s/laila/v2/6iYor3edprH7360qtBGoag.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lakki Reddy",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v3",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lakkireddy/v3/Q5EpFa91FjW37t0FCnedaKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lalezar",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/lalezar/v1/k4_MPf09PGmL7oyGdPKwcg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lancelot",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lancelot/v6/XMT7T_oo_MQUGAnU2v-sdA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lateef",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lateef/v10/PAsKCgi1qc7XPwvzo_I-DQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lato",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v11",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/lato/v11/Upp-ka9rLQmHYCsFgwL-eg.ttf",
                "300": "//fonts.gstatic.com/s/lato/v11/Ja02qOppOVq9jeRjWekbHg.ttf",
                "700": "//fonts.gstatic.com/s/lato/v11/iX_QxBBZLhNj5JHlTzHQzg.ttf",
                "900": "//fonts.gstatic.com/s/lato/v11/8TPEV6NbYWZlNsXjbYVv7w.ttf",
                "100italic": "//fonts.gstatic.com/s/lato/v11/zLegi10uS_9-fnUDISl0KA.ttf",
                "300italic": "//fonts.gstatic.com/s/lato/v11/dVebFcn7EV7wAKwgYestUg.ttf",
                "regular": "//fonts.gstatic.com/s/lato/v11/h7rISIcQapZBpei-sXwIwg.ttf",
                "italic": "//fonts.gstatic.com/s/lato/v11/P_dJOFJylV3A870UIOtr0w.ttf",
                "700italic": "//fonts.gstatic.com/s/lato/v11/WFcZakHrrCKeUJxHA4T_gw.ttf",
                "900italic": "//fonts.gstatic.com/s/lato/v11/draWperrI7n2xi35Cl08fA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "League Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/leaguescript/v7/wnRFLvfabWK_DauqppD6vSeUSrabuTpOsMEiRLtKwk0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Leckerli One",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/leckerlione/v7/S2Y_iLrItTu8kIJTkS7DrC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ledger",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ledger/v4/G432jp-tahOfWHbCYkI0jw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lekton",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/lekton/v7/WZw-uL8WTkx3SBVfTlevXQ.ttf",
                "regular": "//fonts.gstatic.com/s/lekton/v7/r483JYmxf5PjIm4jVAm8Yg.ttf",
                "italic": "//fonts.gstatic.com/s/lekton/v7/_UbDIPBA1wDqSbhp-OED7A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lemon",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lemon/v5/wed1nNu4LNSu-3RoRVUhUw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lemonada",
            "category": "display",
            "variants": [
                "300",
                "regular",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/lemonada/v2/uM3MufQOcwGHuruj4TsXiqCWcynf_cDxXwCLxiixG1c.ttf",
                "600": "//fonts.gstatic.com/s/lemonada/v2/9Vd4MNKsOxNyLzlfTXdKLqCWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/lemonada/v2/9jKcm4hRI511-Dy7FFfQ3aCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/lemonada/v2/pkzws3AUXmaaAzOi7aydSQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Libre Baskerville",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/librebaskerville/v4/kH7K4InNTm7mmOXXjrA5v-xuswJKUVpBRfYFpz0W3Iw.ttf",
                "regular": "//fonts.gstatic.com/s/librebaskerville/v4/pR0sBQVcY0JZc_ciXjFsKyyZRYCSvpCzQKuMWnP5NDY.ttf",
                "italic": "//fonts.gstatic.com/s/librebaskerville/v4/QHIOz1iKF3bIEzRdDFaf5QnhapNS5Oi8FPrBRDLbsW4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Libre Franklin",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/librefranklin/v1/zrsyK9EytLQ07oRM9IZIsX6Zf0VB_l-7q6pFtcZSRCs.ttf",
                "200": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yCwKTB4uIbnDXE2hyxZaFPY.ttf",
                "300": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yMhKJW3W9-339CFS_Lie1us.ttf",
                "500": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yMBjwrbmxH6gp8HgxjPD8qo.ttf",
                "600": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yORt4MKdIUjA60qLK3wI2m8.ttf",
                "700": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yEnStGWSv3WdwjmyyI8xc7Q.ttf",
                "800": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yKltwG0cydF-uC1kFVv1hts.ttf",
                "900": "//fonts.gstatic.com/s/librefranklin/v1/1_DGDtljMiPWFs5rl_p0yF7duMYIKwoQ5QsTL00fobw.ttf",
                "100italic": "//fonts.gstatic.com/s/librefranklin/v1/LHzsuUmxr4UY-IoiG8pRK4gsWNE1DYiT_eIOcNe2Au4.ttf",
                "200italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqho0lu1sSkaQaYEjN61aJ3i1I.ttf",
                "300italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqho14je5cfhxzx5bEvSaoyQQI.ttf",
                "regular": "//fonts.gstatic.com/s/librefranklin/v1/PFwjf3aDdAQPvNKUrT3U7_fSnedoLXQQjURyDxluu8g.ttf",
                "italic": "//fonts.gstatic.com/s/librefranklin/v1/zrsyK9EytLQ07oRM9IZIsX5kKxjpQfTpnFf2SrDLxlg.ttf",
                "500italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqho5VcuOW5XbZIr02vW37iuvg.ttf",
                "600italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqhowNPRgU5g4Xymf9hgRWrbNs.ttf",
                "700italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqhow7kn3RFjf4gfwsdsBE-Rf4.ttf",
                "800italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqho80d7u0uHUbaRkK-cNyim1w.ttf",
                "900italic": "//fonts.gstatic.com/s/librefranklin/v1/7_V210XP3LBEtEwiCTqho0THpHUXJVnEwH4tSjkF0wg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Life Savers",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/lifesavers/v6/THQKqChyYUm97rNPVFdGGXe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/lifesavers/v6/g49cUDk4Y1P0G5NMkMAm7qCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lilita One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lilitaone/v4/vTxJQjbNV6BCBHx8sGDCVvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lily Script One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lilyscriptone/v4/uPWsLVW8uiXqIBnE8ZwGPDjVlsJB_M_Q_LtZxsoxvlw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Limelight",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/limelight/v7/5dTfN6igsXjLjOy8QQShcg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Linden Hill",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lindenhill/v6/UgsC0txqd-E1yjvjutwm_KCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/lindenhill/v6/OcS3bZcu8vJvIDH8Zic83keOrDcLawS7-ssYqLr2Xp4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lobster",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v18",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lobster/v18/9LpJGtNuM1D8FAZ2BkJH2Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lobster Two",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/lobstertwo/v9/bmdxOflBqMqjEC0-kGsIiHe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/lobstertwo/v9/xb9aY4w9ceh8JRzobID1naCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/lobstertwo/v9/Ul_16MSbfayQv1I4QhLEoEeOrDcLawS7-ssYqLr2Xp4.ttf",
                "700italic": "//fonts.gstatic.com/s/lobstertwo/v9/LEkN2_no_6kFvRfiBZ8xpM_zJjSACmk0BRPxQqhnNLU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Londrina Outline",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/londrinaoutline/v5/lls08GOa1eT74p072l1AWJmp8DTZ6iHear7UV05iykg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Londrina Shadow",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/londrinashadow/v4/dNYuzPS_7eYgXFJBzMoKdbw6Z3rVA5KDSi7aQxS92Nk.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Londrina Sketch",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/londrinasketch/v4/p7Ai06aT1Ycp_D2fyE3z69d6z_uhFGnpCOifUY1fJQo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Londrina Solid",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/londrinasolid/v4/yysorIEiYSBb0ylZjg791MR125CwGqh8XBqkBzea0LA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lora",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/lora/v9/enKND5SfzQKkggBA_VnT1A.ttf",
                "regular": "//fonts.gstatic.com/s/lora/v9/aXJ7KVIGcejEy1abawZazg.ttf",
                "italic": "//fonts.gstatic.com/s/lora/v9/AN2EZaj2tFRpyveuNn9BOg.ttf",
                "700italic": "//fonts.gstatic.com/s/lora/v9/ivs9j3kYU65pR9QD9YFdzQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Love Ya Like A Sister",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/loveyalikeasister/v7/LzkxWS-af0Br2Sk_YgSJY-ad1xEP8DQfgfY8MH9aBUg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Loved by the King",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lovedbytheking/v6/wg03xD4cWigj4YDufLBSr8io2AFEwwMpu7y5KyiyAJc.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lovers Quarrel",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/loversquarrel/v4/gipdZ8b7pKb89MzQLAtJHLHLxci2ElvNEmOB303HLk0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Luckiest Guy",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/luckiestguy/v6/5718gH8nDy3hFVihOpkY5C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lusitana",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/lusitana/v4/GWtZyUsONxgkdl3Mc1P7FKCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/lusitana/v4/l1h9VDomkwbdzbPdmLcUIw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Lustria",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/lustria/v4/gXAk0s4ai0X-TAOhYzZd1w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Macondo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/macondo/v5/G6yPNUscRPQ8ufBXs_8yRQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Macondo Swash Caps",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/macondoswashcaps/v4/SsSR706z-MlvEH7_LS6JAPkkgYRHs6GSG949m-K6x2k.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mada",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "900"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/mada/v1/P46fye2TPh4fVwALgHSXCA.ttf",
                "500": "//fonts.gstatic.com/s/mada/v1/PhhDsBi34sP0LptbpS9m6w.ttf",
                "900": "//fonts.gstatic.com/s/mada/v1/aCyc9Kc3rOJLL6fV9VfptA.ttf",
                "regular": "//fonts.gstatic.com/s/mada/v1/io_zUrt5o943T_q45OHLWQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Magra",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/magra/v4/6fOM5sq5cIn8D0RjX8Lztw.ttf",
                "regular": "//fonts.gstatic.com/s/magra/v4/hoZ13bwCXBxuGZqAudgc5A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Maiden Orange",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/maidenorange/v6/ZhKIA2SPisEwdhW7g0RUWojjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Maitree",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/maitree/v1/JTlrRs3bVPV4i05cUIx_z_esZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/maitree/v1/rEGdABAOaqCHggl37mkWjfesZW2xOQ-xsNqO47m55DA.ttf",
                "500": "//fonts.gstatic.com/s/maitree/v1/2VHD7TXjRhN4Xu74SEPGdvesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/maitree/v1/uuazDnPwt30gW3cKsG-e0_esZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/maitree/v1/cnHhc9fphsL3q-pistN3IPesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/maitree/v1/SpKVJkAjDAYOr1VkdSRspA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mako",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mako/v7/z5zSLmfPlv1uTVAdmJBLXg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mallanna",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mallanna/v4/krCTa-CfMbtxqF0689CbuQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mandali",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mandali/v4/0lF8yJ7fkyjXuqtSi5bWbQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marcellus",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/marcellus/v4/UjiLZzumxWC9whJ86UtaYw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marcellus SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/marcellussc/v4/_jugwxhkkynrvsfrxVx8gS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marck Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/marckscript/v7/O_D1NAZVOFOobLbVtW3bci3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Margarine",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/margarine/v5/DJnJwIrcO_cGkjSzY3MERw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marko One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/markoone/v6/hpP7j861sOAco43iDc4n4w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marmelad",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/marmelad/v6/jI0_FBlSOIRLL0ePWOhOwQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Martel",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/martel/v1/_wfGdswZbat7P4tupHLA1w.ttf",
                "300": "//fonts.gstatic.com/s/martel/v1/SghoV2F2VPdVU3P0a4fa9w.ttf",
                "600": "//fonts.gstatic.com/s/martel/v1/Kt9uPhH1PvUwuZ5Y6zuAMQ.ttf",
                "700": "//fonts.gstatic.com/s/martel/v1/4OzIiKB5wE36xXL2U0vzWQ.ttf",
                "800": "//fonts.gstatic.com/s/martel/v1/RVF8drcQoRkRL7l_ZkpTlQ.ttf",
                "900": "//fonts.gstatic.com/s/martel/v1/iS0YUpFJoiLRlnyl40rpEA.ttf",
                "regular": "//fonts.gstatic.com/s/martel/v1/9ALu5czkaaf5zsYk6GJEnQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Martel Sans",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQEnzyIngrzGjGh22wPb6cGM.ttf",
                "300": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQC9-WlPSxbfiI49GsXo3q0g.ttf",
                "600": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQJZ7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQHe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "800": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQA89PwPrYLaRFJ-HNCU9NbA.ttf",
                "900": "//fonts.gstatic.com/s/martelsans/v2/7ajme85aKKx_SCWF59ImQCenaqEuufTBk9XMKnKmgDA.ttf",
                "regular": "//fonts.gstatic.com/s/martelsans/v2/91c8DPDZncMc0RFfhmc2RqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Marvel",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/marvel/v6/WrHDBL1RupWGo2UcdgxB3Q.ttf",
                "regular": "//fonts.gstatic.com/s/marvel/v6/Fg1dO8tWVb-MlyqhsbXEkg.ttf",
                "italic": "//fonts.gstatic.com/s/marvel/v6/HzyjFB-oR5usrc7Lxz9g8w.ttf",
                "700italic": "//fonts.gstatic.com/s/marvel/v6/Gzf5NT09Y6xskdQRj2kz1qCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mate",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mate/v5/ooFviPcJ6hZP5bAE71Cawg.ttf",
                "italic": "//fonts.gstatic.com/s/mate/v5/5XwW6_cbisGvCX5qmNiqfA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mate SC",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/matesc/v5/-YkIT2TZoPZF6pawKzDpWw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Maven Pro",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "700",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/mavenpro/v7/SQVfzoJBbj9t3aVcmbspRi3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/mavenpro/v7/uDssvmXgp7Nj3i336k_dSi3USBnSvpkopQaUR-2r7iU.ttf",
                "900": "//fonts.gstatic.com/s/mavenpro/v7/-91TwiFzqeL1F7Kh91APwS3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/mavenpro/v7/sqPJIFG4gqsjl-0q_46Gbw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "McLaren",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mclaren/v4/OprvTGxaiINBKW_1_U0eoQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Meddon",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/meddon/v9/f8zJO98uu2EtSj9p7ci9RA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "MedievalSharp",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/medievalsharp/v8/85X_PjV6tftJ0-rX7KYQkOe45sJkivqprK7VkUlzfg0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Medula One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/medulaone/v6/AasPgDQak81dsTGQHc5zUPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Meera Inimai",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "tamil"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/meerainimai/v1/fWbdJc2ZVZnWCi06NRCxDy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Megrim",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/megrim/v7/e-9jVUC9lv1zxaFQARuftw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Meie Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/meiescript/v4/oTIWE5MmPye-rCyVp_6KEqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Merienda",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/merienda/v4/GlwcvRLlgiVE2MBFQ4r0sKCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/merienda/v4/MYY6Og1qZlOQtPW2G95Y3A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Merienda One",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/meriendaone/v7/bCA-uDdUx6nTO8SjzCLXvS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Merriweather",
            "category": "serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v13",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/merriweather/v13/ZvcMqxEwPfh2qDWBPxn6nqcQoVhARpoaILP7amxE_8g.ttf",
                "700": "//fonts.gstatic.com/s/merriweather/v13/ZvcMqxEwPfh2qDWBPxn6nkD2ttfZwueP-QU272T9-k4.ttf",
                "900": "//fonts.gstatic.com/s/merriweather/v13/ZvcMqxEwPfh2qDWBPxn6nqObDOjC3UL77puoeHsE3fw.ttf",
                "300italic": "//fonts.gstatic.com/s/merriweather/v13/EYh7Vl4ywhowqULgRdYwICna0FLWfcB-J_SAYmcAXaI.ttf",
                "regular": "//fonts.gstatic.com/s/merriweather/v13/RFda8w1V0eDZheqfcyQ4EC3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/merriweather/v13/So5lHxHT37p2SS4-t60SlPMZXuCXbOrAvx5R0IT5Oyo.ttf",
                "700italic": "//fonts.gstatic.com/s/merriweather/v13/EYh7Vl4ywhowqULgRdYwIPAs9-1nE9qOqhChW0m4nDE.ttf",
                "900italic": "//fonts.gstatic.com/s/merriweather/v13/EYh7Vl4ywhowqULgRdYwIBd0_s6jQr9r5s5OZYvtzBY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Merriweather Sans",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic",
                "800",
                "800italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/merriweathersans/v8/6LmGj5dOJopQKEkt88Gowan5N8K-_DP0e9e_v51obXQ.ttf",
                "700": "//fonts.gstatic.com/s/merriweathersans/v8/6LmGj5dOJopQKEkt88GowbqxG25nQNOioCZSK4sU-CA.ttf",
                "800": "//fonts.gstatic.com/s/merriweathersans/v8/6LmGj5dOJopQKEkt88GowYufzO2zUYSj5LqoJ3UGkco.ttf",
                "300italic": "//fonts.gstatic.com/s/merriweathersans/v8/nAqt4hiqwq3tzCecpgPmVdytE4nGXk2hYD5nJ740tBw.ttf",
                "regular": "//fonts.gstatic.com/s/merriweathersans/v8/AKu1CjQ4qnV8MUltkAX3sOAj_ty82iuwwDTNEYXGiyQ.ttf",
                "italic": "//fonts.gstatic.com/s/merriweathersans/v8/3Mz4hOHzs2npRMG3B1ascZ32VBCoA_HLsn85tSWZmdo.ttf",
                "700italic": "//fonts.gstatic.com/s/merriweathersans/v8/nAqt4hiqwq3tzCecpgPmVbuqAJxizi8Dk_SK5et7kMg.ttf",
                "800italic": "//fonts.gstatic.com/s/merriweathersans/v8/nAqt4hiqwq3tzCecpgPmVdDmPrYMy3aZO4LmnZsxTQw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Metal Mania",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/metalmania/v6/isriV_rAUgj6bPWPN6l9QKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Metamorphous",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/metamorphous/v6/wGqUKXRinIYggz-BTRU9ei3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Metrophobic",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/metrophobic/v6/SaglWZWCrrv_D17u1i4v_aCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Michroma",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/michroma/v7/0c2XrW81_QsiKV8T9thumA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Milonga",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/milonga/v4/dzNdIUSTGFmy2ahovDRcWg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Miltonian",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/miltonian/v10/Z4HrYZyqm0BnNNzcCUfzoQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Miltonian Tattoo",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v11",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/miltoniantattoo/v11/1oU_8OGYwW46eh02YHydn2uk0YtI6thZkz1Hmh-odwg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Miniver",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/miniver/v5/4yTQohOH_cWKRS5laRFhYg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Miriam Libre",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "700": "//fonts.gstatic.com/s/miriamlibre/v1/FLc0J-Gdn8ynDWUkeeesAED2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/miriamlibre/v1/Ljtpu8zR5iJWmlN3Faba5S3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mirza",
            "category": "display",
            "variants": [
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "500": "//fonts.gstatic.com/s/mirza/v1/dT3HbZoBCx1xbU7PnFEFyQ.ttf",
                "600": "//fonts.gstatic.com/s/mirza/v1/6T4uh2Zti9P6Eq_gbAYvVQ.ttf",
                "700": "//fonts.gstatic.com/s/mirza/v1/b47CZDHoZdhnplmDpZymFw.ttf",
                "regular": "//fonts.gstatic.com/s/mirza/v1/8oe36Xbgj9BMSLJBaZ8VAQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Miss Fajardose",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/missfajardose/v6/WcXjlQPKn6nBfr8LY3ktNu6rPKfVZo7L2bERcf0BDns.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mitr",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/mitr/v1/GCzZRAhweqJhxrmM0bPztg.ttf",
                "300": "//fonts.gstatic.com/s/mitr/v1/A61rQ_y9i8Ja__oFN7KxiQ.ttf",
                "500": "//fonts.gstatic.com/s/mitr/v1/r_Z6yrJJ0zmkGAqxqjlLRg.ttf",
                "600": "//fonts.gstatic.com/s/mitr/v1/42l66tb_XMxM97GKatU9Ng.ttf",
                "700": "//fonts.gstatic.com/s/mitr/v1/V-V7Rul5HOZ651R4Tml2Lw.ttf",
                "regular": "//fonts.gstatic.com/s/mitr/v1/vKMd72X2iT4iBo5GvdCa_A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Modak",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-11",
            "files": {
                "regular": "//fonts.gstatic.com/s/modak/v2/lMsN0QIKid-pCPvL0hH4nw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Modern Antiqua",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/modernantiqua/v6/8qX_tr6Xzy4t9fvZDXPkh6rFJ4O13IHVxZbM6yoslpo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mogra",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/mogra/v1/gIxQBn9PseDaI0D4FnOiBQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Molengo",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/molengo/v7/jcjgeGuzv83I55AzOTpXNQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Molle",
            "category": "handwriting",
            "variants": [
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "italic": "//fonts.gstatic.com/s/molle/v4/9XTdCsjPXifLqo5et-YoGA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Monda",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/monda/v4/EVOzZUyc_j1w2GuTgTAW1g.ttf",
                "regular": "//fonts.gstatic.com/s/monda/v4/qFMHZ9zvR6B_gnoIgosPrw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Monofett",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/monofett/v6/C6K5L799Rgxzg2brgOaqAw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Monoton",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/monoton/v6/aCz8ja_bE4dg-7agSvExdw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Monsieur La Doulaise",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/monsieurladoulaise/v5/IMAdMj6Eq9jZ46CPctFtMKP61oAqTJXlx5ZVOBmcPdM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Montaga",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/montaga/v4/PwTwUboiD-M4-mFjZfJs2A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Montez",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/montez/v6/kx58rLOWQQLGFM4pDHv5Ng.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Montserrat",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/montserrat/v7/IQHow_FEYlDC4Gzy_m8fcgJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/montserrat/v7/Kqy6-utIpx_30Xzecmeo8_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Montserrat Alternates",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/montserratalternates/v4/YENqOGAVzwIHjYNjmKuAZpeqBKvsAhm-s2I4RVSXFfc.ttf",
                "regular": "//fonts.gstatic.com/s/montserratalternates/v4/z2n1Sjxk9souK3HCtdHuklPuEVRGaG9GCQnmM16YWq0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Montserrat Subrayada",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/montserratsubrayada/v4/wf-IKpsHcfm0C9uaz9IeGJvEcF1LWArDbGWgKZSH9go.ttf",
                "regular": "//fonts.gstatic.com/s/montserratsubrayada/v4/nzoCWCz0e9c7Mr2Gl8bbgrJymm6ilkk9f0nDA_sC_qk.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mountains of Christmas",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/mountainsofchristmas/v8/PymufKtHszoLrY0uiAYKNM9cPTbSBTrQyTa5TWAe3vE.ttf",
                "regular": "//fonts.gstatic.com/s/mountainsofchristmas/v8/dVGBFPwd6G44IWDbQtPew2Auds3jz1Fxb61CgfaGDr4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mouse Memoirs",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mousememoirs/v4/NBFaaJFux_j0AQbAsW3QeH8f0n03UdmQgF_CLvNR2vg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mr Bedfort",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mrbedfort/v5/81bGgHTRikLs_puEGshl7_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mr Dafoe",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mrdafoe/v5/s32Q1S6ZkT7EaX53mUirvQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mr De Haviland",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mrdehaviland/v5/fD8y4L6PJ4vqDk7z8Y8e27v4lrhng1lzu7-weKO6cw8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mrs Saint Delafield",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mrssaintdelafield/v4/vuWagfFT7bj9lFtZOFBwmjHMBelqWf3tJeGyts2SmKU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mrs Sheppards",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mrssheppards/v5/2WFsWMV3VUeCz6UVH7UjCn8f0n03UdmQgF_CLvNR2vg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mukta Vaani",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_0nzyIngrzGjGh22wPb6cGM.ttf",
                "300": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_y9-WlPSxbfiI49GsXo3q0g.ttf",
                "500": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_8CNfqCYlB_eIx7H1TVXe60.ttf",
                "600": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_5Z7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_3e1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "800": "//fonts.gstatic.com/s/muktavaani/v1/X9qyC4rK_D9w1AvSv0mw_w89PwPrYLaRFJ-HNCU9NbA.ttf",
                "regular": "//fonts.gstatic.com/s/muktavaani/v1/knS0wTOFNOwOD4CZrdHIxKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Muli",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/muli/v7/VJw4F3ZHRAZ7Hmg3nQu5YQ.ttf",
                "300italic": "//fonts.gstatic.com/s/muli/v7/s-NKMCru8HiyjEt0ZDoBoA.ttf",
                "regular": "//fonts.gstatic.com/s/muli/v7/KJiP6KznxbALQgfJcDdPAw.ttf",
                "italic": "//fonts.gstatic.com/s/muli/v7/Cg0K_IWANs9xkNoxV7H1_w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Mystery Quest",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/mysteryquest/v4/467jJvg0c7HgucvBB9PLDyeUSrabuTpOsMEiRLtKwk0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Neucha",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/neucha/v8/bijdhB-TzQdtpl0ykhGh4Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Neuton",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "italic",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/neuton/v8/DA3Mkew3XqSkPpi1f4tJow.ttf",
                "300": "//fonts.gstatic.com/s/neuton/v8/xrc_aZ2hx-gdeV0mlY8Vww.ttf",
                "700": "//fonts.gstatic.com/s/neuton/v8/gnWpkWY7DirkKiovncYrfg.ttf",
                "800": "//fonts.gstatic.com/s/neuton/v8/XPzBQV4lY6enLxQG9cF1jw.ttf",
                "regular": "//fonts.gstatic.com/s/neuton/v8/9R-MGIOQUdjAVeB6nE6PcQ.ttf",
                "italic": "//fonts.gstatic.com/s/neuton/v8/uVMT3JOB5BNFi3lgPp6kEg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "New Rocker",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/newrocker/v5/EFUWzHJedEkpW399zYOHofesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "News Cycle",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v13",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/newscycle/v13/G28Ny31cr5orMqEQy6ljtwJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/newscycle/v13/xyMAr8VfiUzIOvS1abHJO_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Niconne",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/niconne/v6/ZA-mFw2QNXodx5y7kfELBg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nixie One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/nixieone/v7/h6kQfmzm0Shdnp3eswRaqQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nobile",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/nobile/v7/9p6M-Yrg_r_QPmSD1skrOg.ttf",
                "regular": "//fonts.gstatic.com/s/nobile/v7/lC_lPi1ddtN38iXTCRh6ow.ttf",
                "italic": "//fonts.gstatic.com/s/nobile/v7/vGmrpKzWQQSrb-PR6FWBIA.ttf",
                "700italic": "//fonts.gstatic.com/s/nobile/v7/oQ1eYPaXV638N03KvsNvyKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Norican",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/norican/v4/SHnSqhYAWG5sZTWcPzEHig.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nosifer",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/nosifer/v5/7eJGoIuHRrtcG00j6CptSA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nothing You Could Do",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/nothingyoucoulddo/v6/jpk1K3jbJoyoK0XKaSyQAf-TpkXjXYGWiJZAEtBRjPU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Noticia Text",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/noticiatext/v6/pEko-RqEtp45bE2P80AAKUD2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/noticiatext/v6/wdyV6x3eKpdeUPQ7BJ5uUC3USBnSvpkopQaUR-2r7iU.ttf",
                "italic": "//fonts.gstatic.com/s/noticiatext/v6/dAuxVpkYE_Q_IwIm6elsKPMZXuCXbOrAvx5R0IT5Oyo.ttf",
                "700italic": "//fonts.gstatic.com/s/noticiatext/v6/-rQ7V8ARjf28_b7kRa0JuvAs9-1nE9qOqhChW0m4nDE.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Noto Sans",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "devanagari",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/notosans/v6/PIbvSEyHEdL91QLOQRnZ1y3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/notosans/v6/0Ue9FiUJwVhi4NGfHJS5uA.ttf",
                "italic": "//fonts.gstatic.com/s/notosans/v6/dLcNKMgJ1H5RVoZFraDz0qCWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/notosans/v6/9Z3uUWMRR7crzm1TjRicDne1Pd76Vl7zRpE7NLJQ7XU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Noto Serif",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/notoserif/v4/lJAvZoKA5NttpPc9yc6lPQJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/notoserif/v4/zW6mc7bC1CWw8dH0yxY8JfesZW2xOQ-xsNqO47m55DA.ttf",
                "italic": "//fonts.gstatic.com/s/notoserif/v4/HQXBIwLHsOJCNEQeX9kNzy3USBnSvpkopQaUR-2r7iU.ttf",
                "700italic": "//fonts.gstatic.com/s/notoserif/v4/Wreg0Be4tcFGM2t6VWytvED2ttfZwueP-QU272T9-k4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Cut",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novacut/v8/6q12jWcBvj0KO2cMRP97tA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Flat",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novaflat/v8/pK7a0CoGzI684qe_XSHBqQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "greek",
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novamono/v7/6-SChr5ZIaaasJFBkgrLNw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Oval",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novaoval/v8/VuukVpKP8BwUf8o9W5LYQQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Round",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novaround/v8/7-cK3Ari_8XYYFgVMxVhDvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Script",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novascript/v8/dEvxQDLgx1M1TKY-NmBWYaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Slim",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novaslim/v8/rPYXC81_VL2EW-4CzBX65g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nova Square",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/novasquare/v8/BcBzXoaDzYX78rquGXVuSqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Numans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/numans/v6/g5snI2p6OEjjTNmTHyBdiQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Nunito",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/nunito/v7/zXQvrWBJqUooM7Xv98MrQw.ttf",
                "700": "//fonts.gstatic.com/s/nunito/v7/aEdlqgMuYbpe4U3TnqOQMA.ttf",
                "regular": "//fonts.gstatic.com/s/nunito/v7/ySZTeT3IuzJj0GK6uGpbBg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Offside",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/offside/v4/v0C913SB8wqQUvcu1faUqw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Old Standard TT",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/oldstandardtt/v7/5Ywdce7XEbTSbxs__4X1_HJqbZqK7TdZ58X80Q_Lw8Y.ttf",
                "regular": "//fonts.gstatic.com/s/oldstandardtt/v7/n6RTCDcIPWSE8UNBa4k-DLcB5jyhm1VsHs65c3QNDr0.ttf",
                "italic": "//fonts.gstatic.com/s/oldstandardtt/v7/QQT_AUSp4AV4dpJfIN7U5PWrQzeMtsHf8QsWQ2cZg3c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oldenburg",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/oldenburg/v4/dqA_M_uoCVXZbCO-oKBTnQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oleo Script",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/oleoscript/v5/hudNQFKFl98JdNnlo363fne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/oleoscript/v5/21stZcmPyzbQVXtmGegyqKCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oleo Script Swash Caps",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/oleoscriptswashcaps/v4/HMO3ftxA9AU5floml9c755reFYaXZ4zuJXJ8fr8OO1g.ttf",
                "regular": "//fonts.gstatic.com/s/oleoscriptswashcaps/v4/vdWhGqsBUAP-FF3NOYTe4iMF4kXAPemmyaDpMXQ31P0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Open Sans",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v13",
            "lastModified": "2016-05-20",
            "files": {
                "300": "//fonts.gstatic.com/s/opensans/v13/DXI1ORHCpsQm3Vp6mXoaTS3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/opensans/v13/MTP_ySUJH_bn48VBG8sNSi3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/opensans/v13/k3k702ZOKiLJc3WVjuplzC3USBnSvpkopQaUR-2r7iU.ttf",
                "800": "//fonts.gstatic.com/s/opensans/v13/EInbV5DfGHOiMmvb1Xr-hi3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/opensans/v13/PRmiXeptR36kaC0GEAetxi9-WlPSxbfiI49GsXo3q0g.ttf",
                "regular": "//fonts.gstatic.com/s/opensans/v13/IgZJs4-7SA1XX_edsoXWog.ttf",
                "italic": "//fonts.gstatic.com/s/opensans/v13/O4NhV7_qs9r9seTo7fnsVKCWcynf_cDxXwCLxiixG1c.ttf",
                "600italic": "//fonts.gstatic.com/s/opensans/v13/PRmiXeptR36kaC0GEAetxpZ7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700italic": "//fonts.gstatic.com/s/opensans/v13/PRmiXeptR36kaC0GEAetxne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "800italic": "//fonts.gstatic.com/s/opensans/v13/PRmiXeptR36kaC0GEAetxg89PwPrYLaRFJ-HNCU9NbA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Open Sans Condensed",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v10",
            "lastModified": "2016-05-20",
            "files": {
                "300": "//fonts.gstatic.com/s/opensanscondensed/v10/gk5FxslNkTTHtojXrkp-xEMwSSh38KQVJx4ABtsZTnA.ttf",
                "700": "//fonts.gstatic.com/s/opensanscondensed/v10/gk5FxslNkTTHtojXrkp-xBEM87DM3yorPOrvA-vB930.ttf",
                "300italic": "//fonts.gstatic.com/s/opensanscondensed/v10/jIXlqT1WKafUSwj6s9AzV4_LkTZ_uhAwfmGJ084hlvM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oranienbaum",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/oranienbaum/v5/M98jYwCSn0PaFhXXgviCoaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Orbitron",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "700",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/orbitron/v7/p-y_ffzMdo5JN_7ia0vYEqCWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/orbitron/v7/PS9_6SLkY1Y6OgPO3APr6qCWcynf_cDxXwCLxiixG1c.ttf",
                "900": "//fonts.gstatic.com/s/orbitron/v7/2I3-8i9hT294TE_pyjy9SaCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/orbitron/v7/DY8swouAZjR3RaUPRf0HDQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oregano",
            "category": "display",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/oregano/v4/UiLhqNixVv2EpjRoBG6axA.ttf",
                "italic": "//fonts.gstatic.com/s/oregano/v4/_iwqGEht6XsAuEaCbYG64Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Orienta",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/orienta/v4/_NKSk93mMs0xsqtfjCsB3Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Original Surfer",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/originalsurfer/v5/gdHw6HpSIN4D6Xt7pi1-qIkEz33TDwAZczo_6fY7eg0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oswald",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v11",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/oswald/v11/y3tZpCdiRD4oNRRYFcAR5Q.ttf",
                "700": "//fonts.gstatic.com/s/oswald/v11/7wj8ldV_5Ti37rHa0m1DDw.ttf",
                "regular": "//fonts.gstatic.com/s/oswald/v11/uLEd2g2vJglLPfsBF91DCg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Over the Rainbow",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/overtherainbow/v7/6gp-gkpI2kie2dHQQLM2jQBdxkZd83xOSx-PAQ2QmiI.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Overlock",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/overlock/v5/Fexr8SqXM8Bm_gEVUA7AKaCWcynf_cDxXwCLxiixG1c.ttf",
                "900": "//fonts.gstatic.com/s/overlock/v5/YPJCVTT8ZbG3899l_-KIGqCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/overlock/v5/Z8oYsGi88-E1cUB8YBFMAg.ttf",
                "italic": "//fonts.gstatic.com/s/overlock/v5/rq6EacukHROOBrFrK_zF6_esZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/overlock/v5/wFWnYgeXKYBks6gEUwYnfAJKKGfqHaYFsRG-T3ceEVo.ttf",
                "900italic": "//fonts.gstatic.com/s/overlock/v5/iOZhxT2zlg7W5ij_lb-oDp0EAVxt0G0biEntp43Qt6E.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Overlock SC",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/overlocksc/v5/8D7HYDsvS_g1GhBnlHzgzaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ovo",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/ovo/v7/mFg27dimu3s9t09qjCwB1g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oxygen",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/oxygen/v5/lZ31r0bR1Bzt_DfGZu1S8A.ttf",
                "700": "//fonts.gstatic.com/s/oxygen/v5/yLqkmDwuNtt5pSqsJmhyrg.ttf",
                "regular": "//fonts.gstatic.com/s/oxygen/v5/uhoyAE7XlQL22abzQieHjw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Oxygen Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/oxygenmono/v4/DigTu7k4b7OmM8ubt1Qza6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ptmono/v4/QUbM8H9yJK5NhpQ0REO6Wg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Sans",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ptsans/v8/F51BEgHuR0tYHxF0bD4vwvesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/ptsans/v8/UFoEz2uiuMypUGZL1NKoeg.ttf",
                "italic": "//fonts.gstatic.com/s/ptsans/v8/yls9EYWOd496wiu7qzfgNg.ttf",
                "700italic": "//fonts.gstatic.com/s/ptsans/v8/lILlYDvubYemzYzN7GbLkC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Sans Caption",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ptsanscaption/v9/Q-gJrFokeE7JydPpxASt25tc0eyfI4QDEsobEEpk_hA.ttf",
                "regular": "//fonts.gstatic.com/s/ptsanscaption/v9/OXYTDOzBcXU8MTNBvBHeSW8by34Z3mUMtM-o4y-SHCY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Sans Narrow",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ptsansnarrow/v7/Q_pTky3Sc3ubRibGToTAYsLtdzs3iyjn_YuT226ZsLU.ttf",
                "regular": "//fonts.gstatic.com/s/ptsansnarrow/v7/UyYrYy3ltEffJV9QueSi4ZTvAuddT2xDMbdz0mdLyZY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Serif",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ptserif/v8/kyZw18tqQ5if-_wpmxxOeKCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/ptserif/v8/sAo427rn3-QL9sWCbMZXhA.ttf",
                "italic": "//fonts.gstatic.com/s/ptserif/v8/9khWhKzhpkH0OkNnBKS3n_esZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/ptserif/v8/Foydq9xJp--nfYIx2TBz9QJKKGfqHaYFsRG-T3ceEVo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "PT Serif Caption",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ptserifcaption/v8/7xkFOeTxxO1GMC1suOUYWVsRioCqs5fohhaYel24W3k.ttf",
                "italic": "//fonts.gstatic.com/s/ptserifcaption/v8/0kfPsmrmTSgiec7u_Wa0DB1mqvzPHelJwRcF_s_EUM0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pacifico",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/pacifico/v7/GIrpeRY1r5CzbfL8r182lw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Palanquin",
            "category": "sans-serif",
            "variants": [
                "100",
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/palanquin/v1/Hu0eGDVGK_g4saUFu6AK3KCWcynf_cDxXwCLxiixG1c.ttf",
                "200": "//fonts.gstatic.com/s/palanquin/v1/pqXYXD7-VI5ezTjeqQOcyC3USBnSvpkopQaUR-2r7iU.ttf",
                "300": "//fonts.gstatic.com/s/palanquin/v1/c0-J5OCAagpFCKkKraz-Ey3USBnSvpkopQaUR-2r7iU.ttf",
                "500": "//fonts.gstatic.com/s/palanquin/v1/wLvvkEcZMKy95afLWh2EfC3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/palanquin/v1/405UIAv95_yZkCECrH6y-i3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/palanquin/v1/-UtkePo3NFvxEN3rGCtTvi3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/palanquin/v1/xCwBUoAEV0kzCDwerAZ0Aw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Palanquin Dark",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/palanquindark/v1/iXyBGf5UbFUu6BG8hOY-maMZTo-EwKMRQt3RWHocLi0.ttf",
                "600": "//fonts.gstatic.com/s/palanquindark/v1/iXyBGf5UbFUu6BG8hOY-mVNxaunw8i4Gywrk2SigRnk.ttf",
                "700": "//fonts.gstatic.com/s/palanquindark/v1/iXyBGf5UbFUu6BG8hOY-mWToair6W0TEE44XrlfKbiM.ttf",
                "regular": "//fonts.gstatic.com/s/palanquindark/v1/PamTqrrgbBh_M3702w39rOfChn3JSg5yz_Q_xmrKQN0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Paprika",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/paprika/v4/b-VpyoRSieBdB5BPJVF8HQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Parisienne",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/parisienne/v4/TW74B5QISJNx9moxGlmJfvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Passero One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/passeroone/v8/Yc-7nH5deCCv9Ed0MMnAQqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Passion One",
            "category": "display",
            "variants": [
                "regular",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/passionone/v6/feOcYDy2R-f3Ysy72PYJ2ne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "900": "//fonts.gstatic.com/s/passionone/v6/feOcYDy2R-f3Ysy72PYJ2ienaqEuufTBk9XMKnKmgDA.ttf",
                "regular": "//fonts.gstatic.com/s/passionone/v6/1UIK1tg3bKJ4J3o35M4heqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pathway Gothic One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/pathwaygothicone/v4/Lqv9ztoTUV8Q0FmQZzPqaA6A6xIYD7vYcYDop1i-K-c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Patrick Hand",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/patrickhand/v10/9BG3JJgt_HlF3NpEUehL0C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Patrick Hand SC",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/patrickhandsc/v4/OYFWCgfCR-7uHIovjUZXsbAgSRh1LpJXlLfl8IbsmHg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pattaya",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/pattaya/v1/sJEout1xdD7J8H-1H81pIQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Patua One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/patuaone/v6/njZwotTYjswR4qdhsW-kJw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pavanam",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "tamil",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/pavanam/v1/C7yuEhNK5oftNLSL3I0bGw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Paytone One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/paytoneone/v8/3WCxC7JAJjQHQVoIE0ZwvqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Peddana",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/peddana/v4/zaSZuj_GhmC8AOTugOROnA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Peralta",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/peralta/v4/cTJX5KEuc0GKRU9NXSm-8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Permanent Marker",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/permanentmarker/v5/9vYsg5VgPHKK8SXYbf3sMol14xj5tdg9OHF8w4E7StQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Petit Formal Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/petitformalscript/v4/OEZwr2-ovBsq2n3ACCKoEvVPl2Gjtxj0D6F7QLy1VQc.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Petrona",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/petrona/v5/nnQwxlP6dhrGovYEFtemTg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Philosopher",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/philosopher/v7/napvkewXG9Gqby5vwGHICHe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/philosopher/v7/oZLTrB9jmJsyV0u_T0TKEaCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/philosopher/v7/_9Hnc_gz9k7Qq6uKaeHKmUeOrDcLawS7-ssYqLr2Xp4.ttf",
                "700italic": "//fonts.gstatic.com/s/philosopher/v7/PuKlryTcvTj7-qZWfLCFIM_zJjSACmk0BRPxQqhnNLU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Piedra",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/piedra/v5/owf-AvEEyAj9LJ2tVZ_3Mw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pinyon Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/pinyonscript/v6/TzghnhfCn7TuE73f-CBQ0CeUSrabuTpOsMEiRLtKwk0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pirata One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/pirataone/v4/WnbD86B4vB2ckYcL7oxuhvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Plaster",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/plaster/v8/O4QG9Z5116CXyfJdR9zxLw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Play",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/play/v7/crPhg6I0alLI-MpB3vW-zw.ttf",
                "regular": "//fonts.gstatic.com/s/play/v7/GWvfObW8LhtsOX333MCpBg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Playball",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/playball/v6/3hOFiQm_EUzycTpcN9uz4w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Playfair Display",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v10",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/playfairdisplay/v10/UC3ZEjagJi85gF9qFaBgICsv6SrURqJprbhH_C1Mw8w.ttf",
                "900": "//fonts.gstatic.com/s/playfairdisplay/v10/UC3ZEjagJi85gF9qFaBgIKqwMe2wjvZrAR44M0BJZ48.ttf",
                "regular": "//fonts.gstatic.com/s/playfairdisplay/v10/2NBgzUtEeyB-Xtpr9bm1CV6uyC_qD11hrFQ6EGgTJWI.ttf",
                "italic": "//fonts.gstatic.com/s/playfairdisplay/v10/9MkijrV-dEJ0-_NWV7E6NzMsbnvDNEBX25F5HWk9AhI.ttf",
                "700italic": "//fonts.gstatic.com/s/playfairdisplay/v10/n7G4PqJvFP2Kubl0VBLDECsYW3XoOVcYyYdp9NzzS9E.ttf",
                "900italic": "//fonts.gstatic.com/s/playfairdisplay/v10/n7G4PqJvFP2Kubl0VBLDEC0JfJ4xmm7j1kL6D7mPxrA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Playfair Display SC",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/playfairdisplaysc/v5/5ggqGkvWJU_TtW2W8cEubA-Amcyomnuy4WsCiPxGHjw.ttf",
                "900": "//fonts.gstatic.com/s/playfairdisplaysc/v5/5ggqGkvWJU_TtW2W8cEubKXL3C32k275YmX_AcBPZ7w.ttf",
                "regular": "//fonts.gstatic.com/s/playfairdisplaysc/v5/G0-tvBxd4eQRdwFKB8dRkcpjYTDWIvcAwAccqeW9uNM.ttf",
                "italic": "//fonts.gstatic.com/s/playfairdisplaysc/v5/myuYiFR-4NTrUT4w6TKls2klJsJYggW8rlNoTOTuau0.ttf",
                "700italic": "//fonts.gstatic.com/s/playfairdisplaysc/v5/6X0OQrQhEEnPo56RalREX4krgPi80XvBcbTwmz-rgmU.ttf",
                "900italic": "//fonts.gstatic.com/s/playfairdisplaysc/v5/6X0OQrQhEEnPo56RalREX8Zag2q3ssKz8uH1RU4a9gs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Podkova",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/podkova/v8/SqW4aa8m_KVrOgYSydQ33vesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/podkova/v8/eylljyGVfB8ZUQjYY3WZRQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Poiret One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/poiretone/v4/dWcYed048E5gHGDIt8i1CPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Poller One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/pollerone/v6/dkctmDlTPcZ6boC8662RA_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Poly",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/poly/v7/bcMAuiacS2qkd54BcwW6_Q.ttf",
                "italic": "//fonts.gstatic.com/s/poly/v7/Zkx-eIlZSjKUrPGYhV5PeA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pompiere",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/pompiere/v6/o_va2p9CD5JfmFohAkGZIA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pontano Sans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/pontanosans/v4/gTHiwyxi6S7iiHpqAoiE3C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Poppins",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/poppins/v1/VIeViZ2fPtYBt3B2fQZplvesZW2xOQ-xsNqO47m55DA.ttf",
                "500": "//fonts.gstatic.com/s/poppins/v1/4WGKlFyjcmCFVl8pRsgZ9vesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/poppins/v1/-zOABrCWORC3lyDh-ajNnPesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/poppins/v1/8JitanEsk5aDh7mDYs-fYfesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/poppins/v1/hlvAxH6aIdOjWlLzgm0jqg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Port Lligat Sans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/portlligatsans/v5/CUEdhRk7oC7up0p6t0g4P6mASEpx5X0ZpsuJOuvfOGA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Port Lligat Slab",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/portlligatslab/v5/CUEdhRk7oC7up0p6t0g4PxLSPACXvawUYCBEnHsOe30.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pragati Narrow",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/pragatinarrow/v2/DnSI1zRkc0CY-hI5SC3q3MLtdzs3iyjn_YuT226ZsLU.ttf",
                "regular": "//fonts.gstatic.com/s/pragatinarrow/v2/HzG2TfC862qPNsZsV_djPpTvAuddT2xDMbdz0mdLyZY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Prata",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/prata/v6/3gmx8r842loRRm9iQkCDGg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Press Start 2P",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "greek",
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/pressstart2p/v4/8Lg6LX8-ntOHUQnvQ0E7o1jfl3W46Sz5gOkEVhcFWF4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Pridi",
            "category": "serif",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "200": "//fonts.gstatic.com/s/pridi/v1/WvKJ-kflGuELyK4uQzpYIA.ttf",
                "300": "//fonts.gstatic.com/s/pridi/v1/Ihwk-OGVFS69PINILdqAjQ.ttf",
                "500": "//fonts.gstatic.com/s/pridi/v1/dPNOrMxU-HjLo-fvkFydsQ.ttf",
                "600": "//fonts.gstatic.com/s/pridi/v1/J0i5OZxX07KC4mby5RjNbg.ttf",
                "700": "//fonts.gstatic.com/s/pridi/v1/UhCy4jDDJttTB8k8rtWadg.ttf",
                "regular": "//fonts.gstatic.com/s/pridi/v1/Mau018Ghi7LJX7FkGYCZAQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Princess Sofia",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/princesssofia/v4/8g5l8r9BM0t1QsXLTajDe-wjmA7ie-lFcByzHGRhCIg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Prociono",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/prociono/v6/43ZYDHWogdFeNBWTl6ksmw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Prompt",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/prompt/v1/ltjX-trOmfS-yKy_awt70g.ttf",
                "200": "//fonts.gstatic.com/s/prompt/v1/MNB_CVkbfYHFMWX_UbDC2Q.ttf",
                "300": "//fonts.gstatic.com/s/prompt/v1/LzifakiWysr3N3OoAdbdpg.ttf",
                "500": "//fonts.gstatic.com/s/prompt/v1/w31OY1otplAgr5iZ21K7Fg.ttf",
                "600": "//fonts.gstatic.com/s/prompt/v1/uUrJjg1BGaIb6CAOlUIp9g.ttf",
                "700": "//fonts.gstatic.com/s/prompt/v1/HdM_epiStzshOr-49ubVyg.ttf",
                "800": "//fonts.gstatic.com/s/prompt/v1/GF9cOamDd7mYPHNW1nZLKg.ttf",
                "900": "//fonts.gstatic.com/s/prompt/v1/KFgmbwHbRBQb28VFhH3c8Q.ttf",
                "100italic": "//fonts.gstatic.com/s/prompt/v1/KvTeArBpVb-tA2mahV6Jk_esZW2xOQ-xsNqO47m55DA.ttf",
                "200italic": "//fonts.gstatic.com/s/prompt/v1/NR0JuXzzCDKpLNVhfyEAiaCWcynf_cDxXwCLxiixG1c.ttf",
                "300italic": "//fonts.gstatic.com/s/prompt/v1/ir8BhbeDHM-qnbo-tnpmt6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/prompt/v1/nDo1rQFnTFNua4cp-OnD2A.ttf",
                "italic": "//fonts.gstatic.com/s/prompt/v1/ZD4khIP924SU2fRYOJkraQ.ttf",
                "500italic": "//fonts.gstatic.com/s/prompt/v1/dfaeaRx00u9arVHsaDjliaCWcynf_cDxXwCLxiixG1c.ttf",
                "600italic": "//fonts.gstatic.com/s/prompt/v1/CJUBMsoNNHMMdFRxm-n7p6CWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/prompt/v1/GtXRH7QWy3aLCHoJuR5WIKCWcynf_cDxXwCLxiixG1c.ttf",
                "800italic": "//fonts.gstatic.com/s/prompt/v1/kBLgnnEB-VXkOLFCc0pzwqCWcynf_cDxXwCLxiixG1c.ttf",
                "900italic": "//fonts.gstatic.com/s/prompt/v1/qjrOe-lEPwDDeUu5g6q_DaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Prosto One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/prostoone/v5/bsqnAElAqk9kX7eABTRFJPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Proza Libre",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "500": "//fonts.gstatic.com/s/prozalibre/v1/4gjxWDPA6RMWrIls_qgQBsCNfqCYlB_eIx7H1TVXe60.ttf",
                "600": "//fonts.gstatic.com/s/prozalibre/v1/4gjxWDPA6RMWrIls_qgQBpZ7xm-Bj30Bj2KNdXDzSZg.ttf",
                "700": "//fonts.gstatic.com/s/prozalibre/v1/4gjxWDPA6RMWrIls_qgQBne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "800": "//fonts.gstatic.com/s/prozalibre/v1/4gjxWDPA6RMWrIls_qgQBg89PwPrYLaRFJ-HNCU9NbA.ttf",
                "regular": "//fonts.gstatic.com/s/prozalibre/v1/Hg11OrfE1P_U6mKmrZPknKCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/prozalibre/v1/ClQTew5IUT7yKo8vyspLxEeOrDcLawS7-ssYqLr2Xp4.ttf",
                "500italic": "//fonts.gstatic.com/s/prozalibre/v1/rWq3Qp4ZlPGKduc1qkgLHGnWRcJAYo5PSCx8UfGMHCI.ttf",
                "600italic": "//fonts.gstatic.com/s/prozalibre/v1/rWq3Qp4ZlPGKduc1qkgLHJe6We3S5L6hKLscKpOkmlo.ttf",
                "700italic": "//fonts.gstatic.com/s/prozalibre/v1/rWq3Qp4ZlPGKduc1qkgLHM_zJjSACmk0BRPxQqhnNLU.ttf",
                "800italic": "//fonts.gstatic.com/s/prozalibre/v1/rWq3Qp4ZlPGKduc1qkgLHCad_7rtf4IdDfsLVg-2OV4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Puritan",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/puritan/v8/pJS2SdwI0SCiVnO0iQSFT_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/puritan/v8/wv_RtgVBSCn-or2MC0n4Kg.ttf",
                "italic": "//fonts.gstatic.com/s/puritan/v8/BqZX8Tp200LeMv1KlzXgLQ.ttf",
                "700italic": "//fonts.gstatic.com/s/puritan/v8/rFG3XkMJL75nUNZwCEIJqC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Purple Purse",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/purplepurse/v5/Q5heFUrdmei9axbMITxxxS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quando",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/quando/v5/03nDiEZuO2-h3xvtG6UmHg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quantico",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/quantico/v5/OVZZzjcZ3Hkq2ojVcUtDjaCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/quantico/v5/pwSnP8Xpaix2rIz99HrSlQ.ttf",
                "italic": "//fonts.gstatic.com/s/quantico/v5/KQhDd2OsZi6HiITUeFQ2U_esZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/quantico/v5/HeCYRcZbdRso3ZUu01ELbQJKKGfqHaYFsRG-T3ceEVo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quattrocento",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/quattrocento/v8/Uvi-cRwyvqFpl9j3oT2mqkD2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/quattrocento/v8/WZDISdyil4HsmirlOdBRFC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quattrocento Sans",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/quattrocentosans/v9/tXSgPxDl7Lk8Zr_5qX8FIbqxG25nQNOioCZSK4sU-CA.ttf",
                "regular": "//fonts.gstatic.com/s/quattrocentosans/v9/efd6FGWWGX5Z3ztwLBrG9eAj_ty82iuwwDTNEYXGiyQ.ttf",
                "italic": "//fonts.gstatic.com/s/quattrocentosans/v9/8PXYbvM__bjl0rBnKiByg532VBCoA_HLsn85tSWZmdo.ttf",
                "700italic": "//fonts.gstatic.com/s/quattrocentosans/v9/8N1PdXpbG6RtFvTjl-5E7buqAJxizi8Dk_SK5et7kMg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Questrial",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/questrial/v6/MoHHaw_WwNs_hd9ob1zTVw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quicksand",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/quicksand/v5/qhfoJiLu10kFjChCCTvGlC3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/quicksand/v5/32nyIRHyCu6iqEka_hbKsi3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/quicksand/v5/Ngv3fIJjKB7sD-bTUGIFCA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Quintessential",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/quintessential/v4/mmk6ioesnTrEky_Zb92E5s02lXbtMOtZWfuxKeMZO8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Qwigley",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/qwigley/v6/aDqxws-KubFID85TZHFouw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Racing Sans One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/racingsansone/v4/1r3DpWaCiT7y3PD4KgkNyDjVlsJB_M_Q_LtZxsoxvlw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Radley",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/radley/v9/FgE9di09a-mXGzAIyI6Q9Q.ttf",
                "italic": "//fonts.gstatic.com/s/radley/v9/Z_JcACuPAOO2f9kzQcGRug.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rajdhani",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/rajdhani/v5/9pItuEhQZVGdq8spnHTku6CWcynf_cDxXwCLxiixG1c.ttf",
                "500": "//fonts.gstatic.com/s/rajdhani/v5/nd_5ZpVwm710HcLual0fBqCWcynf_cDxXwCLxiixG1c.ttf",
                "600": "//fonts.gstatic.com/s/rajdhani/v5/5fnmZahByDeTtgxIiqbJSaCWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/rajdhani/v5/UBK6d2Hg7X7wYLlF92aXW6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/rajdhani/v5/Wfy5zp4PGFAFS7-Wetehzw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rakkas",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/rakkas/v1/XWSZpoSbAR4myQgKbSJM9A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Raleway",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v11",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/raleway/v11/UDfD6oxBaBnmFJwQ7XAFNw.ttf",
                "200": "//fonts.gstatic.com/s/raleway/v11/LAQwev4hdCtYkOYX4Oc7nPesZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/raleway/v11/2VvSZU2kb4DZwFfRM4fLQPesZW2xOQ-xsNqO47m55DA.ttf",
                "500": "//fonts.gstatic.com/s/raleway/v11/348gn6PEmbLDWlHbbV15d_esZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/raleway/v11/M7no6oPkwKYJkedjB1wqEvesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/raleway/v11/VGEV9-DrblisWOWLbK-1XPesZW2xOQ-xsNqO47m55DA.ttf",
                "800": "//fonts.gstatic.com/s/raleway/v11/mMh0JrsYMXcLO69jgJwpUvesZW2xOQ-xsNqO47m55DA.ttf",
                "900": "//fonts.gstatic.com/s/raleway/v11/ajQQGcDBLcyLpaUfD76UuPesZW2xOQ-xsNqO47m55DA.ttf",
                "100italic": "//fonts.gstatic.com/s/raleway/v11/hUpHtml6IPNuUR-FwVi2UKCWcynf_cDxXwCLxiixG1c.ttf",
                "200italic": "//fonts.gstatic.com/s/raleway/v11/N2DIbZG4399cPGfifZUEQi3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/raleway/v11/TVSB8ogXDKMcnAAJ5CqrUi3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/raleway/v11/_dCzxpXzIS3sL-gdJWAP8A.ttf",
                "italic": "//fonts.gstatic.com/s/raleway/v11/utU2m1gdZSfuQpArSy5Dbw.ttf",
                "500italic": "//fonts.gstatic.com/s/raleway/v11/S7vGLZZ40c85SJgiptJGVy3USBnSvpkopQaUR-2r7iU.ttf",
                "600italic": "//fonts.gstatic.com/s/raleway/v11/OY22yoG8EJ3IN_muVWm29C3USBnSvpkopQaUR-2r7iU.ttf",
                "700italic": "//fonts.gstatic.com/s/raleway/v11/lFxvRPuGFG5ktd7P0WRwKi3USBnSvpkopQaUR-2r7iU.ttf",
                "800italic": "//fonts.gstatic.com/s/raleway/v11/us4LjTCmlYgh3W8CKujEJi3USBnSvpkopQaUR-2r7iU.ttf",
                "900italic": "//fonts.gstatic.com/s/raleway/v11/oY2RadnkHfshu5f0FLsgVS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Raleway Dots",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ralewaydots/v4/lhLgmWCRcyz-QXo8LCzTfC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ramabhadra",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ramabhadra/v5/JyhxLXRVQChLDGADS_c5MPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ramaraja",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ramaraja/v1/XIqzxFapVczstBedHdQTiw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rambla",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/rambla/v4/C5VZH8BxQKmnBuoC00UPpw.ttf",
                "regular": "//fonts.gstatic.com/s/rambla/v4/YaTmpvm5gFg_ShJKTQmdzg.ttf",
                "italic": "//fonts.gstatic.com/s/rambla/v4/mhUgsKmp0qw3uATdDDAuwA.ttf",
                "700italic": "//fonts.gstatic.com/s/rambla/v4/ziMzUZya6QahrKONSI1TzqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rammetto One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rammettoone/v5/mh0uQ1tV8QgSx9v_KyEYPC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ranchers",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ranchers/v4/9ya8CZYhqT66VERfjQ7eLA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rancho",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/rancho/v6/ekp3-4QykC4--6KaslRgHA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ranga",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ranga/v1/h8G_gEUH7vHKH-NkjAs34A.ttf",
                "regular": "//fonts.gstatic.com/s/ranga/v1/xpW6zFTNzY1JykoBIqE1Zg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rasa",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/rasa/v1/XQ1gDq2EqBtGcdadPyPbww.ttf",
                "500": "//fonts.gstatic.com/s/rasa/v1/HfsDi_Ls3NARO_YEODINGg.ttf",
                "600": "//fonts.gstatic.com/s/rasa/v1/f-fvbq-hWIQCdmT3QHGk3Q.ttf",
                "700": "//fonts.gstatic.com/s/rasa/v1/TSF3CG-8Cn72jvaVdqtMMQ.ttf",
                "regular": "//fonts.gstatic.com/s/rasa/v1/A5PoJUwX_PxTsywxlRB79g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rationale",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rationale/v7/7M2eN-di0NGLQse7HzJRfg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ravi Prakash",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v3",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/raviprakash/v3/8EzbM7Rymjk25jWeHxbO6C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Redressed",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/redressed/v6/3aZ5sTBppH3oSm5SabegtA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Reem Kufi",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v1",
            "lastModified": "2016-08-22",
            "files": {
                "regular": "//fonts.gstatic.com/s/reemkufi/v1/xLwMbK_T1g-h9p-rp60A1Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Reenie Beanie",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/reeniebeanie/v7/ljpKc6CdXusL1cnGUSamX4jjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Revalia",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/revalia/v4/1TKw66fF5_poiL0Ktgo4_A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rhodium Libre",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rhodiumlibre/v1/Vxr7A4-xE2zsBDDI8BcseIjjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ribeye",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ribeye/v5/e5w3VE8HnWBln4Ll6lUj3Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ribeye Marrow",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ribeyemarrow/v6/q7cBSA-4ErAXBCDFPrhlY0cTNmV93fYG7UKgsLQNQWs.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Righteous",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/righteous/v5/0nRRWM_gCGCt2S-BCfN8WQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Risque",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/risque/v4/92RnElGnl8yHP97-KV3Fyg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Roboto",
            "category": "sans-serif",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v15",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/roboto/v15/7MygqTe2zs9YkP0adA9QQQ.ttf",
                "300": "//fonts.gstatic.com/s/roboto/v15/dtpHsbgPEm2lVWciJZ0P-A.ttf",
                "500": "//fonts.gstatic.com/s/roboto/v15/Uxzkqj-MIMWle-XP2pDNAA.ttf",
                "700": "//fonts.gstatic.com/s/roboto/v15/bdHGHleUa-ndQCOrdpfxfw.ttf",
                "900": "//fonts.gstatic.com/s/roboto/v15/H1vB34nOKWXqzKotq25pcg.ttf",
                "100italic": "//fonts.gstatic.com/s/roboto/v15/T1xnudodhcgwXCmZQ490TPesZW2xOQ-xsNqO47m55DA.ttf",
                "300italic": "//fonts.gstatic.com/s/roboto/v15/iE8HhaRzdhPxC93dOdA056CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/roboto/v15/W5F8_SL0XFawnjxHGsZjJA.ttf",
                "italic": "//fonts.gstatic.com/s/roboto/v15/hcKoSgxdnKlbH5dlTwKbow.ttf",
                "500italic": "//fonts.gstatic.com/s/roboto/v15/daIfzbEw-lbjMyv4rMUUTqCWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/roboto/v15/owYYXKukxFDFjr0ZO8NXh6CWcynf_cDxXwCLxiixG1c.ttf",
                "900italic": "//fonts.gstatic.com/s/roboto/v15/b9PWBSMHrT2zM5FgUdtu0aCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Roboto Condensed",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v13",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/robotocondensed/v13/b9QBgL0iMZfDSpmcXcE8nJRhFVcex_hajThhFkHyhYk.ttf",
                "700": "//fonts.gstatic.com/s/robotocondensed/v13/b9QBgL0iMZfDSpmcXcE8nPOYkGiSOYDq_T7HbIOV1hA.ttf",
                "300italic": "//fonts.gstatic.com/s/robotocondensed/v13/mg0cGfGRUERshzBlvqxeAPYa9bgCHecWXGgisnodcS0.ttf",
                "regular": "//fonts.gstatic.com/s/robotocondensed/v13/Zd2E9abXLFGSr9G3YK2MsKDbm6fPDOZJsR8PmdG62gY.ttf",
                "italic": "//fonts.gstatic.com/s/robotocondensed/v13/BP5K8ZAJv9qEbmuFp8RpJY_eiqgTfYGaH0bJiUDZ5GA.ttf",
                "700italic": "//fonts.gstatic.com/s/robotocondensed/v13/mg0cGfGRUERshzBlvqxeAE2zk2RGRC3SlyyLLQfjS_8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Roboto Mono",
            "category": "monospace",
            "variants": [
                "100",
                "100italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/robotomono/v4/aOIeRp72J9_Hp_8KwQ9M-YAWxXGWZ3yJw6KhWS7MxOk.ttf",
                "300": "//fonts.gstatic.com/s/robotomono/v4/N4duVc9C58uwPiY8_59Fzy9-WlPSxbfiI49GsXo3q0g.ttf",
                "500": "//fonts.gstatic.com/s/robotomono/v4/N4duVc9C58uwPiY8_59Fz8CNfqCYlB_eIx7H1TVXe60.ttf",
                "700": "//fonts.gstatic.com/s/robotomono/v4/N4duVc9C58uwPiY8_59Fz3e1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "100italic": "//fonts.gstatic.com/s/robotomono/v4/rqQ1zSE-ZGCKVZgew-A9dgyDtfpXZi-8rXUZYR4dumU.ttf",
                "300italic": "//fonts.gstatic.com/s/robotomono/v4/1OsMuiiO6FCF2x67vzDKA2o9eWDfYYxG3A176Zl7aIg.ttf",
                "regular": "//fonts.gstatic.com/s/robotomono/v4/eJ4cxQe85Lo39t-LVoKa26CWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/robotomono/v4/mE0EPT_93c7f86_WQexR3EeOrDcLawS7-ssYqLr2Xp4.ttf",
                "500italic": "//fonts.gstatic.com/s/robotomono/v4/1OsMuiiO6FCF2x67vzDKA2nWRcJAYo5PSCx8UfGMHCI.ttf",
                "700italic": "//fonts.gstatic.com/s/robotomono/v4/1OsMuiiO6FCF2x67vzDKA8_zJjSACmk0BRPxQqhnNLU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Roboto Slab",
            "category": "serif",
            "variants": [
                "100",
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "100": "//fonts.gstatic.com/s/robotoslab/v6/MEz38VLIFL-t46JUtkIEgIAWxXGWZ3yJw6KhWS7MxOk.ttf",
                "300": "//fonts.gstatic.com/s/robotoslab/v6/dazS1PrQQuCxC3iOAJFEJS9-WlPSxbfiI49GsXo3q0g.ttf",
                "700": "//fonts.gstatic.com/s/robotoslab/v6/dazS1PrQQuCxC3iOAJFEJXe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/robotoslab/v6/3__ulTNA7unv0UtplybPiqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rochester",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/rochester/v6/bnj8tmQBiOkdji_G_yvypg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rock Salt",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/rocksalt/v6/Zy7JF9h9WbhD9V3SFMQ1UQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rokkitt",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/rokkitt/v10/gxlo-sr3rPmvgSixYog_ofesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/rokkitt/v10/GMA7Z_ToF8uSvpZAgnp_VQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Romanesco",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/romanesco/v5/2udIjUrpK_CPzYSxRVzD4Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ropa Sans",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ropasans/v5/Gba7ZzVBuhg6nX_AoSwlkQ.ttf",
                "italic": "//fonts.gstatic.com/s/ropasans/v5/V1zbhZQscNrh63dy5Jk2nqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rosario",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v11",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/rosario/v11/nrS6PJvDWN42RP4TFWccd_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/rosario/v11/bL-cEh8dXtDupB2WccA2LA.ttf",
                "italic": "//fonts.gstatic.com/s/rosario/v11/pkflNy18HEuVVx4EOjeb_Q.ttf",
                "700italic": "//fonts.gstatic.com/s/rosario/v11/EOgFX2Va5VGrkhn_eDpIRS3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rosarivo",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rosarivo/v4/EmPiINK0qyqc7KSsNjJamA.ttf",
                "italic": "//fonts.gstatic.com/s/rosarivo/v4/u3VuWsWQlX1pDqsbz4paNPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rouge Script",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rougescript/v5/AgXDSqZJmy12qS0ixjs6Vy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rozha One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rozhaone/v2/PyrMHQ6lucEIxwKmhqsX8A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rubik",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "hebrew",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-02",
            "files": {
                "300": "//fonts.gstatic.com/s/rubik/v2/o1vXYO8YwDpErHEAPAxpOg.ttf",
                "500": "//fonts.gstatic.com/s/rubik/v2/D4HihERG27s-BJrQ4dvkbw.ttf",
                "700": "//fonts.gstatic.com/s/rubik/v2/m1GGHcpLe6Mb0_sAyjXE4g.ttf",
                "900": "//fonts.gstatic.com/s/rubik/v2/mOHfPRl5uP4vw7-5-dbnng.ttf",
                "300italic": "//fonts.gstatic.com/s/rubik/v2/NyXDvUhvZLSWiVfGa5KM-vesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/rubik/v2/4sMyW_teKWHB3K8Hm-Il6A.ttf",
                "italic": "//fonts.gstatic.com/s/rubik/v2/elD65ddI0qvNcCh42b1Iqg.ttf",
                "500italic": "//fonts.gstatic.com/s/rubik/v2/0hcxMdoMbXtHiEM1ebdN6PesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/rubik/v2/R4g_rs714cUXVZcdnRdHw_esZW2xOQ-xsNqO47m55DA.ttf",
                "900italic": "//fonts.gstatic.com/s/rubik/v2/HH1b7kBbwInqlw8OQxRE5vesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rubik Mono One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rubikmonoone/v5/e_cupPtD4BrZzotubJD7UbAREgn5xbW23GEXXnhMQ5Y.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rubik One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rubikone/v4/Zs6TtctNRSIR8T5PO018rQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ruda",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/ruda/v7/JABOu1SYOHcGXVejUq4w6g.ttf",
                "900": "//fonts.gstatic.com/s/ruda/v7/Uzusv-enCjoIrznlJJaBRw.ttf",
                "regular": "//fonts.gstatic.com/s/ruda/v7/jPEIPB7DM2DNK_uBGv2HGw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rufina",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/rufina/v4/D0RUjXFr55y4MVZY2Ww_RA.ttf",
                "regular": "//fonts.gstatic.com/s/rufina/v4/s9IFr_fIemiohfZS-ZRDbQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ruge Boogie",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rugeboogie/v7/U-TTmltL8aENLVIqYbI5QaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ruluko",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ruluko/v4/lv4cMwJtrx_dzmlK5SDc1g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rum Raisin",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/rumraisin/v4/kDiL-ntDOEq26B7kYM7cx_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ruslan Display",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ruslandisplay/v7/SREdhlyLNUfU1VssRBfs3rgH88D3l9N4auRNHrNS708.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Russo One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/russoone/v5/zfwxZ--UhUc7FVfgT21PRQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ruthie",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/ruthie/v6/vJ2LorukHSbWYoEs5juivg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Rye",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/rye/v4/VUrJlpPpSZxspl3w_yNOrQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sacramento",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sacramento/v4/_kv-qycSHMNdhjiv0Kj7BvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sahitya",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/sahitya/v1/Zm5hNvMwUyN3tC4GMkH1l_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/sahitya/v1/wQWULcDbZqljdTfjOUtDvw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sail",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sail/v7/iuEoG6kt-bePGvtdpL0GUQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Salsa",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/salsa/v6/BnpUCBmYdvggScEPs5JbpA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sanchez",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sanchez/v4/BEL8ao-E2LJ5eHPLB2UAiw.ttf",
                "italic": "//fonts.gstatic.com/s/sanchez/v4/iSrhkWLexUZzDeNxNEHtzA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sancreek",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sancreek/v7/8ZacBMraWMvHly4IJI3esw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sansita One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sansitaone/v6/xWqf68oB50JXqGIRR0h2hqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sarala",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/sarala/v1/hpc9cz8KYsazwq2In_oJYw.ttf",
                "regular": "//fonts.gstatic.com/s/sarala/v1/ohip9lixCHoBab7hTtgLnw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sarina",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sarina/v5/XYtRfaSknHIU3NHdfTdXoQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sarpanch",
            "category": "sans-serif",
            "variants": [
                "regular",
                "500",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/sarpanch/v1/Ov7BxSrFSZYrfuJxL1LzQaCWcynf_cDxXwCLxiixG1c.ttf",
                "600": "//fonts.gstatic.com/s/sarpanch/v1/WTnP2wnc0qSbUaaDG-2OQ6CWcynf_cDxXwCLxiixG1c.ttf",
                "700": "//fonts.gstatic.com/s/sarpanch/v1/57kYsSpovYmFaEt2hsZhv6CWcynf_cDxXwCLxiixG1c.ttf",
                "800": "//fonts.gstatic.com/s/sarpanch/v1/OKyqPLjdnuVghR-1TV6RzaCWcynf_cDxXwCLxiixG1c.ttf",
                "900": "//fonts.gstatic.com/s/sarpanch/v1/JhYc2cr6kqWTo_P0vfvJR6CWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/sarpanch/v1/YMBZdT27b6O5a1DADbAGSg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Satisfy",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/satisfy/v6/PRlyepkd-JCGHiN8e9WV2w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Scada",
            "category": "sans-serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/scada/v4/t6XNWdMdVWUz93EuRVmifQ.ttf",
                "regular": "//fonts.gstatic.com/s/scada/v4/iZNC3ZEYwe3je6H-28d5Ug.ttf",
                "italic": "//fonts.gstatic.com/s/scada/v4/PCGyLT1qNawkOUQ3uHFhBw.ttf",
                "700italic": "//fonts.gstatic.com/s/scada/v4/kLrBIf7V4mDMwcd_Yw7-D_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Scheherazade",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "arabic"
            ],
            "version": "v12",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/scheherazade/v12/C1wtT46acJkQxc6mPHwvHED2ttfZwueP-QU272T9-k4.ttf",
                "regular": "//fonts.gstatic.com/s/scheherazade/v12/AuKlqGWzUC-8XqMOmsqXiy3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Schoolbell",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/schoolbell/v6/95-3djEuubb3cJx-6E7j4vesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Scope One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/scopeone/v2/ge7dY8Yht-n7_1cLHtoT3w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Seaweed Script",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/seaweedscript/v4/eorWAPpOvvWrPw5IHwE60BnpV0hQCek3EmWnCPrvGRM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Secular One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/secularone/v1/yW9qikjpt_X0fh5oQJcdo6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sevillana",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sevillana/v4/6m1Nh35oP7YEt00U80Smiw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Seymour One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/seymourone/v4/HrdG2AEG_870Xb7xBVv6C6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Shadows Into Light",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/shadowsintolight/v6/clhLqOv7MXn459PTh0gXYAW_5bEze-iLRNvGrRpJsfM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Shadows Into Light Two",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/shadowsintolighttwo/v4/gDxHeefcXIo-lOuZFCn2xVQrZk-Pga5KeEE_oZjkQjQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Shanti",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/shanti/v8/lc4nG_JG6Q-2FQSOMMhb_w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Share",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/share/v6/XrU8e7a1YKurguyY2azk1Q.ttf",
                "regular": "//fonts.gstatic.com/s/share/v6/1ytD7zSb_-g9I2GG67vmVw.ttf",
                "italic": "//fonts.gstatic.com/s/share/v6/a9YGdQWFRlNJ0zClJVaY3Q.ttf",
                "700italic": "//fonts.gstatic.com/s/share/v6/A992-bLVYwAflKu6iaznufesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Share Tech",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sharetech/v5/Dq3DuZ5_0SW3oEfAWFpen_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Share Tech Mono",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sharetechmono/v6/RQxK-3RA0Lnf3gnnnNrAscwD6PD0c3_abh9zHKQtbGU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Shojumaru",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/shojumaru/v4/WP8cxonzQQVAoI3RJQ2wug.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Short Stack",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/shortstack/v6/v4dXPI0Rm8XN9gk4SDdqlqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Shrikhand",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "gujarati",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/shrikhand/v1/45jwHiwIDTWCy3Ir85vvKA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sigmar One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sigmarone/v6/oh_5NxD5JBZksdo2EntKefesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Signika",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/signika/v6/0wDPonOzsYeEo-1KO78w4fesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/signika/v6/lQMOF6NUN2ooR7WvB7tADvesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/signika/v6/lEcnfPBICWJPv5BbVNnFJPesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/signika/v6/WvDswbww0oAtvBg2l1L-9w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Signika Negative",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/signikanegative/v5/q5TOjIw4CenPw6C-TW06FjYFXpUPtCmIEFDvjUnLLaI.ttf",
                "600": "//fonts.gstatic.com/s/signikanegative/v5/q5TOjIw4CenPw6C-TW06FrKLaDJM01OezSVA2R_O3qI.ttf",
                "700": "//fonts.gstatic.com/s/signikanegative/v5/q5TOjIw4CenPw6C-TW06FpYzPxtVvobH1w3hEppR8WI.ttf",
                "regular": "//fonts.gstatic.com/s/signikanegative/v5/Z-Q1hzbY8uAo3TpTyPFMXVM1lnCWMnren5_v6047e5A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Simonetta",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "900": "//fonts.gstatic.com/s/simonetta/v5/22EwvvJ2r1VwVCxit5LcVi3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/simonetta/v5/fN8puNuahBo4EYMQgp12Yg.ttf",
                "italic": "//fonts.gstatic.com/s/simonetta/v5/ynxQ3FqfF_Nziwy3T9ZwL6CWcynf_cDxXwCLxiixG1c.ttf",
                "900italic": "//fonts.gstatic.com/s/simonetta/v5/WUXOpCgBZaRPrWtMCpeKoienaqEuufTBk9XMKnKmgDA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sintony",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/sintony/v4/zVXQB1wqJn6PE4dWXoYpvPesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/sintony/v4/IDhCijoIMev2L6Lg5QsduQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sirin Stencil",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sirinstencil/v5/pRpLdo0SawzO7MoBpvowsImg74kgS1F7KeR8rWhYwkU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Six Caps",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/sixcaps/v7/_XeDnO0HOV8Er9u97If1tQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Skranji",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/skranji/v4/Lcrhg-fviVkxiEgoadsI1vesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/skranji/v4/jnOLPS0iZmDL7dfWnW3nIw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Slackey",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/slackey/v6/evRIMNhGVCRJvCPv4kteeA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Smokum",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/smokum/v6/8YP4BuAcy97X8WfdKfxVRw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Smythe",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/smythe/v7/yACD1gy_MpbB9Ft42fUvYw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sniglet",
            "category": "display",
            "variants": [
                "regular",
                "800"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "800": "//fonts.gstatic.com/s/sniglet/v8/NLF91nBmcEfkBgcEWbHFa_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/sniglet/v8/XWhyQLHH4SpCVsHRPRgu9w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Snippet",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/snippet/v6/eUcYMLq2GtHZovLlQH_9kA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Snowburst One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/snowburstone/v4/zSQzKOPukXRux2oTqfYJjIjjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sofadi One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/sofadione/v4/nirf4G12IcJ6KI8Eoj119fesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sofia",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sofia/v5/Imnvx0Ag9r6iDBFUY5_RaQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sonsie One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/sonsieone/v5/KSP7xT1OSy0q2ob6RQOTWPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sorts Mill Goudy",
            "category": "serif",
            "variants": [
                "regular",
                "italic"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sortsmillgoudy/v6/JzRrPKdwEnE8F1TDmDLMUlIL2Qjg-Xlsg_fhGbe2P5U.ttf",
                "italic": "//fonts.gstatic.com/s/sortsmillgoudy/v6/UUu1lKiy4hRmBWk599VL1TYNkCNSzLyoucKmbTguvr0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Source Code Pro",
            "category": "monospace",
            "variants": [
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqaXvKVW_haheDNrHjziJZVk.ttf",
                "300": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqVP7R5lD_au4SZC6Ks_vyWs.ttf",
                "500": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqX63uKwMO11Of4rJWV582wg.ttf",
                "600": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqeiMeWyi5E_-XkTgB5psiDg.ttf",
                "700": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqfgXsetDviZcdR5OzC1KPcw.ttf",
                "900": "//fonts.gstatic.com/s/sourcecodepro/v6/leqv3v-yTsJNC7nFznSMqRA_awHl7mXRjE_LQVochcU.ttf",
                "regular": "//fonts.gstatic.com/s/sourcecodepro/v6/mrl8jkM18OlOQN8JLgasD9Rl0pGnog23EMYRrBmUzJQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Source Sans Pro",
            "category": "sans-serif",
            "variants": [
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v9",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGKXvKVW_haheDNrHjziJZVk.ttf",
                "300": "//fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGFP7R5lD_au4SZC6Ks_vyWs.ttf",
                "600": "//fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGOiMeWyi5E_-XkTgB5psiDg.ttf",
                "700": "//fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGPgXsetDviZcdR5OzC1KPcw.ttf",
                "900": "//fonts.gstatic.com/s/sourcesanspro/v9/toadOcfmlt9b38dHJxOBGBA_awHl7mXRjE_LQVochcU.ttf",
                "200italic": "//fonts.gstatic.com/s/sourcesanspro/v9/fpTVHK8qsXbIeTHTrnQH6OptKU7UIBg2hLM7eMTU8bI.ttf",
                "300italic": "//fonts.gstatic.com/s/sourcesanspro/v9/fpTVHK8qsXbIeTHTrnQH6DUpNKoQAsDux-Todp8f29w.ttf",
                "regular": "//fonts.gstatic.com/s/sourcesanspro/v9/ODelI1aHBYDBqgeIAH2zlNRl0pGnog23EMYRrBmUzJQ.ttf",
                "italic": "//fonts.gstatic.com/s/sourcesanspro/v9/M2Jd71oPJhLKp0zdtTvoMwRX4TIfMQQEXLu74GftruE.ttf",
                "600italic": "//fonts.gstatic.com/s/sourcesanspro/v9/fpTVHK8qsXbIeTHTrnQH6Pp6lGoTTgjlW0sC4r900Co.ttf",
                "700italic": "//fonts.gstatic.com/s/sourcesanspro/v9/fpTVHK8qsXbIeTHTrnQH6LVT4locI09aamSzFGQlDMY.ttf",
                "900italic": "//fonts.gstatic.com/s/sourcesanspro/v9/fpTVHK8qsXbIeTHTrnQH6A0NcF6HPGWR298uWIdxWv0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Source Serif Pro",
            "category": "serif",
            "variants": [
                "regular",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "600": "//fonts.gstatic.com/s/sourceserifpro/v4/yd5lDMt8Sva2PE17yiLarGi4cQnvCGV11m1KlXh97aQ.ttf",
                "700": "//fonts.gstatic.com/s/sourceserifpro/v4/yd5lDMt8Sva2PE17yiLarEkpYHRvxGNSCrR82n_RDNk.ttf",
                "regular": "//fonts.gstatic.com/s/sourceserifpro/v4/CeUM4np2c42DV49nanp55YGL0S0YDpKs5GpLtZIQ0m4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Space Mono",
            "category": "monospace",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "700": "//fonts.gstatic.com/s/spacemono/v1/vdpMRWfyjfCvDYTz00NEPAJKKGfqHaYFsRG-T3ceEVo.ttf",
                "regular": "//fonts.gstatic.com/s/spacemono/v1/B_LOPq3uMVBqC_kmqwURBfesZW2xOQ-xsNqO47m55DA.ttf",
                "italic": "//fonts.gstatic.com/s/spacemono/v1/7xgIgvUEl9Gvhtf7tXsRzC3USBnSvpkopQaUR-2r7iU.ttf",
                "700italic": "//fonts.gstatic.com/s/spacemono/v1/y2NWQDXe2-qPj6a6rWkLc0D2ttfZwueP-QU272T9-k4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Special Elite",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/specialelite/v6/9-wW4zu3WNoD5Fjka35Jm4jjx0o0jr6fNXxPgYh_a8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Spicy Rice",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/spicyrice/v5/WGCtz7cLoggXARPi9OGD6_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Spinnaker",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/spinnaker/v8/MQdIXivKITpjROUdiN6Jgg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Spirax",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/spirax/v5/IOKqhk-Ccl7y31yDsePPkw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Squada One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/squadaone/v5/3tzGuaJdD65cZVgfQzN8uvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sree Krushnadevaraya",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sreekrushnadevaraya/v4/CdsXmnHyEqVl1ahzOh5qnzjDZVem5Eb4d0dXjXa0F_Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sriracha",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/sriracha/v1/l-TXHmKwoHm6vtjy4oUz8Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stalemate",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/stalemate/v4/wQLCnG0qB6mOu2Wit2dt_w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stalinist One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/stalinistone/v8/MQpS-WezM9W4Dd7D3B7I-UT7eZ8.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stardos Stencil",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/stardosstencil/v6/h4ExtgvoXhPtv9Ieqd-XC81wDCbBgmIo8UyjIhmkeSM.ttf",
                "regular": "//fonts.gstatic.com/s/stardosstencil/v6/ygEOyTW9a6u4fi4OXEZeTFf2eT4jUldwg_9fgfY_tHc.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stint Ultra Condensed",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/stintultracondensed/v5/8DqLK6-YSClFZt3u3EgOUYelbRYnLTTQA1Z5cVLnsI4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stint Ultra Expanded",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/stintultraexpanded/v4/FeigX-wDDgHMCKuhekhedQ7dxr0N5HY0cZKknTIL6n4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Stoke",
            "category": "serif",
            "variants": [
                "300",
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "300": "//fonts.gstatic.com/s/stoke/v6/Sell9475FOS8jUqQsfFsUQ.ttf",
                "regular": "//fonts.gstatic.com/s/stoke/v6/A7qJNoqOm2d6o1E6e0yUFg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Strait",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/strait/v4/m4W73ViNmProETY2ybc-Bg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sue Ellen Francisco",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/sueellenfrancisco/v7/TwHX4vSxMUnJUdEz1JIgrhzazJzPVbGl8jnf1tisRz4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Suez One",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "hebrew",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/suezone/v1/xulpHtKbz3V8hoSLE2uKDw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sumana",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/sumana/v1/8AcM-KAproitONSBBHj3sQ.ttf",
                "regular": "//fonts.gstatic.com/s/sumana/v1/wgdl__wAK7pzliiWs0Nlog.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sunshiney",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/sunshiney/v6/kaWOb4pGbwNijM7CkxK1sQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Supermercado One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/supermercadoone/v6/kMGPVTNFiFEp1U274uBMb4mm5hmSKNFf3C5YoMa-lrM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Sura",
            "category": "serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/sura/v1/Z5bXQaFGmoWicN1WlcncxA.ttf",
                "regular": "//fonts.gstatic.com/s/sura/v1/jznKrhTH5NezYxb0-Q5zzA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Suranna",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/suranna/v4/PYmfr6TQeTqZ-r8HnPM-kA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Swanky and Moo Moo",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/swankyandmoomoo/v6/orVNZ9kDeE3lWp3U3YELu9DVLKqNC3_XMNHhr8S94FU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Syncopate",
            "category": "sans-serif",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/syncopate/v7/S5z8ixiOoC4WJ1im6jAlYC3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/syncopate/v7/RQVwO52fAH6MI764EcaYtw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tangerine",
            "category": "handwriting",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/tangerine/v7/UkFsr-RwJB_d2l9fIWsx3i3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/tangerine/v7/DTPeM3IROhnkz7aYG2a9sA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tauri",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/tauri/v4/XIWeYJDXNqiVNej0zEqtGg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Taviraj",
            "category": "serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/taviraj/v1/7iDtujKEc7hwcT6D0zLx-A.ttf",
                "200": "//fonts.gstatic.com/s/taviraj/v1/fn3qCO_sC_zLuf2hqWE37fesZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/taviraj/v1/1EIpbtG_cs5haG6Ba9wX8vesZW2xOQ-xsNqO47m55DA.ttf",
                "500": "//fonts.gstatic.com/s/taviraj/v1/s8BuqYm5ebG2N1R4JkTp_fesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/taviraj/v1/KscmiA6HGz7nCcHhaddQH_esZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/taviraj/v1/TY91892tTFNYCeCXjQ1AEPesZW2xOQ-xsNqO47m55DA.ttf",
                "800": "//fonts.gstatic.com/s/taviraj/v1/oGWJbiDGcxlInLLnrLxTDvesZW2xOQ-xsNqO47m55DA.ttf",
                "900": "//fonts.gstatic.com/s/taviraj/v1/RfIEodnN0NYWUdZHol5fdPesZW2xOQ-xsNqO47m55DA.ttf",
                "100italic": "//fonts.gstatic.com/s/taviraj/v1/ai0UdHXB1gi5etfpU0CZ6aCWcynf_cDxXwCLxiixG1c.ttf",
                "200italic": "//fonts.gstatic.com/s/taviraj/v1/eDMMTK5GhTdvvz3R-ZWvay3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/taviraj/v1/IEBfc1xGgsBbdCeXKNAtfS3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/taviraj/v1/AH1eoWagKJhbVx4Poc3M1A.ttf",
                "italic": "//fonts.gstatic.com/s/taviraj/v1/hAS5RxygdSnG4626KdkXuQ.ttf",
                "500italic": "//fonts.gstatic.com/s/taviraj/v1/319qfe3yzAi9RNFu-dI9zy3USBnSvpkopQaUR-2r7iU.ttf",
                "600italic": "//fonts.gstatic.com/s/taviraj/v1/ofRN6EMiboGiM2Ga3cG_yy3USBnSvpkopQaUR-2r7iU.ttf",
                "700italic": "//fonts.gstatic.com/s/taviraj/v1/4Yzb6i1xtMRZn9oAQ484nS3USBnSvpkopQaUR-2r7iU.ttf",
                "800italic": "//fonts.gstatic.com/s/taviraj/v1/MPtY5Qs3hwV4f0LUH-vVmy3USBnSvpkopQaUR-2r7iU.ttf",
                "900italic": "//fonts.gstatic.com/s/taviraj/v1/aDM2JaXSd_qo0nqKiBAq5C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Teko",
            "category": "sans-serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "300": "//fonts.gstatic.com/s/teko/v5/OobFGE9eo24rcBpN6zXDaQ.ttf",
                "500": "//fonts.gstatic.com/s/teko/v5/FQ0duU7gWM4cSaImOfAjBA.ttf",
                "600": "//fonts.gstatic.com/s/teko/v5/QDx_i8H-TZ1IK1JEVrqwEQ.ttf",
                "700": "//fonts.gstatic.com/s/teko/v5/xKfTxe_SWpH4xU75vmvylA.ttf",
                "regular": "//fonts.gstatic.com/s/teko/v5/UtekqODEqZXSN2L-njejpA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Telex",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/telex/v4/24-3xP9ywYeHOcFU3iGk8A.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tenali Ramakrishna",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v3",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/tenaliramakrishna/v3/M0nTmDqv2M7AGoGh-c946BZak5pSBHqWX6uyVMiMFoA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tenor Sans",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/tenorsans/v7/dUBulmjNJJInvK5vL7O9yfesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Text Me One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/textmeone/v4/9em_3ckd_P5PQkP4aDyDLqCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "The Girl Next Door",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/thegirlnextdoor/v7/cWRA4JVGeEcHGcPl5hmX7kzo0nFFoM60ux_D9BUymX4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tienne",
            "category": "serif",
            "variants": [
                "regular",
                "700",
                "900"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/tienne/v8/JvoCDOlyOSEyYGRwCyfs3g.ttf",
                "900": "//fonts.gstatic.com/s/tienne/v8/FBano5T521OWexj2iRYLMw.ttf",
                "regular": "//fonts.gstatic.com/s/tienne/v8/-IIfDl701C0z7-fy2kmGvA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tillana",
            "category": "handwriting",
            "variants": [
                "regular",
                "500",
                "600",
                "700",
                "800"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/tillana/v1/gqdUngSIcY9tSla5eCZky_esZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/tillana/v1/fqon6-r15hy8M1cyiYfQBvesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/tillana/v1/jGARMTxLrMerzTCpGBpMffesZW2xOQ-xsNqO47m55DA.ttf",
                "800": "//fonts.gstatic.com/s/tillana/v1/pmTtNH_Ibktj5Cyc1XrP6vesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/tillana/v1/zN0D-jDPsr1HzU3VRFLY5g.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Timmana",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "telugu"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/timmana/v1/T25SicsJUJkc2s2sbBsDnA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tinos",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "hebrew",
                "latin-ext",
                "vietnamese",
                "cyrillic-ext"
            ],
            "version": "v9",
            "lastModified": "2016-05-20",
            "files": {
                "700": "//fonts.gstatic.com/s/tinos/v9/vHXfhX8jZuQruowfon93yQ.ttf",
                "regular": "//fonts.gstatic.com/s/tinos/v9/EqpUbkVmutfwZ0PjpoGwCg.ttf",
                "italic": "//fonts.gstatic.com/s/tinos/v9/slfyzlasCr9vTsaP4lUh9A.ttf",
                "700italic": "//fonts.gstatic.com/s/tinos/v9/M6kfzvDMM0CdxdraoFpG6vesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Titan One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/titanone/v4/FbvpRvzfV_oipS0De3iAZg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Titillium Web",
            "category": "sans-serif",
            "variants": [
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/titilliumweb/v4/anMUvcNT0H1YN4FII8wprzOdCrLccoxq42eaxM802O0.ttf",
                "300": "//fonts.gstatic.com/s/titilliumweb/v4/anMUvcNT0H1YN4FII8wpr9ZAkYT8DuUZELiKLwMGWAo.ttf",
                "600": "//fonts.gstatic.com/s/titilliumweb/v4/anMUvcNT0H1YN4FII8wpr28K9dEd5Ue-HTQrlA7E2xQ.ttf",
                "700": "//fonts.gstatic.com/s/titilliumweb/v4/anMUvcNT0H1YN4FII8wpr2-6tpSbB9YhmWtmd1_gi_U.ttf",
                "900": "//fonts.gstatic.com/s/titilliumweb/v4/anMUvcNT0H1YN4FII8wpr7L0GmZLri-m-nfoo0Vul4Y.ttf",
                "200italic": "//fonts.gstatic.com/s/titilliumweb/v4/RZunN20OBmkvrU7sA4GPPj4N98U-66ThNJvtgddRfBE.ttf",
                "300italic": "//fonts.gstatic.com/s/titilliumweb/v4/RZunN20OBmkvrU7sA4GPPrfzCkqg7ORZlRf2cc4mXu8.ttf",
                "regular": "//fonts.gstatic.com/s/titilliumweb/v4/7XUFZ5tgS-tD6QamInJTcTyagQBwYgYywpS70xNq8SQ.ttf",
                "italic": "//fonts.gstatic.com/s/titilliumweb/v4/r9OmwyQxrgzUAhaLET_KO-ixohbIP6lHkU-1Mgq95cY.ttf",
                "600italic": "//fonts.gstatic.com/s/titilliumweb/v4/RZunN20OBmkvrU7sA4GPPgOhzTSndyK8UWja2yJjKLc.ttf",
                "700italic": "//fonts.gstatic.com/s/titilliumweb/v4/RZunN20OBmkvrU7sA4GPPio3LEw-4MM8Ao2j9wPOfpw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Trade Winds",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/tradewinds/v5/sDOCVgAxw6PEUi2xdMsoDaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Trirong",
            "category": "serif",
            "variants": [
                "100",
                "100italic",
                "200",
                "200italic",
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "600",
                "600italic",
                "700",
                "700italic",
                "800",
                "800italic",
                "900",
                "900italic"
            ],
            "subsets": [
                "latin",
                "thai",
                "latin-ext",
                "vietnamese"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "100": "//fonts.gstatic.com/s/trirong/v1/A4AP1moxqvtadq5CW3L17A.ttf",
                "200": "//fonts.gstatic.com/s/trirong/v1/QD8N5qk-agpAEYCSSWullPesZW2xOQ-xsNqO47m55DA.ttf",
                "300": "//fonts.gstatic.com/s/trirong/v1/mfCfGz4GqprWJZ47PUMDGfesZW2xOQ-xsNqO47m55DA.ttf",
                "500": "//fonts.gstatic.com/s/trirong/v1/6CsQ6UR1e8rURaEPxqnGBvesZW2xOQ-xsNqO47m55DA.ttf",
                "600": "//fonts.gstatic.com/s/trirong/v1/1FjmLIhPhB6Yc7RWqO27mfesZW2xOQ-xsNqO47m55DA.ttf",
                "700": "//fonts.gstatic.com/s/trirong/v1/ab8hG5CTSzMAobTnPgcDP_esZW2xOQ-xsNqO47m55DA.ttf",
                "800": "//fonts.gstatic.com/s/trirong/v1/UBRQXGJvi5EHcyI5wwZew_esZW2xOQ-xsNqO47m55DA.ttf",
                "900": "//fonts.gstatic.com/s/trirong/v1/Lam1ewMdiP3O-bVYT-W6t_esZW2xOQ-xsNqO47m55DA.ttf",
                "100italic": "//fonts.gstatic.com/s/trirong/v1/ke-m75CXBPHlqwRHmCTBi6CWcynf_cDxXwCLxiixG1c.ttf",
                "200italic": "//fonts.gstatic.com/s/trirong/v1/TLnptEEWKdIVHKJYBO592y3USBnSvpkopQaUR-2r7iU.ttf",
                "300italic": "//fonts.gstatic.com/s/trirong/v1/RnkK09k5OfEHFxd_smcYuC3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/trirong/v1/lYu4kez-Enlvh2X-itx6CA.ttf",
                "italic": "//fonts.gstatic.com/s/trirong/v1/kV0MzmWPKkglEtJf--dQhQ.ttf",
                "500italic": "//fonts.gstatic.com/s/trirong/v1/I7H5Vf-5oH45BHkyxaUodS3USBnSvpkopQaUR-2r7iU.ttf",
                "600italic": "//fonts.gstatic.com/s/trirong/v1/BXLhSV51vCWUiACSqyWe6i3USBnSvpkopQaUR-2r7iU.ttf",
                "700italic": "//fonts.gstatic.com/s/trirong/v1/CEBv6IoZawJuRHdATx4LQi3USBnSvpkopQaUR-2r7iU.ttf",
                "800italic": "//fonts.gstatic.com/s/trirong/v1/lGUgSzOvjUqrsrJfnROivC3USBnSvpkopQaUR-2r7iU.ttf",
                "900italic": "//fonts.gstatic.com/s/trirong/v1/EtuLHyx5DS9oX5NoKhYlkC3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Trocchi",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/trocchi/v4/uldNPaKrUGVeGCVsmacLwA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Trochut",
            "category": "display",
            "variants": [
                "regular",
                "italic",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/trochut/v4/lWqNOv6ISR8ehNzGLFLnJ_esZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/trochut/v4/6Y65B0x-2JsnYt16OH5omw.ttf",
                "italic": "//fonts.gstatic.com/s/trochut/v4/pczUwr4ZFvC79TgNO5cZng.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Trykker",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/trykker/v5/YiVrVJpBFN7I1l_CWk6yYQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Tulpen One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/tulpenone/v6/lwcTfVIEVxpZLZlWzR5baPesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ubuntu",
            "category": "sans-serif",
            "variants": [
                "300",
                "300italic",
                "regular",
                "italic",
                "500",
                "500italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v9",
            "lastModified": "2016-06-03",
            "files": {
                "300": "//fonts.gstatic.com/s/ubuntu/v9/7-wH0j2QCTHKgp7vLh9-sQ.ttf",
                "500": "//fonts.gstatic.com/s/ubuntu/v9/bMbHEMwSUmkzcK2x_74QbA.ttf",
                "700": "//fonts.gstatic.com/s/ubuntu/v9/B7BtHjNYwAp3HgLNagENOQ.ttf",
                "300italic": "//fonts.gstatic.com/s/ubuntu/v9/j-TYDdXcC_eQzhhp386SjaCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/ubuntu/v9/lhhB5ZCwEkBRbHMSnYuKyA.ttf",
                "italic": "//fonts.gstatic.com/s/ubuntu/v9/b9hP8wd30SygxZjGGk4DCQ.ttf",
                "500italic": "//fonts.gstatic.com/s/ubuntu/v9/NWdMogIO7U6AtEM4dDdf_aCWcynf_cDxXwCLxiixG1c.ttf",
                "700italic": "//fonts.gstatic.com/s/ubuntu/v9/pqisLQoeO9YTDCNnlQ9bf6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ubuntu Condensed",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v7",
            "lastModified": "2016-06-03",
            "files": {
                "regular": "//fonts.gstatic.com/s/ubuntucondensed/v7/DBCt-NXN57MTAFjitYxdrKDbm6fPDOZJsR8PmdG62gY.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ubuntu Mono",
            "category": "monospace",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "greek",
                "latin",
                "greek-ext",
                "cyrillic",
                "latin-ext",
                "cyrillic-ext"
            ],
            "version": "v6",
            "lastModified": "2016-06-03",
            "files": {
                "700": "//fonts.gstatic.com/s/ubuntumono/v6/ceqTZGKHipo8pJj4molytne1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "regular": "//fonts.gstatic.com/s/ubuntumono/v6/EgeuS9OtEmA0y_JRo03MQaCWcynf_cDxXwCLxiixG1c.ttf",
                "italic": "//fonts.gstatic.com/s/ubuntumono/v6/KAKuHXAHZOeECOWAHsRKA0eOrDcLawS7-ssYqLr2Xp4.ttf",
                "700italic": "//fonts.gstatic.com/s/ubuntumono/v6/n_d8tv_JOIiYyMXR4eaV9c_zJjSACmk0BRPxQqhnNLU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Ultra",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/ultra/v8/OW8uXkOstRADuhEmGOFQLA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Uncial Antiqua",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/uncialantiqua/v4/F-leefDiFwQXsyd6eaSllqrFJ4O13IHVxZbM6yoslpo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Underdog",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-06-07",
            "files": {
                "regular": "//fonts.gstatic.com/s/underdog/v5/gBv9yjez_-5PnTprHWq0ig.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Unica One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/unicaone/v4/KbYKlhWMDpatWViqDkNQgA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "UnifrakturCook",
            "category": "display",
            "variants": [
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/unifrakturcook/v8/ASwh69ykD8iaoYijVEU6RrWZkcsCTHKV51zmcUsafQ0.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "UnifrakturMaguntia",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/unifrakturmaguntia/v7/7KWy3ymCVR_xfAvvcIXm3-kdNg30GQauG_DE-tMYtWk.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Unkempt",
            "category": "display",
            "variants": [
                "regular",
                "700"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-06-07",
            "files": {
                "700": "//fonts.gstatic.com/s/unkempt/v7/V7H-GCl9bgwGwqFqTTgDHvesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/unkempt/v7/NLLBeNSspr0RGs71R5LHWA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Unlock",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/unlock/v6/rXEQzK7uIAlhoyoAEiMy1w.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Unna",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/unna/v8/UAS0AM7AmbdCNY_80xyAZQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "VT323",
            "category": "monospace",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/vt323/v7/ITU2YQfM073o1iYK3nSOmQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vampiro One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/vampiroone/v7/OVDs4gY4WpS5u3Qd1gXRW6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Varela",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/varela/v7/ON7qs0cKUUixhhDFXlZUjw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Varela Round",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "hebrew"
            ],
            "version": "v7",
            "lastModified": "2016-06-02",
            "files": {
                "regular": "//fonts.gstatic.com/s/varelaround/v7/APH4jr0uSos5wiut5cpjri3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vast Shadow",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/vastshadow/v6/io4hqKX3ibiqQQjYfW0-h6CWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vesper Libre",
            "category": "serif",
            "variants": [
                "regular",
                "500",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "500": "//fonts.gstatic.com/s/vesperlibre/v8/0liLgNkygqH6EOtsVjZDsZMQuUSAwdHsY8ov_6tk1oA.ttf",
                "700": "//fonts.gstatic.com/s/vesperlibre/v8/0liLgNkygqH6EOtsVjZDsUD2ttfZwueP-QU272T9-k4.ttf",
                "900": "//fonts.gstatic.com/s/vesperlibre/v8/0liLgNkygqH6EOtsVjZDsaObDOjC3UL77puoeHsE3fw.ttf",
                "regular": "//fonts.gstatic.com/s/vesperlibre/v8/Cg-TeZFsqV8BaOcoVwzu2C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vibur",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/vibur/v7/xB9aKsUbJo68XP0bAg2iLw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vidaloka",
            "category": "serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/vidaloka/v8/C6Nul0ogKUWkx356rrt9RA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Viga",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/viga/v5/uD87gDbhS7frHLX4uL6agg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Voces",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/voces/v5/QoBH6g6yKgNIgvL8A2aE2Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Volkhov",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/volkhov/v8/L8PbKS-kEoLHm7nP--NCzPesZW2xOQ-xsNqO47m55DA.ttf",
                "regular": "//fonts.gstatic.com/s/volkhov/v8/MDIZAofe1T_J3un5Kgo8zg.ttf",
                "italic": "//fonts.gstatic.com/s/volkhov/v8/1rTjmztKEpbkKH06JwF8Yw.ttf",
                "700italic": "//fonts.gstatic.com/s/volkhov/v8/W6oG0QDDjCgj0gmsHE520C3USBnSvpkopQaUR-2r7iU.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Vollkorn",
            "category": "serif",
            "variants": [
                "regular",
                "italic",
                "700",
                "700italic"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "700": "//fonts.gstatic.com/s/vollkorn/v6/gOwQjJVGXlDOONC12hVoBqCWcynf_cDxXwCLxiixG1c.ttf",
                "regular": "//fonts.gstatic.com/s/vollkorn/v6/IiexqYAeh8uII223thYx3w.ttf",
                "italic": "//fonts.gstatic.com/s/vollkorn/v6/UuIzosgR1ovBhJFdwVp3fvesZW2xOQ-xsNqO47m55DA.ttf",
                "700italic": "//fonts.gstatic.com/s/vollkorn/v6/KNiAlx6phRqXCwnZZG51JAJKKGfqHaYFsRG-T3ceEVo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Voltaire",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/voltaire/v6/WvqBzaGEBbRV-hrahwO2cA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Waiting for the Sunrise",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/waitingforthesunrise/v7/eNfH7kLpF1PZWpsetF-ha9TChrNgrDiT3Zy6yGf3FnM.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Wallpoet",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v8",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/wallpoet/v8/hmum4WuBN4A0Z_7367NDIg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Walter Turncoat",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/walterturncoat/v6/sG9su5g4GXy1KP73cU3hvQplL2YwNeota48DxFlGDUo.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Warnes",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/warnes/v6/MXG7_Phj4YpzAXxKGItuBw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Wellfleet",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/wellfleet/v4/J5tOx72iFRPgHYpbK9J4XQ.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Wendy One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v4",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/wendyone/v4/R8CJT2oDXdMk_ZtuHTxoxw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Wire One",
            "category": "sans-serif",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/wireone/v7/sRLhaQOQpWnvXwIx0CycQw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Work Sans",
            "category": "sans-serif",
            "variants": [
                "100",
                "200",
                "300",
                "regular",
                "500",
                "600",
                "700",
                "800",
                "900"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v2",
            "lastModified": "2016-06-07",
            "files": {
                "100": "//fonts.gstatic.com/s/worksans/v2/ZAhtNqLaAViKjGLajtuwWaCWcynf_cDxXwCLxiixG1c.ttf",
                "200": "//fonts.gstatic.com/s/worksans/v2/u_mYNr_qYP37m7vgvmIYZy3USBnSvpkopQaUR-2r7iU.ttf",
                "300": "//fonts.gstatic.com/s/worksans/v2/FD_Udbezj8EHXbdsqLUply3USBnSvpkopQaUR-2r7iU.ttf",
                "500": "//fonts.gstatic.com/s/worksans/v2/Nbre-U_bp6Xktt8cpgwaJC3USBnSvpkopQaUR-2r7iU.ttf",
                "600": "//fonts.gstatic.com/s/worksans/v2/z9rX03Xuz9ZNHTMg1_ghGS3USBnSvpkopQaUR-2r7iU.ttf",
                "700": "//fonts.gstatic.com/s/worksans/v2/4udXuXg54JlPEP5iKO5AmS3USBnSvpkopQaUR-2r7iU.ttf",
                "800": "//fonts.gstatic.com/s/worksans/v2/IQh-ap2Uqs7kl1YINeeEGi3USBnSvpkopQaUR-2r7iU.ttf",
                "900": "//fonts.gstatic.com/s/worksans/v2/Hjn0acvjHfjY_vAK9Uc6gi3USBnSvpkopQaUR-2r7iU.ttf",
                "regular": "//fonts.gstatic.com/s/worksans/v2/zVvigUiMvx7JVEnrJgc-5Q.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yanone Kaffeesatz",
            "category": "sans-serif",
            "variants": [
                "200",
                "300",
                "regular",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v7",
            "lastModified": "2016-05-31",
            "files": {
                "200": "//fonts.gstatic.com/s/yanonekaffeesatz/v7/We_iSDqttE3etzfdfhuPRbq92v6XxU4pSv06GI0NsGc.ttf",
                "300": "//fonts.gstatic.com/s/yanonekaffeesatz/v7/We_iSDqttE3etzfdfhuPRZlIwXPiNoNT_wxzJ2t3mTE.ttf",
                "700": "//fonts.gstatic.com/s/yanonekaffeesatz/v7/We_iSDqttE3etzfdfhuPRf2R4S6PlKaGXWPfWpHpcl0.ttf",
                "regular": "//fonts.gstatic.com/s/yanonekaffeesatz/v7/YDAoLskQQ5MOAgvHUQCcLdXn3cHbFGWU4T2HrSN6JF4.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yantramanav",
            "category": "sans-serif",
            "variants": [
                "100",
                "300",
                "regular",
                "500",
                "700",
                "900"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-05-31",
            "files": {
                "100": "//fonts.gstatic.com/s/yantramanav/v1/Rs1I2PF4Z8GAb6qjgvr8wIAWxXGWZ3yJw6KhWS7MxOk.ttf",
                "300": "//fonts.gstatic.com/s/yantramanav/v1/HSfbC4Z8I8BZ00wiXeA5bC9-WlPSxbfiI49GsXo3q0g.ttf",
                "500": "//fonts.gstatic.com/s/yantramanav/v1/HSfbC4Z8I8BZ00wiXeA5bMCNfqCYlB_eIx7H1TVXe60.ttf",
                "700": "//fonts.gstatic.com/s/yantramanav/v1/HSfbC4Z8I8BZ00wiXeA5bHe1Pd76Vl7zRpE7NLJQ7XU.ttf",
                "900": "//fonts.gstatic.com/s/yantramanav/v1/HSfbC4Z8I8BZ00wiXeA5bCenaqEuufTBk9XMKnKmgDA.ttf",
                "regular": "//fonts.gstatic.com/s/yantramanav/v1/FwdziO-qWAO8pZg8e376kaCWcynf_cDxXwCLxiixG1c.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yatra One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "devanagari",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/yatraone/v1/ApKQzWF7_vG0Lt5TDqgUvw.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yellowtail",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-20",
            "files": {
                "regular": "//fonts.gstatic.com/s/yellowtail/v6/HLrU6lhCTjXfLZ7X60LcB_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yeseva One",
            "category": "display",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin",
                "cyrillic",
                "latin-ext"
            ],
            "version": "v10",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/yesevaone/v10/eenQQxvpzSA80JmisGcgX_esZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yesteryear",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v5",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/yesteryear/v5/dv09hP_ZrdjVOfZQXKXuZvesZW2xOQ-xsNqO47m55DA.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Yrsa",
            "category": "serif",
            "variants": [
                "300",
                "regular",
                "500",
                "600",
                "700"
            ],
            "subsets": [
                "latin",
                "latin-ext"
            ],
            "version": "v1",
            "lastModified": "2016-06-20",
            "files": {
                "300": "//fonts.gstatic.com/s/yrsa/v1/YI0C1syzAYpkrPx27UnC2w.ttf",
                "500": "//fonts.gstatic.com/s/yrsa/v1/rWuZmBLHIeKRbnfSvWCvYg.ttf",
                "600": "//fonts.gstatic.com/s/yrsa/v1/1413P-oEfrq-tBIdqnslDQ.ttf",
                "700": "//fonts.gstatic.com/s/yrsa/v1/iV49zaJV5wyo_4LgxE2yng.ttf",
                "regular": "//fonts.gstatic.com/s/yrsa/v1/JWX_dCK4_Jq-oqF7r9rFHg.ttf"
            }
        }, {
            "kind": "webfonts#webfont",
            "family": "Zeyada",
            "category": "handwriting",
            "variants": [
                "regular"
            ],
            "subsets": [
                "latin"
            ],
            "version": "v6",
            "lastModified": "2016-05-31",
            "files": {
                "regular": "//fonts.gstatic.com/s/zeyada/v6/hmonmGYYFwqTZQfG2nRswQ.ttf"
            }
        }
    ]
});

SVGMatrix.prototype.identity = function () {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    return this;
};

SVGMatrix.prototype.toHTML = function (_decimals) {
    if (_decimals) {
        return "matrix(" + [this.a.toFixed(_decimals), this.b.toFixed(_decimals), this.c.toFixed(_decimals), this.d.toFixed(_decimals), this.e.toFixed(_decimals), this.f.toFixed(_decimals)].join(",") + ")";
    }

    return "matrix(" + [this.a, this.b, this.c, this.d, this.e, this.f].join(",") + ")";
};

SVGMatrix.prototype.clone = function () {
    const newMatrix = SVGUtils.createSVGMatrix();
    this.copyTo(newMatrix);
    return newMatrix;
};

SVGMatrix.prototype.removeScale = function () {
    const scale = this.getScale();
    const matrix = SVGUtils.createSVGMatrix().scaleNonUniform(scale.x, scale.y).inverse();
    return this.multiply(matrix);
};

SVGMatrix.prototype.removeRotation = function () {
    const rotation = this.getRotation();
    const matrix = SVGUtils.createSVGMatrix().rotate(rotation).inverse();
    return this.multiply(matrix);
};

SVGMatrix.prototype.rotateAroundPt = function (_rotDeg, _pt) {
    let mat = this.translate(_pt.x, _pt.y);
    mat = mat.rotate(_rotDeg);
    mat = mat.translate(-_pt.x, -_pt.y);
    return mat;
};

SVGMatrix.prototype.scaleAroundPt = function (_scaleX, _scaleY, _pt) {
    let mat = this.translate(_pt.x, _pt.y);
    mat = mat.scaleNonUniform(_scaleX, _scaleY);
    mat = mat.translate(-_pt.x, -_pt.y);
    return mat;
};

SVGMatrix.prototype.copyTo = function (_targetMatrix) {
    _targetMatrix.a = this.a;
    _targetMatrix.b = this.b;
    _targetMatrix.c = this.c;
    _targetMatrix.d = this.d;
    _targetMatrix.e = this.e;
    _targetMatrix.f = this.f;
};

SVGMatrix.prototype.transformPointList = function (_pointList, _createNewList) {
    const max = _pointList.length;
    let newPointList = _pointList;
    if (_createNewList)
        newPointList = [];
    for (let i = 0; i < max; i++)
        newPointList[i] = _pointList[i].matrixTransform(this);
    return newPointList;
}

SVGMatrix.prototype.deltaTransformPoint = function (point) {
    const dx = point.x * this.a + point.y * this.c;
    const dy = point.x * this.b + point.y * this.d;
    return {
        x: dx,
        y: dy
    };
};

SVGMatrix.prototype.getRotation = function () {
    const px = this.deltaTransformPoint({
        x: 0,
        y: 1
    });
    // calculate skew
    return ((180 / Math.PI) * Math.atan2(px.y, px.x) - 90);
}

SVGMatrix.prototype.getScale = function () {
    return {
        x: Math.sqrt(this.a * this.a + this.b * this.b),
        y: Math.sqrt(this.c * this.c + this.d * this.d)
    };
};

SVGMatrix.prototype.getTranslation = function () {
    return SVGUtils.createSVGPoint(this.e, this.f);
};

SVGMatrix.prototype.decompose = function (useLU) {

    let
    me = this,
    a = me.a,
    b = me.b,
    c = me.c,
    d = me.d,
    acos = Math.acos,
    atan = Math.atan,
    sqrt = Math.sqrt,
    pi = Math.PI,

    translate = {
        x: me.e,
        y: me.f
    },
    rotation = 0,
    scale = {
        x: 1,
        y: 1
    },
    skew = {
        x: 0,
        y: 0
    },

    determ = a * d - b * c, // determinant(), skip DRY here...
    r,
    s;

    if (useLU) {
        if (a) {
            skew = {
                x: atan(c / a),
                y: atan(b / a)
            };
            scale = {
                x: a,
                y: determ / a
            };
        } else if (b) {
            rotation = pi * 0.5;
            scale = {
                x: b,
                y: determ / b
            };
            skew.x = atan(d / b);
        } else { // a = b = 0
            scale = {
                x: c,
                y: d
            };
            skew.x = pi * 0.25;
        }
    } else {
        // Apply the QR-like decomposition.
        if (a || b) {
            r = sqrt(a * a + b * b);
            rotation = b > 0 ? acos(a / r) : -acos(a / r);
            scale = {
                x: r,
                y: determ / r
            };
            skew.x = atan((a * c + b * d) / (r * r));
        } else if (c || d) {
            s = sqrt(c * c + d * d);
            rotation = pi * 0.5 - (d > 0 ? acos(-c / s) : -acos(c / s));
            scale = {
                x: determ / s,
                y: s
            };
            skew.y = atan((a * c + b * d) / (s * s));
        } else { // a = b = c = d = 0
            scale = {
                x: 0,
                y: 0
            };
        }
    }

    return {
        translateX: translate.x,
        translateY: translate.y,
        scaleX: scale.x,
        scaleY: scale.y,
        skewX: skew.x,
        skewY: skew.y,
        rotation: rotation
    }
};

SVGPoint.prototype.clone = function () {
    return SVGUtils.createSVGPoint(this.x, this.y);
};

// SVGPoint.prototype.getAngleFromPoint = function( _pt2D , _hasDegree )
// {
// 	let angle = Math.atan2(  _pt2D.y - this.y ,  _pt2D.x - this.x  );
// 	while (angle < 0) angle += Math.PI * 2;
// 	if( _hasDegree=== true) angle = angle * 180 / Math.PI;
// 	return angle;
// };

SVGPoint.prototype.getAngleFromPoint = function (_pt2D, _hasDegree) {
    //let angle = -Math.atan2(  _pt2D.y - this.y ,  _pt2D.x - this.x  );
    let angle = Math.atan2(_pt2D.y - this.y, _pt2D.x - this.x);

    if (_hasDegree === true) {
        angle = angle * 180 / Math.PI;
        if (angle < 0)
            angle = 360 + angle;
    }
    return angle;
};

// SVGPoint.prototype.getAngleFromPointInQuadrants = function( _pt2D , _hasDegree )
// {
// 	let angle = 0 - Math.atan2(  _pt2D.y - this.y ,  _pt2D.x - this.x  );
// 	if( _hasDegree=== true)
// 	{
// 		angle = angle * 180 / Math.PI;
// 		if (angle < 0) angle = 360 + angle;
// 	}
// 	return angle;
// };

SVGPoint.prototype.set = function (_x, _y) {
    this.x = _x;
    this.y = _y;
};

SVGPoint.prototype.getDistanceFromPoint = function (_pt) {
    const x = _pt.x - this.x;
    const y = _pt.y - this.y;
    return Math.sqrt(x * x + y * y);
};

SVGPoint.prototype.getDistance = function (_pt, squared) {
    const x = _pt.x - this.x,
    y = _pt.y - this.y,
    d = x * x + y * y;
    return squared ? d : Math.sqrt(d);
};

SVGPoint.prototype.getLength = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};

SVGPoint.prototype.normalize = function (_length) {
    if (_length === undefined)
        _length = 1;
    const current = this.getLength();
    const scale = current !== 0 ? _length / current : 0;
    return SVGUtils.createSVGPoint(this.x * scale, this.y * scale);
};

SVGPoint.prototype.scale = function (_sx, _sy) {
    this.x *= _sx;
    this.y *= _sy;
};

SVGPoint.prototype.translate = function (_tx, _ty) {
    this.x += _tx;
    this.y += _ty;
};

SVGPoint.prototype.isZero = function () {
    return this.x === 0 && this.y === 0;
};

SVGPoint.prototype.equals = function (_pt2D, _tolerance) {

    if (_tolerance) {
        if (Math.abs(this.x - _pt2D.x) < _tolerance) {
            if (Math.abs(this.y - _pt2D.y) < _tolerance) {
                return true;
            }
        }
    }
    return this.x === _pt2D.x && this.y === _pt2D.y;
};

SVGPoint.prototype.add = function (_pt) {
    if (_pt.x === undefined) {
        return SVGUtils.createSVGPoint(this.x + _pt, this.y + _pt);
    }
    return SVGUtils.createSVGPoint(this.x + _pt.x, this.y + _pt.y);
};

SVGPoint.prototype.subtract = function (_pt) {
    if (_pt.x === undefined) {
        return SVGUtils.createSVGPoint(this.x - _pt, this.y - _pt);
    }
    return SVGUtils.createSVGPoint(this.x - _pt.x, this.y - _pt.y);
};

SVGPoint.prototype.multiply = function (_pt) {

    if (_pt.x === undefined) {
        return SVGUtils.createSVGPoint(this.x * _pt, this.y * _pt);
    }

    return SVGUtils.createSVGPoint(this.x * _pt.x, this.y * _pt.y);
};

SVGPoint.prototype.divide = function (_pt) {
    if (_pt.x === undefined) {
        return SVGUtils.createSVGPoint(this.x / _pt, this.y / _pt);
    }

    return SVGUtils.createSVGPoint(this.x / _pt.x, this.y / _pt.y);
};

SVGPoint.prototype.modulo = function (_pt) {
    if (_pt.x === undefined) {
        return SVGUtils.createSVGPoint(this.x % _pt, this.y % _pt);
    }
    return SVGUtils.createSVGPoint(this.x % _pt.x, this.y % _pt.y);
};

SVGPoint.prototype.negate = function (_pt) {
    return SVGUtils.createSVGPoint(-this.x, -this.y);
};

SVGPoint.prototype.dot = function (_pt) {
    return this.x * _pt.x + this.y * _pt.y;
};

SVGPoint.prototype.cross = function (_pt) {
    return this.x * _pt.y - this.y * _pt.x;
};

_ = SVGSVGElement.prototype;

SVGSVGElement.SVG_NS = 'http://www.w3.org/2000/svg';
SVGSVGElement.XLINK_NS = "http://www.w3.org/1999/xlink";

window.SVGUtils = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
window.SVGUtils.hitTestRect = SVGUtils.createSVGRect();

window.XMLUtils = new DOMParser().parseFromString("<xml></xml>", "application/xml");

_.elementListFromIntersection = function (_globalRect) {
    const resultList = [];
    const elementList = this.getIntersectionList(_globalRect, null);

    let currentElement;
    for (let i = 0; i < elementList.length; i++) {
        currentElement = elementList[i];
        if (currentElement.intersectGlobalRect(_globalRect)) {
            resultList.push(currentElement);
        }
    }
    return resultList;
};

if (SVGSVGElement.prototype.getIntersectionList === undefined) {

    SVGSVGElement.prototype.getIntersectionList = function (_hitTestRect, _resultList) {
        _resultList = _resultList || [];
        const viewRect = this.getBoundingClientRect();
        const elementRect = SVGUtils.createSVGRect();
        let element;
        let elementList = this.querySelectorAll('.layer > *:not(.locked)');

        _hitTestRect.xx = _hitTestRect.x + _hitTestRect.width;
        _hitTestRect.yy = _hitTestRect.y + _hitTestRect.height;

        for (let i = 0; i < elementList.length; i++) {

            element = elementList[i];
            switch (element.nodeName) {
            case 'g':
            case 'foreignObject':
            case 'image':
            case 'path':
            case 'line':
            case 'rect':
            case 'text':
            case 'ellipse':

                const bbox = element.getBoundingClientRect();

                elementRect.x = bbox.x - viewRect.x;
                elementRect.y = bbox.y - viewRect.y;
                elementRect.width = bbox.width;
                elementRect.height = bbox.height;
                elementRect.xx = elementRect.x + bbox.width;
                elementRect.yy = elementRect.y + bbox.height;

                if (!(elementRect.x > _hitTestRect.xx || elementRect.xx < _hitTestRect.x || elementRect.y > _hitTestRect.yy || elementRect.yy < _hitTestRect.y)) {
                    _resultList.push(element);
                }
                break;
            default:

            }
        }
        return _resultList;
    }

}

/*_.hitTestAtPoint = function( _e , _snapDistance ){
if(_e.path[0].nodeName==='foreignObject'){
_e.elementAtPoint = _e.path[0];
return;
}
const hitTestRect = window.SVGUtils.hitTestRect;
hitTestRect.x = _e.layerX-_snapDistance;
hitTestRect.y = _e.layerY-_snapDistance;
hitTestRect.height = hitTestRect.width = _snapDistance*2;
const elementList = this.getIntersectionList(hitTestRect, null);
if(elementList.length>0){
_e.elementListAtPoint = elementList;
const documentRoot = _e.shadowRoot || document;
const max = elementList.length;
let i;
for( i = 0; i < max; i++) elementList[i].classList.add( 'precise-hit-test' );
const elementAtPoint = documentRoot.elementFromPoint( _e.pageX , _e.pageY );
for( i = 0; i < max; i++) elementList[i].classList.remove( 'precise-hit-test' );
if(elementAtPoint && elementAtPoint.nodeName!=='svg') _e.elementAtPoint = elementAtPoint;
}
};*/

_.__createSVGPoint = _.createSVGPoint;

_.createSVGPoint = function (_x, _y) {
    var pt = this.__createSVGPoint();
    pt.x = _x || 0;
    pt.y = _y || 0;
    return pt;
};

// _.createSVGPointPolar = function( _r , _angle )
// {
//     var pt = this.__createSVGPoint();
//     pt.x = _r * Math.cos(_angle);
//     pt.y = _r * Math.sin(_angle);
//     return pt;
// };

_.createSVGPointPolar = function (_r, _angle) {
    var pt = this.__createSVGPoint();
    pt.x = _r * Math.cos(_angle);
    pt.y = _r * Math.sin(_angle);
    return pt;
};

_.createPath = function () {
    return document.createElementNS(SVGSVGElement.SVG_NS, 'path');
};

_.createLine = function (x1, y1, x2, y2) {
    const line = document.createElementNS(SVGSVGElement.SVG_NS, 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke-width', '1');
    line.setAttribute('stroke', '#000000');
    return line;
};

_.createRect = function (x, y, w, h, _useMatrix) {
    const rect = document.createElementNS(SVGSVGElement.SVG_NS, 'rect');

    if (_useMatrix) {
        rect.setAttribute('transform', 'matrix(1,0,0,1,' + x + ',' + y + ')');
    } else {
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
    }

    if (w)
        rect.setAttribute('width', w);
    if (h)
        rect.setAttribute('height', h);
    return rect;
};

_.createEllipse = function (cx, cy, rx, ry) {
    const ellipse = document.createElementNS(SVGSVGElement.SVG_NS, 'ellipse');
    ellipse.setAttribute('cx', cx);
    ellipse.setAttribute('cy', cy);
    ellipse.setAttribute('rx', rx);
    ellipse.setAttribute('ry', ry);
    return ellipse;
};

_.createGroup = function (_x, _y, _id) {
    const group = document.createElementNS(SVGSVGElement.SVG_NS, 'g');
    _x = _x || 0;
    _y = _y || 0;
    group.setAttribute('transform', 'matrix(1,0,0,1,' + _x + ',' + _y + ')');
    if (_id)
        group.setAttribute('id', _id);
    // group.removeAttribute('requiredExtensions');
    // group.removeAttribute('systemLanguage');
    return group;
};

_.createClipPath = function (_id) {
    const clipPath = document.createElementNS(SVGSVGElement.SVG_NS, 'clipPath');
    clipPath.setAttribute('id', _id);
    return clipPath;
};

_.createMask = function (_id) {
    const mask = document.createElementNS(SVGSVGElement.SVG_NS, 'mask');
    mask.setAttribute('id', _id);
    return mask;
};

// _.createTextBox = function( x, y, w, h, _text,  _fontFamily, _fontStyle, _fontWeight, _fontSize, _textAlign  )
// {
//     const textBox = document.createElementNS( SVGSVGElement.SVG_NS, 'text');
//
//     textBox.setAttribute('data-type', 'TextBox' );
//     textBox.setAttribute('data-custom-element', 'TextEditable_cmp' );
//     textBox.setAttribute('transform', 'matrix(1,0,0,1,'+x+','+y+')' );
//     textBox.setAttribute('width', w );
//     textBox.setAttribute('height', h );
//
//     _fontFamily = _fontFamily || 'arial';
//     // _fontStyle = _fontStyle || 'regular';
//     _fontStyle = _fontStyle || 'normal';
//     _fontWeight = _fontWeight || '400';
//     _fontSize = _fontSize || '12';
//     _textAlign = _textAlign || 'left';
//
//     textBox.setAttribute('font-family',_fontFamily );
//     textBox.setAttribute('font-size', _fontSize );
//     textBox.setAttribute('font-style', _fontStyle );
//     textBox.setAttribute('font-weight', _fontWeight );
//     textBox.setAttribute('text-align', _textAlign );
//
//     let svgAlign='start';
//
//     if( _textAlign === 'left') { svgAlign='start'; } else if( _textAlign === 'center') { svgAlign='middle'; } else if( _textAlign === 'right'){ svgAlign='end'; }
//
//     textBox.setAttribute('text-anchor', svgAlign );
//
//     textBox.initCustomElement();
//     textBox.initTextData(_text);
//     return textBox;
// };

_.createTextBox = function (x, y, w, h, _text, _fontFamily, _fontStyle, _fontWeight, _fontSize, _textAlign) {
    const textBox = document.createElementNS(SVGSVGElement.SVG_NS, 'text');

    textBox.setAttribute('data-type', 'TextBox');
    //textBox.setAttribute('data-custom-element', 'TextEditable_cmp' );
    textBox.setAttribute('transform', 'matrix(1,0,0,1,' + x + ',' + y + ')');
    textBox.setAttribute('width', w);
    textBox.setAttribute('height', h);
    textBox.setAttribute('tabindex', '1');

    _fontFamily = _fontFamily || 'arial';
    // _fontStyle = _fontStyle || 'regular';
    _fontStyle = _fontStyle || 'normal';
    _fontWeight = _fontWeight || '400';
    _fontSize = _fontSize || '12';
    _textAlign = _textAlign || 'left';

    textBox.setAttribute('font-family', _fontFamily);
    textBox.setAttribute('font-size', _fontSize);
    textBox.setAttribute('font-style', _fontStyle);
    textBox.setAttribute('font-weight', _fontWeight);
    textBox.setAttribute('text-align', _textAlign);

    let svgAlign = 'start';

    if (_textAlign === 'left') {
        svgAlign = 'start';
    } else if (_textAlign === 'center') {
        svgAlign = 'middle';
    } else if (_textAlign === 'right') {
        svgAlign = 'end';
    }

    textBox.setAttribute('text-anchor', svgAlign);
    textBox.setAttribute('focusable', "true");

    //textBox.innerHTML = _text;

    const tspan = this.createTSpan(0, _text, 20);
    textBox.appendChild(tspan);

    // textBox.initCustomElement();
    textBox.initTextData(_text);
    return textBox;
};

_.createTSpan = function (x, _text, _baseline) {
    const tspan_element = document.createElementNS(SVGSVGElement.SVG_NS, "tspan");
    tspan_element.setAttribute("x", "0");
    tspan_element.setAttribute("dy", _baseline);
    tspan_element.setAttribute("style", 'white-space: pre;');
    tspan_element.appendChild(XMLUtils.createCDATASection(_text));
    return tspan_element;
}

_.createSVGStopColor = function (_offset, _color, _opacity) {
    const stopColorElement = document.createElementNS(SVGSVGElement.SVG_NS, "stop");
    stopColorElement.setAttribute("offset", _offset);
    stopColorElement.setAttribute("stop-color", _color);
    if (_opacity)
        stopColorElement.setAttribute("stop-opacity", _opacity);
    //stopColorElement.setAttribute("style", 'stop-color:'+_color);
    return stopColorElement;
};

_.createSymbol = function (_id) {
    const symbol = document.createElementNS(SVGSVGElement.SVG_NS, 'symbol');
    symbol.setAttribute('id', _id);
    symbol.setAttribute('overflow', "visible");
    return symbol;
};

_.createForeignObject = function (x, y, w, h, _innerHTML) {
    const foreignObject = document.createElementNS(SVGSVGElement.SVG_NS, 'foreignObject');
    foreignObject.setAttribute('transform', 'matrix(1,0,0,1,' + x + ',' + y + ')');
    foreignObject.setAttribute('x', 0);
    foreignObject.setAttribute('y', 0);
    foreignObject.setAttribute('width', w);
    foreignObject.setAttribute('height', h);
    foreignObject.innerHTML = _innerHTML;
    return foreignObject;
};

_.createForeignObjectHtmlText = function (x, y, w, h, _text) {
    const foreignObject = this.createForeignObject(x, y, w, h, '<div>' + _text + '</div>');
    foreignObject.setAttribute('data-type', 'html-text')
    return foreignObject;
};

_.createForeignObjectWidget = function (x, y, w, h, _widgetUrl) {
    const foreignObject = this.createForeignObject(x, y, w, h, '<iframe xmlns="http://www.w3.org/1999/xhtml" width="100%" height="100%" src="' + _widgetUrl + '" frameborder="0"> </iframe>');
    foreignObject.setAttribute('data-type', 'iframe-widget')
    return foreignObject;
};

_.createPattern = function (_id, _x, _y, _width, _height, _rotate, _scale, _patternUnits) {

    const pattern = document.createElementNS(SVGSVGElement.SVG_NS, 'pattern');
    pattern.setAttribute("id", _id);
    _x = _x || 0;
    _y = _y || 0;
    _width = _width || 100;
    _height = _height || 100;
    _patternUnits = _patternUnits || "userSpaceOnUse";

    pattern.setAttribute("x", _x);
    pattern.setAttribute("y", _y);

    if (_rotate || _scale) {
        pattern.setAttribute("patternTransform", 'rotate(' + _rotate + ') ' + 'scale(' + _scale + ') ');
    }

    pattern.setAttribute("patternUnits", _patternUnits);
    pattern.setAttribute("width", _width);
    pattern.setAttribute("height", _height);

    return pattern;
};

_.createMarker = function (_id, _markerWidth, _markerHeight, _markerUnits, _refX, _refY, _orient) {
    var marker = document.createElementNS(SVGSVGElement.SVG_NS, 'marker');
    marker.setAttribute("id", _id);
    _refX = _refX || 0;
    _refY = _refY || 0;
    _orient = _orient || "auto";
    _markerUnits = _markerUnits || "strokeWidth";

    marker.setAttribute("refX", _refX);
    marker.setAttribute("refY", _refY);
    marker.setAttribute("orient", _orient);
    marker.setAttribute("markerUnits", _markerUnits);
    marker.setAttribute("style", 'overflow:visible;');

    if (_markerWidth)
        marker.setAttribute("markerWidth", _markerWidth);
    if (_markerHeight)
        marker.setAttribute("markerHeight", _markerHeight);

    return marker;
};

_.createImage = function (_url, _x, _y, _width, _height, _onLoadCallback) {
    _x = _x || 0;
    _y = _y || 0;

    var imageElement = document.createElementNS(SVGSVGElement.SVG_NS, "image");
    imageElement.setAttribute('x', _x);
    imageElement.setAttribute('y', _y);

    if (!_width || !_height) {
        var img = new Image();
        img.src = _url;
        img.onload = function () {
            imageElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', _url);
            // imageElement.setAttribute( 'xlink:href', _url );
            imageElement.setAttribute('width', this.width);
            imageElement.setAttribute('height', this.height);
            if (_onLoadCallback)
                _onLoadCallback(imageElement);
        }
    } else {
        imageElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', _url);
        // imageElement.setAttribute( 'xlink:href', _url );
        imageElement.setAttribute('width', _width);
        imageElement.setAttribute('height', _height);
    }

    return imageElement;
};

_.createUse = function (_xlink_href) {
    const use = document.createElementNS(SVGSVGElement.SVG_NS, 'use');
    // use.setAttributeNS( SVGSVGElement.XLINK_NS , 'href', '#'+_xlink_href  );
    use.setAttribute('href', '#' + _xlink_href);
    return use;
};

_.createDefs = function () {
    return document.createElementNS(SVGSVGElement.SVG_NS, 'defs');
};

_.createXlink = function (_href, _target) {
    const xlink = document.createElementNS(SVGSVGElement.SVG_NS, 'a');
    xlink.setAttribute('xlink:href', _href);
    if (_target)
        xlink.setAttribute('target', _target);
    return xlink;
};

_.createSVGLinearGradient = function (_id, _x1, _y1, _x2, _y2, _gradientUnits, _spreadMethod) {
    _gradientUnits = _gradientUnits || 'objectBoundingBox';
    _spreadMethod = _spreadMethod || 'pad';
    const gradientElement = document.createElementNS(SVGSVGElement.SVG_NS, "linearGradient");
    gradientElement.setAttribute("id", _id);
    gradientElement.setAttribute("x1", _x1);
    gradientElement.setAttribute("y1", _y1);
    gradientElement.setAttribute("x2", _x2);
    gradientElement.setAttribute("y2", _y2);
    gradientElement.setAttribute("gradientUnits", _gradientUnits);
    gradientElement.setAttribute("gradientTransform", 'matrix(1 0 0 1 0 0)');
    gradientElement.setAttribute("spreadMethod", _spreadMethod);
    return gradientElement;
};

_.createSVGRadialGradient = function (_id, _cx, _cy, _r, _gradientUnits, _spreadMethod) {
    _gradientUnits = _gradientUnits || 'objectBoundingBox';
    _spreadMethod = _spreadMethod || 'pad';
    const gradientElement = document.createElementNS(SVGSVGElement.SVG_NS, "radialGradient");
    gradientElement.setAttribute("id", _id);
    gradientElement.setAttribute("cx", _cx);
    gradientElement.setAttribute("cy", _cy);
    gradientElement.setAttribute("r", _r);
    gradientElement.setAttribute("gradientUnits", _gradientUnits);
    gradientElement.setAttribute("gradientTransform", 'matrix(1 0 0 1 0 0)');
    gradientElement.setAttribute("spreadMethod", _spreadMethod);
    return gradientElement;
};

_.createSVG = function (_width, _height) {
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');
    if (_width)
        svg.setAttribute('width', _width);
    if (_height)
        svg.setAttribute('height', _height);
    return svg;
};

_.consolidateMatrix = function () {
    const elements = this.querySelectorAll('[transform]');
    for (let i = 0; i < elements.length; i++) {
        elements[i].getTransform().setMatrix(elements[i].transform.baseVal.consolidate().matrix);
    }
};

_.getResourceById = function (_id) {
    return this.querySelector('defs [id="' + _id + '"]');
};

_.extractIdFromIRI = function (_iri) {
    if (_iri.indexOf('url') !== -1) {
        return _iri.split('#')[1].split(')')[0].split('"')[0]; // elimino anche l'eventuale doppio apice finale
    }
    return null;
};

_.getResourceByIRI = function (_idAttributeValue) {
    const id = this.extractIdFromIRI(_idAttributeValue);
    if (id)
        return this.getResourceById(id);
    return null;
};

_.addResource = function (_resourceElement, _newId) {
    if (_newId)
        _resourceElement.setAttribute('id', _newId);
    this.querySelector('defs').appendChild(_resourceElement);
};

_.createResourceIdFromExistentId = function (idResource) {
    let counter = 1;
    const splittedName = idResource.split('_');
    if (splittedName.length > 1) {
        let numberInName = parseInt(splittedName.pop());
        if (!isNaN(numberInName)) {
            counter = numberInName;
            idResource = splittedName.join('_');
        }
    }

    let idNewResource = idResource + '_' + counter;
    let existentResource = this.getResourceById(idNewResource);
    while (existentResource) {
        counter++;
        idNewResource = idResource + '_' + counter;
        existentResource = this.getResourceById(idNewResource);
    }
    return idNewResource;
};

_.removeUnusedResources = function (_options) {
    const defsElementList = this.querySelectorAll('defs>*[id]');
    let element;
    for (let i = 0; i < defsElementList.length; i++) {
        element = defsElementList[i];

        if ((element.nodeName === 'linearGradient' || element.nodeName === 'radialGradient')) {
            if (_options.removeUnusedGradients === false)
                continue;
        } else if (element.nodeName === 'pattern') {
            if (_options.removeUnusedPatterns === false)
                continue;
        } else if (element.nodeName === 'symbol') {
            if (_options.removeUnusedSymbols === false)
                continue;
        } else if (element.nodeName === 'filter') {
            if (_options.removeUnusedFilters === false)
                continue;
        } else if (element.nodeName === 'marker') {
            if (_options.removeUnusedMarkers === false)
                continue;
        }

        if (this.getReferencedElementList(element).length === 0)
            element.remove();
    }
};

_.getReferencedElementList = function (_sourceElement) {
    const ID = _sourceElement.getAttribute('id');

    switch (_sourceElement.nodeName) {
    case 'symbol':
        return this.querySelectorAll('use[href="#' + ID + '"]');
        break;
    case 'filter':
        // return this.querySelectorAll( '*[filter="url(#' + ID + ')"]');
        return this.querySelectorAll('*[filter*="#' + ID + '"]');
        break;
    case 'marker':
        //return this.querySelectorAll('*[marker-start="url(#' + ID + ')"],'+'*[marker-mid="url(#' + ID + ')"],'+'*[marker-end="url(#' + ID + ')"]');
        return this.querySelectorAll('*[marker-start*="#' + ID + '"],*[marker-mid*="#' + ID + '"],*[marker-end*="#' + ID + '"]');
        break;
    case 'linearGradient':
    case 'radialGradient':
    case 'pattern':
        // return this.querySelectorAll( '*[fill="url(#' + ID + ')"],'+'*[stroke="url(#' + ID + ')"]');
        return this.querySelectorAll('*[fill*="' + ID + '"],*[stroke*="' + ID + '"]');
        break;
    default:
        //return this.querySelectorAll('*[clip-path="url(#' + ID + ')"],'+'*[mask="url(#' + ID + ')"],'+'*[*|href="url(#' + ID + ')"]');
        return this.querySelectorAll('*[clip-path*="#' + ID + '"],*[mask*="#' + ID + '"],*[*|href="#' + ID + '"]');
        break;
    }
};

// _.refactorElementID = function( _sourceElement , _newID , _rootNode  )
// {
//     _rootNode = _rootNode || this;
//
//     const oldID = _sourceElement.getAttribute('id');
//
//     _sourceElement.setAttribute('id',_newID);
//
//     let referencedElementList;
//
//     switch (_sourceElement.nodeName)
//     {
//         case 'symbol':
//             referencedElementList = _rootNode.querySelectorAll( 'use[href="#' + oldID + '"]');
//             this.setAttributeElementList( referencedElementList,{'href':'#'+_newID } );
//             break;
//         case 'filter':
//             referencedElementList = _rootNode.querySelectorAll( '*[filter*="#' + oldID + '"]');
//             this.setAttributeElementList( referencedElementList,{'filter':'url(#'+_newID +')'} );
//             break;
//         case 'marker':
//             referencedElementList = _rootNode.querySelectorAll('*[marker-start*="url(#' + oldID + ')"]');
//             this.setAttributeElementList( referencedElementList, {'marker-start':'url(#'+_newID +')'} );
//             referencedElementList = _rootNode.querySelectorAll('*[marker-mid*="url(#' + oldID + ')"]');
//             this.setAttributeElementList( referencedElementList, {'marker-mid':'url(#'+_newID +')'} );
//             referencedElementList = _rootNode.querySelectorAll('*[marker-end*="url(#' + oldID + ')"]');
//             this.setAttributeElementList( referencedElementList, {'marker-end':'url(#'+_newID +')'} );
//             break;
//         case 'linearGradient': case 'radialGradient': case 'pattern':
//         referencedElementList = _rootNode.querySelectorAll( '*[fill*="url(#'+oldID+')"]');
//         this.setAttributeElementList( referencedElementList,{'fill':'url(#'+_newID+')'} );
//         referencedElementList = _rootNode.querySelectorAll( '*[stroke*="url(#'+oldID+')"]');
//         this.setAttributeElementList( referencedElementList,{'stroke':'url(#'+_newID+')'} );
//         break;
//
//         default:
//             referencedElementList = _rootNode.querySelectorAll('*[clip-path*="url(#' + oldID + ')"]');
//             this.setAttributeElementList( referencedElementList,{'clip-path':'url(#'+_newID +')'} );
//             referencedElementList = _rootNode.querySelectorAll('*[mask*="url(#' + oldID + ')"]');
//             this.setAttributeElementList( referencedElementList,{'mask':'url(#'+_newID +')'} );
//             referencedElementList = _rootNode.querySelectorAll('*[*|href="#' + oldID + '"]');
//             this.setAttributeElementList( referencedElementList,{ 'href':'#'+_newID } );
//             break;
//     }
//
//     return referencedElementList;
// };

// _.setAttributeElementList = function (  _elementList , _attributeKeyValues   )
// {
//     for(let i=0; i<_elementList.length; i++ )
//     {
//         for(let attributeName in _attributeKeyValues)
//         {
//             _elementList[i].setAttribute( attributeName, _attributeKeyValues[ attributeName ] );
//         }
//     }
// };

_.getAsBitmap = function (_callback, _mimeType, _scale, _asBlob) {
    const _svg = this;
    _mimeType = _mimeType || "image/png";
    _scale = _scale || 1;
    const svgString = new XMLSerializer().serializeToString(_svg);
    const DOMURL = window.URL;
    const blob = new Blob([svgString], {
        type: "image/svg+xml;charset=utf-8"
    });
    const objectUrl = DOMURL.createObjectURL(blob);

    const canvas = document.createElement("canvas");
    canvas.width = Math.floor(_svg.getAttribute('width') * _scale);
    canvas.height = Math.floor(_svg.getAttribute('height') * _scale);
    const ctx = canvas.getContext("2d");

    const img = new Image();
    img.onload = function () {
        if (_mimeType === 'image/jpeg') {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        ctx.drawImage(img, 0, 0);

        if (_asBlob) {
            function onBlobCreate(_blobData) {
                _callback(_blobData);
                DOMURL.revokeObjectURL(objectUrl);
            }
            canvas.toBlob(onBlobCreate, _mimeType);
        } else {
            _callback(canvas.toDataURL(_mimeType));
            DOMURL.revokeObjectURL(objectUrl);
        }
    };

    img.src = objectUrl;
};

//
// _.encodeSVG = function ( _svg )
// {
//     let svgAsString = new XMLSerializer().serializeToString(_svg);
//
//     //
//     //   Encode (may need a few extra replacements)
//     //
//     svgAsString.replace(/"/g, '\'')
//         .replace(/%/g, '%25')
//         .replace(/#/g, '%23')
//         .replace(/{/g, '%7B')
//         .replace(/}/g, '%7D')
//         .replace(/</g, '%3C')
//         .replace(/>/g, '%3E')
//         .replace(/\s+/g,' ')
//     //
//     //    The maybe list (add on documented fail)
//     //
//      .replace(/&/g, '%26')
//      .replace('|', '%7C')
//      .replace('[', '%5B')
//      .replace(']', '%5D')
//      .replace('^', '%5E')
//      .replace('`', '%60')
//      .replace(';', '%3B')
//      .replace('?', '%3F')
//      .replace(':', '%3A')
//      .replace('@', '%40')
//      .replace('=', '%3D');
//
//     return svgAsString;
// };


_.convertElementListToPath = function (_elementListToConvert, _onComplete, _onProgress, _onError) {
    const convertedPathList = [];
    let i,
    max,
    element,
    newPath;

    max = _elementListToConvert.length;
    let maxTextToConvert = 0;
    let textConvertedCounter = 0;

    // const progressWindow = activeApplication.windows['progress-window'];

    function onTextConverted(_groupOfPaths) {
        textConvertedCounter++;
        if (textConvertedCounter === maxTextToConvert) {
            // progressWindow.endVirtualProgress();
            _onComplete(convertedPathList);
        } // se non ci altri testi da convertire
    }

    function onFontLoadingError() {
        _onError('The Font file could not be loaded.');
        // activeApplication.modalDialogs['alert-dialog'].open( localString('Error!') , localString('The Font file could not be loaded.'));
    }

    for (i = 0; i < max; i++) {
        element = _elementListToConvert[i];
        if (element.nodeName === 'text') {
            maxTextToConvert++;
            newPath = element.convertTextToPath(onTextConverted, onFontLoadingError);
            convertedPathList.push(newPath);
        } else if (element.nodeName === 'path') {
            newPath = element.cloneNode();
            convertedPathList.push(newPath);
        } else if (element.nodeName === 'g' && element.dataset.objectId) {
            const objectController = OBJECTS[element.dataset.objectId];
            const newPath = objectController.convertToPath(element);
            if (newPath)
                convertedPathList.push(newPath);
        } else {
            newPath = SVGUtils.createPath();
            newPath.getTransform().setMatrix(element.getTransform().matrix.clone());
            newPath.setPathData(element.getPathData({
                    absolutize: true,
                    normalize: true
                }));
            newPath.setGraphicAttributesByElement(element);
            convertedPathList.push(newPath);
        }
    }

    if (maxTextToConvert === 0) // se non ci sono testi da convertire
    {
        _onComplete(convertedPathList);
    }
    // else {
    //     progressWindow.open(true).setProgressBarValue(1).startVirtualProgress(100000);
    //     // progressWindow.setProgressBarValue(1);
    //     // progressWindow.open(true);
    //     // progressWindow.startVirtualProgress( 100000 );
    // }

};

_ = SVGSVGElement.prototype;

_.parse_clear = function () {
    const svgTagAttributes = SVG_TAG_ATTRIBUTES;

    function clearNodes(_parentNode) {
        let attributeName,
        attributeList,
        element;
        const elementList = [].slice.call(_parentNode.children, 0);
        let ie,
        ia,
        validSvgTag;
        const max = elementList.length;
        for (ie = 0; ie < max; ie++) {
            element = elementList[ie];
            validSvgTag = svgTagAttributes[element.nodeName];
            if (!validSvgTag) {
                element.parentElement.removeChild(element);
                continue;
            } else if (element.attributes) {
                attributeList = [].slice.call(element.attributes, 0);
                for (ia = 0; ia < attributeList.length; ia++) {
                    attributeName = attributeList[ia].name;
                    if (validSvgTag.indexOf(attributeName) === -1) {
                        if (svgTagAttributes['*'].indexOf(attributeName) === -1) {
                            if (attributeName.indexOf('data-') !== 0) {
                                element.removeAttribute(attributeName);
                            }
                        }
                    }
                }
            }

            clearNodes(element);
        }
    }

    clearNodes(this);
};

_.parse_adjustAttributes = function () {

    function adjustElementAttribute(_elementList, _attributeName, _value) {
        let element;
        const max = _elementList.length;
        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            if (element.hasAttribute(_attributeName))
                return;
            let parent = element.parentElement;
            while (parent && (!parent.hasAttribute(_attributeName)))
                parent = parent.parentElement;
            if (parent)
                _value = parent.getAttribute(_attributeName);
            element.setAttribute(_attributeName, _value);
        }
    }

    let i,
    max;
    const allTypeList = this.querySelectorAll('ellipse,path,line,rect');
    const lineList = [];
    const rectList = [];
    const ellipseList = [];
    const pathList = [];
    let type;
    max = allTypeList.length;
    for (let i = 0; i < max; i++) {
        type = allTypeList[i].nodeName;

        if (type === 'line') {
            lineList.push(allTypeList[i]);
        } else if (type === 'rect') {
            rectList.push(allTypeList[i]);
        } else if (type === 'ellipse') {
            ellipseList.push(allTypeList[i]);
        } else if (type === 'path') {
            pathList.push(allTypeList[i]);
        }
    }

    adjustElementAttribute(allTypeList, 'stroke', 'none');
    adjustElementAttribute(allTypeList, 'stroke-width', '1');
    adjustElementAttribute(lineList.concat(pathList), 'stroke-linecap', 'butt');
    adjustElementAttribute(rectList.concat(pathList), 'stroke-linejoin', 'miter');
    adjustElementAttribute(rectList.concat(ellipseList, pathList), 'fill', '#000000');

    let currentColorElementList = this.querySelectorAll('[stroke="currentColor"]');
    max = currentColorElementList.length;
    for (i = 0; i < max; i++)
        currentColorElementList[i].setAttribute('stroke', '#000000');

    currentColorElementList = this.querySelectorAll('[fill="currentColor"]');
    max = currentColorElementList.length;
    for (i = 0; i < max; i++)
        currentColorElementList[i].setAttribute('fill', '#000000');

};

_.parse_scripts = function () {
    const result = [];
    const elementList = [].slice.call(this.querySelectorAll('script'), 0);
    let element;
    const max = elementList.length;
    for (let i = 0; i < max; i++) {
        element = elementList[i];
        result.push({
            description: 'script removed',
            element: element
        });
        element.parentElement.removeChild(element);
    }
    return result;
};

// un clipped content è composto da un elemento da clippare (es. un gruppo) e uno o più  elementi usati come clippath
_.parse_clipPaths = function () {
    const elementList = [].slice.call(this.querySelectorAll('[clip-path]'), 0);
    let element,
    urlClipPath,
    idClipPath,
    clipPath;
    const max = elementList.length;
    for (let i = 0; i < max; i++) {
        element = elementList[i];
        // verificare! perchè potrebbe non essere un gruppo
        if (element.nodeName === 'g') {
            urlClipPath = element.getAttribute('clip-path');
            idClipPath = this.extractIdFromIRI(urlClipPath);
            clipPath = this.querySelector('clipPath[id="' + idClipPath + '"]');
            if (clipPath) {
                if (clipPath.parentElement !== element) {
                    if (element.children.length > 1) {
                        const newGroup = this.createGroup();
                        // newGroup.appendChildren(element.children);
                        element.moveChildrenTo(newGroup);
                        element.appendChild(newGroup);
                    }
                    element.appendChild(clipPath);
                }
            } else {}
        }
    }
};

// un masked content è composto da un elemento da mascherare (es. un gruppo) e uno o più  elementi usati come maschera
_.parse_masks = function () {
    const elementList = [].slice.call(this.querySelectorAll('[mask]'), 0);
    let element,
    urlMask,
    idMask,
    mask;
    const max = elementList.length;
    for (let i = 0; i < max; i++) {
        element = elementList[i];
        // verificare! perchè potrebbe non essere un gruppo
        if (element.nodeName === 'g') {
            urlMask = element.getAttribute('mask');
            idMask = this.extractIdFromIRI(urlMask);
            mask = this.querySelector('mask[id="' + idMask + '"]');
            if (mask) {
                if (mask.parentElement !== element) {
                    if (element.children.length > 1) {
                        const newGroup = this.createGroup();
                        newGroup.appendChildren(element.children);
                        element.appendChild(newGroup);
                    }
                    element.appendChild(mask);
                }
            } else {}
        }
    }
};

_.parse_styleToAttributes = function () {
    const elements = this.querySelectorAll('[style]');
    for (let i = 0; i < elements.length; i++)
        if (elements[i]instanceof SVGElement)
            elements[i].stylePropertiesToAttributes();
};

// questo è sicuramente da mettere a posto !!!
_.parse_cssToAttributes = function () {
    const styleList = [].slice.call(this.querySelectorAll('style'), 0);

    function removeComments(css) {
        return css.replace(/\/\*(\r|\n|.)*\*\//g, "");
    }

    function parseCSSBlock(css) {
        const rule = {};
        const declarations = css.split(';');
        declarations.pop();
        const len = declarations.length;
        let i,
        loc,
        property,
        value;
        for (i = 0; i < len; i++) {
            loc = declarations[i].indexOf(':');
            property = declarations[i].substring(0, loc).trim();
            value = declarations[i].substring(loc + 1).trim();
            //console.log('css property', property );
            //console.log('css value', value );
            if (property !== "" && value !== "")
                rule[property] = value;
        }
        return rule;
    }

    function parseCSS(css) {
        const rules = {};
        css = removeComments(css);
        const blocks = css.split('}');
        blocks.pop();
        const len = blocks.length;
        let i,
        pair,
        className;
        for (i = 0; i < len; i++) {
            pair = blocks[i].split('{');
            //className = pair[0].trim().split('.')[1];
            className = pair[0].trim();
            rules[className] = parseCSSBlock(pair[1]);
        }
        return rules;
    }

    let CSS_JSON,
    elementList,
    className;
    const max = styleList.length;
    for (let i = 0; i < max; i++) {
        CSS_JSON = parseCSS(styleList[i].textContent);
        styleList[i].remove();
        for (className in CSS_JSON) {
            //console.log('css className', className );
            //console.log('css CSS_JSON[className]', CSS_JSON[className] );
            elementList = this.querySelectorAll(className);
            for (let i2 = 0; i2 < elementList.length; i2++) {
                elementList[i2].stylePropertiesToAttributes(CSS_JSON[className]);
                elementList[i2].classList.remove(className);
            }
        }
    }

};

_.parse_class = function () {
    const elements = this.querySelectorAll('.layer *[class]');
    let element;
    for (let i = 0; i < elements.length; i++) {
        element = elements[i];
        //element.setAttribute('data-css-class', element.getAttribute('class') );
        element.__setAttribute('data-css-class', element.getAttribute('class'));
        element.removeAttribute('class');
    }
};

_.parse_fonts = function () {

    const result = [];

    const sourceDefsNode = this.querySelector('defs');

    if (sourceDefsNode) {
        const linkTagsList = [].slice.call(sourceDefsNode.querySelectorAll('link'), 0);
        let i,
        linkNode,
        href;
        const max = linkTagsList.length;
        for (i = 0; i < max; i++) {
            linkNode = linkTagsList[i];

            if (linkNode.hasAttribute("rel")) {
                if (linkNode.getAttribute("rel") === "stylesheet") {
                    href = linkNode.getAttribute("href");
                    href = href.replace("http:", "https:");
                    let isGoogleFont = href.indexOf('//fonts.googleapis.com/css?family');
                    if (isGoogleFont > -1) {
                        result.push({
                            description: 'google font',
                            href: href
                        });
                        linkNode.remove();
                    }
                }
            }
        }
    }

    return result;
};

_.parse_gradients = function () {
    const gradientList = this.querySelectorAll('linearGradient[*|href],radialGradient[*|href]');
    let gradient,
    gradientDef;
    const max = gradientList.length;
    for (let i = 0; i < max; i++) {
        gradient = gradientList[i];
        gradientDef = this.querySelector(gradient.getAttribute('xlink:href'));
        if (gradientDef) {
            gradientDef.cloneChildrenTo(gradient);
            if (gradientDef.hasAttribute('gradientTransform') && (!gradient.hasAttribute('gradientTransform')))
                gradient.setAttribute('gradientTransform', gradientDef.getAttribute('gradientTransform'));
            gradient.removeAttribute('xlink:href');
        }
    }
};

_.parse_anchors = function () {

    const elementList = [].slice.call(this.querySelectorAll('a'), 0);
    const max = elementList.length;
    let i,
    xlinkUrl,
    element,
    parentElement;

    for (i = 0; i < max; i++) {
        element = elementList[i];
        parentElement = element.parentElement;
        xlinkUrl = element.getAttribute('xlink:href');
        const content = element.firstElementChild;
        content.setAttribute('data-xlink-href', xlinkUrl);
        if (element.hasAttribute("target"))
            content.setAttribute('data-xlink-target', element.getAttribute('target'));
        parentElement.replaceChild(element.firstElementChild, element)
    }

};

_.sanitize_geometry = function () {
    // if( this.isJanvasDocument ) return;

    //console.log('sanitize_geometry');


    let elementListToConvert = 'polygon,polyline,circle,path';

    const elementList = this.querySelectorAll(elementListToConvert);
    let i,
    element,
    newElement;
    for (i = 0; i < elementList.length; i++) {
        element = elementList[i];
        if (element.nodeName === 'circle') {
            newElement = this.createEllipse(element.getAttribute('cx'), element.getAttribute('cy'), element.getAttribute('r'), element.getAttribute('r'));
        } else {
            newElement = this.createPath();
            newElement.setPathData(element.getPathData({
                    absolutize: true,
                    normalize: true
                }));
        }

        newElement.setGraphicAttributesByElement(element);
        if (element.hasAttribute('transform'))
            newElement.setAttribute('transform', element.getAttribute('transform'));
        element.parentElement.replaceChild(newElement, element);
    }
};

// _.sanitize_geometry = function()
// {
//     let elementListToConvertToPath = 'polygon,polyline,circle';
//     if( ! this.isJanvasDocument ) elementListToConvertToPath+=',path';
//
//     const elementList = this.querySelectorAll(elementListToConvertToPath);
//     let i,path,element;
//     for ( i = 0; i < elementList.length; i++) {
//         element = elementList[i];
//         element.getPathData();
//         path = this.createPath();
//         path.setGraphicAttributesByElement(element);
//         path.setPathData(element.getPathData({absolutize:true,normalize:true}));
//         if (element.hasAttribute('transform')) path.setAttribute('transform', element.getAttribute('transform'));
//         element.parentElement.replaceChild(path, element);
//     }
// };

_.areSourceDefsInTargetDefs = function (_targetDefs) {
    const sourceDefsItems = this.querySelectorAll('defs *[id]');
    if (sourceDefsItems.length > 0) {
        let query = '';
        for (let i = 0; i < sourceDefsItems.length; i++)
            query += ('[id="' + sourceDefsItems[i].getAttribute('id') + '"],');
        query = query.substring(0, query.length - 1); // tolgo la virgola finale
        return _targetDefs.querySelector(query); // se è presente un elemento vuol dire che si dovrà chiedere cosa fare
    }
    return false;
};

_.parse_defs = function (_targetDefs) {
    // const sourceDefs = this.querySelector('defs');
    let defsList = this.querySelectorAll('defs');

    if (defsList.length === 0)
        this.appendChild(SVGUtils.createDefs());
    defsList = this.querySelectorAll('defs');

    if (defsList.length > 1) {
        for (let i = 1; i < defsList.length; i++) {
            //defsList[0].appendChildren(defsList[i].children);
            defsList[i].moveChildrenTo(defsList[0]);
            defsList[i].remove();
        }
    }

    const sourceDefs = defsList[0];

    //if( ! sourceDefs ) return;
    sourceDefs.remove(); // rimuovo il defs
    //Verifco che non ci siano elementi che andrebbero in defs presenti nel documento
    const elementList = [].slice.call(this.querySelectorAll('linearGradient,radialGradient,pattern,marker,symbol'), 0);
    for (let i = 0; i < elementList.length; i++)
        sourceDefs.appendChild(elementList[i]);
    this.appendChild(sourceDefs); // riaggiungo il defs perchè poteri dover rifare un refactor degli id degli elementi , anche quelli dentro il defs

    if (_targetDefs) {
        const defsSourceElementList = sourceDefs.querySelectorAll('*[id]');
        let sourceDefsItem,
        sourceDefsItemID;

        for (let i = 0; i < defsSourceElementList.length; i++) {
            sourceDefsItem = defsSourceElementList[i];
            sourceDefsItemID = sourceDefsItem.getAttribute('id');
            let targetDefsItem = _targetDefs.querySelector('[id="' + sourceDefsItemID + '"]');
            if (targetDefsItem) {
                sourceDefsItem.setAttribute('data-item-exists', 'true');
                sourceDefsItem.targetDefsItem = targetDefsItem;
            }
        }
    }

};

// _.parse_defs = function ( _targetDefs )
// {
//     // const sourceDefs = this.querySelector('defs');
//     const defsList = this.querySelectorAll('defs');
//
//     if(defsList.length===0)return null;
//
//     if(defsList.length>1)
//     {
//         for (let i = 1; i < defsList.length; i++)
//         {
//             defsList[0].appendChildren(defsList[i].children);
//             defsList[i].remove();
//         }
//     }
//
//     const sourceDefs = defsList[0];
//
//
//     //if( ! sourceDefs ) return;
//     sourceDefs.remove(); // rimuovo il defs
//     //Verifco che non ci siano elementi che andrebbero in defs presenti nel documento
//     const elementList = [].slice.call(this.querySelectorAll('linearGradient,radialGradient,pattern,marker,symbol'), 0);
//     for (let i = 0; i < elementList.length; i++) sourceDefs.appendChild(elementList[i]);
//     this.appendChild( sourceDefs ); // riaggiungo il defs perchè poteri dover rifare un refactor degli id degli elementi , anche quelli dentro il defs
//
//     if(_targetDefs)
//     {
//         const defsSourceElementList = sourceDefs.querySelectorAll('*[id]');
//         let sourceDefsItem,sourceDefsItemID;
//
//         for (let i = 0; i < defsSourceElementList.length; i++)
//         {
//             sourceDefsItem = defsSourceElementList[i];
//             sourceDefsItemID = sourceDefsItem.getAttribute('id');
//             let targetDefsItem = _targetDefs.querySelector('[id="'+sourceDefsItemID+'"]' );
//             if(targetDefsItem) {
//                 sourceDefsItem.setAttribute('data-item-exists','true');
//                 sourceDefsItem.targetDefsItem = targetDefsItem;
//             }
//         }
//     }
//
//
// };


_.parse_content = function () {};

_.parse_text = function () {
    //const textElementList = this.querySelectorAll('text');
    const textElementList = this.querySelectorAll('text:not( [data-type="object"] text)'); // escludo oggetti tipo: dimension ed altri figli di object
    let i,
    textElement;
    for (i = 0; i < textElementList.length; i++) {
        textElement = textElementList[i];

        if (!textElement.hasAttribute('data-custom-element'))
            textElement.__setAttribute('data-custom-element', "TextEditable_cmp");
        if (!textElement.hasAttribute('data-type'))
            textElement.__setAttribute('data-type', "TextBox");

        if (textElement.hasAttribute('x') && textElement.hasAttribute('y')) {
            let matrix = textElement.getTransform().matrix.translate(parseFloat(textElement.getAttribute('x')), parseFloat(textElement.getAttribute('y')));
            textElement.getTransform().setMatrix(matrix);
            textElement.removeAttribute('x');
            textElement.removeAttribute('y');

            if (textElement.firstElementChild) {
                textElement.firstElementChild.__setAttribute('x', '0');
                textElement.firstElementChild.__setAttribute('y', '0');
            }
        }

        const tspanElementList = textElement.querySelectorAll('tspan');
        for (let i = 0; i < tspanElementList.length; i++)
            tspanElementList[i].style.whiteSpace = "pre";

    }

};

_ = SVGGraphicsElement.prototype;

_.prepareToNormalizeScale = function (_options) {
    this.normalizationData = {};
    this.normalizationData.storedScreenMatrix = this.getScreenCTM();
    this.normalizationData.localRotation = this.getTransform().matrix.getRotation(); // salvo la rotazione

    const max = this.childNodes.length;
    for (let i = 0; i < max; i++) {
        if (this.childNodes[i].prepareToNormalizeScale)
            this.childNodes[i].prepareToNormalizeScale(_options);
    }
};

// un generico elemento grafico
_.normalizeScale = function (_options) {
    const newLocalMatrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
    this.getTransform().setMatrix(newLocalMatrix);
    const max = this.childNodes.length;
    for (let i = 0; i < max; i++)
        if (this.childNodes[i].normalizeScale)
            this.childNodes[i].normalizeScale(_options);
};

_.normalizeFillingScale = function (_graphicSide, _options) {
    if (!this.hasAttribute(_graphicSide))
        return null;

    const fillingValue = this.getAttribute(_graphicSide);
    if (fillingValue.indexOf('url') > -1) {
        const defElement = activeApplication.activeDocument.resources.getResourceByIRI(fillingValue);

        if (defElement.nodeName === 'radialGradient' || defElement.nodeName === 'linearGradient') {
            this.normalizeGradientScale(defElement, _options);
        } else if (defElement.nodeName === 'pattern') {
            this.normalizePatternScale(defElement, _options);
        }
    }
};

_.normalizePatternScale = function (_pattern, _options) {};

_.normalizeGradientScale = function (_gradient, _options) {
    let localMatrix,
    pt,
    pt1,
    pt2;

    const gradientUnits = _gradient.getAttribute('gradientUnits') || 'objectBoundingBox';

    if (gradientUnits === 'objectBoundingBox')
        return;

    if (_gradient instanceof SVGRadialGradientElement) {
        pt = this.ownerSVGElement.createSVGPoint(_gradient.cx.baseVal.value, _gradient.cy.baseVal.value);
        const gradientMatrix = _gradient.getTransform().matrix;
        pt = pt.matrixTransform(gradientMatrix);
        _gradient.getTransform().matrix.identity();

        localMatrix = this.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
        pt = pt.matrixTransform(localMatrix);

        _gradient.cx.baseVal.value = pt.x;
        _gradient.cy.baseVal.value = pt.y;
        _gradient.r.baseVal.value = _gradient.r.baseVal.value * _options.effectScale;

    } else if (_gradient instanceof SVGLinearGradientElement) {

        pt1 = this.ownerSVGElement.createSVGPoint(_gradient.x1.baseVal.value, _gradient.y1.baseVal.value);
        pt2 = this.ownerSVGElement.createSVGPoint(_gradient.x2.baseVal.value, _gradient.y2.baseVal.value);

        const gradientMatrix = _gradient.getTransform().matrix;
        pt1 = pt1.matrixTransform(gradientMatrix);
        pt2 = pt2.matrixTransform(gradientMatrix);
        _gradient.getTransform().matrix.identity();

        localMatrix = this.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
        pt1 = pt1.matrixTransform(localMatrix);
        pt2 = pt2.matrixTransform(localMatrix);

        _gradient.x1.baseVal.value = pt1.x;
        _gradient.y1.baseVal.value = pt1.y;
        _gradient.x2.baseVal.value = pt2.x;
        _gradient.y2.baseVal.value = pt2.y;
    }

};

_.createSelectionPreview = function (_matrix) {
    if (this.hasAttribute('no-preview'))
        return;
    const selectionPreview = this.toSelectionPreview();
    if (!selectionPreview) {
        console.log('NO createSelectionPreview', this.nodeName);
        return null;
    }
    selectionPreview.elementRef = this;
    selectionPreview.classList.add('interactive-path');
    selectionPreview.setAttribute('vector-effect', "non-scaling-stroke");
    selectionPreview.setAttribute('stroke-width', "1");
    _matrix = _matrix || this.getScreenCTM();
    selectionPreview.getTransform().setMatrix(_matrix);

    this.selectionPreview = selectionPreview;
    return selectionPreview;
};

_.toSelectionPreview = function () {
    if (!this.getBBox)
        return null;
    const bbox = this.getLocalBBox();
    const rect = SVGUtils.createRect(bbox.x, bbox.y, bbox.width, bbox.height);
    if (this.dataset.mantainAspectRatio === 'true')
        rect.dataset.mantainAspectRatio = 'true';
    return rect;
};

_.scaleStrokeAndEffects = function (_strokeScale) {
    if (!this.hasAttribute('stroke-width'))
        this.setAttribute('stroke-width', 1);

    this.scaleAttributeNumber('stroke-width', _strokeScale);

    const strokeDashArray = this.getAttribute('stroke-dasharray');
    if (strokeDashArray) {
        const values = strokeDashArray.split(' ');
        const max = values.length;
        for (let i = 0; i < max; i++) {
            values[i] = parseFloat(values[i]) * _strokeScale;
        }
        this.setAttribute('stroke-dasharray', values.join(' '));
    }
    const strokeDashOffset = this.getAttribute('stroke-dash-offset');

    if (strokeDashOffset) {
        this.scaleAttributeNumber('stroke-dash-offset', _strokeScale);
    }
};

_.setGraphicAttributesByElement = function (_element, _validAttributeList) {
    const validAttributeList = _validAttributeList || ['opacity', 'fill', 'stroke', 'fill-opacity', 'stroke-opacity', 'fill-rule', 'vector-effect', 'paint-order', 'stroke-width', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'marker-start', 'marker-end', 'marker-mid'];
    const copiedAttributeList = [];
    let attributeName;
    const max = validAttributeList.length;
    for (let i = 0; i < max; i++) {
        attributeName = validAttributeList[i];
        if (_element.hasAttribute(attributeName)) {
            this.setAttribute(attributeName, _element.getAttribute(attributeName));
            copiedAttributeList.push(attributeName);
        }
    }

    return copiedAttributeList;
};

_.setGraphicAttributesByObjectProperties = function (_objectPropertieValues) {
    const copiedAttributeList = [];

    const validAttributes = ['opacity', 'fill', 'stroke', 'fill-opacity', 'stroke-opacity', 'fill-rule', 'vector-effect', 'paint-order', 'stroke-width', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'marker-start', 'marker-end', 'marker-mid'];

    for (let propertyName in _objectPropertieValues) {
        if (validAttributes.indexOf(propertyName) > -1) {
            this.setAttribute(propertyName, _objectPropertieValues[propertyName]);
            copiedAttributeList.push(propertyName);
        }
    }

    return copiedAttributeList;
};

_.getFill = function () {
    if (!this.hasAttribute('fill'))
        return this.parentElement.getFill();
    return this.getAttribute('fill');
};

_.getStroke = function () {
    if (!this.hasAttribute('stroke'))
        return this.parentElement.getStroke();
    return this.getAttribute('stroke');
};

/*
_ = SVGElement.prototype;

// FIX CHROME 48
if( _.getTransformToElement === undefined ) { _.getTransformToElement = function( _element ) {return _element.getScreenCTM().inverse().multiply(  this.getScreenCTM()  );};}


// usato per trasformare una qualsiasi matrice globale in una locale all'elemento this
_.globalMatrixToLocalMatrix = function( _globalMatrix ){
let validParentNode = this.parentNode;
if(validParentNode instanceof SVGMaskElement) validParentNode = validParentNode.parentNode;
const invertedParentGlobalMatrix  = this.ownerSVGElement.getTransformToElement(validParentNode);
return invertedParentGlobalMatrix.multiply(  _globalMatrix  );
};

_.getTransform = function(){
if(this.transform.baseVal.numberOfItems===0){
let newTransform = SVGUtils.createSVGTransformFromMatrix( SVGUtils.createSVGMatrix() );
this.transform.baseVal.appendItem(newTransform);
}

return this.transform.baseVal.getItem(0);
};


_.getLayerOwner = function () {
return this.closest('.layer');
};
 */

_ = SVGElement.prototype;

_.__setAttribute = _.setAttribute;
_.__getAttribute = _.getAttribute;

_.setAttribute = function (_attributeName, _attributeValue) {
    this.onSetAttribute(_attributeName, _attributeValue);
};

_.onSetAttribute = function (_attributeName, _attributeValue) {
    this.__setAttribute(_attributeName, _attributeValue);
};

_.getAttribute = function (_attributeName) {
    return this.onGetAttribute(_attributeName);
};

_.onGetAttribute = function (_attributeName) {
    return this.__getAttribute(_attributeName);
};

_.placeAt = function (_x, _y) {
    this.setAttribute('transform', 'matrix(1 0 0 1 ' + _x + ' ' + _y + ')');
};

_.getTransform = function () {
    if (this.transform.baseVal.numberOfItems === 0) {
        let newTransform = SVGUtils.createSVGTransformFromMatrix(SVGUtils.createSVGMatrix());
        this.transform.baseVal.appendItem(newTransform);
    }

    return this.transform.baseVal.getItem(0);
};

_.setOrigin = function (_workspaceX, _workspaceY) {};

_.resetOrigin = function () {
    // non fare nulla
};

_.bakeTransform = function () {};

// FIX CHROME 48
if (_.getTransformToElement === undefined) {
    _.getTransformToElement = function (_element) {
        return _element.getScreenCTM().inverse().multiply(this.getScreenCTM());
    };
}

// DEFAULT intersectGlobalRect
// _.intersectGlobalRect = function ( _globalRect )
// {
//     const bbox = this.getGlobalBBox();
//     return !(bbox.left > _globalRect.right || bbox.right < _globalRect.left || bbox.top > _globalRect.bottom || bbox.bottom < _globalRect.top);
// };

_.intersectGlobalRect = function (_globalRect) {
    if (this.isContainedInGlobalRect(_globalRect))
        return true;

    const localPolygon = this.globalRectToLocalPolygon(_globalRect);

    // per utilità creo questi punti che mi saranno utili per la costruzione delle linee usate per il successivo hit test poligono con lati del bbox locale
    const min = {},
    max = {};
    const bbox = this.getBBox();
    //
    min.x = bbox.x;
    min.y = bbox.y;
    max.x = bbox.x + bbox.width;
    max.y = bbox.y + bbox.height;
    //console.log('bbox' , bbox );
    // min.x = this.x.baseVal.value ;
    // min.y = this.y.baseVal.value ;
    // max.x = min.x + this.width.baseVal.value ;
    // max.y = min.y + this.height.baseVal.value ;


    var result;
    result = GeometryUtils.getPolygonLineIntersection(localPolygon, {
        x: min.x,
        y: min.y
    }, {
        x: max.x,
        y: min.y
    }); // la linea up
    if (result)
        return true;
    result = GeometryUtils.getPolygonLineIntersection(localPolygon, {
        x: max.x,
        y: min.y
    }, {
        x: max.x,
        y: max.y
    }); // la linea right
    if (result)
        return true;
    result = GeometryUtils.getPolygonLineIntersection(localPolygon, {
        x: max.x,
        y: max.y
    }, {
        x: min.x,
        y: max.y
    }); // la linea bottom
    if (result)
        return true;
    result = GeometryUtils.getPolygonLineIntersection(localPolygon, {
        x: min.x,
        y: max.y
    }, {
        x: min.x,
        y: min.y
    }); // la linea left
    if (result)
        return true;

    return false;
};

// usato per trasformare una qualsiasi matrice globale in una locale all'elemento this
_.globalMatrixToLocalMatrix = function (_globalMatrix) {
    let validParentNode = this.parentNode;
    if (validParentNode instanceof SVGMaskElement)
        validParentNode = validParentNode.parentNode;
    const invertedParentGlobalMatrix = this.ownerSVGElement.getTransformToElement(validParentNode);
    return invertedParentGlobalMatrix.multiply(_globalMatrix);
};

_.screenMatrixToLocalMatrix = function (_screenMatrix) {
    return this.getScreenCTM().inverse().multiply(_screenMatrix);
};

_.globalToLocal = function (_x, _y) {
    if (!this.ownerSVGElement)
        return {
            x: _x,
            y: _y
        };
    const globalPoint = this.ownerSVGElement.createSVGPoint(_x, _y);
    const mat = this.ownerSVGElement.getTransformToElement(this);
    return globalPoint.matrixTransform(mat);
};

_.localToGlobal = function (_x, _y) {
    const localPoint = this.ownerSVGElement.createSVGPoint();
    localPoint.x = _x;
    localPoint.y = _y;
    return localPoint.matrixTransform(this.getCTM());
};

_.localToScreen = function (_x, _y) {
    const localPoint = this.ownerSVGElement.createSVGPoint();
    localPoint.x = _x;
    localPoint.y = _y;
    return localPoint.matrixTransform(this.getScreenCTM());
};

_.translateInGlobal = function (_globalX, _globalY) {
    const matrix = this.ownerSVGElement.createSVGMatrix().translate(_globalX, _globalY).multiply(this.getCTM());
    this.getTransform().setMatrix(this.globalMatrixToLocalMatrix(matrix));
};

_.scaleAttributeNumber = function (_attributeName, _scale) {
    if (this.hasAttribute(_attributeName))
        this.setAttribute(_attributeName, parseFloat(this.getAttribute(_attributeName)) * _scale);
};

_.getGradient = function (_graphicSide) /* _graphicSide = fill or stroke */
{
    if (!this.hasAttribute(_graphicSide))
        return null;

    const attributeValue = this.getAttribute(_graphicSide);
    const node = this.getElementFromDocumentByIRI(attributeValue);
    if (node) {
        if ((node instanceof SVGLinearGradientElement) || (node instanceof SVGRadialGradientElement))
            return node;
    }

    return null;
};

_.getElementFromDocumentByIRI = function (_idAttributeValue) {
    if (_idAttributeValue.indexOf('url') !== -1) {
        let id = _idAttributeValue.split('#')[1].split(')')[0];
        id = id.split('"')[0]; // elimino l'eventuale doppio apice finale
        const node = document.querySelector('[id="' + id + '"]');
        if (node)
            return node;
    }
    return null;
};

_.getMainElement = function () {
    let mainElement = this;

    if (mainElement instanceof SVGTSpanElement)
        mainElement = mainElement.parentElement;

    if (mainElement instanceof SVGTextPathElement)
        mainElement = mainElement.parentElement;

    const parentObject = this.closest('[data-type="object"]');

    if (parentObject) {
        return parentObject;
    }

    // if( _element.nodeName == 'DIV' )
    // {
    //     var foreignObjectElement =  _element.getParentElementByNodeName('foreignObject');
    //     if(foreignObjectElement)  mainElement = foreignObjectElement ;
    // }

    return mainElement;
};

_.getLayerOwner = function () {
    return this.closest('.layer');
};

_.isSelected = function () {
    return this.hasAttribute('selected');
};

_.isLocked = function () {
    return this.hasAttribute('locked');
};

_.isContainedInGlobalRect = function (_globalRect) {
    const bbox = this.getGlobalBBox();
    return (bbox.left > _globalRect.left) && (bbox.right < _globalRect.right) && (bbox.top > _globalRect.top) && (bbox.bottom < _globalRect.bottom);
};

_.globalRectToLocalPolygon = function (_globalRect) {
    const mat = this.ownerSVGElement.getTransformToElement(this);
    const localPoint = this.ownerSVGElement.createSVGPoint();

    localPoint.x = _globalRect.x;
    localPoint.y = _globalRect.y;
    const pt1 = localPoint.matrixTransform(mat);

    localPoint.x = _globalRect.x + _globalRect.width;
    localPoint.y = _globalRect.y;
    const pt2 = localPoint.matrixTransform(mat);

    localPoint.x = _globalRect.x + _globalRect.width;
    localPoint.y = _globalRect.y + _globalRect.height;
    const pt3 = localPoint.matrixTransform(mat);

    localPoint.x = _globalRect.x;
    localPoint.y = _globalRect.y + _globalRect.height;
    const pt4 = localPoint.matrixTransform(mat);

    // creo il poligono con il risultato dei punti
    return [pt1, pt2, pt3, pt4, pt1];
};

_.getLocalBBox = function () {
    const bbox = this.getBBox();
    bbox.center = {
        x: bbox.x + (bbox.width / 2),
        y: bbox.y + (bbox.height / 2)
    };
    bbox.min = {
        x: bbox.x,
        y: bbox.y
    };
    bbox.max = {
        x: bbox.x + bbox.width,
        y: bbox.y + bbox.height
    };
    return bbox;
};

_.getGlobalBBox = function () {
    const bbox = this.getBoundingClientRect();
    const bbox2 = {};
    bbox2.y = bbox2.top = bbox.top - activeApplication.workspace.bounding.y;
    bbox2.x = bbox2.left = bbox.left - activeApplication.workspace.bounding.x;
    bbox2.width = bbox.width;
    bbox2.height = bbox.height;
    bbox2.min = {
        x: bbox2.x,
        y: bbox2.y
    };
    bbox2.max = {
        x: bbox2.x + bbox2.width,
        y: bbox2.y + bbox2.height
    };
    bbox2.center = {
        x: bbox2.x + (bbox2.width / 2),
        y: bbox2.y + (bbox2.height / 2)
    };
    bbox2.right = bbox2.max.x;
    bbox2.bottom = bbox2.max.y;
    return bbox2;
};

_.getGlobalBBoxByLocalBox = function () {
    const mat = this.getCTM();
    const localPoint = this.ownerSVGElement.createSVGPoint();

    const bbox = this.getLocalBBox();

    localPoint.x = bbox.x;
    localPoint.y = bbox.y;
    const pt1 = localPoint.matrixTransform(mat);

    localPoint.x = bbox.x + bbox.width;
    localPoint.y = bbox.y;
    const pt2 = localPoint.matrixTransform(mat);

    localPoint.x = bbox.x + bbox.width;
    localPoint.y = bbox.y + bbox.height;
    const pt3 = localPoint.matrixTransform(mat);

    localPoint.x = bbox.x;
    localPoint.y = bbox.y + bbox.height;
    const pt4 = localPoint.matrixTransform(mat);

    const xMin = Math.min(pt1.x, pt2.x, pt3.x, pt4.x);
    const xMax = Math.max(pt1.x, pt2.x, pt3.x, pt4.x);
    const yMin = Math.min(pt1.y, pt2.y, pt3.y, pt4.y);
    const yMax = Math.max(pt1.y, pt2.y, pt3.y, pt4.y);

    bbox.min = {
        x: xMin,
        y: yMin
    };
    bbox.max = {
        x: xMax,
        y: yMax
    };

    bbox.x = xMin;
    bbox.y = yMin;
    bbox.width = xMax - xMin;
    bbox.height = yMax - yMin;

    bbox.left = xMin;
    bbox.right = xMax;
    bbox.top = yMin;
    bbox.bottom = yMax;

    bbox.center = {
        x: bbox.x + (bbox.width / 2),
        y: bbox.y + (bbox.height / 2)
    };

    return bbox;
};

/*_.getSnapPointList = function( _enableCenterSnap ){
const bbox = this.getBBox();
const min={};
const max={};
const center={};
min.x =  bbox.x;
min.y =  bbox.y;
max.x = bbox.x+bbox.width;
max.y =  bbox.y+bbox.height;
center.x= min.x+bbox.width/2;
center.y= min.y+bbox.height/2;

const pointList =[];

function createSnapPoint(_x,_y,_name){
const pt = SVGUtils.createSVGPoint( _x, _y );
pt.name = _name;
pointList.push(pt);
}

createSnapPoint( 0, 0 , 'origin') ; // l'origine
createSnapPoint( min.x, min.y, 'top-left') ;
createSnapPoint( max.x, min.y, 'top-right') ;
createSnapPoint( max.x, max.y, 'bottom-right') ;
createSnapPoint( min.x, max.y, 'bottom-left') ;

if(_enableCenterSnap){
createSnapPoint( center.x, min.y, 'top-center') ;
createSnapPoint( max.x, center.y, 'right-center') ;
createSnapPoint( center.x, max.y, 'bottom-center') ;
createSnapPoint( min.x, center.y, 'left-center') ;
createSnapPoint( center.x, center.y, 'center') ;
}


return pointList;
};*/

// _.isLinearElement = function()
// {
//     return false;
// }

// per default
_.getEditableGeometryPointList = function () {
    return [];
};

// per default
_.getGeometryPointList = function () {
    return [];
};

/*_.hitTestSegmentAtPoint = function(_workspaceX , _workspaceY , _snapDistance ){
return this.findLinearSegmentAtPoint( _workspaceX , _workspaceY , _snapDistance  );
};

_.findLinearSegmentAtPoint = function( _workspaceX , _workspaceY , _snapDistance ){
const localPoint = this.globalToLocal( _workspaceX , _workspaceY );

// per utilità creo questi punti che mi saranno utili per la costruzione delle linee usate per il successivo hit test poligono con lati del bbox locale
const bbox = this.getBBox();
const min={};
const max={};
min.x =  bbox.x;
min.y =  bbox.y;
max.x = bbox.x+bbox.width;
max.y =  bbox.y+bbox.height;

let pointOnLine;

pointOnLine = GeometryUtils.isPointOnLine( {x:min.x , y:min.y}, {x:max.x , y:min.y} , localPoint , _snapDistance  );// la linea up
if(pointOnLine) return {element:this, point:pointOnLine, idSegment:0, pt1: SVGUtils.createSVGPoint(min.x,min.y), pt2:SVGUtils.createSVGPoint(max.x,min.y) , name:this.nodeName+' top'} ;

pointOnLine = GeometryUtils.isPointOnLine( {x:max.x , y:min.y}, {x:max.x , y:max.y} , localPoint , _snapDistance  );// la linea right
if(pointOnLine) return{element:this, point:pointOnLine, idSegment:1, pt1: SVGUtils.createSVGPoint(max.x,min.y), pt2:SVGUtils.createSVGPoint(max.x,max.y) , name:this.nodeName+' right'} ;

pointOnLine = GeometryUtils.isPointOnLine( {x:max.x , y:max.y}, {x:min.x , y:max.y} , localPoint , _snapDistance  );// la linea bottom
if(pointOnLine) return{element:this, point:pointOnLine, idSegment:2, pt1: SVGUtils.createSVGPoint(max.x,max.y), pt2:SVGUtils.createSVGPoint(min.x,max.y), name:this.nodeName+' bottom'} ;

pointOnLine = GeometryUtils.isPointOnLine( {x:min.x , y:max.y} , {x:min.x , y:min.y} , localPoint , _snapDistance  );// la linea left
if(pointOnLine) return{element:this, point:pointOnLine, idSegment:3, pt1: SVGUtils.createSVGPoint(min.x,max.y), pt2:SVGUtils.createSVGPoint(min.x,min.y), name:this.nodeName+' left'} ;

return null;
};*/

_.getSelectedTransformablePointList = function () {

    const pointListToTransform = [];
    const geometryPointList = this.getGeometryPointList();
    for (let i = 0; i < geometryPointList.length; i++) {
        if (geometryPointList[i].isSelected)
            pointListToTransform.push(geometryPointList[i]);
    }
    return pointListToTransform;
};

// _.findSnapToPoint = function( _workspaceX , _workspaceY , _snapDistance , _enableCenterSnap )
// {
//     const localPoint = this.globalToLocal( _workspaceX , _workspaceY );
//     const geometryPointList = this.getSnapPointList( _enableCenterSnap );
//     let currentPoint;
//     const max = geometryPointList.length;
//     for( let i=0; i<max; i++)
//     {
//         currentPoint = geometryPointList[i];
//
//         if( (currentPoint.x > (localPoint.x -_snapDistance)) && (currentPoint.x < (localPoint.x + _snapDistance)) )
//         {
//             if( (currentPoint.y > (localPoint.y -_snapDistance)) && (currentPoint.y < (localPoint.y + _snapDistance)) )
//             {
//                 currentPoint.idSegment = i;
//                 return currentPoint;
//             }
//         }
//     }
//     return null;
// };


_.isTextAttribute = function (_attributeName) {
    const textAttributeList = ['font-family', 'text-decoration', 'font-style', 'text-align', 'font-weight', 'font-size', 'letter-spacing', 'word-spacing', 'line-height'];
    return textAttributeList.indexOf(_attributeName) > -1;
};

_.isGraphicAttribute = function (_attributeName) {
    const textAttributeList = ['opacity', 'fill', 'stroke', 'fill-opacity', 'stroke-opacity', 'fill-rule', 'paint-order', 'stroke-width', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'marker-start', 'marker-end', 'marker-mid'];
    return textAttributeList.indexOf(_attributeName) > -1;
};

_.stylePropertiesToAttributes = function (_styleProperties) {
    let newStyleAsString = '';

    const properties = _styleProperties || this.style;
    if (properties.opacity) {
        this.__setAttribute('opacity', properties.opacity);
        this.style.removeProperty('opacity');
    }
    if (properties.fill) {
        this.__setAttribute('fill', properties.fill);
        this.style.removeProperty('fill');
    }
    if (properties.stroke) {
        this.__setAttribute('stroke', properties.stroke);
        this.style.removeProperty('stroke');
    }

    if (properties.fillOpacity) {
        if (properties.fillOpacity !== "1")
            this.__setAttribute('fill-opacity', properties.fillOpacity);
        this.style.removeProperty('fill-opacity');
    }

    if (properties.strokeOpacity) {
        if (properties.strokeOpacity !== "1")
            this.__setAttribute('stroke-opacity', properties.strokeOpacity);
        this.style.removeProperty('stroke-opacity');
    }

    if (properties.fillRule) {
        if (properties.fillRule !== "nonzero")
            this.__setAttribute('fill-rule', properties.fillRule);
        this.style.removeProperty('fill-rule');
    }

    if (properties['stroke-width']) {
        this.__setAttribute('stroke-width', properties['stroke-width']);
        this.style.removeProperty('stroke-width');
    }
    if (properties['stroke-linecap']) {
        this.__setAttribute('stroke-linecap', properties['stroke-linecap']);
        this.style.removeProperty('stroke-linecap');
    }
    if (properties['stroke-linejoin']) {
        this.__setAttribute('stroke-linejoin', properties['stroke-linejoin']);
        this.style.removeProperty('stroke-linejoin');
    }
    if (properties['stroke-miterlimit']) {
        this.__setAttribute('stroke-miterlimit', properties['stroke-miterlimit']);
        this.style.removeProperty('stroke-miterlimit');
    }
    if (properties['marker-start']) {
        if (properties['marker-start'] !== 'none')
            this.__setAttribute('marker-start', properties['marker-start']);
        this.style.removeProperty('marker-start');
    }
    if (properties['marker-end']) {
        if (properties['marker-end'] !== 'none')
            this.__setAttribute('marker-end', properties['marker-end']);
        this.style.removeProperty('marker-end');
    }
    if (properties['marker-mid']) {
        if (properties['marker-mid'] !== 'none')
            this.__setAttribute('marker-mid', properties['marker-mid']);
        this.style.removeProperty('marker-mid');
    }

    if (properties['font-family']) {
        this.__setAttribute('font-family', properties['font-family'].replace(/"/g, ''));
        this.style.removeProperty('font-family');
    }

    if (properties['font-weight']) {
        this.__setAttribute('font-weight', properties['font-weight']);
        this.style.removeProperty('font-weight');
    }

    if (properties['font-size']) {
        this.__setAttribute('font-size', parseFloat(properties['font-size']));
        this.style.removeProperty('font-size');
    }

    if (properties['filter']) {
        this.__setAttribute('filter', properties['filter'].replace(/"/g, ''));
        this.style.removeProperty('filter');
    }

    if (properties['mix-blend-mode']) {
        newStyleAsString += 'mix-blend-mode:' + properties['mix-blend-mode'] + '; ';
    }

    this.setAttribute('style', newStyleAsString)

};

_.render = function () {
    this.waitForRendering = false;
};

_.renderRequest = function (_timeout, _callback) {
    // forzato il ridisegneo da qualche  funzione
    if (_timeout === 0) {
        this.render();
    } else if (this.waitForRendering !== true) {
        _timeout = _timeout || 0;
        this.waitForRendering = true;
        const self = this;
        setTimeout(function () {
            // se non è stato forzato il ridisegneo da qualche altra funzione durante l'attesa
            if (self.waitForRendering === true) {
                self.render();
                if (_callback)
                    _callback(self);
            }
        }, _timeout);
    }
};

// _.storeJsonData = function( _dataType, jsonData )
// {
//     let jvsDataNode = this.querySelector('[data-type="'+_dataType+'"]')
//     if(jvsDataNode)
//     {
//        //console.log('jvsDataNode.innerText before',jvsDataNode.innerText)
//         jvsDataNode.innerText = JSON.stringify(jsonData);
//        //console.log('jvsDataNode.innerText after',jvsDataNode.innerText)
//         return jvsDataNode;
//     }
//
//
//     // data node
//     jvsDataNode = document.createElement( 'jvs:data' );
//     jvsDataNode.setAttribute('xmlns:jvs', 'http://www.janvas.com/jvs');
//     jvsDataNode.setAttribute( 'data-type', _dataType );
//     jvsDataNode.innerText = JSON.stringify(jsonData);
//     console.log('jvsDataNode',jvsDataNode)
//     this.appendChild(jvsDataNode);
//     return jvsDataNode;
// };
//
// _.getStoredJsonData = function( _dataType )
// {
//     const jvsDataNode = this.querySelector('[data-type="'+_dataType+'"]');
//
//     if(!jvsDataNode)
//     {
//         console.log('node data not found' , _dataType );
//         return null;
//     }
//     return JSON.parse(jvsDataNode.textContent);
// };


_.storeJsonData = function (_dataType, jsonData) {
    let jvsDataNode = this.querySelector('[data-type="' + _dataType + '"]')
        if (jvsDataNode) {
            jvsDataNode.innerHTML = JSON.stringify(jsonData);
            return jvsDataNode;
        }

        // data node
        jvsDataNode = document.createElement('jvs:data');
    jvsDataNode.setAttribute('xmlns:jvs', 'http://www.janvas.com/jvs');
    jvsDataNode.setAttribute('data-type', _dataType);
    jvsDataNode.innerHTML = JSON.stringify(jsonData);
    this.appendChild(jvsDataNode);
    return jvsDataNode;
};

_.getStoredJsonData = function (_dataType) {
    const jvsDataNode = this.querySelector('[data-type="' + _dataType + '"]');

    if (!jvsDataNode) {
        console.log('stored jsonData not found', _dataType);
        return null;
    }
    return JSON.parse(jvsDataNode.innerHTML);
};

_.getObjectController = function () {
    const controller = OBJECTS[this.dataset.objectId];
    controller.init(this);
    return controller;
};

_ = SVGLineElement.prototype;

_.resetOrigin = function () {
    const bbox = this.getGlobalBBox();
    const centerInParent = this.parentElement.globalToLocal(bbox.center.x, bbox.center.y);
    const group = SVGUtils.createGroup(centerInParent.x, centerInParent.y);
    this.parentElement.appendChild(group);
    this.transformGeometryPointList(this.getTransformToElement(group));
    this.getTransform().setMatrix(group.getTransform().matrix.clone());
    this.render();
    group.remove();
};

_.normalizeScale = function (_options) {
    const matrixInParent = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);

    if (this.getAttribute('vector-effect') !== "non-scaling-stroke") {
        if (_options.scaleStrokeAndEffects) {
            this.scaleStrokeAndEffects(_options.effectScale);
        }
    }

    this.getTransform().setMatrix(this.getTransform().matrix.identity().translate(matrixInParent.e, matrixInParent.f).rotate(this.normalizationData.localRotation));

    //this.transformGeometryPointList( this.screenMatrixToLocalMatrix(  this.normalizationData.storedScreenMatrix  ) );


    //var pointList = this.getGeometryPointList();

    const localMatrix = this.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
    localMatrix.transformPointList(this.getGeometryPointList());

    this.geometryPointList[0].ownerShapeElement = this;
    this.geometryPointList[1].ownerShapeElement = this;
    this.geometryPointList[0].id = 0;
    this.geometryPointList[1].id = 1;

    // var pt1,pt2;
    //
    // pt1 = pointList[0].matrixTransform( this.normalizationData.storedGlobalMatrix );
    // pt2 = pointList[1].matrixTransform( this.normalizationData.storedGlobalMatrix );

    // var originPosition =  this.parentNode.globalToLocal( this.normalizationData.storedGlobalMatrix.e ,   this.normalizationData.storedGlobalMatrix.f );
    // var rotationMatrix = this.getTransform().matrix.identity().rotate( this.normalizationData.localRotation );
    // this.getTransform().setMatrix( this.ownerSVGElement.createSVGMatrix().translate( originPosition.x, originPosition.y ).multiply( rotationMatrix ) );

    // pt1 = this.globalToLocal( pt1.x , pt1.y );
    // pt2 = this.globalToLocal( pt2.x , pt2.y );
    //
    // pointList[0].set( pt1.x , pt1.y );
    // pointList[1].set( pt2.x , pt2.y );

    this.render();

    if (_options.scaleStrokeAndEffects) {

        //this.scaleStrokeAndEffects(strokeScale);
        this.normalizeFillingScale('stroke', _options);
    }

    // var gradient = this.getGradient('stroke');
    // if(gradient)this.normalizeGradientScale(gradient , _options );

};

// LINE intersectGlobalRect
_.intersectGlobalRect = function (_globalRect) {
    if (this.isContainedInGlobalRect(_globalRect))
        return true;

    var localPolygon = this.globalRectToLocalPolygon(_globalRect);
    return GeometryUtils.getPolygonLineIntersection(localPolygon, {
        x: this.x1.baseVal.value,
        y: this.y1.baseVal.value
    }, {
        x: this.x2.baseVal.value,
        y: this.y2.baseVal.value
    }, true);
};

Object.defineProperty(_, "width", {
    get: function () {
        var pt1 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x1'), this.getAttribute('y1'));
        var pt2 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x2'), this.getAttribute('y2'));
        return pt2.getDistanceFromPoint(pt1);
    },
    set: function (_value) {
        var pt1 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x1'), this.getAttribute('y1'));
        var pt2 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x2'), this.getAttribute('y2'));
        var scale = _value / pt2.getDistanceFromPoint(pt1);
        pt2.x = pt1.x + ((pt2.x - pt1.x) * scale);
        pt2.y = pt1.y + ((pt2.y - pt1.y) * scale);
        this.setAttribute('x2', pt2.x);
        this.setAttribute('y2', pt2.y);
    },
    enumerable: true
});

Object.defineProperty(_, "orientation", {
    get: function () {
        var pt1 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x1'), this.getAttribute('y1'));
        var pt2 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x2'), this.getAttribute('y2'));
        return pt1.getAngleFromPoint(pt2, true);
    },
    set: function (_value) {
        var pt1 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x1'), this.getAttribute('y1'));
        var pt2 = this.ownerSVGElement.createSVGPoint(this.getAttribute('x2'), this.getAttribute('y2'));
        var distance = pt2.getDistanceFromPoint(pt1);
        pt2 = this.ownerSVGElement.createSVGPointPolar(distance, _value * (Math.PI / 180));
        this.setAttribute('x2', pt1.x + pt2.x);
        this.setAttribute('y2', pt1.y + pt2.y);
    },
    enumerable: true
});

_.toSVGPathElement = function () {
    var newPath = this.ownerSVGElement.createPath();
    newPath.setPathData(this.getPathData({
            normalize: true
        }));
    return newPath;
};

_.updateGeometry = function (x1, y1, x2, y2) {
    this.x1.baseVal.value = x1;
    this.y1.baseVal.value = y1;
    this.x2.baseVal.value = x2;
    this.y2.baseVal.value = y2;
    this.geometryPointList = null;
};

_.getPt1 = function () {
    //return{x:this.x1.baseVal.value,y:this.y1.baseVal.value};
    return SVGUtils.createSVGPoint(this.x1.baseVal.value, this.y1.baseVal.value);
};

_.getPt2 = function () {
    //return{x:this.x2.baseVal.value,y:this.y2.baseVal.value};
    return SVGUtils.createSVGPoint(this.x2.baseVal.value, this.y2.baseVal.value);
};

// _.getSnapPointList = function( )
// {
// 	return this.getGeometryPointList();
// };


// _.isLinearElement = function()
// {
// 	return true;
// }

// per default
_.getEditableGeometryPointList = function () {
    return this.getGeometryPointList();
};

_.getGeometryPointList = function () {
    //console.log('line getGeometryPointList', this.geometryPointList);

    if (!this.geometryPointList) {
        //console.log('creo getGeometryPointList', this.geometryPointList);

        this.geometryPointList = [];
        this.geometryPointList.push(SVGUtils.createSVGPoint(this.x1.baseVal.value, this.y1.baseVal.value));
        this.geometryPointList.push(SVGUtils.createSVGPoint(this.x2.baseVal.value, this.y2.baseVal.value));
        this.geometryPointList[0].ownerShapeElement = this;
        this.geometryPointList[1].ownerShapeElement = this;
        this.geometryPointList[0].id = 0;
        this.geometryPointList[1].id = 1;
        this.geometryPointList[0].name = 'start';
        this.geometryPointList[1].name = 'end';
    }
    return this.geometryPointList;
};

_.setGeometryPointList = function (_geometryPointList) {
    this.geometryPointList = _geometryPointList;
    this.geometryPointList[0].ownerShapeElement = this;
    this.geometryPointList[1].ownerShapeElement = this;
    this.geometryPointList[0].id = 0;
    this.geometryPointList[1].id = 1;
};

// _.findLinearSegmentAtPoint = function( _workspaceX , _workspaceY , _snapDistance  )
// {
// 	const localPoint = this.globalToLocal( _workspaceX , _workspaceY );
// 	const pt1 = this.getPt1();
// 	const pt2 = this.getPt2();
// 	const pointOnLine = GeometryUtils.isPointOnLine( pt1, pt2, localPoint, _snapDistance  );
// 	//if(pointOnLine) return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:1, pt1: pt1, pt2:pt2} };
// 	if(pointOnLine) return {element:this, point:pointOnLine, idSegment:1, pt1: pt1, pt2:pt2, name:'line' } ;
// 	return null;
// };

_.cloneGeometryPointList = function (_addSelectionState) {

    var _geometryPointList = this.getGeometryPointList();

    var clonedGeometryPointList = [];
    clonedGeometryPointList.push(SVGUtils.createSVGPoint(_geometryPointList[0].x, _geometryPointList[0].y));
    clonedGeometryPointList.push(SVGUtils.createSVGPoint(_geometryPointList[1].x, _geometryPointList[1].y));

    if (_addSelectionState) {
        clonedGeometryPointList[0].isSelected = _geometryPointList[0].isSelected;
        clonedGeometryPointList[1].isSelected = _geometryPointList[1].isSelected;
    }

    return clonedGeometryPointList;
};

_.transformGeometryPointList = function (_matrix, _segmentList) {
    var point,
    pointResult;
    _segmentList = _segmentList || this.getGeometryPointList();

    var i,
    max = _segmentList.length;
    for (i = 0; i < max; i++) {
        point = _segmentList[i];
        pointResult = point.matrixTransform(_matrix);
        point.x = pointResult.x;
        point.y = pointResult.y;
    }
};

// _.cloneGeometryPointList = function( _geometryPointList , _addSelectionState)
// {
//
// 	_geometryPointList = _geometryPointList || this.getGeometryPointList();
//
// 	var clonedGeometryPointList = [];
// 	clonedGeometryPointList.push( SVGUtils.createSVGPoint( _geometryPointList[0].x, _geometryPointList[0].y ) );
// 	clonedGeometryPointList.push( SVGUtils.createSVGPoint( _geometryPointList[1].x, _geometryPointList[1].y ) );
//
// 	if(_addSelectionState)
// 	{
//
// 		clonedGeometryPointList[0].isSelected =  _geometryPointList[0].isSelected;
// 		clonedGeometryPointList[1].isSelected =  _geometryPointList[1].isSelected;
// 	}
//
// 	return clonedGeometryPointList;
// };


// _.createElementPreview = function( _matrix )
// {
// 	if( this.hasAttribute('no-preview') )return;
// 	var interactiveElement = this.cloneNode();
// 	if(!interactiveElement) return null;
// 	// inserisco un riferimento alla preview ed all'elemento
// 	interactiveElement.elementRef = this;
// 	this.interactiveElement = interactiveElement;
// 	interactiveElement.classList.add('interactive-path');
// 	interactiveElement.setAttribute('vector-effect' , "non-scaling-stroke" );
//
// 	_matrix = _matrix || this.getScreenCTM();
// 	interactiveElement.getTransform().setMatrix( _matrix );
// 	return interactiveElement;
// };

_.toSelectionPreview = function () {
    return this.cloneNode();
};

/*_.getSnapPointList = function( _enableCenterSnap ){
const geometryPointList = this.getGeometryPointList();

const segment = {element:this, pt1:geometryPointList[0], pt2:geometryPointList[1] };
geometryPointList[0].segment=segment;
geometryPointList[1].segment=segment;
// const center = {snapName:'center'};
// center.x = geometryPointList[0].x + ((geometryPointList[1].x-geometryPointList[0].x)/2);
// center.y = geometryPointList[0].y + ((geometryPointList[1].y-geometryPointList[0].y)/2);
if(_enableCenterSnap){
const centerPoint = SVGUtils.createSVGPoint( geometryPointList[0].x + ((geometryPointList[1].x-geometryPointList[0].x)/2) , geometryPointList[0].y + ((geometryPointList[1].y-geometryPointList[0].y)/2) )
centerPoint.name = 'midpoint';
centerPoint.segment = segment;
return geometryPointList.concat( [centerPoint] );
}

return geometryPointList;
};*/

_.getFill = function () {
    return 'none';
};

_.render = function () {
    this.x1.baseVal.value = this.geometryPointList[0].x;
    this.y1.baseVal.value = this.geometryPointList[0].y;
    this.x2.baseVal.value = this.geometryPointList[1].x;
    this.y2.baseVal.value = this.geometryPointList[1].y;

    this.waitForRendering = false;
};

_ = SVGRectElement.prototype;

// rettangolo
_.normalizeScale = function (_options) {
    const newLocalMatrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);

    const scale = newLocalMatrix.getScale();

    if (this.getAttribute('vector-effect') !== "non-scaling-stroke") {
        if (_options.scaleStrokeAndEffects) {
            this.scaleStrokeAndEffects(_options.effectScale);
        }
    }

    this.scaleAttributeNumber('x', scale.x);
    this.scaleAttributeNumber('y', scale.y);

    this.scaleAttributeNumber('width', scale.x);
    this.scaleAttributeNumber('height', scale.y);

    this.scaleAttributeNumber('rx', scale.x);
    this.scaleAttributeNumber('ry', scale.y);

    const invertedScaledMatrix = this.ownerSVGElement.createSVGMatrix().scaleNonUniform(scale.x, scale.y).inverse();
    this.getTransform().setMatrix(newLocalMatrix.multiply(invertedScaledMatrix));

    if (_options.scaleStrokeAndEffects) {
        this.normalizeFillingScale('fill', _options);
        this.normalizeFillingScale('stroke', _options);
    }
};

_.resetOrigin = function () {
    const x = parseFloat(this.getAttribute('x')) || 0;
    const y = parseFloat(this.getAttribute('y')) || 0;
    const width = parseFloat(this.getAttribute('width'));
    const height = parseFloat(this.getAttribute('height'));
    const center = SVGUtils.createSVGPoint(x + (width / 2), y + (height / 2));
    this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x, center.y));
    this.setAttribute('x', 0 - width / 2);
    this.setAttribute('y', 0 - height / 2);
};

_.setOrigin = function (_workspaceX, _workspaceY) {
    const pt = this.globalToLocal(_workspaceX, _workspaceY);
    const center = SVGUtils.createSVGPoint(parseFloat(this.getAttribute('x')) || 0, parseFloat(this.getAttribute('y')) || 0);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(pt.x, pt.y));
    this.setAttribute('x', center.x - pt.x);
    this.setAttribute('y', center.y - pt.y);
};

_.toSVGPathElement = function () {
    const newPath = SVGUtils.createPath();
    newPath.setPathData(this.getPathData({
            normalize: true
        }));
    return newPath;
};

_.toSelectionPreview = function () {
    return this.cloneNode();
};

_.updateGeometry = function (x, y, w, h) {
    this.x.baseVal.value = x;
    this.y.baseVal.value = y;
    if (w)
        this.width.baseVal.value = w;
    if (h)
        this.height.baseVal.value = h;
};

_ = SVGEllipseElement.prototype;

// ellipse
_.normalizeScale = function (_options) {
    //var newLocalMatrix = this.globalMatrixToLocalMatrix( this.normalizationData.storedGlobalMatrix );

    var newLocalMatrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);

    var scale = newLocalMatrix.getScale();

    if (this.getAttribute('vector-effect') !== "non-scaling-stroke") {
        if (_options.scaleStrokeAndEffects) {
            this.scaleStrokeAndEffects(_options.effectScale);
        }
    }

    this.scaleAttributeNumber('cx', scale.x);
    this.scaleAttributeNumber('cy', scale.y);

    this.scaleAttributeNumber('rx', scale.x);
    this.scaleAttributeNumber('ry', scale.y);
    var invertedScaledMatrix = this.ownerSVGElement.createSVGMatrix().scaleNonUniform(scale.x, scale.y).inverse();
    this.getTransform().setMatrix(newLocalMatrix.multiply(invertedScaledMatrix));

    if (_options.scaleStrokeAndEffects) {
        this.normalizeFillingScale('fill', _options);
        this.normalizeFillingScale('stroke', _options);
    }

};

// meglio questo
_.resetOrigin = function () {
    const center = SVGUtils.createSVGPoint(this.getAttribute('cx'), this.getAttribute('cy'));
    this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x, center.y));
    this.setAttribute('cx', 0);
    this.setAttribute('cy', 0);
};

_.setOrigin = function (_workspaceX, _workspaceY) {
    const pt = this.globalToLocal(_workspaceX, _workspaceY);
    const center = SVGUtils.createSVGPoint(this.getAttribute('cx'), this.getAttribute('cy'));
    this.getTransform().setMatrix(this.getTransform().matrix.translate(pt.x, pt.y));
    this.setAttribute('cx', center.x - pt.x);
    this.setAttribute('cy', center.y - pt.y);
};

// _.resetOrigin = function()
// {
// 	const localBox = this.getLocalBBox();
// 	const center = SVGUtils.createSVGPoint(localBox.center.x, localBox.center.y);
// 	this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x,center.y));
// 	this.setAttribute('cx', 0);
// 	this.setAttribute('cy', 0);
// };


// _.getSnapPointList = function()
// {
// 	var bbox = this.getBBox();
// 	var min={},max={},center={};
// 	min.x =  bbox.x;
// 	min.y =  bbox.y;
// 	max.x = bbox.x+bbox.width;
// 	max.y =  bbox.y+bbox.height;
// 	center.x= min.x+bbox.width/2;
// 	center.y= min.y+bbox.height/2;
//
// 	//var pointList = [];
//
// 	const origin = SVGUtils.createSVGPoint(0,0);
// 	origin.snapName='origin';
// 	const pointList =[ origin ];
//
//
// 	pointList.push( SVGUtils.createSVGPoint( center.x, min.y) );
// 	pointList.push( SVGUtils.createSVGPoint( max.x, center.y) );
// 	pointList.push( SVGUtils.createSVGPoint( center.x, max.y) );
// 	pointList.push( SVGUtils.createSVGPoint( min.x, center.y) );
//
// 	pointList.push( SVGUtils.createSVGPoint( center.x, center.y) );
//
//
// 	return pointList;
// };


_.updateGeometry = function (cx, cy, rx, ry) {
    this.cx.baseVal.value = cx;
    this.cy.baseVal.value = cy;
    if (rx)
        this.rx.baseVal.value = rx;
    if (ry)
        this.ry.baseVal.value = ry;
};

_.toSVGPathElement = function () {
    var newPath = SVGUtils.createPath();
    newPath.setPathData(this.getPathData({
            normalize: true
        }));
    return newPath;
};

_.toSelectionPreview = function () {
    return this.cloneNode();
};

// import { Bezier,PolyBezier } from "../../../libs/bezier.js";
// window.Bezier = Bezier;
// window.PolyBezier = PolyBezier;

_ = SVGPathElement.prototype;

_.normalizeScale = function (_options) {
    if (this.getAttribute('vector-effect') !== "non-scaling-stroke") {
        if (_options.scaleStrokeAndEffects)
            this.scaleStrokeAndEffects(_options.effectScale);
    }

    const posInParent = SVGUtils.createSVGPoint(this.getTransform().matrix.e, this.getTransform().matrix.f);

    this.getTransform().setMatrix(this.getTransform().matrix.identity().translate(posInParent.x, posInParent.y).rotate(this.normalizationData.localRotation));

    if (this.dataset.objectId && OBJECTS[this.dataset.objectId]) {
        const matrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
        const scale = matrix.getScale();
        const objectController = this.getObjectController();
        objectController.normalizeScale(scale.x, scale.y, _options.effectScale);
    } else {
        this.transformGeometryPointList(this.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix));
        this.render();
    }

    if (_options.scaleStrokeAndEffects) {

        this.normalizeFillingScale('fill', _options);
        this.normalizeFillingScale('stroke', _options);
    }

    // if(this.dataset.objectId)
    // {
    //     const matrix = this.parentElement.screenMatrixToLocalMatrix(  this.normalizationData.storedScreenMatrix  );
    //     const objectController = OBJECTS[ this.dataset.objectId ];
    //     if( objectController )
    //     {
    //         const scale = matrix.getScale();
    //         objectController.normalizeScale( this , scale.x , scale.y , _options.effectScale );
    //     }
    // }
};

_.toSelectionPreview = function () {
    const newPath = this.toSVGPathElement();
    if (this.dataset.mantainAspectRatio === 'true')
        newPath.dataset.mantainAspectRatio = 'true';
    return newPath;
};

_.bakeTransform = function () {
    const bbox = this.getGlobalBBox();
    const centerInParent = this.parentElement.globalToLocal(bbox.center.x, bbox.center.y);
    const group = SVGUtils.createGroup(centerInParent.x, centerInParent.y);
    this.parentElement.appendChild(group);
    this.transformGeometryPointList(this.getTransformToElement(group));
    this.getTransform().setMatrix(group.getTransform().matrix.clone());
    this.render();
    group.remove();
};

_.setOrigin = function (_workspaceX, _workspaceY) {
    const pt = this.globalToLocal(_workspaceX, _workspaceY);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(pt.x, pt.y));
    this.transformGeometryPointList(SVGUtils.createSVGMatrix().translate( - (pt.x),  - (pt.y)));
    this.render();
};

_.resetOrigin = function () {
    const localBox = this.getLocalBBox();
    const center = SVGUtils.createSVGPoint(localBox.center.x, localBox.center.y);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x, center.y));
    this.transformGeometryPointList(SVGUtils.createSVGMatrix().translate( - (center.x),  - (center.y)));
    this.render();
};

_.setPivot = function (_x, _y) {};

// _.geometryPointListToTransformData = function( _geometryPointList )
// {
//     const geometryPointList = _geometryPointList || this.getGeometryPointList();
//     const transformData = { element:this, pointDataList:[] };
//
//     let point;
//     const max = geometryPointList.length;
//     for( let i = 0; i < max; i++)
//     {
//         point = geometryPointList[i];
//
//         switch (point.type)
//         {
//             case 'L': case 'M':
//             transformData.pointDataList.push( { point:point, values:{ x:point.x,y:point.y} });
//             break;
//             case 'C':
//                 transformData.pointDataList.push( { point:point, values:{ x:point.x,y:point.y} });
//                 transformData.pointDataList.push( { point:point.controlPt1, values:{ x:point.controlPt1.x,y:point.controlPt1.y} });
//                 transformData.pointDataList.push( { point:point.controlPt2, values:{ x:point.controlPt2.x,y:point.controlPt2.y} });
//                 break;
//             case 'Q':
//                 transformData.pointDataList.push( { point:point, values:{ x:point.x,y:point.y} });
//                 transformData.pointDataList.push( { point:point.controlPt1, values:{ x:point.controlPt1.x,y:point.controlPt1.y} });
//                 break;
//         }
//     }
//
//     return transformData;
// };


_.transformGeometryPointList = function (_matrix, _segmentList) {
    let point,
    controlPoint,
    pointResult;
    _segmentList = _segmentList || this.getGeometryPointList();

    let isClockwise
    if (_segmentList.length > 2) {
        isClockwise = GeometryUtils.getPolygonArea([_segmentList[0], _segmentList[1], _segmentList[2]]) > 0;
        //console.log('isClockwise',isClockwise);
    }

    const scale = _matrix.getScale();

    const max = _segmentList.length;
    for (let i = 0; i < max; i++) {
        point = _segmentList[i];

        switch (point.type) {
        case 'L':
        case 'M':
            pointResult = point.matrixTransform(_matrix);
            point.x = pointResult.x;
            point.y = pointResult.y;
            break;
        case 'C':
            pointResult = point.matrixTransform(_matrix);
            point.x = pointResult.x;
            point.y = pointResult.y;
            controlPoint = point.controlPt1;
            pointResult = controlPoint.matrixTransform(_matrix);
            controlPoint.x = pointResult.x;
            controlPoint.y = pointResult.y;
            controlPoint = point.controlPt2;
            pointResult = controlPoint.matrixTransform(_matrix);
            controlPoint.x = pointResult.x;
            controlPoint.y = pointResult.y;
            break;
        case 'Q':
            pointResult = point.matrixTransform(_matrix);
            point.x = pointResult.x;
            point.y = pointResult.y;
            controlPoint = point.controlPt1;
            pointResult = controlPoint.matrixTransform(_matrix);
            controlPoint.x = pointResult.x;
            controlPoint.y = pointResult.y;
            break;
        case 'A':
            // se di tratta di una scalatura
            if (scale.x !== 1 || scale.y !== 1) {
                point.rx *= scale.x;
                point.ry *= scale.y;
            }

            // point.rx *= scale.x;
            // point.ry *= scale.y;

            // const radiusResult = SVGUtils.createSVGPoint(point.rx,point.ry).matrixTransform( _matrix );
            // point.rx = radiusResult.x;
            // point.ry = radiusResult.y;

            pointResult = point.matrixTransform(_matrix);
            point.x = pointResult.x;
            point.y = pointResult.y;
            break;
        }
    }

    if (_segmentList.length > 2) {
        const isClockwiseAfterTransform = GeometryUtils.getPolygonArea([_segmentList[0], _segmentList[1], _segmentList[2]]) > 0;
        if (isClockwiseAfterTransform !== isClockwise) {
            for (let i = 0; i < max; i++) {
                point = _segmentList[i];
                if (point.type === 'A') {
                    if (point.sweepFlag === 1) {
                        point.sweepFlag = 0;
                    } else {
                        point.sweepFlag = 1;
                    }
                }
            }
        }
    }

};

_.getGeometryPointList = function (_options) {
    if (!this.geometryPointList) {
        this.geometryPointList = [];

        const pathData = this.getPathData(_options);
        //console.log('pathData',pathData);
        let currentSubPathStartSegment = null;
        const max = pathData.length;
        let pathDataItem,
        newGeometryPoint;
        for (let i = 0; i < max; i++) {
            pathDataItem = pathData[i];
            newGeometryPoint = null;
            switch (pathDataItem.type) {
            case 'L':
                newGeometryPoint = this.createGeometryPoint_LINETO(pathDataItem.values[0], pathDataItem.values[1]);
                break;
            case 'Z':
                var lastSegment = this.geometryPointList[this.geometryPointList.length - 1];
                if ((lastSegment.x !== currentSubPathStartSegment.x) || (lastSegment.y !== currentSubPathStartSegment.y)) {
                    const newLineToSegment = this.createGeometryPoint_LINETO(currentSubPathStartSegment.x, currentSubPathStartSegment.y);
                    newLineToSegment.ownerShapeElement = this;
                    this.geometryPointList.push(newLineToSegment);
                }
                newGeometryPoint = this.createGeometryPoint_CLOSEPATH();
                break;
            case 'M':
                newGeometryPoint = this.createGeometryPoint_MOVETO(pathDataItem.values[0], pathDataItem.values[1]);
                currentSubPathStartSegment = newGeometryPoint;
                break;
            case 'C':
                newGeometryPoint = this.createGeometryPoint_CURVETO_CUBIC(pathDataItem.values[0], pathDataItem.values[1], pathDataItem.values[2], pathDataItem.values[3], pathDataItem.values[4], pathDataItem.values[5]);
                break;
            case 'Q':
                newGeometryPoint = this.createGeometryPoint_CURVETO_QUADRATIC(pathDataItem.values[0], pathDataItem.values[1], pathDataItem.values[2], pathDataItem.values[3]);
                break;
            case 'A':
                newGeometryPoint = this.createGeometryPoint_ARCTO(pathDataItem.values[0], pathDataItem.values[1], pathDataItem.values[2], pathDataItem.values[3], pathDataItem.values[4], pathDataItem.values[5], pathDataItem.values[6]);
                break;
            default:
                this.geometryPointList = null;
                return this.getGeometryPointList({
                    absolutize: true,
                    normalize: true
                });
                break;
            }

            newGeometryPoint.ownerShapeElement = this;
            newGeometryPoint.id = i;

            this.geometryPointList.push(newGeometryPoint);
        }
    }

    return this.geometryPointList;
};

// _.getGeometryPointList = function( _options )
// {
//     if(!this.geometryPointList)
//     {
//         this.geometryPointList = [];
//
//         const pathData = this.getPathData( _options );
//        //console.log('pathData',pathData);
//         let currentSubPathStartSegment=null;
//         const max = pathData.length;
//         let pathDataItem,newGeometryPoint;
//         for(let i = 0; i < max; i++)
//         {
//             pathDataItem = pathData[i];
//             newGeometryPoint=null;
//             switch (pathDataItem.type) {
//                 case 'L':
//                     newGeometryPoint = this.createGeometryPoint_LINETO(pathDataItem.values[0], pathDataItem.values[1]);
//                     break;
//                 case 'Z':
//                     var lastSegment = this.geometryPointList[this.geometryPointList.length-1];
//                     if( (lastSegment.x !== currentSubPathStartSegment.x ) || (lastSegment.y !== currentSubPathStartSegment.y ) )
//                     {
//                         const newLineToSegment = this.createGeometryPoint_LINETO(currentSubPathStartSegment.x, currentSubPathStartSegment.y);
//                         newLineToSegment.ownerShapeElement = this;
//                         this.geometryPointList.push( newLineToSegment );
//                     }
//                     newGeometryPoint = this.createGeometryPoint_CLOSEPATH();
//                     break;
//                 case 'M':
//                     newGeometryPoint = this.createGeometryPoint_MOVETO(pathDataItem.values[0], pathDataItem.values[1]);
//                     currentSubPathStartSegment = newGeometryPoint;
//                     break;
//                 case 'C':
//                     newGeometryPoint = this.createGeometryPoint_CURVETO_CUBIC(pathDataItem.values[0], pathDataItem.values[1], pathDataItem.values[2], pathDataItem.values[3],pathDataItem.values[4], pathDataItem.values[5]);
//                     break;
//                 case 'Q':
//                     newGeometryPoint = this.createGeometryPoint_CURVETO_QUADRATIC(pathDataItem.values[0], pathDataItem.values[1] , pathDataItem.values[2], pathDataItem.values[3] );
//                     break;
//                 case 'A':
//                     newGeometryPoint = this.createGeometryPoint_ARCTO(pathDataItem.values[0], pathDataItem.values[1], pathDataItem.values[2] , pathDataItem.values[3], pathDataItem.values[4],  pathDataItem.values[5],  pathDataItem.values[6]);
//                     break;
//             }
//
//             newGeometryPoint.ownerShapeElement = this;
//             newGeometryPoint.id = i;
//
//             this.geometryPointList.push( newGeometryPoint );
//         }
//     }
//
//     return this.geometryPointList;
// };

// _.updateGeometryPointListIds = function(  )
// {
//     const max = this.geometryPointList.length;
//     for(let i = 0; i < max; i++)
//     {
//         this.geometryPointList[i].id = i;
//         this.geometryPointList[i].ownerShapeElement = this;
//     }
// }


_ /*.getSnapPointList = function(  _enableCenterSnap ){
const geometryCenterList =[];
const geometryPointList = this.getGeometryPointList();
let currentPoint,previousPoint={};
for (let i = 0; i < geometryPointList.length; i++) {
currentPoint = geometryPointList[i];
//if (currentPoint.type==='L')  geometryCenterList.push( {snapName:'center', x : previousPoint.x + ((currentPoint.x-previousPoint.x)/2) , y : previousPoint.y + ((currentPoint.y-previousPoint.y)/2) } );
if (currentPoint.type==='L'){
currentPoint.segment = {element:this, pt1:previousPoint, pt2:currentPoint };
if( _enableCenterSnap) geometryCenterList.push( {name:'midpoint', x : previousPoint.x + ((currentPoint.x-previousPoint.x)/2) , y : previousPoint.y + ((currentPoint.y-previousPoint.y)/2), segment:currentPoint.segment } );
}
previousPoint = currentPoint;
}
return geometryPointList.concat(geometryCenterList,[ SVGUtils.createSVGPoint() ]); // concateno anche l'origine (ricorda che lo snap avviene solo se il riempimento non è none, ovvero qaundo si verifica il mouse over)
};*/

_.cloneSegment = function (_segment, _addSelectionState) {
    let newGeometryPoint;
    switch (_segment.type) {
    case 'L':
        newGeometryPoint = this.createGeometryPoint_LINETO(_segment.x, _segment.y);
        break;
    case 'Z':
        newGeometryPoint = this.createGeometryPoint_CLOSEPATH();
        break;
    case 'M':
        newGeometryPoint = this.createGeometryPoint_MOVETO(_segment.x, _segment.y);
        break;
    case 'C':
        newGeometryPoint = this.createGeometryPoint_CURVETO_CUBIC(_segment.controlPt1.x, _segment.controlPt1.y, _segment.controlPt2.x, _segment.controlPt2.y, _segment.x, _segment.y);
        break;
    case 'Q':
        newGeometryPoint = this.createGeometryPoint_CURVETO_QUADRATIC(_segment.controlPt1.x, _segment.controlPt1.y, _segment.x, _segment.y);
        break;
    case 'A':
        newGeometryPoint = this.createGeometryPoint_ARCTO(_segment.rx, _segment.ry, _segment.angle, _segment.largeArcFlag, _segment.sweepFlag, _segment.x, _segment.y);
        break;
    }

    if (_addSelectionState)
        newGeometryPoint.isSelected = _segment.isSelected;

    return newGeometryPoint;
};

_.cloneGeometryPointList = function (_addSelectionState) {
    const geometryPointList = this.getGeometryPointList();
    const newGeometryPointList = [];
    const max = geometryPointList.length;
    let clonedSegment;
    for (let i = 0; i < max; i++) {
        clonedSegment = this.cloneSegment(geometryPointList[i], _addSelectionState);
        clonedSegment.id = i;
        newGeometryPointList.push(clonedSegment);
    }
    return newGeometryPointList;
};

_.clonePointList = function (_geometryPointList) {
    const newGeometryPointList = [];
    const max = _geometryPointList.length;
    for (let i = 0; i < max; i++) {
        newGeometryPointList.push(this.cloneSegment(_geometryPointList[i]));
    }
    return newGeometryPointList;
};

_.setGeometryPointList = function (_geometryPointList) {
    this.geometryPointList = _geometryPointList;
    const max = this.geometryPointList.length;
    for (let i = 0; i < max; i++) {
        this.geometryPointList[i].ownerShapeElement = this;
        this.geometryPointList[i].id = i;
    }
};

_.getSubPathMoveToSegmentId = function (segment) {
    const geometryPointList = this.getGeometryPointList();
    let idSegment = geometryPointList.indexOf(segment);
    if (idSegment > -1) {
        segment = geometryPointList[idSegment];
        while (segment && segment.type !== 'M') {
            idSegment--;
            segment = geometryPointList[idSegment];
        }
    }

    return idSegment;
};

_.getSubPathList = function () {
    const geometryPointList = this.getGeometryPointList();
    let newSubPath;
    const subPathList = [];
    const max = geometryPointList.length;
    for (let i = 0; i < max; i++) {
        if (geometryPointList[i].type === 'M') {
            newSubPath = {
                ownerPath: this,
                geometryPointList: []
            };
            subPathList.push(newSubPath);
        }
        newSubPath.geometryPointList.push(geometryPointList[i]);
    }

    return subPathList;
};

_.getSubPathIdBySegment = function (_segment) {
    const subPathList = this.getSubPathList();
    const max = subPathList.length;
    for (let i = 0; i < max; i++) {
        if (subPathList[i].geometryPointList.indexOf(_segment) > -1)
            return i;
    }

    return 0;
};

_.removeSubPath = function (_idSubPath) {
    const subPathList = this.getSubPathList();
    let newGeometryPointList = [];
    const max = subPathList.length;
    for (let i = 0; i < max; i++) {
        if (i !== _idSubPath)
            newGeometryPointList = newGeometryPointList.concat(subPathList[i].geometryPointList);
    }

    this.setGeometryPointList(newGeometryPointList);
};

_.setSubPathGeometryPointList = function (_idSubPath, _geometryPointList) {
    const subPathList = this.getSubPathList();
    let newGeometryPointList = [];
    const max = subPathList.length;
    for (let i = 0; i < max; i++) {
        if (i === _idSubPath) {
            newGeometryPointList = newGeometryPointList.concat(_geometryPointList);
        } else {
            newGeometryPointList = newGeometryPointList.concat(subPathList[i].geometryPointList);
        }
    }

    this.setGeometryPointList(newGeometryPointList);
};

// _.getNearestPoint = function(  _point ) {
//     const paperScope = {};
//     paper.install(paperScope);
//     paper.setup([640, 480]);
//
//     const pathTarget = paperScope.project.importSVG(this);
//     const location = pathTarget.getNearestLocation(_point);
//     return {x:location.point.x, y:location.point.y , distance:location.distance, t:location.time};
// }


_.getSegmentIdAtLength = function (distance) {
    if (distance === undefined || !isFinite(distance))
        throw "Invalid arguments.";

    const measurementElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    measurementElement.setAttribute("d", this.getAttribute("d"));

    const geometryPointList = measurementElement.getGeometryPointList();
    if (geometryPointList.length === 0)
        return null;

    let currentSegment;
    let max = geometryPointList.length - 1;
    for (; max > 0; max--) {
        currentSegment = geometryPointList.pop();
        measurementElement.render();
        if (distance > measurementElement.getTotalLength())
            return max;
    }

    return null;
};

_.getSegmentAtLength = function (distance) {
    const segmentId = this.getSegmentIdAtLength(distance);
    if (segmentId)
        return this.getGeometryPointList()[segmentId];
    return null;
};

// _.findLinearSegmentAtPoint = function( _workspaceX , _workspaceY , _snapDistance  )
// {
//     const localPoint = this.globalToLocal( _workspaceX , _workspaceY );
//     const geometryPointList = this.getGeometryPointList();
//     const max = geometryPointList.length;
//     let i,currentPoint,previousPoint,pointOnLine;
//     for(  i=0; i<max; i++) {
//         currentPoint = geometryPointList[i];
//         if( currentPoint.type!=='L' ) continue;
//         previousPoint = geometryPointList[i-1];
//         pointOnLine = GeometryUtils.isPointOnLine( previousPoint , currentPoint , localPoint , _snapDistance , true );
//         if(pointOnLine)
//         {
//             //return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:i, pt1: SVGUtils.createSVGPoint(previousPoint.x,previousPoint.y), pt2:SVGUtils.createSVGPoint(currentPoint.x,currentPoint.y)} };
//             return {element:this, point:pointOnLine, idSegment:i, pt1: SVGUtils.createSVGPoint(previousPoint.x,previousPoint.y), pt2:SVGUtils.createSVGPoint(currentPoint.x,currentPoint.y), name:'path line'} ;
//         }
//
//     }
//     return null;
// };


// From https://bl.ocks.org/mbostock/8027637
_.closestPoint = function (point) {
    const pathNode = this;
    let pathLength = pathNode.getTotalLength(),
    precision = 8,
    best,
    bestLength,
    bestDistance = Infinity;

    // linear scan for coarse approximation
    for (let scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
        if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
            best = scan,
            bestLength = scanLength,
            bestDistance = scanDistance;
        }
    }

    // binary search for precise estimate
    precision /= 2;
    while (precision > 0.5) {
        let before,
        after,
        beforeLength,
        afterLength,
        beforeDistance,
        afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
            best = before,
            bestLength = beforeLength,
            bestDistance = beforeDistance;
        } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
            best = after,
            bestLength = afterLength,
            bestDistance = afterDistance;
        } else {
            precision /= 2;
        }
    }

    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
        const dx = p.x - point.x,
        dy = p.y - point.y;
        return dx * dx + dy * dy;
    }
}

/*
_.hitTestSegmentAtPoint = function(_workspaceX , _workspaceY , _snapDistance ){
const localPos = this.parentElement.globalToLocal( _workspaceX , _workspaceY );

const paperScope={};
paper.install(paperScope);
paper.setup([640, 480]);

const pathTarget = paperScope.project.importSVG(this);

pathTarget.fillColor = 'none';
pathTarget.strokeColor = 'black';
pathTarget.strokeWidth = _snapDistance;

const hitOptions = {
segments: true,
stroke: true,
fill: false,
tolerance: _snapDistance
};

const hitResult = paperScope.project.hitTest(localPos, hitOptions);

if (!hitResult) return null;
let t=null;
let idSegment;
if (hitResult.type === 'segment'){
idSegment = hitResult.segment.index;
}
else if (hitResult.type === 'stroke'){
idSegment = hitResult.location.index;
t = hitResult.location.time;
}

idSegment++; // sembra che paper non abbia il punto moveTo iniziale
const subPathList = this.getSubPathList();
const subPathId = hitResult.item.index;
const subPath = subPathList[ subPathId ];
const segment = subPath.geometryPointList[ idSegment ];

const previousSegment = subPath.geometryPointList[ idSegment-1 ];
const point = {x:hitResult.point.x, y:hitResult.point.y};

return { path:this, subPathList:subPathList, type:hitResult.type,subPath:subPath,subPathId:subPathId,segmentId:idSegment,segment:segment,previousSegment:previousSegment,t:t,point:point };

};
 */

/*

_.applySnapTo_segments = function(_globalPoint , _snapDistance )
{
// var startTimeStamp = new Date().getTime();
const localPos = this.parentElement.globalToLocal( _globalPoint.x , _globalPoint.y );

const paperScope={};
paper.install(paperScope);
paper.setup([640, 480]);

const pathTarget = paperScope.project.importSVG(this);

pathTarget.fillColor = 'none';
pathTarget.strokeColor = 'black';

const hitOptions = {
segments: true,
stroke: true,
fill: false,
tolerance: _snapDistance
};

const hitResult = paperScope.project.hitTest(localPos, hitOptions);

if (!hitResult) return null;
let t=null;
let idSegment;
if (hitResult.type === 'segment') {
idSegment = hitResult.segment.index;
} else if (hitResult.type === 'stroke') {
idSegment = hitResult.location.index;
t = hitResult.location.time;
}

idSegment++; // sembra che paper non abbia il punto moveTo iniziale
const subPathList = this.getSubPathList();
const subPathId = hitResult.item.index;
const subPath = subPathList[ subPathId ];
const segment = subPath.geometryPointList[ idSegment ];
const point = {x:hitResult.point.x, y:hitResult.point.y};

return { path:this, subPathList:subPathList, type:hitResult.type,subPath:subPath,subPathId:subPathId,segmentId:idSegment,segment:segment,t:t,point:point };
};
 */

_.getGeometryPointListAsString = function () {
    const max = this.geometryPointList.length;
    let pointsAsString = '';
    for (let i = 0; i < max; i++) {
        pointsAsString += this.geometryPointList[i].toString();
    }
    return pointsAsString;
};

_.render = function () {
    const max = this.geometryPointList.length;
    let pointsAsString = '';
    for (let i = 0; i < max; i++) {
        this.geometryPointList[i].id = i;
        pointsAsString += this.geometryPointList[i].toString();
    }
    this.setAttribute('d', pointsAsString);
    this.waitForRendering = false;
};

_.createGeometryPoint_CLOSEPATH = function () {
    const pt = {};
    pt.type = 'Z';
    pt.toString = function () {
        return this.type + ' ';
    };
    return pt;
};

_.createGeometryPoint_MOVETO = function (_x, _y) {
    const pt = SVGUtils.createSVGPoint(_x, _y);
    pt.type = 'M';
    pt.toString = function () {
        return this.type + ' ' + this.x + ' ' + this.y + ' ';
    };
    return pt;
};

_.createGeometryPoint_LINETO = function (_x, _y) {
    const pt = SVGUtils.createSVGPoint(_x, _y);
    pt.type = 'L';
    pt.toString = function () {
        return this.type + ' ' + this.x + ' ' + this.y + ' ';
    };
    return pt;
};

_.createGeometryPoint_CURVETO_CUBIC = function (_x1, _y1, _x2, _y2, _x, _y) {
    const pt = SVGUtils.createSVGPoint(_x, _y);
    pt.type = 'C';
    pt.controlPt1 = SVGUtils.createSVGPoint(_x1, _y1);
    pt.controlPt1.type = 'CTRL1';
    pt.controlPt2 = SVGUtils.createSVGPoint(_x2, _y2);
    pt.controlPt2.type = 'CTRL2';
    pt.controlPt1.ownerPoint = pt;
    pt.controlPt2.ownerPoint = pt;
    pt.toString = function () {
        return this.type + ' ' + this.controlPt1.x + ' ' + this.controlPt1.y + ' ' + this.controlPt2.x + ' ' + this.controlPt2.y + ' ' + this.x + ' ' + this.y + ' ';
    };
    return pt;
};

_.createGeometryPoint_CURVETO_QUADRATIC = function (_x1, _y1, _x, _y) {
    const pt = SVGUtils.createSVGPoint(_x, _y);
    pt.type = 'Q';
    pt.controlPt1 = SVGUtils.createSVGPoint(_x1, _y1);
    pt.controlPt1.type = 'CTRL1';
    pt.controlPt1.ownerPoint = pt;
    pt.toString = function () {
        return this.type + ' ' + this.controlPt1.x + ' ' + this.controlPt1.y + ' ' + this.x + ' ' + this.y + ' ';
    };
    return pt;
};

_.createGeometryPoint_ARCTO = function (_rx = 100, _ry = 100, _angle = 0, _largeArcFlag = 1, _sweepFlag = 1, _x = 100, _y = 100) {
    const pt = SVGUtils.createSVGPoint(_x, _y);
    pt.type = 'A';
    pt.rx = _rx;
    pt.ry = _ry;
    pt.angle = _angle;
    pt.largeArcFlag = _largeArcFlag;
    pt.sweepFlag = _sweepFlag;
    pt.toString = function () {
        return this.type + ' ' + this.rx + ' ' + this.ry + ' ' + this.angle + ' ' + this.largeArcFlag + ' ' + this.sweepFlag + ' ' + this.x + ' ' + this.y + ' ';
    };
    return pt;
};

// _.createGeometryPoint_ARCTO_by_startEndAngles = function(  _center, radius, startAngle, endAngle , _arcToTarget )
// {
//     if(endAngle<startAngle)endAngle+=360;
//
//     function polarToCartesian(center, radius, angleInDegrees) {
//         const angleInRadians = angleInDegrees * Math.PI / 180.0;
//
//         return SVGUtils.createSVGPoint(
//             center.x + (radius * Math.cos(angleInRadians)),
//             center.y + (radius * Math.sin(angleInRadians))
//         )
//     }
//
//     const start = polarToCartesian(_center, radius, startAngle);
//     const end = polarToCartesian(_center, radius, endAngle);
//     const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
//
//     _arcToTarget = _arcToTarget || this.createGeometryPoint_ARCTO();
//
//     _arcToTarget.rx = radius;
//     _arcToTarget.ry = radius;
//     _arcToTarget.angle = 0;
//     _arcToTarget.largeArcFlag = largeArcFlag;
//     _arcToTarget.sweepFlag = 1;
//     _arcToTarget.x = end.x;
//     _arcToTarget.y = end.y;
//     _arcToTarget.startPt = start;
//     _arcToTarget.endPt = end;
//     _arcToTarget.center = _center;
//     _arcToTarget.angleStart = startAngle;
//     _arcToTarget.angleEnd = endAngle;
//     _arcToTarget.radius = radius;
//
//     return _arcToTarget;
//
// };

_.createGeometryPoint_ARCTO_by_startEndAngles = function (_center, radius, startAngle, endAngle, _arcToTarget, counterClockwise = 0) {
    if (endAngle < startAngle)
        endAngle += 360;

    function polarToCartesian(center, radius, angleInDegrees) {
        const angleInRadians = angleInDegrees * Math.PI / 180.0;

        return SVGUtils.createSVGPoint(
            center.x + (radius * Math.cos(angleInRadians)),
            center.y + (radius * Math.sin(angleInRadians)))
    }

    let end,
    start,
    largeArcFlag,
    sweepFlag;

    if (counterClockwise === 1) {
        start = polarToCartesian(_center, radius, endAngle);
        end = polarToCartesian(_center, radius, startAngle);
        largeArcFlag = Math.abs(startAngle - endAngle) <= 180 ? "0" : "1";
        sweepFlag = 0;
    } else {
        start = polarToCartesian(_center, radius, startAngle);
        end = polarToCartesian(_center, radius, endAngle);
        largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        sweepFlag = 1;
    }

    _arcToTarget = _arcToTarget || this.createGeometryPoint_ARCTO();

    _arcToTarget.rx = radius;
    _arcToTarget.ry = radius;
    _arcToTarget.angle = 0;
    _arcToTarget.largeArcFlag = largeArcFlag;
    _arcToTarget.sweepFlag = sweepFlag;
    _arcToTarget.x = end.x;
    _arcToTarget.y = end.y;
    _arcToTarget.startPt = start;
    _arcToTarget.endPt = end;
    _arcToTarget.center = _center;
    _arcToTarget.angleStart = startAngle;
    _arcToTarget.angleEnd = endAngle;
    _arcToTarget.radius = radius;

    return _arcToTarget;

};

_.createGeometryPoint_ARCTO_by_3Points = function (a, b, c, _arcToTarget) {
    function dist(a, b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    const A = dist(b, c);
    const B = dist(c, a);
    const C = dist(a, b);

    const angle = Math.acos((A * A + B * B - C * C) / (2 * A * B));

    //calc radius of circle
    const K = .5 * A * B * Math.sin(angle);
    let r = A * B * C / 4 / K;

    //large arc flag
    const laf =  + (Math.PI / 2 > angle);

    //sweep flag
    const saf =  + ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) < 0);

    if (isNaN(r))
        r = 1;

    _arcToTarget = _arcToTarget || this.createGeometryPoint_ARCTO();

    _arcToTarget.rx = r;
    _arcToTarget.ry = r;
    _arcToTarget.angle = 0;
    _arcToTarget.largeArcFlag = laf;
    _arcToTarget.sweepFlag = saf;
    _arcToTarget.x = b.x;
    _arcToTarget.y = b.y;
    //_arcToTarget.radius = r;


    return _arcToTarget;

};

// _.buildArc = function(_center, radius, startAngle, endAngle , _pathTarget){
//
//     _pathTarget = _pathTarget || this;
//
//     function polarToCartesian(center, radius, angleInDegrees) {
//         const angleInRadians = (angleInDegrees) * Math.PI / 180.0;
//
//         return {
//             x: center.x + (radius * Math.cos(angleInRadians)),
//             y: center.y + (radius * Math.sin(angleInRadians))
//         };
//     }
//
//     const start = polarToCartesian(_center, radius, startAngle);
//     const end = polarToCartesian(_center, radius, endAngle);
//     const largeArcFlag = endAngle - startAngle <= 180 ? "1" : "0";
//
//
//     const d = [
//         "M", start.x, start.y,
//         "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
//     ].join(" ");
//
//     _pathTarget.setAttribute('d', d );
//     return {center:_center,angleStart:start,angleEnd:end,startPt:start,endPt:end};
// }


_.buildArc = function (_center, radius, startAngle, endAngle, _pathTarget) {

    _pathTarget = _pathTarget || this;

    if (endAngle < startAngle)
        endAngle += 360;

    function polarToCartesian(center, radius, angleInDegrees) {
        const angleInRadians = angleInDegrees * Math.PI / 180.0;

        return SVGUtils.createSVGPoint(
            center.x + (radius * Math.cos(angleInRadians)),
            center.y + (radius * Math.sin(angleInRadians)))
    }

    const start = polarToCartesian(_center, radius, startAngle);
    const end = polarToCartesian(_center, radius, endAngle);
    const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

    const d = [
        "M", start.x, start.y,
        "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y
    ].join(" ");

    // const d = [
    //     "M", start.x, start.y,
    //     "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y,
    //     "M 0 0"
    // ].join(" ");

    _pathTarget.setAttribute('d', d);
    return {
        center: _center,
        angleStart: start,
        angleEnd: end,
        startPt: start,
        endPt: end
    };
}

_.buildArcBy3Points = function (a, b, c, _pathTarget) {
    _pathTarget = _pathTarget || this;

    function dist(a, b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }

    const A = dist(b, c);
    const B = dist(c, a);
    const C = dist(a, b);

    const angle = Math.acos((A * A + B * B - C * C) / (2 * A * B));

    //calc radius of circle
    const K = .5 * A * B * Math.sin(angle);
    let r = A * B * C / 4 / K;
    //r = Math.round(r*1000)/1000;

    //large arc flag
    const laf =  + (Math.PI / 2 > angle);

    //sweep flag
    const saf =  + ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) < 0);

    if (isNaN(r))
        r = 1;

    _pathTarget.setAttribute('d', ['M', a.x, a.y, 'A', r, r, 0, laf, saf, b.x, b.y].join(' '));

    //return {center:_center,angleStart:start,angleEnd:end,startPt:a,endPt:b,radius:r};

    //return ['M', a.x, a.y, 'A', r, r, 0, laf, saf, b.x ,b.y ].join(' ');
};

_.createFillet = function (_radius, _segment1, _segment2) {
    const path = this;
    const subPathId = path.getSubPathIdBySegment(_segment1);
    const subPath = path.getSubPathList()[subPathId];
    const pointList = subPath.geometryPointList;
    const isSubPathClosed = pointList[pointList.length - 1].type === 'Z';

    // let segment1_id  = pointList.indexOf(_segment1);
    // let segment2_id  = pointList.indexOf(_segment2);

    let segment1_id = _segment1.id;
    let segment2_id = _segment2.id;

    if (segment1_id > segment2_id) {
        let temp = _segment1
            _segment1 = _segment2;
        _segment2 = temp;
        temp = segment1_id;
        segment1_id = segment2_id;
        segment2_id = temp;
    }

    if (segment2_id === (segment1_id + 1)) {
        const arcSegment = path.createGeometryPoint_ARCTO(10, 10, 0, 0, 0, _segment2.x, _segment2.y);
        const geometryPointList = path.getGeometryPointList();
        geometryPointList.addAt(arcSegment, segment2_id);
        path.setGeometryPointList(geometryPointList);
        this.updateFillet(_radius, arcSegment);
    }

}

_.updateFillet = function (_radius, arcSegment) {
    const path = this;
    const subPathId = path.getSubPathIdBySegment(arcSegment);
    const subPath = path.getSubPathList()[subPathId];
    const pointList = subPath.geometryPointList;
    const isSubPathClosed = pointList[pointList.length - 1].type === 'Z';

    const arcSegmentId = pointList.indexOf(arcSegment);

    let previousSegment = pointList[arcSegmentId - 1];
    let nextSegment = pointList[arcSegmentId + 1];

    let previousLineSegment = null;
    let nextLineSegment = null;

    if (previousSegment.type === 'L') {
        previousLineSegment = previousSegment;
    } else if (isSubPathClosed && previousSegment.type === 'M') {
        const segmentBeforeCloseSegment = pointList[pointList.length - 2];
        if (segmentBeforeCloseSegment.type === 'L')
            previousLineSegment = segmentBeforeCloseSegment;
    }

    if (!previousLineSegment)
        return;

    if (nextSegment.type === 'L') {
        nextLineSegment = nextSegment;
    } else if (isSubPathClosed && nextSegment.type === 'Z') {
        const segmentAfterMoveToSegment = pointList[1];
        if (segmentAfterMoveToSegment.type === 'L')
            nextLineSegment = segmentAfterMoveToSegment;
    }

    if (!nextLineSegment)
        return;

    const segmentBeforePreviousLineSegment = pointList[pointList.indexOf(previousLineSegment) - 1];

    const line1_pt1 = {
        x: segmentBeforePreviousLineSegment.x,
        y: segmentBeforePreviousLineSegment.y
    };
    const line1_pt2 = {
        x: previousLineSegment.x,
        y: previousLineSegment.y
    };
    const line2_pt1 = {
        x: arcSegment.x,
        y: arcSegment.y
    };
    const line2_pt2 = {
        x: nextLineSegment.x,
        y: nextLineSegment.y
    };

    //console.log('arcSegment', arcSegment );
    //console.log('previousLineSegment', previousLineSegment );
    //console.log('nextLineSegment', nextLineSegment );

    const corner = GeometryUtils.getLineLineIntersection(line1_pt1, line1_pt2, line2_pt1, line2_pt2);

    if (!corner)
        return;

    const result = GeometryUtils.fillet(line1_pt2, corner, line2_pt2, _radius);

    let counterClockwise = 0;
    if (result.area < 0)
        counterClockwise = 1;

    path.createGeometryPoint_ARCTO_by_startEndAngles(result.center, result.radius, result.startAngle, result.endAngle, arcSegment, counterClockwise);

    previousLineSegment.x = arcSegment.startPt.x;
    previousLineSegment.y = arcSegment.startPt.y;

    if (previousSegment.type === 'M') {
        previousSegment.x = previousLineSegment.x;
        previousSegment.y = previousLineSegment.y;
    }

    path.render();

    return result;

};

_.buildRegularPolygon = function (posX, posY, numSides, size, _pathTarget) {
    _pathTarget = _pathTarget || this;
    const angleSteep = 2 * Math.PI / numSides;
    let x,
    y,
    i = 0;
    x = posX + size * Math.sin(angleSteep / 2 + angleSteep * i);
    y = posY + size * Math.cos(angleSteep / 2 + angleSteep * i);

    let d_attr = 'M ' + x + ' ' + y;

    for (i = 1; i <= numSides; i++) {
        x = posX + size * Math.sin(angleSteep / 2 + angleSteep * i);
        y = posY + size * Math.cos(angleSteep / 2 + angleSteep * i);
        d_attr += ' L ' + x + ' ' + y;
    }

    d_attr += 'Z';

    _pathTarget.setAttribute('d', d_attr);
};

_.quadraticCurveToCubicCurve = function (startPt, _quadraticCurveSeg) {
    // if:   quadratic bezier = (x1, y1), (x2,y2), (x3, y3)
    // then: cubic bezier     = (x1, y1), (x1 + 2/3 (x2 - x1) , y1 + 2/3 (y2 - y1)), (x2 + 1/3 (x3 - x2) , y2 + 1/3 (y3 - y2))(x3,y3)
    const x1 = (startPt.x + 2 / 3 * (_quadraticCurveSeg.controlPt1.x - startPt.x));
    const y1 = (startPt.y + 2 / 3 * (_quadraticCurveSeg.controlPt1.y - startPt.y));
    const x2 = (_quadraticCurveSeg.controlPt1.x + 1 / 3 * (_quadraticCurveSeg.x - _quadraticCurveSeg.controlPt1.x));
    const y2 = (_quadraticCurveSeg.controlPt1.y + 1 / 3 * (_quadraticCurveSeg.y - _quadraticCurveSeg.controlPt1.y));
    return this.createGeometryPoint_CURVETO_CUBIC(x1, y1, x2, y2, _quadraticCurveSeg.x, _quadraticCurveSeg.y);
};

_.convertQuandraticCurveToCubicCurve = function () {
    const convertedPointList = [];
    const pointList = this.getGeometryPointList();
    const max = pointList.length;
    let currentPoint;
    for (let i = 0; i < max; i++) {
        currentPoint = pointList[i];
        if (currentPoint.type === 'Q') {
            pointList[i] = this.quadraticCurveToCubicCurve(pointList[i - 1], pointList[i]);
            pointList[i].ownerShapeElement = this;
            convertedPointList.push(pointList[i]);
        }
    }
    return convertedPointList;
};

_.getSelectedTransformablePointList = function () {
    const pointListToTransform = [];

    const subPathList = this.getSubPathList();

    const maxSubPath = subPathList.length;
    for (let idSubPath = 0; idSubPath < maxSubPath; idSubPath++) {
        const subPath = subPathList[idSubPath];
        const geometryPointList = subPath.geometryPointList;
        const max = geometryPointList.length;

        let nextGeometryPoint;

        for (let i = 0; i < max; i++) {
            var geometryPoint = geometryPointList[i];
            if (geometryPoint.isSelected) {
                geometryPoint.flagged = true;

                if (geometryPoint.type === 'Q') {
                    geometryPoint.controlPt1.flagged = true;
                } else if (geometryPoint.type === 'C') {
                    geometryPoint.controlPt2.flagged = true;
                }
                // questo è usato perchè quando si dragga un segmento il punto M viene selezionato con javascript
                else if (geometryPoint.type === 'M' && geometryPointList[max - 1].type === 'Z') {
                    var lastSegment = geometryPointList[max - 2];
                    lastSegment.flagged = true; // anche l'ultimo sara draggabile
                    if (lastSegment.type === 'Q') {
                        lastSegment.controlPt1.flagged = true;
                    } else if (lastSegment.type === 'C') {
                        lastSegment.controlPt2.flagged = true;
                    }
                }

                if (i < (max - 1)) {
                    nextGeometryPoint = geometryPointList[i + 1];
                    if (nextGeometryPoint.type === 'Z') {
                        nextGeometryPoint = geometryPointList[0];
                        nextGeometryPoint.flagged = true; // anche il moveTo sara draggabile
                        nextGeometryPoint = geometryPointList[1];
                    } // dopo il punto moveTo
                    if (nextGeometryPoint.type === 'Q' || nextGeometryPoint.type === 'C')
                        nextGeometryPoint.controlPt1.flagged = true;
                }
            }
        }

        // creo la lista dei punti da draggare
        for (let i = 0; i < max; i++) {
            geometryPoint = geometryPointList[i];

            if (geometryPoint.flagged) {
                pointListToTransform.push(geometryPoint);
                geometryPoint.connectedToSelection = true;
                delete geometryPoint.flagged;
            }

            if (geometryPoint.type === 'Q') {
                if (geometryPoint.controlPt1.flagged) {
                    pointListToTransform.push(geometryPoint.controlPt1);
                    geometryPoint.controlPt1.connectedToSelection = true;
                    delete geometryPoint.controlPt1.flagged;
                }

            } else if (geometryPoint.type === 'C') {
                if (geometryPoint.controlPt1.flagged) {
                    pointListToTransform.push(geometryPoint.controlPt1);
                    geometryPoint.controlPt1.connectedToSelection = true;
                    delete geometryPoint.controlPt1.flagged;
                }
                if (geometryPoint.controlPt2.flagged) {
                    pointListToTransform.push(geometryPoint.controlPt2);
                    geometryPoint.controlPt2.connectedToSelection = true;
                    delete geometryPoint.controlPt2.flagged;
                }
            }
        }
    }

    return pointListToTransform;
};

_.updateGeometryPointListBySubPathList = function (_subPathList) {
    let newGeometryPointList = [];
    for (let i = 0; i < _subPathList.length; i++)
        newGeometryPointList = newGeometryPointList.concat(_subPathList[i].geometryPointList);
    this.setGeometryPointList(newGeometryPointList);
};

_.addPathPointAtLocation = function (_segment, t) {

    const previousSegment = _segment.pt1;
    const segmentTarget = _segment.pt2;

    if (segmentTarget.type === 'C') {
        t = t || _segment.pointOnSegment.t;

        const curve = new Bezier(previousSegment.x, previousSegment.y, segmentTarget.controlPt1.x, segmentTarget.controlPt1.y, segmentTarget.controlPt2.x, segmentTarget.controlPt2.y, segmentTarget.x, segmentTarget.y);
        const result = curve.split(t);

        const curveLeft = result.left;
        const curveRight = result.right;
        let curveLeftToAdd = this.createGeometryPoint_CURVETO_CUBIC(curveLeft.points[1].x, curveLeft.points[1].y, curveLeft.points[2].x, curveLeft.points[2].y, curveLeft.points[3].x, curveLeft.points[3].y);
        let curveRightToAdd = this.createGeometryPoint_CURVETO_CUBIC(curveRight.points[1].x, curveRight.points[1].y, curveRight.points[2].x, curveRight.points[2].y, curveRight.points[3].x, curveRight.points[3].y);
        const geometryPointList = this.getGeometryPointList();

        geometryPointList.removeAt(segmentTarget.id);
        geometryPointList.addAt(curveLeftToAdd, segmentTarget.id);
        geometryPointList.addAt(curveRightToAdd, segmentTarget.id + 1);

        this.setGeometryPointList(geometryPointList); // serve ad aggiornare gli id ed altri riferimenti
        return curveLeftToAdd;

    } else if (segmentTarget.type === 'L') {
        const newLine = this.createGeometryPoint_LINETO(_segment.pointOnSegment.x, _segment.pointOnSegment.y);
        const geometryPointList = this.getGeometryPointList();
        geometryPointList.addAt(newLine, segmentTarget.id);
        this.setGeometryPointList(geometryPointList); // serve ad aggiornare gli id ed altri riferimenti
        return newLine;
    } else if (segmentTarget.type === 'A') {
        segmentTarget.largeArcFlag = 0;
        // segmentTarget.rx = _segment.radius;
        // segmentTarget.ry = _segment.radius;
        segmentTarget.rx = segmentTarget.radius;
        segmentTarget.ry = segmentTarget.radius;
        const newArc = this.createGeometryPoint_ARCTO(segmentTarget.rx, segmentTarget.ry, segmentTarget.angle, segmentTarget.largeArcFlag, segmentTarget.sweepFlag, _segment.pointOnSegment.x, _segment.pointOnSegment.y);
        //const newArc = this.createGeometryPoint_ARCTO( _segment.radius, _segment.radius, segmentTarget.angle, segmentTarget.largeArcFlag , segmentTarget.sweepFlag , _segment.pointOnSegment.x , _segment.pointOnSegment.y );

        // verifico se il centro dell'arco è cambiato ed imposto largeArcFlag
        let arcCenter = GeometryUtils.getArcCenter(previousSegment.x, previousSegment.y, newArc.x, newArc.y, newArc.rx, newArc.ry, newArc.angle, newArc.largeArcFlag, newArc.sweepFlag);

        if (!GeometryUtils.isPointSnappedTo(arcCenter, segmentTarget.center, 2))
            newArc.largeArcFlag = 1;

        arcCenter = GeometryUtils.getArcCenter(newArc.x, newArc.y, segmentTarget.x, segmentTarget.y, segmentTarget.rx, segmentTarget.ry, segmentTarget.angle, segmentTarget.largeArcFlag, segmentTarget.sweepFlag);

        if (!GeometryUtils.isPointSnappedTo(arcCenter, segmentTarget.center, 2))
            segmentTarget.largeArcFlag = 1;

        const geometryPointList = this.getGeometryPointList();
        geometryPointList.addAt(newArc, segmentTarget.id);
        this.setGeometryPointList(geometryPointList); // serve ad aggiornare gli id ed altri riferimenti
        return newArc;
    }

}

// _.splitPathAtLocation = function (  _segment , t )
// {
//     const path = this.cloneNode();
//     path.setGeometryPointList( this.cloneGeometryPointList() ) ;
//     const addedPoint = path.addPathPointAtLocation(  _segment , t );
//     return path.splitPathAtPoint( addedPoint );
// }

_.splitPathAtPoint = function (_point) {
    const subPathList = this.getSubPathList();
    if (subPathList.length === 1) {
        const geometryPointList = this.getGeometryPointList();
        const leftPathGeometryPointList = geometryPointList.slice(0, _point.id + 1);
        const rightPathGeometryPointList = geometryPointList.slice(_point.id + 1);
        rightPathGeometryPointList.unshift(this.createGeometryPoint_MOVETO(_point.x, _point.y)); // aggiungo M alla parte destra
        // se la path è chiusa
        if (rightPathGeometryPointList[rightPathGeometryPointList.length - 1].type === 'Z') {
            leftPathGeometryPointList.shift(this.createGeometryPoint_MOVETO(_point.x, _point.y)); // rimuovo M alla parte sinistra
            rightPathGeometryPointList.pop(); // rimuovo Z dalla parte destra
            const path = this.cloneNode();
            path.setGeometryPointList(rightPathGeometryPointList.concat(leftPathGeometryPointList));
            path.render();
            return [path];
        }

        const leftPath = this.cloneNode();
        const rightPath = this.cloneNode();
        leftPath.setGeometryPointList(leftPathGeometryPointList);
        leftPath.render();
        rightPath.setGeometryPointList(rightPathGeometryPointList);
        rightPath.render();
        return [leftPath, rightPath];
    }
    //const subPath = this.getSubPathIdBySegment( _point.id );
}

_.joinPath = function (_sourcePathToJoin, _tolerance = 2) {
    // _tolerance = _tolerance || 2;
    const m = _sourcePathToJoin.getTransformToElement(this);
    _sourcePathToJoin = _sourcePathToJoin.cloneNode();
    _sourcePathToJoin.transformGeometryPointList(m);

    const subPathToJoinList = _sourcePathToJoin.getSubPathList();
    const targetSubPathList = this.getSubPathList();
    let subPathToJoin,
    targetSubPath,
    subPathToJoinPointList,
    targetSubPathPointList,
    subPathToJoinStartPoint,
    targetStartPoint,
    subPathToJoinEndPoint,
    targetEndPoint;
    const maxss = subPathToJoinList.length;

    for (let iss = 0; iss < maxss; iss++) {
        subPathToJoin = subPathToJoinList[iss];
        subPathToJoinPointList = subPathToJoin.geometryPointList;
        subPathToJoinStartPoint = subPathToJoinPointList[0];
        subPathToJoinEndPoint = subPathToJoinPointList[subPathToJoinPointList.length - 1];

        if (subPathToJoinEndPoint.type !== 'Z' && subPathToJoinEndPoint.type !== 'z') {
            const maxts = targetSubPathList.length;
            for (let its = 0; its < maxts; its++) {
                targetSubPath = targetSubPathList[its];
                targetSubPathPointList = targetSubPath.geometryPointList;
                targetStartPoint = targetSubPathPointList[0];
                targetEndPoint = targetSubPathPointList[targetSubPathPointList.length - 1];

                if (targetEndPoint.type !== 'Z' && targetEndPoint.type !== 'z') {
                    if (subPathToJoinStartPoint.getDistanceFromPoint(targetEndPoint) < _tolerance) {
                        // OK
                        //il punto iniziale di sourcePath è connesso con il punto finale di target subPath
                        // rimuovi il primo punto (moveTo) di source path e aggiungi in coda a target path
                        subPathToJoinPointList.shift();
                        targetSubPath.geometryPointList = targetSubPathPointList.concat(subPathToJoinPointList);
                        this.updateGeometryPointListBySubPathList(targetSubPathList);
                        return true;
                    } else if (subPathToJoinStartPoint.getDistanceFromPoint(targetStartPoint) < _tolerance) {
                        // il punto iniziale di sourcePath è connesso con il punto iniziale di target subPath
                        // inverti ordine di subPathToJoin
                        // rimuovi il primo punto (moveTo) di target path
                        // inserisci in testa
                        _sourcePathToJoin.reverseSubPath(subPathToJoin);
                        targetSubPathPointList.shift();
                        targetSubPath.geometryPointList = subPathToJoinPointList.concat(targetSubPathPointList);
                        this.updateGeometryPointListBySubPathList(targetSubPathList);
                        return true;
                    } else if (subPathToJoinEndPoint.getDistanceFromPoint(targetEndPoint) < _tolerance) {
                        //il punto finale di _sourcePathToJoin è connesso con il punto finale di target subPath
                        // inverti ordine di subPathToJoin e aggiungi in coda

                        _sourcePathToJoin.reverseSubPath(subPathToJoin);
                        subPathToJoinPointList.shift();
                        targetSubPath.geometryPointList = targetSubPathPointList.concat(subPathToJoinPointList);
                        this.updateGeometryPointListBySubPathList(targetSubPathList);
                        return true;
                    } else if (subPathToJoinEndPoint.getDistanceFromPoint(targetStartPoint) < _tolerance) {
                        // OK
                        //il punto finale di _sourcePathToJoin è connesso con il punto iniziale di target subPath
                        // aggiungi in testa
                        targetSubPathPointList.shift();
                        targetSubPath.geometryPointList = subPathToJoinPointList.concat(targetSubPathPointList);
                        this.updateGeometryPointListBySubPathList(targetSubPathList);
                        return true;
                    }
                }
            }
        }
    }

    return false;
};

_.unifyPathSegments = function (_pathToUnify) {
    const mat = _pathToUnify.getTransformToElement(this);
    _pathToUnify = _pathToUnify.cloneNode();
    _pathToUnify.transformGeometryPointList(mat);
    this.setGeometryPointList(this.getGeometryPointList().concat(_pathToUnify.cloneGeometryPointList()));
};

_.reverseSubPath = function (_subPath) {
    let geometryPointList = _subPath.geometryPointList;
    const moveTo = geometryPointList.shift();
    const lastPointX = moveTo.x;
    const lastPointY = moveTo.y;
    let isClosedPath = false;
    if (geometryPointList[geometryPointList.length - 1].type === 'Z' || geometryPointList[geometryPointList.length - 1].type === 'Z') {
        isClosedPath = true;
        geometryPointList.pop();
    }
    geometryPointList.push(moveTo);
    geometryPointList.reverse();
    let currentPoint,
    nextPoint;
    const max = geometryPointList.length;
    for (let i = 0; i < max - 1; i++) {
        currentPoint = geometryPointList[i];
        nextPoint = geometryPointList[i + 1];
        currentPoint.x = nextPoint.x;
        currentPoint.y = nextPoint.y;
        if (currentPoint.type === 'C') {
            let tempX = currentPoint.controlPt1.x;
            let tempY = currentPoint.controlPt1.y;
            currentPoint.controlPt1.x = currentPoint.controlPt2.x;
            currentPoint.controlPt1.y = currentPoint.controlPt2.y;
            currentPoint.controlPt2.x = tempX;
            currentPoint.controlPt2.y = tempY;
        } else if (currentPoint.type === 'A') {
            // currentPoint.sweepFlag = 1 - currentPoint.sweepFlag;
            if (currentPoint.sweepFlag === 1) {
                currentPoint.sweepFlag = 0;
            } else {
                currentPoint.sweepFlag = 1;
            }

            // if(currentPoint.largeArcFlag===1)
            // {
            //     currentPoint.largeArcFlag=0;
            // }else {
            //     currentPoint.largeArcFlag=1;
            // }
            //currentPoint.largeArcFlag = 1 - currentPoint.largeArcFlag;
        }

    }

    const lastPoint = geometryPointList[geometryPointList.length - 1];
    lastPoint.x = lastPointX;
    lastPoint.y = lastPointY;
    if (lastPoint.type === 'C') {
        let tempX = lastPoint.controlPt1.x;
        let tempY = lastPoint.controlPt1.y;
        lastPoint.controlPt1.x = lastPoint.controlPt2.x;
        lastPoint.controlPt1.y = lastPoint.controlPt2.y;
        lastPoint.controlPt2.x = tempX;
        lastPoint.controlPt2.y = tempY;
    } else if (lastPoint.type === 'A') {
        if (lastPoint.sweepFlag === 1) {
            lastPoint.sweepFlag = 0;
        } else {
            lastPoint.sweepFlag = 1;
        }
    }

    if (isClosedPath)
        geometryPointList.push(this.createGeometryPoint_CLOSEPATH());
};

_.reverseSegments = function (_subPathId) {
    const subPathList = this.getSubPathList();

    if (_subPathId !== undefined) {
        this.reverseSubPath(subPathList[_subPathId]);
    } else {
        for (let i = 0; i < subPathList.length; i++)
            this.reverseSubPath(subPathList[i]);
    }

    this.updateGeometryPointListBySubPathList(subPathList);
    this.render();

};

_.closePath = function (_subPathId) {
    const subPathList = this.getSubPathList();

    const self = this;

    function closeSubPath(_subPath) {
        const geometryPointList = _subPath.geometryPointList;
        const firstSegment = geometryPointList[0];
        const lastSegment = geometryPointList[geometryPointList.length - 1];

        if ((lastSegment.type !== 'Z') && (lastSegment.type !== 'z')) {
            if ((firstSegment.x === lastSegment.x) && (firstSegment.y === lastSegment.y)) {
                geometryPointList.push(self.createGeometryPoint_CLOSEPATH());
            } else {
                geometryPointList.push(self.createGeometryPoint_LINETO(firstSegment.x, firstSegment.y));
                geometryPointList.push(self.createGeometryPoint_CLOSEPATH());
            }
        }
    }

    if (_subPathId !== undefined) {
        closeSubPath(subPathList[_subPathId]);
    } else {
        for (let i = 0; i < subPathList.length; i++)
            closeSubPath(subPathList[i]);
    }

    let newSegmentList = [];

    for (let i = 0; i < subPathList.length; i++) {
        newSegmentList = newSegmentList.concat(subPathList[i].geometryPointList);
    }

    this.setGeometryPointList(newSegmentList);
    this.render();
};

_.hasPointInPolygon = function (_polygon) {
    const pointList = this.getGeometryPointList();
    let currentSegmentPoint;
    const max = pointList.length;
    for (let i = 0; i < max; i++) {
        currentSegmentPoint = pointList[i];
        if ((currentSegmentPoint.type !== "Z")) {
            if (GeometryUtils.isPointInPoly(_polygon, currentSegmentPoint))
                return true;
        }
    }
    return false;
};

_.intersectGlobalRect = function (_globalRect) {
    if (this.isContainedInGlobalRect(_globalRect))
        return true;

    const localRectAsPolygon = this.globalRectToLocalPolygon(_globalRect);

    if (this.hasPointInPolygon(localRectAsPolygon))
        return true;

    const totalLength = this.getTotalLength();
    let pointAtLength;
    let currentLength = 0;
    while (currentLength < totalLength) {
        pointAtLength = this.getPointAtLength(currentLength);
        if (GeometryUtils.isPointInPoly(localRectAsPolygon, pointAtLength))
            return true;
        currentLength += 3;
    }

    return false;
};

// ritorna un array di punti: [ {x,y,smooth} , ...]
_.toPolygonVertices = function (pointList, unit = 1, curveResolutionFactor = .125) {
    pointList = pointList || this.getGeometryPointList({
        normalize: true
    });
    //pointList = pointList || this.getGeometryPointList();

    const vertexList = [];

    function cubicCurveToPolygon(resolutionFactor, start_x, start_y, x, y, ctrl1_x, ctrl1_y, ctrl2_x, ctrl2_y) {
        let ax,
        bx,
        cx,
        ay,
        by,
        cy,
        tSquared,
        tCubed,
        t;

        cx = 3.0 * (ctrl1_x - start_x);
        bx = 3.0 * (ctrl2_x - ctrl1_x) - cx;
        ax = x - start_x - cx - bx;

        cy = 3.0 * (ctrl1_y - start_y);
        by = 3.0 * (ctrl2_y - ctrl1_y) - cy;
        ay = y - start_y - cy - by;

        t = resolutionFactor;

        for (; t <= 1; t += resolutionFactor) {
            tSquared = t * t;
            tCubed = tSquared * t;
            vertexList.push({
                x: start_x + (ax * tCubed) + (bx * tSquared) + (cx * t),
                y: start_y + (ay * tCubed) + (by * tSquared) + (cy * t),
                smooth: true
            });
        }
    }

    function quadraticCurveToPolygon(resolutionFactor, start_x, start_y, x, y, ctrl1_x, ctrl1_y) {
        let ax,
        cx,
        ay,
        cy,
        t;

        cx = 2.0 * (ctrl1_x - start_x);
        ax = x - start_x;

        cy = 2.0 * (ctrl1_y - start_y);
        ay = y - start_y;

        t = resolutionFactor;

        for (; t <= 1; t += resolutionFactor) {
            vertexList.push({
                x: start_x + t * ((1 - t) * cx + t * ax),
                y: start_y + t * ((1 - t) * cy + t * ay),
                smooth: true
            });
        }
    }

    ////console.log('pointList',pointList);

    let previousSegment = null;

    // const unit = 100;

    let segment,
    i,
    max = pointList.length;
    for (i = 0; i < max; i++) {
        segment = pointList[i];

        if (segment.type === 'L') {
            vertexList.push({
                x: segment.x / unit,
                y: segment.y / unit
            });
        } else if (segment.type === 'C') {
            cubicCurveToPolygon(curveResolutionFactor, previousSegment.x / unit, previousSegment.y / unit, segment.x / unit, segment.y / unit, segment.controlPt1.x / unit, segment.controlPt1.y / unit, segment.controlPt2.x / unit, segment.controlPt2.y / unit);
        } else if (segment.type === 'Q') {
            quadraticCurveToPolygon(curveResolutionFactor, previousSegment.x / unit, previousSegment.y / unit, segment.x / unit, segment.y / unit, segment.controlPt1.x / unit, segment.controlPt1.y / unit);
        } else if (segment.type === 'M') {
            vertexList.push({
                x: segment.x / unit,
                y: segment.y / unit
            });
        } else if (segment.type === 'Z') {
            if ((previousSegment.type === 'C') || (previousSegment.type === 'Q')) {
                const firstSegment = pointList[1]; // successivo al moveTo
                if ((firstSegment.type === 'C') || (firstSegment.type === 'Q')) {
                    vertexList[0].smooth = true;
                }
            }
        }
        previousSegment = segment;
    }

    return vertexList;
};

_.getOffsetPathAsPolygon = function (_offset) {
    let d = '';
    const subPathList = this.getSubPathList();
    const max = subPathList.length;
    for (let i = 0; i < max; i++) {
        const polygonVertices = this.toPolygonVertices(subPathList[i].geometryPointList);
        const maxVertices = polygonVertices.length;
        const isClosed = subPathList[i].geometryPointList[subPathList[i].geometryPointList.length - 1].type === 'Z';
        const polygonOffset = GeometryUtils.getPolygonOffset(polygonVertices, _offset, isClosed);
        d += ' M' + polygonOffset[0].x + ' ' + polygonOffset[0].y;
        for (let iv = 1; iv < maxVertices; iv++)
            d += ' L' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
        if (isClosed)
            d += ' Z';
    }

    const pathResult = this.cloneNode();
    pathResult.setAttribute('d', d);
    return pathResult;
}

_.toPathPolygonWithControlPoints = function (pointList) {
    //pointList = pointList || this.getGeometryPointList({normalize:true});
    //pointList = pointList || this.getGeometryPointList();

    const vertexList = [];

    let previousSegment = null;
    let segment,
    i,
    max = pointList.length;
    for (i = 0; i < max; i++) {
        segment = pointList[i];

        if (segment.type === 'L') {
            vertexList.push({
                type: 'L',
                x: segment.x,
                y: segment.y
            });
        } else if (segment.type === 'C') {
            vertexList.push({
                type: 'Ctrl1',
                x: segment.controlPt1.x,
                y: segment.controlPt1.y
            });
            vertexList.push({
                type: 'Ctrl2',
                x: segment.controlPt2.x,
                y: segment.controlPt2.y
            });
            vertexList.push({
                type: 'C',
                x: segment.x,
                y: segment.y
            });
        } else if (segment.type === 'Q') {
            vertexList.push({
                type: 'Ctrl1',
                x: segment.controlPt1.x,
                y: segment.controlPt1.y
            });
            vertexList.push({
                type: 'Q',
                x: segment.x,
                y: segment.y
            });
        } else if (segment.type === 'M') {
            vertexList.push({
                type: 'M',
                x: segment.x,
                y: segment.y
            });
        } else if (segment.type === 'A') {
            vertexList.push({
                type: 'A',
                x: segment.x,
                y: segment.y,
                radius: segment.radius,
                rx: segment.rx,
                ry: segment.ry,
                largeArcFlag: segment.largeArcFlag,
                sweepFlag: segment.sweepFlag,
                angle: segment.angle
            });
        } else if (segment.type === 'Z') {}
        previousSegment = segment;
    }

    return vertexList;
};

// http://brunoimbrizi.com/unbox/2015/03/offset-curve/

_.getOffsetPath = function (_offset) {
    let d = '';
    const subPathList = this.getSubPathList();
    const max = subPathList.length;
    for (let i = 0; i < max; i++) {
        const polygonVertices = this.toPathPolygonWithControlPoints(subPathList[i].geometryPointList);
        const maxVertices = polygonVertices.length;
        const isClosed = subPathList[i].geometryPointList[subPathList[i].geometryPointList.length - 1].type === 'Z';
        const polygonOffset = GeometryUtils.getPolygonOffset(polygonVertices, _offset, isClosed);

        let currentPt;
        for (let iv = 0; iv < maxVertices; iv++) {
            currentPt = polygonVertices[iv];
            if (currentPt.type === 'M') {
                d += ' M' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
            } else if (currentPt.type === 'L') {
                d += ' L' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
            } else if (currentPt.type === 'A') {
                d += ' A' + (currentPt.rx + _offset) + ' ' + (currentPt.ry + _offset) + ' ' + currentPt.angle + ' ' + currentPt.largeArcFlag + ' ' + currentPt.sweepFlag + ' ' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
            } else if (currentPt.type === 'C') {
                d += ' C' + polygonOffset[iv - 2].x + ' ' + polygonOffset[iv - 2].y + ' ' + polygonOffset[iv - 1].x + ' ' + polygonOffset[iv - 1].y + ' ' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
            } else if (currentPt.type === 'Q') {
                d += ' Q' + polygonOffset[iv - 1].x + ' ' + polygonOffset[iv - 1].y + ' ' + polygonOffset[iv].x + ' ' + polygonOffset[iv].y;
            }
        }
        if (isClosed)
            d += ' Z';
    }

    return d;

    // const pathResult = this.cloneNode();
    // pathResult.setAttribute('d', d );
    // return pathResult;
}

_.reduceCurves = function (_path) {
    _path = _path || this;
    const pointListResult = [];
    //const pointList = _path.getGeometryPointList();
    const pointList = _path.getGeometryPointList({
        normalize: true
    }); // per il momento devo convertire gli archi in curve a causa di bug o migliore interpretazione del problema dell'offset
    const max = pointList.length;
    let currentPoint;
    for (let i = 0; i < max; i++) {
        currentPoint = pointList[i];
        if (currentPoint.type === 'C') {
            const previousPoint = pointList[i - 1];
            const curve = new Bezier(previousPoint, currentPoint.controlPt1, currentPoint.controlPt2, currentPoint);
            const reduced = curve.reduce();
            if (reduced.length > 0) {
                reduced.forEach((c, i) => {
                    const newCurvePoint = _path.createGeometryPoint_CURVETO_CUBIC(c.points[1].x, c.points[1].y, c.points[2].x, c.points[2].y, c.points[3].x, c.points[3].y);
                    pointListResult.push(newCurvePoint);
                });
            } else {
                pointListResult.push(currentPoint);
            }
        } else if (currentPoint.type === 'Q') {
            const previousPoint = pointList[i - 1];
            const curve = new Bezier(previousPoint, currentPoint.controlPt1, currentPoint.x, currentPoint.y);
            const reduced = curve.reduce();
            if (reduced.length > 0) {
                reduced.forEach((c, i) => {
                    const newCurvePoint = _path.createGeometryPoint_CURVETO_QUADRATIC(c.points[1].x, c.points[1].y, c.points[2].x, c.points[2].y);
                    pointListResult.push(newCurvePoint);
                });
            } else {
                pointListResult.push(currentPoint);
            }
        } else if (currentPoint.type === 'A') {
            if (currentPoint.rx === currentPoint.ry) {
                if (!currentPoint.radius) {
                    const previousPoint = pointList[i - 1];
                    const arcCenter = GeometryUtils.getArcCenter(previousPoint.x, previousPoint.y, currentPoint.x, currentPoint.y, currentPoint.rx, currentPoint.ry, currentPoint.angle, currentPoint.largeArcFlag, currentPoint.sweepFlag);
                    currentPoint.radius = currentPoint.rx = currentPoint.ry = arcCenter.getDistanceFromPoint(currentPoint);
                }
            }
            pointListResult.push(currentPoint);
        } else {
            pointListResult.push(currentPoint)
        }
    }

    return pointListResult;
}

// _.getOffsetPath = function ( _offset )
// {
//     let d='';
//     const subPathList = this.getSubPathList();
//     const max = subPathList.length;
//     for( let i = 0; i < max; i++)
//     {
//         const geometryPointList = subPathList[i].geometryPointList;
//         const maxPoints = geometryPointList.length;
//         const polyBezier = new PolyBezier(  );
//         for(let ip=0;ip<maxPoints-1;ip++)
//         {
//             const p1 = geometryPointList[ip];
//             const p2 = geometryPointList[ip+1];
//
//
//             if(p2.type==='C')
//             {
//                 const curve = new Bezier( p1.x, p1.y, p2.controlPt1.x, p2.controlPt1.y ,  p2.controlPt2.x, p2.controlPt2.y, p2.x, p2.y );
//                 polyBezier.addCurve(curve);
//             }else {
//                //console.log('punto da convertire:',p2);
//             }
//
//         }
//
//         const polyBezierOffset = polyBezier.offset( _offset );
//
//         polyBezierOffset.curves.forEach((c,idx) => {
//             d+=c.toSVG();
//         });
//
//        //console.log(polyBezier);
//
//     }
//
//     const pathResult = this.cloneNode();
//     pathResult.setAttribute('d', d );
//     return pathResult;
// }


_.toSVGPathElement = function () {
    if (isNaN(this.getTransform().matrix.e))
        this.getTransform().matrix.identity(); // sistema un bag della versione 6.1
    return this.cloneNode(true);
};

_ = SVGGElement.prototype;

_.getEditableGeometryPointList = function () {
    console.log('this.dataset', this.dataset);
    //if(this.isLinearElement())
    if (this.dataset.objectId && OBJECTS[this.dataset.objectId].type === 'linear-object') {
        // const objectController = OBJECTS[ this.dataset.objectId ];
        // const properties = objectController.getProperties( this );
        const objectController = this.getObjectController();
        const properties = objectController.getProperties();
        const geometryPointList = [];
        geometryPointList.push(SVGUtils.createSVGPoint(0, 0));
        geometryPointList.push(SVGUtils.createSVGPoint(properties.width, 0));
        geometryPointList.push(SVGUtils.createSVGPoint(properties.width / 2, properties.height));
        // geometryPointList.push( SVGUtils.createSVGPoint( this.dataset.width, 0 ) );
        // geometryPointList.push( SVGUtils.createSVGPoint( this.dataset.width/2, this.dataset.height ) );

        geometryPointList[0].ownerShapeElement = this;
        geometryPointList[1].ownerShapeElement = this;
        geometryPointList[2].ownerShapeElement = this;
        geometryPointList[0].id = 0;
        geometryPointList[1].id = 1;
        geometryPointList[2].id = 2;
        geometryPointList[0].name = 'start';
        geometryPointList[1].name = 'end';
        geometryPointList[2].name = 'height';

        return this.getTransformToElement(this.parentElement).transformPointList(geometryPointList, true);
        //return geometryPointList;
    }
};

// _.isLinearElement = function()
// {
// 	//if(this.dataset.objectId && this.dataset.type === 'linear-object')
// 	if(this.dataset.type==='object' && this.dataset.objectType==='linear-object')
// 	{
// 		return true;
// 	}
//
// 	return false;
//
// }


_.getLocalBBox = function () {
    if (this.dataset.objectId) {
        // const objectController = OBJECTS[ this.dataset.objectId ];
        // const properties = objectController.getProperties( this );

        const objectController = this.getObjectController();
        const properties = objectController.getProperties();

        let bbox = {};
        bbox.x = 0;
        bbox.y = 0;

        bbox.width = properties.width;
        bbox.height = properties.height;
        // bbox.width=parseFloat(this.dataset.width);
        // bbox.height=parseFloat(this.dataset.height);
        bbox.center = {
            x: bbox.x + (bbox.width / 2),
            y: bbox.y + (bbox.height / 2)
        };
        bbox.min = {
            x: bbox.x,
            y: bbox.y
        };
        bbox.max = {
            x: bbox.x + bbox.width,
            y: bbox.y + bbox.height
        };
        return bbox;
    }

    let bbox = this.getBBox();

    if (this.hasAttribute('clip-path')) {
        const clipPath = this.querySelector('clipPath');
        if (clipPath.getBBox) {
            bbox = clipPath.getBBox(); // chrome
            if (bbox.width === 0)
                bbox = clipPath.parentElement.getBBox(); // safari
        } else {
            bbox = clipPath.parentElement.getBBox(); // firefox
        }
    }

    bbox.center = {
        x: bbox.x + (bbox.width / 2),
        y: bbox.y + (bbox.height / 2)
    };
    bbox.min = {
        x: bbox.x,
        y: bbox.y
    };
    bbox.max = {
        x: bbox.x + bbox.width,
        y: bbox.y + bbox.height
    };
    return bbox;
};

_.__getGlobalBBox = SVGElement.prototype.getGlobalBBox;

_.getGlobalBBox = function () {

    if (this.hasAttribute('clip-path')) {
        const clipPath = this.querySelector('clipPath');
        if (clipPath)
            return clipPath.getGlobalBBox();
    }

    // else if(this.hasAttribute('mask'))
    // {
    // 	var mask = this.querySelector('mask');
    // 	console.log('getGlobalBBox',mask);
    // 	if(mask) return mask.getGlobalBBox();
    // }

    return this.__getGlobalBBox();
};

_.normalizeScale = function (_options) {
    let validParentNode = this.parentElement;
    if (validParentNode instanceof SVGMaskElement)
        validParentNode = validParentNode.parentElement;
    //if( validParentNode instanceof SVGMaskElement || validParentNode instanceof SVGClipPathElement ) validParentNode = validParentNode.parentElement;
    const matrixInParent = validParentNode.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
    this.getTransform().setMatrix(this.getTransform().matrix.identity().translate(matrixInParent.e, matrixInParent.f).rotate(this.normalizationData.localRotation));

    // if(this.dataset.objectId)
    // {
    // 	const objectController = OBJECTS[ this.dataset.objectId ];
    // 	if( objectController )
    // 	{
    // 		const scale = matrixInParent.getScale();
    // 		this.scaleAttributeNumber( 'data-width' , scale.x );
    // 		this.scaleAttributeNumber( 'data-height' , scale.y );
    // 		objectController.update( this );
    // 	}
    // 	return;
    // }


    if (this.dataset.objectId && OBJECTS[this.dataset.objectId]) {
        const matrix = validParentNode.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);
        const scale = matrix.getScale();
        // const objectController = OBJECTS[ this.dataset.objectId ];
        // objectController.normalizeScale( this , scale.x , scale.y , _options.effectScale );
        const objectController = this.getObjectController();
        objectController.normalizeScale(scale.x, scale.y, _options.effectScale);
        return;
    }

    const max = this.childNodes.length;
    for (let i = 0; i < max; i++)
        if (this.childNodes[i].normalizeScale)
            this.childNodes[i].normalizeScale(_options);
};

// _.normalizeScale = function( _options )
// {
// 	let validParentNode = this.parentNode;
// 	if(validParentNode instanceof SVGMaskElement) validParentNode = validParentNode.parentNode;
// 	const matrixInParent = validParentNode.screenMatrixToLocalMatrix(  this.normalizationData.storedScreenMatrix  );
// 	this.getTransform().setMatrix( this.getTransform().matrix.identity().translate( matrixInParent.e, matrixInParent.f ).rotate( this.normalizationData.localRotation ) );
//
//
// 	if(this.dataset.objectPlugin)
// 	{
// 		const plugin = PLUGINS[ this.dataset.objectPlugin ];
// 		if( plugin )
// 		{
// 			const scale = matrixInParent.getScale();
// 			this.scaleAttributeNumber( 'data-width' , scale.x );
// 			this.scaleAttributeNumber( 'data-height' , scale.y );
// 			plugin.onPluginResize( this );
// 		}
// 		return;
// 	}
//
//
// 	const max = this.childNodes.length;
// 	for(let i = 0; i < max; i++) if(this.childNodes[i].normalizeScale) this.childNodes[i].normalizeScale( _options ) ;
// };


// la clip path non deve essere trasformata
_.getTransformableChildren = function () {
    const result = [];
    for (let i = 0; i < this.children.length; i++) {
        //if(this.children[i].nodeName==='clipPath')
        console.log('getTransformableChildren', this.children[i].nodeName);
        if (this.children[i].nodeName === 'clipPath' || this.children[i].nodeName === 'mask') {
            const subChildren = this.children[i].children;
            for (let ic = 0; ic < subChildren.length; ic++)
                result.push(subChildren[ic]);
        } else {
            result.push(this.children[i])
        }
    }

    return result;
};

_.setOrigin = function (_workspaceX, _workspaceY) {
    const pt = this.globalToLocal(_workspaceX, _workspaceY);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(pt.x, pt.y));
    this.setAttribute('x',  - (pt.x));
    this.setAttribute('y',  - (pt.y));

    const translateMatrix = SVGUtils.createSVGMatrix().translate(-pt.x, -pt.y);

    const transformableChildren = this.getTransformableChildren();
    for (let i = 0; i < transformableChildren.length; i++) {
        if (transformableChildren[i].getTransform)
            transformableChildren[i].getTransform().setMatrix(translateMatrix.multiply(transformableChildren[i].getTransform().matrix));
    }

    // for(let i=0; i<this.children.length; i++ )
    // {
    // 	if(this.children[i].nodeName==='clipPath')
    // 	{
    // 		const clipPathChildren = this.children[i].children;
    // 		for(let ic=0; ic<clipPathChildren.length; ic++ ) clipPathChildren[ic].getTransform().setMatrix(  translateMatrix.multiply(clipPathChildren[ic].getTransform().matrix) );
    // 	} else {
    // 		this.children[i].getTransform().setMatrix(  translateMatrix.multiply(this.children[i].getTransform().matrix) );
    // 	}
    // }
};

_.resetOrigin = function () {
    const localBox = this.getLocalBBox();
    const center = SVGUtils.createSVGPoint(localBox.center.x, localBox.center.y);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x, center.y));
    this.setAttribute('x',  - (center.x));
    this.setAttribute('y',  - (center.y));

    const translateMatrix = SVGUtils.createSVGMatrix().translate(-center.x, -center.y);

    const transformableChildren = this.getTransformableChildren();
    for (let i = 0; i < transformableChildren.length; i++) {
        transformableChildren[i].getTransform().setMatrix(translateMatrix.multiply(transformableChildren[i].getTransform().matrix));
    }

    // for(let i=0; i<this.children.length; i++ )
    // {
    // 	this.children[i].getTransform().setMatrix(  translateMatrix.multiply(this.children[i].getTransform().matrix) );
    // }
};

_.bakeTransform = function () {
    const bbox = this.getGlobalBBox();
    const centerInParent = this.parentElement.globalToLocal(bbox.center.x, bbox.center.y);
    const group = SVGUtils.createGroup(centerInParent.x, centerInParent.y);
    this.parentElement.appendChild(group);

    const transformableChildren = this.getTransformableChildren();
    for (let i = 0; i < transformableChildren.length; i++) {
        transformableChildren[i].getTransform().setMatrix(transformableChildren[i].getTransformToElement(group).clone());
    }

    // for(let i=0; i<this.children.length; i++ )
    // {
    // 	this.children[i].getTransform().setMatrix(  this.children[i].getTransformToElement(group).clone() );
    // }

    this.getTransform().setMatrix(group.getTransform().matrix.clone());
    group.remove();
};

// _.normalizeScale = function( _options )
// {
// 	var validParentNode = this.parentNode;
// 	if(validParentNode instanceof SVGMaskElement) validParentNode = validParentNode.parentNode;
// 	var matrixInParent = validParentNode.screenMatrixToLocalMatrix(  this.normalizationData.storedScreenMatrix  );
// 	this.getTransform().setMatrix( this.getTransform().matrix.identity().translate( matrixInParent.e, matrixInParent.f ).rotate( this.normalizationData.localRotation ) );
//
// 	var max = this.childNodes.length;
// 	for(var i = 0; i < max; i++) if(this.childNodes[i].normalizeScale) this.childNodes[i].normalizeScale( _options ) ;
// };

_.toSVGPathElement = function () {
    return null;
};

/*
_.__cloneNode = _.cloneNode;

_.cloneNode = function ( _depth ){
var clonedNode = this.__cloneNode( false );

if(_depth){
// cosi facendo vengono chiamati cloneNode dei figli che potranno creare versioni customizzate
for(var i=0;i<this.children.length;i++) clonedNode.appendChild( this.children[i].cloneNode(_depth) );
}

return clonedNode;
};

 */

_ = SVGImageElement.prototype;

// _.findLinearSegmentAtPoint = function( _workspaceX , _workspaceY , _snapDistance  ) {
// 	return null;
// };


_.initializeWithOriginalSize = function (_callback) {
    var imageElement = this;
    var img = new Image();
    img.src = imageElement.getAttributeNS(SVGSVGElement.XLINK_NS, 'href');

    img.onload = function () {

        imageElement.setAttribute('width', this.naturalWidth);
        imageElement.setAttribute('height', this.naturalHeight);
        if (_callback)
            _callback();
    }
};

_.resetOrigin = function () {
    const localBox = this.getLocalBBox();
    const center = SVGUtils.createSVGPoint(localBox.center.x, localBox.center.y);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x, center.y));
    this.setAttribute('x',  - (center.x));
    this.setAttribute('y',  - (center.y));
};

_.setOrigin = function (_workspaceX, _workspaceY) {
    const pt = this.globalToLocal(_workspaceX, _workspaceY);
    const center = SVGUtils.createSVGPoint(parseFloat(this.getAttribute('x')) || 0, parseFloat(this.getAttribute('y')) || 0);
    this.getTransform().setMatrix(this.getTransform().matrix.translate(pt.x, pt.y));
    this.setAttribute('x', center.x - pt.x);
    this.setAttribute('y', center.y - pt.y);
};

_.resizeTo = function (_width, _height) {
    const canvas = document.createElement("canvas");
    canvas.width = _width;
    canvas.height = _height;
    const ctx = canvas.getContext("2d");
    //ctx.drawImage( this.getAttributeNS(SVGElement.XLINK_NS, 'href') , 0, 0, parseInt(this.getAttribute('width')), parseInt(this.getAttribute('height')), 0, 0, canvas.width, canvas.height);
    ctx.drawImage(this, 0, 0, parseInt(this.getAttribute('width')), parseInt(this.getAttribute('height')), 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL("image/png");
    //this.setAttributeNS( SVGSVGElement.XLINK_NS , 'href',  canvas.toDataURL( "image/png" )  );
}

SVGGradientElement.prototype.getTransform = function () {
    if (this.gradientTransform.baseVal.numberOfItems === 0) {
        var newTransform = SVGUtils.createSVGTransformFromMatrix(SVGUtils.createSVGMatrix());
        this.gradientTransform.baseVal.appendItem(newTransform);
    }

    return this.gradientTransform.baseVal.getItem(0);
};

SVGLinearGradientElement.prototype.copyPointsTo = function (_targetGradient) {
    if (_targetGradient instanceof SVGRadialGradientElement) {
        var x = this.x2.baseVal.value - this.x1.baseVal.value;
        var y = this.y2.baseVal.value - this.y1.baseVal.value;
        var r = Math.sqrt(x * x + y * y) / 2;
        var cx = this.x1.baseVal.value + (x / 2);
        var cy = this.y1.baseVal.value + (y / 2);

        _targetGradient.cx.baseVal.value = cx;
        _targetGradient.cy.baseVal.value = cy;
        _targetGradient.r.baseVal.value = r;
    } else if (_targetGradient instanceof SVGLinearGradientElement) {
        _targetGradient.x1.baseVal.value = this.x1.baseVal.value;
        _targetGradient.y1.baseVal.value = this.y1.baseVal.value;
        _targetGradient.x2.baseVal.value = this.x2.baseVal.value;
        _targetGradient.y2.baseVal.value = this.y2.baseVal.value;
    }
};

SVGRadialGradientElement.prototype.copyPointsTo = function (_targetGradient) {
    if (_targetGradient instanceof SVGRadialGradientElement) {
        _targetGradient.cx.baseVal.value = this.cx.baseVal.value;
        _targetGradient.cy.baseVal.value = this.cy.baseVal.value;
        _targetGradient.r.baseVal.value = this.r.baseVal.value;
    } else if (_targetGradient instanceof SVGLinearGradientElement) {
        var x1 = this.cx.baseVal.value - this.r.baseVal.value;
        var y1 = this.cy.baseVal.value - this.r.baseVal.value;
        var x2 = this.cx.baseVal.value + this.r.baseVal.value;
        var y2 = this.cy.baseVal.value + this.r.baseVal.value;

        _targetGradient.x1.baseVal.value = x1;
        _targetGradient.y1.baseVal.value = y1;
        _targetGradient.x2.baseVal.value = x2;
        _targetGradient.y2.baseVal.value = y2;
    }
};

SVGGradientElement.prototype.initDefaultPoints = function () {
    this.setAttribute('gradientUnits', 'objectBoundingBox');

    if (this.nodeName == 'linearGradient') {
        this.setAttribute('x1', '0');
        this.setAttribute('y1', '0.5');
        this.setAttribute('x2', '1');
        this.setAttribute('y2', '.5');

    } else {
        this.setAttribute('cx', '0.5');
        this.setAttribute('cy', '0.5');
        this.setAttribute('r', '.5');
    }
};

SVGGradientElement.prototype.setPointsFromBBox = function (_bbox) {
    if (this instanceof SVGRadialGradientElement) {
        this.cx.baseVal.value = _bbox.center.x;
        this.cy.baseVal.value = _bbox.center.y;
        this.r.baseVal.value = _bbox.width / 2;
    } else if (this instanceof SVGLinearGradientElement) {
        this.x1.baseVal.value = _bbox.center.x;
        this.y1.baseVal.value = _bbox.min.y;
        this.x2.baseVal.value = _bbox.center.x;
        this.y2.baseVal.value = _bbox.max.y;
    }
};

SVGGradientElement.prototype.insertNewStopColor = function (_offset, _colorValue, _opacity) {

    var newStopColorNode = SVGUtils.createSVGStopColor(_offset, '#FFFFFF', '1');

    this.appendChild(newStopColorNode);

    this.sortStopColors();

    if (!_colorValue) {
        var previousStopColor,
        previousStopColor_offset,
        previousStopColor_rgba,
        nextStopColor,
        nextStopColor_offset,
        nextStopColor_rgba;

        if (newStopColorNode.previousElementSibling) {
            previousStopColor = newStopColorNode.previousElementSibling;
            previousStopColor_rgba = ColorUtils.parseColorString(previousStopColor.getAttribute('stop-color'));
            previousStopColor_rgba.a = parseFloat(previousStopColor.getAttribute('stop-opacity') || 1);
            previousStopColor_offset = parseFloat(previousStopColor.getAttribute('offset'));
        } else {
            previousStopColor_rgba = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
            previousStopColor_offset = 0;
        }

        if (newStopColorNode.nextElementSibling) {
            nextStopColor = newStopColorNode.nextElementSibling;
            nextStopColor_rgba = ColorUtils.parseColorString(nextStopColor.getAttribute('stop-color'));
            nextStopColor_rgba.a = parseFloat(nextStopColor.getAttribute('stop-opacity') || 1);
            nextStopColor_offset = parseFloat(nextStopColor.getAttribute('offset'));
        } else {
            nextStopColor_rgba = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
            nextStopColor_offset = 1;
        }

        var amountToMix = (_offset - previousStopColor_offset) / (nextStopColor_offset - previousStopColor_offset);

        var r = ColorUtils.mixColorChannel(previousStopColor_rgba.r, nextStopColor_rgba.r, amountToMix);
        var g = ColorUtils.mixColorChannel(previousStopColor_rgba.g, nextStopColor_rgba.g, amountToMix);
        var b = ColorUtils.mixColorChannel(previousStopColor_rgba.b, nextStopColor_rgba.b, amountToMix);
        var a = ColorUtils.mixColorChannel(previousStopColor_rgba.a, nextStopColor_rgba.a, amountToMix);

        newStopColorNode.setAttribute('stop-color', ColorUtils.rgbToHex(r, g, b));
        newStopColorNode.setAttribute('stop-opacity', a);
        newStopColorNode.setAttribute('fill', ColorUtils.rgbToHex(r, g, b));

    } else {

        newStopColorNode.setAttribute('stop-color', _colorValue);
        newStopColorNode.setAttribute('stop-opacity', _opacity);
    }

    return newStopColorNode;
};

SVGGradientElement.prototype.sortStopColors = function () {
    var sortedArray = [];
    var id,
    max = this.children.length;
    for (id = 0; id < max; id++)
        sortedArray.push(this.children[id]);
    sortedArray.sort(function (a, b) {
        return a.offset.baseVal - b.offset.baseVal
    });
    this.removeChildren();
    for (id = 0; id < max; id++)
        this.appendChild(sortedArray[id]);
};

SVGGradientElement.prototype.copyStopColorsTo = function (_targetGradient) {
    var id,
    max = this.children.length;
    _targetGradient.removeChildren();
    for (id = 0; id < max; id++)
        _targetGradient.appendChild(this.children[id].cloneNode(true));
};

/*  STOP ELEMENT */

SVGStopElement.prototype.stylePropertiesToAttributes = function () {

    const result = [];

    if (this.style['stop-opacity']) {
        this.setAttribute('stop-opacity', this.style['stop-opacity']);
        result.push({
            description: 'style to attribute',
            attribute: 'stop-opacity'
        });
    }

    if (this.style['stop-color']) {
        var rgba = ColorUtils.parseColorString(this.style['stop-color']);
        this.setAttribute('stop-color', ColorUtils.rgbToHex(rgba.r, rgba.g, rgba.b));
        if (rgba.a !== 1)
            this.setAttribute('stop-opacity', rgba.a);
        result.push({
            description: 'style to attribute',
            attribute: 'stop-color'
        });
    }

    this.removeAttribute('style');

    return result;

};

// SVGStopElement.prototype.stylePropertiesToAttributes = function() {
// 	var style = this.style;
//
//
// 	if (style['stop-opacity'])
// 	{
// 		this.setAttribute('stop-opacity' , style['stop-opacity'] );
// 	}
//
// 	if (style['stop-color'])
// 	{
// 		var rgba = ColorUtils.parseColorString(style['stop-color']);
// 		console.log('stop-color' , rgba );
// 		this.setAttribute('stop-color' ,  ColorUtils.rgbToHex( rgba.r,rgba.g,rgba.b ) );
// 		if(rgba.a!=1)this.setAttribute('stop-opacity' ,  rgba.a );
// 	}
//
// 	  this.style.removeProperty('stop-color');
// 	 this.style.removeProperty('stop-opacity');
// };


//
// SVGClipPathElement.prototype.normalizeScale =  SVGGElement.prototype.normalizeScale = function( _options )
// {
// 	var validParentNode = this.parentNode;
// 	if(validParentNode instanceof SVGMaskElement) validParentNode = validParentNode.parentNode;
//
// 	var newLocalPos = validParentNode.globalToLocal( this.normalizationData.globalPosition.x ,   this.normalizationData.globalPosition.y);
//   	var localMatrix = this.getTransform().matrix.identity().rotate( this.normalizationData.localRotation );
//  	this.getTransform().setMatrix( this.ownerSVGElement.createSVGMatrix().translate( newLocalPos.x, newLocalPos.y ).multiply( localMatrix ) );
// 	var max = this.childNodes.length;
// 	for(var i = 0; i < max; i++) if(this.childNodes[i].normalizeScale) this.childNodes[i].normalizeScale( _options ) ;
// };


SVGClipPathElement.prototype.normalizeScale = SVGGElement.prototype.normalizeScale;

SVGClipPathElement.prototype.toSVGPathElement = SVGGElement.prototype.toSVGPathElement;

_ = SVGClipPathElement.prototype;

// fix per firefox
_.prepareToNormalizeScale = function (_options) {
    this.normalizationData = this.parentNode.normalizationData;
    const max = this.childNodes.length;
    for (let i = 0; i < max; i++)
        if (this.childNodes[i].prepareToNormalizeScale)
            this.childNodes[i].prepareToNormalizeScale(_options);
};
// fix per firefox
_.getScreenCTM = function (_options) {
    return this.parentElement.getScreenCTM();
};

_ = SVGMaskElement.prototype;

_.getScreenCTM = function (_options) {
    return this.parentNode.getScreenCTM();
};

_.prepareToNormalizeScale = function (_options) {
    this.normalizationData = this.parentNode.normalizationData;
    const max = this.childNodes.length;
    for (let i = 0; i < max; i++)
        if (this.childNodes[i].prepareToNormalizeScale)
            this.childNodes[i].prepareToNormalizeScale(_options);
};

// un generico elemento grafico
_.normalizeScale = function (_options) {
    const max = this.childNodes.length;
    for (let i = 0; i < max; i++)
        if (this.childNodes[i].normalizeScale)
            this.childNodes[i].normalizeScale(_options);
};

_ = SVGUseElement.prototype;

// DISABILITATO ResetTransform, sembra che ci sia un bag: quando x e y sono negative non prende più l'evento del mouse

// _.resetOrigin = function()
// {
//     return;
//
//     const localBox = this.getLocalBBox();
//     const center = SVGUtils.createSVGPoint(localBox.center.x, localBox.center.y);
//     this.getTransform().setMatrix(this.getTransform().matrix.translate(center.x,center.y));
//     this.setAttribute('x', -(center.x));
//     this.setAttribute('y', -(center.y));
// };


//
// _.getSnapPointList = function()
// {
//     const bbox = this.getBBox();
//     let min={},max={},center={};
//     min.x =  bbox.x;
//     min.y =  bbox.y;
//     max.x = bbox.x+bbox.width;
//     max.y =  bbox.y+bbox.height;
//     center.x= min.x+bbox.width/2;
//     center.y= min.y+bbox.height/2;
//
//     const pointList = [];
//
//     pointList.push( SVGUtils.createSVGPoint( min.x, min.y) );
//     pointList.push( SVGUtils.createSVGPoint( max.x, min.y) );
//     pointList.push( SVGUtils.createSVGPoint( max.x, max.y) );
//     pointList.push( SVGUtils.createSVGPoint( min.x, max.y) );
//
//     pointList.push( SVGUtils.createSVGPoint( center.x, min.y) );
//     pointList.push( SVGUtils.createSVGPoint( max.x, center.y) );
//     pointList.push( SVGUtils.createSVGPoint( center.x, max.y) );
//     pointList.push( SVGUtils.createSVGPoint( min.x, center.y) );
//
//     pointList.push( SVGUtils.createSVGPoint( center.x, center.y) );
//
//
//     return pointList;
// };

/*_.getSnapPointList = function()
{
return [];
};*/

// _.findLinearSegmentAtPoint = function( _workspaceX , _workspaceY , _snapDistance  )
// {
//     return null;

/*
// questo potrebbe anche andare ma potrebbe essere più interessante entrare direttamente nel symbol
const scale = this.getScreenCTM().getScale(); // ricavo dalla matrice globale di this la scala globale
_snapDistance /= (Math.sqrt(scale.x * scale.x + scale.y * scale.y) / Math.sqrt(2));

const localPoint = this.globalToLocal( _workspaceX , _workspaceY );
console.log('this _snapDistance' , _snapDistance );
console.log('localPoint' , localPoint );
// per utilità creo questi punti che mi saranno utili per la costruzione delle linee usate per il successivo hit test poligono con lati del bbox locale
const bbox = this.getBBox();
let min={},max={};
min.x =  bbox.x;
min.y =  bbox.y;
max.x = bbox.x+bbox.width;
max.y =  bbox.y+bbox.height;

let pointOnLine;

console.log('la linea up' , localPoint );

pointOnLine = CoordsUtils.isPointOnLine( {x:min.x , y:min.y}, {x:max.x , y:min.y} , localPoint , _snapDistance , true );// la linea up
console.log('la linea up' , localPoint );
if(pointOnLine) return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:1, pt1: SVGUtils.createSVGPoint(min.x,min.y), pt2:SVGUtils.createSVGPoint(max.x,min.y)} };

pointOnLine = CoordsUtils.isPointOnLine( {x:max.x , y:min.y}, {x:max.x , y:max.y} , localPoint , _snapDistance , true );// la linea right
console.log('// la linea right' , localPoint );
if(pointOnLine) return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:2, pt1: SVGUtils.createSVGPoint(max.x,min.y), pt2:SVGUtils.createSVGPoint(max.x,max.y)} };

pointOnLine = CoordsUtils.isPointOnLine( {x:max.x , y:max.y}, {x:min.x , y:max.y} , localPoint , _snapDistance , true );// la linea bottom
console.log('// la linea bottom' , localPoint );
if(pointOnLine) return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:3, pt1: SVGUtils.createSVGPoint(max.x,max.y), pt2:SVGUtils.createSVGPoint(min.x,max.y)} };

pointOnLine = CoordsUtils.isPointOnLine( {x:min.x , y:max.y} , {x:min.x , y:min.y} , localPoint , _snapDistance , true );// la linea left
console.log('// la linea left' , localPoint );
if(pointOnLine) return { x:pointOnLine.x, y:pointOnLine.y, segment:{element:this, idSegment:4, pt1: SVGUtils.createSVGPoint(min.x,max.y), pt2:SVGUtils.createSVGPoint(min.x,min.y)} };

return null;

 */
// };


// _.findSnapToPoint = function( _workspaceX , _workspaceY , _snapDistance )
// {
//     if( !this.symbolRef ) this.symbolRef = document.querySelector( this.getAttribute('href') );
//
//     console.log('this.symbolRef' , this.symbolRef );
//     console.log('this.symbolRef.parentElement.parentElement' , this.symbolRef.parentElement.parentElement );
//
//
//     var localPoint = this.globalToLocal( _globalPoint.x , _globalPoint.y );
//
//
//     var svgDoc = this.symbolRef.parentElement.parentElement;
//
//     var hitRect = svgDoc.createSVGRect(); // creo il rect per l'hit test
//     hitRect.x = localPoint.x-2-DOCUMENT_OFFSET.x;
//     hitRect.y = localPoint.y-2-DOCUMENT_OFFSET.y;
//     hitRect.width = 4;
//     hitRect.height = 4;
//     var elementList = svgDoc.getIntersectionList(hitRect, null);
//    console.log('hit test insede symbol' , elementList );
//
//     // da finire
//
//
//     return null;
// };


_ = SVGForeignObjectElement.prototype;

_.normalizeScale = function (_options) {
    const newLocalMatrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);

    const scale = newLocalMatrix.getScale();

    this.scaleAttributeNumber('x', scale.x);
    this.scaleAttributeNumber('y', scale.y);

    this.scaleAttributeNumber('width', scale.x);
    this.scaleAttributeNumber('height', scale.y);
    const invertedScaledMatrix = this.ownerSVGElement.createSVGMatrix().scaleNonUniform(scale.x, scale.y).inverse();
    this.getTransform().setMatrix(newLocalMatrix.multiply(invertedScaledMatrix));

};

_.toSVGPathElement = function () {
    return SVGUtils.createRect(this.x.baseVal.value, this.y.baseVal.value, this.width.baseVal.value, this.height.baseVal.value).toSVGPathElement();
};

_.getGlobalBBox = function () {
    return this.getGlobalBBoxByLocalBox();
};

_.updateGeometry = function (x, y, w, h) {
    this.x.baseVal.value = x;
    this.y.baseVal.value = y;
    if (w)
        this.width.baseVal.value = w;
    if (h)
        this.height.baseVal.value = h;
};

_ = SVGTextElement.prototype;

_.createTextData = function (_text) {
    _text = _text || "";
    var textData = {};
    textData.text = _text;
    textData.style = new Array(textData.text.length);
    textData.drawInfo = new Array(textData.text.length);
    return textData;
};

_.initTextData = function (_text) {
    _text = _text || "";
    this.caretPosition = 0;
    this.textData = this.createTextData(_text);
};

_.getText = function () {
    if (!this.textData)
        return '';

    return this.textData.text;
};

_.getElementStyle = function (_element) {
    var style = {};

    style['opacity'] = _element.getAttribute('opacity') || this.getAttribute('opacity') || '1';
    style['fill'] = _element.getAttribute('fill') || this.getAttribute('fill') || '#000000';
    style['fill-opacity'] = _element.getAttribute('fill-opacity') || this.getAttribute('fill-opacity') || 1;
    style['stroke'] = _element.getAttribute('stroke') || this.getAttribute('stroke') || 'none';
    style['stroke-opacity'] = _element.getAttribute('stroke-opacity') || this.getAttribute('stroke-opacity') || 1;
    style['stroke-width'] = _element.getAttribute('stroke-width') || this.getAttribute('stroke-width') || 0;

    style['font-family'] = _element.getAttribute('font-family') || this.getAttribute('font-family') || 'arial';
    style['text-decoration'] = _element.getAttribute('text-decoration') || this.getAttribute('text-decoration') || 'none';
    style['font-size'] = _element.getAttribute('font-size') || this.getAttribute('font-size') || 12;
    style['text-align'] = _element.getAttribute('text-align') || this.getAttribute('text-align') || 'left';
    style['font-weight'] = _element.getAttribute('font-weight') || this.getAttribute('font-weight') || '';
    style['font-style'] = _element.getAttribute('font-style') || this.getAttribute('font-style') || '';
    style['letter-spacing'] = _element.getAttribute('letter-spacing') || this.getAttribute('letter-spacing') || 0;
    style['word-spacing'] = _element.getAttribute('word-spacing') || this.getAttribute('word-spacing') || 0;
    style['line-height'] = _element.getAttribute('line-height') || this.getAttribute('line-height') || 'normal';

    return style;
};

// _.setText = function ( _text )
// {
// 	if( !this.textData ) this.initTextData( _text );
// };

_.__getLocalBBox = SVGElement.prototype.getLocalBBox;

_.getLocalBBox = function () {
    if (this.getAttribute('data-type') !== "TextBox") {
        return this.__getLocalBBox();
    }

    let bbox = {};

    if (!this.hasAttribute('width') || !this.hasAttribute('height')) {
        bbox = this.getBBox();
        this.setAttribute('width', bbox.width);
        this.setAttribute('height', bbox.height);
    } else {

        bbox.x = 0;
        bbox.y = 0;
        bbox.width = parseFloat(this.getAttribute('width'));
        bbox.height = parseFloat(this.getAttribute('height'));
    }

    bbox.center = {
        x: bbox.x + (bbox.width / 2),
        y: bbox.y + (bbox.height / 2)
    };
    bbox.min = {
        x: bbox.x,
        y: bbox.y
    };
    bbox.max = {
        x: bbox.x + bbox.width,
        y: bbox.y + bbox.height
    };
    return bbox;
};

_.getGlobalBBox = function () {
    return this.getGlobalBBoxByLocalBox();
};

_.prepareToNormalizeScale = function (_options) {
    this.normalizationData = {};
    this.normalizationData.storedScreenMatrix = this.getScreenCTM();
    this.normalizationData.localRotation = this.getTransform().matrix.getRotation(); // salvo la rotazione
};

_.normalizeScale = function (_options) {
    const newLocalMatrix = this.parentElement.screenMatrixToLocalMatrix(this.normalizationData.storedScreenMatrix);

    const scale = newLocalMatrix.getScale();
    this.scaleAttributeNumber('x', scale.x);
    this.scaleAttributeNumber('y', scale.y);
    this.scaleAttributeNumber('width', scale.x);
    this.scaleAttributeNumber('height', scale.y);

    const strokeScale = Math.sqrt(scale.x * scale.x + scale.y * scale.y) / Math.sqrt(2);

    if (this.getAttribute('vector-effect') !== "non-scaling-stroke") {
        if (_options.scaleStrokeAndEffects)
            this.scaleStrokeAndEffects(strokeScale);
    }

    if (_options.scaleText || this.scaleText) {
        // this.scaleAttributeNumber( 'stroke-width' , strokeScale );
        this.scaleStrokeAndEffects(strokeScale);
        this.scaleAttributeNumber('font-size', strokeScale);
        this.scaleAttributeNumber('letter-spacing', strokeScale);
        this.scaleAttributeNumber('word-spacing', strokeScale);
        this.scaleAttributeNumber('line-height', strokeScale);

        //if(this.useRichText && this.textData.style )
        if ((this.dataset.useRichText === "true") && this.textData.style) {
            var styleList = this.textData.style;
            var style,
            i,
            max = styleList.length;
            for (i = 0; i < max; i++) {
                style = styleList[i];
                if (style) {
                    if (style['font-size'])
                        style['font-size'] = parseFloat(style['font-size']) * strokeScale;
                    if (style['letter-spacing'])
                        style['letter-spacing'] = parseFloat(style['letter-spacing']) * strokeScale;
                    if (style['word-spacing'])
                        style['word-spacing'] = parseFloat(style['word-spacing']) * strokeScale;
                    if (style['line-height'])
                        style['line-height'] = style['line-height'] * strokeScale;
                }
            }

        }
    }

    const invertedScaledMatrix = this.ownerSVGElement.createSVGMatrix().scaleNonUniform(scale.x, scale.y).inverse();
    this.getTransform().setMatrix(newLocalMatrix.multiply(invertedScaledMatrix));

    this.render();

    // var gradient = this.getGradient('fill');
    // if(gradient) this.normalizeGradientScale(gradient , _options);
    //
    // gradient = this.getGradient('stroke');
    // if(gradient)this.normalizeGradientScale(gradient , _options);

    if (_options.scaleStrokeAndEffects) {

        //this.scaleStrokeAndEffects(strokeScale);
        this.normalizeFillingScale('fill', _options);
        this.normalizeFillingScale('stroke', _options);
    }

};

_.intersectGlobalRect = SVGRectElement.prototype.intersectGlobalRect;

_.__cloneNode = _.cloneNode;

_.cloneNode = function (_depth) {
    var clonedNode = this.__cloneNode(_depth);
    //clonedNode.initCustomElement();
    if (this.textData)
        clonedNode.textData = this.getTextData();
    return clonedNode;
};

_.convertTextToPath = function (_onConvertCompleteCallback, _onFontLoadingError) {
    if (this.getAttribute('data-type') === 'TextOnPath') {
        return this.convertTextOnPathToPath(_onConvertCompleteCallback, _onFontLoadingError);
    } else {
        return this.convertTextBoxToPath(_onConvertCompleteCallback, _onFontLoadingError);
    }
};

_.convertTextBoxToPath = function (_onConvertCompleteCallback, _onFontLoadingError) {
    var self = this;
    var tspanList = this.querySelectorAll('tspan');

    var newGroup = SVGUtils.createGroup();
    newGroup.getTransform().setMatrix(this.getTransform().matrix.clone());

    function loadFont(_fontFileUrl, _callback) {
        opentype.load(_fontFileUrl, function (err, font) {
            if (err) {
                if (_onFontLoadingError)
                    _onFontLoadingError(newGroup);
            } else {
                _callback(font);
            }
        });
    }

    function convertTSpanElement(_tspan) {
        var x,
        y,
        charBBox;
        charBBox = _tspan.getStartPositionOfChar(0);
        x = charBBox.x;
        y = charBBox.y;

        var style = self.getElementStyle(_tspan);

        var fontFileUrl = window.GoogleFonts.getGoogleFontObjectByFamilyName(style['font-family']).files[window.GoogleFonts.getGoogleFontVariantNameByStyleAndWeight(style['font-style'], style['font-weight'])];

        function onFontLoaded(_font) {
            var opentypeRenderOptions = opentype.Font.prototype.defaultRenderOptions;
            opentypeRenderOptions.letterSpacing = parseFloat(style['letter-spacing']) || 0;
            opentypeRenderOptions.wordSpacing = parseFloat(style['word-spacing']) || 0;

            var glyphPaths = _font.getPaths(_tspan.textContent, x, y, style['font-size'], opentypeRenderOptions);
            for (var i = 0; i < glyphPaths.length; i++) {
                var newPath = SVGUtils.createPath();
                newPath.setAttribute('d', glyphPaths[i].toPathData(6));
                newPath.setGraphicAttributesByObjectProperties(style);
                newGroup.appendChild(newPath);
            }

            if (_tspan.nextElementSibling) {
                convertTSpanElement(_tspan.nextElementSibling);
            } else {
                if (_onConvertCompleteCallback)
                    _onConvertCompleteCallback(newGroup);
            }
        }

        loadFont(fontFileUrl, onFontLoaded);
    }

    convertTSpanElement(tspanList[0]);

    return newGroup;

};

_.convertTextOnPathToPath = function (_onConvertCompleteCallback, _onFontLoadingError) {
    var self = this;
    var tspanList = this.querySelectorAll('tspan');

    var newGroup = SVGUtils.createGroup();
    newGroup.getTransform().setMatrix(this.getTransform().matrix.clone());

    function loadFont(_fontFileUrl, _callback) {
        opentype.load(_fontFileUrl, function (err, font) {
            if (err) {
                if (_onFontLoadingError)
                    _onFontLoadingError(newGroup);
            } else {
                _callback(font);
            }
        });
    }

    function convertTSpanElement(_tspan) {
        var x,
        y,
        rotation,
        charBBox;
        var style = self.getElementStyle(_tspan);

        var fontFileUrl = window.GoogleFonts.getGoogleFontObjectByFamilyName(style['font-family']).files[window.GoogleFonts.getGoogleFontVariantNameByStyleAndWeight(style['font-style'], style['font-weight'])];

        function onFontLoaded(_font) {
            var opentypeRenderOptions = opentype.Font.prototype.defaultRenderOptions;
            opentypeRenderOptions.letterSpacing = parseFloat(style['letter-spacing']) || 0;
            opentypeRenderOptions.wordSpacing = parseFloat(style['word-spacing']) || 0;

            var maxChars = _tspan.getNumberOfChars();

            for (var ic = 0; ic < maxChars; ic++) {
                charBBox = _tspan.getStartPositionOfChar(ic);
                x = charBBox.x;
                y = charBBox.y;
                rotation = _tspan.getRotationOfChar(ic);

                var glyphPaths = _font.getPaths(_tspan.textContent[ic], 0, 0, style['font-size'], opentypeRenderOptions);
                for (var i = 0; i < glyphPaths.length; i++) {
                    var newPath = SVGUtils.createPath();
                    newPath.getTransform().setMatrix(SVGUtils.createSVGMatrix().translate(x, y).rotate(rotation));
                    newPath.setAttribute('d', glyphPaths[i].toPathData(3));
                    newPath.setGraphicAttributesByObjectProperties(style);
                    newGroup.appendChild(newPath);
                }
            }

            if (_tspan.nextElementSibling) {
                convertTSpanElement(_tspan.nextElementSibling);
            } else {
                if (_onConvertCompleteCallback)
                    _onConvertCompleteCallback(newGroup);
            }
        }

        loadFont(fontFileUrl, onFontLoaded);
    }

    convertTSpanElement(tspanList[0]);

    return newGroup;

};

// override del methodo di opentype.js

opentype.Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    var this$1 = this;

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    var kerningLookups;
    if (options.kerning) {
        var script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
    }
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this$1, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            // We should apply position adjustment lookups in a more generic way.
            // Here we only use the xAdvance value.
            var kerningValue = kerningLookups ?
                this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                this$1.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }

        if (options.wordSpacing && (glyph.name == 'space'))
            if (glyph.name == 'space')
                x += options.wordSpacing;

        // if (options.letterSpacing) {
        // 	x += options.letterSpacing * fontSize;
        // } else if (options.tracking) {
        // 	x += (options.tracking / 1000) * fontSize;
        // }
    }
    return x;
};

_ = SVGTextElement.prototype;

_.setTextSelectionAttribute = function (_attributeName, _attributeValue) {
    this.setTextStyleProperty(this.storedTextSelectionRange.textDataStartOffset, this.storedTextSelectionRange.textDataEndOffset, _attributeName, _attributeValue);
};

// implementare l'undo redo per lo style in un nuovo modo
_.onSetAttribute = function (_attributeName, _attributeValue) {

    // if(this.ownerSVGElement && (this.ownerSVGElement.parseState === true) )
    // {
    //     this.__setAttribute( _attributeName , _attributeValue );
    //    //console.log('( onSetAttribute this.ownerSVGElement',this.ownerSVGElement);
    //     return;
    // }


    if (this.hasAttribute('data-type'))
        //if( this.hasAttribute('data-type') )
    {

        //console.log('(this.ownerSVGElement',this.ownerSVGElement);

        // if( _attributeName === 'selected' )
        // {
        // 	this.__setAttribute( _attributeName , _attributeValue );
        // 	return;
        // }

        if ((this.dataset.useRichText === "true")) {
            if (this.storedTextSelectionRange && this.hasAttribute('contenteditable')) {
                this.setTextSelectionAttribute(_attributeName, _attributeValue);
            } else {
                // if( !this.textData )
                // {
                //     this.parseText();
                //     //this.renderRequest();
                //     //this.render();
                //
                // }

                this.setTextStyleProperty(0, this.textData.text.length, _attributeName, _attributeValue);
                this.__setAttribute(_attributeName, _attributeValue);
            }

        } else {
            this.__setAttribute(_attributeName, _attributeValue);
        }

        let timeout;
        if (this.isTextAttribute(_attributeName))
            timeout = 200;

        const self = this;
        this.renderRequest(timeout, function () {
            self.restoreTextSelectionRange();
        });

    } else {

        this.__setAttribute(_attributeName, _attributeValue);
    }

};

_.enterToTextEditing = function (_e) {
    if (!this.textData) {
        this.parseText();
        this.renderRequest();
    }

    if (this.firstElementChild && !this.firstElementChild.hasAttribute('data-start-offset'))
        this.renderRequest();

    this.__setAttribute('contenteditable', 'true');

    this.updateTextCursorPosition();
    this.updateDocumentDrawingProperties();
};

_.exitFromTextEditing = function (_e) {
    //console.log('onExitFromTextEditing');

    this.onEndInputAction();

    this.setCaretPosition(this.caretPosition);

    if (this.textData.text.length === 0) {
        this.textData = null;
        // this.setText('text');
        this.initTextData('text');
        activeApplication.activeDocument.createInsertTextDataUndoRedoActions(this, this.getTextData());
        //activeApplication.activeDocument.activePage.createInsertTextDataUndoRedoActions(this, this.getTextData());
        this.renderRequest();
    }

    this.removeAttribute('contenteditable');
    this.removeAttribute('tabindex');
    XOS.hideElement(activeApplication.workspace.TEXT_CURSOR);

    activeApplication.isTextEditing = false;
    activeApplication.currentEditableTextElement = null;
};

// _.onMouseDown = function (  _e )
// {
//     XOS.hideElement( activeApplication.workspace.TEXT_CURSOR );
// };
//
//
// _.onMouseMove = function (  _e )
// {
// 	/// MOLTO INTERESSANTE IL CODICE QUI SOTTO PER UN FUTURO AGGIORNAMENTO
// 	/*
// 	const activePage = activeApplication.activeDocument.activePage;
// 	activePage.createPenEvent( _e  );
// 	const localPoint = this.globalToLocal(activePage.currentPenEvent.workspaceX,activePage.currentPenEvent.workspaceY);
// 	console.log( 'clickedElement.getCharNumAtPosition()' , this.getCharNumAtPosition( localPoint ));
// 	 */
// };
//
//
// _.onMouseUp = function ( _e  )
// {
// 	/// MOLTO INTERESSANTE IL CODICE QUI SOTTO PER UN FUTURO AGGIORNAMENTO
// 	/*
// 	console.log('TEXT EDITING onMouseUp');
// 	const activePage = activeApplication.activeDocument.activePage;
// 	activePage.createPenEvent( _e  );
// 	const localPoint = this.globalToLocal(activePage.currentPenEvent.workspaceX,activePage.currentPenEvent.workspaceY);
// 	console.log( 'clickedElement.getCharNumAtPosition()' , this.getCharNumAtPosition( localPoint ));
// 	 */
//
// 		this.onEndInputAction();
// 		const self = this;
// 		setTimeout(function()
// 		{
// 			self.saveTextSelectionRange(_e);
// 			self.caretPosition = self.storedTextSelectionRange.textDataStartOffset;
// 			self.updateTextCursorPosition();
// 			self.updateDocumentDrawingProperties();
// 		},0);
//
// };

_.updateSelectionState = function () {
    this.onEndInputAction();

    this.saveTextSelectionRange();
    this.caretPosition = this.storedTextSelectionRange.textDataStartOffset;
    this.updateTextCursorPosition();
    this.updateDocumentDrawingProperties();

}

_.updateTextCursorPosition = function () {
    let charPosition,
    charRotation;
    const maxChars = this.getNumberOfChars();

    if (maxChars === 0) {
        charPosition = {
            x: 0,
            y: 0
        };
        charRotation = 0;
        this.lastDescent = 0;
    } else {

        if (this.caretPosition >= maxChars) {
            charPosition = this.getEndPositionOfChar(maxChars - 1);
            charRotation = this.getRotationOfChar(maxChars - 1);
        } else {
            charPosition = this.getStartPositionOfChar(this.caretPosition);
            charRotation = this.getRotationOfChar(this.caretPosition);
        }

        let charBBox;
        if (this.storedTextSelectionRange && this.storedTextSelectionRange.startContainer.nodeName === '#cdata-section') {
            charBBox = this.storedTextSelectionRange.startContainer.parentElement.getExtentOfChar(charPosition);
        } else {
            charBBox = this.getExtentOfChar(charPosition);
        }

        // Va bene solo per il text box in quanto bisognerebbe prima portare la rotazione a 0
        let descent = (charBBox.y + charBBox.height - charPosition.y);
        if (descent > 0)
            this.lastDescent = descent;
        let ascent = charBBox.height - this.lastDescent;

        /* cè un bag di SVG: per il secondo carattere delle righe successive alla prima non viene preso correttamente il bbox ( y ) */

        if (this.caretPosition >= maxChars) {
            if (this.textData.text[this.textData.text.length - 1] === '\n') {
                charPosition.x = 0;
                charPosition.y += charBBox.height;
            }
        }

        if (this.dataset.type === 'TextBox') {
            activeApplication.workspace.TEXT_CURSOR.setAttribute('y1', this.lastDescent);
            activeApplication.workspace.TEXT_CURSOR.setAttribute('y2',  - (charBBox.height - this.lastDescent));
        } else {
            activeApplication.workspace.TEXT_CURSOR.setAttribute('y1', 0);
            activeApplication.workspace.TEXT_CURSOR.setAttribute('y2', -charBBox.height);
        }

    }

    const cursorMatrix = this.getCTM().translate(charPosition.x, charPosition.y).rotate(charRotation);
    activeApplication.workspace.TEXT_CURSOR.getTransform().setMatrix(cursorMatrix);
    XOS.showElement(activeApplication.workspace.TEXT_CURSOR);
};

_.updateDocumentDrawingProperties = function () {
    let style;

    if (this.dataset.useRichText === "true") {
        style = this.getTextStyleAt(this.caretPosition);
    } else {
        style = this.getElementStyle(this);
    }

    activeApplication.activeDocument.showSelectionProperties();
};

_.onStartInputAction = function (_actionName) {
    this.inputAction = _actionName;
    this.inputActionTextData = this.createTextData("");
    this.inputActionTextData.offset = 0;
};

_.onInputAction = function (_e) {
    var inputText = _e.key;
    // var keyCode = _e.keyCode;
    var removedCharData;

    const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

    if (KEY_NAME === 'ESC') {
        this.onEndInputAction();
        activeApplication.setActiveTool('draw-edit-text-tool').endTextEditing();
        return;
    }

    if (KEY_NAME === 'HOME' || KEY_NAME === 'PAGEUP') {
        this.onEndInputAction();
        this.setCaretPosition(0);
        this.updateDocumentDrawingProperties();
        return;
    }

    if (KEY_NAME === 'END' || KEY_NAME === 'PAGEDOWN') {
        this.onEndInputAction();
        this.setCaretPosition(this.getNumberOfChars());
        this.updateDocumentDrawingProperties();
        return;
    }

    if (KEY_NAME === 'LEFT' || KEY_NAME === 'UP') {
        this.onEndInputAction();
        this.caretPosition--;
        if (this.caretPosition < 0)
            this.caretPosition = 0;
        this.setCaretPosition(this.caretPosition);

        this.updateDocumentDrawingProperties();
        return;
    }

    if (KEY_NAME === 'RIGHT' || KEY_NAME === 'DOWN') {
        this.onEndInputAction();
        this.caretPosition++;
        var maxChar = this.getNumberOfChars();
        if (this.caretPosition > maxChar)
            this.caretPosition = maxChar;
        this.setCaretPosition(this.caretPosition);
        this.updateDocumentDrawingProperties();
        return;
    }

    if (KEY_NAME === 'TAB') {
        inputText = "    ";
        _e.preventDefault();
        //_e.stopPropagation();
    }

    if (KEY_NAME === 'BACKSPACE') {
        if (this.storedTextSelectionRange.selectedCharNum > 0) {
            //console.log('deleteSelectedText');
            this.deleteSelectedText();
            this.renderRequest();

            return;
        }

        if (this.caretPosition === 0)
            return;

        this.caretPosition--;

        if (this.inputAction !== 'deletePreviousText') {
            this.onEndInputAction();
            this.onStartInputAction('deletePreviousText');
        }

        removedCharData = this.deleteTextData(this.caretPosition, 1);

        this.inputActionTextData.text = removedCharData.text + this.inputActionTextData.text;
        this.inputActionTextData.style.unshift(removedCharData.style[0]);
        this.inputActionTextData.offset = this.caretPosition; // imposto l'inizio di inserimento del testo rimosso
    } else if (KEY_NAME === 'DELETE') {
        if (this.storedTextSelectionRange.selectedCharNum > 0) {
            this.deleteSelectedText();
            this.renderRequest();
            return;
        }

        if (this.inputAction !== 'deleteNextText') {
            this.onEndInputAction();
            this.onStartInputAction('deleteNextText');
            this.inputActionTextData.offset = this.caretPosition;
        }

        removedCharData = this.deleteTextData(this.caretPosition, 1);

        this.inputActionTextData.text += removedCharData.text;
        this.inputActionTextData.style.push(removedCharData.style[0]);
    } else {
        if (this.storedTextSelectionRange && this.storedTextSelectionRange.selectedCharNum > 0) {
            this.deleteSelectedText();
            //this.renderRequest();
            //this.renderRequest();
            // continua
        }

        if (KEY_NAME === 'ENTER') {
            this.onEndInputAction();
            inputText = "\n";
        }

        this.insertText(this.caretPosition, inputText);

        if (this.inputAction !== 'insertText') {
            this.onEndInputAction();
            this.onStartInputAction('insertText');
            this.inputActionTextData.offset = this.caretPosition; // imposto l'inizio di inserimento del testo rimosso
        }

        this.inputActionTextData.text += inputText;
        this.inputActionTextData.style = new Array(this.inputActionTextData.text.length);

        this.caretPosition += inputText.length;
    }

    var self = this;
    this.renderRequest(null, function () {
        self.setCaretPosition(self.caretPosition)
    });

};

_.setCaretPosition = function (_caretPosition) {
    this.caretPosition = _caretPosition;
    var charPos = _caretPosition;
    var maxChars = this.getNumberOfChars();
    if (charPos >= maxChars)
        charPos = maxChars - 1;
    if (charPos < 0)
        return;
    this.selectSubString(charPos, 0);
    this.saveTextSelectionRange();
    this.updateTextCursorPosition();
};

_.onEndInputAction = function () {

    if (this.inputAction === 'insertText') {
        activeApplication.activeDocument.createInsertTextDataUndoRedoActions(this, this.inputActionTextData);
    } else if (this.inputAction === 'deletePreviousText') {
        activeApplication.activeDocument.createDeleteTextDataUndoRedoActions(this, this.inputActionTextData);
    } else if (this.inputAction === 'deleteNextText') {
        activeApplication.activeDocument.createDeleteTextDataUndoRedoActions(this, this.inputActionTextData);
    }

    this.inputAction = null;
};

_.deleteSelectedText = function () {
    if (!this.storedTextSelectionRange)
        return;

    if (this.storedTextSelectionRange.selectedCharNum > 0) {
        var removedTextData = this.deleteTextData(this.caretPosition, this.storedTextSelectionRange.selectedCharNum);
        activeApplication.activeDocument.createDeleteTextDataUndoRedoActions(this, removedTextData);
        this.setCaretPosition(this.caretPosition);
    }
};

_.onKeyDown = function (_e) {
    //var inputText =  _e.key;

    const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];
    if (KEYBOARD_EVENT_MANAGER.cmdKeyPressed) {
        this.onEndInputAction();

        switch (KEY_NAME) {
        case 'Z':
            if (_e.shiftKey) {
                COMMANDS.redo.execute();
            } else {
                COMMANDS.undo.execute();
            }
            _e.stopPropagation();
            break;

        case 'A':
            _e.stopPropagation();
            this.selectAll();
            break;
        case 'C':
            break;
        case 'V':
            break;
        case 'X':
            break;
        }
        return;
    }

    if (KEY_NAME === 'SHIFT' || _e.keyCode === 18 || _e.keyCode === 116 || _e.keyCode === 20)
        return;

    _e.stopPropagation();

    this.onInputAction(_e);
};

_.selectAll = function () {
    this.selectSubString(0, this.textData.text.length);
    this.caretPosition = 0;
    this.updateTextCursorPosition();
    const self = this;
    setTimeout(function () {
        self.saveTextSelectionRange();
    }, 0);
};

_.onPaste = function (_e) {
    this.pasteText(_e.clipboardData.getData('Text'));
    _e.preventDefault();
};

_.onCopy = function (_e) {
    this.copySelectedText(_e);
    _e.preventDefault();
};

_.onCut = function (_e) {
    this.cutSelectedText(_e);
    _e.preventDefault();
};

_.copySelectedText = function (_e) {
    _e.clipboardData.setData('text/plain', this.textData.text.substring(this.storedTextSelectionRange.textDataStartOffset, this.storedTextSelectionRange.textDataEndOffset));
};

_.cutSelectedText = function (_e) {
    _e.clipboardData.setData('text/plain', this.textData.text.substring(this.storedTextSelectionRange.textDataStartOffset, this.storedTextSelectionRange.textDataEndOffset));
    this.deleteSelectedText();
    const self = this;
    this.renderRequest(null, function () {
        self.setCaretPosition(self.caretPosition)
    });
};

_.pasteText = function (clipText) {

    this.deleteSelectedText();

    const textData = this.createTextData(clipText);

    textData.offset = this.caretPosition;

    activeApplication.activeDocument.createInsertTextDataUndoRedoActions(this, textData);

    this.insertTextData(this.caretPosition, textData);

    this.caretPosition += textData.text.length;

    const self = this;
    this.renderRequest(null, function () {
        self.setCaretPosition(self.caretPosition)
    });

    this.updateDocumentDrawingProperties();

};

_.insertText = function (_pos, _string) {
    this.textData.text = this.textData.text.splice(_pos, 0, _string);
    const codaOfElements = this.textData.style.splice(_pos);
    this.textData.style = this.textData.style.concat(new Array(_string.length), codaOfElements);
};

_.deleteTextData = function (_pos, _deleteCharNum) {
    const removedTextData = this.getTextData(_pos, _pos + _deleteCharNum);
    this.textData.text = this.textData.text.splice(_pos, _deleteCharNum);
    this.textData.style.splice(_pos, _deleteCharNum);
    return removedTextData;
};

_.cloneStyle = function (_style) {
    var clonedStyle = {};
    for (var propertyName in _style)
        clonedStyle[propertyName] = _style[propertyName];
    return clonedStyle;
};

_.cloneTextDataStyle = function (_textDataStyle) {
    var style,
    i,
    max = _textDataStyle.style.length;
    for (i = 0; i < max; i++) {
        style = _textDataStyle.style[i];
        if (style)
            _textDataStyle.style[i] = this.cloneStyle(style);
    }
};

_.getTextData = function (_startPos, _endPos) {
    var textData = {};

    _startPos = _startPos || 0;

    textData.offset = _startPos;

    if (_endPos) {
        textData.text = this.textData.text.substring(_startPos, _endPos);
        textData.style = this.textData.style.slice(_startPos, _endPos);
    } else {
        textData.text = this.textData.text.substring(_startPos);
        textData.style = this.textData.style.slice(_startPos);
    }

    this.cloneTextDataStyle(textData);

    return textData;
};

_.insertTextData = function (_startPos, _textData, _replaceCharNum) {
    _replaceCharNum = _replaceCharNum || 0;
    this.textData.text = this.textData.text.splice(_startPos, _replaceCharNum, _textData.text);
    if (_replaceCharNum > 0)
        this.textData.style.splice(_startPos, _replaceCharNum); // rimuovo eventuali caratteri selezionati
    var codaOfElements = this.textData.style.splice(_startPos);
    this.textData.style = this.textData.style.concat(_textData.style, codaOfElements);
};

_.splitTextStyle = function (_from, _to) {
    var startStyle = this.textData.style[_from];
    var endStyle = this.textData.style[_to];

    // se non esiste style nei punti start e from allora li creo in base a quelli correnti prelevati con getTextStyleAt
    if (!startStyle)
        this.textData.style[_from] = this.cloneStyle(this.getTextStyleAt(_from));
    if (!endStyle)
        this.textData.style[_to] = this.cloneStyle(this.getTextStyleAt(_to));
};

_.setTextStyleProperty = function (_from, _to, _attributeName, _attributeValue) {
    this.splitTextStyle(_from, _to);
    // setto la proprietà al primo e a tutti gli style intermedi
    var i = _from;
    var max = _to;

    for (i; i < max; i++)
        if (this.textData.style[i])
            this.textData.style[i][_attributeName] = _attributeValue;
};

_.getTextStyleAt = function (_charPos) {
    var style = this.textData.style;
    while (_charPos > -1) {
        if (style[_charPos])
            return style[_charPos]; // ritorno lo style trovato in data
        _charPos--;
    }
    return this.getElementStyle(this); // ritorno lo style di this Text
};

_.getTSpanAt = function (_charPos) {
    var style = this.textData.style;
    while (_charPos > -1) {
        if (style[_charPos])
            break;
        _charPos--;
    }

    return this.querySelector('tspan[data-start-offset="' + _charPos + '"]');
};

_.restoreTextSelectionRange = function () {

    if (!this.storedTextSelectionRange)
        return;

    if (this.storedTextSelectionRange.selectedCharNum > 0)
        this.selectSubString(this.storedTextSelectionRange.textDataStartOffset, this.storedTextSelectionRange.selectedCharNum);

    this.caretPosition = this.storedTextSelectionRange.textDataStartOffset;
};

_.saveTextSelectionRange = function (_e) {
    var selection;
    var range;

    // selection=window.getSelection();
    //selection=_e.shadowRoot.getSelection();
    //selection=this.getRootNode().getSelection();

    ////console.log('this.getRootNode()' , this.getRootNode() );
    //


    //safari non funzione in nessun dei due modi
    if (this.getRootNode().getSelection) {
        selection = this.getRootNode().getSelection();
    } else {
        selection = window.getSelection(); // firefox
    }

    if (selection.type != 'None') {
        range = selection.getRangeAt(0);

        this.storedTextSelectionRange = range;

        if (this.storedTextSelectionRange.startContainer.nodeName === '#cdata-section') {
            this.storedTextSelectionRange.textDataStartOffset = parseInt(this.storedTextSelectionRange.startContainer.parentElement.dataset.startOffset) + this.storedTextSelectionRange.startOffset;
            this.storedTextSelectionRange.textDataEndOffset = parseInt(this.storedTextSelectionRange.endContainer.parentElement.dataset.startOffset) + this.storedTextSelectionRange.endOffset;
        } else {
            this.storedTextSelectionRange.textDataStartOffset = 0;
            this.storedTextSelectionRange.textDataEndOffset = 0;
        }

        this.storedTextSelectionRange.selectedCharNum = this.storedTextSelectionRange.textDataEndOffset - this.storedTextSelectionRange.textDataStartOffset;

        //this.caretPosition = this.storedTextSelectionRange.textDataStartOffset;
    } else {
        this.storedTextSelectionRange.endContainer = this.storedTextSelectionRange.startContainer;
        this.storedTextSelectionRange.textDataStartOffset = parseInt(this.storedTextSelectionRange.startContainer.parentElement.dataset.startOffset) + this.storedTextSelectionRange.startOffset;
        this.storedTextSelectionRange.textDataEndOffset = this.storedTextSelectionRange.textDataStartOffset;
        this.storedTextSelectionRange.selectedCharNum = 0;
    }

    //console.log('this.caretPosition',this.caretPosition);
    //console.log('selection start',this.storedTextSelectionRange.textDataStartOffset);
    //console.log('selection end',this.storedTextSelectionRange.textDataEndOffset);

};

_.parseText = function () {
    if (this.textData)
        return;

    var textData = {};
    textData.text = '';
    textData.style = new Array(textData.text.length);
    textData.drawInfo = new Array(textData.text.length);

    var tspan_text,
    tspan_style;
    var cdata,
    tspan,
    tspanList = this.children;

    if (tspanList.length == 0) {
        //this.setText( this.textContent );
        this.initTextData(this.textContent);
        // this.useRichText = false;
        this.dataset.useRichText = "false";
    } else {
        for (var i = 0; i < tspanList.length; i++) {
            tspan = tspanList[i];
            cdata = null;
            for (var i2 = 0; i2 < tspan.childNodes.length; i2++) {
                if (tspan.childNodes[i2].nodeName == '#cdata-section') {
                    //console.log('trovato cdata', tspan.childNodes[i2] );
                    cdata = tspan.childNodes[i2];
                    break;
                }
            }

            if (cdata) {
                tspan_text = cdata.data;
                //console.log('uso cdata.data', cdata.data );
            } else {
                tspan_text = tspan.textContent;
                //console.log('non uso cdata.data', tspan.textContent );
            }

            tspan_style = this.getElementStyle(tspan);
            textData.style[textData.text.length] = tspan_style;
            textData.text += tspan_text;
        }
        this.textData = textData;
    }

};

// prende lo style da test element e aggiunge gli attributi presenti in textData.style
_.consolidateAllStyles = function () {
    var globalStyle = this.getElementStyle(this);
    var propertyName,
    style,
    styleList = this.textData.style;

    for (var i = 0; i < styleList.length; i++) {
        style = styleList[i];
        if (style) {
            for (propertyName in globalStyle) {
                //console.log( propertyName , style[propertyName]);
                if (style[propertyName] == undefined)
                    style[propertyName] = globalStyle[propertyName];
            }
        }
    }
};

// da finire
_.getTextRangeStyle = function (_start, _end) {
    _start = _start || this.storedTextSelectionRange.textDataStartOffset;
    _end = _end || this.storedTextSelectionRange.textDataEndOffset;

    const textRangeStyle = {
        start: start,
        end: end
    };

    const maxChars = _end - _start;

    let style,
    clonedStyle,
    propertyName;
    const textDataStyle = new Array(maxChars);

    for (var i = 0; i <= maxChars; i++) {
        style = this.textData.style[_start + i];

        if (style) {
            clonedStyle = {};
            for (propertyName in style)
                clonedStyle[propertyName] = style[propertyName];
            textDataStyle[i] = clonedStyle;
        }
    }

    textRangeStyle.textDataStyle = textDataStyle;

    return textRangeStyle;
};

// _.renderRequest = function( _timeout , _callback ) {
//
// 	if( this.waitForRendering !== true )
// 	{
// 		_timeout = _timeout || 0;
// 		this.waitForRendering = true;
// 		const self = this;
// 		setTimeout( function() {
// 			// se non è stato forzato il ridisegneo da qualche altra funzione durante l'attesa
// 			if(self.waitForRendering === true )
// 			{
// 				self.render();
// 				if(_callback)_callback( self );
// 			}
// 		}, _timeout);
// 	}
// };


_ = SVGTextElement.prototype;

_.render = function () {
    this.waitForRendering = false;

    this.textElementUtils = document.querySelector('#TEXT_UTILS');

    if (!this.textData)
        this.parseText();

    const wordList = this.createWordList(this.textData);

    const textType = this.getAttribute('data-type');

    let textContainer = this;

    if (textType === 'TextOnPath')
        textContainer = this.querySelector('textPath');

    textContainer.removeChildren();

    if (wordList.length === 0)
        return;

    let limitX = null;

    if (textType === 'TextBox')
        limitX = parseFloat(this.getAttribute('width'));

    this.textElementUtils.removeChildren();

    const tspanOutputList = this.renderizeWordList(wordList, limitX);

    if (textType !== 'TextBox')
        tspanOutputList[0].setAttribute('dy', 0);

    for (let i = 0; i < tspanOutputList.length; i++)
        textContainer.appendChild(tspanOutputList[i]);

    const bbox = this.getBBox();

    //if(bbox.width<parseFloat(this.getAttribute('width'))) this.__setAttribute('width' , bbox.width);

    this.__setAttribute('height', bbox.y + bbox.height);
    this.updateTextAlignment();
};

_.createWordList = function (_textData) {
    const wordList = [];
    const text = _textData.text;
    const style = _textData.style;
    let currentStyle,
    currentChar,
    currentWordChunk,
    currentWord = null;
    let isNewWord = true,
    isNewLine = true;
    let i,
    max = text.length;

    for (i = 0; i < max; i++) {

        currentStyle = style[i];
        currentChar = text[i];

        if (isNewWord) {
            currentWordChunk = {
                isNewLine: isNewLine,
                idStart: i,
                text: '',
                style: currentStyle
            };
            currentWord = {
                wordChunkList: [currentWordChunk]
            }; // creo una nuova parola ed il primo chunk
            wordList.push(currentWord);
            isNewWord = isNewLine = false;
        } else if (currentStyle) {
            currentWordChunk = {
                idStart: i,
                text: '',
                style: currentStyle
            }; // creo un nuovo chunk nell aprola corrente
            currentWord.wordChunkList.push(currentWordChunk);
        }

        currentWordChunk.text += currentChar;

        if (currentChar === '\n') {
            isNewWord = isNewLine = true;
        } else if (currentChar === ' ') {
            isNewWord = true;
        }
    }

    return wordList;
};

_.renderizeWordList = function (_wordList, _limitX) {
    console.log('renderizeWordList', _wordList);
    const tspanOutputList = [];
    const textUtils = this.textElementUtils;
    let currentLineBBox,
    lineHeight,
    ascent,
    descent,
    previousDescent = 0;
    let currentWord,
    current_tspan,
    idWord,
    maxWords = _wordList.length;
    let currentStyle = this.currentStyle = this.getElementStyle(this);
    const self = this;

    // copio gli attibuti di style nel text box di utilità
    for (let propertyName in currentStyle)
        textUtils.setAttribute(propertyName, currentStyle[propertyName]);

    function onTextLineCompleted() {
        if (!textUtils.firstElementChild)
            return;

        currentLineBBox = textUtils.getBBox();
        lineHeight = currentLineBBox.height;
        ascent = 0 - currentLineBBox.y;
        descent = lineHeight - ascent;
        if (currentStyle['line-height'] && currentStyle['line-height'] != 'normal')
            lineHeight = parseFloat(currentStyle['line-height']);

        textUtils.firstElementChild.setAttribute('dy', previousDescent + lineHeight - descent);

        //console.log('textLineWidth',textUtils.firstElementChild.textLineWidth);


        previousDescent = descent;
        while (textUtils.firstElementChild)
            tspanOutputList.push(textUtils.removeChild(textUtils.firstElementChild));
    }

    for (idWord = 0; idWord < maxWords; idWord++) {
        currentWord = _wordList[idWord];

        if (currentWord.wordChunkList[0].isNewLine) {
            onTextLineCompleted();
            current_tspan = self.renderizeWordInNewTextLine(currentWord);
        } else {
            current_tspan = this.renderizeWordInCurrentTextLine(currentWord, _limitX);
            if (!current_tspan) {
                onTextLineCompleted();
                current_tspan = self.renderizeWordInNewTextLine(currentWord);
            }
        }
    }

    onTextLineCompleted();

    return tspanOutputList;
};

_.renderizeWordInNewTextLine = function (_wordData) {
    let idWordChunk,
    maxWordChunks,
    currentWordChunk,
    currentTSpan;

    currentWordChunk = _wordData.wordChunkList[0];

    if (currentWordChunk.style)
        this.currentStyle = currentWordChunk.style;

    currentTSpan = this.createTSpan(currentWordChunk.idStart, currentWordChunk.text, this.currentStyle, true, 0);

    maxWordChunks = _wordData.wordChunkList.length;
    for (idWordChunk = 1; idWordChunk < maxWordChunks; idWordChunk++) {
        currentWordChunk = _wordData.wordChunkList[idWordChunk];
        if (currentWordChunk.style) {
            this.currentStyle = currentWordChunk.style;
            currentTSpan = this.createTSpan(currentWordChunk.idStart, currentWordChunk.text, this.currentStyle, false);
        } else {
            currentTSpan.firstChild.data += currentWordChunk.text;
        }
    }

    this.textElementUtils.firstElementChild.lastTextLineTSpan = this.textElementUtils.lastElementChild;

    return currentTSpan;
};

_.renderizeWordInCurrentTextLine = function (_wordData, _limitX) {
    let idWordChunk,
    maxWordChunks,
    currentWordChunk,
    currentTSpan;

    let initalTSpan = currentTSpan = this.textElementUtils.lastElementChild;
    let initialTSpanText = initalTSpan.firstChild.data;
    let initialStyle = this.currentStyle;
    let textLineWidth;

    maxWordChunks = _wordData.wordChunkList.length;
    for (idWordChunk = 0; idWordChunk < maxWordChunks; idWordChunk++) {
        currentWordChunk = _wordData.wordChunkList[idWordChunk];

        //if(this.useRichText && currentWordChunk.style)
        if ((this.dataset.useRichText === "true") && currentWordChunk.style) {
            this.currentStyle = currentWordChunk.style;
            currentTSpan = this.createTSpan(currentWordChunk.idStart, currentWordChunk.text, this.currentStyle, false);
        } else {
            currentTSpan.firstChild.data += currentWordChunk.text;
        }
    }

    if (_limitX) {
        textLineWidth = this.textElementUtils.getBBox().width;
        if (textLineWidth > _limitX) {
            while (this.textElementUtils.lastElementChild !== initalTSpan)
                this.textElementUtils.lastElementChild.remove();
            initalTSpan.firstChild.data = initialTSpanText;
            this.currentStyle = initialStyle;
            currentTSpan = null;
        } else {
            this.textElementUtils.firstElementChild.textLineWidth = textLineWidth;
        }
    }

    this.textElementUtils.firstElementChild.lastTextLineTSpan = this.textElementUtils.lastElementChild;

    return currentTSpan;
};

_.updateTextAlignment = function () {
    const textBoxWidth = parseFloat(this.getAttribute('width'));

    let i,
    max,
    text,
    maxChars,
    charCode,
    textBoxLetterSpacing,
    letterSpacing,
    lastCharPosX,
    lastTextLineTSpan,
    tspan,
    tspanList;

    const textAlign = this.getAttribute('text-align');
    let anchorOffsetX = 0;
    textBoxLetterSpacing = 0;

    if (this.hasAttribute('letter-spacing'))
        textBoxLetterSpacing = parseFloat(this.getAttribute('letter-spacing'));

    if (textAlign === 'justify') {
        this.__setAttribute('text-anchor', 'start');
        this.__setAttribute('text-anchor', 'start');
        tspanList = this.querySelectorAll('tspan');
        max = tspanList.length;
        for (i = 0; i < max; i++) {
            tspan = tspanList[i];
            tspan.setAttribute('lengthAdjust', "spacing");
            tspan.setAttribute('textLength', textBoxWidth);
        }

    } else if (textAlign === 'right' || textAlign === 'center') {
        this.__setAttribute('text-anchor', 'end');
    } else {
        this.__setAttribute('text-anchor', 'start');
    }

    tspanList = this.querySelectorAll('tspan[x="0"]');
    max = tspanList.length;
    for (i = 0; i < max; i++) {
        tspan = tspanList[i];

        if (textAlign === 'right') {
            lastTextLineTSpan = tspanList[i].lastTextLineTSpan;
            text = lastTextLineTSpan.firstChild.data;
            maxChars = text.length;
            charCode = text.charCodeAt(maxChars - 1);

            if (charCode === 32 || charCode === 10) {
                lastCharPosX = lastTextLineTSpan.getStartPositionOfChar(maxChars - 1).x;
                letterSpacing = textBoxLetterSpacing;
                if (lastTextLineTSpan.hasAttribute('letter-spacing'))
                    letterSpacing = parseFloat(lastTextLineTSpan.getAttribute('letter-spacing'));
                anchorOffsetX = textBoxWidth - lastCharPosX + letterSpacing;
            } else {
                anchorOffsetX = textBoxWidth;
            }

            tspan.setAttribute('x', anchorOffsetX);
        } else if (textAlign === 'center') {

            lastTextLineTSpan = tspanList[i].lastTextLineTSpan;
            text = lastTextLineTSpan.firstChild.data;
            maxChars = text.length;
            charCode = text.charCodeAt(maxChars - 1);

            if (charCode === 32 || charCode === 10) {
                lastCharPosX = lastTextLineTSpan.getStartPositionOfChar(maxChars - 1).x;
                letterSpacing = textBoxLetterSpacing;
                if (lastTextLineTSpan.hasAttribute('letter-spacing'))
                    letterSpacing = parseFloat(lastTextLineTSpan.getAttribute('letter-spacing'));
                anchorOffsetX = textBoxWidth / 2 + Math.abs(lastCharPosX) / 2 + letterSpacing / 2;
            } else {
                anchorOffsetX = textBoxWidth / 2;
            }

            tspan.setAttribute('x', anchorOffsetX);

        } else if (textAlign === 'justify') {

            lastTextLineTSpan = tspanList[i].lastTextLineTSpan;
            text = lastTextLineTSpan.firstChild.data;
            maxChars = text.length;
            charCode = text.charCodeAt(maxChars - 1);

            if (charCode === 32 || charCode === 10) {
                lastCharPosX = Math.abs(lastTextLineTSpan.getStartPositionOfChar(maxChars - 1).x);
                letterSpacing = textBoxLetterSpacing;
                if (lastTextLineTSpan.hasAttribute('letter-spacing'))
                    letterSpacing = parseFloat(lastTextLineTSpan.getAttribute('letter-spacing'));
                tspan.setAttribute('textLength', textBoxWidth + (textBoxWidth - lastCharPosX) + letterSpacing);
            }
        }
    }

    if (textAlign === 'center') {
        this.__setAttribute('text-anchor', 'middle');
    }
};

_.createTSpan = function (_idStartChar, _text, _style, _isNewLine, _baseline) {
    var tspan_element = document.createElementNS(SVGSVGElement.SVG_NS, "tspan"); // Create first tspan element
    tspan_element.dataset.startOffset = _idStartChar;
    tspan_element.setAttribute('style', 'white-space: pre;');
    tspan_element.appendChild(XMLUtils.createCDATASection(_text));
    // if( this.useRichText && _style ) for( var propertyName in _style ) tspan_element.setAttribute( propertyName , _style[propertyName] ) ;
    if ((this.dataset.useRichText === "true") && _style)
        for (var propertyName in _style)
            tspan_element.setAttribute(propertyName, _style[propertyName]);
    if (_isNewLine) {
        tspan_element.setAttribute("x", "0");
        tspan_element.setAttribute("dy", _baseline);
    }
    this.textElementUtils.appendChild(tspan_element); // Add text to tspan element
    return tspan_element;
};

const SVG_TAG_ATTRIBUTES = {
    "meta": [
        "xmlns:jvs",
        "name"
    ],
    "jvs:property": [
        "value",
        "name"
    ],
    "jvs:data": [
        "xmlns:jvs",
    ],
    "link": [
        "xmlns",
        "rel",
        "type",
        "href"
    ],
    "style": [
    ],
    // "#text": [
    // ],
    "#cdata-section": [
    ],
    "*": [
        "name",
        "class",
        "id",
        "tabindex",
        "fill",
        "fill-opacity",
        "fill-rule",
        "vector-effect",
        "stroke",
        "stroke-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-width",
        "filter",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "clip-path",
        "opacity",
        "style",
        "transform",
        "preserveAspectRatio",
        "paint-order",
        /* janvas */
        "locked",
        "data-width",
        "data-height"
    ],
    "a": [
        "href",
        "xlink:href",
        "target"
    ],
    "circle": [
        "cx",
        "cy",
        "r"
    ],
    "clipPath": [
    ],
    "defs": [
    ],
    "desc": [
    ],
    "ellipse": [
        "cx",
        "cy",
        "rx",
        "ry"
    ],
    "feBlend": [
        "in",
        "in2",
        "mode",
        "result"
    ],
    "feColorMatrix": [
        "in",
        "type",
        "values",
        "result"
    ],
    "feComponentTransfer": [
        "in",
        "result"
    ],
    "feComposite": [
        "in",
        "in2",
        "k1",
        "k2",
        "k3",
        "k4",
        "result",
        "operator"
    ],
    "feConvolveMatrix": [
    ],
    "feDiffuseLighting": [

        "lighting-color",
        "diffuseConstant",
        "surfaceScale",
        "result"

    ],
    "feDisplacementMap": [
        "in",
        "in2",
        "scale",
        "xChannelSelector",
        "yChannelSelector",
        "result"
    ],
    "feDistantLight": [
        "azimuth",
        "elevation",
        "result"
    ],
    "feDropShadow": [
        "dx",
        "dy",
        "stdDeviation",
        "result"
    ],
    "feFlood": [
        "flood-color",
        "flood-opacity",
        "result"
    ],
    "feFuncA": [
        "amplitude",
        "exponent",
        "intercept",
        "offset",
        "slope",
        "tableValues",
        "type",
        "result"
    ],
    "feFuncB": [
        "amplitude",
        "exponent",
        "intercept",
        "offset",
        "slope",
        "tableValues",
        "type",
        "result"
    ],
    "feFuncG": [
        "amplitude",
        "exponent",
        "intercept",
        "offset",
        "slope",
        "tableValues",
        "type",
        "result"
    ],
    "feFuncR": [
        "amplitude",
        "exponent",
        "intercept",
        "offset",
        "slope",
        "tableValues",
        "type",
        "result"
    ],
    "feGaussianBlur": [
        "in",
        "stdDeviation",
        "endgeMode",
        "result"
    ],
    "feImage": [
        "xlink:href",
        "href",
        "width",
        "height",
        "x",
        "y",
        "preserveAspectRatio",
        "result"
    ],
    "feMerge": [
        "result"
    ],
    "feMergeNode": [
        "in",
        "result"
    ],
    "feMorphology": [
        "in",
        "operator",
        "radius",
        "result"
    ],
    "feOffset": [
        "in",
        "dx",
        "dy",
        "result"
    ],
    "fePointLight": [
        "x",
        "y",
        "z",
        "result"
    ],
    "feSpecularLighting": [
        "specularExponent",
        "specularConstant",
        "surfaceScale",
        "lighting-color",
        "result",
        "in"
    ],
    "feSpotLight": [
        "limitingConeAngle",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "specularExponent",
        "x",
        "y",
        "z",
        "result"
    ],
    "feTile": [
        "in",
        "width",
        "height",
        "x",
        "y",
        "result"
    ],
    "feTurbulence": [
        "baseFrequency",
        "numOctaves",
        "seed",
        "stitchTiles",
        "result"
    ],
    "filter": [
        "filterUnits",
        "primitiveUnits",
        "width",
        "height",
        "x",
        "y"
    ],
    "foreignObject": [
        "height",
        "width",
        "x",
        "y"
    ],
    "g": [
    ],
    "iframe": [
        "src",
        "height",
        "width",
        "frameborder",
        "xmlns",
        "allow"
    ],
    "div": [
    ],
    "br": [
    ],
    "pre": [
        "style",
    ],
    "span": [
        "style",
    ],
    "image": [
        "height",
        "href",
        "xlink:href",
        "width",
        "x",
        "y"
    ],
    "line": [
        "x1",
        "x2",
        "y1",
        "y2"
    ],
    "linearGradient": [
        "gradientTransform",
        "gradientUnits",
        "href",
        "xlink:href",
        "spreadMethod",
        "x1",
        "x2",
        "y1",
        "y2"
    ],
    "marker": [
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "viewBox",
        "overflow",
        "orient",
        "refX",
        "refY"
    ],
    "mask": [
        "maskContentUnits",
        "maskUnits",
        "height",
        "width",
        "mask-type",
        "x",
        "y"
    ],
    "path": [
        "d"
    ],
    "pattern": [
        "height",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "viewBox",
        "width",
        "height",
        "href",
        "xlink:href",
        "x",
        "y"
    ],
    "polygon": [
        "points"
    ],
    "polyline": [
        "points"
    ],
    "radialGradient": [
        "cx",
        "cy",
        "fr",
        "fx",
        "fy",
        "gradientTransform",
        "gradientUnits",
        "href",
        "xlink:href",
        "r",
        "spreadMethod"
    ],
    "rect": [
        "height",
        "rx",
        "ry",
        "width",
        "x",
        "y"
    ],
    "script": [
        "xlink:href",
        "href",
        "type"
    ],
    "stop": [
        "offset",
        "stop-color",
        "stop-opacity"
    ],
    "svg": [
        "height",
        "viewBox",
        "width",
        "x",
        "y",
        "xmlns",
        "xmlns:xlink",
    ],
    "switch": [
    ],
    "symbol": [
        "height",
        "viewBox",
        "width",
        "x",
        "y",
        "refX",
        "refY",
        "overflow"
    ],
    "text": [
        "alignment-baseline",
        "baseline-shift",
        "direction",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "kerning",
        "lengthAdjust",
        "letter-spacing",
        "lighting-color",
        "line-height",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "textLength",
        "text-align",
        "unicode-bidi",
        "word-spacing",
        "width",
        "height",
        "x",
        "y"
    ],
    "textArea": [
    ],
    "textPath": [
        "method",
        "side",
        "spacing",
        "startOffset",
        "href",
        "xlink:href"
    ],
    "title": [
    ],
    "tspan": [
        "alignment-baseline",
        "baseline-shift",
        "direction",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "kerning",
        "lengthAdjust",
        "letter-spacing",
        "lighting-color",
        "line-height",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "textLength",
        "unicode-bidi",
        "word-spacing",
        "dx",
        "dy",
        "rotate",
        "x",
        "y"
    ],
    "use": [
        "href",
        "xlink:href",
        "height",
        "viewBox",
        "width",
        "x",
        "y",
        "refX",
        "refY"
    ]
};

// in futuro si potrebbe guardare a questa libreria per le intersezioni
// https://github.com/thelonious/kld-intersections

class GeometryUtils {

    static getArcCenter(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag) {
        var degToRad = function (degrees) {
            return (Math.PI * degrees) / 180;
        };

        var rotate = function (x, y, angleRad) {
            var X = x * Math.cos(angleRad) - y * Math.sin(angleRad);
            var Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);
            return {
                x: X,
                y: Y
            };
        };

        var angleRad = degToRad(angle);
        var cx,
        cy;

        var p1 = rotate(x1, y1, -angleRad);
        x1 = p1.x;
        y1 = p1.y;

        var p2 = rotate(x2, y2, -angleRad);
        x2 = p2.x;
        y2 = p2.y;

        var x = (x1 - x2) / 2;
        var y = (y1 - y2) / 2;
        var h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);

        if (h > 1) {
            h = Math.sqrt(h);
            r1 = h * r1;
            r2 = h * r2;
        }

        var sign;

        if (largeArcFlag === sweepFlag) {
            sign = -1;
        } else {
            sign = 1;
        }

        var r1Pow = r1 * r1;
        var r2Pow = r2 * r2;

        var left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;
        var right = r1Pow * y * y + r2Pow * x * x;

        var k = sign * Math.sqrt(Math.abs(left / right));

        cx = k * r1 * y / r2 + (x1 + x2) / 2;
        cy = k * -r2 * x / r1 + (y1 + y2) / 2;

        //return {x:cx,y:cy};

        return SVGUtils.createSVGPoint(cx, cy);

    }

    static getClosestPointToEllipse(point, semiMajor, semiMinor) {
        // semiMajor = Math.max(semiMajor,  semiMinor);
        // semiMinor = Math.min(semiMajor,  semiMinor);


        let px = Math.abs(point.x);
        let py = Math.abs(point.y);

        let a = semiMajor;
        let b = semiMinor;

        let tx = 0.70710678118;
        let ty = 0.70710678118;

        let x,
        y,
        ex,
        ey,
        rx,
        ry,
        qx,
        qy,
        r,
        q,
        t = 0;

        for (let i = 0; i < 3; ++i) {
            x = a * tx;
            y = b * ty;

            ex = (a * a - b * b) * (tx * tx * tx) / a;
            ey = (b * b - a * a) * (ty * ty * ty) / b;

            rx = x - ex;
            ry = y - ey;

            qx = px - ex;
            qy = py - ey;

            r = Math.sqrt(rx * rx + ry * ry);
            q = Math.sqrt(qy * qy + qx * qx);

            tx = Math.min(1, Math.max(0, (qx * r / q + ex) / a));
            ty = Math.min(1, Math.max(0, (qy * r / q + ey) / b));

            t = Math.sqrt(tx * tx + ty * ty);

            tx /= t;
            ty /= t;
        }

        return {
            x: (a * (point.x < 0 ? -tx : tx)),
            y: (b * (point.y < 0 ? -ty : ty))
        };
    }

    static fillet(_pt1, _intersectionPt, _pt2, _radius) {
        // porto i punti in senso orario
        const area = GeometryUtils.getPolygonArea([_pt1, _intersectionPt, _pt2]);
        if (area < 0) {
            const temp = _pt1;
            _pt1 = _pt2;
            _pt2 = temp;
        }

        let angleSeg1 = GeometryUtils.getSegmentAngle(_intersectionPt, _pt1);
        let angleSeg2 = GeometryUtils.getSegmentAngle(_intersectionPt, _pt2);

        let angleDifference = angleSeg2 - angleSeg1;

        let angleBetweenSegs = angleSeg2 - (angleDifference / 2);

        if (angleDifference > 0)
            angleBetweenSegs += Math.PI;

        let distance = Math.abs(_radius / Math.sin((angleDifference / 2)));

        const arc_center = _intersectionPt.add(SVGUtils.createSVGPoint(Math.cos(angleBetweenSegs) * distance, Math.sin(angleBetweenSegs) * distance));
        let arc_startAngle = angleSeg1 / (Math.PI / 180) + 90;
        let arc_endAngle = angleSeg2 / (Math.PI / 180) - 90;

        return {
            startAngle: arc_startAngle,
            endAngle: arc_endAngle,
            center: arc_center,
            radius: _radius,
            area: area
        }

    }

    static getPolygonArea(_polygonPts) {
        let i,
        j;
        let area = 0;
        const maxPts = _polygonPts.length;
        for (i = 0; i < maxPts; i++) {
            j = (i + 1) % maxPts;
            area += _polygonPts[i].x * _polygonPts[j].y;
            area -= _polygonPts[i].y * _polygonPts[j].x;
        }
        area /= 2;
        return area;
    }

    static getCurveBounds(ax, ay, bx, by, cx, cy, dx, dy, _precision = 40) {
        let px,
        py,
        qx,
        qy,
        rx,
        ry,
        sx,
        sy,
        tx,
        ty,
        tobx,
        toby,
        tocx,
        tocy,
        todx,
        tody,
        toqx,
        toqy,
        torx,
        tory,
        totx,
        toty;
        let x,
        y,
        minx,
        miny,
        maxx,
        maxy;

        minx = miny = Number.POSITIVE_INFINITY;
        maxx = maxy = Number.NEGATIVE_INFINITY;

        tobx = bx - ax;
        toby = by - ay; // directions
        tocx = cx - bx;
        tocy = cy - by;
        todx = dx - cx;
        tody = dy - cy;
        const step = 1 / _precision; // precision
        for (let d = 0; d < 1.001; d += step) {
            px = ax + d * tobx;
            py = ay + d * toby;
            qx = bx + d * tocx;
            qy = by + d * tocy;
            rx = cx + d * todx;
            ry = cy + d * tody;
            toqx = qx - px;
            toqy = qy - py;
            torx = rx - qx;
            tory = ry - qy;

            sx = px + d * toqx;
            sy = py + d * toqy;
            tx = qx + d * torx;
            ty = qy + d * tory;
            totx = tx - sx;
            toty = ty - sy;

            x = sx + d * totx;
            y = sy + d * toty;
            minx = Math.min(minx, x);
            miny = Math.min(miny, y);
            maxx = Math.max(maxx, x);
            maxy = Math.max(maxy, y);
        }
        return {
            x: minx,
            y: miny,
            width: maxx - minx,
            height: maxy - miny
        };
    }

    static bezierMinMax(x0, y0, x1, y1, x2, y2, x3, y3) {
        let tvalues = [],
        xvalues = [],
        yvalues = [],
        a,
        b,
        c,
        t,
        t1,
        t2,
        b2ac,
        sqrtb2ac;
        for (let i = 0; i < 2; ++i) {
            if (i === 0) {
                b = 6 * x0 - 12 * x1 + 6 * x2;
                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                c = 3 * x1 - 3 * x0;
            } else {
                b = 6 * y0 - 12 * y1 + 6 * y2;
                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                c = 3 * y1 - 3 * y0;
            }
            if (Math.abs(a) < 1e-12) {
                if (Math.abs(b) < 1e-12) {
                    continue;
                }
                t = -c / b;
                if (0 < t && t < 1) {
                    tvalues.push(t);
                }
                continue;
            }
            b2ac = b * b - 4 * c * a;
            if (b2ac < 0) {
                if (Math.abs(b2ac) < 1e-12) {
                    t = -b / (2 * a);
                    if (0 < t && t < 1) {
                        tvalues.push(t);
                    }
                }
                continue;
            }
            sqrtb2ac = Math.sqrt(b2ac);
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
                tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
                tvalues.push(t2);
            }
        }

        let j = tvalues.length,
        mt;
        while (j--) {
            t = tvalues[j];
            mt = 1 - t;
            xvalues[j] = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
            yvalues[j] = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
        }

        xvalues.push(x0, x3);
        yvalues.push(y0, y3);

        return {
            min: {
                x: Math.min.apply(0, xvalues),
                y: Math.min.apply(0, yvalues)
            },
            max: {
                x: Math.max.apply(0, xvalues),
                y: Math.max.apply(0, yvalues)
            }
        };
    }

    static getCircleTangentPoints(startPenEvent, _circleCenter, _circleRadius) {
        let dx,
        dy,
        dd,
        a,
        b,
        t,
        ta,
        tb;
        // find tangents
        dx = _circleCenter.x - startPenEvent.x;
        dy = _circleCenter.y - startPenEvent.y;
        dd = Math.sqrt(dx * dx + dy * dy);
        a = Math.asin(_circleRadius / dd);
        b = Math.atan2(dy, dx);

        t = b - a
            ta = {
            x: _circleRadius * Math.sin(t),
            y: _circleRadius * -Math.cos(t)
        };
        ta.x += _circleCenter.x;
        ta.y += _circleCenter.y;

        t = b + a
            tb = {
            x: _circleRadius * -Math.sin(t),
            y: _circleRadius * Math.cos(t)
        };
        tb.x += _circleCenter.x;
        tb.y += _circleCenter.y;

        return {
            t1: ta,
            t2: tb
        };
    }

    static lineOffset(pt1, pt2, _radius) {
        //const intersectionPoint = GeometryUtils.getLineLineIntersection( pt1, pt2, pt3, pt4 );
        let angle = pt1.getAngleFromPoint(pt2);
        let anglePerperdicular = angle + Math.PI / 2;
        let pointOffset = SVGUtils.createSVGPointPolar(_radius, anglePerperdicular);
        let offsetPoint1 = pt1.add(pointOffset);
        let offsetPoint2 = pt2.add(pointOffset);
        return {
            pt1: offsetPoint1,
            pt2: offsetPoint2
        };
    }

    static getSegmentAngle(pt1, pt2, _asDegree) {
        return Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x);

        // https://stackoverflow.com/questions/2320986/easy-way-to-keeping-angles-between-179-and-180-degrees
        //         // reduce the angle
        //         angle =  angle % 360;
        //
        // // force it to be the positive remainder, so that 0 <= angle < 360
        //         angle = (angle + 360) % 360;


    }

    static getAngleBetweenTwoLine(A1x, A1y, A2x, A2y, B1x, B1y, B2x, B2y) {

        var dAx = A2x - A1x;
        var dAy = A2y - A1y;
        var dBx = B2x - B1x;
        var dBy = B2y - B1y;
        var angle = Math.atan2(dAx * dBy - dAy * dBx, dAx * dBx + dAy * dBy);
        if (angle < 0) {
            angle = angle * -1;
        }
        return angle;
        //var degree_angle = angle * (180 / Math.PI);

    }

    static getOffsetPoint(pt1, pt2, pt3, _offsetValue) {
        let angleSeg1,
        angleSeg2,
        angleDifference,
        angleBetweenSegs,
        distance;

        angleSeg1 = GeometryUtils.getSegmentAngle(pt2, pt1);
        angleSeg2 = GeometryUtils.getSegmentAngle(pt2, pt3);

        // if (angleSeg1 < 0) angleSeg1 += 2*Math.PI;
        // if (angleSeg2 < 0) angleSeg2 += 2*Math.PI;

        angleDifference = angleSeg2 - angleSeg1;

        if (Math.abs(angleDifference) < 0.01) {
            angleBetweenSegs = angleSeg2;
            distance = Math.abs(_offsetValue / Math.sin((angleSeg2 / 2)));
            if (angleDifference > 0)
                angleBetweenSegs += Math.PI;
        } else {
            angleBetweenSegs = angleSeg2 - (angleDifference / 2);
            if (angleDifference > 0)
                angleBetweenSegs += Math.PI;
            distance = Math.abs(_offsetValue / Math.sin((angleDifference / 2)));
        }

        if (_offsetValue < 0)
            distance = 0 - distance;
        return SVGUtils.createSVGPoint(Math.cos(angleBetweenSegs) * distance, Math.sin(angleBetweenSegs) * distance);

    }

    static getPolygonOffset(_sourcePolyPts, _offsetValue, _closedPolygon) {

        const offsetPoints = [];
        let offsetPt;

        //  Il punto di inizio
        if (_closedPolygon === true) {
            offsetPt = GeometryUtils.getOffsetPoint(_sourcePolyPts[_sourcePolyPts.length - 2], _sourcePolyPts[0], _sourcePolyPts[1], _offsetValue);
        } else {

            const angleSeg1 = GeometryUtils.getSegmentAngle(_sourcePolyPts[0], _sourcePolyPts[1]);
            offsetPt = SVGUtils.createSVGPoint(Math.cos(angleSeg1 + Math.PI / 2) * _offsetValue, Math.sin(angleSeg1 + Math.PI / 2) * _offsetValue);
        }

        offsetPoints.push(SVGUtils.createSVGPoint(_sourcePolyPts[0].x + offsetPt.x, _sourcePolyPts[0].y + offsetPt.y));

        const max = _sourcePolyPts.length - 2;
        for (let id = 0; id < max; id++) {
            offsetPt = GeometryUtils.getOffsetPoint(_sourcePolyPts[id], _sourcePolyPts[id + 1], _sourcePolyPts[id + 2], _offsetValue);
            offsetPoints.push(SVGUtils.createSVGPoint(_sourcePolyPts[id + 1].x + offsetPt.x, _sourcePolyPts[id + 1].y + offsetPt.y));
        }

        //  Il punto di finale
        if (_closedPolygon === true) {
            offsetPt = GeometryUtils.getOffsetPoint(_sourcePolyPts[max], _sourcePolyPts[_sourcePolyPts.length - 1], _sourcePolyPts[1], _offsetValue);
        } else {
            const angleSeg2 = GeometryUtils.getSegmentAngle(_sourcePolyPts[_sourcePolyPts.length - 2], _sourcePolyPts[_sourcePolyPts.length - 1]);
            offsetPt = SVGUtils.createSVGPoint(Math.cos(angleSeg2 + Math.PI / 2) * _offsetValue, Math.sin(angleSeg2 + Math.PI / 2) * _offsetValue);
        }

        offsetPoints.push(SVGUtils.createSVGPoint(_sourcePolyPts[_sourcePolyPts.length - 1].x + offsetPt.x, _sourcePolyPts[_sourcePolyPts.length - 1].y + offsetPt.y));

        return offsetPoints;
    }

    //+ Jonas Raoni Soares Silva
    //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]
    static isPointInPoly(poly, pt) {
        let c = false;
        const l = poly.length
            for (let i = -1, j = l - 1; ++i < l; j = i)
                ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) && (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) && (c = !c);
            return c;
    }

    static outsetBBox(_bbox, _outsetValue) {
        _bbox.min.x -= _outsetValue;
        _bbox.min.y -= _outsetValue;
        _bbox.max.x += _outsetValue;
        _bbox.max.y += _outsetValue;
        return _bbox;
    }

    static insetBBox(_bbox, _insetValue) {
        _bbox.min.x += _insetValue;
        _bbox.min.y += _insetValue;
        _bbox.max.x -= _insetValue;
        _bbox.max.y -= _insetValue;
        return _bbox;
    }

    static isPointSnappedTo(_point, _targetPoint, _snapDistance) {
        if ((_point.x > (_targetPoint.x - _snapDistance)) && (_point.x < (_targetPoint.x + _snapDistance))) {
            if ((_point.y > (_targetPoint.y - _snapDistance)) && (_point.y < (_targetPoint.y + _snapDistance))) {
                return true;
            }
        }
        return false;
    }

    static isPointRect(pt, _rect) {
        return (pt.x > _rect.left) && (pt.x < _rect.right) && (pt.y > _rect.top) && (pt.y < _rect.bottom);
    }

    static getClosestPointToCircle(point, center, radius) {
        const vX = point.x - center.x;
        const vY = point.y - center.y;
        const magV = Math.sqrt(vX * vX + vY * vY);
        const aX = center.x + vX / magV * radius;
        const aY = center.y + vY / magV * radius;
        return {
            x: aX,
            y: aY
        };
    };

    static getCircleCircleIntersection(x0, y0, r0, x1, y1, r1) {
        var a,
        dx,
        dy,
        d,
        h,
        rx,
        ry;
        var x2,
        y2;

        /* dx and dy are the vertical and horizontal distances between
         * the circle centers.
         */
        dx = x1 - x0;
        dy = y1 - y0;

        /* Determine the straight-line distance between the centers. */
        d = Math.sqrt((dy * dy) + (dx * dx));

        /* Check for solvability. */
        if (d > (r0 + r1)) {
            /* no solution. circles do not intersect. */
            return false;
        }
        if (d < Math.abs(r0 - r1)) {
            /* no solution. one circle is contained in the other */
            return false;
        }

        /* 'point 2' is the point where the line through the circle
         * intersection points crosses the line between the circle
         * centers.
         */

        /* Determine the distance from point 0 to point 2. */
        a = ((r0 * r0) - (r1 * r1) + (d * d)) / (2.0 * d);

        /* Determine the coordinates of point 2. */
        x2 = x0 + (dx * a / d);
        y2 = y0 + (dy * a / d);

        /* Determine the distance from point 2 to either of the
         * intersection points.
         */
        h = Math.sqrt((r0 * r0) - (a * a));

        /* Now determine the offsets of the intersection points from
         * point 2.
         */
        rx = -dy * (h / d);
        ry = dx * (h / d);

        /* Determine the absolute intersection points. */
        var xi = x2 + rx;
        var xi_prime = x2 - rx;
        var yi = y2 + ry;
        var yi_prime = y2 - ry;

        // return [xi, xi_prime, yi, yi_prime];

        return {
            intersection1: {
                x: xi,
                y: yi
            },
            intersection2: {
                x: xi_prime,
                y: yi_prime
            }
        };
    }

    static getLineCircleIntersection(a, b, circleCenter, circleRadius) {
        function distance(a, b) {
            return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
        }
        function is_on(a, b, c) {
            return distance(a, c) + distance(c, b) === distance(a, b);
        }

        // Calculate the euclidean distance between a & b
        const eDistAtoB = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));

        // compute the direction vector d from a to b
        const d = [(b.x - a.x) / eDistAtoB, (b.y - a.y) / eDistAtoB];

        // Now the line equation is x = dx*t + ax, y = dy*t + ay with 0 <= t <= 1.

        // compute the value t of the closest point to the circle center (cx, cy)
        const t = (d[0] * (circleCenter.x - a.x)) + (d[1] * (circleCenter.y - a.y));

        // compute the coordinates of the point e on line and closest to c
        const e = {
            coords: [],
            onLine: false
        };
        e.coords[0] = (t * d[0]) + a.x;
        e.coords[1] = (t * d[1]) + a.y;

        // Calculate the euclidean distance between c & e
        const eDistCtoE = Math.sqrt(Math.pow(e.coords[0] - circleCenter.x, 2) + Math.pow(e.coords[1] - circleCenter.y, 2));

        // test if the line intersects the circle
        if (eDistCtoE < circleRadius) {
            // compute distance from t to circle intersection point
            const dt = Math.sqrt(Math.pow(circleRadius, 2) - Math.pow(eDistCtoE, 2));

            // compute first intersection point
            const f = {
                coords: [],
                onLine: false
            };
            f.coords[0] = ((t - dt) * d[0]) + a.x;
            f.coords[1] = ((t - dt) * d[1]) + a.y;
            // check if f lies on the line
            f.onLine = is_on(a, b, f.coords);

            // compute second intersection point
            const g = {
                coords: [],
                onLine: false
            };
            g.coords[0] = ((t + dt) * d[0]) + a.x;
            g.coords[1] = ((t + dt) * d[1]) + a.y;
            // check if g lies on the line
            g.onLine = is_on(a, b, g.coords);

            return {
                points: {
                    intersection1: f,
                    intersection2: g
                },
                pointOnLine: e
            };

        } else if (parseInt(eDistCtoE) === parseInt(circleRadius)) {
            ////console.log("Only one intersection");
            return {
                points: false,
                pointOnLine: e
            };
        } else {
            ////console.log("No intersection");
            return {
                points: false,
                pointOnLine: e
            };
        }
    }

    // static getClosestPointToLine(a, b, p, _insideSegment) {
    //     const atob = {x: b.x - a.x, y: b.y - a.y};
    //     const atop = {x: p.x - a.x, y: p.y - a.y};
    //     const len = atob.x * atob.x + atob.y * atob.y;
    //     let dot = atop.x * atob.x + atop.y * atob.y;
    //     let t;
    //     if (_insideSegment) {
    //         t = Math.min(1, Math.max(0, dot / len));
    //     } else {
    //         t = dot / len;
    //     }
    //
    //     dot = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
    //
    //     return {
    //         point: {
    //             x: a.x + atob.x * t,
    //             y: a.y + atob.y * t
    //         },
    //         left: dot < 1,
    //         dot: dot,
    //         t: t
    //     };
    // };


    static getClosestPointToLine(a, b, p, _insideSegment) {

        const atob = {
            x: b.x - a.x,
            y: b.y - a.y
        };
        const atop = {
            x: p.x - a.x,
            y: p.y - a.y
        };
        const len = atob.x * atob.x + atob.y * atob.y;
        let dot = atop.x * atob.x + atop.y * atob.y;
        let t;
        if (_insideSegment) {
            t = Math.min(1, Math.max(0, dot / len));
        } else {
            t = dot / len;
        }

        dot = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);

        return {
            point: {
                x: a.x + atob.x * t,
                y: a.y + atob.y * t
            },
            left: dot < 1,
            dot: dot,
            t: t
        };
    };

    static isPointOnLine(pt1, pt2, pnt, _snapDistance) {
        const result = GeometryUtils.getClosestPointToLine(pt1, pt2, pnt);
        if ((Math.abs(pnt.x - result.point.x) < _snapDistance) && (Math.abs(pnt.y - result.point.y) < _snapDistance))
            return result.point;
        return false;
    }

    static isPointOverSegment(pt1, pt2, pnt, _snapDistance, _insideSegment = true) {
        const result = GeometryUtils.getClosestPointToLine(pt1, pt2, pnt, _insideSegment);
        if ((Math.abs(pnt.x - result.point.x) < _snapDistance) && (Math.abs(pnt.y - result.point.y) < _snapDistance))
            return result.point;
        return false;
    }

    // static isPointOnLine(pt1, pt2, pnt, _snapDistance)
    // {
    //     const L2 = (((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
    //     if (L2 === 0) return false;
    //     const r = (((pnt.x - pt1.x) * (pt2.x - pt1.x)) + ((pnt.y - pt1.y) * (pt2.y - pt1.y))) / L2;
    //     const x = pt1.x + (r * (pt2.x - pt1.x));
    //     const y = pt1.y + (r * (pt2.y - pt1.y));
    //
    //     //if( (pnt.x > (x -_snapDistance)) && (pnt.x < (x + _snapDistance)) && (pnt.y > (y -_snapDistance)) && (pnt.y < (y + _snapDistance)) ) return {x: x, y: y};
    //     if( (pnt.x >= (x -_snapDistance)) && (pnt.x <= (x + _snapDistance)) && (pnt.y >= (y -_snapDistance)) && (pnt.y <= (y + _snapDistance)) ) return {x: x, y: y};
    //
    //     return false;
    // }


    //http://stackoverflow.com/a/6868610
    //Tested and Working
    static calcNearestPointOnLine(pt1, pt2, pnt) {
        const L2 = (((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
        if (L2 === 0)
            return false;
        const r = (((pnt.x - pt1.x) * (pt2.x - pt1.x)) + ((pnt.y - pt1.y) * (pt2.y - pt1.y))) / L2;

        return {
            x: pt1.x + (r * (pt2.x - pt1.x)),
            y: pt1.y + (r * (pt2.y - pt1.y))
        };
    }

    static calcDistancePointToLine(pt1, pt2, pnt) {
        const L2 = (((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
        if (L2 === 0)
            return false;
        const s = (((pt1.y - pnt.y) * (pt2.x - pt1.x)) - ((pt1.x - pnt.x) * (pt2.y - pt1.y))) / L2;
        return Math.abs(s) * Math.sqrt(L2);
    }

    static calcIsInsideLineSegment(pt1, pt2, pnt) {
        const L2 = (((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
        if (L2 === 0)
            return false;
        const r = (((pnt.x - pt1.x) * (pt2.x - pt1.x)) + ((pnt.y - pt1.y) * (pt2.y - pt1.y))) / L2;

        return (0 <= r) && (r <= 1);
    }

    static calcIsInsideThickLineSegment(pt1, pt2, pnt, _snapDistance) {
        const L2 = (((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
        if (L2 === 0)
            return false;
        const r = (((pnt.x - pt1.x) * (pt2.x - pt1.x)) + ((pnt.y - pt1.y) * (pt2.y - pt1.y))) / L2;

        //Assume line thickness is circular
        if (r < 0) {
            //Outside pt1
            return (Math.sqrt(((pt1.x - pnt.x) * (pt1.x - pnt.x)) + ((pt1.y - pnt.y) * (pt1.y - pnt.y))) <= _snapDistance);
        } else if ((0 <= r) && (r <= 1)) {
            //On the line segment
            const s = (((pt1.y - pnt.y) * (pt2.x - pt1.x)) - ((pt1.x - pnt.x) * (pt2.y - pt1.y))) / L2;
            return (Math.abs(s) * Math.sqrt(L2) <= _snapDistance);
        } else {
            //Outside pt2
            return (Math.sqrt(((pt2.x - pnt.x) * (pt2.x - pnt.x)) + ((pt2.y - pnt.y) * (pt2.y - pnt.y))) <= _snapDistance);
        }
    }

    // must overlap non funziona
    static getLineLineIntersection(p1, p2, p3, p4, _mustOverlap) {
        // non funziona _must overlap
        if (_mustOverlap) {
            let nx,
            nz,
            dn,
            x4_x3,
            pre2,
            pre3,
            pre4,
            pre5,
            pre6;
            x4_x3 = p4.x - p3.x;
            pre2 = p4.y - p3.y;
            pre3 = p2.x - p1.x;
            pre4 = p2.y - p1.y;
            pre5 = p1.y - p3.y;
            pre6 = p1.y - p3.y;
            nx = x4_x3 * pre5 - pre2 * pre6;
            nz = pre3 * pre5 - pre4 * pre6;
            dn = pre2 * pre3 - x4_x3 * pre4;
            nx /= dn;
            nz /= dn;
            // has intersection
            if ((nx >= 0) && (nx <= 1) && (nz >= 0) && (nz <= 1)) {
                nz = p1.y + nx * pre4;
                nx = p1.x + nx * pre3;
                return {
                    x: nx,
                    y: nz
                };
            } else {
                // no intersection
                return null;
            }

        } else {

            let a1,
            a2,
            b1,
            b2,
            c1,
            c2;

            a1 = p2.y - p1.y;
            b1 = p1.x - p2.x;
            c1 = p2.x * p1.y - p1.x * p2.y;
            a2 = p4.y - p3.y;
            b2 = p3.x - p4.x;
            c2 = p4.x * p3.y - p3.x * p4.y;

            const denom = a1 * b2 - a2 * b1;
            if (denom === 0)
                return null;

            //return {x:(b1*c2 - b2*c1)/denom, y:(a2*c1 - a1*c2)/denom};
            return SVGUtils.createSVGPoint((b1 * c2 - b2 * c1) / denom, (a2 * c1 - a1 * c2) / denom);
        }

    };

    // static getPolygonLineIntersection( _arrayOfPoints , _linePt1, _linePt2  )
    // {
    //     const intersectionPointList=[];
    //     let intersectionPt;
    //     const max = _arrayOfPoints.length-1;
    //     for(let i=0; i<max; i++)
    //     {
    //         //intersectionPt = GeometryUtils.getLineLineIntersection( _arrayOfPoints[i], _arrayOfPoints[i+1], _linePt1 , _linePt2 );
    //         intersectionPt = GeometryUtils.getLineLineIntersection( _arrayOfPoints[i], _arrayOfPoints[i+1], _linePt1 , _linePt2 , true );
    //         if(intersectionPt)
    //         {
    //             if( _onlyTest ) return true;
    //
    //             intersectionPointList.push(intersectionPt);
    //         }
    //     }
    //
    //     if( _onlyTest ) return false;
    //
    //     return intersectionPointList;
    // };


    static isLineLineOverlap(a, b, c, d, p, q, r, s) {
        let det,
        gamma,
        lambda;
        det = (c - a) * (s - q) - (r - p) * (d - b);
        if (det === 0) {
            return false;
        } else {
            lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
            gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }
    };

    static getPolygonLineIntersection(_arrayOfPoints, _linePt1, _linePt2) {
        let intersectionPt;
        const max = _arrayOfPoints.length - 1;
        for (let i = 0; i < max; i++) {
            //intersectionPt = GeometryUtils.getLineLineIntersection( _arrayOfPoints[i], _arrayOfPoints[i+1], _linePt1 , _linePt2 , true );
            intersectionPt = GeometryUtils.isLineLineOverlap(_arrayOfPoints[i].x, _arrayOfPoints[i].y, _arrayOfPoints[i + 1].x, _arrayOfPoints[i + 1].y, _linePt1.x, _linePt1.y, _linePt2.x, _linePt2.y);
            if (intersectionPt) {
                return true;
            }
        }

        return false;
    };

    static getAngleBetweenPoints(_point, _pivotPoint, _snapAngleRadians, _startAngle) {
        const point = {
            x: _point.x - _pivotPoint.x,
            y: _point.y - _pivotPoint.y
        };
        let angle = Math.atan2(point.y, point.x);

        if (_startAngle)
            angle -= _startAngle;

        if (_snapAngleRadians) {
            // if(_startAngle)angle -= _startAngle;
            const snapId = Math.round(angle / _snapAngleRadians);
            angle = snapId * _snapAngleRadians;
        }
        while (angle < 0)
            angle += Math.PI * 2;

        return angle;
    };

    static getElementListGlobalBBox(_elementList) {
        if (_elementList.length === 0)
            return;

        const global_bbox = _elementList[0].getGlobalBBox();

        const minPt = {
            x: global_bbox.x,
            y: global_bbox.y
        };
        const maxPt = {
            x: global_bbox.x + global_bbox.width,
            y: global_bbox.y + global_bbox.height
        };

        let xMax,
        yMax;

        function calculateMinAndMax(_bbox) {
            xMax = _bbox.x + _bbox.width;
            yMax = _bbox.y + _bbox.height;

            if (_bbox.x < minPt.x)
                minPt.x = _bbox.x;
            if (_bbox.y < minPt.y)
                minPt.y = _bbox.y;

            if (xMax > maxPt.x)
                maxPt.x = xMax;
            if (yMax > maxPt.y)
                maxPt.y = yMax;
        }

        for (let i = 1; i < _elementList.length; i++)
            calculateMinAndMax(_elementList[i].getGlobalBBox());

        global_bbox.min = minPt;
        global_bbox.max = maxPt;
        global_bbox.x = minPt.x;
        global_bbox.y = minPt.y;
        global_bbox.width = maxPt.x - minPt.x;
        global_bbox.height = maxPt.y - minPt.y;
        global_bbox.center = {
            x: global_bbox.x + (global_bbox.width / 2),
            y: global_bbox.y + (global_bbox.height / 2)
        };
        return global_bbox;
    };

    static getBBoxPointByLocationName(_sideName, _bbox) {

        _sideName = _sideName || 'left-top';

        //_bbox = _bbox || this.bbox;

        const splittedName = _sideName.split('-');

        const resultPoint = SVGUtils.createSVGPoint();

        switch (splittedName[0]) {
        case 'left':
            resultPoint.x = _bbox.x;
            break;
        case 'center':
            resultPoint.x = _bbox.x + _bbox.width / 2;
            break;
        case 'right':
            resultPoint.x = _bbox.x + _bbox.width;
            break;
        }

        switch (splittedName[1]) {
        case 'top':
            resultPoint.y = _bbox.y;
            break;
        case 'center':
            resultPoint.y = _bbox.y + _bbox.height / 2;
            break;
        case 'bottom':
            resultPoint.y = _bbox.y + _bbox.height;
            break;
        }

        return resultPoint;
    };

    /*

    static sortElementListByIndexZ ( _elementList ){
    _elementList = [].slice.call(_elementList, 0);

    function compareIndex(a,b){return a.sortIndex - b.sortIndex }

    const parentElement = _elementList[0].parentElement;

    const max = parentElement.children.length;
    let i;
    for (  i = 0; i < max; i++) parentElement.children[i].sortIndex = i;

    _elementList = _elementList.sort(compareIndex);

    for (  i = 0; i < max; i++) delete parentElement.children[i].sortIndex;

    return _elementList;
    };



    static sortByDeep( _elementList ){
    const parentList = [];

    let max = _elementList .length;
    for( let i = 0; i < max; i++){
    const parentElement = _elementList[i].parentElement;
    const indexOfParent = parentList.indexOf(parentElement);
    if(indexOfParent>-1) {
    parentList[indexOfParent].childListToSort.push( _elementList[i] );
    } else {
    parentList.push(parentElement);
    parentElement.childListToSort=[];
    parentElement.childListToSort.push( _elementList[i] );
    }
    }

    let sortedElementList = [];
    max = parentList.length;
    for( let i = 0; i < max; i++){
    let currentParent = parentList[i];
    currentParent.childListToSort = GeometryUtils.sortElementListByIndexZ(currentParent.childListToSort);
    sortedElementList = sortedElementList.concat( currentParent.childListToSort );
    delete currentParent.childListToSort;
    }

    return sortedElementList;

    }
     */

    static areElementsInEqualParent(_elementList) {
        if (_elementList.length === 0)
            return false;
        const parentElement = _elementList[0].parentElement;
        const max = _elementList.length;
        let i;
        for (i = 0; i < max; i++) {
            if (_elementList[i].parentElement !== parentElement)
                return false;
        }
        return true;
    };

    static parseTransformString(_transform) {
        const transform = {
            rotate: {
                value: 0,
                x: 0,
                y: 0
            },
            scale: {
                x: 1,
                y: 1
            }
        };

        if (!_transform)
            return transform;

        let index,
        start,
        end,
        propertiesStr,
        values;

        index = _transform.indexOf('rotate');
        if (index > -1) {
            start = _transform.indexOf('(', index + 6);
            end = _transform.indexOf(')', start);
            propertiesStr = _transform.substring(start + 1, end);
            transform.rotate = {
                value: 0,
                x: 0,
                y: 0
            };
            values = propertiesStr.split(',');
            if (values[0])
                transform.rotate.value = parseFloat(values[0]);
            if (values[1])
                transform.rotate.x = parseFloat(values[1]);
            if (values[2])
                transform.rotate.y = parseFloat(values[2]);
        }

        index = _transform.indexOf('scale');
        if (index > -1) {
            start = _transform.indexOf('(', index + 5);
            end = _transform.indexOf(')', start);
            propertiesStr = _transform.substring(start + 1, end);
            transform.scale = {
                x: 1,
                y: 1
            };
            values = propertiesStr.split(',');
            if (values[0])
                transform.scale.x = parseFloat(values[0]);
            if (values[1])
                transform.scale.y = parseFloat(values[1]);
        }

        return transform;
    };

    static getClosestPointToCubicBezier(ptX, ptY, x0, y0, x1, y1, x2, y2, x3, y3, start = 0, end = 1, slices = 80) {
        const tick = (end - start) / slices;
        let x,
        y,
        dx,
        dy;
        let best = 0,
        bestX,
        bestY;
        let bestDistance = Number.POSITIVE_INFINITY;
        let currentDistance;
        let t = start;
        while (t <= end) {
            x = (1 - t) * (1 - t) * (1 - t) * x0 + 3 * (1 - t) * (1 - t) * t * x1 + 3 * (1 - t) * t * t * x2 + t * t * t * x3;
            y = (1 - t) * (1 - t) * (1 - t) * y0 + 3 * (1 - t) * (1 - t) * t * y1 + 3 * (1 - t) * t * t * y2 + t * t * t * y3;

            dx = x - ptX;
            dy = y - ptY;
            dx *= dx;
            dy *= dy;
            currentDistance = dx + dy;
            if (currentDistance < bestDistance) {
                bestDistance = currentDistance;
                best = t;
                bestX = x;
                bestY = y;

            }
            t += tick;
        }

        return {
            x: bestX,
            y: bestY,
            t: t,
            best: best,
            tick: tick,
            slices: slices
        };
    }

    //static getClosestPointToQuadraticBezier( iterations,  ptX,  ptY,  start,  end, slices,  x0,  y0,  x1,  y1,  x2,  y2)
    static getClosestPointToQuadraticBezier(ptX, ptY, x0, y0, x1, y1, x2, y2, start = 0, end = 1, slices = 80) {
        const tick = (end - start) / slices;
        let x,
        y,
        dx,
        dy;
        let best = 0,
        bestX,
        bestY;
        let bestDistance = Number.POSITIVE_INFINITY;
        let currentDistance;
        let t = start;
        while (t <= end) {
            x = (1 - t) * (1 - t) * x0 + 2 * (1 - t) * t * x1 + t * t * x2; //quad.
            y = (1 - t) * (1 - t) * y0 + 2 * (1 - t) * t * y1 + t * t * y2; //quad.

            dx = x - ptX;
            dy = y - ptY;
            dx *= dx;
            dy *= dy;
            currentDistance = dx + dy;
            if (currentDistance < bestDistance) {
                bestDistance = currentDistance;
                best = t;
                bestX = x;
                bestY = y;
            }
            t += tick;
        }

        return {
            x: bestX,
            y: bestY,
            t: t,
            best: best,
            tick: tick,
            slices: slices
        };
    }

}

GeometryUtils.unitProperty = {
    PIXEL: {
        unitName: 'px',
        gridStep: 1,
        drawingScale: 1,
        unitValue: 1,
        fixedDecimals: 0
    },
    KILOMETER: {
        unitName: 'km',
        gridStep: 0.37795275595312794,
        drawingScale: 1000,
        unitValue: 0.000002645833333,
        fixedDecimals: 3
    },
    METER: {
        unitName: 'm',
        gridStep: 1.8897637797656397,
        drawingScale: 20,
        unitValue: 0.0002645833333,
        fixedDecimals: 2
    },
    CENTIMETER: {
        unitName: 'cm',
        gridStep: 0.18897637797656397,
        drawingScale: 20,
        unitValue: 0.02645833333,
        fixedDecimals: 2
    },
    MILLIMETER: {
        unitName: 'mm',
        gridStep: 3.779527559531279,
        drawingScale: 1,
        unitValue: 0.2645833333,
        fixedDecimals: 0
    },
    FEET: {
        unitName: 'ft',
        gridStep: 1.152014513568638,
        drawingScale: 10,
        unitValue: 0.0008680446194226,
        fixedDecimals: 2
    },
    INCH: {
        unitName: 'in',
        gridStep: 9.59999996928,
        drawingScale: 1,
        unitValue: 0.0104166667,
        fixedDecimals: 2
    },
    YARD: {
        unitName: 'yd',
        gridStep: 0.34560435407059137,
        drawingScale: 100,
        unitValue: 0.0002893482064742,
        fixedDecimals: 2
    },
    MILE: {
        unitName: 'mi',
        gridStep: 0.06082636631640895,
        drawingScale: 100000,
        unitValue: 1.644023900422e-7,
        fixedDecimals: 3
    },
    NAUTICAL_MILE: {
        unitName: 'nm',
        gridStep: 0.6999773225490207,
        drawingScale: 100000,
        unitValue: 1.428617710583e-7,
        fixedDecimals: 3
    }
};

function DeleteTextData_action(_documentRef) {
    this.textElement = null;
    this.offset = 0;
    this.replaceCharNum = 0;
    this.updateDocumentSelection = true;
}

_ = DeleteTextData_action.prototype;

_.execute = function () {
    this.textElement.deleteTextData(this.offset, this.replaceCharNum);
    var self = this;
    this.textElement.renderRequest(null,
        function () {
        self.onExecuteEnd();
        // self.setCaretPosition( self.caretPosition )
    });

};

_.onExecuteEnd = function () {
    activeApplication.activeDocument.onChange();

    if (this.updateDocumentSelection) {
        if (this.textElement.hasAttribute('contenteditable')) {
            this.textElement.setCaretPosition(this.offset);
        } else {
            activeApplication.activeDocument.deselectAll();
            activeApplication.workspace.update();
        }
    }
};

_.setDeleteTextDataProperties = function (_textElement, _offset, _replaceCharNum) {
    this.textElement = _textElement;
    this.offset = _offset;
    this.replaceCharNum = _replaceCharNum;
};

function InsertTextData_action(_documentRef) {
    this.textElement = null;
    this.textData = null;
    this.replaceCharNum = 0;
    this.updateDocumentSelection = true;
}

_ = InsertTextData_action.prototype;

_.execute = function () {
    this.textElement.insertTextData(this.textData.offset, this.textData, this.replaceCharNum);
    var self = this;
    this.textElement.renderRequest(null,
        function () {
        self.onExecuteEnd();
    });

};

_.onExecuteEnd = function () {
    activeApplication.activeDocument.onChange();

    if (this.updateDocumentSelection) {
        if (this.textElement.hasAttribute('contenteditable')) {
            this.textElement.setCaretPosition(this.textData.offset + this.textData.text.length);
        } else {
            activeApplication.activeDocument.deselectAll();
            activeApplication.workspace.update();
        }

    }

};

_.setInsertTextDataProperties = function (_textElement, _textData, _replaceCharNum) {
    this.textElement = _textElement;
    this.textData = _textData;
    this.replaceCharNum = _replaceCharNum;
};

function SetTextDataStyle_action(_documentRef) {
    this.textElement = null;
    this.textDataStyle = null;
    this.updateDocumentSelection = true;
}

_ = SetTextDataStyle_action.prototype;

_.execute = function () {
    var max = this.textDataStyle.length;
    for (var i = 0; i < max; i++) {
        this.textElement.textData.style[this.textDataStartOffset + i] = this.textDataStyle[i]
    }

    this.textElement.renderRequest();

    this.onExecuteEnd();
};

_.onExecuteEnd = function () {
    activeApplication.activeDocument.onChange();

    if (this.updateDocumentSelection) {
        if (this.textElement.hasAttribute('contenteditable')) {}
        else {

            activeApplication.activeDocument.selectElementList([this.textElement]);
            activeApplication.workspace.update();
        }
    }

    //activeApplication.activeDocument.showSelectionProperties();
};

// _.setTextRange = function ( _start , _end )
// {
// 	this.textDataStartOffset =  _start;
// 	this.maxChars =  _end - this.textDataStartOffset;
// };


_.setTextDataStyleRange = function (_textElement, _start, _end) {
    this.textElement = _textElement;
    // this.textDataStartOffset =  this.textElement.storedTextSelectionRange.textDataStartOffset;
    // this.maxChars =  this.textElement.storedTextSelectionRange.textDataEndOffset - this.textDataStartOffset;

    this.textDataStartOffset = _start;
    this.maxChars = _end - this.textDataStartOffset;

    var style,
    clonedStyle,
    propertyName;
    this.textDataStyle = new Array(this.maxChars);

    for (var i = 0; i <= this.maxChars; i++) {
        style = this.textElement.textData.style[this.textDataStartOffset + i];

        if (style) {
            clonedStyle = {};
            for (propertyName in style)
                clonedStyle[propertyName] = style[propertyName];
            this.textDataStyle[i] = clonedStyle;
        }
    }

};

class ButtonsPanel_cmp extends PopUpPanel {

    constructor() {
        super();
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onClickOnToolButton(_e) {
        const buttonTool = _e.target;
        const toolName = buttonTool.dataset.toolName;
        activeApplication.setActiveTool(toolName);
        PopUpPanel.deactivateAllPopUpPanels();
    }
}

customElements.define("buttons-panel", ButtonsPanel_cmp);

class PageListInspector_cmp extends PopUpPanel {

    constructor() {
        super();
        this.pageViewList = this.querySelector('.itemList');
        this.pageViewTemplate = this.pageViewList.querySelector('li');
        this.pageViewList.removeChildren();
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    // activateBy( _activatorElement , _mode, _selectActivator)
    // {
    //     super.activateBy( _activatorElement , _mode, _selectActivator );
    //     this.update();
    // }

    update() {
        //if( (this.parentElement.offsetParent === null) ) return;
        this.drawPageList();
    }

    drawPageList() {
        const pageList = activeApplication.activeDocument.pageList.children;
        let pageView,
        pageImage,
        currentPage;

        this.pageViewList.removeChildren();

        const max = pageList.length;

        for (let i = 0; i < max; i++) {
            currentPage = pageList[i];
            pageView = this.pageViewTemplate.cloneNode(true);
            pageView.pageRef = currentPage;
            pageImage = activeApplication.activeDocument.getPagePreview(currentPage);
            pageImage.classList.add('dropShadow');
            pageView.querySelector('.page-preview').appendChild(pageImage);
            pageView.querySelector('.label').innerHTML = String(i + 1);
            if (pageView.pageRef.hasAttribute('id')) {
                pageView.querySelector('.label').innerHTML = pageView.pageRef.getAttribute('id');
            } else {
                pageView.querySelector('.label').innerHTML = String(i + 1);
            }
            this.pageViewList.appendChild(pageView);

            if (currentPage.classList.contains('showed')) {
                pageView.classList.add('selected');
                pageView.classList.add('active');
            } else {
                pageView.classList.remove('selected');
                pageView.classList.remove('active');
            }
        }

    }

    updatePageNumber() {
        const pageVieList = this.pageViewList.children;
        const max = pageVieList.length;
        let i,
        pageView;
        for (i = 0; i < max; i++) {
            pageView = pageVieList[i];
            if (pageView.pageRef.hasAttribute('id')) {
                pageView.querySelector('.label').innerHTML = pageView.pageRef.getAttribute('id');
            } else {
                pageView.querySelector('.label').innerHTML = String(i + 1);
            }

        }
    }

    onClick_menu(_e) {

        const activatorElement = _e.target;
        const menuToActivate = document.querySelector('#POP_UP_MENUS>#' + activatorElement.dataset.menuActivator);
        if (menuToActivate)
            menuToActivate.activateBy(activatorElement);
    }

    onClick_newPage() {
        const newPage = activeApplication.activeDocument.createNewPage();
        activeApplication.activeDocument.setActivePage(newPage);
        this.drawPageList();
        //newPage.focus(true); // trovare una alternativa
        this.adjustPosition();
        // const self=this;
        // setTimeout(function(){ self.adjustPosition() },1000);
    };

    onClick_removePage() {
        const pageListToRemove = this.pageViewList.querySelectorAll('.selected');

        if (pageListToRemove.length === this.pageViewList.children.length) {
            document.querySelector('alert-dialog').open('Invalid operation', 'You can not remove all pages from the document.');
            return;
        }

        const self = this;

        function onConfirm_Ok() {
            for (let i = 0; i < pageListToRemove.length; i++)
                pageListToRemove[i].pageRef.remove();
            activeApplication.activeDocument.setActivePage(activeApplication.activeDocument.pageList.firstElementChild);
            self.drawPageList();
            this.close();
        }

        document.querySelector('confirm-dialog').open('Confirm', 'Are you sure you want to remove the selected pages?', onConfirm_Ok);

    };

    // questi due metodi differiscono dal comune impilamento degli elementi grafici
    // in quanto la pagina sopra in realta è la prima dei figli
    onClick_bringPageUp() {
        const activePagePreview = this.pageViewList.querySelector('.selected');
        activePagePreview.sendDown();
        activePagePreview.pageRef.sendDown();
        this.updatePageNumber();
    };

    onClick_sendPageDown() {
        var activePagePreview = this.pageViewList.querySelector('.selected');
        activePagePreview.bringUp();
        activePagePreview.pageRef.bringUp();
        this.updatePageNumber();
    };

    onClickItemList(_e) {
        if (_e.target.nodeName === 'UL') {
            const pageListToDeselect = this.pageViewList.querySelectorAll('.selected:not(.active)');
            for (let i = 0; i < pageListToDeselect.length; i++)
                pageListToDeselect[i].classList.remove('selected');
            return;
        }

        const pageView = _e.target.closest('li');

        if (pageView.classList.contains('selected')) {
            if (_e.shiftKey) {
                XOS.deselectElement(pageView);
            } else {
                pageView.applyClass('active');
                activeApplication.activeDocument.setActivePage(pageView.pageRef);
            }
        } else {
            if (_e.shiftKey) {
                XOS.selectElement(pageView, 'add');
            } else {
                XOS.selectElement(pageView, 'unique');
                pageView.applyClass('active');
                activeApplication.activeDocument.setActivePage(pageView.pageRef);
            }
        }
    };

    // chiamato dall'applicazione
    onCopy(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.exitFrom_AllIsolateLayerEditing();

        const selectedPageViewList = this.pageViewList.querySelectorAll('.selected');

        const pageListToSerialize = [];
        for (let i = 0; i < selectedPageViewList.length; i++)
            pageListToSerialize.push(selectedPageViewList[i].pageRef);

        const clipboardDocument = new DocumentSerializer().serialize(activeApplication.activeDocument, {
            pageList: pageListToSerialize
        });
        //clipboardDocument.setAttribute('clipboard-id' ,activeApplication.activeDocument.getAttribute('id') ); // questo non ci deve essere
        //console.log( new XMLSerializer().serializeToString(clipboardDocument) );
        _e.clipboardData.setData('text/plain', new XMLSerializer().serializeToString(clipboardDocument));

        _e.preventDefault();
    }

    onCut(_e) {

        const selectedPageViewList = this.pageViewList.querySelectorAll('.selected');

        if (selectedPageViewList.length === this.pageViewList.children.length) {
            document.querySelector('alert-dialog').open('Invalid operation', 'You can not remove all pages from the document.');
            return;
        }

        this.onCopy(_e);

        for (let i = 0; i < selectedPageViewList.length; i++)
            selectedPageViewList[i].pageRef.remove();
        activeApplication.activeDocument.setActivePage(activeApplication.activeDocument.pageList.firstElementChild);
        this.drawPageList();
    }

}

customElements.define("page-list-inspector", PageListInspector_cmp);

class RectangularTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.bboxPivotLocationName = 'left-top';
        this.isLocalMode = true;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);

    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let bbox,
        bboxPivotPosition;
        this.isLocalMode = activePage.selectionList.length === 1;
        // const bbox = activeApplication.workspace.bboxInteraction2D.selectionBBox || activeEditableElement.getLocalBBox();

        if (this.isLocalMode) {
            bbox = activeApplication.workspace.bboxInteraction2D.selectionBBox || activeEditableElement.getLocalBBox();
            const decomposedMatrix = activeEditableElement.getTransform().matrix.decompose();
            this.controlledElements.rotation.value = activeDocument.valueToFixed(decomposedMatrix.rotation * (180 / Math.PI)) + ' °';
            this.controlledElements.sizeX.value = activeDocument.valueToUnit(bbox.width * decomposedMatrix.scaleX);
            this.controlledElements.sizeY.value = activeDocument.valueToUnit(bbox.height * decomposedMatrix.scaleY);

            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox).matrixTransform(activeEditableElement.getTransformToElement(activeEditableElement.parentElement));

            if (activeEditableElement.parentElement.classList.contains('layer')) {
                bboxPivotPosition.x -= activeDocument.preferences.origin.x;
                bboxPivotPosition.y -= activeDocument.preferences.origin.y;
            }

            this.controlledElements.positionX.value = activeDocument.valueToUnit(bboxPivotPosition.x);
            this.controlledElements.positionY.value = activeDocument.valueToUnit(bboxPivotPosition.y);
            this.controlledElements.scaleTo.value = '100 %';
            this.controlledElements.scaleX.value = activeDocument.valueToFixed(decomposedMatrix.scaleX * 100) + ' %';
            this.controlledElements.scaleY.value = activeDocument.valueToFixed(decomposedMatrix.scaleY * 100) + ' %';
            this.controlledElements.skewX.value = activeDocument.valueToFixed(decomposedMatrix.skewX) + ' °';
            this.controlledElements.skewY.value = activeDocument.valueToFixed(decomposedMatrix.skewY) + ' °';

            // ruoto sempre pivot-display con la rotazione globale (sarà più facile capire in pivot-display i riferimenti relativi ai punti del bbox)
            const elementGlobalMatrix = activeEditableElement.getCTM();
            const rotation = elementGlobalMatrix.getRotation();
            this.controlledElements['pivot-display'].querySelector('.bbox').setAttribute('style', 'transform:rotate(' + rotation + 'deg)');
        } else {
            bbox = activeApplication.workspace.bboxInteraction2D.selectionBBox || GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
            const matrixInContentSpace = activePage.content.getCTM().inverse();

            bbox.min = SVGUtils.createSVGPoint(bbox.min.x, bbox.min.y).matrixTransform(matrixInContentSpace);
            bbox.max = SVGUtils.createSVGPoint(bbox.max.x, bbox.max.y).matrixTransform(matrixInContentSpace);

            bbox.min.x -= activeDocument.preferences.origin.x;
            bbox.min.y -= activeDocument.preferences.origin.y;
            bbox.max.x -= activeDocument.preferences.origin.x;
            bbox.max.y -= activeDocument.preferences.origin.y;
            bbox.x = bbox.min.x;
            bbox.y = bbox.min.y;

            bbox.width = bbox.max.x - bbox.min.x;
            bbox.height = bbox.max.y - bbox.min.y;
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox);

            this.controlledElements.positionX.value = activeDocument.valueToUnit(bboxPivotPosition.x);
            this.controlledElements.positionY.value = activeDocument.valueToUnit(bboxPivotPosition.y);
            this.controlledElements.sizeX.value = activeDocument.valueToUnit(bbox.width);
            this.controlledElements.sizeY.value = activeDocument.valueToUnit(bbox.height);
            this.controlledElements.rotation.value = '0 °';

            this.controlledElements.scaleX.value = '100 %';
            this.controlledElements.scaleY.value = '100 %';
            this.controlledElements.skewX.value = '0 °';
            this.controlledElements.skewY.value = '0 °';

            this.controlledElements['pivot-display'].querySelector('.bbox').setAttribute('style', 'transform:rotate(0deg)');
        }

        XOS.deselectElement(this.controlledElements['mantain-aspect-ratio-button']);

        if (this.isLocalMode) {
            if (activePage.selectionList[0].dataset.mantainAspectRatio === 'true')
                XOS.selectElement(this.controlledElements['mantain-aspect-ratio-button']);
        } else if (activeDocument.preferences.mantainAspectRatio === true)
            XOS.selectElement(this.controlledElements['mantain-aspect-ratio-button']);

    };

    setInputPropertyFocus(_focusField) {
        this.controlledElements[_focusField].select();
    }

    onClick_pivot(_e) {

        XOS.selectElement(_e.target);
        this.bboxPivotLocationName = _e.target.getAttribute('id');
        this.update();
    };

    onChange_positionX(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox()).matrixTransform(selectedElement.getTransformToElement(selectedElement.parentElement));
            newValue = newValue - bboxPivotPosition.x;
            if (selectedElement.parentElement.classList.contains('layer'))
                newValue += activeDocument.preferences.origin.x;
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
            const valueInGlobalSpace = SVGUtils.createSVGPoint(newValue + activeDocument.preferences.origin.x, 0).matrixTransform(activePage.content.getCTM());
            newValue = valueInGlobalSpace.x - bboxPivotPosition.x;
        }

        activeDocument.translateElementList_undable(activePage.selectionList, newValue, 0, this.isLocalMode);

    };

    onChange_positionY(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox()).matrixTransform(selectedElement.getTransformToElement(selectedElement.parentElement));
            newValue = newValue - bboxPivotPosition.y;
            if (selectedElement.parentElement.classList.contains('layer'))
                newValue += activeDocument.preferences.origin.y;
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
            const valueInGlobalSpace = SVGUtils.createSVGPoint(0, newValue + activeDocument.preferences.origin.y).matrixTransform(activePage.content.getCTM());
            newValue = valueInGlobalSpace.y - bboxPivotPosition.y;
        }

        activeDocument.translateElementList_undable(activePage.selectionList, 0, newValue, this.isLocalMode);
    };

    onChange_sizeX(_e) {
        this.applySizeX(_e.target.value);
    };

    applySizeX(_value) {
        let newValue = Math.evalExpression(_value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        newValue = activeDocument.unitToValue(newValue);

        let bbox,
        bboxPivotPosition,
        matrix;

        if (this.isLocalMode) {
            bbox = activePage.selectionList[0].getLocalBBox();
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox);
            bboxPivotPosition = bboxPivotPosition.matrixTransform(activePage.selectionList[0].getCTM());

        } else {

            bbox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox);

            // trasporto min e max del bbox in content space
            matrix = activePage.content.getCTM().inverse();
            bbox.min = SVGUtils.createSVGPoint(bbox.min.x, bbox.min.y).matrixTransform(matrix);
            bbox.max = SVGUtils.createSVGPoint(bbox.max.x, bbox.max.y).matrixTransform(matrix);
            bbox.width = bbox.max.x - bbox.min.x;
            bbox.height = bbox.max.y - bbox.min.y;
        }

        let scaleX = newValue / bbox.width;
        let scaleY = 1;

        if (this.isLocalMode) {
            if (activePage.selectionList[0].dataset.mantainAspectRatio === 'true')
                scaleY = scaleX;
        } else {
            if (activeDocument.preferences.mantainAspectRatio === true)
                scaleY = scaleX;
        }

        activeDocument.scaleElementList_undable(activePage.selectionList, scaleX, scaleY, bboxPivotPosition, this.isLocalMode);
    };

    onChange_sizeY(_e) {
        this.applySizeY(_e.target.value);
    };

    applySizeY(_value) {
        let newValue = Math.evalExpression(_value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        newValue = activeDocument.unitToValue(newValue);

        let bbox,
        bboxPivotPosition,
        matrix;

        if (this.isLocalMode) {
            bbox = activePage.selectionList[0].getLocalBBox();
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox);
            bboxPivotPosition = bboxPivotPosition.matrixTransform(activePage.selectionList[0].getCTM());
        } else {

            bbox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, bbox);

            // trasporto min e max del bbox in content space
            matrix = activePage.content.getCTM().inverse();
            bbox.min = SVGUtils.createSVGPoint(bbox.min.x, bbox.min.y).matrixTransform(matrix);
            bbox.max = SVGUtils.createSVGPoint(bbox.max.x, bbox.max.y).matrixTransform(matrix);
            bbox.width = bbox.max.x - bbox.min.x;
            bbox.height = bbox.max.y - bbox.min.y;
        }

        let scaleX = 1;
        let scaleY = newValue / bbox.height;

        if (this.isLocalMode) {
            if (activePage.selectionList[0].dataset.mantainAspectRatio === 'true')
                scaleX = scaleY;
        } else {
            if (activeDocument.preferences.mantainAspectRatio === true)
                scaleX = scaleY;
        }

        activeDocument.scaleElementList_undable(activePage.selectionList, scaleX, scaleY, bboxPivotPosition, this.isLocalMode);
    };

    onChange_rotation(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            newValue = newValue - selectedElement.getTransform().matrix.getRotation();
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox()).matrixTransform(selectedElement.getCTM());
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        }

        activeDocument.rotateElementList_undable(activePage.selectionList, newValue, bboxPivotPosition);

    };

    onChange_scaleTo(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;
        newValue = newValue / 100;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox());
            bboxPivotPosition = bboxPivotPosition.matrixTransform(selectedElement.getCTM());
            newValue = newValue / selectedElement.getTransform().matrix.decompose().scaleX;
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        }

        activeDocument.scaleElementList_undable(activePage.selectionList, newValue, newValue, bboxPivotPosition, this.isLocalMode);
    };

    onChange_scaleX(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;
        newValue = newValue / 100;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox());
            bboxPivotPosition = bboxPivotPosition.matrixTransform(selectedElement.getCTM());
            newValue = newValue / selectedElement.getTransform().matrix.decompose().scaleX;
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        }

        activeDocument.scaleElementList_undable(activePage.selectionList, newValue, 1, bboxPivotPosition, this.isLocalMode);
    };

    onChange_scaleY(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;
        newValue = newValue / 100;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        if (this.isLocalMode) {
            const selectedElement = activePage.selectionList[0];
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, selectedElement.getLocalBBox());
            bboxPivotPosition = bboxPivotPosition.matrixTransform(selectedElement.getCTM());
            newValue = newValue / selectedElement.getTransform().matrix.decompose().scaleY;
        } else {
            bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        }

        activeDocument.scaleElementList_undable(activePage.selectionList, 1, newValue, bboxPivotPosition, this.isLocalMode);
    };

    onChange_skewX(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        // lo skew può essere solo globale perchè altrimenti non è possibile fare undo e redo
        bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        activeDocument.skewElementList_undable(activePage.selectionList, newValue, null, bboxPivotPosition, false);
    };

    onChange_skewY(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let bboxPivotPosition;

        // lo skew può essere solo globale perchè altrimenti non è possibile fare undo e redo
        bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName(this.bboxPivotLocationName, GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
        activeDocument.skewElementList_undable(activePage.selectionList, null, newValue, bboxPivotPosition, false);
    };

    onChange_moveX(_e) {
        var newValue = Math.evalExpression(this.controlledElements.moveX.value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activePage.moveX = activeDocument.unitToValue(newValue);
        activeDocument.translateElementList_undable(activePage.selectionList, activePage.moveX, 0, this.isLocalMode);
    };

    onChange_moveY(_e) {
        var newValue = Math.evalExpression(this.controlledElements.moveY.value);
        if (isNaN(newValue))
            return;
        if (newValue === 0)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activePage.moveY = activeDocument.unitToValue(newValue);
        //activeDocument.unitToValue(  newValue  );
        activeDocument.translateElementList_undable(activePage.selectionList, 0, activePage.moveY, this.isLocalMode);
    };

    onClick_moveX(_e) {
        this.onChange_moveX();
    };

    onClick_moveY(_e) {
        this.onChange_moveY();
    };

    onClick_mantainAspectRatio(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return;

        const selectedElement = activePage.selectionList[0];

        if (this.isLocalMode) {
            selectedElement.dataset.mantainAspectRatio = selectedElement.dataset.mantainAspectRatio !== 'true';
        } else {
            activeDocument.preferences.mantainAspectRatio = activeDocument.preferences.mantainAspectRatio !== true;
        }

        activeApplication.workspace.update();
        //this.update();
        activeDocument.onChange();

    };

    // onClick_mantainAspectRatio ( _e )
    // {
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    //
    // 	if(activePage.selectionList.length===0) return;
    //
    // 	const selectedElement = activePage.selectionList[0];
    //
    // 	if( this.isLocalMode )
    // 	{
    // 		if(selectedElement.dataset.mantainAspectRatio==='true')
    // 		{
    // 			selectedElement.dataset.mantainAspectRatio = false;
    // 		} else {
    // 			selectedElement.dataset.mantainAspectRatio = true;
    // 		}
    // 	}
    // 	else
    // 	{
    // 		if(this.mantainAspectRatio===true)
    // 		{
    // 			this.mantainAspectRatio = false;
    // 		} else {
    // 			this.mantainAspectRatio = true;
    // 		}
    // 	}
    //
    // 	//activeApplication.workspace.update();
    // 	this.update();
    // 	activeDocument.onChange();
    //
    //
    // };

}

customElements.define("rectangular-transform-inspector", RectangularTransformInspector_cmp);

class RadialTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.isLocalMode = true;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        //const positionInContent = activeEditableElement.getTransformToElement( activePage.content ).getTranslation();
        const positionInParent = activeEditableElement.getTransformToElement(activeEditableElement.parentElement).getTranslation();
        if (activeEditableElement.parentElement.classList.contains('layer')) {
            positionInParent.x -= activeDocument.preferences.origin.x;
            positionInParent.y -= activeDocument.preferences.origin.y;
        }

        this.controlledElements.positionX.value = activeDocument.valueToUnit(positionInParent.x);
        this.controlledElements.positionY.value = activeDocument.valueToUnit(positionInParent.y);

        // const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        // const objectProperties = objectController.getProperties( activeEditableElement );

        this.objectProperties = activeEditableElement.getObjectController().getProperties(activeEditableElement);

        this.controlledElements.startAngle.value = activeDocument.valueToFixed(this.objectProperties.startAngle) + ' °';
        this.controlledElements.endAngle.value = activeDocument.valueToFixed(this.objectProperties.endAngle) + ' °';
        this.controlledElements.sweepAngle.value = activeDocument.valueToFixed(this.objectProperties.endAngle - this.objectProperties.startAngle) + ' °';

        this.controlledElements.radius.value = activeDocument.valueToUnit(this.objectProperties.radius);
        this.controlledElements.diameter.value = activeDocument.valueToUnit(this.objectProperties.radius * 2);

        // const decomposedMatrix = activeEditableElement.getTransform().matrix.decompose();
        // this.controlledElements.rotation.value = activeDocument.valueToFixed(decomposedMatrix.rotation * (180 / Math.PI) )+' °';

    };

    setInputPropertyFocus(_focusField) {
        this.controlledElements[_focusField].select();
    }

    onChange_positionX(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        const positionInParent = activeEditableElement.getTransformToElement(activeEditableElement.parentElement).getTranslation();
        newValue = newValue - positionInParent.x;
        let isLocalMode = true;

        activeDocument.translateElementList_undable(activePage.selectionList, newValue, 0, isLocalMode);
    };

    onChange_positionY(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        const positionInParent = activeEditableElement.getTransformToElement(activeEditableElement.parentElement).getTranslation();
        newValue = newValue - positionInParent.y;
        let isLocalMode = true;

        activeDocument.translateElementList_undable(activePage.selectionList, 0, newValue, isLocalMode);
    };

    onChange_startAngle(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'startAngle': newValue
        });

    };

    onChange_endAngle(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'endAngle': newValue
        });

    };

    onChange_sweepAngle(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'endAngle': this.objectProperties.startAngle + newValue
        });

    };

    onChange_radius(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'radius': newValue
        });

    };

    onChange_diameter(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.selectionList[0];

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeDocument.unitToValue(newValue);

        activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'radius': newValue / 2
        });

    };

    // onChange_rotation ( _e )
    // {
    // 	let newValue =  Math.evalExpression( _e.target.value );
    // 	if( isNaN(newValue) ) return;
    //
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    //
    // 	let bboxPivotPosition;
    //
    // 	const selectedElement = activePage.selectionList[0];
    // 	newValue = newValue - selectedElement.getTransform().matrix.getRotation();
    // 	// bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName( this.bboxPivotLocationName , selectedElement.getLocalBBox() ).matrixTransform( selectedElement.getCTM() );
    //
    // 	bboxPivotPosition = selectedElement.getCTM().getTranslation();
    //
    // 	activeDocument.rotateElementList_undable( activePage.selectionList , newValue , bboxPivotPosition );
    //
    // };


}

customElements.define("radial-transform-inspector", RadialTransformInspector_cmp);

class LinearTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        //this.localMode = false;
        this.linePivotLocationName = 'start';
        this.controlledElements = null;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const geometryPointList = activeEditableElement.getEditableGeometryPointList();

        let point1,
        point2,
        matrix;

        point1 = geometryPointList[0].clone();
        point2 = geometryPointList[1].clone();

        // sempre in globale relativo al content
        matrix = activeEditableElement.parentElement.getTransformToElement(activePage.content);
        point1 = point1.matrixTransform(matrix);
        point2 = point2.matrixTransform(matrix);
        point1.x -= activeDocument.preferences.origin.x;
        point1.y -= activeDocument.preferences.origin.y;
        point2.x -= activeDocument.preferences.origin.x;
        point2.y -= activeDocument.preferences.origin.y;

        // if( this.localMode)
        // {
        // 	matrix = activeEditableElement.getTransformToElement( activeEditableElement.parentElement );
        // 	point1 = point1.matrixTransform(matrix);
        // 	point2 = point2.matrixTransform(matrix);
        // } else {
        // 	matrix = activeEditableElement.parentElement.getTransformToElement(activePage.content);
        // 	point1 = point1.matrixTransform(matrix);
        // 	point2 = point2.matrixTransform(matrix);
        // 	point1.x-=activeDocument.preferences.origin.x;
        // 	point1.y-=activeDocument.preferences.origin.y;
        // 	point2.x-=activeDocument.preferences.origin.x;
        // 	point2.y-=activeDocument.preferences.origin.y;
        // }

        if (this.linePivotLocationName === 'start') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y);
        } else if (this.linePivotLocationName === 'end') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point2.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point2.y);
        } else if (this.linePivotLocationName === 'center') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x + ((point2.x - point1.x) / 2));
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y + ((point2.y - point1.y) / 2));
        }

        const lineLength = point2.getDistanceFromPoint(point1);

        this.controlledElements.lineLength.value = activeDocument.valueToUnit(lineLength);

        let rotation = point1.getAngleFromPoint(point2, true);

        // ruoto sempre pivot-display con la rotazione globale (sarà più facile capire in pivot-display i riferimenti relativi ai punti del bbox)
        this.controlledElements['pivot-display'].querySelector('.bbox').setAttribute('style', 'transform:rotate(' + rotation + 'deg)');

        if (this.linePivotLocationName === 'end')
            rotation = point2.getAngleFromPoint(point1, true);
        this.controlledElements.lineOrientation.value = activeDocument.valueToFixed(rotation) + ' °';

    }

    setInputPropertyFocus(_focusField) {
        this.controlledElements[_focusField].select();
    }

    onClick_pivot(_e) {
        XOS.selectElement(_e.target);
        this.linePivotLocationName = _e.target.getAttribute('id');
        this.update();
    };

    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let pointX = parseFloat(this.controlledElements.pointX.value);
        if (isNaN(pointX))
            return;
        pointX = activeDocument.unitToValue(pointX);

        let pointY = parseFloat(this.controlledElements.pointY.value);
        if (isNaN(pointY))
            return;
        pointY = activeDocument.unitToValue(pointY);

        let matrix;
        let point = SVGUtils.createSVGPoint();

        // sempre in globale relativo al content
        point.x = pointX + activeDocument.preferences.origin.x;
        point.y = pointY + activeDocument.preferences.origin.y;
        matrix = activePage.content.getTransformToElement(activeEditableElement.parentElement); // diverso da line

        // if( this.isLocalMode)
        // {
        // 	point.x = pointX;
        // 	point.y = pointY;
        // 	matrix = activeEditableElement.parentElement.getTransformToElement( activeEditableElement );
        // } else {
        // 	point.x = pointX+activeDocument.preferences.origin.x;
        // 	point.y = pointY+activeDocument.preferences.origin.y;
        // 	matrix = activePage.content.getTransformToElement(activeEditableElement.parentElement); // diverso da line
        // }

        point = point.matrixTransform(matrix);

        let editablePointList = activeEditableElement.getEditableGeometryPointList();
        let point1 = editablePointList[0];
        let point2 = editablePointList[1];

        if (this.linePivotLocationName === 'start') {
            point1.x = point.x;
            point1.y = point.y;
        } else if (this.linePivotLocationName === 'end') {
            point2.x = point.x;
            point2.y = point.y;
        } else if (this.linePivotLocationName === 'center') {
            const centerPoint = SVGUtils.createSVGPoint(point1.x + ((point2.x - point1.x) / 2), point1.y + ((point2.y - point1.y) / 2));
            const translatePointX = point.x - centerPoint.x;
            const translatePointY = point.y - centerPoint.y;
            editablePointList[0].x += translatePointX;
            editablePointList[0].y += translatePointY;
            editablePointList[1].x += translatePointX;
            editablePointList[1].y += translatePointY;
        }

        console.log('editablePointList', editablePointList);

        //const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        const objectController = activeEditableElement.getObjectController();
        const newWidth = editablePointList[1].getDistanceFromPoint(editablePointList[0]);
        const currentTransform = activeEditableElement.getAttribute('transform');
        const undoRedoActions = activeApplication.activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'width': newWidth
        });
        //objectController.setLinearObjectPoints( activeEditableElement , editablePointList[0], editablePointList[1] );
        objectController.setLinearObjectPoints(editablePointList[0], editablePointList[1]);
        const newTransform = activeEditableElement.getAttribute('transform');
        undoRedoActions.undoAction.onExecuteEnd = function () {
            activeEditableElement.setAttribute('transform', currentTransform);
        }
        undoRedoActions.redoAction.onExecuteEnd = function () {
            activeEditableElement.setAttribute('transform', newTransform);
        }

        //
        // const undoAction = new UndoRedoAction();
        // const redoAction = new UndoRedoAction();
        // activePage.history.addUndoRedoActions( undoAction , redoAction );
        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function() {  objectController.update( activeEditableElement ); activeDocument.selectElementList([activeEditableElement]); };
        //
        // undoAction.createAttributeSnapshot( [activeEditableElement] , 'data-width,transform' );
        //
        // const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        // //if( objectController ) objectController.setEditableGeometryPointList( activeEditableElement , editablePointList );
        // if( objectController ) objectController.setLinearObjectPoints( activeEditableElement , editablePointList[0],editablePointList[1] );
        //
        // redoAction.createAttributeSnapshot( [activeEditableElement] , 'data-width,transform' );

        activeDocument.onChange();
        activeApplication.workspace.update();

    };

    onChange_lineLength(_e) {
        this.setLineLength(this.controlledElements.lineLength.value);
        this.controlledElements.lineLength.blur();
    };

    setLineLength(_value, _linePivotLocationName) {

        _linePivotLocationName = _linePivotLocationName || this.linePivotLocationName;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let lineLength = parseFloat(_value);
        if (isNaN(lineLength))
            return;
        lineLength = activeDocument.unitToValue(lineLength);

        const geometryPointList = activeEditableElement.getEditableGeometryPointList();
        let pt1 = geometryPointList[0];
        let pt2 = geometryPointList[1];

        const currentLineLength = pt2.getDistanceFromPoint(pt1);
        const scale = lineLength / currentLineLength;

        if (_linePivotLocationName === 'start') {
            pt2.x = pt1.x + ((pt2.x - pt1.x) * scale);
            pt2.y = pt1.y + ((pt2.y - pt1.y) * scale);
        } else if (_linePivotLocationName === 'end') {
            pt1.x = pt2.x + ((pt1.x - pt2.x) * scale);
            pt1.y = pt2.y + ((pt1.y - pt2.y) * scale);
        } else if (_linePivotLocationName === 'center') {
            const memorizedEndPoint = {
                x: pt2.x,
                y: pt2.y
            };
            pt2.x = pt1.x + ((pt2.x - pt1.x) * scale);
            pt2.y = pt1.y + ((pt2.y - pt1.y) * scale);
            const translatePointX = (memorizedEndPoint.x - pt2.x) / 2;
            const translatePointY = (memorizedEndPoint.y - pt2.y) / 2;
            pt1.x += translatePointX;
            pt1.y += translatePointY;
            pt2.x += translatePointX;
            pt2.y += translatePointY;
        }

        //const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        const objectController = activeEditableElement.getObjectController();
        const newWidth = geometryPointList[1].getDistanceFromPoint(geometryPointList[0]);
        const currentTransform = activeEditableElement.getAttribute('transform');
        const undoRedoActions = activeApplication.activeDocument.setPropertyObjectElementList_undable([activeEditableElement], {
            'width': newWidth
        });
        objectController.setLinearObjectPoints(geometryPointList[0], geometryPointList[1]);
        //objectController.setLinearObjectPoints( activeEditableElement , geometryPointList[0], geometryPointList[1] );
        const newTransform = activeEditableElement.getAttribute('transform');
        undoRedoActions.undoAction.onExecuteEnd = function () {
            activeEditableElement.setAttribute('transform', currentTransform);
        }
        undoRedoActions.redoAction.onExecuteEnd = function () {
            activeEditableElement.setAttribute('transform', newTransform);
        }

        // const undoAction = new UndoRedoAction();
        // const redoAction = new UndoRedoAction();
        // activePage.history.addUndoRedoActions( undoAction , redoAction );
        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function() {  objectController.update( activeEditableElement ); activeDocument.selectElementList([activeEditableElement]); };
        //
        // undoAction.createAttributeSnapshot( [activeEditableElement] , 'data-width,transform' );
        //
        // const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        // //if( objectController ) objectController.setEditableGeometryPointList( activeEditableElement , geometryPointList );
        // if( objectController ) objectController.setLinearObjectPoints( activeEditableElement , geometryPointList[0],geometryPointList[1] );
        //
        // redoAction.createAttributeSnapshot( [activeEditableElement] , 'data-width,transform' );

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

    onChange_lineOrientation(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let lineOrientation = parseFloat(this.controlledElements.lineOrientation.value);
        if (isNaN(lineOrientation))
            return;
        //lineOrientation = activeDocument.unitToValue(lineOrientation);


        const geometryPointList = activeEditableElement.getEditableGeometryPointList();
        const pt1 = geometryPointList[0];
        const pt2 = geometryPointList[1];

        let orientedPoint = SVGUtils.createSVGPointPolar(pt2.getDistanceFromPoint(pt1), lineOrientation * (Math.PI / 180));

        if (this.linePivotLocationName === 'start') {
            pt2.x = pt1.x + orientedPoint.x;
            pt2.y = pt1.y + orientedPoint.y;
        } else if (this.linePivotLocationName === 'end') {
            pt1.x = pt2.x + orientedPoint.x;
            pt1.y = pt2.y + orientedPoint.y;
        } else if (this.linePivotLocationName === 'center') {
            const center = SVGUtils.createSVGPoint(pt1.x + (pt2.x - pt1.x) / 2, pt1.y + (pt2.y - pt1.y) / 2);
            const linearLength = pt2.getDistanceFromPoint(pt1) / 2;
            orientedPoint = SVGUtils.createSVGPointPolar(linearLength, lineOrientation * (Math.PI / 180));
            pt1.x = center.x - orientedPoint.x;
            pt1.y = center.y - orientedPoint.y;
            pt2.x = center.x + orientedPoint.x;
            pt2.y = center.y + orientedPoint.y;
        }

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            objectController.update(activeEditableElement);
            activeDocument.selectElementList([activeEditableElement]);
        };

        undoAction.createAttributeSnapshot([activeEditableElement], 'data-width,transform');

        // const objectController = OBJECTS[ activeEditableElement.dataset.objectId ];
        // if( objectController ) objectController.setLinearObjectPoints( activeEditableElement ,geometryPointList[0], geometryPointList[1] );

        const objectController = activeEditableElement.getObjectController();
        if (objectController)
            objectController.setLinearObjectPoints(geometryPointList[0], geometryPointList[1]);

        redoAction.createAttributeSnapshot([activeEditableElement], 'data-width,transform');

        activeDocument.onChange();
        activeApplication.workspace.update();
    };

}

customElements.define("linear-transform-inspector", LinearTransformInspector_cmp);

class LineTransformInspector_cmp extends LinearTransformInspector_cmp {

    constructor() {
        super();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const geometryPointList = activeEditableElement.getEditableGeometryPointList();

        let point1,
        point2,
        matrix;

        point1 = geometryPointList[0].clone();
        point2 = geometryPointList[1].clone();

        // sempre in globale relativo al content
        matrix = activeEditableElement.getTransformToElement(activePage.content);
        point1 = point1.matrixTransform(matrix);
        point2 = point2.matrixTransform(matrix);
        point1.x -= activeDocument.preferences.origin.x;
        point1.y -= activeDocument.preferences.origin.y;
        point2.x -= activeDocument.preferences.origin.x;
        point2.y -= activeDocument.preferences.origin.y;

        // if( this.localMode)
        // {
        // 	matrix = activeEditableElement.getTransformToElement( activeEditableElement.parentElement );
        // 	point1 = point1.matrixTransform(matrix);
        // 	point2 = point2.matrixTransform(matrix);
        // } else {
        // 	matrix = activeEditableElement.parentElement.getTransformToElement(activePage.content);
        // 	point1 = point1.matrixTransform(matrix);
        // 	point2 = point2.matrixTransform(matrix);
        // 	point1.x-=activeDocument.preferences.origin.x;
        // 	point1.y-=activeDocument.preferences.origin.y;
        // 	point2.x-=activeDocument.preferences.origin.x;
        // 	point2.y-=activeDocument.preferences.origin.y;
        // }

        if (this.linePivotLocationName === 'start') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y);
        } else if (this.linePivotLocationName === 'end') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point2.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point2.y);
        } else if (this.linePivotLocationName === 'center') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x + ((point2.x - point1.x) / 2));
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y + ((point2.y - point1.y) / 2));
        }

        const lineLength = point2.getDistanceFromPoint(point1);

        this.controlledElements.lineLength.value = activeDocument.valueToUnit(lineLength);

        let rotation = point1.getAngleFromPoint(point2, true);

        // ruoto sempre pivot-display con la rotazione globale (sarà più facile capire in pivot-display i riferimenti relativi ai punti del bbox)
        this.controlledElements['pivot-display'].querySelector('.bbox').setAttribute('style', 'transform:rotate(' + rotation + 'deg)');

        if (this.linePivotLocationName === 'end')
            rotation = point2.getAngleFromPoint(point1, true);
        this.controlledElements.lineOrientation.value = activeDocument.valueToFixed(rotation) + ' °';

    }

    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let pointX = parseFloat(this.controlledElements.pointX.value);
        if (isNaN(pointX))
            return;
        pointX = activeDocument.unitToValue(pointX);

        let pointY = parseFloat(this.controlledElements.pointY.value);
        if (isNaN(pointY))
            return;
        pointY = activeDocument.unitToValue(pointY);

        let matrix;
        let point = SVGUtils.createSVGPoint();

        if (this.isLocalMode) {
            point.x = pointX;
            point.y = pointY;
            matrix = activeEditableElement.parentElement.getTransformToElement(activeEditableElement);
        } else {
            point.x = pointX + activeDocument.preferences.origin.x;
            point.y = pointY + activeDocument.preferences.origin.y;
            matrix = activePage.content.getTransformToElement(activeEditableElement);
        }

        point = point.matrixTransform(matrix);

        let attributesValues;

        if (this.linePivotLocationName === 'start') {
            attributesValues = {
                'x1': point.x,
                'y1': point.y
            };
        } else if (this.linePivotLocationName === 'end') {
            attributesValues = {
                'x2': point.x,
                'y2': point.y
            };
        } else if (this.linePivotLocationName === 'center') {
            let point1 = activeEditableElement.getPt1();
            let point2 = activeEditableElement.getPt2();
            const centerPoint = SVGUtils.createSVGPoint(point1.x + ((point2.x - point1.x) / 2), point1.y + ((point2.y - point1.y) / 2));
            const translatePointX = point.x - centerPoint.x;
            const translatePointY = point.y - centerPoint.y;
            point1.x += translatePointX;
            point1.y += translatePointY;
            point2.x += translatePointX;
            point2.y += translatePointY;
            attributesValues = {
                'x1': point1.x,
                'y1': point1.y,
                'x2': point2.x,
                'y2': point2.y
            };
        }

        activeEditableElement.geometryPointList = null;

        activeDocument.setAttributeElementList_undable([activeEditableElement], attributesValues);

    };

    // onChange_lineLength(_e){
    // 	this.setLineLength(  this.controlledElements.lineLength.value  );
    // };


    setLineLength(_value, _linePivotLocationName) {

        _linePivotLocationName = _linePivotLocationName || this.linePivotLocationName;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let lineLength = parseFloat(_value);
        if (isNaN(lineLength))
            return;
        lineLength = activeDocument.unitToValue(lineLength);

        const geometryPointList = activeEditableElement.getGeometryPointList();
        let pt1 = geometryPointList[0];
        let pt2 = geometryPointList[1];

        const currentLineLength = pt2.getDistanceFromPoint(pt1);
        const scale = lineLength / currentLineLength;

        if (_linePivotLocationName === 'start') {
            pt2.x = pt1.x + ((pt2.x - pt1.x) * scale);
            pt2.y = pt1.y + ((pt2.y - pt1.y) * scale);
        } else if (_linePivotLocationName === 'end') {
            pt1.x = pt2.x + ((pt1.x - pt2.x) * scale);
            pt1.y = pt2.y + ((pt1.y - pt2.y) * scale);
        } else if (_linePivotLocationName === 'center') {
            const memorizedEndPoint = {
                x: pt2.x,
                y: pt2.y
            };
            pt2.x = pt1.x + ((pt2.x - pt1.x) * scale);
            pt2.y = pt1.y + ((pt2.y - pt1.y) * scale);
            const translatePointX = (memorizedEndPoint.x - pt2.x) / 2;
            const translatePointY = (memorizedEndPoint.y - pt2.y) / 2;
            pt1.x += translatePointX;
            pt1.y += translatePointY;
            pt2.x += translatePointX;
            pt2.y += translatePointY;
        }

        const undoRedoActions = activeDocument.setAttributeElementList_undable([activeEditableElement], {
            'x1': pt1.x,
            'y1': pt1.y,
            'x2': pt2.x,
            'y2': pt2.y
        });

        undoRedoActions.undoAction.onExecuteEnd = function () {
            activeEditableElement.geometryPointList = null;
            activeDocument.selectElementList([activeEditableElement])
        }
        undoRedoActions.redoAction.onExecuteEnd = function () {
            activeEditableElement.geometryPointList = null;
            activeDocument.selectElementList([activeEditableElement])
        }

        activeEditableElement.geometryPointList = null;
    };

    onChange_lineOrientation(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let lineOrientation = parseFloat(this.controlledElements.lineOrientation.value);
        if (isNaN(lineOrientation))
            return;
        //lineOrientation = activeDocument.unitToValue(lineOrientation);

        let undoRedoActions;

        const geometryPointList = activeEditableElement.getGeometryPointList();
        const pt1 = geometryPointList[0];
        const pt2 = geometryPointList[1];

        let orientedPoint = SVGUtils.createSVGPointPolar(pt2.getDistanceFromPoint(pt1), lineOrientation * (Math.PI / 180));

        if (this.linePivotLocationName === 'start') {
            pt2.x = pt1.x + orientedPoint.x;
            pt2.y = pt1.y + orientedPoint.y;
            undoRedoActions = activeDocument.setAttributeElementList_undable([activeEditableElement], {
                'x2': pt2.x,
                'y2': pt2.y
            });
        } else if (this.linePivotLocationName === 'end') {
            pt1.x = pt2.x + orientedPoint.x;
            pt1.y = pt2.y + orientedPoint.y;
            undoRedoActions = activeDocument.setAttributeElementList_undable([activeEditableElement], {
                'x1': pt1.x,
                'y1': pt1.y
            });
        } else if (this.linePivotLocationName === 'center') {
            const center = SVGUtils.createSVGPoint(pt1.x + (pt2.x - pt1.x) / 2, pt1.y + (pt2.y - pt1.y) / 2);
            const linearLength = pt2.getDistanceFromPoint(pt1) / 2;
            orientedPoint = SVGUtils.createSVGPointPolar(linearLength, lineOrientation * (Math.PI / 180));
            pt1.x = center.x - orientedPoint.x;
            pt1.y = center.y - orientedPoint.y;
            pt2.x = center.x + orientedPoint.x;
            pt2.y = center.y + orientedPoint.y;
            undoRedoActions = activeDocument.setAttributeElementList_undable([activeEditableElement], {
                'x1': pt1.x,
                'y1': pt1.y,
                'x2': pt2.x,
                'y2': pt2.y
            });
        }

        undoRedoActions.undoAction.onExecuteEnd = function () {
            activeEditableElement.geometryPointList = null;
            activeDocument.selectElementList([activeEditableElement]);
        }
        undoRedoActions.redoAction.onExecuteEnd = function () {
            activeEditableElement.geometryPointList = null;
            activeDocument.selectElementList([activeEditableElement]);
        }

        activeEditableElement.geometryPointList = null;
        this.update();
    };

}

customElements.define("line-transform-inspector", LineTransformInspector_cmp);

class PathPointTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const focusedPathSegmentPoint = activePage.focusedPoint;
        const activeEditableElement = focusedPathSegmentPoint.ownerShapeElement;

        // this.controlledElements.lineLength.value = activeDocument.valueToUnit( lineLength );

        // sempre in globale relativo al content
        const matrix = activeEditableElement.getTransformToElement(activePage.content);
        const pointTo = focusedPathSegmentPoint.matrixTransform(matrix);
        pointTo.x -= activeDocument.preferences.origin.x;
        pointTo.y -= activeDocument.preferences.origin.y;

        this.controlledElements.pointX.value = activeDocument.valueToUnit(pointTo.x);
        this.controlledElements.pointY.value = activeDocument.valueToUnit(pointTo.y);

    }

    // onChange_pointXY(_e){
    //
    // 	const activeDocument = activeApplication.activeDocument;
    // 	const activePage = activeDocument.activePage;
    // 	const activeEditableElement = activePage.focusedElement;
    // 	const focusedPathSegmentPoint = activePage.focusedPoint;
    //
    // 	const changedFieldName = _e.target.getAttribute('name');
    //
    // 	let newLocationValue = parseFloat( _e.target.value );
    // 	if( isNaN( newLocationValue ) ) return;
    //
    // 	const undoAction = new UndoRedoAction();
    // 	const redoAction = new UndoRedoAction();
    // 	activePage.history.addUndoRedoActions( undoAction , redoAction );
    // 	undoAction.createAttributeSnapshot( [activeEditableElement] , 'd'  );
    // 	undoAction.onExecuteEnd = redoAction.onExecuteEnd = function(){activeDocument.selectElementList([activeEditableElement]); activeEditableElement.geometryPointList = null; };
    //
    // 	if(changedFieldName==='pointX')
    // 	{
    // 		newLocationValue =  activeDocument.preferences.origin.x + activeDocument.unitToValue(newLocationValue);
    // 		const matrix = activePage.content.getTransformToElement( activeEditableElement );
    // 		const inLocal = SVGUtils.createSVGPoint(newLocationValue,0).matrixTransform(  matrix  );
    // 		focusedPathSegmentPoint.x = inLocal.x;
    // 	}
    // 	else
    // 	{
    // 		newLocationValue =  activeDocument.preferences.origin.y + activeDocument.unitToValue(newLocationValue);
    // 		const matrix = activePage.content.getTransformToElement( activeEditableElement );
    // 		const inLocal = SVGUtils.createSVGPoint(0, newLocationValue).matrixTransform(  matrix  );
    // 		focusedPathSegmentPoint.y = inLocal.y;
    // 	}
    //
    // 	console.log('focusedPathSegmentPoint',focusedPathSegmentPoint);
    // 	focusedPathSegmentPoint.ownerShapeElement.render();
    //
    // 	redoAction.createAttributeSnapshot( [activeEditableElement] , 'd' );
    //
    // 	activeApplication.workspace.update();
    // };


    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPoint;

        const changedFieldName = _e.target.getAttribute('name');

        let newLocationValue = parseFloat(_e.target.value);
        if (isNaN(newLocationValue))
            return;

        //let inLocal;

        // if(changedFieldName==='pointX')
        // {
        // 	newLocationValue =  activeDocument.preferences.origin.x + activeDocument.unitToValue(newLocationValue);
        // 	const matrix = activePage.content.getTransformToElement( activeEditableElement );
        // 	 inLocal = SVGUtils.createSVGPoint(newLocationValue,0).matrixTransform(  matrix  );
        // 	activeDocument.translateSelectedPointList_undable(  inLocal.x - focusedPathSegmentPoint.x ,   0 , true ,true   );
        // }
        // else
        // {
        // 	newLocationValue =  activeDocument.preferences.origin.y + activeDocument.unitToValue(newLocationValue);
        // 	const matrix = activePage.content.getTransformToElement( activeEditableElement );
        // 	 inLocal = SVGUtils.createSVGPoint(0, newLocationValue).matrixTransform(  matrix  );
        // 	activeDocument.translateSelectedPointList_undable(  0 ,  inLocal.y - focusedPathSegmentPoint.y , true ,true   );
        // }

        const pointInGlobalSpace = activePage.focusedPoint.ownerShapeElement.localToGlobal(focusedPathSegmentPoint.x, focusedPathSegmentPoint.y)
            if (changedFieldName === 'pointX') {
                newLocationValue = activeDocument.preferences.origin.x + activeDocument.unitToValue(newLocationValue);
                let translation = activePage.content.localToGlobal(newLocationValue, 0);
                translation.x -= pointInGlobalSpace.x;
                activeDocument.translateSelectedPointList_undable(translation.x, 0, false, true);
            } else {
                newLocationValue = activeDocument.preferences.origin.y + activeDocument.unitToValue(newLocationValue);
                let translation = activePage.content.localToGlobal(0, newLocationValue);
                translation.y -= pointInGlobalSpace.y;
                activeDocument.translateSelectedPointList_undable(0, translation.y, false, true);
            }

    };

}

customElements.define("path-point-transform-inspector", PathPointTransformInspector_cmp);

class LineToTransformInspector_cmp extends LinearTransformInspector_cmp {

    constructor() {
        super();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        let point1,
        point2,
        matrix;

        point1 = focusedPathSegmentPoint.previousSegment;
        point2 = focusedPathSegmentPoint;

        // sempre in globale relativo al content
        matrix = activeEditableElement.getTransformToElement(activePage.content);
        point1 = point1.matrixTransform(matrix);
        point2 = point2.matrixTransform(matrix);
        point1.x -= activeDocument.preferences.origin.x;
        point1.y -= activeDocument.preferences.origin.y;
        point2.x -= activeDocument.preferences.origin.x;
        point2.y -= activeDocument.preferences.origin.y;

        if (this.linePivotLocationName === 'start') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y);
        } else if (this.linePivotLocationName === 'end') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point2.x);
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point2.y);
        } else if (this.linePivotLocationName === 'center') {
            this.controlledElements.pointX.value = activeDocument.valueToUnit(point1.x + ((point2.x - point1.x) / 2));
            this.controlledElements.pointY.value = activeDocument.valueToUnit(point1.y + ((point2.y - point1.y) / 2));
        }

        const lineLength = point2.getDistanceFromPoint(point1);

        this.controlledElements.lineLength.value = activeDocument.valueToUnit(lineLength);

        let rotation = point1.getAngleFromPoint(point2, true);

        // ruoto sempre pivot-display con la rotazione globale (sarà più facile capire in pivot-display i riferimenti relativi ai punti del bbox)
        this.controlledElements['pivot-display'].querySelector('.bbox').setAttribute('style', 'transform:rotate(' + rotation + 'deg)');

        if (this.linePivotLocationName === 'end')
            rotation = point2.getAngleFromPoint(point1, true);
        this.controlledElements.lineOrientation.value = activeDocument.valueToFixed(rotation) + ' °';

    }

    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        const changedFieldName = _e.target.getAttribute('name');

        let newLocationValue = parseFloat(_e.target.value);
        if (isNaN(newLocationValue))
            return;
        newLocationValue = activeDocument.unitToValue(newLocationValue);

        let valueInGlobalSpace;

        if (changedFieldName === 'pointX') {
            valueInGlobalSpace = SVGUtils.createSVGPoint(newLocationValue + activeDocument.preferences.origin.x, 0).matrixTransform(activePage.content.getCTM());
        } else {
            valueInGlobalSpace = SVGUtils.createSVGPoint(0, newLocationValue + activeDocument.preferences.origin.y).matrixTransform(activePage.content.getCTM());
        }

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };

        // const valueInGlobalSpace = SVGUtils.createSVGPoint(newLocationValue+activeDocument.preferences.origin.x,0).matrixTransform(  activePage.content.getCTM() );
        let pointInGlobalSpace;
        if (this.linePivotLocationName === 'start') {
            activeDocument.selectPointList([focusedPathSegmentPoint.previousSegment]);
            pointInGlobalSpace = activeEditableElement.localToGlobal(focusedPathSegmentPoint.previousSegment.x, focusedPathSegmentPoint.previousSegment.y);
        } else if (this.linePivotLocationName === 'end') {
            activeDocument.selectPointList([focusedPathSegmentPoint]);
            pointInGlobalSpace = activeEditableElement.localToGlobal(focusedPathSegmentPoint.x, focusedPathSegmentPoint.y);
        } else if (this.linePivotLocationName === 'center') {
            activeDocument.selectPointList([focusedPathSegmentPoint.previousSegment, focusedPathSegmentPoint]);
            const centerPoint = SVGUtils.createSVGPoint(focusedPathSegmentPoint.previousSegment.x + ((focusedPathSegmentPoint.x - focusedPathSegmentPoint.previousSegment.x) / 2), focusedPathSegmentPoint.previousSegment.y + ((focusedPathSegmentPoint.y - focusedPathSegmentPoint.previousSegment.y) / 2));
            pointInGlobalSpace = activeEditableElement.localToGlobal(centerPoint.x, centerPoint.y);
        }

        if (changedFieldName === 'pointX') {
            const translateValue = valueInGlobalSpace.x - pointInGlobalSpace.x;
            const transformDataPointList = activeDocument.getSelectedTransformablePointData();
            activeDocument.translateTransformDataPointList(transformDataPointList, translateValue, 0, false, true);
        } else {
            const translateValue = valueInGlobalSpace.y - pointInGlobalSpace.y;
            const transformDataPointList = activeDocument.getSelectedTransformablePointData();
            activeDocument.translateTransformDataPointList(transformDataPointList, 0, translateValue, false, true);
        }

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');

        activeApplication.workspace.update();
    };

    setLineLength(_value, _linePivotLocationName) {

        _linePivotLocationName = _linePivotLocationName || this.linePivotLocationName;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        let lineLength = parseFloat(_value);
        if (isNaN(lineLength))
            return;
        lineLength = activeDocument.unitToValue(lineLength);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');

        let pt1 = focusedPathSegmentPoint.previousSegment;
        let pt2 = focusedPathSegmentPoint;

        const currentLineLength = pt2.getDistanceFromPoint(pt1);
        const scale = lineLength / currentLineLength;

        activeDocument.selectPointList([focusedPathSegmentPoint.previousSegment, focusedPathSegmentPoint]);
        const transformDataPointList = activeDocument.getSelectedTransformablePointData();

        let centerOfScalingInGlobalSpace;
        if (_linePivotLocationName === 'start') {
            centerOfScalingInGlobalSpace = activeEditableElement.localToGlobal(focusedPathSegmentPoint.previousSegment.x, focusedPathSegmentPoint.previousSegment.y);
            activeDocument.scaleTransformDataPointList(transformDataPointList, scale, scale, centerOfScalingInGlobalSpace, true);
        } else if (_linePivotLocationName === 'end') {
            centerOfScalingInGlobalSpace = activeEditableElement.localToGlobal(focusedPathSegmentPoint.x, focusedPathSegmentPoint.y);
            activeDocument.scaleTransformDataPointList(transformDataPointList, scale, scale, centerOfScalingInGlobalSpace, true);
        } else if (_linePivotLocationName === 'center') {
            const centerOfScaling = SVGUtils.createSVGPoint(pt1.x + (pt2.x - pt1.x) / 2, pt1.y + (pt2.y - pt1.y) / 2);
            centerOfScalingInGlobalSpace = activeEditableElement.localToGlobal(centerOfScaling.x, centerOfScaling.y);
            activeDocument.scaleTransformDataPointList(transformDataPointList, scale, scale, centerOfScalingInGlobalSpace, true);
        }

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

    onChange_lineOrientation(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        let lineOrientation = parseFloat(this.controlledElements.lineOrientation.value);
        if (isNaN(lineOrientation))
            return;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };

        let pt1 = focusedPathSegmentPoint.previousSegment;
        let pt2 = focusedPathSegmentPoint;

        const orientedPoint = SVGUtils.createSVGPointPolar(focusedPathSegmentPoint.getDistanceFromPoint(focusedPathSegmentPoint.previousSegment), lineOrientation * (Math.PI / 180));

        let translationPoint = SVGUtils.createSVGPoint();
        let transformDataPointList;

        if (this.linePivotLocationName === 'start') {
            activeDocument.selectPointList([focusedPathSegmentPoint]);
            translationPoint.x = (pt1.x + orientedPoint.x) - pt2.x;
            translationPoint.y = (pt1.y + orientedPoint.y) - pt2.y;
            transformDataPointList = activeDocument.getSelectedTransformablePointData();
            activeDocument.translateTransformDataPointList(transformDataPointList, translationPoint.x, translationPoint.y, true, true);
        } else if (this.linePivotLocationName === 'end') {
            activeDocument.selectPointList([focusedPathSegmentPoint.previousSegment]);
            translationPoint.x = (pt2.x + orientedPoint.x) - pt1.x;
            translationPoint.y = (pt2.y + orientedPoint.y) - pt1.y;
            transformDataPointList = activeDocument.getSelectedTransformablePointData();
            activeDocument.translateTransformDataPointList(transformDataPointList, translationPoint.x, translationPoint.y, true, true);
        } else if (this.linePivotLocationName === 'center') {
            activeDocument.selectPointList([focusedPathSegmentPoint.previousSegment, focusedPathSegmentPoint]);
            transformDataPointList = activeDocument.getSelectedTransformablePointData();
            const centerOfRotation = SVGUtils.createSVGPoint(pt1.x + (pt2.x - pt1.x) / 2, pt1.y + (pt2.y - pt1.y) / 2);
            const centerOfRotationInGlobalSpace = activeEditableElement.localToGlobal(centerOfRotation.x, centerOfRotation.y);
            let rotation = pt1.getAngleFromPoint(pt2, true);
            activeDocument.rotateTransformDataPointList(transformDataPointList, lineOrientation - rotation, centerOfRotationInGlobalSpace, true);
        }

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');

        activeApplication.workspace.update();
    }

    // onChange_lineOrientation(_e){
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    // 	const activeEditableElement = activePage.focusedElement;
    //
    //
    // 	let lineOrientation  =  parseFloat( this.controlledElements.lineOrientation.value );
    // 	if( isNaN( lineOrientation ) ) return;
    // 	lineOrientation = activeDocument.unitToValue(lineOrientation);
    //
    //
    // 	const geometryPointList = activeEditableElement.getGeometryPointList();
    // 	const pt1 = geometryPointList[0];
    // 	const pt2 = geometryPointList[1];
    //
    // 	const orientedPoint = SVGUtils.createSVGPointPolar( pt2.getDistanceFromPoint(pt1) , lineOrientation * (Math.PI/180) );
    //
    //
    // 	if(this.linePivotLocationName === 'start')
    // 	{
    // 		pt2.x=pt1.x+orientedPoint.x;
    // 		pt2.y=pt1.y+orientedPoint.y;
    // 		activeDocument.setAttributeElementList_undable(  [activeEditableElement] , {'x2':pt2.x,'y2':pt2.y }   );
    // 	}
    // 	else if(this.linePivotLocationName === 'end')
    // 	{
    // 		pt1.x=pt2.x+orientedPoint.x;
    // 		pt1.y=pt2.y+orientedPoint.y;
    // 		activeDocument.setAttributeElementList_undable(  [activeEditableElement] , {'x1':pt1.x,'y1':pt1.y }   );
    // 	}
    //
    // 	activeEditableElement.geometryPointList=null;
    // 	this.update();
    // };

}

customElements.define("line-to-transform-inspector", LineToTransformInspector_cmp);

class ArcToTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        // sempre in globale relativo al content
        const matrix = activeEditableElement.getTransformToElement(activePage.content);
        const point = focusedPathSegmentPoint.matrixTransform(matrix);
        point.x -= activeDocument.preferences.origin.x;
        point.y -= activeDocument.preferences.origin.y;

        this.controlledElements.pointX.value = activeDocument.valueToUnit(point.x);
        this.controlledElements.pointY.value = activeDocument.valueToUnit(point.y);

        const arcCenter = GeometryUtils.getArcCenter(focusedPathSegmentPoint.previousSegment.x, focusedPathSegmentPoint.previousSegment.y, focusedPathSegmentPoint.x, focusedPathSegmentPoint.y, focusedPathSegmentPoint.rx, focusedPathSegmentPoint.ry, focusedPathSegmentPoint.angle, focusedPathSegmentPoint.largeArcFlag, focusedPathSegmentPoint.sweepFlag);
        const radius = arcCenter.getDistanceFromPoint(focusedPathSegmentPoint.previousSegment);

        if (focusedPathSegmentPoint.ry === focusedPathSegmentPoint.rx) {

            this.controlledElements.radiusY.value = this.controlledElements.radiusX.value = activeDocument.valueToUnit(radius);
            this.controlledElements.radiusY.disabled = true;
        } else {

            this.controlledElements.radiusX.value = activeDocument.valueToUnit(focusedPathSegmentPoint.rx);
            this.controlledElements.radiusY.value = activeDocument.valueToUnit(focusedPathSegmentPoint.ry);
            this.controlledElements.radiusY.disabled = false;
        }

    }

    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        const changedFieldName = _e.target.getAttribute('name');

        let newLocationValue = parseFloat(_e.target.value);
        if (isNaN(newLocationValue))
            return;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };

        if (changedFieldName === 'pointX') {
            newLocationValue = activeDocument.preferences.origin.x + activeDocument.unitToValue(newLocationValue);
            const matrix = activePage.content.getTransformToElement(activeEditableElement);
            const inLocal = SVGUtils.createSVGPoint(newLocationValue, 0).matrixTransform(matrix);
            focusedPathSegmentPoint.x = inLocal.x;
        } else {
            newLocationValue = activeDocument.preferences.origin.y + activeDocument.unitToValue(newLocationValue);
            const matrix = activePage.content.getTransformToElement(activeEditableElement);
            const inLocal = SVGUtils.createSVGPoint(0, newLocationValue).matrixTransform(matrix);
            focusedPathSegmentPoint.y = inLocal.y;
        }

        focusedPathSegmentPoint.ownerShapeElement.render();

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');

        activeApplication.workspace.update();
    };

    onChange_radiusXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        const changedFieldName = _e.target.getAttribute('name');

        let newValue = parseFloat(_e.target.value);
        if (isNaN(newValue))
            return;

        newValue = activeDocument.unitToValue(newValue);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };

        const result = activeEditableElement.updateFillet(newValue, focusedPathSegmentPoint);
        redoAction.createAttributeSnapshot([activeEditableElement], 'd');
        if (result) {
            activeEditableElement.geometryPointList = null; // sono costretto a fare questo in quanto non si capisce perchè il centro non viene calcolato (forse non è lo stesso riferimento)
            activeApplication.workspace.update();
            return;
        }
        focusedPathSegmentPoint.rx = focusedPathSegmentPoint.ry = newValue;

        // if(focusedPathSegmentPoint.rx===focusedPathSegmentPoint.ry)
        // {
        // 	const result = activeEditableElement.updateFillet( newValue , focusedPathSegmentPoint  );
        // 	redoAction.createAttributeSnapshot( [activeEditableElement] , 'd' );
        // 	if(result)
        // 	{
        // 		activeEditableElement.geometryPointList = null; // sono costretto a fare questo in quanto non si capisce perchè il centro non viene calcolato (forse non è lo stesso riferimento)
        // 		activeApplication.workspace.update();
        // 		return;
        // 	}
        // }
        //
        // if(changedFieldName==='radiusX') {focusedPathSegmentPoint.rx = newValue;} else {focusedPathSegmentPoint.ry =newValue;}

        focusedPathSegmentPoint.ownerShapeElement.render();

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');

        activeEditableElement.geometryPointList = null; // sono costretto a fare questo in quanto non si capisce perchè il centro non viene calcolato (forse non è lo stesso riferimento)
        activeApplication.workspace.update();
    };

}

customElements.define("arc-to-transform-inspector", ArcToTransformInspector_cmp);

class CurveToTransformInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        // this.controlledElements.lineLength.value = activeDocument.valueToUnit( lineLength );

        // sempre in globale relativo al content
        const matrix = activeEditableElement.getTransformToElement(activePage.content);
        const pointTo = focusedPathSegmentPoint.matrixTransform(matrix);
        pointTo.x -= activeDocument.preferences.origin.x;
        pointTo.y -= activeDocument.preferences.origin.y;

        this.controlledElements.pointX.value = activeDocument.valueToUnit(pointTo.x);
        this.controlledElements.pointY.value = activeDocument.valueToUnit(pointTo.y);

    }

    onChange_pointXY(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const focusedPathSegmentPoint = activePage.focusedPathSegmentPoint;

        console.log('onChange_pointXY,', focusedPathSegmentPoint);

        const changedFieldName = _e.target.getAttribute('name');

        let newLocationValue = parseFloat(_e.target.value);
        if (isNaN(newLocationValue))
            return;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createAttributeSnapshot([activeEditableElement], 'd');
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([activeEditableElement]);
            activeEditableElement.geometryPointList = null;
        };

        if (changedFieldName === 'pointX') {
            newLocationValue = activeDocument.preferences.origin.x + activeDocument.unitToValue(newLocationValue);
            const matrix = activePage.content.getTransformToElement(activeEditableElement);
            const inLocal = SVGUtils.createSVGPoint(newLocationValue, 0).matrixTransform(matrix);
            focusedPathSegmentPoint.x = inLocal.x;
        } else {
            newLocationValue = activeDocument.preferences.origin.y + activeDocument.unitToValue(newLocationValue);
            const matrix = activePage.content.getTransformToElement(activeEditableElement);
            const inLocal = SVGUtils.createSVGPoint(0, newLocationValue).matrixTransform(matrix);
            focusedPathSegmentPoint.y = inLocal.y;
        }

        console.log('focusedPathSegmentPoint', focusedPathSegmentPoint);
        focusedPathSegmentPoint.ownerShapeElement.render();

        redoAction.createAttributeSnapshot([activeEditableElement], 'd');

        activeApplication.workspace.update();
    };

}

customElements.define("curve-to-transform-inspector", CurveToTransformInspector_cmp);

class RectInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        if (activeEditableElement.hasAttribute('rx')) {
            this.controlledElements.roundCorners.value = activeDocument.valueToUnit(activeEditableElement.getAttribute('rx'));
            this.controlledElements.roundCornersSlider.value = activeDocument.valueToFixed(parseFloat(this.controlledElements.roundCorners.value));
        } else {
            this.controlledElements.roundCorners.value = '';
            this.controlledElements.roundCornersSlider.value = 0;
        }

    };

    onChange_roundCorners(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'rx': newValue,
            'ry': newValue
        });
    }

    onSliderChangeStart_roundCorners(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'rx,ry');
    }

    onSliderChangeEnd_roundCorners(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, 'rx,ry');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();
    }

    onSliderChange_roundCorners(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.onSliderChangeStart_roundCorners(_e);
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'rx': _e.target.value,
            'ry': _e.target.value
        });
        this.controlledElements.roundCorners.value = activeDocument.valueToUnit(_e.target.value);
    }

    onClick_convertToPath(_e) {
        // if( TOOLS.activeTool !== TOOLS["selection-points-tool"] ) activeApplication.setActiveTool( "selection-points-tool" );
        // const activePage =  activeApplication.activeDocument.activePage;
        // activeApplication.activeDocument.convertElementListToPath_undable( activePage.selectionList );
    }

}

customElements.define("rect-inspector", RectInspector_cmp);

class EllipseInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        this.controlledElements.rx.value = activeDocument.valueToUnit(activeEditableElement.getAttribute('rx'));
        this.controlledElements.ry.value = activeDocument.valueToUnit(activeEditableElement.getAttribute('ry'));
    }

    onChange_rx(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const value = activeDocument.unitToValue(this.controlledElements.rx.value);
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            rx: value
        });
    };

    onChange_ry(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const value = activeDocument.unitToValue(this.controlledElements.ry.value);
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            ry: value
        });

    };

    onClick_convertToPath(_e) {
        // if( TOOLS.activeTool !== TOOLS["selection-points-tool"] ) activeApplication.setActiveTool( "selection-points-tool" );
        // const activePage =  activeApplication.activeDocument.activePage;
        // activeApplication.activeDocument.convertElementListToPath_undable( activePage.selectionList );
    }

}

customElements.define("ellipse-inspector", EllipseInspector_cmp);

class PathInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        this.simplifyTolerance = 2.5;
    }

    update() {
        // const activeDocument =  activeApplication.activeDocument;
        // const activePage =  activeDocument.activePage;
        // const activeEditableElement = activePage.focusedElement;
        //
        // let href = activeEditableElement.getAttributeNS(SVGSVGElement.XLINK_NS, 'href');
        //
        // if(href)
        // {
        // 	if(href.indexOf('data:')>-1) href = 'data:*';
        // 	this.controlledElements.href.value = href;
        // }
        //
        // let imageSizeX = activeEditableElement.getAttribute('width');
        // let imageSizeY = activeEditableElement.getAttribute('height');
        //
        // if(!imageSizeX)
        // {
        // 	const bbox = activeEditableElement.getLocalBBox();
        // 	imageSizeX = bbox.width;
        // 	imageSizeY = bbox.height;
        // }
        //
        // this.controlledElements.imageSizeX.value = activeDocument.valueToUnit( imageSizeX );
        // this.controlledElements.imageSizeY.value = activeDocument.valueToUnit( imageSizeY );

    }

    onClick_simplifyPathButton() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const paperScope = {};
        paper.install(paperScope);
        paper.setup([640, 480]);

        activePage.focusedElement.geometryPointList = null;

        let pathSource = paperScope.project.importSVG(activePage.focusedElement);
        //pathSource.simplify(this.simplifyTolerance/activePage.content.currentScale);
        //pathSource.smooth();
        pathSource.reduce();

        const resultPath = pathSource.exportSVG();
        resultPath.transformGeometryPointList(activePage.focusedElement.getTransform().matrix.inverse()); // serve a riportare i punti nello spazio di coordinate della shape originale
        resultPath.render();

        activeDocument.setAttributeElementList_undable([activePage.focusedElement], {
            d: resultPath.getAttribute('d')
        });

        // activePage.focusedElement.transformGeometryPointList(  activePage.focusedElement.getTransform().matrix.inverse() ); // serve a riportare i punti nello spazio di coordinate della shape originale
        // activePage.focusedElement.render();

        activeApplication.workspace.update();
    }

    onClick_fixPathButton() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const newPathData = activePage.focusedElement.reduceCurves();

        activePage.focusedElement.setGeometryPointList(newPathData);
        activePage.focusedElement.render();
    }

}

customElements.define("path-inspector", PathInspector_cmp);

class GroupInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        // const activeDocument =  activeApplication.activeDocument;
        // const activePage =  activeDocument.activePage;
        //const activeEditableElement = activePage.focusedElement;

        // if(activeEditableElement && activeEditableElement.nodeName==='g' && ( ! activeEditableElement.hasAttribute('clip-path') && ! activeEditableElement.hasAttribute('mask')) )
        // {
        // 	this.classList.remove('hidden');
        // } else {
        // 	this.classList.add('hidden');
        // 	return;
        // }

    };

    onClick_expand(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        activeDocument.ungroupElementList_undable();
    };

    onClick_edit(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        activeDocument.enterTo_isolateLayerEditing(activeEditableElement);
    };

}

customElements.define("group-inspector", GroupInspector_cmp);

class ImageInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        this.currentFilterName = null;
    }

    update() {
        console.log('update');
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let href = activeEditableElement.getAttributeNS(SVGSVGElement.XLINK_NS, 'href');

        if (href) {
            if (href.indexOf('data:') > -1)
                href = 'data:*';
            this.controlledElements.href.value = href;
        }

        let imageSizeX = activeEditableElement.getAttribute('width');
        let imageSizeY = activeEditableElement.getAttribute('height');

        if (!imageSizeX) {
            const bbox = activeEditableElement.getLocalBBox();
            imageSizeX = bbox.width;
            imageSizeY = bbox.height;
        }

        this.controlledElements.imageSizeX.value = imageSizeX + ' px';
        this.controlledElements.imageSizeY.value = imageSizeY + ' px';

        // this.controlledElements.imageSizeX.value = activeDocument.valueToUnit( imageSizeX );
        // this.controlledElements.imageSizeY.value = activeDocument.valueToUnit( imageSizeY );

    }

    onClickOnTabBar(_e) {
        XOS.selectElement(_e.target);
        XOS.showElement(this.querySelector('.' + _e.target.dataset.sectionTarget));
    }

    onChange_href(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        activeDocument.setAttributeElementList_undable([activeEditableElement], {
            'href': _e.target.value
        }, false);
        activeEditableElement.initializeWithOriginalSize(function () {
            activeApplication.workspace.update();
        });
    };

    // FILTERS

    onChange_filterList(_e) {
        //if(_e.target.value!=='choose-filter')XOS.showElement( this.querySelector( '.'+_e.target.value) );
        if (_e.target.value !== 'choose-filter') {
            this.currentFilterName = _e.target.value;
            XOS.showElement(this.querySelector('[data-filter-name="' + this.currentFilterName + '"]'));
        } else {
            this.currentFilterName = null;
        }
    }

    resetFilterProperties() {
        this.currentFilterName = null;
        this.controlledElements.brightness.value = this.controlledElements.contrast.value = 0;
        this.controlledElements.brightness_slider.value = this.controlledElements.contrast_slider.value = 0;

        this.controlledElements.hue.value = this.controlledElements.saturation.value = 0;
        this.controlledElements.hue_slider.value = this.controlledElements.saturation_slider.value = 0;

        this.controlledElements.vibrance.value = this.controlledElements.vibrance_slider.value = 0;

        this.controlledElements.denoise.value = this.controlledElements.denoise_slider.value = 0;
        this.controlledElements.noise.value = this.controlledElements.noise_slider.value = 0;
        this.controlledElements.sepia.value = this.controlledElements.sepia_slider.value = 0;

        this.controlledElements.filterList.value = 'choose-filter';
        XOS.hideElementChildren(this.querySelector('.filter-properties'));

    }

    onSliderChange_filterProperty(_e) {
        _e.target.nextElementSibling.value = _e.target.value;
        this.applyFilter();
    }

    onSliderChangeEnd_filterProperty(_e) {}

    onChange_filterProperty(_e) {
        const previousElement = _e.target.previousElementSibling;
        if (previousElement.nodeName === 'INPUT')
            previousElement.value = parseFloat(_e.target.value); // aggiorno lo slider
        this.applyFilter();
    }

    onClick_done(_e) {
        this.applyFilterFromOriginalAndFinalize();
    }

    initFilterData() {
        if (!this.canvasFx) {
            try {
                this.canvasFx = fx.canvas();
            } catch (e) {
                alert(e);
                return;
            }
        }

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        const self = this;

        if (!activeEditableElement.originalImage) {

            activeEditableElement.originalImage = new Image();
            activeEditableElement.originalImage.src = activeEditableElement.getAttributeNS(SVGSVGElement.XLINK_NS, 'href');

            let previewSizeX = parseInt(activeEditableElement.getAttribute('width'));
            let previewSizeY = parseInt(activeEditableElement.getAttribute('height'));

            let scale = null;

            if (previewSizeX > previewSizeY && previewSizeX > 800) {
                scale = 800 / previewSizeX;
            } else if (previewSizeY > previewSizeX && previewSizeY > 800) {
                scale = 800 / previewSizeY;
            }

            if (scale) {
                const resizedImageForTexture = new Image();
                resizedImageForTexture.src = activeEditableElement.resizeTo(previewSizeX * scale, previewSizeY * scale);
                resizedImageForTexture.onload = function () {
                    activeEditableElement.texture = self.canvasFx.texture(resizedImageForTexture);
                }
            } else {
                activeEditableElement.originalImage.onload = function () {
                    activeEditableElement.texture = self.canvasFx.texture(activeEditableElement.originalImage);
                }
            }

            function onMouseDown(_e) {
                const imagePropertySection = _e.target.closest('.filter-properties');
                if (imagePropertySection)
                    return;

                _e.stopPropagation();
                _e.preventDefault();
                document.removeEventListener('mousedown', onMouseDown, true);

                function onClick_OK() {
                    this.close();
                    self.applyFilterFromOriginalAndFinalize();
                }

                function onClick_CANCEL() {
                    this.close();
                    activeEditableElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', activeEditableElement.originalImage.src);
                    activeEditableElement.texture = activeEditableElement.originalImage = null;
                    self.resetFilterProperties();
                }

                DIALOGS['confirmDialog'].open(localString('Apply filter'), localString('Do you want to apply the filter to image ?'), onClick_OK, onClick_CANCEL);

            }

            activeEditableElement.mouseEventlistenerToRemove = onMouseDown; // devo inserirlo qui perchè quando uno clicca su done deve rimuovere il gestore dell mouseDown

            document.addEventListener('mousedown', onMouseDown, true);
        }

    }

    applyFilterFromOriginalAndFinalize() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        activeEditableElement.texture = this.canvasFx.texture(activeEditableElement.originalImage);
        this.applyFilter();
        activeEditableElement.texture = activeEditableElement.originalImage = null;
        this.resetFilterProperties();
        document.removeEventListener('mousedown', activeEditableElement.mouseEventlistenerToRemove, true);
    }

    applyFilter() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        if (!activeEditableElement.originalImage)
            this.initFilterData();

        if (!activeEditableElement.texture)
            return;

        switch (this.currentFilterName) {
        case 'brightnessContrast':
            this.canvasFx.draw(activeEditableElement.texture).brightnessContrast(parseFloat(this.controlledElements.brightness.value), parseFloat(this.controlledElements.contrast.value)).update();
            break;
        case 'hueSaturation':
            this.canvasFx.draw(activeEditableElement.texture).hueSaturation(parseFloat(this.controlledElements.hue.value), parseFloat(this.controlledElements.saturation.value)).update();
            break;
        case 'vibrance':
            this.canvasFx.draw(activeEditableElement.texture).vibrance(parseFloat(this.controlledElements.vibrance.value)).update();
            break;
        case 'denoise':
            this.canvasFx.draw(activeEditableElement.texture).denoise(parseFloat(this.controlledElements.denoise.value)).update();
            break;
        case 'noise':
            this.canvasFx.draw(activeEditableElement.texture).noise(parseFloat(this.controlledElements.noise.value)).update();
            break;
        case 'sepia':
            this.canvasFx.draw(activeEditableElement.texture).sepia(parseFloat(this.controlledElements.sepia.value)).update();
            break;
        }

        activeEditableElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', this.canvasFx.toDataURL("image/png"));
    }

}

customElements.define("image-inspector", ImageInspector_cmp);

class ClippedContentInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {};

    onClick_expand(_e) {
        activeApplication.activeDocument.ungroupElementList_undable();
    };

    onClick_edit(_e) {
        activeApplication.activeDocument.enterTo_isolateLayerEditing(activeApplication.activeDocument.activePage.activeEditableElement);
    };

}

customElements.define("clipped-content-inspector", ClippedContentInspector_cmp);

class MaskedContentInspector extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {};

    onClick_expand(_e) {
        activeApplication.activeDocument.ungroupElementList_undable();
    };

    onClick_edit(_e) {
        activeApplication.activeDocument.enterTo_isolateLayerEditing(activeApplication.activeDocument.activePage.focusedElement);
    };

}

customElements.define("masked-content-inspector", MaskedContentInspector);

class ForeignObjectInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const type = activePage.focusedElement.getAttribute('data-type');
        if (type === 'iframe-widget') {
            let src = activePage.focusedElement.querySelector('iframe').getAttribute('src');
            if (src)
                this.controlledElements.src.value = src;
        }

    }

    onChange_src(_e) {
        activeApplication.activeDocument.setAttributeElementList_undable([activeApplication.activeDocument.activePage.focusedElement.querySelector('iframe')], {
            'src': _e.target.value
        });
    };

}

customElements.define("foreign-object-inspector", ForeignObjectInspector_cmp);

class UseInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const href = activeEditableElement.getAttribute('href') || activeEditableElement.getAttribute('xlink:href');
        this.controlledElements.id.value = href.split('#')[1];
    };

    onChange_ID(_e) {
        const idElement = this.controlledElements.id.value;
        if (idElement === '')
            return;

        function onClick_OK() {
            this.close();
            _e.target.focus();
            _e.target.select();
        }
        if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            /* Does not match*/
            DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            return;
        }
        if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            return;
        }

        _e.target.blur();

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const href = activeEditableElement.getAttribute('href') || activeEditableElement.getAttribute('xlink:href');
        const currentSymbolID = href.split('#')[1];
        const symbolToRename = activeDocument.resources.getResourceById(currentSymbolID);

        activeDocument.refactorElementID(symbolToRename, idElement, activeApplication.activeDocument.shadowRoot); // non è undable
        //activeApplication.activeDocument.onLibraryChange( "symbol-library" );

    }

    onClick_expand(_e) {
        activeApplication.activeDocument.expandUseElementList_undable();
    };

    onClick_edit(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const href = activeEditableElement.getAttribute('href') || activeEditableElement.getAttribute('xlink:href');
        const currentSymbolID = href.split('#')[1];
        const symbolToEdit = activeDocument.resources.getResourceById(currentSymbolID);
        activeDocument.enterTo_isolateLayerEditing(symbolToEdit);
    };

    onClick_cloneSymbol(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const href = activeEditableElement.getAttribute('href') || activeEditableElement.getAttribute('xlink:href');
        const symbolID = href.split('#')[1];
        const clonedSymbol = activeDocument.resources.getResourceById(symbolID).cloneNode(true);
        const newSymbolID = activeDocument.resources.createResourceIdFromExistentId(clonedSymbol.getAttribute('id'));
        activeDocument.resources.addResource(clonedSymbol, newSymbolID);
        const attributeValues = {};
        attributeValues['href'] = '#' + newSymbolID;
        activeDocument.setAttributeElementList_undable([activeEditableElement], attributeValues);
        //activePage.updateInteraction();
        //this.update();
    };

}

customElements.define("use-inspector", UseInspector_cmp);

class ObjectInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;
        const objectController = focusedElement.getObjectController();
        const propertyData = objectController.getProperties(focusedElement);
        // const objectController = OBJECTS[ focusedElement.dataset.objectId ];
        // const propertyData =  objectController.getProperties( focusedElement );
        console.log('propertyData', propertyData);
    }

}

customElements.define("object-inspector", ObjectInspector_cmp);

class TextInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        this.textAlignPanel = document.querySelector('#TEXT_ALIGN_PANEL');
        this.textDecorationPanel = document.querySelector('#TEXT_DECORATION_PANEL');
        this.textHeightSpacePanel = document.querySelector('#TEXT_HEIGHT_SPACE_PANEL');
        XOS.connectDomEvents(this.textAlignPanel.querySelectorAll('[data-event]'), this, this.controlledElements);
        XOS.connectDomEvents(this.textDecorationPanel.querySelectorAll('[data-event]'), this, this.controlledElements);
        XOS.connectDomEvents(this.textHeightSpacePanel.querySelectorAll('[data-event]'), this, this.controlledElements);
    }

    //In futuro usare questo link per tradurre il box di testo
    //https://script.google.com/macros/s/AKfycbxRehmGvsDa4ei4JpfHu1mhs2G1TAPLj2c6a0AmO2l1KvKFoiqRo-mezXioew2IrKF2Mw/exec?sourceText=ciao&sourceLanguage=it&targetLanguage=en


    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let lineHeight = activeEditableElement.getAttribute('line-height') || 'normal';
        if (isNaN(lineHeight)) {
            this.controlledElements.lineHeightSlider.value = 0;
            this.controlledElements.lineHeight.value = 'normal';
        } else {
            this.controlledElements.lineHeightSlider.value = activeDocument.valueToFixed(lineHeight);
            this.controlledElements.lineHeight.value = lineHeight + ' pt';
        }

        let letterSpacing = activeEditableElement.getAttribute('letter-spacing') || '0'; // firefox non va
        this.controlledElements.letterSpacingSlider.value = activeDocument.valueToFixed(letterSpacing);
        this.controlledElements.letterSpacing.value = activeDocument.valueToFixed(letterSpacing) + ' pt';

        let wordSpacing = activeEditableElement.getAttribute('word-spacing') || '0'; // firefox non va
        this.controlledElements.wordSpacingSlider.value = activeDocument.valueToFixed(wordSpacing);
        this.controlledElements.wordSpacing.value = activeDocument.valueToFixed(wordSpacing) + ' pt';

        const controllerName = activeEditableElement.getAttribute('data-type');

        if (controllerName === 'TextOnPath') {
            this.controlledElements.startOffset.parentElement.parentElement.classList.remove('hidden');
            this.controlledElements.startOffset.value = parseFloat(activeEditableElement.querySelector('textPath').getAttribute('startOffset') || 0);
        } else {
            this.controlledElements.startOffset.parentElement.parentElement.classList.add('hidden');
        }

        let fontFamily = activeEditableElement.getAttribute('font-family') || '';
        this.controlledElements.fontFamily.value = fontFamily;
        this.fontObject = window.GoogleFonts.getGoogleFontObjectByFamilyName(fontFamily);
        this.updateFontVariantsMenu();

        let fontSize = activeEditableElement.getAttribute('font-size') || 12;
        this.controlledElements.fontSizeSlider.value = activeDocument.valueToFixed(fontSize);
        this.controlledElements.fontSize.value = activeDocument.valueToFixed(fontSize) + ' pt';

        this.controlledElements.useRichText.checked = activeEditableElement.dataset.useRichText === "true";

        const textAlign = activeEditableElement.getAttribute('text-align') || 'left';
        let iconUrl = this.textAlignPanel.querySelector('[data-value="' + textAlign + '"] use').getAttribute('xlink:href');
        this.querySelector('[data-panel-target="TEXT_ALIGN_PANEL"] use').setAttribute('xlink:href', iconUrl);

        let textDecoration = 'none';
        if (activeEditableElement.hasAttribute('text-decoration'))
            textDecoration = activeEditableElement.getAttribute('text-decoration');
        console.log('textDecoration', textDecoration);
        iconUrl = this.textDecorationPanel.querySelector('[data-value="' + textDecoration + '"] use').getAttribute('xlink:href');
        this.querySelector('[data-panel-target="TEXT_DECORATION_PANEL"] use').setAttribute('xlink:href', iconUrl);

    }

    // onClickOnPanelActivator(_e)
    // {
    // 	//this.getSelection();
    // 	console.log('onClickOnPanelActivator' , _e);
    // 	const button = _e.target;
    //
    // 	if(button.dataset.panelTarget)
    // 	{
    // 		const panelToActivate = PANELS[button.dataset.panelTarget];
    // 		panelToActivate.activateBy(button,undefined);
    // 	}
    //
    // 	_e.preventDefault();
    // 	_e.stopPropagation();
    // 	return false;
    // }


    updateFontVariantsMenu() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.controlledElements.fontVariants.removeChildren();
        if (this.fontObject == null)
            return;
        let i,
        variant,
        option,
        variantInfo;
        for (i = 0; i < this.fontObject.variants.length; i++) {
            variant = this.fontObject.variants[i];
            option = document.createElement('option');
            variantInfo = window.GoogleFonts.getGoogleFontStyleAndWeightByVariantName(variant);
            option.appendChild(document.createTextNode(variantInfo.name));
            option.setAttribute('value', variant);
            this.controlledElements.fontVariants.appendChild(option);
        }

        let activeEditableElement = activePage.focusedElement;

        let fontWeight = activeEditableElement.getAttribute('font-weight') || 'normal';
        let fontStyle = activeEditableElement.getAttribute('font-style') || 'regular';

        this.controlledElements.fontVariants.value = window.GoogleFonts.getGoogleFontVariantNameByStyleAndWeight(fontStyle, fontWeight);
    };

    onChange_fontVariants(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.applyFontElementList_undable(activePage.selectionList, this.fontObject, _e.target.value);
        activePage.selectionList[0].focus();
    }

    // updateFontVariantsMenu (  )
    // {
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    // 	this.controlledElements.fontVariants.removeChildren();
    // 	if(this.fontObject==null) return;
    // 	let i,variant,option, variantInfo;
    // 	for(i=0;i<this.fontObject.variants.length;i++ )
    // 	{
    // 		variant = this.fontObject.variants[i];
    // 		option = document.createElement('option');
    // 		variantInfo = window.GoogleFonts.getGoogleFontStyleAndWeightByVariantName(variant);
    // 		option.appendChild( document.createTextNode(variantInfo.name));
    // 		option.setAttribute('value',variant);
    // 		this.controlledElements.fontVariants.appendChild(option);
    // 	}
    //
    // 	let activeEditableElement = activePage.activeEditableElement;
    //
    // 	let fontWeight = activeEditableElement.getAttribute('font-weight') || 'normal';
    // 	let fontStyle = activeEditableElement.getAttribute('font-style') || 'regular';
    //
    // 	this.controlledElements.fontVariants.value = window.GoogleFonts.getGoogleFontVariantNameByStyleAndWeight(fontStyle,fontWeight);
    // };
    //
    //
    // onChange_fontVariants(_e){
    //
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    // 	activeDocument.applyFontElementList_undable( activePage.selectionList , this.fontObject , _e.target.value );
    // 	activePage.selectionList[0].focus();
    // }

    onClick_showFontLibrary(_e) {

        //activeApplication.windows['font-library-window'].open(true);

        WINDOWS['mainLibraryWindow'].showSection("font-library");

        //document.querySelector('left-tool-bar div[data-content-target="FONT_LIBRARY"]').click();


    };

    // FONT SIZE

    onChange_fontSize(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'font-size': newValue
        }, true, 300);
    }

    onSliderChangeStart_fontSize(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'font-size');
    }

    onSliderChangeEnd_fontSize(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, 'font-size');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();

    }

    onSliderChange_fontSize(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.onSliderChangeStart_fontSize(_e);
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'font-size': _e.target.value
        });
        this.controlledElements.fontSize.value = _e.target.value + ' pt';
    }

    onChange_textDecoration(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const filteredElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'text');
        if (filteredElementList.length === 0)
            return;
        activeDocument.setAttributeElementList_undable(filteredElementList, {
            'text-decoration': _e.target.value
        });
        // activeDocument.updateInteraction( 202 );
        filteredElementList[0].focus();
    }

    onChange_useRichText(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const filteredElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'text');
        if (filteredElementList.length === 0)
            return;
        activeDocument.setAttributeElementList_undable(filteredElementList, {
            'data-use-rich-text': String(_e.target.checked)
        });
        filteredElementList[0].focus();
    }

    // LINE-HEIGHT

    onChange_lineHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            newValue = 'normal';
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'line-height': newValue
        }, true, 300);
    }

    onSliderChangeStart_lineHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'line-height');
    }

    onSliderChangeEnd_lineHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, 'line-height');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();

    }

    onSliderChange_lineHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.onSliderChangeStart_lineHeight(_e);
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'line-height': _e.target.value
        });
        this.controlledElements.lineHeight.value = _e.target.value + ' pt';
    }

    // LETTER-SPACING

    onChange_letterSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'letter-spacing': newValue
        }, true, 300);
    }

    onSliderChangeStart_letterSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'letter-spacing');
    }

    onSliderChangeEnd_letterSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, 'letter-spacing');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();

    }

    onSliderChange_letterSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.onSliderChangeStart_letterSpacing(_e);
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'letter-spacing': _e.target.value
        });
        this.controlledElements.letterSpacing.value = _e.target.value + ' pt';
    }

    // WORD-SPACING

    onChange_wordSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'word-spacing': newValue
        }, true, 300);
    }

    onSliderChangeStart_wordSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'word-spacing');
    }

    onSliderChangeEnd_wordSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, 'word-spacing');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();

    }

    onSliderChange_wordSpacing(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.onSliderChangeStart_wordSpacing(_e);
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'word-spacing': _e.target.value
        });
        this.controlledElements.wordSpacing.value = _e.target.value + ' pt';
    }

    // START OFFSET

    onChange_startOffset(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const textPathElement = activePage.activeEditableElement.querySelector('textPath');
        if (textPathElement) {
            activeDocument.setAttributeElementList_undable([textPathElement], {
                'startOffset': Math.evalExpression(_e.target.value)
            });
        }
        activeDocument.onChange();
        //activeApplication.workspace.update();

    };

    onSliderChangeStart_startOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        const textPathElement = activeEditableElement.querySelector('textPath');
        this.undoAction.createAttributeSnapshot([textPathElement], 'startOffset');
    }

    onSliderChangeEnd_startOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const textPathElement = activeEditableElement.querySelector('textPath');
        this.redoAction.createAttributeSnapshot([textPathElement], 'startOffset');
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        activeApplication.workspace.update();

    }

    onSliderChange_startOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        if (!this.undoAction) {
            this.onSliderChangeStart_startOffset(_e);
        }
        const textPathElement = activeEditableElement.querySelector('textPath');
        activeDocument.setAttributeElementList([textPathElement], {
            'startOffset': _e.target.value
        });
        this.controlledElements.startOffset.value = _e.target.value + ' pt';
    }

    onClick_textAlign(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const filteredElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'text');
        if (filteredElementList.length === 0)
            return;
        activeDocument.setAttributeElementList_undable(filteredElementList, {
            'text-align': _e.target.getAttribute('data-value')
        });
        //_e.target.selectElement();
    };

    onClick_textDecoration(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const filteredElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'text');
        if (filteredElementList.length === 0)
            return;
        activeDocument.setAttributeElementList_undable(filteredElementList, {
            'text-decoration': _e.target.getAttribute('data-value')
        });
        //activePage.updateInteraction( 202 );
        filteredElementList[0].focus();
    }

    onClick_convertToPath(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        if (activeDocument.isTextEditing)
            activeDocument.exitFrom_TextEditing();
        if (TOOLS.activeTool !== TOOLS["selection-tool"])
            activeApplication.setActiveTool("selection-tool");
        activeDocument.convertElementListToPath_undable(activePage.selectionList);
    };

}

customElements.define("text-inspector", TextInspector_cmp);

class ElementInfoInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        if (activeEditableElement) {
            this.controlledElements.id.value = activeEditableElement.getAttribute('id') || '';
            this.controlledElements.name.value = activeEditableElement.getAttribute('data-name') || '';
            this.controlledElements.cssClass.value = activeEditableElement.getAttribute('data-css-class') || '';

            let title = '',
            titleElement = activeEditableElement.querySelector(':scope > title');
            if (titleElement)
                title = titleElement.innerHTML;
            this.controlledElements.title.value = title;

            let description = '',
            descElement = activeEditableElement.querySelector(':scope > desc');
            if (descElement)
                description = descElement.innerHTML;
            this.controlledElements.desc.value = description;

            this.controlledElements.anchorLink.value = activeEditableElement.getAttribute('data-xlink-href') || '';
            this.controlledElements.anchorLinkTarget.value = activeEditableElement.getAttribute('data-xlink-target') || '';

            const anchorNames = this.controlledElements.anchorNames;
            const template = anchorNames.firstElementChild; // la prima voce deve essere mantenuta ( <option value="no-set">choose anchor name</option> )
            anchorNames.removeChildren();
            anchorNames.appendChild(template);

            const pageList = activeApplication.activeDocument.pageList.querySelectorAll(':scope>.page[id]');
            let newOption,
            currentPage,
            idPage;

            const max = pageList.length;

            for (let i = 0; i < max; i++) {
                currentPage = pageList[i];
                if (currentPage.hasAttribute('id')) {
                    idPage = currentPage.getAttribute('id');
                    newOption = template.cloneNode();
                    newOption.value = '#' + idPage;
                    newOption.innerHTML = idPage;
                    anchorNames.appendChild(newOption);
                }
            }

        }

    }

    onChange_ID(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        const idElement = _e.target.value;

        if (idElement !== '') {
            if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
                /* Does not match*/
                DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'));
                return;
            }
            if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
                DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement);
                return;
            }

            // function onClick_OK() {
            // 	this.close();
            // 	_e.target.focus();
            // 	_e.target.select();
            // }
            //
            // if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            // 	/* Does not match*/
            // 	DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            // 	return;
            // }
            // if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            // 	DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            // 	return;
            // }
        }

        _e.target.blur();

        activeApplication.activeDocument.setAttributeElementList_undable([activeEditableElement], {
            'id': idElement
        });

    }

    onChange_title(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let titleElement = activeEditableElement.querySelector('title');

        if (_e.target.value === '') {
            if (titleElement)
                titleElement.remove();
        } else {

            if (!titleElement) {
                titleElement = document.createElementNS(SVGSVGElement.SVG_NS, 'title');
                activeEditableElement.appendChild(titleElement);
            }

            titleElement.innerHTML = XOS.stripHtml(_e.target.value);
        }
    }

    onChange_desc(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        let descElement = activeEditableElement.querySelector('desc');

        if (_e.target.value === '') {
            if (descElement)
                descElement.remove();
        } else {

            if (!descElement) {
                descElement = document.createElementNS(SVGSVGElement.SVG_NS, 'desc');
                activeEditableElement.appendChild(descElement);
            }

            descElement.innerHTML = XOS.stripHtml(_e.target.value);
        }

    }

    onChange_name(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        if (_e.target.value === '') {
            activeEditableElement.removeAttribute('data-name');
        } else {
            activeEditableElement.setAttribute('data-name', _e.target.value);
        }

    }

    onChange_cssClass(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        const value = _e.target.value;
        if (value === '') {
            activeEditableElement.removeAttribute('data-css-class');
        } else {
            activeEditableElement.setAttribute('data-css-class', value);
        }
        //activePage.setAttributeElementList_undable( activePage.selectionList , {'data-css-class':value} );
    }

    // onMouseDown_anchorNames( _e )
    // {
    //
    // 	const activeDocument =  activeApplication.activeDocument;
    // 	const activePage =  activeDocument.activePage;
    // 	const activeEditableElement = activePage.focusedElement;
    //
    // 	const pageList = activePage.parentElement.querySelectorAll('.page[id]');
    //
    // 	if(pageList.length>0)
    // 	{
    // 		const pageListOptionGroup = this.controlledElements.anchorNames.querySelector('#IDs');
    // 		let htmlString = '';
    // 		let idPage;
    // 		for(let i=0; i < pageList.length; i++ )
    // 		{
    // 			idPage = pageList[i].getAttribute('id');
    // 			if(idPage!=='')
    // 			{
    // 				htmlString+='<option value="#'+idPage+'">#'+idPage+'</option>';
    // 			}
    // 		}
    // 		pageListOptionGroup.innerHTML = htmlString;
    // 	}
    // 	console.log('onMouseDown_anchorNames pageList' , pageList );
    // }


    onChange_anchorNames(_e) {
        if (_e.target.value !== 'no-set') {
            this.controlledElements.anchorLink.value = _e.target.value;
            _e.target.value = 'no-set';
        }

        this.onChange_anchorLink();
    }

    onChange_anchorLink(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let value = this.controlledElements.anchorLink.value;
        if (value === '') {
            activeEditableElement.removeAttribute('data-xlink-href');
            activeEditableElement.removeAttribute('data-xlink-target');
        } else {
            activeEditableElement.setAttribute('data-xlink-href', value);
        }
    }

    onChange_anchorLinkTarget(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let value = _e.target.value;
        if (value === '') {
            activeEditableElement.removeAttribute('data-xlink-target');
        } else {
            activeEditableElement.setAttribute('data-xlink-target', value);
        }

    }

}

customElements.define("element-info-inspector", ElementInfoInspector_cmp);

class MarkersInspector_cmp extends HTMLElement {

    constructor() {
        super();
        PANELS[this.nodeName.toLowerCase()] = this;
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onClick_collapse(_e) {
        //console.log('onClick_collapse');
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    onClick_showMarkerLibrary() {
        WINDOWS['mainLibraryWindow'].showSection("marker-library");
    }

    update() {

        //this.querySelector('#markers-context').style.display='none';

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        let markerStartIRI = '',
        markerMidIRI = '',
        markerEndIRI = '';

        if (!focusedElement || (['line', 'path'].indexOf(focusedElement.nodeName) === -1)) {
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        markerStartIRI = focusedElement.getAttribute('marker-start') || '';
        markerMidIRI = focusedElement.getAttribute('marker-mid') || '';
        markerEndIRI = focusedElement.getAttribute('marker-end') || '';
        //if( markerStartIRI==='' && markerMidIRI==='' && markerEndIRI==='') return;

        const self = this;

        function updateMarkerDisplay(_markerSideID, _markerSourceID) {
            const sourceMarker = activeApplication.activeDocument.resources.getResourceByIRI(_markerSourceID);
            const clonedMarker = sourceMarker.cloneNode(true);
            clonedMarker.setAttribute('id', _markerSideID);
            const marker = self.querySelector('#' + _markerSideID);
            marker.parentElement.replaceChild(clonedMarker, marker);
            clonedMarker.markerRef = sourceMarker;
        }

        function resetMarkerDisplay(_markerSideID) {
            const marker = self.querySelector('#' + _markerSideID);
            marker.style.visibility = 'collapse';
            marker.markerRef = null;
        }

        if (markerStartIRI !== '') {
            updateMarkerDisplay('MARKER_START', markerStartIRI);
        } else {
            resetMarkerDisplay('MARKER_START')
        }
        if (markerMidIRI !== '') {
            updateMarkerDisplay('MARKER_MID', markerMidIRI);
        } else {
            resetMarkerDisplay('MARKER_MID')
        }
        if (markerEndIRI !== '') {
            updateMarkerDisplay('MARKER_END', markerEndIRI);
        } else {
            resetMarkerDisplay('MARKER_END')
        }
        this.updateSelectedMarkerProperties();
    }

    updateSelectedMarkerProperties() {
        const activeDocument = activeApplication.activeDocument;

        const selectedDisplay = this.querySelector('.markers-display .selected');
        this.focusedMarker = selectedDisplay.querySelector('marker').markerRef;

        if (!this.focusedMarker) {
            this.querySelector('#marker-properties').style.display = 'none';
            return;
        }

        this.querySelector('#marker-properties').style.display = 'block';

        this.controlledElements.id.value = this.focusedMarker.getAttribute('id');
        this.controlledElements.markerUnits.value = this.focusedMarker.getAttribute('markerUnits') || 'strokeWidth';
        this.controlledElements.refX.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('refX'));
        this.controlledElements.refY.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('refY'));
        this.controlledElements.markerWidth.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('markerWidth'));
        this.controlledElements.markerHeight.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('markerHeight'));
        this.controlledElements.orient.value = this.focusedMarker.getAttribute('orient');

        if (this.controlledElements.orient.value !== 'auto' && this.controlledElements.orient.value !== 'auto-start-reverse') {
            this.controlledElements.orientMode.value = 'angle';
        } else {
            this.controlledElements.orientMode.value = this.controlledElements.orient.value;
        }
    }

    onClick_markerDisplay(_e) {
        XOS.selectElement(_e.target);
        this.updateSelectedMarkerProperties();
    }

    onChange_markerID(_e) {
        const idElement = this.controlledElements.id.value;
        if (idElement === '')
            return;

        const activeDocument = activeApplication.activeDocument;

        function onClick_OK() {
            this.close();
            _e.target.focus();
            _e.target.select();
        }
        if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            /* Does not match*/
            DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            return;
        }
        if (activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            return;
        }

        _e.target.blur();

        activeDocument.refactorElementID(this.focusedMarker, idElement); // non è undable
        this.update();
        //activeDocument.onLibraryChange( "marker-library" );
    }

    onClick_cloneMarker(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const clonedResource = this.focusedMarker.cloneNode(true);
        const idNewResource = activeDocument.resources.createResourceIdFromExistentId(clonedResource.getAttribute('id'));
        activeDocument.resources.addResource(clonedResource, idNewResource);
        const href = 'url(#' + idNewResource + ')';
        const attributeValues = {};
        const attributeName = this.querySelector('.markers-display .selected').getAttribute('name');
        attributeValues[attributeName] = href;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, attributeValues);
        this.update();
        //activeApplication.workspace.update();
        //activeDocument.onLibraryChange("marker-library");
    };

    getActiveMarkerSideName() {
        return this.querySelector('.markers-display .selected').getAttribute('name');
    }

    onClick_editMarker(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.enterTo_isolateLayerEditing(this.focusedMarker);
    }

    onClick_removeMarker(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const attributeValues = {};
        const attributeName = this.querySelector('.markers-display .selected').getAttribute('name');
        attributeValues[attributeName] = '';
        activeDocument.setAttributeElementList_undable(activePage.selectionList, attributeValues);
        this.update();
    }

    onChange_markerUnits(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'markerUnits': _e.target.value
        }, false);
    }

    onChange_refX(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'refX': activeDocument.unitToValue(_e.target.value)
        }, false);
    }

    onChange_refY(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'refY': activeDocument.unitToValue(_e.target.value)
        }, false);

    }

    onChange_markerWidth(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'markerWidth': activeDocument.unitToValue(_e.target.value)
        }, false);
    }

    onChange_markerHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'markerHeight': activeDocument.unitToValue(_e.target.value)
        }, false);
    }

    onChange_orientMode(_e) {
        if (_e.target.value === 'angle') {
            this.controlledElements.orient.value = '0';
        } else {
            const activeDocument = activeApplication.activeDocument;
            activeDocument.setAttributeElementList_undable([this.focusedMarker], {
                'orient': _e.target.value
            }, false);
            this.controlledElements.orient.value = _e.target.value;
        }
    }

    onChange_orient(_e) {
        if (_e.target.value === '')
            _e.target.value = 'auto';
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setAttributeElementList_undable([this.focusedMarker], {
            'orient': _e.target.value
        }, false);
    }

}

customElements.define("markers-inspector", MarkersInspector_cmp);

class FiltersInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.init();
    }

    init() {
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);

        for (const name in this.controlledElements) {
            const inputElement = this.controlledElements[name];
            if (inputElement.dataset.type === 'color') {
                Object.defineProperty(inputElement, 'value', {
                    get: function (_value) {
                        return inputElement.querySelector('.rgba').style.backgroundColor;
                    },
                    set: function (_value) {
                        inputElement.querySelector('.rgba').style.backgroundColor = _value;
                    }
                });
            }
        }

    }

    chooseColor(_e) {
        const inputColorElement = _e.target;
        const colorPicker = PANELS['global-color-picker'];
        const self = this;
        function onChangeEnd(_colorPicker) {
            inputColorElement.value = _colorPicker.hex;
            console.log(' _colorPicker.hex', _colorPicker.hex);
            self.applyFilter();
        }

        colorPicker.set(inputColorElement.value, 1, onChangeEnd);
        colorPicker.activateBy(inputColorElement);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        XOS.hideElementChildren(this.querySelector('.filter-properties'));

        if (activeEditableElement.hasAttribute('filter')) {
            let filterRawList = activeEditableElement.getAttribute('filter').replace(/\s\s+/g, ' ').split(') ');
            for (let i = 0; i < filterRawList.length; i++) {
                const filterText = filterRawList[i];
                const filterName = filterText.substring(0, filterText.indexOf("(")).trim();
                if (filterName === "")
                    continue;
                const filterRawProperties = filterText.substring(filterText.indexOf("(") + 1).split(' ');
                const filterProperties = [];
                for (let ip = 0; ip < filterRawProperties.length; ip++)
                    if (filterRawProperties[ip] !== "" && filterRawProperties[ip] !== " ")
                        filterProperties.push(filterRawProperties[ip]);

                const filterInspector = this.querySelector('[data-filter-name="' + filterName + '"]');
                if (!filterInspector)
                    continue;

                const inputProperties = filterInspector.querySelectorAll('input[type="text"] , [data-type="color"] ');
                for (let ip = 0; ip < inputProperties.length; ip++) {
                    const inputProperty = inputProperties[ip];
                    let propertyValue = filterProperties[ip];

                    if (inputProperty.dataset.type === 'color') {
                        console.log('color', propertyValue);
                        inputProperty.value = propertyValue;
                    } else {
                        inputProperty.value = parseFloat(propertyValue) + inputProperty.dataset.unit;
                        const slider = inputProperty.previousElementSibling;
                        if (slider)
                            slider.value = parseFloat(propertyValue);
                    }
                }

                XOS.showElement(filterInspector, 'add');
            }
        }
    }

    // FILTERS
    onChange_filterList(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        if (_e.target.value !== 'add-filter') {
            const filterName = _e.target.value;

            const filterInspector = this.querySelector('[data-filter-name="' + filterName + '"]');
            const inputProperties = filterInspector.querySelectorAll('input[type="text"]')
                for (let ip = 0; ip < inputProperties.length; ip++) {
                    const inputProperty = inputProperties[ip];
                    let valueToDisplay = inputProperty.dataset.defaultValue;
                    valueToDisplay += inputProperty.dataset.unit;
                    inputProperty.value = valueToDisplay;
                }

                XOS.showElement(filterInspector, 'add');
            _e.target.value = 'add-filter';
            this.applyFilter();
        }

    }

    onSliderChange_filterProperty(_e) {
        if (_e.target.changed !== true) {
            this.onSliderChangeStart_filterProperty(_e);
            _e.target.changed = true;
        }
        const valueDisplay = _e.target.nextElementSibling;
        let newValue = _e.target.value;
        newValue += valueDisplay.dataset.unit;
        valueDisplay.value = newValue;
        this.applyFilter();
    }

    onSliderChangeEnd_filterProperty(_e) {
        _e.target.changed = false;
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionList = activePage.selectionList;
        this.redoAction.createAttributeSnapshot(selectionList, 'filter');
        this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectionList);
        };
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        console.log('onSliderChangeEnd_filterProperty');
    }

    onSliderChangeStart_filterProperty(_e) {
        console.log('onSliderChangeStart_filterProperty');
        this.createUndoRedo();
    }

    createUndoRedo() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot(activePage.selectionList, 'filter');
    }

    onChange_filterProperty(_e) {
        const previousElement = _e.target.previousElementSibling;
        if (previousElement.nodeName === 'INPUT')
            previousElement.value = parseFloat(_e.target.value); // aggiorno lo slider
        _e.target.value = parseFloat(_e.target.value) + _e.target.dataset.unit;
        this.createUndoRedo();
        this.applyFilter();

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionList = activePage.selectionList;
        this.redoAction.createAttributeSnapshot(selectionList, 'filter');
        this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectionList);
        };
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
    }

    onClick_removeFilter(_e) {
        const filterElement = _e.target.closest('[data-filter-name]');
        XOS.hideElement(filterElement);
        this.applyFilter();
    }

    applyFilter() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;
        let filterAttribute = '';

        const showedFilterInspector = this.querySelectorAll('[data-filter-name].showed');
        for (let i = 0; i < showedFilterInspector.length; i++) {
            filterAttribute += showedFilterInspector[i].dataset.filterName + '(';
            const inputProperties = showedFilterInspector[i].querySelectorAll('input[type="text"] , [data-type="color"]');
            for (let ip = 0; ip < inputProperties.length; ip++) {
                filterAttribute += ' ' + inputProperties[ip].value;
            }
            filterAttribute += ') ';
        }

        activeEditableElement.setAttribute('filter', filterAttribute);
    }
}

customElements.define("filters-inspector", FiltersInspector_cmp);

class StrokeInspector_cmp extends PopUpPanel {

    constructor() {
        super('S');

        this.strokeGradientDef = document.querySelector('#APPLICATION_DEFS #STROKE_GRADIENT');
        this.strokePatternDef = document.querySelector('#APPLICATION_DEFS #STROKE_PATTERN');
        this.strokeDisplay = this.querySelector('#STROKE_DISPLAY');

        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        //
        this.controlledElements.strokeLineCap = this.querySelector('[name="strokeLineCap"]');
        this.controlledElements.strokeLineJoin = this.querySelector('[name="strokeLineJoin"]');
    }

    onClick_collapse(_e) {
        //console.log('onClick_collapse');
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    // onClick_showMarkerLibrary()
    // {
    //     WINDOWS['mainLibraryWindow'].showSection("marker-library");
    // }

    onClickOnTabBar(_e) {
        //console.log('onClickOnTabBar', _e.target );
        XOS.selectElement(_e.target);
        XOS.showElement(this.querySelector('.' + _e.target.dataset.sectionTarget));
        //this.update( 'tab-bar' );
    }

    update() {
        this.updateStrokeWidth();
        this.updateCapAndJoin();
        this.updateDash();
        // this.updateMarkers();
    }

    updateStrokeWidth() {
        const activeDocument = activeApplication.activeDocument;
        const fillAndStrokeManager = activeDocument.fillAndStrokeManager;

        // THIKNESS
        this.controlledElements.strokeWidthSlider.value = fillAndStrokeManager['stroke-width'];
        this.controlledElements.strokeWidth.value = activeDocument.valueToFixed(fillAndStrokeManager['stroke-width']) + ' px';
        this.controlledElements.nonScalingStroke.checked = fillAndStrokeManager.nonScalingStroke;
    }

    updateCapAndJoin() {
        const activeDocument = activeApplication.activeDocument;
        const fillAndStrokeManager = activeDocument.fillAndStrokeManager;

        const strokeLineCup = fillAndStrokeManager['stroke-linecap'] || 'butt';
        XOS.selectElement(this.controlledElements.strokeLineCap.querySelector('[data-value="' + strokeLineCup + '"]'));

        const strokeLineJoin = fillAndStrokeManager['stroke-linejoin'] || 'miter';
        XOS.selectElement(this.controlledElements.strokeLineJoin.querySelector('[data-value="' + strokeLineJoin + '"]'));
    }

    updateDash() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let i;
        for (i = 0; i < 6; i++)
            this.controlledElements['strokeDashArray_' + i].value = ''; // resetto tutti i campi

        const focusedElement = activePage.focusedElement;
        if (focusedElement && focusedElement.hasAttribute('stroke-dasharray') && focusedElement.getAttribute('stroke-dasharray') !== '') {
            const strokeDashArray = focusedElement.getAttribute('stroke-dasharray').split(/,| /);
            // aggiorno con i valori
            for (i = 0; i < strokeDashArray.length; i++)
                this.controlledElements['strokeDashArray_' + i].value = activeDocument.valueToFixed(parseFloat(strokeDashArray[i]));
            this.controlledElements.strokeDashOffsetSlider.value = parseFloat(focusedElement.getAttribute('stroke-dasharray'));
            this.controlledElements.strokeDashOffset.value = activeDocument.valueToFixed(this.controlledElements.strokeDashOffsetSlider.value) + ' px';
            //this.querySelector('#stroke-dash-context').style.display='block';
        } else {
            this.controlledElements.strokeDashOffsetSlider.value = 0;
            this.controlledElements.strokeDashOffset.value = '';
            //this.querySelector('#stroke-dash-context').style.display='none';
        }
    }

    updateMarkers() {
        //this.querySelector('#markers-context').style.display='none';

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        let markerStartIRI = '',
        markerMidIRI = '',
        markerEndIRI = '';

        if (!focusedElement || (['line', 'path', 'rect', 'ellipse'].indexOf(focusedElement.nodeName) === -1))
            return;

        markerStartIRI = focusedElement.getAttribute('marker-start') || '';
        markerMidIRI = focusedElement.getAttribute('marker-mid') || '';
        markerEndIRI = focusedElement.getAttribute('marker-end') || '';
        if (markerStartIRI === '' && markerMidIRI === '' && markerEndIRI === '')
            return;

        //this.querySelector('#markers-context').style.display='block';

        const self = this;

        function updateMarkerDisplay(_markerSideID, _markerSourceID) {
            const sourceMarker = activeApplication.activeDocument.resources.getResourceByIRI(_markerSourceID);
            const clonedMarker = sourceMarker.cloneNode(true);
            clonedMarker.setAttribute('id', _markerSideID);
            const marker = self.querySelector('#' + _markerSideID);
            marker.parentElement.replaceChild(clonedMarker, marker);
            clonedMarker.markerRef = sourceMarker;
        }

        function resetMarkerDisplay(_markerSideID) {
            const marker = self.querySelector('#' + _markerSideID);
            marker.style.visibility = 'collapse';
            marker.markerRef = null;
        }

        if (markerStartIRI !== '') {
            updateMarkerDisplay('MARKER_START', markerStartIRI);
        } else {
            resetMarkerDisplay('MARKER_START')
        }
        if (markerMidIRI !== '') {
            updateMarkerDisplay('MARKER_MID', markerMidIRI);
        } else {
            resetMarkerDisplay('MARKER_MID')
        }
        if (markerEndIRI !== '') {
            updateMarkerDisplay('MARKER_END', markerEndIRI);
        } else {
            resetMarkerDisplay('MARKER_END')
        }
        this.updateSelectedMarkerProperties();
    }

    updateSelectedMarkerProperties() {
        const activeDocument = activeApplication.activeDocument;

        const selectedDisplay = this.querySelector('.markers-display .selected');
        this.focusedMarker = selectedDisplay.querySelector('marker').markerRef;

        if (!this.focusedMarker) {
            this.querySelector('#marker-properties').style.display = 'none';
            return;
        }

        this.querySelector('#marker-properties').style.display = 'block';

        this.controlledElements.id.value = this.focusedMarker.getAttribute('id');
        this.controlledElements.markerUnits.value = this.focusedMarker.getAttribute('markerUnits') || 'strokeWidth';
        this.controlledElements.refX.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('refX'));
        this.controlledElements.refY.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('refY'));
        this.controlledElements.markerWidth.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('markerWidth'));
        this.controlledElements.markerHeight.value = activeDocument.valueToUnit(this.focusedMarker.getAttribute('markerHeight'));
        this.controlledElements.orient.value = this.focusedMarker.getAttribute('orient');

        if (this.controlledElements.orient.value !== 'auto' && this.controlledElements.orient.value !== 'auto-start-reverse') {
            this.controlledElements.orientMode.value = 'angle';
        } else {
            this.controlledElements.orientMode.value = this.controlledElements.orient.value;
        }
    }

    // STROKE WIDTH

    onChange_strokeWidth(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        // if(activePage.selectionList.length>0){
        //     activeDocument.setAttributeElementList_undable(  activePage.selectionList , {'stroke-width':newValue }   );
        // }else {
        //     activeDocument.fillAndStrokeManager.set_stroke( {'stroke-width':newValue } );
        // }

        if (activePage.selectionList.length > 0) {
            activeDocument.setAttributeElementList_undable(activePage.selectionList, {
                'stroke-width': newValue
            });
        }

        activeDocument.fillAndStrokeManager.set_stroke({
            'stroke-width': newValue
        });

    }

    onSliderChangeEnd_strokeWidth(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionList = activePage.selectionList;
        if (this.undoAction) {
            this.redoAction.createAttributeSnapshot(selectionList, 'stroke-width');
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
            activeDocument.onChange();
        }

        activeDocument.fillAndStrokeManager.set_stroke({
            'stroke-width': _e.target.value
        });

        // else {
        //     activeDocument.fillAndStrokeManager.set_stroke( {'stroke-width':_e.target.value } );
        // }

        this.undoAction = this.redoAction = null;
    }

    onSliderChange_strokeWidth(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length > 0) {
            if (!this.undoAction) {
                this.undoAction = new UndoRedoAction();
                this.redoAction = new UndoRedoAction();
                activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
                this.undoAction.createAttributeSnapshot(activePage.selectionList, 'stroke-width');
            }
            activeDocument.setAttributeElementList(activePage.selectionList, {
                'stroke-width': _e.target.value
            });
        }
        this.controlledElements.strokeWidth.value = _e.target.value + ' px';
    }

    onChange_nonScalingStroke(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let attributeValue = null;

        if (_e.target.checked)
            attributeValue = 'non-scaling-stroke';

        activeDocument.fillAndStrokeManager.nonScalingStroke = _e.target.checked;

        if (activePage.selectionList.length > 0)
            activeDocument.setAttributeElementList_undable(activePage.selectionList, {
                'vector-effect': attributeValue
            });

    }

    // STROKE CUP JOIN

    onClick_lineCup(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const button = _e.target.closest('[data-value]');
        if (activePage.selectionList.length > 0) {
            activeDocument.setAttributeElementList_undable(activePage.selectionList, {
                'stroke-linecap': button.dataset.value
            });
        } else {
            activeDocument.fillAndStrokeManager.set_stroke({
                'stroke-linecap': button.dataset.value
            });
        }
        this.update();
    }

    onClick_lineJoin(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const button = _e.target.closest('[data-value]');
        if (activePage.selectionList.length > 0) {
            activeDocument.setAttributeElementList_undable(activePage.selectionList, {
                'stroke-linejoin': button.dataset.value
            });
        } else {
            activeDocument.fillAndStrokeManager.set_stroke({
                'stroke-linejoin': button.dataset.value
            });
        }

        this.update();
    }

    onChange_miterLimit(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            newValue = 4;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'stroke-miterlimit': newValue
        });
    }

    // STROKE DASH

    onClickStrokeDashStyle(_e) {
        //console.log('onClickStrokeDashStyle', _e );
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const line = _e.target.querySelector('line')
            const newValue = line.getAttribute('stroke-dasharray')
            activeDocument.setAttributeElementList_undable(activePage.selectionList, {
                'stroke-dasharray': newValue
            });
        this.updateDash()
    }

    onChange_strokeDashArray(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (isNaN(Math.evalExpression(_e.target.value)))
            return;

        let i,
        element;
        let newValue = '';
        for (i = 0; i < 6; i++) {
            element = this.controlledElements['strokeDashArray_' + i];
            if (element.value === '')
                break;
            newValue += (element.value + ' ');
        }
        newValue = newValue.trim();

        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'stroke-dasharray': newValue
        });
    }

    onChange_strokeDashOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'stroke-dashoffset': newValue
        });
    }

    onSliderChangeEnd_strokeDashOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionList = activePage.selectionList;
        this.redoAction.createAttributeSnapshot(selectionList, 'stroke-dashoffset');
        this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectionList);
        };
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        // activePage.activeGraphicProperties.strokeDashOffset=_e.target.value;
    }

    onSliderChange_strokeDashOffset(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.undoAction = new UndoRedoAction();
            this.redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
            this.undoAction.createAttributeSnapshot(activePage.selectionList, 'stroke-dashoffset');
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'stroke-dashoffset': _e.target.value
        });
        this.controlledElements.strokeDashOffset.value = _e.target.value + ' px';
    }

    // MARKERS

    /*
    onClick_markerDisplay ( _e ) {
    XOS.selectElement(  _e.target );
    this.updateSelectedMarkerProperties();
    }

    onChange_markerID(_e)
{
    const idElement = this.controlledElements.id.value;
    if(idElement==='') return;

    const activeDocument =  activeApplication.activeDocument;

    function onClick_OK() { this.close(); _e.target.focus();_e.target.select();}
    if ( ! (/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement)) ) {
    /!* Does not match*!/
    DIALOGS['alert-dialog'].open( localString('Invalid identifier') , localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'),onClick_OK);
    return;
    }
    if( activeDocument.shadowRoot.querySelector('*[id="'+idElement+'"]') ) {
    DIALOGS['alert-dialog'].open( localString('Existent ID') , localString('The document already contains an element with ID:')+idElement,onClick_OK );
    return;
    }

    _e.target.blur();

    activeDocument.refactorElementID(this.focusedMarker, idElement ); // non è undable
    this.update();
    //activeDocument.onLibraryChange( "marker-library" );
    }


    onClick_cloneMarker(_e){

    const activeDocument =  activeApplication.activeDocument;
    const activePage =  activeDocument.activePage;

    const clonedResource = this.focusedMarker.cloneNode(true);
    const idNewResource = activeDocument.resources.createResourceIdFromExistentId( clonedResource.getAttribute('id' ) );
    activeDocument.resources.addResource(  clonedResource , idNewResource );
    const href = 'url(#'+idNewResource+')';
    const attributeValues ={};
    const attributeName = this.querySelector('.markers-display .selected').getAttribute('name');
    attributeValues[ attributeName ] = href;
    activeDocument.setAttributeElementList_undable( activePage.selectionList, attributeValues );
    this.update();
    //activeApplication.workspace.update();
    //activeDocument.onLibraryChange("marker-library");
    };

    getActiveMarkerSideName()
{
    return this.querySelector('.markers-display .selected').getAttribute('name');
    }



    onClick_editMarker(_e)
{
    const activeDocument =  activeApplication.activeDocument;
    const activePage =  activeDocument.activePage;
    activeDocument.enterTo_isolateLayerEditing( this.focusedMarker );
    }


    onClick_removeMarker(_e)
{
    const activeDocument =  activeApplication.activeDocument;
    const activePage =  activeDocument.activePage;
    const attributeValues ={};
    const attributeName = this.querySelector('.markers-display .selected').getAttribute('name');
    attributeValues[ attributeName ] = '';
    activeDocument.setAttributeElementList_undable(activePage.selectionList,attributeValues);
    this.update();
    }



    onChange_markerUnits(_e){
    const activeDocument =  activeApplication.activeDocument;
    const activePage =  activeDocument.activePage;
    activeDocument.setAttributeElementList_undable([this.focusedMarker],{'markerUnits' : _e.target.value }, false );
    }


    onChange_refX(_e){
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'refX' : activeDocument.unitToValue(_e.target.value)} , false );
    }

    onChange_refY(_e){
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'refY' : activeDocument.unitToValue(_e.target.value)} , false );

    }

    onChange_markerWidth(_e){
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'markerWidth' : activeDocument.unitToValue(_e.target.value)}, false );
    }

    onChange_markerHeight(_e){
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'markerHeight' : activeDocument.unitToValue(_e.target.value)} , false);
    }

    onChange_orientMode(_e){
    if( _e.target.value ==='angle')
{
    this.controlledElements.orient.value = '0';
    } else {
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'orient' : _e.target.value}, false );
    this.controlledElements.orient.value =  _e.target.value;
    }
    }

    onChange_orient(_e){
    if( _e.target.value==='') _e.target.value = 'auto';
    const activeDocument =  activeApplication.activeDocument;
    activeDocument.setAttributeElementList_undable( [this.focusedMarker], {'orient' : _e.target.value}, false );
    }*/

}

customElements.define("stroke-inspector", StrokeInspector_cmp);

class FillingInspector_cmp extends PopUpPanel {

    constructor() {
        super('S');
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event="change:onChange_fillingType"],[data-event="click:onClick_fillingType"]'), this); // solo questo
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('.content>.button-bar.small>[data-event]'), this, this.controlledElements); // solo questo
        // this.fillGradientDef = document.querySelector('#APPLICATION_DEFS #FILL_GRADIENT');
        // this.strokeGradientDef = document.querySelector('#APPLICATION_DEFS #STROKE_GRADIENT');
    }

    onDomReady() {
        const self = this;
        let undoAction,
        redoAction;

        function onChangeStart(_colorPicker) {
            //console.log('-----onChangeStart--------');
            const activeDocument = activeApplication.activeDocument;
            const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
            const activePage = activeDocument.activePage;

            if (activePage.selectionList.length > 0) {
                undoAction = new UndoRedoAction();
                redoAction = new UndoRedoAction();
                activePage.history.addUndoRedoActions(undoAction, redoAction);
                undoAction.createAttributeSnapshot(activePage.selectionList, focusedGraphicSideName + ',' + focusedGraphicSideName + '-opacity');
            }
        }

        function onChange(_colorPicker) {
            //console.log('-----onChange--------');
            const activeDocument = activeApplication.activeDocument;
            const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
            const activePage = activeDocument.activePage;
            const data = {};
            data[focusedGraphicSideName] = _colorPicker.hex;
            data[focusedGraphicSideName + '-opacity'] = _colorPicker.alpha;
            if (activePage.selectionList.length > 0)
                activeDocument.setAttributeElementList(activePage.selectionList, data);
            activeDocument.fillAndStrokeManager['set_' + focusedGraphicSideName](data);
        }

        function onChangeEnd(_colorPicker) {
            //console.log('-----onChangeEnd--------');
            if (undoAction && redoAction) {
                const activeDocument = activeApplication.activeDocument;
                const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
                const activePage = activeDocument.activePage;
                const selectionList = activePage.selectionList;
                redoAction.createAttributeSnapshot(selectionList, focusedGraphicSideName + ',' + focusedGraphicSideName + '-opacity');
                undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                    activeDocument.selectElementList(selectionList);
                };
                activeDocument.onChange();
            }

            undoAction = redoAction = null;

            //activeDocument.fillAndStrokeManager[focusedGraphicSideName]= _colorPicker.hex;
            // activeDocument.fillAndStrokeManager['set_'+focusedGraphicSideName]( {focusedGraphicSideName:_colorPicker.hex});

        }

        this.querySelector('color-picker').setOnChangeEvents(onChangeEnd, onChange, onChangeStart);
    }

    // quando il menu viene attivato da un click su un elemento
    activateBy(_activatorElement, _mode, _selectActivator = true) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.fillAndStrokeManager.focusedGraphicSideName = _activatorElement.dataset.graphicSide;
        super.activateBy(_activatorElement, _mode, _selectActivator);
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        //const activePage = activeDocument.activePage;

        this.classList.add(focusedGraphicSideName);
        this.querySelector('.title').innerHTML = localString(focusedGraphicSideName);

        // const iconLink = this.querySelector('svg>use').getAttribute('xlink:href' );
        // this.querySelector('svg>use').setAttribute('xlink:href',iconLink.split('#')[0]+'#'+focusedGraphicSideName+'_icon' );

        const fillingType = activeDocument.fillAndStrokeManager[focusedGraphicSideName + 'FillingType'];

        if (fillingType === 'radialGradient' || fillingType === 'linearGradient') {
            this.controlledElements.fillingType.value = 'gradient';
            const gradientInspector = this.querySelector('gradient-inspector');
            XOS.showElement(gradientInspector);
            gradientInspector.update(); // fillGradient oppure strokeGradient
            XOS.selectElement(this.querySelector('[data-filling-type="gradient"]'));
        } else if (fillingType === 'pattern') {
            this.controlledElements.fillingType.value = 'pattern';
            const patternInspector = this.querySelector('pattern-inspector');
            XOS.showElement(patternInspector);
            patternInspector.update();
            XOS.selectElement(this.querySelector('[data-filling-type="pattern"]'));
        } else if (fillingType === 'color') {
            this.controlledElements.fillingType.value = 'color';
            const colorPicker = this.querySelector('color-picker');
            XOS.showElement(colorPicker);
            colorPicker.setColor(activeDocument.fillAndStrokeManager[focusedGraphicSideName], activeDocument.fillAndStrokeManager[focusedGraphicSideName + '-opacity']);
            XOS.selectElement(this.querySelector('[data-filling-type="color"]'));
        } else {
            this.controlledElements.fillingType.value = 'none';
            XOS.showElement(this.querySelector('.none-context'));
            XOS.selectElement(this.querySelector('[data-filling-type="none"]'));
        }

    }

    onClick_fillingType(_e) {
        //console.log( 'onClick_fillingType', _e.target.dataset.fillingType );
        //XOS.selectElement(  _e.target );
        this.setSelectionFillingType(_e.target.dataset.fillingType);
    }

    onChange_fillingType(_e) {
        this.setSelectionFillingType(_e.target.value);
    }

    setSelectionFillingType(_fillingType) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        const elementList = activePage.selectionList;

        const fillOrStrokeFilling = focusedGraphicSideName;
        const fillOrStrokeFillingOpacity = focusedGraphicSideName + '-opacity';

        const fillingType = _fillingType;

        if (fillingType === 'none') {
            const data = {};
            data[fillOrStrokeFilling] = 'none';
            data[fillOrStrokeFillingOpacity] = '1';
            if (elementList.length > 0) {
                activeDocument.setAttributeElementList_undable(activePage.selectionList, data);
            } else {
                activeDocument.fillAndStrokeManager['set_' + focusedGraphicSideName](data);
            }

            this.update();
        } else if (fillingType === 'color') {
            const data = {};
            data[fillOrStrokeFilling] = '#FFFFFF';
            data[fillOrStrokeFillingOpacity] = '1';
            // activeDocument.setAttributeElementList_undable( activePage.selectionList , data );
            if (elementList.length > 0) {
                activeDocument.setAttributeElementList_undable(activePage.selectionList, data);
            } else {
                activeDocument.fillAndStrokeManager['set_' + focusedGraphicSideName](data);
            }
            this.update();
        } else if (fillingType === 'gradient') {
            const activePage = activeApplication.activeDocument.activePage;
            let sourceGradient = activeDocument.fillAndStrokeManager[fillOrStrokeFilling + 'Gradient'] || document.querySelector('#defaultGradient');
            let sourceGradientID = sourceGradient.getAttribute('id');
            let exists = activeDocument.resources.getResourceById(sourceGradientID);
            if (!exists) {
                const newResource = sourceGradient.cloneNode(true);
                activeDocument.resources.addResource(newResource);
            }
            const data = {};
            data[fillOrStrokeFilling] = 'url(#' + sourceGradientID + ')';
            data[fillOrStrokeFillingOpacity] = '1';

            // activeDocument.setAttributeElementList_undable( activePage.selectionList , data );
            if (elementList.length > 0) {
                activeDocument.setAttributeElementList_undable(activePage.selectionList, data);
            } else {
                activeDocument.fillAndStrokeManager['set_' + focusedGraphicSideName](data);
            }
            this.update();
        } else if (fillingType === 'pattern') {
            let sourcePattern = activeDocument.fillAndStrokeManager[fillOrStrokeFilling + 'Pattern'] || document.querySelector('#defaultPattern');
            let sourcePatternID = sourcePattern.getAttribute('id');
            let exists = activeDocument.resources.getResourceById(sourcePatternID);
            if (!exists) {
                const newResource = sourcePattern.cloneNode(true);
                activeDocument.resources.addResource(newResource);
            }

            const data = {};
            data[fillOrStrokeFilling] = 'url(#' + sourcePatternID + ')';
            data[fillOrStrokeFillingOpacity] = '1';

            // activeDocument.setAttributeElementList_undable( activePage.selectionList , data );
            if (elementList.length > 0) {
                activeDocument.setAttributeElementList_undable(activePage.selectionList, data);
            } else {
                activeDocument.fillAndStrokeManager['set_' + focusedGraphicSideName](data);
            }
            this.update();
        } else if (fillingType === 'swapFillStroke') {
            const sourceStroke = activeDocument.fillAndStrokeManager.stroke;
            let sourceStrokeWidth = activeDocument.fillAndStrokeManager['stroke-width'];
            //console.log('sourceStrokeWidth', sourceStrokeWidth);
            if (sourceStrokeWidth === '0' || sourceStrokeWidth === 0)
                sourceStrokeWidth = 1;
            const sourceStrokeOpacity = activeDocument.fillAndStrokeManager['stroke-opacity'] || 1;
            const sourceFill = activeDocument.fillAndStrokeManager.fill;
            const sourceFillOpacity = activeDocument.fillAndStrokeManager['fill-opacity'] || 1;
            const data = {
                'fill': sourceStroke,
                'fill-opacity': sourceStrokeOpacity,
                'stroke': sourceFill,
                'stroke-opacity': sourceFillOpacity,
                'stroke-width': sourceStrokeWidth
            };
            if (elementList.length > 0) {
                activeDocument.setAttributeElementList_undable(activePage.selectionList, data);
            } else {
                activeDocument.fillAndStrokeManager.set_stroke(data);
                activeDocument.fillAndStrokeManager.set_fill(data);
            }

            this.update();

            // const sourceStroke = activeDocument.fillAndStrokeManager.stroke ;
            // let sourceStrokeWidth = activeDocument.fillAndStrokeManager['stroke-width'] ;
            // if( sourceStrokeWidth==='0'|| sourceStrokeWidth===0 ) sourceStrokeWidth=1;
            // const sourceStrokeOpacity = activeDocument.fillAndStrokeManager['stroke-opacity'] || 1 ;
            // const sourceFill = activeDocument.fillAndStrokeManager.fill ;
            // const sourceFillOpacity = activeDocument.fillAndStrokeManager['fill-opacity'] || 1 ;
            // activeDocument.setAttributeElementList_undable( activePage.selectionList , { 'fill':sourceStroke, 'fill-opacity':sourceStrokeOpacity,'stroke':sourceFill, 'stroke-opacity':sourceFillOpacity, 'stroke-width':sourceStrokeWidth} );
            // this.update();
        }
        // else if(fillingType==='applyToSelection')
        // {
        //     const activePage =  activeApplication.activeDocument.activePage;
        //     const sourceFill = activeDocument.fillAndStrokeManager.fill ;
        //     const sourceFillOpacity = activeDocument.fillAndStrokeManager.fillOpacity || 1 ;
        //     activePage.setAttributeElementList_undable( activePage.selectionList , { 'fill':sourceFill, 'fill-opacity':sourceFillOpacity} );
        //     activePage.updateDrawingProperties();
        // }
    }

}

customElements.define("filling-inspector", FillingInspector_cmp);

class GradientInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.stopColorListContainer = this.querySelector('#GRADIENT_COLOR_LIST');
        this.stopColorTemplate = this.stopColorListContainer.querySelector('.editable-gradient-color');
        this.stopColorTemplate.parentElement.removeChild(this.stopColorTemplate);
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    onClick_showGradientLibrary() {
        WINDOWS['mainLibraryWindow'].showSection("gradient-library");
    }

    update(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        this.editableGradient = activeDocument.fillAndStrokeManager[focusedGraphicSideName + 'GradientDef']; // #FILL_GRADIENT oppure #STROKE_GRADIENT definiti come strokeGradientDef e fillGradientDef
        this.stopColorListContainer.previousElementSibling.setAttribute('fill', 'url(#' + this.editableGradient.getAttribute('id') + ')'); // FILL_GRADIENT or STROKE_GRADIENT
        this.createEditableStopColors();

        this.controlledElements.id.value = this.editableGradient.original.getAttribute('id');
        this.controlledElements.spreadMethod.value = this.editableGradient.original.getAttribute('spreadMethod') || 'pad';
        const gradientUnits = this.controlledElements.gradientUnits.value = this.editableGradient.original.getAttribute('gradientUnits') || 'objectBoundingBox';

        const gradientType = this.editableGradient.original.nodeName;

        this.controlledElements.gradientType.value = this.editableGradient.original.nodeName;

        if (gradientType === 'linearGradient') {
            XOS.showElement(this.querySelector('#LINEAR_GRADIENT_PROPERTIES'));

            let x1,
            y1,
            x2,
            y2;
            x1 = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('x1'));
            y1 = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('y1'));
            x2 = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('x2'));
            y2 = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('y2'));

            if (gradientUnits === 'objectBoundingBox') {
                // x1 = x1*100+' %';
                // y1 = y1*100+' %';
                // x2 = x2*100+' %';
                // y2 = y2*100+' %';
            } else if (gradientUnits === 'userSpaceOnUse') {
                x1 += ' px';
                y1 += ' px';
                x2 += ' px';
                y2 += ' px';
            }

            this.controlledElements.x1.value = x1;
            this.controlledElements.y1.value = y1;
            this.controlledElements.x2.value = x2;
            this.controlledElements.y2.value = y2;

        } else {

            XOS.showElement(this.querySelector('#RADIAL_GRADIENT_PROPERTIES'))

            let cx,
            cy,
            r,
            fx = '',
            fy = '';
            cx = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('cx'));
            cy = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('cy'));
            r = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('r'));

            if (this.editableGradient.original.hasAttribute('fx'))
                fx = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('fx'));
            if (this.editableGradient.original.hasAttribute('fy'))
                fy = activeDocument.valueToFixed(this.editableGradient.original.getAttribute('fy'));

            if (gradientUnits === 'objectBoundingBox') {
                // cx = cx*100+' %';
                // cy = cy*100+' %';
                // r  =  r*100+' %';
                // if( fx!='' ) fx = fx*100+' %';
                // if( fy!='' ) fy = fy*100+' %';
            } else if (gradientUnits === 'userSpaceOnUse') {
                cx += ' px';
                cy += ' px';
                r += ' px';
                if (fx !== '')
                    fx += ' px';
                if (fy !== '')
                    fy += ' px';
            }

            this.controlledElements.cx.value = cx;
            this.controlledElements.cy.value = cy;
            this.controlledElements.r.value = r;
            this.controlledElements.fx.value = fx;
            this.controlledElements.fy.value = fy;
        }
    }

    createEditableStopColors() {
        let stopColor,
        stopColorView;
        //this.editableGradient.sortStopColors();
        this.stopColorListContainer.removeChildren();
        const max = this.editableGradient.children.length;
        for (let i = 0; i < max; i++) {
            stopColor = this.editableGradient.children[i];
            stopColor.original = this.editableGradient.original.children[i];
            stopColor.stylePropertiesToAttributes();
            stopColorView = this.stopColorTemplate.cloneNode(true);
            stopColorView.stopColorRef = stopColor;
            stopColorView.setAttribute('fill', stopColor.getAttribute('stop-color'));
            this.stopColorListContainer.appendChild(stopColorView);
            stopColorView.placeAt(150 * stopColor.offset.baseVal, 12);
        }
    }

    onChange_ID(_e) {
        const idElement = this.controlledElements.id.value;
        if (idElement === '')
            return;

        const activeDocument = activeApplication.activeDocument;
        //const activePage = activeDocument.activePage;

        const self = this;
        function onClick_OK() {
            this.close();
            self.showElement();
            self.parentElement.classList.add('locked');
            _e.target.focus();
            _e.target.select();
        }
        if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            /* Does not match*/
            DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            return;
        }
        if (activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            return;
        }

        _e.target.blur();

        activeDocument.refactorElementID(this.editableGradient.original, idElement); // non è undable
        this.update();
        //activeDocument.onLibraryChange("gradient-library");
    }

    onClick_cloneGradient(_e) {

        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;

        const clonedGradient = this.editableGradient.original.cloneNode(true);
        const idNewResource = activeDocument.resources.createResourceIdFromExistentId(clonedGradient.getAttribute('id'));
        activeDocument.resources.addResource(clonedGradient, idNewResource);
        const href = 'url(#' + idNewResource + ')';
        const attributeValues = {};
        attributeValues[focusedGraphicSideName] = href;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, attributeValues);
        this.update();
        //activeDocument.onLibraryChange("gradient-library");
    };

    onChange_gradientType(_e) {

        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        const originalGradient = this.editableGradient.original;

        const gradientType = originalGradient.nodeName;
        let newGradient = null;
        const newGradientType = this.controlledElements.gradientType.value;
        const spreadMethod = originalGradient.getAttribute('spreadMethod');

        if ((newGradientType === 'radialGradient') && (gradientType === 'linearGradient')) {
            newGradient = SVGUtils.createSVGRadialGradient(originalGradient.id, .5, .5, .5, 'objectBoundingBox', spreadMethod);
        } else if ((newGradientType === 'linearGradient') && (gradientType === 'radialGradient')) {
            newGradient = SVGUtils.createSVGLinearGradient(originalGradient.id, 0, .5, 1, .5, 'objectBoundingBox', spreadMethod);
        }

        if (newGradient) {
            originalGradient.cloneChildrenTo(newGradient);
            const idNewResource = activeDocument.resources.createResourceIdFromExistentId(originalGradient.getAttribute('id'));

            activeDocument.resources.addResource(newGradient, idNewResource);
            const href = 'url(#' + idNewResource + ')';

            const attributeValues = {};
            attributeValues[focusedGraphicSideName] = href;
            activeDocument.setAttributeElementList_undable(activePage.selectionList, attributeValues);
        }

        this.update();
        activeApplication.workspace.gradientInteraction.update();
        //activeDocument.onLibraryChange("gradient-library");
    };

    onChange_spreadMethod(_e) {

        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;

        let spreadMethod = this.controlledElements.spreadMethod.value;
        if (spreadMethod === 'pad')
            spreadMethod = null;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'spreadMethod': spreadMethod
        }, false);
        //this.update();
    };

    onChange_gradientUnits(_e) {

        const activeDocument = activeApplication.activeDocument;
        // const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        // const activePage = activeDocument.activePage;

        const originalGradient = this.editableGradient.original;

        const gradientType = originalGradient.nodeName;
        const gradientUnits = this.controlledElements.gradientUnits.value;
        const properties = {};
        properties.gradientUnits = gradientUnits;

        if (gradientUnits === 'objectBoundingBox') {
            if (gradientType === 'linearGradient') {
                properties.x1 = 0;
                properties.y1 = 0.5;
                properties.x2 = 1;
                properties.y2 = 0.5;
            } else if (gradientType === 'radialGradient') {
                properties.cx = 0.5;
                properties.cy = 0.5;
                properties.r = 0.5;
            }
        } else if (gradientUnits === 'userSpaceOnUse') {
            if (gradientType === 'linearGradient') {
                properties.x1 = 0;
                properties.y1 = 50;
                properties.x2 = 100;
                properties.y2 = 50;
            } else if (gradientType === 'radialGradient') {
                properties.cx = 50;
                properties.cy = 50;
                properties.r = 50;
            }
        }

        activeDocument.setAttributeElementList_undable([originalGradient], properties, false);
        //activeApplication.activeDocument.activePage.updateInteraction();


    }

    onChange_linearGradient_x1(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.x1.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'x1': newValue
        }, false);
    }

    onChange_linearGradient_y1(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.y1.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'y1': newValue
        }, false);
    }

    onChange_linearGradient_x2(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.x2.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'x2': newValue
        }, false);
    }

    onChange_linearGradient_y2(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.y2.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'y2': newValue
        }, false);
    }

    onChange_radialGradient_cx(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.cx.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'cx': newValue
        }, false);
    }

    onChange_radialGradient_cy(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.cy.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'cy': newValue
        }, false);
    }

    onChange_radialGradient_fx(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        let newValue = Math.evalExpression(this.controlledElements.fx.value);
        if (isNaN(newValue))
            newValue = null;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'fx': newValue
        }, false);
    }

    onChange_radialGradient_fy(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        let newValue = Math.evalExpression(this.controlledElements.fy.value);
        if (isNaN(newValue))
            newValue = null;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'fy': newValue
        }, false);
    }

    onChange_radialGradient_r(_e) {
        const activeDocument = activeApplication.activeDocument;
        const originalGradient = this.editableGradient.original;
        const newValue = Math.evalExpression(this.controlledElements.r.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([originalGradient], {
            'r': newValue
        }, false);
    }

    // si riferisce a fill o stroke
    onChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue > 0)
            newValue /= 100;
        const properties = {};
        properties[focusedGraphicSideName + '-opacity'] = newValue;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, properties);
    }

    onSliderChangeEnd_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, focusedGraphicSideName + '-opacity');

        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }

        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
    }

    onSliderChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.undoAction = new UndoRedoAction();
            this.redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
            this.undoAction.createAttributeSnapshot(activePage.selectionList, focusedGraphicSideName + '-opacity');
        }
        const properties = {};
        properties[focusedGraphicSideName + '-opacity'] = _e.target.value / 100;
        activeDocument.setAttributeElementList(activePage.selectionList, properties);
        // this.controlledElements.opacity.value = _e.target.value/100 +' %';
        this.controlledElements.opacity.value = _e.target.value + ' %';
    }

    onMouseDown_gradientColorList(_e) {
        this.dragLimitsRect = this.stopColorListContainer.closest('svg').getBoundingClientRect();
        if (_e.target.nodeName === 'rect') {
            XOS.selectElement(_e.target.parentElement);

            XOS.initDragFunctions(this, _e);
        }
    };

    onMouseUp_gradientColorList(_e) {
        //_e.stopPropagation(); // fermo l'evento per non far sparire il prossimo pannello, ovverpo il color picker (azione di default del context inspector )
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;

        if (_e.target.nodeName === 'rect') {
            this.editGradientColor(_e.target.parentElement);
        } else if (_e.target.nodeName === 'svg') {
            const x = _e.pageX - this.dragLimitsRect.left; //x position within the element.
            //const y = _e.pageY - this.dragLimitsRect.top;  //y position within the element.

            const offset = x / 150;

            const newStopColorNode = this.editableGradient.insertNewStopColor(offset);

            this.undoAction = new UndoRedoAction();
            this.redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);

            this.undoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'insert');
            this.redoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'delete');

            this.editableGradient.cloneChildrenTo(this.editableGradient.original);

            this.undoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'delete');
            this.undoAction.snapshotDataList.reverse();

            this.redoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'insert');
            this.redoAction.snapshotDataList.reverse();

            const selectionList = activePage.selectionList;
            if (selectionList.length > 0) {
                this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                    activeDocument.selectElementList(selectionList);
                    activeApplication.workspace.update();
                    activeDocument.onChange();
                };
            }

            this.undoAction = this.redoAction = null;

            this.update();

            XOS.selectElement(this.stopColorListContainer.querySelector('g[fill="' + newStopColorNode.getAttribute('stop-color') + '"]'));

            activeApplication.workspace.gradientInteraction.update();

        }
    };

    editGradientColor(editableColorView) {
        XOS.selectElement(editableColorView);
        const editableGradientColor = editableColorView.stopColorRef;
        const id = Array.from(editableGradientColor.parentElement.children).indexOf(editableGradientColor);
        editableGradientColor.original = this.editableGradient.original.children[id];

        const colorValue = editableGradientColor.getAttribute('stop-color');
        const alpha = editableGradientColor.getAttribute('stop-opacity') || 1;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const self = this;
        let undoAction,
        redoAction;

        function onChangeStart(_colorPicker) {
            undoAction = new UndoRedoAction();
            redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);
            undoAction.createAttributeSnapshot([editableGradientColor.original], 'stop-color,stop-opacity');
        }

        function onChange(_colorPicker) {
            const hexColorValue = _colorPicker.hex;
            activeDocument.setAttributeElementList([editableGradientColor], {
                'stop-color': hexColorValue,
                'stop-opacity': _colorPicker.alpha
            });
            activeDocument.setAttributeElementList([editableGradientColor.original], {
                'stop-color': hexColorValue,
                'stop-opacity': _colorPicker.alpha
            });
        }

        function onChangeEnd(_colorPicker) {
            redoAction.createAttributeSnapshot([editableGradientColor.original], 'stop-color,stop-opacity');

            activeDocument.onChange();
            self.update();
            //self.gradientColorContainer.querySelector('g[fill="'+editableGradientColor.original.getAttribute('stop-color')+'"]' ).selectElement();
            XOS.selectElement(self.stopColorListContainer.querySelector('g[fill="' + editableGradientColor.original.getAttribute('stop-color') + '"]'));

            activeApplication.workspace.gradientInteraction.update();

            const selectionList = activePage.selectionList;
            if (selectionList.length > 0) {
                undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                    activeDocument.selectElementList(selectionList);
                };
                // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function(){
                //     activeDocument.selectElementList(selectionList);
                //     activeDocument.workspace.update();
                // };
            }

            undoAction = redoAction = null;

            //activeApplication.activeDocument.onLibraryChange("gradient-library");
        }

        const colorPicker = PANELS['global-color-picker'];
        colorPicker.set(colorValue, alpha, onChangeEnd, onChange, onChangeStart);
        colorPicker.activateBy(editableColorView, 'add');

    };

    // se si dragga un colore
    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);

        this.undoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'insert');
        this.redoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'delete');
    };

    onDrag(_e) {
        const editableColorView = this.stopColorListContainer.querySelector('.selected');

        let x = _e.pageX - this.dragLimitsRect.left; //x position within the element.
        const y = _e.pageY - this.dragLimitsRect.top; //y position within the element.


        editableColorView.classList.remove('hidden');

        if (x < 0)
            x = 0;
        if (x > 150)
            x = 150;

        if ((y < 0 || y > 20) && (this.stopColorListContainer.children.length > 2)) {
            editableColorView.classList.add('hidden');
        }

        editableColorView.placeAt(x, 12);
        editableColorView.stopColorRef.setAttribute('offset', String(x / 150));
        this.editableGradient.sortStopColors();

        this.editableGradient.cloneChildrenTo(this.editableGradient.original);
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const editableColorView = this.stopColorListContainer.querySelector('.selected');
        const editableGradientColor = editableColorView.stopColorRef;
        if (editableColorView.classList.contains('hidden')) {
            // rimuovo il color Stop
            const colorList = [].slice.call(editableGradientColor.parentElement.children, 0);
            const idChild = colorList.indexOf(editableGradientColor);
            this.editableGradient.original.children[idChild].remove();
            editableGradientColor.remove();
        }

        this.undoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'delete');
        this.undoAction.snapshotDataList.reverse();
        this.redoAction.createDomNodeSnapshot(this.editableGradient.original.children, 'insert');
        this.redoAction.snapshotDataList.reverse();

        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
                activeApplication.workspace.update();
                activeDocument.onChange();
            };
        }

        this.undoAction = this.redoAction = null;
        activeApplication.workspace.gradientInteraction.update();
        // activeApplication.activeDocument.onLibraryChange("gradient-library");
    };

}
customElements.define("gradient-inspector", GradientInspector_cmp);

class PatternInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        this.patternDisplay = this.querySelector('.pattern-display');
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    update(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;

        this.editablePattern = activeDocument.fillAndStrokeManager[focusedGraphicSideName + 'PatternDef'];

        this.patternDisplay.setAttribute('fill', 'url(#' + this.editablePattern.getAttribute('id') + ')');

        this.controlledElements.id.value = this.editablePattern.original.getAttribute('id');
        //this.controlledElements.patternUnits.value = this.editablePattern.original.getAttribute('patternUnits') || 'objectBoundingBox';

        const patternX = activeDocument.valueToFixed(this.editablePattern.original.getAttribute('x')) || '0';
        this.controlledElements.patternXSlider.value = patternX;
        this.controlledElements.patternX.value = patternX + ' pt';

        const patternY = activeDocument.valueToFixed(this.editablePattern.original.getAttribute('y')) || '0';
        this.controlledElements.patternYSlider.value = patternY;
        this.controlledElements.patternY.value = patternY + ' pt';

        // const patternWidth = activePage.valueToFixed( this.editablePattern.original.getAttribute('width'));
        // const patternHeight = activePage.valueToFixed( this.editablePattern.original.getAttribute('height'));

        const transformProperties = GeometryUtils.parseTransformString(this.editablePattern.original.getAttribute('patternTransform'));
        let rotate = 0,
        scale = 1;
        if (transformProperties.rotate)
            rotate = activeDocument.valueToFixed(transformProperties.rotate.value);
        if (transformProperties.scale)
            scale = activeDocument.valueToFixed(transformProperties.scale.x);

        this.controlledElements.patternRotation.value = rotate + ' °';
        this.controlledElements.patternRotationSlider.value = rotate;

        this.controlledElements.patternScale.value = scale * 100 + ' %';
        this.controlledElements.patternScaleSlider.value = scale * 100;
    }

    onClick_showPatternLibrary() {
        WINDOWS['mainLibraryWindow'].showSection("pattern-library");
    }

    onChange_ID(_e) {
        const idElement = this.controlledElements.id.value;
        if (idElement === '')
            return;

        const activeDocument = activeApplication.activeDocument;
        // const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        // const activePage = activeDocument.activePage;


        const self = this;
        function onClick_OK() {
            this.close();
            self.showElement();
            self.parentElement.classList.add('locked');
            _e.target.focus();
            _e.target.select();
        }
        if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            /* Does not match*/
            DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            return;
        }
        if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            return;
        }

        _e.target.blur();

        activeDocument.refactorElementID(this.editablePattern.original, idElement); // non è undable
        this.update();
        //activeApplication.activeDocument.onLibraryChange("pattern-library");
    }

    onClick_clonePattern(_e) {

        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;

        const clonedPattern = this.editablePattern.original.cloneNode(true);
        const idNewResource = activeDocument.resources.createResourceIdFromExistentId(clonedPattern.getAttribute('id'));
        activeDocument.resources.addResource(clonedPattern, idNewResource);
        const href = 'url(#' + idNewResource + ')';
        const attributeValues = {};
        attributeValues[focusedGraphicSideName] = href;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, attributeValues);
        //activePage.showSelectionProperties();
        this.update();
        //activeDocument.onLibraryChange("pattern-library");
    };

    onClick_editPattern(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.enterTo_isolateLayerEditing(this.editablePattern.original);
    };

    // onChange_offsetX(_e){
    //     const newValue =  Math.evalExpression( this.controlledElements.offsetX.value );
    //     if( isNaN(newValue) ) return;
    //     activeApplication.activeDocument.activePage.setAttributeElementList_undable([this.editablePattern.original],{'x':newValue} , false );
    // };
    //
    // onChange_offsetY(_e){
    //     const newValue =  Math.evalExpression( this.controlledElements.offsetY.value );
    //     if( isNaN(newValue) ) return;
    //     activeApplication.activeDocument.activePage.setAttributeElementList_undable([this.editablePattern.original],{'y':newValue} , false );
    // };


    // OFFSET X

    onChange_patternX(_e) {
        const activeDocument = activeApplication.activeDocument;
        const newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([this.editablePattern.original], {
            'x': newValue
        }, false);
        this.update();
    }

    onSliderChangeStart_patternX(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot([this.editablePattern.original], 'x');
    }

    onSliderChangeEnd_patternX(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot([this.editablePattern.original], 'x');
        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        this.update();
    }

    onSliderChange_patternX(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (!this.undoAction)
            this.onSliderChangeStart_patternX(_e);
        activeDocument.setAttributeElementList([this.editablePattern.original], {
            'x': _e.target.value
        });
        this.controlledElements.patternX.value = _e.target.value + ' pt';
    }

    // OFFSET Y

    onChange_patternY(_e) {
        const activeDocument = activeApplication.activeDocument;
        const newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([this.editablePattern.original], {
            'y': newValue
        }, false);
    }

    onSliderChangeStart_patternY(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot([this.editablePattern.original], 'y');
    }

    onSliderChangeEnd_patternY(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot([this.editablePattern.original], 'y');
        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        this.update();
    }

    onSliderChange_patternY(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (!this.undoAction)
            this.onSliderChangeStart_patternY(_e);
        activeDocument.setAttributeElementList([this.editablePattern.original], {
            'y': _e.target.value
        });
        this.controlledElements.patternY.value = _e.target.value + ' pt';
    }

    // SCALE


    // _.onChange_patternScaleRotation = function(_e){
    //     var editablePattern = this.appRef.fillStroke2DPanel.editablePatternDef;
    //     var activeEditablePage = this.appRef.activeEditablePage;
    //     var scaleValue =  Math.evalExpression( this.controlledElements.patternScale.value/100 );
    //     if( isNaN(scaleValue) ) return;
    //     var rotationValue =  Math.evalExpression( this.controlledElements.patternRotation.value );
    //     if( isNaN(rotationValue) ) return;
    //
    //     var transformString = 'rotate('+rotationValue+')' + ' scale('+scaleValue+')';
    //     this.appRef.activeEditablePage.setAttributeElementList_undable([editablePattern],{'patternTransform':transformString} , false );
    // };

    composePatternTransform() {
        const scaleValue = parseFloat(this.controlledElements.patternScale.value) / 100;
        if (isNaN(scaleValue))
            return;
        const rotationValue = parseFloat(this.controlledElements.patternRotation.value);
        if (isNaN(rotationValue))
            return;
        return 'rotate(' + rotationValue + ')' + ' scale(' + scaleValue + ')';
    }

    onChange_patternScale(_e) {
        const activeDocument = activeApplication.activeDocument;
        const transformString = this.composePatternTransform();
        const newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([this.editablePattern.original], {
            'patternTransform': transformString
        }, false);
        //activeApplication.activeDocument.onLibraryChange("pattern-library");
        this.update();
    }

    onSliderChangeStart_patternScale(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot([this.editablePattern.original], 'patternTransform');
    }

    onSliderChangeEnd_patternScale(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot([this.editablePattern.original], 'patternTransform');
        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        this.update();
        //activeApplication.activeDocument.onLibraryChange("pattern-library");
    }

    onSliderChange_patternScale(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (!this.undoAction)
            this.onSliderChangeStart_patternScale(_e);

        this.controlledElements.patternScale.value = _e.target.value + ' %';
        const transformString = this.composePatternTransform();
        activeDocument.setAttributeElementList([this.editablePattern.original], {
            'patternTransform': transformString
        }, false);

    }

    // ROTATION

    onChange_patternRotation(_e) {
        const transformString = this.composePatternTransform();
        const activeDocument = activeApplication.activeDocument;
        const newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        activeDocument.setAttributeElementList_undable([this.editablePattern.original], {
            'patternTransform': transformString
        }, false);
        this.update();
        //activeApplication.activeDocument.onLibraryChange("pattern-library");
    }

    onSliderChangeStart_patternRotation(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.undoAction = new UndoRedoAction();
        this.redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
        this.undoAction.createAttributeSnapshot([this.editablePattern.original], 'patternTransform');
    }

    onSliderChangeEnd_patternRotation(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot([this.editablePattern.original], 'patternTransform');
        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
        this.update();
        //activeApplication.activeDocument.onLibraryChange("pattern-library");
    }

    onSliderChange_patternRotation(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (!this.undoAction)
            this.onSliderChangeStart_patternRotation(_e);
        this.controlledElements.patternRotation.value = _e.target.value + ' °';
        const transformString = this.composePatternTransform();
        activeDocument.setAttributeElementList([this.editablePattern.original], {
            'patternTransform': transformString
        }, false);

    }

    // si riferisce a fill o stroke
    onChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue > 0)
            newValue /= 100;
        const properties = {};
        properties[focusedGraphicSideName + '-opacity'] = newValue;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, properties);

    }

    onSliderChangeEnd_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        this.redoAction.createAttributeSnapshot(activePage.selectionList, focusedGraphicSideName + '-opacity');
        const selectionList = activePage.selectionList;
        if (selectionList.length > 0) {
            this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
            };
        }
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();

    }

    onSliderChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const focusedGraphicSideName = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.undoAction = new UndoRedoAction();
            this.redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
            this.undoAction.createAttributeSnapshot(activePage.selectionList, focusedGraphicSideName + '-opacity');
        }
        const properties = {};
        properties[focusedGraphicSideName + '-opacity'] = _e.target.value / 100;
        activeDocument.setAttributeElementList(activePage.selectionList, properties);
        this.controlledElements.opacity.value = _e.target.value + ' %';
    }

    // onChange_patternUnits(_e){
    //
    //     const editablePattern = this.editablePattern.original;
    //
    //
    //     const patternUnits = this.controlledElements.patternUnits.value;
    //     const properties ={};
    //     properties.patternUnits = patternUnits;
    //
    //     if(patternUnits==='objectBoundingBox')
    //     {
    //         properties.x1 = 0; properties.y1 = 0.5; properties.x2 = 1; properties.y2 = 0.5;
    //     }
    //     else if(patternUnits==='userSpaceOnUse')
    //     {
    //         properties.x1 = 0; properties.y1 = 50; properties.x2 = 100; properties.y2 = 50;
    //     }
    //
    //     activeApplication.activeDocument.setAttributeElementList_undable([editablePattern],properties , false );
    //
    //
    //
    // };

}
customElements.define("pattern-inspector", PatternInspector_cmp);

class AppearanceInspector_cmp extends PopUpPanel {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        const opacityValue = activeEditableElement.getAttribute('opacity') || 1;

        this.controlledElements.opacitySlider.value = activeDocument.valueToFixed(opacityValue * 100);
        this.controlledElements.opacity.value = this.controlledElements.opacitySlider.value + ' %';

        this.controlledElements.mixBlendMode.value = activeEditableElement.style.mixBlendMode || 'normal';
        this.controlledElements.paintOrder.value = activeEditableElement.getAttribute('paint-order') || 'normal';

    }

    onChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        if (newValue > 0)
            newValue /= 100;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'opacity': newValue
        });
    }

    onSliderChangeEnd_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionList = activePage.selectionList;
        this.redoAction.createAttributeSnapshot(selectionList, 'opacity');
        this.undoAction.onExecuteEnd = this.redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectionList);
        };
        this.undoAction = this.redoAction = null;
        activeDocument.onChange();
    }

    onSliderChange_opacity(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (!this.undoAction) {
            this.undoAction = new UndoRedoAction();
            this.redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(this.undoAction, this.redoAction);
            this.undoAction.createAttributeSnapshot(activePage.selectionList, 'opacity');
        }
        activeDocument.setAttributeElementList(activePage.selectionList, {
            'opacity': _e.target.value / 100
        });
        this.controlledElements.opacity.value = _e.target.value + ' %';
    }

    onChange_paintOrder(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.setAttributeElementList_undable(activePage.selectionList, {
            'paint-order': _e.target.value
        });
    }

    onChange_mixBlendMode(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const styleList = [];
        for (let i = 0; i < activePage.selectionList.length; i++) {
            if (activePage.selectionList[i].style)
                styleList.push(activePage.selectionList[i].style);
        }

        activeDocument.setPropertyElementList_undable(styleList, {
            'mixBlendMode': _e.target.value
        });

    }

}

customElements.define("appearance-inspector", AppearanceInspector_cmp);

class SnapsInspector_cmp extends PopUpPanel {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.controlledElements.snapToGrid.checked = activeDocument.preferences.snap.snapToGrid;
        this.controlledElements.snapToAngles.checked = activeDocument.preferences.snap.snapToAngles;
        this.controlledElements.snapToPoints.checked = activeDocument.preferences.snap.snapToPoints;
        this.controlledElements.snapToCenter.checked = activeDocument.preferences.snap.snapToCenter;
        this.controlledElements.snapToContour.checked = activeDocument.preferences.snap.snapToContour;
        this.controlledElements.snapToPerpendicular.checked = activeDocument.preferences.snap.snapToPerpendicular;
        this.controlledElements.snapToIntersection.checked = activeDocument.preferences.snap.snapToIntersection;
        this.controlledElements.snapToOffset.checked = activeDocument.preferences.snap.snapToOffset;
        this.controlledElements.snapToTangent.checked = activeDocument.preferences.snap.snapToTangent;
        this.controlledElements.useSmartGuides.checked = activeDocument.preferences.snap.useSmartGuides;
        this.controlledElements.useSmartPoints.checked = activeDocument.preferences.snap.useSmartPoints;

        this.controlledElements.distance.value = activeDocument.preferences.snap.distance;
        this.controlledElements.gridStep.value = activeDocument.valueToUnit(activeDocument.preferences.gridStep);
        this.controlledElements.snapAngleList.value = activeDocument.preferences.snap.snapAngleList.join(',');
        this.controlledElements.offsetDistance.value = activeDocument.preferences.snap.offsetDistance;

    }

    onChange_snap(_e) {
        activeApplication.activeDocument.preferences.snap[_e.target.id] = _e.target.checked;
    };

    onChange_distance(_e) {
        const activeDocument = activeApplication.activeDocument;
        const snapDistance = parseFloat(_e.target.value);
        if (isNaN(snapDistance))
            return;
        activeDocument.preferences.snap.distance = snapDistance;
    }

    onChange_gridStep(_e) {
        const activeDocument = activeApplication.activeDocument;
        const gridStep = parseFloat(_e.target.value);
        if (isNaN(gridStep))
            return;
        activeDocument.preferences.gridStep = activeDocument.unitToValue(gridStep);
        activeApplication.workspace.update();
    }

    onChange_snapAngleList(_e) {
        const activeDocument = activeApplication.activeDocument;
        const angleList = _e.target.value.split(',');
        const numericAngleList = []
        for (let i = 0; i < angleList.length; i++) {
            numericAngleList.push(parseFloat(angleList[i]));
        }
        activeDocument.preferences.snap.snapAngleList = numericAngleList;

    }

    onChange_offsetDistance(_e) {
        const activeDocument = activeApplication.activeDocument;
        const offsetDistance = parseFloat(_e.target.value);
        if (isNaN(offsetDistance))
            return;
        activeDocument.preferences.snap.offsetDistance = activeDocument.unitToValue(offsetDistance);
        activeApplication.workspace.update();
    }

}

customElements.define("snaps-inspector", SnapsInspector_cmp);

class SettingsInspector_cmp extends PopUpPanel {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.controlledElements.unitKey.value = activeDocument.preferences.unitKey;
        this.controlledElements.fixedDecimals.value = activeDocument.preferences.fixedDecimals;
        // this.controlledElements.drawingScale.value = activeDocument.preferences.drawingScale;
        this.controlledElements.drawingScaleMenu.value = activeDocument.preferences.drawingScale;
        this.controlledElements.scaleStrokeAndEffects.checked = activeDocument.preferences.scaleStrokeAndEffects;
        this.controlledElements.scaleText.checked = activeDocument.preferences.scaleText;
        this.controlledElements.selectMainNodes.checked = activeDocument.preferences.selectMainNodes;
        this.controlledElements.optimizeZoom.checked = activeDocument.preferences.optimizeZoom;
        this.controlledElements.elementOriginVisibility.checked = activeDocument.preferences.elementOriginVisibility;

        this.controlledElements.rulersVisibility.checked = activeDocument.preferences.rulersVisibility;
        this.controlledElements.gridVisibility.checked = activeDocument.preferences.gridVisibility;

        this.controlledElements.moveStep.value = activeDocument.valueToUnit(activeDocument.preferences.moveStep);
        this.controlledElements.rotateStep.value = activeDocument.preferences.rotateStep + ' °';

        // this.controlledElements.svgAlignmentPreserveAspectRatio.value = activeDocument.preferences.svgAlignmentPreserveAspectRatio;

        const alignmentArray = activeDocument.preferences.svgAlignmentPreserveAspectRatio.split(' ');
        //console.log('alignmentArray',alignmentArray);
        this.controlledElements.svgOutputAlignment.value = alignmentArray[0];
        if (alignmentArray.length === 2) {
            this.controlledElements.svgOutputScaleMode.value = alignmentArray[1];
        }

    }

    onChange_unitKey(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.setUnits(this.controlledElements.unitKey.value);
        activeDocument.setActivePageScale('fit');
        activeApplication.workspace.update();
        this.update();
    }

    onChange_fixedDecimals(_e) {
        const activeDocument = activeApplication.activeDocument;
        let fixedDecimals = parseInt(this.controlledElements.fixedDecimals.value);
        if (isNaN(fixedDecimals))
            fixedDecimals = 2;
        activeApplication.activeDocument.preferences.fixedDecimals = fixedDecimals;
        activeApplication.workspace.update();
        this.update();
    }

    onChange_drawingScaleMenu(_e) {
        const activeDocument = activeApplication.activeDocument;
        const drawingScale = parseInt(this.controlledElements.drawingScaleMenu.value);
        if (isNaN(drawingScale))
            return;
        activeDocument.setDrawingScale(drawingScale)
        //activeDocument.preferences.drawingScale = drawingScale ;
        activeDocument.setActivePageScale('fit');
        //activeApplication.workspace.update();
    }

    onChange_selectMainNodes(_e) {
        activeApplication.activeDocument.preferences.selectMainNodes = this.controlledElements.selectMainNodes.checked;
    };

    onChange_scaleStrokeAndEffects(_e) {
        activeApplication.activeDocument.preferences.scaleStrokeAndEffects = this.controlledElements.scaleStrokeAndEffects.checked;
    };

    onChange_scaleText(_e) {
        activeApplication.activeDocument.preferences.scaleText = this.controlledElements.scaleText.checked;
    };

    onChange_optimizeZoom(_e) {
        activeApplication.activeDocument.preferences.optimizeZoom = this.controlledElements.optimizeZoom.checked;
    };

    onChange_elementOriginVisibility(_e) {
        activeApplication.activeDocument.preferences.elementOriginVisibility = this.controlledElements.elementOriginVisibility.checked;
        activeApplication.workspace.update();
    }

    onChange_rulersVisibility(_e) {
        activeApplication.activeDocument.preferences.rulersVisibility = _e.target.checked;
        if (_e.target.checked === false) {
            this.controlledElements.gridVisibility.checked = activeApplication.activeDocument.preferences.gridVisibility = false;
        }
        activeApplication.editingView.update();
    }

    onChange_interactionLabelVisibility(_e) {
        activeApplication.activeDocument.preferences.interactionLabelVisibility = _e.target.checked;
        if (_e.target.checked === false) {
            this.controlledElements.interactionLabelVisibility.checked = activeApplication.activeDocument.preferences.interactionLabelVisibility = false;
        }
        activeApplication.workspace.update();
    }

    onChange_gridVisibility(_e) {
        activeApplication.activeDocument.preferences.gridVisibility = _e.target.checked;
        if (_e.target.checked === true) {
            this.controlledElements.rulersVisibility.checked = activeApplication.activeDocument.preferences.rulersVisibility = true;
        }
        activeApplication.editingView.update();
    }

    onChange_moveStep(_e) {
        const activeDocument = activeApplication.activeDocument;
        const moveStep = parseFloat(_e.target.value);
        if (isNaN(moveStep))
            return;
        activeDocument.preferences.moveStep = activeDocument.unitToValue(moveStep);
    }

    onChange_rotateStep(_e) {
        const activeDocument = activeApplication.activeDocument;
        const rotateStep = parseFloat(_e.target.value);
        if (isNaN(rotateStep))
            return;
        activeDocument.preferences.rotateStep = rotateStep;
    }

    onChange_svgOutputAlignment(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (this.controlledElements.svgOutputAlignment.value === 'unset') {
            activeDocument.preferences.svgAlignmentPreserveAspectRatio = 'unset';
            return;
        }

        activeDocument.preferences.svgAlignmentPreserveAspectRatio = this.controlledElements.svgOutputAlignment.value + ' ' + this.controlledElements.svgOutputScaleMode.value;
    }

    onChange_svgOutputScaleMode(_e) {
        this.onChange_svgOutputAlignment(_e);
        // const activeDocument = activeApplication.activeDocument;
        // activeDocument.preferences.svgAlignmentPreserveAspectRatio = this.controlledElements.svgOutputAlignment.value + ' ' + this.controlledElements.svgOutputScaleMode.value ;
    }
}

customElements.define("settings-inspector", SettingsInspector_cmp);

class PageInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        // this.setUnits( 'MILLIMETER'  );
    }

    onClick_collapse(_e) {
        _e.target.closest('.property-container').classList.toggle('collapsed');
        this.update();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.preferences.unitKey === 'PIXEL') {
            this.setUnits('PIXEL');
        } else {
            this.setUnits('MILLIMETER');
        }
        //this.controlledElements.unitKey.value = this.unitKey;


        this.controlledElements.pageWidth.value = this.valueToUnit(parseInt(activePage.dataset.pageWidth));
        this.controlledElements.pageHeight.value = this.valueToUnit(parseInt(activePage.dataset.pageHeight));
        this.controlledElements.pagePresets.value = 'formats';

        this.controlledElements.id.value = activePage.getAttribute('id') || '';
        this.controlledElements.name.value = activePage.getAttribute('data-name') || '';

        let title = '',
        titleElement = activePage.parentElement.querySelector('svg.page.showed>title');
        if (titleElement)
            title = titleElement.innerHTML;
        this.controlledElements.title.value = title;

        let description = '',
        descElement = activePage.parentElement.querySelector('svg.page.showed>desc');
        if (descElement)
            description = descElement.innerHTML;
        this.controlledElements.desc.value = description;

        this.controlledElements.cssClass.value = activePage.getAttribute('data-css-class') || '';

    }

    // onChange_unitKey( _e )
    // {
    // 	this.setUnits( this.controlledElements.unitKey.value );
    // 	this.update();
    // }


    setUnits(_unitKey) {
        this.unitKey = _unitKey;
        const unitProperties = GeometryUtils.unitProperty[this.unitKey];
        this.unitValue = unitProperties.unitValue;
        this.unitName = unitProperties.unitName;
    }

    // le pagine sono in mm
    valueToUnit(_valueInPixel) {
        return Number(_valueInPixel * this.unitValue).toFixed(0) + ' ' + this.unitName;
    }

    unitToValue(_value) {
        return Number(_value / this.unitValue).toFixed(0);
    }

    onChange_pageWidth(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let pageWidth = Math.evalExpression(this.controlledElements.pageWidth.value);
        if (isNaN(pageWidth))
            return;
        pageWidth = this.unitToValue(pageWidth);
        activeDocument.setActivePageSize(pageWidth, activePage.dataset.pageHeight, this.querySelector('#applyFormatToAllPages').checked);
        activeDocument.setActivePageScale('fit');
        activeApplication.workspace.update();
    };

    onChange_pageHeight(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let pageHeight = Math.evalExpression(this.controlledElements.pageHeight.value);
        if (isNaN(pageHeight))
            return;
        pageHeight = this.unitToValue(pageHeight);
        activeDocument.setActivePageSize(activePage.dataset.pageWidth, pageHeight, this.querySelector('#applyFormatToAllPages').checked);
        activeDocument.setActivePageScale('fit');
        activeApplication.workspace.update();
    };

    onChange_pagePresets(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const data = _e.target.value.split(',');

        let newPageWidth = parseFloat(data[0]);
        let newPageHeight = parseFloat(data[1]);
        const newPage_unit = data[2];

        activeDocument.setUnits(newPage_unit);
        //this.setUnits(newPage_unit);


        newPageWidth = this.unitToValue(newPageWidth);
        newPageHeight = this.unitToValue(newPageHeight);

        activeDocument.setActivePageSize(newPageWidth, newPageHeight, this.querySelector('#applyFormatToAllPages').checked);
        activeDocument.setActivePageScale('fit');
        activeApplication.workspace.update();
        this.update();
    };

    onClick_PortraitLandscape() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let pageWidth = Math.evalExpression(this.controlledElements.pageWidth.value);
        let pageHeight = Math.evalExpression(this.controlledElements.pageHeight.value);
        if (isNaN(pageWidth) || isNaN(pageHeight))
            return;
        activeDocument.setActivePageSize(this.unitToValue(pageHeight), this.unitToValue(pageWidth), this.querySelector('#applyFormatToAllPages').checked);
        activeDocument.setActivePageScale('fit');
        activeApplication.workspace.update();
        this.update();
    }

    onChange_ID(_e) {

        const idElement = _e.target.value;

        if (idElement !== '') {
            if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
                /* Does not match*/
                DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'));
                return;
            }
            if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
                DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement);
                return;
            }

            // function onClick_OK() {
            // 	this.close();
            // 	_e.target.focus();
            // 	_e.target.select();
            // }
            //
            // if (!(/^[A-Za-z][-A-Za-z0-9_:.]*$/.test(idElement))) {
            // 	/* Does not match*/
            // 	DIALOGS['alert-dialog'].open(localString('Invalid identifier'), localString('ID must begin with a letter ([A-Za-z]) and may be followed by any number of letters.'), onClick_OK);
            // 	return;
            // }
            // if (activeApplication.activeDocument.shadowRoot.querySelector('*[id="' + idElement + '"]')) {
            // 	DIALOGS['alert-dialog'].open(localString('Existent ID'), localString('The document already contains an element with ID:') + idElement, onClick_OK);
            // 	return;
            // }
        }

        _e.target.blur();

        const activePage = activeApplication.activeDocument.activePage;
        activeApplication.activeDocument.setAttributeElementList_undable([activePage], {
            'id': idElement
        }, false);
        //PANELS['page-list-inspector'].updatePageNumber();

    }

    onChange_name(_e) {
        const activePage = activeApplication.activeDocument.activePage;

        if (_e.target.value === '') {
            activePage.removeAttribute('data-name');
        } else {
            activePage.setAttribute('data-name', _e.target.value);
        }
    }

    onChange_title(_e) {
        const activePage = activeApplication.activeDocument.activePage;

        let titleElement = activePage.parentElement.querySelector('svg.page.showed>title');

        if (_e.target.value === '') {
            if (titleElement)
                titleElement.remove();
        } else {

            if (!titleElement) {
                titleElement = document.createElementNS(SVGSVGElement.SVG_NS, 'title');
                //activePage.appendChild(titleElement);
                activePage.insertBefore(titleElement, activePage.firstChild);
            }

            titleElement.innerHTML = XOS.stripHtml(_e.target.value);
        }
    };

    onChange_desc(_e) {
        const activePage = activeApplication.activeDocument.activePage;
        let descElement = activePage.parentElement.querySelector('svg.page.showed>desc');

        if (_e.target.value === '') {
            if (descElement)
                descElement.remove();
        } else {

            if (!descElement) {
                descElement = document.createElementNS(SVGSVGElement.SVG_NS, 'desc');
                //activePage.appendChild(descElement);
                activePage.insertBefore(descElement, activePage.firstChild);
            }

            descElement.innerHTML = XOS.stripHtml(_e.target.value);
        }

    };

    onChange_cssClass(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const value = _e.target.value;
        if (value === '') {
            activePage.removeAttribute('data-css-class');
        } else {
            activePage.setAttribute('data-css-class', value);
        }
    }

}

customElements.define("page-inspector", PageInspector_cmp);

class GlobalColorPicker_cmp extends PopUpPanel {

    constructor() {
        super('C');

    }

    set(_hexColor, _alpha, _onChangeEndFunction, _onChangeFunction, _onChangeStartFunction) {
        this.colorPicker = this.querySelector('color-picker');
        this.colorPicker.setColor(_hexColor, _alpha);
        this.colorPicker.setOnChangeEvents(_onChangeEndFunction, _onChangeFunction, _onChangeStartFunction)
    }
}

customElements.define("global-color-picker", GlobalColorPicker_cmp);

class BaseObjectInspector_cmp extends HTMLElement {

    constructor() {
        super();
        this.objectController = null;
        this.objectProperties = null;
        this.elements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        console.log('this.elements', this.elements);
        this.createInputGetterSetter();
    }

    createInputGetterSetter() {

        for (const name in this.elements) {
            const inputElement = this.elements[name];
            if (inputElement.dataset.propertyType === 'color') {
                console.log('inputElement color', inputElement);
                Object.defineProperty(inputElement, 'value', {
                    set: function (_value) {
                        console.log('set inputElement color', inputElement);
                        inputElement.querySelector('.rgba').style.backgroundColor = _value;
                    }
                });
            }
        }
    }

    onClickOnTabBar(_e) {
        XOS.selectElement(_e.target);
        XOS.showElement(this.querySelector('.' + _e.target.dataset.sectionTarget));
    }

    update(_graphicElement) {
        this.graphicElement = _graphicElement;
        this.objectController = this.graphicElement.getObjectController();
        this.objectProperties = this.objectController.getProperties();
        // this.objectController = OBJECTS[ this.graphicElement.dataset.objectId ];
        // this.objectController.properties = this.objectProperties = this.graphicElement.getStoredJsonData('jvs-object-properties') ||  this.objectController.properties;

        let inputElement;
        for (let name in this.elements) {
            inputElement = this.elements[name];
            if (inputElement.dataset.propertyType === 'color') {
                inputElement.value = this.objectProperties[name];
            } else if (inputElement.dataset.propertyType === 'angle') {
                inputElement.value = activeApplication.activeDocument.valueToFixed(this.objectProperties[name]) + ' °';
            } else if (inputElement.dataset.propertyType === 'dimension') {
                inputElement.value = activeApplication.activeDocument.valueToUnit(this.objectProperties[name]);
            } else if (inputElement.dataset.propertyType === 'boolean') {
                inputElement.checked = this.objectProperties[name];
            } else if (inputElement.dataset.propertyType === 'string') {
                inputElement.value = this.objectProperties[name];
            }
        }

    }

    onChangeProperty(_e) {
        let inputElement = _e.target;
        const propertyType = inputElement.dataset.propertyType;
        const propertyName = inputElement.getAttribute('name');
        let propertyValue;
        if (propertyType === 'dimension') {
            propertyValue = Math.evalExpression(_e.target.value);
            if (isNaN(propertyValue))
                return;
            propertyValue = activeApplication.activeDocument.unitToValue(propertyValue);
        } else if (propertyType === 'angle') {
            propertyValue = Math.evalExpression(_e.target.value);
            if (isNaN(propertyValue))
                return;
        } else if (propertyType === 'boolean') {
            propertyValue = _e.target.checked;
        } else if (propertyType === 'string') {
            propertyValue = _e.target.value;
        }

        const objectProperties = {};
        objectProperties[propertyName] = propertyValue;

        activeApplication.activeDocument.setPropertyObjectElementList_undable(activeApplication.activeDocument.activePage.selectionList, objectProperties);
    }

    chooseColor(_e) {
        const inputColorElement = _e.target;
        const colorPropertyName = inputColorElement.getAttribute('name');
        const colorPicker = PANELS['global-color-picker'];
        function onChangeEnd(_colorPicker) {
            const objectProperties = {};
            objectProperties[colorPropertyName] = _colorPicker.hex;
            activeApplication.activeDocument.setPropertyObjectElementList_undable(activeApplication.activeDocument.activePage.selectionList, objectProperties);
        }

        colorPicker.set(this.objectProperties[colorPropertyName], 1, onChangeEnd);
        colorPicker.activateBy(inputColorElement);
    }
}

class DrawRegularPolygonToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        this.controlledElements.numSides.value = TOOLS['draw-regular-polygon-tool'].numSides;
    }

    onChange_numSides(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        TOOLS['draw-regular-polygon-tool'].numSides = newValue;
    }
}

customElements.define("draw-regular-polygon-tool-info", DrawRegularPolygonToolInfo_cmp);

class DrawFreehandToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        this.controlledElements.simplifyTolerance.value = TOOLS['draw-freehand-tool'].simplifyTolerance;
        this.controlledElements.joinTolerance.value = TOOLS['draw-freehand-tool'].joinTolerance;
    }

    onChange_simplifyTolerance(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        TOOLS['draw-freehand-tool'].simplifyTolerance = newValue;
    }

    onChange_joinTolerance(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        TOOLS['draw-freehand-tool'].joinTolerance = newValue;
    }

}

customElements.define("draw-freehand-tool-info", DrawFreehandToolInfo_cmp);

class RotateByPivotToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        this.controlledElements.rotation.value = '0';
    }

    onChange_rotation(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const pivot = activeApplication.workspace.rotateByPivotInteraction.pivot.getCTM().getTranslation();

        if (activePage.selectionPointList.length > 0) {

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const selectedElementList = activePage.selectionList;

            undoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

            activeDocument.rotateTransformDataPointList(activeDocument.getSelectedTransformablePointData(), newValue, pivot, true);

            redoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

            undoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectedElementList);
                for (let i = 0; i < selectedElementList.length; i++)
                    selectedElementList[i].geometryPointList = null;
            };
            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectedElementList);
                for (let i = 0; i < selectedElementList.length; i++)
                    selectedElementList[i].geometryPointList = null;
            };

            activeDocument.onChange();
            activeApplication.workspace.snapInteraction2D.reset();
            activeApplication.workspace.update();

        } else {
            activeDocument.rotateElementList_undable(activePage.selectionList, newValue, pivot);
        }

        this.controlledElements.rotation.select();

    };

}

customElements.define("rotate-by-pivot-tool-info", RotateByPivotToolInfo_cmp);

class ScaleByPivotToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        this.mantainAspectRatio = true;
    }

    update() {
        this.controlledElements.scaleX.value = '1';
        this.controlledElements.scaleY.value = '1';
        if (this.mantainAspectRatio === true) {
            XOS.selectElement(this.controlledElements['mantain-aspect-ratio-button']);
        } else {
            XOS.deselectElement(this.controlledElements['mantain-aspect-ratio-button']);
        }
    }

    onChange_scale(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        let scaleX = 1;
        let scaleY = 1;
        if (this.mantainAspectRatio) {
            scaleY = scaleX = newValue;
        } else {
            if (_e.target.name === 'scaleX') {
                scaleX = newValue;
            } else if (_e.target.name === 'scaleY') {
                scaleY = newValue;
            }
        }

        console.log('onChange_scale', _e.target.name);

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const pivot = activeApplication.workspace.scaleByPivotInteraction.pivot.getCTM().getTranslation();

        if (activePage.selectionPointList.length > 0) {

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const selectedElementList = activePage.selectionList;

            undoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

            activeDocument.scaleTransformDataPointList(activeDocument.getSelectedTransformablePointData(), scaleX, scaleY, pivot, true);

            redoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

            undoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectedElementList);
                for (let i = 0; i < selectedElementList.length; i++)
                    selectedElementList[i].geometryPointList = null;
            };
            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectedElementList);
                for (let i = 0; i < selectedElementList.length; i++)
                    selectedElementList[i].geometryPointList = null;
            };

            activeDocument.onChange();
            activeApplication.workspace.snapInteraction2D.reset();
            activeApplication.workspace.update();

        } else {
            activeDocument.scaleElementList_undable(activePage.selectionList, scaleX, scaleY, pivot);
        }

        //this.controlledElements.rotation.select();

    };

    onClick_mantainAspectRatio(_e) {
        this.mantainAspectRatio = this.mantainAspectRatio !== true;
        console.log('this.mantainAspectRatio', this.mantainAspectRatio);
        this.update();
    };

}

customElements.define("scale-by-pivot-tool-info", ScaleByPivotToolInfo_cmp);

class OffsetToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        PANELS["offset-tool-info"] = this;
    }

    update() {
        this.controlledElements.offset.value = TOOLS["offset-tool"].offset || '';
    }

    setInputPropertyFocus(_focusField, _value) {
        this.controlledElements[_focusField].removeAttribute('disabled');
        this.controlledElements[_focusField].value = activeApplication.activeDocument.valueToUnit(_value);
        this.controlledElements[_focusField].select();

    }

    onChange_offset(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        newValue = activeDocument.unitToValue(newValue);

        TOOLS["offset-tool"].updateDrawingInteraction({
            offsetValue: newValue
        });
        TOOLS["offset-tool"].finalize(_e);

        this.controlledElements.offset.blur();
        this.controlledElements.offset.setAttribute('disabled', 'true');

    };

}

customElements.define("offset-tool-info", OffsetToolInfo_cmp);

class RoundCornersToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        PANELS["round-corners-tool-info"] = this;
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        this.controlledElements.radiusLimit.value = activeDocument.valueToUnit(TOOLS["round-corners-tool"].radiusLimit);
    }

    onChange_radiusLimit(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;

        const activeDocument = activeApplication.activeDocument;
        newValue = activeDocument.unitToValue(newValue);
        TOOLS["round-corners-tool"].radiusLimit = newValue;
    };

}

customElements.define("round-corners-tool-info", RoundCornersToolInfo_cmp);

class JoinFilletToolInfo_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        PANELS["join-fillet-tool-info"] = this;
    }

    update() {
        //this.controlledElements.filletRadius.value = TOOLS["join-fillet-tool"].filletRadius || '' ;
        const offsetValue = TOOLS["join-fillet-tool"].filletRadius;

        this.controlledElements.filletRadius.value = activeApplication.activeDocument.valueToUnit(offsetValue);

    }

    // setInputPropertyFocus( _focusField , _value  ) {
    // 	this.controlledElements[_focusField].removeAttribute('disabled');
    // 	this.controlledElements[_focusField].value = activeApplication.activeDocument.valueToUnit(_value);
    // 	this.controlledElements[_focusField].select();
    // }

    onChange_filletRadius(_e) {
        let newValue = Math.evalExpression(_e.target.value);
        if (isNaN(newValue))
            return;
        newValue = activeApplication.activeDocument.unitToValue(newValue);
        TOOLS["join-fillet-tool"].filletRadius = newValue;
    };

}

customElements.define("join-fillet-tool-info", JoinFilletToolInfo_cmp);

class ToolsWindow extends WindowBase {

    constructor() {
        super();
        this.buttonBar = this.querySelector('.button-bar');
        XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    addTool(_tool) {
        const toolButton = document.getElementById('TOOL-BUTTON').content.querySelector('div').cloneNode(true);
        toolButton.setAttribute('data-tool-name', _tool.name);
        toolButton.querySelector('svg>use').setAttribute('xlink:href', _tool.iconUrl);
        this.buttonBar.appendChild(toolButton);
    }

    addToolObject(_properties) {
        const toolButton = document.getElementById('TOOL-BUTTON').content.querySelector('div').cloneNode(true);
        toolButton.setAttribute('data-tool-name', _properties.name);
        //TOOLS[ _properties.name ] = TOOLS[ 'draw-object-tool' ]; // creo un riferimento a draw-object-tool ma con il nome del nuovo tool
        TOOLS[_properties.name] = new DrawObject2D_tool(_properties.name, _properties.shortcut); // creo un draw-object-tool ma con il nome del nuovo tool
        TOOLS[_properties.name].objectId = _properties.objectId;

        toolButton.querySelector('svg>use').setAttribute('xlink:href', _properties.iconUrl);
        //toolButton.dataset.objectId =_properties.objectId;
        this.buttonBar.appendChild(toolButton);
    }

    // addToolObject( _properties )
    // {
    //     const toolButton = document.getElementById('TOOL-BUTTON').content.querySelector('div').cloneNode(true);
    //     toolButton.setAttribute('data-tool-name' , _properties.name );
    //     TOOLS[ _properties.name ] = TOOLS[ 'draw-object-tool' ]; // creo un riferimento a draw-object-tool ma con il nome del nuovo tool
    //
    //     toolButton.querySelector('svg>use').setAttribute('xlink:href', _properties.iconUrl );
    //     toolButton.dataset.objectId =_properties.objectId;
    //     this.buttonBar.appendChild( toolButton );
    // }

    //onClickOnButton(_e)
    onMouseDownOnToolButton(_e) {
        //console.log('onMouseDownOnToolButton' , _e);
        const button = _e.target;

        if (button.dataset.toolName) {
            const toolName = button.dataset.toolName;
            //if(button.dataset.objectId) TOOLS[ toolName ].objectId = button.dataset.objectId; // setto il riferimento all'ogetto da creare
            activeApplication.setActiveTool(toolName);
        }

        // if(button.dataset.panelTarget)
        // {
        //     const panelToActivate = PANELS[button.dataset.panelTarget];
        //     panelToActivate.activateBy(button,undefined);
        //     // evita che il pannello non venga chiuso ( l'attivazione dello strumento avviene con mousedown non con click )
        //     _e.preventDefault();
        //     _e.stopPropagation();
        // }
    }

}

customElements.define("tools-window", ToolsWindow);

class MainInspectorWindow extends WindowBase {

    constructor() {
        super();
        //this.transformInspector = this.querySelector('transform-inspector')
        XOS.connectDomEvents(this.querySelectorAll('.button-bar [data-event]'), this);
        XOS.connectDomEvents(this.querySelectorAll('.tab-bar[data-event]'), this);
        this.style.left = document.body.offsetWidth - 180 + 'px';
    }

    onClickOnTabBar(_e) {
        //console.log('onClickOnTabBar', _e.target );
        XOS.selectElement(_e.target);
        XOS.showElement(this.querySelector('.' + _e.target.dataset.sectionTarget));
        this.update('tab-bar');
    }

    showMainSection(_mainSectionName) {
        const tabBarItemToSelect = this.querySelector('.main-tab-bar > [data-section-target="' + _mainSectionName + '"]');
        if (tabBarItemToSelect.classList.contains('selected'))
            return;

        XOS.selectElement(tabBarItemToSelect);
        XOS.showElement(this.querySelector('.main-sections > .' + _mainSectionName));
        this.update();
    }

    //
    // onClickOnPanelActivator(_e)
    // {
    //     const buttonTarget = _e.target;
    //     let panelToActivate = PANELS[buttonTarget.dataset.panelTarget];
    //     panelToActivate.activateBy(buttonTarget,undefined);
    // }

    onExpand() {
        this.update();
    }

    update(_by) {
        if (this.classList.contains('collaped'))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        const activeMainSectionName = this.querySelector('.main-tab-bar > .selected').dataset.sectionTarget;

        if (activeMainSectionName === 'selection-section') {
            if (activeEditableElement) {
                const selectionSection = this.querySelector('.main-sections > .selection-section');
                XOS.showElement(selectionSection);

                const activeSubSectionName = selectionSection.querySelector('.tab-bar > .selected').dataset.sectionTarget;
                const activeSubSection = selectionSection.querySelector('.' + activeSubSectionName);
                XOS.showElement(activeSubSection);

                if (activeSubSection.classList.contains('graphic-section')) {
                    this.updateGraphicSection();
                } else {
                    activeSubSection.firstElementChild.update();
                }

            } else {
                const pageSection = this.querySelector('.main-sections > .page-section');
                XOS.showElement(pageSection);
                pageSection.firstElementChild.update();
            }
        } else if (activeMainSectionName === 'tool-section') {
            const activeToolName = activeApplication.getAttribute('active-tool');
            //console.log('activeToolName',activeToolName)

            const toolSection = this.querySelector('.main-sections > .tool-section');

            const toolInfoPanel = toolSection.querySelector(activeToolName + '-info');
            //console.log('toolInfoPanel name',activeToolName+'-info');
            if (toolInfoPanel) {
                XOS.showElement(toolInfoPanel);
                if (toolInfoPanel.update)
                    toolInfoPanel.update();
            } else {
                XOS.showElement(toolSection.lastElementChild);
            }
        }

    }

    updateGraphicSection() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        let activeTransformInspectorPanel;
        if (activePage.selectionList.length === 1) {
            if (activeEditableElement.nodeName === 'line') {
                activeTransformInspectorPanel = this.querySelector('line-transform-inspector');
            } else if (activeEditableElement.nodeName === 'path') {
                if (activePage.focusedPathSegmentPoint) {
                    if (activePage.focusedPathSegmentPoint.type === 'L') {
                        activeTransformInspectorPanel = this.querySelector('line-to-transform-inspector');
                    } else if (activePage.focusedPathSegmentPoint.type === 'A') {
                        activeTransformInspectorPanel = this.querySelector('arc-to-transform-inspector');
                    } else if (activePage.focusedPathSegmentPoint.type === 'C' || activePage.focusedPathSegmentPoint.type === 'Q') {
                        activeTransformInspectorPanel = this.querySelector('curve-to-transform-inspector');
                    }
                } else if (activePage.focusedPoint) {
                    activeTransformInspectorPanel = this.querySelector('path-point-transform-inspector');
                } else {
                    activeTransformInspectorPanel = this.querySelector('rectangular-transform-inspector');
                }
            }
            // else if(activeEditableElement.nodeName==='path' && activePage.focusedPathSegmentPoint && activePage.focusedPathSegmentPoint.type==='L')
            // {
            //     activeTransformInspectorPanel = this.querySelector('line-to-transform-inspector');
            // }
            else {
                if (activeEditableElement.dataset.objectId) {
                    const objectController = OBJECTS[activeEditableElement.dataset.objectId];
                    if (objectController.type === 'linear-object') {
                        activeTransformInspectorPanel = this.querySelector('linear-transform-inspector');
                    } else if (objectController.type === 'rectangular-object') {
                        activeTransformInspectorPanel = this.querySelector('rectangular-transform-inspector');
                    } else if (objectController.type === 'radial-object') {
                        activeTransformInspectorPanel = this.querySelector('radial-transform-inspector');
                    }
                } else {
                    activeTransformInspectorPanel = this.querySelector('rectangular-transform-inspector');
                }
            }
        } else if (activePage.focusedPoint) {
            activeTransformInspectorPanel = this.querySelector('path-point-transform-inspector');
        } else {
            activeTransformInspectorPanel = this.querySelector('rectangular-transform-inspector');
        }

        // if(activeEditableElement.nodeName==='line')
        // {
        //     activeTransformInspectorPanel = this.querySelector('line-transform-inspector');
        // }else {
        //     if(activeEditableElement.dataset.type==='object' && activeEditableElement.dataset.objectType==='linear-object')
        //     {
        //         activeTransformInspectorPanel = this.querySelector('linear-transform-inspector');
        //     }else{
        //         activeTransformInspectorPanel = this.querySelector('rectangular-transform-inspector');
        //     }
        // }


        XOS.showElement(activeTransformInspectorPanel);
        activeTransformInspectorPanel.update();

        // specific object

        if (activeEditableElement.dataset.type && activeEditableElement.dataset.objectId) {
            const objectController = OBJECTS[activeEditableElement.dataset.objectId];
            if (!objectController) {
                //console.log('objectController undefined');
                return;
            }
            const elementInspectorName = activeEditableElement.dataset.objectId + '-inspector';
            const panelContainer = this.querySelector('#element-panels');
            let inspectorPanel = panelContainer.querySelector(':scope>' + elementInspectorName);
            if (!inspectorPanel) {
                const container = document.createElement('div');
                container.innerHTML = objectController.createInspector();
                inspectorPanel = panelContainer.appendChild(container.firstElementChild);
            }
            XOS.showElement(inspectorPanel);
            inspectorPanel.update(activeEditableElement);
            return;
        }

        let elementInspectorName = activeEditableElement.nodeName + '-inspector';

        if (activeEditableElement && activeEditableElement.nodeName === 'g') {
            if (activeEditableElement.hasAttribute('clip-path')) {
                elementInspectorName = 'clipped-content-inspector';
            } else if (activeEditableElement.hasAttribute('mask')) {
                elementInspectorName = 'masked-content-inspector';
            } else {
                elementInspectorName = 'group-inspector';
            }
        } else if (activeEditableElement && activeEditableElement.nodeName === 'foreignObject') {
            elementInspectorName = 'foreign-object-inspector';

            if (activeEditableElement.hasAttribute('data-type')) {
                const elementType = activeEditableElement.getAttribute('data-type');
                if (elementType === 'html-text')
                    elementInspectorName = 'html-text-inspector';
            }
        }

        const elementInspector = this.querySelector('#element-panels > ' + elementInspectorName);
        if (elementInspector) {
            XOS.showElement(elementInspector);
            elementInspector.update();
        } else {
            XOS.hideElementChildren(this.querySelector('#element-panels'));
        }
    }

}

customElements.define("main-inspector-window", MainInspectorWindow);

class MainLibraryWindow extends WindowBase {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event="click:onClickOnTabBar"]'), this);
        this.style.left = document.body.offsetWidth - 180 + 'px';
    }

    onClickOnTabBar(_e) {
        //console.log('onClickOnTabBar', _e.target );
        this.showSection(_e.target.dataset.sectionTarget);
        //XOS.selectElement( _e.target );
        // const sectionTarget = this.querySelector( '.'+_e.target.dataset.sectionTarget);
        // XOS.showElement( sectionTarget );
        // sectionTarget.onShow( );
    }

    onOpen() {
        const activeSectionName = this.querySelector('.content>.tab-bar>.selected').dataset.sectionTarget;
        const sectionTarget = this.querySelector('.' + activeSectionName);
        XOS.showElement(sectionTarget);
        sectionTarget.onShow();
    }

    // showSection( _mainSectionName )
    // {
    //     const tabBarItemToSelect = this.querySelector('.tab-bar > [data-section-target="'+_mainSectionName+'"]');
    //     XOS.selectElement( tabBarItemToSelect );
    //     const sectionTarget = this.querySelector( '.'+_mainSectionName);
    //     XOS.showElement( sectionTarget );
    //     sectionTarget.onShow( );
    //     //if(tabBarItemToSelect.classList.contains('selected')) return;
    //     this.open( true );
    // }

    showSection(_mainSectionName) {
        const tabBarItemToSelect = this.querySelector('.tab-bar > [data-section-target="' + _mainSectionName + '"]');
        XOS.selectElement(tabBarItemToSelect);

        if (this.classList.contains('closed')) {
            this.open(true);
            return;
        }

        const sectionTarget = this.querySelector('.' + _mainSectionName);
        XOS.showElement(sectionTarget);
        sectionTarget.onShow();
        //if(tabBarItemToSelect.classList.contains('selected')) return;
    }

}

customElements.define("main-library-window", MainLibraryWindow);

class LayersWindow extends WindowBase {

    constructor() {
        super();
        this.controlledElements = null;
        this.layerList = this.querySelector('.layer-list');
        this.layerListItemTemplate = this.layerList.querySelector('.layer-list-item');
        this.layerList.removeChildren();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    onOpen() {
        this.update();
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        this.drawLayerList();
    }

    updateLayerSelection(_layer) {
        const activeDocument = activeApplication.activeDocument;
        //const activePageLayer = activeDocument.getActivePageLayer();
        //console.log('updateLayerSelection',_layer);
        //console.log('this.layerList',this.layerList);
        let item,
        i,
        max = this.layerList.children.length;

        for (i = 0; i < max; i++) {
            item = this.layerList.children[i];
            if (item.layerRef === _layer) {
                XOS.selectElement(item);
                return;
            }
        }
    }

    drawLayerList() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.layerList.removeChildren();

        const pageLayersChildren = activePage.content.querySelector('.layers').children;

        let item,
        layer,
        i,
        max = pageLayersChildren.length - 1;

        for (i = max; i > -1; i--) {
            layer = pageLayersChildren[i];
            item = this.layerListItemTemplate.cloneNode(true);
            item.layerRef = layer;
            this.updateLayerListItem(item);
            this.layerList.appendChild(item);
        }
    }

    updateLayerListItem(_item) {
        const layer = _item.layerRef;
        if (layer.hasAttribute('hidden'))
            _item.classList.add('invisible');
        if (layer.hasAttribute('locked'))
            _item.classList.add('locked');
        if (layer.hasAttribute('active'))
            _item.classList.add('selected');
        _item.querySelector('.label').innerHTML = layer.dataset.layerName;
        _item.querySelector('.color-state').style.backgroundColor = layer.dataset.layerColor;
    }

    isMouseHold() {
        let mouseUpTime = new Date().getTime();
        return (mouseUpTime - this.lastMouseDownTime) > 250;
    };

    onMouseDown_layerList(_e) {
        this.lastMouseDownTime = new Date().getTime();
    };

    onClick_layerList(_e) {
        let clickedElement = _e.target;
        if (clickedElement.nodeName === 'UL')
            return;
        let element_li = clickedElement.closest('li');

        const activeDocument = activeApplication.activeDocument;

        activeDocument.setActivePageLayer(element_li.layerRef);

        if (clickedElement.classList.contains('color-state')) {
            // forse si potrebbe cambiare colore al layer aprendo il color piker
        } else if (clickedElement.classList.contains('visibility-state')) {
            this.onClick_hide(element_li);
        } else if (clickedElement.classList.contains('locked-state')) {
            this.onClick_lock(element_li);
        } else if (clickedElement.classList.contains('label')) {
            // element_li.selectElement();
            XOS.selectElement(element_li);
            if (this.isMouseHold())
                this.editLayerName(element_li);
        }

    };

    editLayerName(_element_li) {
        const label_div = _element_li.querySelector('.label');

        let previousValue = label_div.textContent;

        label_div.setAttribute('contenteditable', 'true');
        label_div.focus();
        document.execCommand('selectAll', false, null);

        const self = this;

        function onBlur(_e) {
            if (label_div.textContent === "")
                label_div.textContent = 'layer';
            if (label_div.textContent !== previousValue)
                self.onEndEditLayerName(label_div);
            label_div.removeAttribute('contenteditable');
            XOS.disconnectEvent("blur", label_div, onBlur);
            XOS.disconnectEvent("keydown", label_div, onKeyDown);
        }

        function onKeyDown(_e) {
            if (_e.keyCode === 13) {
                onBlur();
                return false;
            }
        }

        XOS.connectEvent("blur", label_div, onBlur);
        XOS.connectEvent("keydown", label_div, onKeyDown);

        label_div.focus();

        const activeDocument = activeApplication.activeDocument;
        activeDocument.onChange();
    };

    onEndEditLayerName(label_div) {
        const layerRef = label_div.parentElement.layerRef;
        // layerRef.setAttribute('name' , label_div.textContent );
        layerRef.dataset.layerName = label_div.textContent;
        //return _element_input.value;
    };

    onClick_hide(_element_li) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        _element_li.classList.toggle('invisible');
        if (!_element_li.classList.contains('invisible')) {
            _element_li.layerRef.removeAttribute('hidden');
        } else {
            _element_li.layerRef.setAttribute('hidden', '');
        }

        activeDocument.deselectAll();
        activeApplication.workspace.update();
        activeDocument.onChange();
    };

    onClick_lock(_element_li) {
        const activeDocument = activeApplication.activeDocument;
        _element_li.classList.toggle('locked');
        if (!_element_li.classList.contains('locked')) {
            _element_li.layerRef.removeAttribute('locked');
        } else {
            _element_li.layerRef.setAttribute('locked', '');
        }
        // _element_li.layerRef.classList.toggle('locked');
        activeDocument.deselectAll();
        activeApplication.workspace.update();
        activeDocument.onChange();
    };

    onClick_newLayer() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxLayers = this.layerList.childNodes.length + 1;
        //const newLayer = activeDocument.createPageLayer( localString( 'Layer' ) +' '+ maxLayers , ColorUtils.rainbow( 12,  maxLayers ));
        const currentActiveLayer = activeDocument.getActivePageLayer();

        const newLayer = activeDocument.createPageLayer('Layer' + ' ' + maxLayers, ColorUtils.rainbow(12, maxLayers));
        activeDocument.addPageLayer(newLayer);
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        redoAction.createDomNodeSnapshot([newLayer], 'insert');
        undoAction.createDomNodeSnapshot([newLayer], 'delete');

        const self = this;
        undoAction.onExecuteEnd = function () {
            activeDocument.deselectAll();
            activeDocument.setActivePageLayer(currentActiveLayer);
            self.drawLayerList();
        };

        redoAction.onExecuteEnd = function () {
            activeDocument.deselectAll();
            activeDocument.setActivePageLayer(newLayer);
            self.drawLayerList();
        };

        activeDocument.onChange();
        this.drawLayerList();

    };

    onClick_removeLayer() {
        if (this.layerList.children.length === 1)
            return;

        const selectedItem = this.layerList.querySelector('.selected');
        if (!selectedItem)
            return;

        selectedItem.parentNode.removeChild(selectedItem);

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeLayer = selectedItem.layerRef;
        const layerToActivate = activeLayer.nextElementSibling || activeLayer.previousElementSibling;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot([activeLayer], 'insert');
        redoAction.createDomNodeSnapshot([activeLayer], 'delete');

        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function(){ activeDocument.deselectAll(); self.drawLayerList()};
        const currentActiveLayer = activeDocument.getActivePageLayer();
        const self = this;
        undoAction.onExecuteEnd = function () {
            activeDocument.deselectAll();
            activeDocument.setActivePageLayer(activeLayer);
            self.drawLayerList();
        };

        redoAction.onExecuteEnd = function () {
            activeDocument.deselectAll();
            activeDocument.setActivePageLayer(layerToActivate);
            self.drawLayerList();
        };

        activeLayer.parentNode.removeChild(activeLayer);

        activeDocument.setActivePageLayer(layerToActivate);

        activeDocument.onChange();
        this.drawLayerList();
    };

    onClick_bringLayerUp() {
        const selectedItem = this.layerList.querySelector('.selected');
        if (!selectedItem.previousElementSibling)
            return;
        selectedItem.sendDown();

        const activeLayer = selectedItem.layerRef;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot([activeLayer], 'insert');
        let insertBeforeTarget = null;
        if (activeLayer.nextElementSibling && activeLayer.nextElementSibling.nextElementSibling) {
            insertBeforeTarget = activeLayer.nextElementSibling.nextElementSibling;
        }
        activeLayer.parentElement.insertBefore(activeLayer, insertBeforeTarget);
        redoAction.createDomNodeSnapshot([activeLayer], 'insert');

        const self = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            self.drawLayerList()
        };
        activeDocument.onChange();

    };

    onClick_sendLayerDown() {
        const selectedItem = this.layerList.querySelector('.selected');
        if (!selectedItem.nextElementSibling)
            return;
        selectedItem.bringUp();

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeLayer = selectedItem.layerRef;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot([activeLayer], 'insert');
        let beforePreviousElement = activeLayer.previousElementSibling;
        if (beforePreviousElement) {
            activeLayer.parentElement.insertBefore(activeLayer, beforePreviousElement);
            redoAction.createDomNodeSnapshot([activeLayer], 'insert');
        }

        const self = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            self.drawLayerList()
        };
        activeDocument.onChange();

    };

    onClick_placeSelectionInActiveLayer() {
        const selectedItem = this.layerList.querySelector('.selected');
        const layerTarget = selectedItem.layerRef;
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        //const elementList = GeometryUtils.sortByDeep( activePage.selectionList );
        const elementList = activeDocument.sortElementListByLevel(activePage.selectionList);

        const max = elementList.length;
        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            layerTarget.appendChild(elementList[i]);
            redoAction.createDomNodeSnapshot([elementList[i]], 'insert');
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato
        activeApplication.workspace.update();
        activeDocument.onChange();

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList)
        };

    };

}

customElements.define("layers-window", LayersWindow);

class KeyboardEventManager extends KeyboardManager {

    constructor() {
        super();
        //this.disabled = false;
        this.pressedCharKeyDisplay = document.querySelector('#pressed-keys .char-key .key-button');
    }

    onKeyDown(_e) {

        if (!_e.keyCode)
            return;

        console.log('onKeyDown _e.keyCode', _e.keyCode);

        // F15
        if (_e.keyCode === 126) {
            activeApplication.showPressedKeys = !activeApplication.showPressedKeys
                return;
        }

        if (activeApplication.isTextEditing) {
            if (activeApplication.currentEditableTextElement.nodeName === 'text')
                activeApplication.currentEditableTextElement.onKeyDown(_e);
            return;
        }

        // if(TEXT_MANAGER.isTextEditing)
        // {
        //     TEXT_MANAGER.onInputText( _e );
        //     return;
        // }


        const focusedElement = document.activeElement;

        if (focusedElement.nodeName === 'INPUT' || focusedElement.nodeName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable'))
            return;

        // if(this.disabled)return;


        if (this.cmdKeyPressed) {
            if (this.isCommandShortcut(_e)) {
                _e.preventDefault();
                _e.stopPropagation();
                return false;
            }
            return;
        } else if (!this.spaceKeyPressed && !this.shiftKeyPressed && !this.altKeyPressed) {
            if (this.isToolShortcut(_e)) {
                _e.preventDefault();
                _e.stopPropagation();
                return false;
            }

            // non più usato
            // if( this.isPanelShortcut(_e) )
            // {
            //     _e.preventDefault();
            //     _e.stopPropagation();
            //     return false;
            // }
        }

        if (TOOLS.activeTool.onKeyDown(_e)) {
            _e.preventDefault();
            _e.stopPropagation();
            return false;
        }
    }

    onKeyUp(_e) {

        if (!_e.keyCode)
            return;

        //console.log('onKeyUp _e.keyCode',_e.keyCode);

        if (activeApplication.isTextEditing)
            return;

        // if(TEXT_MANAGER.isTextEditing)
        // {
        //     TEXT_MANAGER.onInputText( _e );
        //     return;
        // }

        const focusedElement = document.activeElement;
        if (focusedElement.nodeName === 'INPUT' || focusedElement.nodeName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable'))
            return;

        //console.log('onKeyUp');
    }

    onPaste(_e) {
        //console.log('onPaste');
        if (activeApplication.isTextEditing) {
            if (activeApplication.currentEditableTextElement.nodeName === 'text')
                activeApplication.currentEditableTextElement.onPaste(_e);
            return;
        }

        const focusedElement = document.activeElement;
        if (focusedElement.nodeName === 'INPUT' || focusedElement.nodeName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable'))
            return;

        //const text = (_e.originalEvent || _e).clipboardData.getData('text/plain');
        //console.log('onPaste', _e );
        activeApplication.activeDocument.onPaste(_e);
    }

    onCopy(_e) {
        //console.log('onCopy');
        if (activeApplication.isTextEditing) {
            if (activeApplication.currentEditableTextElement.nodeName === 'text')
                activeApplication.currentEditableTextElement.onCopy(_e);
            return;
        }

        const focusedElement = document.activeElement;
        if (focusedElement.nodeName === 'INPUT' || focusedElement.nodeName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable'))
            return;

        activeApplication.activeDocument.onCopy(_e);
    }

    onCut(_e) {
        //console.log('onCut');
        if (activeApplication.isTextEditing) {
            if (activeApplication.currentEditableTextElement.nodeName === 'text')
                activeApplication.currentEditableTextElement.onCut(_e);
            return;
        }

        const focusedElement = document.activeElement;
        if (focusedElement.nodeName === 'INPUT' || focusedElement.nodeName === 'TEXTAREA' || focusedElement.hasAttribute('contenteditable'))
            return;

        activeApplication.activeDocument.onCut(_e);
    }

    isCommandShortcut(_e) {
        let keyResult = [];

        if (this.cmdKeyPressed)
            keyResult.push('cmd-key');
        if (this.shiftKeyPressed)
            keyResult.push('shift-key');
        if (this.altKeyPressed)
            keyResult.push('alt-key');
        if (_e.keyCode !== 91 && _e.keyCode !== 16 && _e.keyCode !== 17 && _e.keyCode !== 18) {
            const keyName = this.KEY_CODE_TO_NAME[_e.keyCode];
            if (keyName) {
                keyResult.push(keyName);
                const shortcut = keyResult.join(' ');
                const command = Object.values(COMMANDS).find(item => (item.shortcut === shortcut))
                    if (command) {
                        //console.log('execute command',  command );
                        command.execute(_e);
                        return true
                    }
            }

        }
        return false;
    }

    isToolShortcut(_e) {
        const shortcut = this.KEY_CODE_TO_NAME[_e.keyCode];
        if (shortcut) {
            //console.log('_e.keyCode', _e.keyCode);
            //console.log('shortcut', shortcut);
            const tool = Object.values(TOOLS).find(item => (item.shortcut === shortcut));
            if (tool) {
                //console.log('activate tool', tool);
                activeApplication.setActiveTool(tool.name);
                return true;
            }
        }

        return false;
    }

    isPanelShortcut(_e) {
        const shortcut = this.KEY_CODE_TO_NAME[_e.keyCode];
        if (shortcut) {
            const panel = Object.values(PANELS).find(item => (item.shortcut === shortcut));
            if (panel && (!panel.classList.contains('showed'))) {
                const workspaceBounding = activeApplication.workspace.bounding;
                panel.activateAt(workspaceBounding.left + workspaceBounding.width / 2, workspaceBounding.top + 30, 'center');
                return true;
            }
        }

        return false;
    }

    updateKeysState(_e) {
        super.updateKeysState(_e);

        if (activeApplication.showPressedKeys) {
            document.documentElement.classList.add('show-pressed-keys');
            if (this.charKeyPressed) {
                const charName = this.KEY_CODE_TO_NAME[_e.keyCode];

                if (charName) {
                    document.documentElement.classList.add('char-key');
                    if (this.pressedCharKeyDisplay)
                        this.pressedCharKeyDisplay.setAttribute('data-char-key', charName);
                    return;
                }

                document.documentElement.classList.remove('char-key');
                if (this.pressedCharKeyDisplay)
                    this.pressedCharKeyDisplay.setAttribute('data-char-key', '');
            } else {
                document.documentElement.classList.remove('char-key');
                if (this.pressedCharKeyDisplay)
                    this.pressedCharKeyDisplay.setAttribute('data-char-key', '');
            }
        } else {
            document.documentElement.classList.remove('show-pressed-keys');
        }

    }

}

KEYBOARD_EVENT_MANAGER = new KeyboardEventManager();

class DragAndDropManager {
    constructor() {}

    pointerEventToCoords(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        //activeApplication.workspace.snapInteraction2D.lastEvent = _e;
        this.currentPointerEvent = _e;
    }

    reset(_e) {
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    }

    onDragOver(_e) {
        this.pointerEventToCoords(_e);
    };

    onDropOver(_e) {
        this.reset();

        const transferData = XOS.getTransferData();

        if (transferData) {
            this.onDropTransferData(transferData);
            XOS.setTransferData(null);
            return;
        }

        const urlStr = _e.dataTransfer.getData('url');

        if (urlStr) {
            activeApplication.activeDocument.placeImage_undable(urlStr)
        } else if (_e.dataTransfer.types === 'text/html,text/uri-list,url') {}
        else if (_e.dataTransfer.types === 'text,text/plain') {}
        else if (_e.dataTransfer.files.length > 0) {
            this.onDropFiles(_e);
        }
    }

    onDropTransferData(_transferData) {
        if (_transferData.type === 'svg-symbol') {
            this.onDropSymbol(_transferData);
        } else if (_transferData.type === 'svg-symbol-as-shape') {
            this.onDropSymbolAsShape(_transferData);
        } else if (_transferData.type === 'svg-symbol-as-widget') {
            this.onDropSymbolAsWidget(_transferData);
        } else if (_transferData.type === 'svg-color') {
            this.onDropColor(_transferData);
        } else if (_transferData.type === 'svg-gradient') {
            this.onDropGradient(_transferData);
        } else if (_transferData.type === 'svg-pattern') {
            this.onDropPattern(_transferData);
        } else if (_transferData.type === 'svg-filter') {
            this.onDropFilter(_transferData);
        }

    }

    onDropFiles(_e) {
        const files = _e.dataTransfer.files;

        if (files.length > 0) {
            let fileHandle;
            for (let i = 0; i < files.length; i++) {
                fileHandle = files[i];
                const splittedFileName = fileHandle.name.split('.');
                const fileType = splittedFileName[splittedFileName.length - 1].toLowerCase();

                if (fileType === 'svg' || fileType === 'htm' || fileType === 'html') {
                    this.onDropFile_SVG(fileHandle);
                } else if ((fileType === 'jpg') || (fileType === 'jpeg') || (fileType === 'png') || (fileType === 'gif')) {
                    this.onDropFile_IMAGE(fileHandle);
                } else if (fileType === 'dxf') {
                    //this.onDropFile_DXF(fileHandle);
                } else {
                    DIALOGS['alert-dialog'].open(localString('Unsupported file type:' + fileType), localString('You can drop only "svg", "jpg", "png" file types.'));
                }
            }
        }
    }

    onDropFile_SVG(_file) {
        LOCAL_FILE_SYSTEM.readXMLFile(_file, function (_xmlDocument) {
            activeApplication.documentsManager.unserializeDocument(_xmlDocument, {
                import: true,
                centerInView: true
            });
        });
    }

    onDropFile_IMAGE(_file) {
        LOCAL_FILE_SYSTEM.readImageFileAsDataUrl(_file, function (_dataURL) {
            activeApplication.activeDocument.placeImage_undable(_dataURL);
        });
    }

    onDropColor(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (!this.currentPointerEvent.elementAtPoint)
            return;

        let activeGraphicSide;
        if (this.currentPointerEvent.segmentSnap) {
            activeGraphicSide = 'stroke';
        } else {
            activeGraphicSide = 'fill';
        }

        activeDocument.fillAndStrokeManager.focusedGraphicSideName = activeGraphicSide;

        //activeApplication.setActiveGraphicSide( activeGraphicSide );

        const propertyObject = {};
        propertyObject[activeGraphicSide] = _transferData.colorValue;
        activeDocument.setAttributeElementList_undable([this.currentPointerEvent.elementAtPoint], propertyObject);
        //this.showSelectionProperties();

    }

    onDropGradient(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (!this.currentPointerEvent.elementAtPoint)
            return;

        let activeGraphicSide;
        if (this.currentPointerEvent.segmentSnap) {
            activeGraphicSide = 'stroke';
        } else {
            activeGraphicSide = 'fill';
        }

        activeDocument.fillAndStrokeManager.focusedGraphicSideName = activeGraphicSide;

        const gradientID = _transferData.gradient.getAttribute('id');
        let gradient = activeApplication.activeDocument.resources.getResourceById(gradientID);
        if (!gradient) {
            gradient = _transferData.gradient.cloneNode(true);
            activeApplication.activeDocument.resources.addResource(gradient);
        }

        const propertyObject = {};
        propertyObject[activeGraphicSide] = 'url(#' + gradientID + ')';
        propertyObject[activeGraphicSide + '-opacity'] = '1';
        activeDocument.setAttributeElementList_undable([this.currentPointerEvent.elementAtPoint], propertyObject);
        //this.showSelectionProperties();
    }

    onDropPattern(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (!this.currentPointerEvent.elementAtPoint)
            return;

        let activeGraphicSide;
        if (this.currentPointerEvent.segmentSnap) {
            activeGraphicSide = 'stroke';
        } else {
            activeGraphicSide = 'fill';
        }

        activeDocument.fillAndStrokeManager.focusedGraphicSideName = activeGraphicSide;

        const gradientID = _transferData.pattern.getAttribute('id');
        let gradient = activeApplication.activeDocument.resources.getResourceById(gradientID);
        if (!gradient) {
            gradient = _transferData.pattern.cloneNode(true);
            activeApplication.activeDocument.resources.addResource(gradient);
        }

        const patternID = _transferData.pattern.getAttribute('id');
        let pattern = activeApplication.activeDocument.resources.getResourceById(patternID);
        if (!pattern) {
            pattern = _transferData.pattern.cloneNode(true);
            activeApplication.activeDocument.resources.addResource(pattern);
        }

        const propertyObject = {};
        propertyObject[activeGraphicSide] = 'url(#' + patternID + ')';
        propertyObject[activeGraphicSide + '-opacity'] = '1';
        activeDocument.setAttributeElementList_undable([this.currentPointerEvent.elementAtPoint], propertyObject);
        //this.showSelectionProperties();
    }

    onDropSymbol(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        const symbolID = _transferData.symbol.getAttribute('id');
        let symbol = activeApplication.activeDocument.resources.getResourceById(symbolID);
        if (!symbol) {
            symbol = _transferData.symbol.cloneNode(true);
            activeApplication.activeDocument.resources.addResource(symbol);
        }
        const useElement = SVGUtils.createUse(symbolID);
        activeDocument.getActivePageLayer().appendChild(useElement);
        useElement.placeAt(this.currentPointerEvent.contentX, this.currentPointerEvent.contentY);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([useElement])
        };

        redoAction.createDomNodeSnapshot([useElement], 'insert');
        undoAction.createDomNodeSnapshot([useElement], 'delete');

        activeDocument.onChange();

        // seleziono l'elemento inserito
        activeDocument.selectElementList([useElement]);
        activeApplication.workspace.update();
        // this.setActiveEditableElement(useElement);
        // this.updateInteraction();
    }

    onDropSymbolAsShape(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        let newElement;
        if (_transferData.symbol.children.length === 1) {
            newElement = _transferData.symbol.children[0].cloneNode(true);
            newElement.getTransform().setMatrix(newElement.getTransform().matrix.translate(this.currentPointerEvent.contentX, this.currentPointerEvent.contentY));
        } else {
            newElement = SVGUtils.createGroup(this.currentPointerEvent.contentX, this.currentPointerEvent.contentY);
            for (let i = 0; i < _transferData.symbol.children.length; i++)
                newElement.appendChild(_transferData.symbol.children[i].cloneNode(true));
        }

        activeDocument.getActivePageLayer().appendChild(newElement);
        newElement.resetOrigin();

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([newElement])
        };

        redoAction.createDomNodeSnapshot([newElement], 'insert');
        undoAction.createDomNodeSnapshot([newElement], 'delete');

        activeDocument.onChange();

        // seleziono l'elemento inserito
        activeDocument.selectElementList([newElement]);
        activeApplication.workspace.update();
    }

    onDropSymbolAsWidget(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        const newElement = SVGUtils.createForeignObjectWidget(this.currentPointerEvent.contentX, this.currentPointerEvent.contentY, 320, 240, _transferData.symbol.dataset.defaultUrl);

        activeDocument.getActivePageLayer().appendChild(newElement);
        newElement.resetOrigin();

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        const self = this;
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([newElement])
        };

        redoAction.createDomNodeSnapshot([newElement], 'insert');
        undoAction.createDomNodeSnapshot([newElement], 'delete');

        activeDocument.onChange();

        activeDocument.selectElementList([newElement]);
        activeApplication.workspace.update();
    }

    onDropFilter(_transferData) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (!this.currentPointerEvent.elementAtPoint)
            return;

        const filterID = _transferData.filter.getAttribute('id');
        let filter = activeApplication.activeDocument.resources.getResourceById(filterID);
        if (!filter) {
            filter = _transferData.filter.cloneNode(true);
            activeApplication.activeDocument.resources.addResource(filter);
        }

        const propertyObject = {};
        propertyObject['filter'] = 'url(#' + filterID + ')';
        activeDocument.setAttributeElementList_undable([this.currentPointerEvent.elementAtPoint], propertyObject);
        activeDocument.showSelectionProperties();
    }

}

DRAG_AND_DROP_MANAGER = new DragAndDropManager();

class FillAndStrokeManager {

    constructor(_document2D) {
        this.reset();
        this.applicationDef = document.querySelector('#APPLICATION_DEFS');
        this.fillGradientDef = this.applicationDef.querySelector('#FILL_GRADIENT');
        this.strokeGradientDef = this.applicationDef.querySelector('#STROKE_GRADIENT');
        this.fillPatternDef = this.applicationDef.querySelector('#FILL_PATTERN');
        this.strokePatternDef = this.applicationDef.querySelector('#STROKE_PATTERN');
        this.focusedGraphicSideName = 'fill';
        //this.focusedGraphicSideName = this.activeGraphicSide='fill';
        this.fillFillingDisplayList = document.querySelectorAll('.fill-filling-display');
        this.strokeFillingDisplayList = document.querySelectorAll('.stroke-filling-display');
    }

    reset() {
        this.fill = '#FFFFFF';
        this.stroke = '#000000';
        this.fillFillingType = 'color';
        this.strokeFillingType = 'color';
        this.nonScalingStroke = false;

        this['fill-opacity'] = '1';
        this['stroke-opacity'] = '1';
        this['stroke-width'] = '1';
        this['stroke-linecap'] = 'butt';
        this['stroke-linejoin'] = 'miter';

        // this['fill-opacity']='1';
        // this.stroke='#000000';
        //this['stroke-opacity']='1';
        // this['stroke-width']='1';
        // this['stroke-linecap'] = 'butt';
        // this['stroke-linejoin'] = 'miter';
    }

    update_strokeDisplay() {
        let strokeFilling = this.stroke;
        if (this.strokeFillingType === 'radialGradient' || this.strokeFillingType === 'linearGradient') {
            strokeFilling = 'url(#STROKE_GRADIENT)';
        } else if (this.strokeFillingType === 'pattern') {
            strokeFilling = 'url(#STROKE_PATTERN)';
        }
        const max = this.strokeFillingDisplayList.length;
        for (let i = 0; i < max; i++) {
            this.strokeFillingDisplayList[i].setAttribute('fill', strokeFilling);
            if (this.focusedGraphicSideName === 'stroke')
                XOS.selectElement(this.strokeFillingDisplayList[i].closest('[data-graphic-side="stroke"]'));
        }
    }

    update_fillDisplay() {
        let fillFilling = this.fill;
        if (this.fillFillingType === 'radialGradient' || this.fillFillingType === 'linearGradient') {
            fillFilling = 'url(#FILL_GRADIENT)';
        } else if (this.fillFillingType === 'pattern') {
            fillFilling = 'url(#FILL_PATTERN)';
        }
        const max = this.fillFillingDisplayList.length;
        for (let i = 0; i < max; i++) {
            this.fillFillingDisplayList[i].setAttribute('fill', fillFilling);
            if (this.focusedGraphicSideName === 'fill')
                XOS.selectElement(this.fillFillingDisplayList[i].closest('[data-graphic-side="fill"]'));
        }
    }

    set_stroke(_element) {
        if (!_element)
            return;

        const activeDocument = activeApplication.activeDocument;

        if (_element instanceof SVGElement) {
            if (_element.nodeName === 'image')
                return;
            this.stroke = _element.getAttribute('stroke') || '#000000';
            this['stroke-opacity'] = _element.getAttribute('stroke-opacity') || '1';
            this['stroke-width'] = _element.getAttribute('stroke-width') || '1';
            this['stroke-linecap'] = _element.getAttribute('stroke-linecap') || 'butt';
            this['stroke-linejoin'] = _element.getAttribute('stroke-linejoin') || 'miter';
            this.nonScalingStroke = _element.getAttribute('vector-effect') === 'non-scaling-stroke';
        } else // quando sono proprietà
        {
            this.stroke = _element['stroke'] || this.stroke;
            this['stroke-opacity'] = _element['stroke-opacity'] || this['stroke-opacity'];
            this['stroke-width'] = _element['stroke-width'] || this['stroke-width'];
            this['stroke-linecap'] = _element['stroke-linecap'] || this['stroke-linecap'];
            this['stroke-linejoin'] = _element['stroke-linejoin'] || this['stroke-linejoin'];
            //this.nonScalingStroke =  _element['vector-effect'] === 'non-scaling-stroke';
        }

        if (this.stroke === 'none') {
            this.strokeFillingType = 'none';
        } else if (this.stroke.indexOf('url') > -1) {
            const defElement = activeDocument.resources.getResourceByIRI(this.stroke);

            if (defElement.nodeName === 'radialGradient' || defElement.nodeName === 'linearGradient') {
                this.strokeFillingType = defElement.nodeName;
                this.strokeGradient = defElement;
                this.strokeGradient.copyStopColorsTo(this.strokeGradientDef);
                this.strokeGradientDef.original = this.strokeGradient;
            } else if (defElement.nodeName === 'pattern') {
                // non si sa perchè sono costretto a prendere sempre il riferimento in questo modo
                // va in errore quando cambio documento
                this.strokePatternDef = this.applicationDef.querySelector('#STROKE_PATTERN');

                this.strokeFillingType = defElement.nodeName;
                this.strokePattern = defElement;

                const clonedPattern = this.strokePattern.cloneNode(true);
                this.strokePatternDef.parentElement.replaceChild(clonedPattern, this.strokePatternDef);
                this.strokePatternDef = clonedPattern;
                this.strokePatternDef.setAttribute('id', 'STROKE_PATTERN');
                this.strokePatternDef.original = this.strokePattern;
            }
        } else {
            this.strokeFillingType = 'color';
        }
        this.update_strokeDisplay();
    }

    set_fill(_element) {
        if (!_element)
            return;

        const activeDocument = activeApplication.activeDocument;

        if (_element instanceof SVGElement) {
            if (_element.nodeName === 'image')
                return;
            this.fill = _element.getAttribute('fill') || '#FFFFFF';
            this['fill-opacity'] = _element.getAttribute('fill-opacity') || '1';
        } else // quando è una proprietà
        {
            this.fill = _element['fill'] || this.fill;
            this['fill-opacity'] = _element['fill-opacity'] || this['fill-opacity'];
        }

        if (this.fill === 'none') {
            this.fillFillingType = 'none';
        } else if (this.fill.indexOf('url') > -1) {
            const defElement = activeDocument.resources.getResourceByIRI(this.fill);
            if (!defElement)
                return;

            if (defElement.nodeName === 'radialGradient' || defElement.nodeName === 'linearGradient') {
                this.fillFillingType = defElement.nodeName;
                this.fillGradient = defElement;
                this.fillGradient.copyStopColorsTo(this.fillGradientDef);
                this.fillGradientDef.original = this.fillGradient;
            } else if (defElement.nodeName === 'pattern') {
                // non si sa perchè sono costretto a prendere sempre il riferimento in questo modo
                // va in errore quando cambio documento
                this.fillPatternDef = this.applicationDef.querySelector('#FILL_PATTERN');
                this.fillFillingType = defElement.nodeName;
                this.fillPattern = defElement;
                const clonedPattern = this.fillPattern.cloneNode(true);
                this.fillPatternDef.parentElement.replaceChild(clonedPattern, this.fillPatternDef);
                this.fillPatternDef = clonedPattern;
                this.fillPatternDef.setAttribute('id', 'FILL_PATTERN');
                this.fillPatternDef.original = this.fillPattern;
            }
        } else {
            this.fillFillingType = 'color';
        }
        this.update_fillDisplay();
    }

    //
    // set_stroke( _element )
    // {
    //     const activeDocument = activeApplication.activeDocument;
    //     const activePage = activeDocument.activePage;
    //     _element = _element || activePage.focusedElement;
    //
    //     if(!_element) return;
    //     if(_element.nodeName==='image'  ) return;
    //
    //     let stroke = _element.getAttribute('stroke') || 'none';
    //     this.stroke=stroke;
    //     this['stroke-opacity'] = _element.getAttribute('stroke-opacity') || '1';
    //     this['stroke-width'] = _element.getAttribute('stroke-width') || '1';
    //     this['stroke-linecap'] = _element.getAttribute('stroke-linecap') || 'butt';
    //     this['stroke-linejoin'] = _element.getAttribute('stroke-linejoin') || 'miter';
    //     this.nonScalingStroke =  _element.getAttribute('vector-effect') === 'non-scaling-stroke';
    //
    //     if (stroke === 'none')
    //     {
    //         this.strokeFillingType = 'none';
    //     }
    //     else if (stroke.indexOf('url') > -1)
    //     {
    //         const defElement = activeDocument.resources.getResourceByIRI(stroke);
    //
    //         if( defElement.nodeName === 'radialGradient' || defElement.nodeName === 'linearGradient' )
    //         {
    //             this.strokeFillingType = defElement.nodeName;
    //             this.strokeGradient = defElement;
    //             this.strokeGradient.copyStopColorsTo( this.strokeGradientDef );
    //             this.strokeGradientDef.original =  this.strokeGradient;
    //         }
    //         else if( defElement.nodeName === 'pattern' )
    //         {
    //             this.strokeFillingType = defElement.nodeName;
    //             this.strokePattern = defElement;
    //
    //             const clonedPattern = this.strokePattern.cloneNode(true);
    //             this.strokePatternDef.parentElement.replaceChild( clonedPattern ,  this.strokePatternDef );
    //             this.strokePatternDef = clonedPattern;
    //             this.strokePatternDef.setAttribute('id','STROKE_PATTERN');
    //             this.strokePatternDef.original = this.strokePattern;
    //         }
    //     }
    //     else
    //     {
    //         this.strokeFillingType = 'color';
    //     }
    //     this.update_strokeDisplay();
    // }
    //
    //
    // set_fill( _element )
    // {
    //     const activeDocument = activeApplication.activeDocument;
    //     const activePage = activeDocument.activePage;
    //     _element = _element || activePage.focusedElement;
    //
    //     if(!_element) return;
    //
    //     if(_element.nodeName==='image') return;
    //
    //     let fill = _element.getAttribute('fill') || '#000000';
    //     this.fill=fill;
    //     this['fill-opacity']=_element.getAttribute('fill-opacity') || '1';
    //
    //     if (fill === 'none')
    //     {
    //         this.fillFillingType = 'none';
    //     }
    //     else if (fill.indexOf('url') > -1)
    //     {
    //         const defElement = activeApplication.activeDocument.resources.getResourceByIRI(fill);
    //         if(!defElement) return;
    //
    //         if( defElement.nodeName === 'radialGradient' || defElement.nodeName === 'linearGradient' )
    //         {
    //             this.fillFillingType = defElement.nodeName;
    //             this.fillGradient =  defElement;
    //             this.fillGradient.copyStopColorsTo( this.fillGradientDef );
    //             this.fillGradientDef.original =  this.fillGradient;
    //         }
    //         else if( defElement.nodeName === 'pattern' )
    //         {
    //             this.fillFillingType = defElement.nodeName;
    //             this.fillPattern =  defElement;
    //
    //             const clonedPattern = this.fillPattern.cloneNode(true);
    //             this.fillPatternDef.parentElement.replaceChild( clonedPattern ,  this.fillPatternDef );
    //             this.fillPatternDef = clonedPattern;
    //             this.fillPatternDef.setAttribute('id','FILL_PATTERN');
    //             this.fillPatternDef.original = this.fillPattern;
    //
    //         }
    //     }
    //     else
    //     {
    //         this.fillFillingType = 'color';
    //     }
    //     this.update_fillDisplay();
    // }


    apply_stroke(_element) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        _element.setAttribute('stroke-width', this['stroke-width']);
        if (this['stroke-opacity'] < 1)
            _element.setAttribute('stroke-opacity', this['stroke-opacity']);
        if (this.nonScalingStroke)
            _element.setAttribute('vector-effect', 'non-scaling-stroke');
        if (this['stroke-linecap'] !== 'butt')
            _element.setAttribute('stroke-linecap', this['stroke-linecap']);
        if (this['stroke-linejoin'] !== 'miter')
            _element.setAttribute('stroke-linejoin', this['stroke-linejoin']);

        let stroke = this.stroke;

        let defElement = null;

        if (this.strokeFillingType === 'radialGradient' || this.strokeFillingType === 'linearGradient') {
            defElement = this.strokeGradient;
        } else if (this.strokeFillingType === 'pattern') {
            defElement = this.strokePattern;
        }

        if (defElement) {
            const newDefElement = defElement.cloneNode(true);
            const idNewResource = activeDocument.resources.createResourceIdFromExistentId(newDefElement.getAttribute('id'));
            activeDocument.resources.addResource(newDefElement, idNewResource);
            stroke = 'url(#' + idNewResource + ')';
        }

        _element.setAttribute('stroke', stroke);

    }

    apply_fill(_element) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let fill = this.fill;

        if (this['fill-opacity'] < 1)
            _element.setAttribute('fill-opacity', this['fill-opacity']);

        let defElement = null;

        if (this.fillFillingType === 'radialGradient' || this.fillFillingType === 'linearGradient') {
            defElement = this.fillGradient;
        } else if (this.fillFillingType === 'pattern') {
            defElement = this.fillPattern;
        }

        if (defElement) {
            const newDefElement = defElement.cloneNode(true);
            const idNewResource = activeDocument.resources.createResourceIdFromExistentId(newDefElement.getAttribute('id'));
            activeDocument.resources.addResource(newDefElement, idNewResource);
            fill = 'url(#' + idNewResource + ')';
        }

        _element.setAttribute('fill', fill);

    }

}

class BaseCommand_cmd {

    constructor(_shortcut = '') {
        //( attenzione la sequenza deve essere rispettata )
        // "cmd-key H"
        // "cmd-key shift-key H"
        // "cmd-key shift-key alt-key H"
        this.shortcut = _shortcut;
    }

    execute(_e) {
        this.onBeforeExecute(_e);
        this.onExecute(_e);
        this.onAfterExecute(_e);
    }

    onBeforeExecute(_e) {}

    onExecute(_e) {}

    onAfterExecute(_e) {}

}

// questo probabilmente è da eliminare, serve solo ad aprire il dialogo about
class ShowDialog_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const dialog = document.querySelector('#' + _e.target.dataset.value);
        if (dialog)
            XOS.showElement(dialog);
    }
}

COMMANDS.showDialog = new ShowDialog_cmd();

class ActivatePopUpPanel_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const buttonTarget = _e.target;
        const panelToActivate = PANELS[buttonTarget.dataset.panelTarget];
        const horizontalPlacement = buttonTarget.dataset.horizontalPlacement;
        const verticalPlacement = buttonTarget.dataset.verticalPlacement;
        panelToActivate.activateBy(buttonTarget, undefined, undefined, horizontalPlacement, verticalPlacement);
    }
}

COMMANDS.activePopUpPanel = new ActivatePopUpPanel_cmd();

class OpenWindow_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const buttonTarget = _e.target;
        const windowToOpen = WINDOWS[buttonTarget.dataset.windowTarget];
        windowToOpen.open(true);
    }
}

COMMANDS.openWindow = new OpenWindow_cmd();

class Undo_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        activeDocument.deselectAll();
        activeDocument.activePage.history.undo();
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.undo = new Undo_cmd('cmd-key Z');

class Redo_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        activeDocument.deselectAll();
        activeDocument.activePage.history.redo();
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.redo = new Redo_cmd('cmd-key shift-key Z');

class Duplicate_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
        this.lastTransformAction = null;
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction('duplicate');
        const redoAction = new UndoRedoAction('duplicate');
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const elementListToDuplicate = activePage.selectionList;

        activeDocument.deselectAll();

        const newElementList = [];
        const max = elementListToDuplicate.length;
        for (let i = 0; i < max; i++) {
            let clonedElement = elementListToDuplicate[i].cloneNode(true);
            newElementList.push(clonedElement);
            elementListToDuplicate[i].parentElement.insertBefore(clonedElement, elementListToDuplicate[i].nextElementSibling);
        }

        if (_e)
            this.applyTransformAction(newElementList);
        //if(this.lastTransformAction)  this.applyTransformAction( newElementList );

        redoAction.createDomNodeSnapshot(newElementList, 'insert');
        undoAction.createDomNodeSnapshot(newElementList, 'delete');

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementListToDuplicate);
            // activeApplication.workspace.update();
        };

        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(newElementList);
            // activeApplication.workspace.update();
        };

        activeDocument.selectElementList(newElementList);
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

    applyTransformAction(_elementList) {
        if (this.lastTransformAction)
            this.lastTransformAction(_elementList);
    };

}

COMMANDS.duplicate = new Duplicate_cmd('cmd-key D');

class BringToFront_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        //const elementList = GeometryUtils.sortByDeep( activePage.selectionList );
        const elementList = activeDocument.sortElementListByLevel(activePage.selectionList);

        const max = elementList.length;
        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            elementList[i].parentElement.appendChild(elementList[i]);
            redoAction.createDomNodeSnapshot([elementList[i]], 'insert');
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.bringToFront = new BringToFront_cmd('cmd-key F');

class BringUp_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        //const elementList = GeometryUtils.sortByDeep( activePage.selectionList ).reverse();
        const elementList = activeDocument.sortElementListByLevel(activePage.selectionList).reverse();
        const max = elementList.length;
        let insertBeforeTarget = null;

        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            insertBeforeTarget = null;
            if (elementList[i].nextElementSibling && elementList[i].nextElementSibling.nextElementSibling) {
                insertBeforeTarget = elementList[i].nextElementSibling.nextElementSibling;
            }
            elementList[i].parentElement.insertBefore(elementList[i], insertBeforeTarget);
            redoAction.createDomNodeSnapshot([elementList[i]], 'insert');
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.bringUp = new BringUp_cmd('cmd-key alt-key F');

class SendDown_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        //const elementList = GeometryUtils.sortByDeep( activePage.selectionList );
        const elementList = activeDocument.sortElementListByLevel(activePage.selectionList);
        const max = elementList.length;
        //let insertBeforeTarget = elementList[0].previousElementSibling;

        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            let beforePreviousElement = elementList[i].previousElementSibling;
            if (beforePreviousElement) {
                elementList[i].parentElement.insertBefore(elementList[i], beforePreviousElement);
                redoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            }
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();

    }

}

COMMANDS.sendDown = new SendDown_cmd('cmd-key alt-key B');

class SendToBack_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        //const elementList = GeometryUtils.sortByDeep( activePage.selectionList );
        const elementList = activeDocument.sortElementListByLevel(activePage.selectionList);
        elementList.reverse();

        const max = elementList.length;
        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([elementList[i]], 'insert');
            elementList[i].parentElement.insertBefore(elementList[i], elementList[i].parentElement.firstElementChild);
            redoAction.createDomNodeSnapshot([elementList[i]], 'insert');
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();

    }
}

COMMANDS.sendToBack = new SendToBack_cmd('cmd-key B');

class Reflect_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const elementListToReflect = activePage.selectionList;
        const bbox = GeometryUtils.getElementListGlobalBBox(elementListToReflect);

        // const undoAction = new UndoRedoAction();
        // const redoAction = new UndoRedoAction();
        // activePage.history.addUndoRedoActions( undoAction , redoAction );
        //
        // undoAction.createAttributeSnapshot( elementListToReflect , 'transform' );

        let endScaleX = 1,
        endScaleY = 1;

        switch (_e.target.dataset.value) {
        case 'horizontally':
            endScaleX = -1;
            break;
        case 'vertically':
            endScaleY = -1;
            break;
        }

        activeDocument.scaleElementList_undable(elementListToReflect, endScaleX, endScaleY, bbox.center, false);

        // activeDocument.scaleElementList (  elementListToReflect , endScaleX ,  endScaleY , bbox.center , false   );
        // redoAction.createAttributeSnapshot( elementListToReflect , 'transform' );
        //
        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function() { activeDocument.selectElementList(elementListToReflect);};
        //
        // activeApplication.workspace.update();
        // activeDocument.onChange();
    }

}

COMMANDS.reflect = new Reflect_cmd();

COMMANDS.reflectHorizontally = {
    shortcut: 'cmd-key alt-key H',
    execute: function (_e) {
        COMMANDS.reflect.execute({
            target: {
                dataset: {
                    value: 'horizontally'
                }
            }
        })
    }
};
COMMANDS.reflectVertically = {
    shortcut: 'cmd-key alt-key V',
    execute: function (_e) {
        COMMANDS.reflect.execute({
            target: {
                dataset: {
                    value: 'vertically'
                }
            }
        })
    }
};

class RotateByStep_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const elementListToRotate = activePage.selectionList;
        const rotationValue = _e.target.dataset.value || 90;
        const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName('center-center', GeometryUtils.getElementListGlobalBBox(elementListToRotate));

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(elementListToRotate, 'transform');

        activeDocument.rotateElementList(elementListToRotate, rotationValue, bboxPivotPosition);

        redoAction.createAttributeSnapshot(elementListToRotate, 'transform');

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementListToRotate);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.rotateByStep = new RotateByStep_cmd();

COMMANDS.rotate90 = {
    shortcut: 'cmd-key alt-key R',
    execute: function (_e) {
        COMMANDS.rotateByStep.execute({
            target: {
                dataset: {
                    value: 90
                }
            }
        })
    }
};
COMMANDS.rotateMinus90 = {
    shortcut: 'cmd-key shift-key alt-key R',
    execute: function (_e) {
        COMMANDS.rotateByStep.execute({
            target: {
                dataset: {
                    value: -90
                }
            }
        })
    }
};

class Align_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let bboxTarget;

        if (activePage.selectionList.length === 1) {
            //bboxTarget = activePage.querySelector('.content>.background-layers>.printable-area ').getGlobalBBox();
            bboxTarget = activeApplication.workspace.pageBackground.getGlobalBBox();
        } else if (activePage.selectionList.length > 1) {
            bboxTarget = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
        } else {
            return null;
        }

        const elementListToAlign = activePage.selectionList;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(elementListToAlign, 'transform');

        let element,
        bboxSource;

        const max = elementListToAlign.length;

        for (let id = 0; id < max; id++) {
            element = elementListToAlign[id];

            bboxSource = element.getGlobalBBox();

            switch (_e.target.dataset.value) {
            case 'alignLeft':
                element.translateInGlobal(bboxTarget.min.x - bboxSource.min.x, 0);
                break;
            case 'alignVCenter':
                element.translateInGlobal(bboxTarget.center.x - bboxSource.center.x, 0);
                break;
            case 'alignRight':
                element.translateInGlobal(bboxTarget.max.x - bboxSource.max.x, 0);
                break;
            case 'alignTop':
                element.translateInGlobal(0, bboxTarget.min.y - bboxSource.min.y);
                break;
            case 'alignHCenter':
                element.translateInGlobal(0, bboxTarget.center.y - bboxSource.center.y);
                break;
            case 'alignBottom':
                element.translateInGlobal(0, bboxTarget.max.y - bboxSource.max.y);
                break;
            }

        }

        redoAction.createAttributeSnapshot(elementListToAlign, 'transform');

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementListToAlign);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.align = new Align_cmd();

COMMANDS.alignLeft = {
    shortcut: 'cmd-key alt-key ONE',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignLeft'
                }
            }
        })
    }
};
COMMANDS.alignVCenter = {
    shortcut: 'cmd-key alt-key TWO',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignVCenter'
                }
            }
        })
    }
};
COMMANDS.alignRight = {
    shortcut: 'cmd-key alt-key THREE',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignRight'
                }
            }
        })
    }
};
COMMANDS.alignTop = {
    shortcut: 'cmd-key alt-key FOUR',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignTop'
                }
            }
        })
    }
};
COMMANDS.alignHCenter = {
    shortcut: 'cmd-key alt-key FIVE',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignHCenter'
                }
            }
        })
    }
};
COMMANDS.alignBottom = {
    shortcut: 'cmd-key alt-key SIX',
    execute: function (_e) {
        COMMANDS.align.execute({
            target: {
                dataset: {
                    value: 'alignBottom'
                }
            }
        })
    }
};

class Distribuite_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length < 3)
            return;

        const bboxTarget = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);

        const elementList = activePage.selectionList;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(elementList, 'transform');

        const max = elementList.length;
        let stepX,
        stepY;
        let rightObjBounds,
        leftObjBounds,
        topObjBounds,
        bottomObjBounds;

        switch (_e.target.dataset.value) {

        case 'distribuiteCenterX':
            // ordino per posizione x
            elementList.sort(function (a, b) {
                return a.getGlobalBBox().min.x - b.getGlobalBBox().min.x
            });
            leftObjBounds = elementList[0].getGlobalBBox();
            rightObjBounds = elementList[max - 1].getGlobalBBox();
            bboxTarget.min.x = leftObjBounds.center.x;
            bboxTarget.max.x = rightObjBounds.center.x;
            stepX = bboxTarget.width / (max - 1);
            break;

        case 'distribuiteCenterY':
            // ordino per posizione y
            elementList.sort(function (a, b) {
                return a.getGlobalBBox().min.y - b.getGlobalBBox().min.y
            });
            topObjBounds = elementList[0].getGlobalBBox();
            bottomObjBounds = elementList[max - 1].getGlobalBBox();
            bboxTarget.min.y = topObjBounds.center.y;
            bboxTarget.max.y = bottomObjBounds.center.y;
            bboxTarget.height = bboxTarget.max.y - bboxTarget.min.y;
            stepY = bboxTarget.height / (max - 1);
            break;

        case 'distribuiteHSpace':
            // ordino per posizione x
            elementList.sort(function (a, b) {
                return a.getGlobalBBox().min.x - b.getGlobalBBox().min.x
            });

            let allObjWidth = 0;
            for (let id = 0; id < max; id++)
                allObjWidth += elementList[id].getGlobalBBox().width;

            stepX = (bboxTarget.width - allObjWidth) / (max - 1);

            leftObjBounds = elementList[0].getGlobalBBox();
            rightObjBounds = elementList[max - 1].getGlobalBBox();
            bboxTarget.min.x = leftObjBounds.max.x;
            bboxTarget.max.x = rightObjBounds.min.x;
            break;

        case 'distribuiteVSpace':
            // ordino per posizione y
            elementList.sort(function (a, b) {
                return a.getGlobalBBox().min.y - b.getGlobalBBox().min.y
            });

            let allObjHeight = 0;
            for (let id = 0; id < max; id++)
                allObjHeight += elementList[id].getGlobalBBox().height;

            stepY = (bboxTarget.height - allObjHeight) / (max - 1);

            topObjBounds = elementList[0].getGlobalBBox();
            bottomObjBounds = elementList[max - 1].getGlobalBBox();
            bboxTarget.min.y = topObjBounds.max.y;
            bboxTarget.max.y = bottomObjBounds.min.y;
            break;
        }

        let element,
        elementBBox;

        for (let id = 1; id < (max - 1); id++) {
            element = elementList[id];
            elementBBox = element.getGlobalBBox();

            switch (_e.target.dataset.value) {
            case 'distribuiteCenterX':
                element.translateInGlobal((bboxTarget.min.x + stepX - (elementBBox.width / 2)) - elementBBox.min.x, 0);
                stepX += stepX;
                break;

            case 'distribuiteCenterY':
                element.translateInGlobal(0, (bboxTarget.min.y + stepY - (elementBBox.height / 2)) - elementBBox.min.y);
                stepY += stepY;
                break;
            case 'distribuiteHSpace':
                element.translateInGlobal((bboxTarget.min.x + stepX) - elementBBox.min.x, 0);
                bboxTarget.min.x = bboxTarget.min.x + stepX + elementBBox.width;
                break;
            case 'distribuiteVSpace':
                element.translateInGlobal(0, (bboxTarget.min.y + stepY) - elementBBox.min.y);
                bboxTarget.min.y = bboxTarget.min.y + stepY + elementBBox.height;
                break;
            }
        }

        redoAction.createAttributeSnapshot(elementList, 'transform');

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementList);
        };

        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.distribuite = new Distribuite_cmd();

COMMANDS.distribuiteHSpace = {
    shortcut: 'cmd-key alt-key SEVEN',
    execute: function (_e) {
        COMMANDS.distribuite.execute({
            target: {
                dataset: {
                    value: 'distribuiteHSpace'
                }
            }
        })
    }
};
COMMANDS.distribuiteVSpace = {
    shortcut: 'cmd-key alt-key EIGHT',
    execute: function (_e) {
        COMMANDS.distribuite.execute({
            target: {
                dataset: {
                    value: 'distribuiteVSpace'
                }
            }
        })
    }
};
COMMANDS.distribuiteCenterX = {
    shortcut: '',
    execute: function (_e) {
        COMMANDS.distribuite.execute({
            target: {
                dataset: {
                    value: 'distribuiteCenterX'
                }
            }
        })
    }
};
COMMANDS.distribuiteCenterY = {
    shortcut: '',
    execute: function (_e) {
        COMMANDS.distribuite.execute({
            target: {
                dataset: {
                    value: 'distribuiteCenterY'
                }
            }
        })
    }
};

class Booleans_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    booleanPathsOperation(_pathTargetSVG, _pathSourceSVG, _actionName) {

        const paperScope = {};
        paper.install(paperScope);
        paper.setup([640, 480]);

        const pathTarget = paperScope.project.importSVG(_pathTargetSVG);
        const pathSource = paperScope.project.importSVG(_pathSourceSVG);

        let result;

        switch (_actionName) {
        case 'unite':
            result = pathTarget.unite(pathSource);
            break;
        case 'intersect':
            result = pathTarget.intersect(pathSource);
            break;
        case 'subtract':
            result = pathTarget.subtract(pathSource);
            break;
        case 'exclude':
            result = pathTarget.exclude(pathSource);
            break;
        case 'divide':
            result = pathTarget.divide(pathSource);
            break;
        }

        const resultElement = result.exportSVG();
        let createdSVGPathList = [];

        if (resultElement.nodeName === 'g') {
            createdSVGPathList = resultElement.querySelectorAll('path');
        } else {
            createdSVGPathList.push(resultElement);
        }

        return createdSVGPathList;

    };

    // booleanPathsOperation_undable( _actionName )
    // {
    //
    //     const activeDocument = activeApplication.activeDocument;
    //     const activePage = activeDocument.activePage;
    //
    //     let sourceElementList = XOS.getFilteredElementListByNodeName( activePage.selectionList , 'path,rect,ellipse');
    //     if(sourceElementList.length!==2) return;
    //
    //     sourceElementList = activeDocument.sortElementListByLevel( sourceElementList );
    //
    //     activeDocument.deselectAll();
    //
    //     const self=this;
    //
    //     function onConversionComplete( sourcePathList )
    //     {
    //         if(sourcePathList.length!==2) return;
    //
    //         const pathTarget = sourcePathList[0];
    //         const pathSource = sourcePathList[1];
    //         const createdSVGPathList = self.booleanPathsOperation( pathTarget , pathSource, _actionName );
    //
    //         // l'aspetto grafico è sempre preso dall'elemento che sta sotto
    //         activeDocument.fillAndStrokeManager.set_stroke( pathTarget );
    //         activeDocument.fillAndStrokeManager.set_fill( pathTarget );
    //
    //         for(let i=0; i<createdSVGPathList.length;i++) createdSVGPathList[i].setPathData( createdSVGPathList[i].getPathData({absolutize:true}));
    //
    //        activeDocument.replaceElementList_undable( sourceElementList , createdSVGPathList );
    //
    //         for(let i=0; i<createdSVGPathList.length;i++)
    //         {
    //             createdSVGPathList[i].resetOrigin();
    //             activeDocument.fillAndStrokeManager.apply_stroke(createdSVGPathList[i]);
    //             activeDocument.fillAndStrokeManager.apply_fill(createdSVGPathList[i]);
    //         }
    //
    //         activeApplication.workspace.update(); // non costretto ad aggiornare il workspace per aggiornare la posizione della origine
    //     }
    //
    //     activePage.convertElementListToPath(sourceElementList , onConversionComplete );
    // };


    booleanPathsOperation_undable(_actionName) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let sourceElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'path,rect,ellipse');
        sourceElementList = activeDocument.sortElementListByLevel(sourceElementList);
        activeDocument.deselectAll();

        const self = this;

        function onConversionComplete(sourcePathList) {
            let pathTarget,
            pathSource;
            if (sourcePathList.length === 2) {
                pathTarget = sourcePathList[0];
                pathSource = sourcePathList[1];
            } else {
                pathSource = sourcePathList.pop(); // non verrà aggiunto al dom

                const pathContainer = sourceElementList[0].parentElement; // inserisco qui le path per poter usare unify che vuole il parent per trafsormare i punti
                for (let i = 0; i < sourcePathList.length; i++)
                    pathContainer.appendChild(sourcePathList[i]);

                pathTarget = sourcePathList[0];

                const max = sourcePathList.length;
                for (let i = 1; i < max; i++)
                    pathTarget.unifyPathSegments(sourcePathList[i]);
                pathTarget.render();

                for (let i = 0; i < sourcePathList.length; i++)
                    pathContainer.removeChild(sourcePathList[i]); // rimuovo le path

                // pathSource = sourcePathList.pop();
                // pathTarget = sourcePathList[0];
                // const max = sourcePathList.length;
                // for(let i=1; i<max;i++) pathTarget.unifyPathSegments( sourcePathList[i] );
                // pathTarget.render();

            }

            //console.log('pathTarget',pathTarget);

            //console.log('pathSource',pathSource);

            const createdSVGPathList = self.booleanPathsOperation(pathTarget, pathSource, _actionName);

            // l'aspetto grafico è sempre preso dall'elemento che sta sotto
            activeDocument.fillAndStrokeManager.set_stroke(pathTarget);
            activeDocument.fillAndStrokeManager.set_fill(pathTarget);

            for (let i = 0; i < createdSVGPathList.length; i++)
                createdSVGPathList[i].setPathData(createdSVGPathList[i].getPathData({
                        absolutize: true
                    }));

            activeDocument.replaceElementList_undable(sourceElementList, createdSVGPathList);

            for (let i = 0; i < createdSVGPathList.length; i++) {
                createdSVGPathList[i].resetOrigin();
                activeDocument.fillAndStrokeManager.apply_stroke(createdSVGPathList[i]);
                activeDocument.fillAndStrokeManager.apply_fill(createdSVGPathList[i]);
            }

            activeApplication.workspace.update(); // non costretto ad aggiornare il workspace per aggiornare la posizione della origine
        }

        activePage.convertElementListToPath(sourceElementList, onConversionComplete);
    };

    onExecute(_e) {

        const activePage = window.activeApplication.activeDocument.activePage;

        if (activePage.selectionList.length < 2)
            return;

        this.booleanPathsOperation_undable(_e.target.dataset.value);

    }
}

COMMANDS.booleans = new Booleans_cmd();

class Delete_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let i,
        max = activePage.selectionList.length;

        if (max === 0)
            return null;

        const elementListToRemove = [];

        // non si può eliminare una viewBox, analizzo la lista degli elementi da eliminare
        for (i = 0; i < max; i++) {
            if (!activePage.selectionList[i].classList.contains('view-box'))
                elementListToRemove.push(activePage.selectionList[i]);
        }

        max = elementListToRemove.length;
        if (max === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        for (i = 0; i < max; i++) {
            //elementListToRemove[i].removeAttribute('selected');
            undoAction.createDomNodeSnapshot([elementListToRemove[i]], 'insert');
            redoAction.createDomNodeSnapshot([elementListToRemove[i]], 'delete');
            //XOS.removeElementList( [elementListToRemove[i]] );
            elementListToRemove[i].remove();
        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato


        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(elementListToRemove);
        };

        activeDocument.deselectAll();

        activeApplication.workspace.update();
        activeDocument.onChange();

    }

}

COMMANDS.delete = new Delete_cmd('DELETE');
COMMANDS.deleteBackspace = new Delete_cmd('BACKSPACE');

class NewDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        //console.log('NewDocument_cmd',_e);
        activeApplication.documentsManager.newDocument();
    }
}

COMMANDS.newDocument = new NewDocument_cmd();

class OpenDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        activeApplication.documentsManager.chooseDocument();
    }
}

COMMANDS.openDocument = new OpenDocument_cmd();

class CloseDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        activeApplication.documentsManager.closeDocument();
    }
}

COMMANDS.closeDocument = new CloseDocument_cmd();

class SaveDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super("cmd-key S");
    }

    onExecute(_e) {
		activeApplication.documentsManager.saveDocument();  
    }

}
COMMANDS.saveDocument = new SaveDocument_cmd();

class SaveDocumentAs_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        activeApplication.documentsManager.saveDocumentAs();
    }

}

COMMANDS.saveDocumentAs = new SaveDocumentAs_cmd();

class saveDocumentAsDefault_cmd extends BaseCommand_cmd {

    constructor() {
        super();
        //this.shortcut = [KEYBOARD.CODES.BACKSPACE,KEYBOARD.CODES.DELETE];
    }

    onExecute(_e) {
        activeApplication.documentsManager.saveDocumentAsDefault();
    }

}
COMMANDS.saveDocumentAsDefault = new saveDocumentAsDefault_cmd();

class RemoveDefaultDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
        //this.shortcut = [KEYBOARD.CODES.BACKSPACE,KEYBOARD.CODES.DELETE];
    }

    onExecute(_e) {
        activeApplication.documentsManager.removeDefaultDocument();
    }

}

COMMANDS.removeDefaultDocument = new RemoveDefaultDocument_cmd();

class ImportImage_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        window.activeApplication.activeDocument.importLocalImageAsDataURL_undable();
    }
}

COMMANDS.importImage = new ImportImage_cmd();

class ImportDXF_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const self = this;
        LOCAL_FILE_SYSTEM.chooseFile("application/dxf", function (_e) {
            LOCAL_FILE_SYSTEM.readTextFile(_e.target.files[0], function (_textData) {
                self.parse_DXF(_textData)
            })
        });
    }

    parse_DXF(_textData) {
        const importer = new DXF_importer();
        importer.import(_textData, 1);
    }
}

COMMANDS.importDXF = new ImportDXF_cmd();

class ImportDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        window.activeApplication.documentsManager.chooseDocument({
            import: true
        });
    }
}

COMMANDS.importDocument = new ImportDocument_cmd();

class ExportAsImage_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const self = this;
        self.doExport(_e);
    }

    doExport(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        activeDocument.exitFrom_AllIsolateLayerEditing();

        function onBitmapComplete(_bitmapDataToSave) {
            const fileName = LOCAL_FILE_SYSTEM.fileNameAndExtensionByMimeType(activeApplication.activeDocument.fileHandle.name, _e.target.dataset.mimeType);
            LOCAL_FILE_SYSTEM.saveLocalFile(fileName, _bitmapDataToSave, _e.target.dataset.mimeType);
        }

        activeDocument.convertPageToBitmap(activePage, onBitmapComplete, _e.target.dataset.mimeType);
    }
}

COMMANDS.exportAsImage = new ExportAsImage_cmd();

class PrintDocument_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        window.print();
    }
}

COMMANDS.printDocument = new PrintDocument_cmd('cmd-key P');

class CutByClick_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        document.execCommand('cut');
    }

}

COMMANDS.cutByClick = new CutByClick_cmd('cmd-key X');

class CopyByClick_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        document.execCommand('copy');
    }

}
COMMANDS.copyByClick = new CopyByClick_cmd('cmd-key C');

class PasteByClick_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    async onExecute(_e) {

        // non va
        // var pasteEvent = new ClipboardEvent('paste');
        // //pasteEvent.clipboardData.items.add('My string', 'text/plain');
        // document.dispatchEvent(pasteEvent);


        try {
            const items = await navigator.clipboard.read();
            const textBlob = await items[0].getType("text/plain");
            let string = await(new Response(textBlob)).text();
            let startID = string.indexOf('<svg');
            if (startID === -1)
                return;
            string = string.substring(startID, string.lastIndexOf('</svg>') + 6);
            const xmlDocument = new DOMParser().parseFromString(string, "image/svg+xml").querySelector('svg');
            let importInPlace = false;
            if (_e.target.dataset.importInPlace)
                importInPlace = true;
            //activeApplication.unserializeDocument( xmlDocument , { import: true, shiftKey:shiftKey }  );
            activeApplication.documentsManager.unserializeDocument(xmlDocument, {
                import: true,
                importInPlace: importInPlace
            });
        } catch (err) {
            DIALOGS['alertDialog'].open(localString('Tips'), localString('Try to paste using the keyboard [Cmd/Ctrl]+V'), null, null, '../XOS/icons/sys-dialog-icons.svg#message-dialog-icon');
            document.execCommand('paste'); // non va
        }

        //
        // function onTextFromClipboardReady( _text )
        // {
        //     console.log('onTextFromClipboardReady' , _text );
        //     const pasteEvent = {clipboardData:{items:[{kind:'string',type:"text/plain", 'getAsString':function(_callback){_callback(_text);}}],'getData':function(_callback){return _text;}},'preventDefault':function(){}};
        //     if(_e.target.dataset.shiftKey) pasteEvent.shiftKey=true;
        //     activePage.onPaste(pasteEvent);
        // }
        //
        // navigator.clipboard.readText().then( clipText => onTextFromClipboardReady( clipText ) );
    }

}

COMMANDS.pasteByClick = new PasteByClick_cmd('cmd-key V');

class SelectAll_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
        //this.shortcut = [KEYBOARD.CODES.BACKSPACE,KEYBOARD.CODES.DELETE];
    }

    onExecute(_e) {
        activeApplication.activeDocument.selectAll();
    }

}

COMMANDS.selectAll = new SelectAll_cmd('cmd-key A');

class DeselectAll_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        activeApplication.activeDocument.deselectAll();
        activeApplication.workspace.update();
    }

}

COMMANDS.deselectAll = new DeselectAll_cmd('cmd-key shift-key A');

class ResetRotation_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = window.activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length < 1)
            return null;
        window.activeApplication.activeDocument.resetRotationElementList_undable();
    }

}

COMMANDS.resetRotation = new ResetRotation_cmd();

class ResetTransform_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length < 1)
            return null;

        activeApplication.activeDocument.resetTransformElementList_undable();
    }

}

COMMANDS.resetTransform = new ResetTransform_cmd();

class BakeTransform_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = window.activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length < 1)
            return null;

        window.activeApplication.activeDocument.bakeTransformElementList_undable();
        // chiamandolo 2 volte trova anche il centro corretto
        // activePage.activeEditableElement.resetOrigin();
        // activePage.activeEditableElement.resetOrigin();
        // activePage.updateInteraction();
    }

}

COMMANDS.bakeTransform = new BakeTransform_cmd();

class ResetOrigin_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = window.activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length < 1)
            return null;

        window.activeApplication.activeDocument.resetOriginElementList_undable();
        // chiamandolo 2 volte trova anche il centro corretto
        // activePage.activeEditableElement.resetOrigin();
        // activePage.activeEditableElement.resetOrigin();
        // activePage.updateInteraction();
    }

}

COMMANDS.resetOrigin = new ResetOrigin_cmd();

class Group_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;
        activeDocument.groupElementList_undable();
    }

    // onExecute(_e)
    // {
    //     const activeDocument = activeApplication.activeDocument;
    //     const activePage = activeDocument.activePage;
    //
    //     if( activePage.selectionList.length===0 ) return null;
    //
    //
    //     if( GeometryUtils.areElementsInEqualParent(activePage.selectionList) !== true )
    //     {
    //         DIALOGS['alertDialog'].open( localString('Invalid operation') , localString('To make a group the elements must be inside the same level or group!'));
    //         return null;
    //     }
    //
    //     const undoAction = new UndoRedoAction();
    //     const redoAction = new UndoRedoAction();
    //     activePage.history.addUndoRedoActions( undoAction , redoAction );
    //
    //     const elementListToGroup = activeDocument.sortElementListByLevel(activePage.selectionList);
    //
    //     activeDocument.deselectAll();
    //
    //     undoAction.createDomNodeSnapshot( elementListToGroup , 'insert');
    //     redoAction.createDomNodeSnapshot( elementListToGroup , 'delete') ;
    //
    //     const parentElementTarget = elementListToGroup[0].parentElement;
    //     const insertBeforeTarget = elementListToGroup[elementListToGroup.length-1].nextElementSibling;
    //
    //     const bbox = GeometryUtils.getElementListGlobalBBox( elementListToGroup );
    //     const centerInParent = parentElementTarget.globalToLocal( bbox.center.x , bbox.center.y );
    //
    //     XOS.removeElementList(elementListToGroup);
    //
    //     const newGroup = SVGUtils.createGroup(centerInParent.x, centerInParent.y);
    //
    //     const tempMatrix = SVGUtils.createSVGMatrix().translate( -centerInParent.x, -centerInParent.y );
    //
    //     let clonedElement;
    //     let i,max = elementListToGroup.length;
    //     for( i = 0; i < max; i++)
    //     {
    //         clonedElement = elementListToGroup[i].cloneNode(true);
    //         clonedElement.getTransform().setMatrix( tempMatrix.multiply( clonedElement.getTransform().matrix ) );
    //         newGroup.appendChild(clonedElement);
    //     }
    //
    //     parentElementTarget.insertBefore( newGroup , insertBeforeTarget );
    //
    //     undoAction.createDomNodeSnapshot( [newGroup] , 'delete');
    //     undoAction.snapshotDataList.reverse();
    //     redoAction.createDomNodeSnapshot( [newGroup] , 'insert') ;
    //
    //     activeDocument.selectElementList( [newGroup] );
    //     activeApplication.workspace.update();
    //     activeDocument.onChange();
    // }

}

COMMANDS.group = new Group_cmd('cmd-key G');

class Ungroup_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activePage = activeApplication.activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        return activeApplication.activeDocument.ungroupElementList_undable();
    }

}

COMMANDS.ungroup = new Ungroup_cmd('cmd-key shift-key G');

class ConvertToPath_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = window.activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        window.activeApplication.activeDocument.convertElementListToPath_undable();
        if (TOOLS.activeTool !== TOOLS['selection-points-tool'])
            window.activeApplication.setActiveTool('selection-points-tool');
    }

}

COMMANDS.convertToPath = new ConvertToPath_cmd();

class ConvertToBitmap_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activePage = window.activeApplication.activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        window.activeApplication.activeDocument.convertElementToBitmap_undable(activePage.selectionList[0]);
    }

}

COMMANDS.convertToBitmap = new ConvertToBitmap_cmd();

class Lock_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        const elementList = activePage.selectionList;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(elementList, 'locked');
        const max = elementList.length;
        for (let i = 0; i < max; i++)
            elementList[i].setAttribute('locked', '');
        redoAction.createAttributeSnapshot(elementList, 'locked');

        activeDocument.deselectAll();
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

COMMANDS.lock = new Lock_cmd('cmd-key L');

class UnlockAll_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {

        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const elementList = activePage.content.querySelectorAll('.layers .layer[active] [locked]');

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(elementList, 'locked');
        const max = elementList.length;
        for (let i = 0; i < max; i++)
            elementList[i].removeAttribute('locked');
        redoAction.createAttributeSnapshot(elementList, 'locked');

        activeDocument.selectElementList(elementList);
        activeApplication.workspace.update();
        activeDocument.onChange();

    }

}

COMMANDS.unlockAll = new UnlockAll_cmd('cmd-key shift-key L');

class ViewPageAtScale_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
        this.scale = 'fit';
    }

    onExecute(_e) {
        activeApplication.activeDocument.setActivePageScale(this.scale);
        activeApplication.workspace.update();
    }

}

COMMANDS.fitPageToView = new ViewPageAtScale_cmd('cmd-key ZERO');

COMMANDS.viewPageAt100 = new ViewPageAtScale_cmd('cmd-key ONE');
COMMANDS.viewPageAt100.scale = 1;

COMMANDS.viewPageAt200 = new ViewPageAtScale_cmd('cmd-key TWO');
COMMANDS.viewPageAt200.scale = 2;

class FitSelectionToView_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0) {
            activeDocument.setActivePageScale(this.scale);
            activeApplication.workspace.update();
            return;
        }
        const bbox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
        activeDocument.fitRectToView(bbox, 100, 100);
        activeApplication.workspace.update();
    }

}

COMMANDS.fitSelectionToView = new FitSelectionToView_cmd('cmd-key alt-key ZERO');

class ShowAsWireframe_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {

        const activePage = window.activeApplication.activeDocument.activePage;
        if (_e.target.classList.contains('checked')) {
            activePage.classList.remove('show-as-wireframe');
            _e.target.classList.remove('checked');
        } else {
            activePage.classList.add('show-as-wireframe');
            _e.target.classList.add('checked');
        }
    }
}

COMMANDS.showAsWireframe = new ShowAsWireframe_cmd();

class DuplicatePage_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        activeDocument.deselectAll();
        const newPage = activePage.cloneNode(true);

        activePage.parentElement.insertBefore(newPage, activePage.nextElementSibling);
        activeDocument.setActivePage(newPage);

        PANELS['page-list-inspector'].update();
    }

}

COMMANDS.duplicatePage = new DuplicatePage_cmd();

class CopyPages_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        activeApplication.activeDocument.copyAndCutListener = PANELS["page-list-inspector"];
        document.execCommand('copy');
    }

}

COMMANDS.copyPages = new CopyPages_cmd();

class CutPages_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        // activeApplication.copyAndCutManager = activeApplication.propertyPanels["page-list-inspector"];
        // document.execCommand('cut');

        activeApplication.activeDocument.copyAndCutListener = PANELS["page-list-inspector"];
        document.execCommand('cut');
    }

}

COMMANDS.cutPages = new CutPages_cmd();

class JoinPaths_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 2)
            return null;
        activeDocument.joinPaths_undable();
    }

}

COMMANDS.joinPaths = new JoinPaths_cmd('cmd-key J');

class ClosePath_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 1)
            return null;
        activeDocument.closePath_undable();
    }

}

COMMANDS.closePath = new ClosePath_cmd();

class UnifyPaths_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 2)
            return null;
        activeDocument.unifyPaths_undable();
    }

}

COMMANDS.unifyPaths = new UnifyPaths_cmd();

class SeparateSubPaths_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        activeDocument.separateSubPaths_undable();
    }

}

COMMANDS.separateSubPaths = new SeparateSubPaths_cmd();

class ReversePath_cmd extends BaseCommand_cmd {

    constructor(_shortcut) {
        super(_shortcut);
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        activeDocument.reversePath_undable();
    }

}

COMMANDS.reversePath = new ReversePath_cmd();

class CreateMaskedContent_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 2)
            return null;
        activeDocument.createMaskedContent_undable();
    }

}

COMMANDS.createMaskedContent = new CreateMaskedContent_cmd();

class CreateClippedContent_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 2)
            return null;
        activeDocument.createClippedContent_undable();
    }

}

COMMANDS.createClippedContent = new CreateClippedContent_cmd();

class CreateSymbol_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;

        const promptDialog = DIALOGS['promptDialog'];
        const alertDialog = DIALOGS['alertDialog'];

        function onClick_ok() {
            let newSymbolId = promptDialog.getPromptValue();
            if (newSymbolId === '')
                newSymbolId = null;

            // controllo se per caso esiste già un elemento con lo stesso nome
            const symbolExists = activeDocument.resources.getResourceById(newSymbolId);
            if (symbolExists) {
                alertDialog.open(localString('Existent ID'), localString('The document already contains an element with ID:') + newSymbolId);
                return;
            }

            activeDocument.createSymbol_undable(activePage.selectionList, newSymbolId);

            //activeApplication.activeDocument.onLibraryChange( "symbol-library" );
            this.close();
        }

        promptDialog.open(localString('Symbol id'), localString('Give a custom symbol name.'), onClick_ok, null, 'resources/icons/janvas-app-icons.svg#symbolLibrary2D_icon');
        promptDialog.setPromptValue('', localString('symbol name'));

    }

}

COMMANDS.createSymbol = new CreateSymbol_cmd();

class CreatePattern_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        activeDocument.createPattern_undable();
    }

}

COMMANDS.createPattern = new CreatePattern_cmd();

class CreateMarker_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return null;
        activeDocument.createMarker_undable();
    }

}

COMMANDS.createMarker = new CreateMarker_cmd();

class CreateTextOnPath_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const activeDocument = window.activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length < 2)
            return null;
        activeDocument.createTextOnPath_undable();
    }

}

COMMANDS.createTextOnPath = new CreateTextOnPath_cmd();

class IFrameServiceDialogAction_cmd extends BaseCommand_cmd {

    constructor() {
        super();
    }

    onExecute(_e) {
        const dialogService = DIALOGS[_e.target.dataset.dialogId];
        if (dialogService)
            dialogService.doServiceAction(_e.target.dataset.action);
    }
}

COMMANDS.iframeServiceDialogAction = new IFrameServiceDialogAction_cmd();

class Base2D_tool{
    constructor(_name, _shortcut = '') {
        this.name = _name;
        this.shortcut = _shortcut;
        TOOLS[this.name] = this;
    }

    onActivate() {
        if (activeApplication.activeDocument) {
            // activeApplication.workspace.update();
            // activeApplication.workspace.snapInteraction2D.reset();
            activeApplication.workspace.snapInteraction2D.reset();
            activeApplication.workspace.update();

        }
    }

    onDeactivate() {}

    onKeyDown(_e) {}

    onPointerDownOnInteractionPoint(_e) {}

    onPointerDoubleClick() {}

    onPointerDown(_e) {
        if (this.lastPointerDownEvent) {
            if ((_e.timeStamp - this.lastPointerDownEvent.timeStamp) < 250) {
                _e.isDoubleClick = true;
            }
        }
        this.lastPointerDownEvent = _e;
    }

    onPointerUp(_e) {
        if (this.lastPointerUpEvent) {
            if ((_e.timeStamp - this.lastPointerUpEvent.timeStamp) < 250)
                _e.isDoubleClick = true; // possibile gestire il doppio click sia in fase di down che in fase di up
            if ((_e.timeStamp - this.lastPointerUpEvent.timeStamp) > 250)
                _e.isMouseHold = true;
        }
        this.lastPointerUpEvent = _e;
    }

    onPointerMove(_e) {}

    onDragStart(_e) {}

    onDrag(_e) {}

    onDragEnd() {}

    onWheelChangeStart(_e) {

        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        // if( this.timeoutRef)clearTimeout( this.timeoutRef);
        if (activeApplication.activeDocument.preferences.optimizeZoom)
            activeApplication.activeDocument.activePage.classList.add('optimize-zoom');

    }

    onWheelChangeEnd(_e) {
        // SUPER !!!! todo
        //activeApplication.activeDocument.hideElementsNotInViewport(); // ottmizza grandi progetti
        if (!activeApplication.isTextEditing)
            activeApplication.workspace.update();
        if (activeApplication.activeDocument.preferences.optimizeZoom)
            activeApplication.activeDocument.activePage.classList.remove('optimize-zoom');

    }

    onWheelChange(_e) {
        activeApplication.activeDocument.zoom(_e.deltaSumY, _e.pageX - activeApplication.workspace.bounding.left, _e.pageY - activeApplication.workspace.bounding.top);
    }

    showInteraction() {}

    onDocumentViewChange() {}

}

class BaseDraw2D_tool extends Base2D_tool{
    constructor(_name, _shortcut, _interactionMode = 'linear-interaction') {
        super(_name, _shortcut);
        this.pointA = null;
        this.pointB = null;
        this.pointC = null;
        this.currentPenEvent = null;
        this.createdElement = null;
        this.interactionMode = _interactionMode;
    }

    onDeactivate() {
        this.reset();
    }

    onKeyDown(_e) {
        const activeDocument = activeApplication.activeDocument;

        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();
            this.reset();
            break;

        case 'TAB':
            if (this.interactionMode === 'linear-interaction') {
                if (this.pointA && this.pointB)
                    this.finalize(_e);
                WINDOWS['mainInspectorWindow'].showMainSection('selection-section');
                PANELS['linear-transform-inspector'].setInputPropertyFocus('lineLength');
            } else if (this.interactionMode === 'rectangular-interaction') {
                if (this.pointA && this.pointB)
                    this.finalize(_e);
                WINDOWS['mainInspectorWindow'].showMainSection('selection-section');
                PANELS['rectangular-transform-inspector'].setInputPropertyFocus('sizeX');
            } else if (this.interactionMode === 'elliptical-interaction') {
                if (this.pointA && this.pointB)
                    this.finalize(_e);
                WINDOWS['mainInspectorWindow'].showMainSection('selection-section');
                PANELS['rectangular-transform-inspector'].setInputPropertyFocus('sizeX');
            } else if (this.interactionMode === 'radial-interaction') {
                if (this.pointA && this.pointB && this.pointC)
                    this.finalize(_e);
                WINDOWS['mainInspectorWindow'].showMainSection('selection-section');
                PANELS['radial-transform-inspector'].setInputPropertyFocus('radius');
            }

            _e.preventDefault();
            break;

        case 'ESC':
            this.reset();
            _e.preventDefault();
            break;
        }

    }

    onDocumentViewChange(_e) {
        if (this.pointA)
            activeApplication.activeDocument.pageContentToWorkspaceCoords(this.pointA);
        if (this.pointB)
            activeApplication.activeDocument.pageContentToWorkspaceCoords(this.pointB);
    }

    pointerEventToCoords(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        if (this.pointA)
            _e.startPenEvent = this.pointA; // servirà per calcolare la perpendicolare ad un segmento esistente
        if (_e.shiftKey && _e.startPenEvent)
            activeApplication.workspace.snapInteraction2D.applySnapTo_angle(_e);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;
    }

    reset(_e) {
        this.pointA = null;
        this.pointB = null;
        this.pointC = null;
        this.createdElement = null;
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    }

    setPointA(_e) {
        this.reset();
        this.pointA = this.currentPenEvent;
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY));
    }

    setPointB(_e) {
        this.pointB = this.currentPenEvent;
    }

    setPointC(_e) {
        this.pointC = this.currentPenEvent;
    }

    onReadyPoints_A_B(_e) {
        // must be redefine
    }

    onReadyPoints_A_B_C(_e) {
        // must be redefine
    }

    finalize(_e) {

        this.createElement(_e);

        if (this.createdElement) {
            this.createUndoRedoActions(this.createdElement);
            const activeDocument = activeApplication.activeDocument;
            activeDocument.onChange();
            activeDocument.selectElementList([this.createdElement]);
        }

        this.reset();
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (this.pointA === null) {
            this.setPointA();
            this.setPointB();
        } else if (this.pointC === null) {
            this.setPointC();
            this.onReadyPoints_A_B(_e);
        } else if (this.pointC) {
            this.onReadyPoints_A_B_C(_e);
        }

        XOS.initDragFunctions(this, _e);
    }

    onPointerMove(_e) {
        this.pointerEventToCoords(_e);
        this.currentPenEvent = _e;

        if (this.pointA === null)
            return;

        if (this.pointC === null) {
            this.setPointB();
        } else {
            this.setPointC();
        }

        this.updateDrawingInteraction(_e);
    }

    onDrag(_e) {
        this.onPointerMove(_e)
    }

    onDragEnd(_e) {
        // this.setPointC(this.currentPenEvent);
        // this.onReadyPoints_A_B(_e);

        if (this.pointA === null) {
            return;
        } else if (this.pointC === null) {
            this.setPointC();
            this.onReadyPoints_A_B(_e);
        } else if (this.pointC) {
            this.onReadyPoints_A_B_C(_e);
        }
    }

    updateDrawingInteraction(_e) {
        if (this.interactionMode === 'linear-interaction') {
            this.updateDrawingInteraction_linear(_e);
        } else if (this.interactionMode === 'rectangular-interaction') {
            this.updateDrawingInteraction_rectangular(_e);
        } else if (this.interactionMode === 'elliptical-interaction') {
            this.updateDrawingInteraction_elliptical(_e);
        } else if (this.interactionMode === 'radial-interaction') {
            this.updateDrawingInteraction_angular(_e);
        }
    }

    createElement(_e) {
        // must be redefine
    }

    createUndoRedoActions(_createdElementList) {
        if (!(_createdElementList instanceof Array))
            _createdElementList = [_createdElementList];
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const undoAction = new UndoRedoAction('remove element');
        const redoAction = new UndoRedoAction('added element');
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(_createdElementList);
        };
        redoAction.createDomNodeSnapshot(_createdElementList, 'insert');
        undoAction.createDomNodeSnapshot(_createdElementList, 'delete');
        return {
            undoAction: undoAction,
            redoAction: redoAction
        };
    }

    updateDrawingInteraction_linear(_e) {
        if (this.pointC) {
            let pt1 = SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY);
            let pt2 = SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY);
            let pt3 = SVGUtils.createSVGPoint(this.pointC.contentX, this.pointC.contentY);
            let result = GeometryUtils.getClosestPointToLine(pt1, pt2, pt3);
            let distance = pt3.getDistanceFromPoint(result.point);
            if (result.left) {
                let temp = this.pointB;
                this.pointB = this.pointA;
                this.pointA = temp;
                pt1 = SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY);
                pt2 = SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY);
            }

            this.pointC.height = distance; // memorizzo qui l'altezza reale dell'oggetto che verrà creato

            let angleDeg = GeometryUtils.getAngleBetweenPoints(pt2, pt1) / (Math.PI / 180);

            const contentScale = activeApplication.activeDocument.activePage.content.currentScale;

            const interactiveRectangle = activeApplication.workspace.interactiveRectangle;

            const rectWidth = pt2.getDistanceFromPoint(pt1) * contentScale;
            let rectHeight = distance * contentScale;
            let matrix = interactiveRectangle.getTransform().matrix;
            matrix.identity();
            matrix = matrix.translate(this.pointA.workspaceX, this.pointA.workspaceY);
            matrix = matrix.rotate(angleDeg);
            interactiveRectangle.getTransform().setMatrix(matrix);
            interactiveRectangle.updateGeometry(0, 0, rectWidth, rectHeight);
            interactiveRectangle.classList.add('showed');
        } else if (this.pointB) {
            const interactiveLine = activeApplication.workspace.interactiveLine;
            interactiveLine.updateGeometry(this.pointA.workspaceX, this.pointA.workspaceY, this.pointB.workspaceX, this.pointB.workspaceY);
            interactiveLine.geometryPointList = null;
            interactiveLine.classList.add('showed');
        }

    }

    updateDrawingInteraction_rectangular(_e) {
        let x = Math.min(this.pointA.workspaceX, this.pointB.workspaceX);
        let y = Math.min(this.pointA.workspaceY, this.pointB.workspaceY);
        let w = Math.abs(this.pointB.workspaceX - this.pointA.workspaceX);
        let h = Math.abs(this.pointB.workspaceY - this.pointA.workspaceY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        const interactiveRectangle = activeApplication.workspace.interactiveRectangle;
        interactiveRectangle.getTransform().matrix.identity();
        interactiveRectangle.updateGeometry(x, y, w, h);
        interactiveRectangle.classList.add('showed');
    }

    updateDrawingInteraction_elliptical(_e) {
        let x = Math.min(this.pointA.workspaceX, this.pointB.workspaceX);
        let y = Math.min(this.pointA.workspaceY, this.pointB.workspaceY);
        let w = Math.abs(this.pointB.workspaceX - this.pointA.workspaceX);
        let h = Math.abs(this.pointB.workspaceY - this.pointA.workspaceY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        const rx = w / 2;
        const ry = h / 2;
        const cx = x + rx;
        const cy = y + ry;

        const interactiveEllipse = activeApplication.workspace.interactiveEllipse;
        interactiveEllipse.updateGeometry(cx, cy, rx, ry);
        interactiveEllipse.classList.add('showed');
    }

    updateDrawingInteraction_angular(_e) {
        if (this.pointC) {
            const pt1 = SVGUtils.createSVGPoint(this.pointA.workspaceX, this.pointA.workspaceY);
            const pt2 = SVGUtils.createSVGPoint(this.pointB.workspaceX, this.pointB.workspaceY);
            const pt3 = SVGUtils.createSVGPoint(this.pointC.workspaceX, this.pointC.workspaceY);
            const interactiveArc = activeApplication.workspace.interactiveArc;

            let angleStart = pt1.getAngleFromPoint(pt2, true);
            let angleEnd = pt1.getAngleFromPoint(pt3, true);

            if (pt3.equals(pt2, 10))
                this.checkExit = true;

            if (this.checkExit) {
                if (!pt3.equals(pt2, _e.snapDistance)) {
                    this.inversion = !this.inversion;
                    this.checkExit = false;
                }
            }

            if (this.inversion) {
                const temp = angleStart;
                angleStart = angleEnd;
                angleEnd = temp;
            }

            if (angleEnd < angleStart)
                angleEnd += 360;

            const result = interactiveArc.querySelector('.arc').buildArc(pt1, pt2.getDistanceFromPoint(pt1), angleStart, angleEnd);
            interactiveArc.querySelector('.center').placeAt(pt1.x, pt1.y);
            interactiveArc.querySelector('.angle-start').updateGeometry(pt1.x, pt1.y, pt2.x, pt2.y);
            interactiveArc.querySelector('.angle-end').updateGeometry(pt1.x, pt1.y, result.endPt.x, result.endPt.y);

            interactiveArc.geometryPointList = null;
            interactiveArc.classList.add('showed');
            activeApplication.workspace.interactiveLine.classList.remove('showed');
        } else if (this.pointB) {
            const interactiveLine = activeApplication.workspace.interactiveLine;
            interactiveLine.updateGeometry(this.pointA.workspaceX, this.pointA.workspaceY, this.pointB.workspaceX, this.pointB.workspaceY);
            interactiveLine.geometryPointList = null;
            interactiveLine.classList.add('showed');
        }
    }

}

class Selection2D_tool extends Base2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.clickedElement = null;
        this.currentPenEvent = null;
        this.selectMainNodes = true;
    }

    onActivate() {
        if (activeApplication.activeDocument) {
            const activeDocument = activeApplication.activeDocument;
            activeDocument.deselectAllPoints();
            super.onActivate();
            //console.log('Selection2D_too onActivatel' , activeApplication.activeDocument.activePage.selectionList );
        }

    }

    // probabilmente sarebbe meglio convertire ogni path con solo MveTo e lineTo in una linea! buttando via questo codice
    // chiamato da interaction points
    // questo è necessario nel caso in cui è selezionata una path composta da solamente 2 punti , come una linea
    onPointerDownOnInteractionPoint(_e) {
        const clickedHandle = _e.target.parentElement;
        const handlePosition = clickedHandle.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(virtualEvent);

        activeDocument.deselectAllPoints();
        activeDocument.selectPoint(clickedHandle.pointRef);
        activeDocument.activePage.focusedPoint = clickedHandle.pointRef;

        //console.log('onPointerDownOnInteractionPoint' , _e )

        if (_e.target.classList.contains('resize')) {
            TOOLS['translate-points-tool'].initDrag(virtualEvent);
        } else if (_e.target.classList.contains('translate')) {
            TOOLS['translate-tool'].initDrag(virtualEvent);
        }
    }

    onPointerDown(_e) {
        //console.log('onPointerDown Selection tool');

        super.onPointerDown(_e);

        this.clickedElement = null;

        const activeDocument = activeApplication.activeDocument;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        // chiamo mouse move da mouse down se l'evento precedente è stato annullato dal doppio click per entrare in uno isolate layer
        if (!this.currentPenEvent) {
            this.onPointerMove(_e);
        }

        this.clickedElement = this.currentPenEvent.elementAtPoint;

        //console.log(' this.clickedElement ' ,  this.clickedElement  );

        if (this.clickedElement && this.clickedElement.nodeName !== 'svg') {
            this.clickedElement = this.clickedElement.getMainElement();
            if (activeDocument.preferences.selectMainNodes && this.selectMainNodes)
                this.clickedElement = this.clickedElement.closest('.layer>*');
            this.onPointerDownOnElement(_e);
        } else {
            this.clickedElement = null;
            this.onPointerDownOnPageBackground(_e);
        }
    }

    onPointerDownOnElement(_e) {
        const activeDocument = activeApplication.activeDocument;

        // if(_e.isDoubleClick)
        // {
        //     this.onPointerDoubleClickOnElement(_e);
        //     return;
        // }

        if (_e.shiftKey) {
            activeDocument.selectElement(this.clickedElement, true);
        } else {
            if (!activeDocument.isElementSelected(this.clickedElement))
                activeDocument.deselectAll();
            activeDocument.selectElement(this.clickedElement);
        }

        activeApplication.workspace.update();

        TOOLS['translate-tool'].initDrag(this.currentPenEvent);

    }

    onPointerDownOnPageBackground(_e) {
        //console.log('onPointerDownOnPageBackground');
        // if(_e.isDoubleClick)
        // {
        //     this.onPointerDoubleClickOnWorkspace(_e);
        //     return;
        // }
        TOOLS['selection-by-rect-area-tool'].initDrag(this.currentPenEvent);
    }

    onPointerDoubleClickOnWorkspace() {
        const activeDocument = activeApplication.activeDocument;

        const layers = activeDocument.activePage.content.querySelector('.layers').children;
        const lastLayer = layers[layers.length - 1];

        if (lastLayer.classList.contains('isolate-layer')) {
            activeDocument.exitFrom_isolateLayerEditing();
            return;
        }

        // if( this.selectionMode !== 'GLOBAL_SELECTION' )
        // {
        //     activeApplication.setActiveTool( "selection-tool" );
        //     return;
        // }

        activeDocument.setActivePageScale('fit');
    }

    onPointerDoubleClickOnElement() {
        //console.log('onPointerDoubleClickOnElement');

        const activeDocument = activeApplication.activeDocument;

        // if( this.clickedElement.nodeName==='text' || (this.clickedElement.nodeName==='foreignObject' && this.clickedElement.dataset.type === 'html-text')  )
        // {
        //     activeDocument.deselectAll();
        //     activeDocument.selectElement( this.clickedElement );
        //     activeApplication.workspace.update();
        //     activeApplication.setActiveTool('draw-edit-text-tool');
        //     TOOLS.activeTool.startTextEditing( this.clickedElement );
        // }
        if (this.clickedElement.nodeName === 'text') {
            activeDocument.deselectAll();
            activeDocument.selectElement(this.clickedElement);
            activeApplication.workspace.update();
            activeApplication.setActiveTool('draw-edit-text-tool');
            TOOLS.activeTool.startTextEditing(this.clickedElement);
        } else if ((this.clickedElement.nodeName === 'foreignObject' && this.clickedElement.dataset.type === 'html-text')) {
            activeDocument.deselectAll();
            activeDocument.selectElement(this.clickedElement);
            activeApplication.workspace.update();
            activeApplication.setActiveTool('draw-edit-text-tool');
            TOOLS.activeTool.startTextEditing(this.clickedElement);
        } else if (this.clickedElement.nodeName === 'path' && this.clickedElement.dataset.type !== 'object') {
            activeApplication.setActiveTool('selection-points-tool');
            activeApplication.workspace.update();
        }
        //else if( (this.clickedElement.nodeName === 'ellipse') || (this.clickedElement.nodeName === 'rect') || (this.clickedElement.nodeName === 'line') )
        else if ((this.clickedElement.nodeName === 'g' && this.clickedElement.dataset.objectId) || (this.clickedElement.nodeName === 'ellipse') || (this.clickedElement.nodeName === 'rect') || (this.clickedElement.nodeName === 'line') || (this.clickedElement.nodeName === 'path' && this.clickedElement.dataset.type === 'object')) {
            activeDocument.convertElementListToPath_undable([this.clickedElement]);
            activeApplication.setActiveTool('selection-points-tool');
        } else if (this.clickedElement.nodeName === 'g' && this.clickedElement.dataset.type !== 'object') {
            activeDocument.enterTo_isolateLayerEditing(this.clickedElement);
        } else if (this.clickedElement.nodeName === 'use') {
            const sourceElement = activeDocument.resources.getResourceById(this.clickedElement.getAttribute('href').split('#')[1]);
            activeDocument.enterTo_isolateLayerEditing(sourceElement);
        }

        this.currentPenEvent = null; // necessario per evitare che cliccando senza spostare il mouse successivamente venga mantenuto un riferimento ad un elemento cambiato (come quando si entra in un gruppo )


    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        if (_e.elementAtPoint && _e.elementAtPoint.isLocked())
            _e.elementAtPoint = null;
        activeApplication.workspace.snapInteraction2D.lastEvent = null; // non deve creare ne smart points ne smart guides
        this.currentPenEvent = _e;
    }

    onPointerUp(_e) {
        super.onPointerUp(_e);

        //console.log('onPointerUp',this.clickedElement);
        //console.log('onPointerUp',this.name);
        //console.log('_e.isDoubleClick',_e.isDoubleClick);

        // if(this.clickedElement && _e.isDoubleClick)
        // {
        //     this.onPointerDoubleClickOnElement(_e);
        //     return;
        // }

        if (_e.isDoubleClick) {
            if (this.clickedElement) {
                this.onPointerDoubleClickOnElement(_e);
            } else {
                this.onPointerDoubleClickOnWorkspace(_e);
            }
            return;
        }

        // activeApplication.workspace.snapInteraction2D.reset();
        // this.clickedElement=null;
        const activeDocument = activeApplication.activeDocument;
        if (!this.clickedElement)
            activeDocument.deselectAll();
        activeApplication.workspace.update();

    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const maxItems = activeDocument.activePage.selectionList.length;
        //console.log('activeDocument.activePage.selectionList',activeDocument.activePage.selectionList);
        if (maxItems > 0) {
            if (maxItems === 1) {
                const selectedElement = activeDocument.activePage.selectionList[0];
                //if(selectedElement.isLinearElement())
                if (selectedElement.dataset.type === 'object') {
                    if (selectedElement.dataset.objectId) {
                        const objectController = OBJECTS[selectedElement.dataset.objectId];
                        if (!objectController) {
                            //console.log('objectController undefined');
                            return;
                        }

                        objectController.showInteraction();
                    }
                    return;
                }

                if (selectedElement.nodeName === 'line') {
                    const lineInteraction2D = activeApplication.workspace.lineInteraction2D;
                    lineInteraction2D.show();
                    return;
                }

                // if(selectedElement.dataset.type==='object' && selectedElement.dataset.objectType==='linear-object')
                // {
                //     const linearObjectInteraction2D =  activeApplication.workspace.linearObjectInteraction2D;
                //     linearObjectInteraction2D.show();
                //     return;
                // }
                // else if(selectedElement.dataset.type==='object' && selectedElement.dataset.objectType==='radial-object')
                // {
                //     const radialObjectInteraction2D =  activeApplication.workspace.radialObjectInteraction2D;
                //     radialObjectInteraction2D.show();
                //     return;
                // }else

                if (selectedElement.nodeName === 'path') {
                    const geometryPointList = selectedElement.getGeometryPointList();
                    if (geometryPointList.length === 2 && geometryPointList[1].type === 'L') {
                        geometryPointList[1].previousSegment = geometryPointList[0];
                        activeDocument.setFocusedPathSegmentPoint(geometryPointList[1]);
                        const pointsInteraction = activeApplication.workspace.pointsInteraction;
                        pointsInteraction.show();
                        return;
                    } else {
                        const bboxInteraction2D = activeApplication.workspace.bboxInteraction2D;
                        bboxInteraction2D.show();
                    }
                } else {
                    const bboxInteraction2D = activeApplication.workspace.bboxInteraction2D;
                    bboxInteraction2D.show();
                }
            } else {
                const bboxInteraction2D = activeApplication.workspace.bboxInteraction2D;
                bboxInteraction2D.show();
            }

            if (activeDocument.preferences.elementOriginVisibility)
                activeApplication.workspace.elementOrigin2D.show();

            // if(bboxInteraction2D.isLocalMode)
            // {
            //     const pts = bboxInteraction2D.boundsPoints;
            //     window.activeApplication.accessories.horizontalRuler.updateSelectionRange( Math.min(pts[0].x,pts[1].x,pts[2].x,pts[3].x) , Math.max(pts[0].x,pts[1].x,pts[2].x,pts[3].x) );
            //     window.activeApplication.accessories.verticalRuler.updateSelectionRange(  Math.min(pts[0].y,pts[1].y,pts[2].y,pts[3].y) , Math.max(pts[0].y,pts[1].y,pts[2].y,pts[3].y) );
            // }else {
            //     window.activeApplication.accessories.horizontalRuler.updateSelectionRange( bboxInteraction2D.selectionBBox.min.x , bboxInteraction2D.selectionBBox.max.x );
            //     window.activeApplication.accessories.verticalRuler.updateSelectionRange(  bboxInteraction2D.selectionBBox.min.y , bboxInteraction2D.selectionBBox.max.y   );
            // }

        }
    }

    onKeyDown(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const translationValue = activeDocument.preferences.moveStep * activePage.content.currentScale;

        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();
            break;

        case 'TAB':
            if (activePage.focusedElement) {
                if (activePage.focusedElement.nodeName === 'line') {
                    //document.querySelector('transform-inspector').setInputPropertyFocus( 'sizeX' );
                    document.querySelector('line-inspector').setInputPropertyFocus('lineLength');
                } else {
                    document.querySelector('rectangular-transform-inspector').setInputPropertyFocus('sizeX');
                }
            }

            _e.preventDefault();
            break;

        case 'LEFT':

            if (_e.altKey) {
                const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName('center-center', GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
                activeDocument.rotateElementList_undable(activePage.selectionList, -activeDocument.preferences.rotateStep, bboxPivotPosition);
            } else {
                activeDocument.translateElementList_undable(activePage.selectionList, -translationValue, 0);
            }

            break;

        case 'UP':
            activeDocument.translateElementList_undable(activePage.selectionList, 0, -translationValue);
            break;

        case 'RIGHT':

            if (_e.altKey) {
                const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName('center-center', GeometryUtils.getElementListGlobalBBox(activePage.selectionList));
                activeDocument.rotateElementList_undable(activePage.selectionList, activeDocument.preferences.rotateStep, bboxPivotPosition);
            } else {
                activeDocument.translateElementList_undable(activePage.selectionList, translationValue, 0);
            }
            break;

        case 'DOWN':
            activeDocument.translateElementList_undable(activePage.selectionList, 0, translationValue);
            break;
        }

    }

}

new Selection2D_tool('selection-tool', 'V');

class SelectionPoints2D_tool extends Selection2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.selectMainNodes = false;
    }

    onDeactivate() {
        activeApplication.workspace.pointsInteraction.mode = 'translate-points';
        activeApplication.workspace.pointsInteraction.removeAllInteractionPoints();
        activeApplication.activeDocument.setFocusedPathSegmentPoint(null);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;

        if (maxSelectedElements === 0)
            return;

        if (maxSelectedElements === 1) {
            if (activePage.focusedElement.nodeName !== 'path') {
                super.showInteraction();
                return;
            }

            if (activePage.focusedElement.dataset.type === 'object') {
                super.showInteraction();
                return;
            }

        }

        activeApplication.workspace.pointsInteraction.show();

        if (activeDocument.preferences.elementOriginVisibility)
            activeApplication.workspace.elementOrigin2D.show();

        if (activePage.focusedPathSegmentPoint)
            activeApplication.workspace.updateActiveEditableSegmentInteraction();

        // if(activePage.focusedPathSegmentPoint)
        //   {
        //       if(activePage.focusedPathSegmentPoint.type==='L')
        //       {
        //           //activeApplication.workspace.segmentInteraction_L.showSegmentInteraction( activePage.focusedPathSegmentPoint );
        //           activeApplication.workspace.segmentInteraction_L.show();
        //       }
        //       else if(activePage.focusedPathSegmentPoint.type==='C')
        //       {
        //           activeApplication.workspace.segmentInteraction_C.show();
        //       }
        //       else if(activePage.focusedPathSegmentPoint.type==='Q')
        //       {
        //           activeApplication.workspace.segmentInteraction_Q.show();
        //       }
        //       else if(activePage.focusedPathSegmentPoint.type==='A')
        //       {
        //           activeApplication.workspace.segmentInteraction_A.show();
        //       }
        //   }

    }

    onPointerDownOnInteractionPoint(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activePage.focusedPathSegmentPoint = null;
        // nasconderà eventuali segmenti attivi, questo è l'unico modo perchè non aggiorno il workspace
        activeApplication.workspace.updateActiveEditableSegmentInteraction();

        const clickedHandle = _e.target.parentElement;

        const handlePosition = clickedHandle.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeDocument.pointerEventToCoords(virtualEvent);

        // se NON è un control point
        if (!clickedHandle.classList.contains('control')) {

            if (KEYBOARD_EVENT_MANAGER.cmdKeyPressed && _e.shiftKey && _e.altKey) {
                // const subPathId = clickedHandle.pointRef.ownerShapeElement.getSubPathIdBySegment( clickedHandle.pointRef );
                // activeDocument.splitPathAtLocation_undable( clickedHandle.pointRef.ownerShapeElement, subPathId , virtualEvent.workspaceX, virtualEvent.workspaceY );
                //
                // const clickedHandle = _e.target.parentElement;
                const path = clickedHandle.pointRef.ownerShapeElement;
                const result = path.splitPathAtPoint(clickedHandle.pointRef);

                if (result.length > 0) {
                    path.geometryPointList = null;
                    activeDocument.replaceElement_undable(path, result);
                }

                // activeDocument.splitPathAtPoint_undable( clickedHandle.pointRef  );
                activePage.focusedPoint = null;

                return;
            }

            if (_e.altKey && _e.shiftKey && clickedHandle.pointRef.ownerShapeElement.nodeName === 'path') {
                _e.clickedHandle = clickedHandle;
                TOOLS["convert-point-tool"].onPointerDownOnInteractionPoint(_e);
                return;
            }

            if (_e.altKey && clickedHandle.pointRef.ownerShapeElement.nodeName === 'path') {
                activeDocument.removePathPoints_undable([clickedHandle.pointRef]);
                activePage.focusedPoint = null;
                return;
            }

            if (clickedHandle.pointRef.isSelected) {
                if (_e.shiftKey) {
                    activeDocument.deselectPoint(clickedHandle.pointRef);
                    activePage.focusedPoint = null;
                } else {
                    clickedHandle.pointRef.editable = true; // dovrà mostrare i control points
                    activePage.focusedPoint = clickedHandle.pointRef;
                    activeDocument.showSelectionProperties();
                }
            } else {
                if (!_e.shiftKey)
                    activeDocument.deselectAllPoints();
                activeDocument.selectPoint(clickedHandle.pointRef);
                clickedHandle.pointRef.editable = true; // dovrà mostrare i control points
                activePage.focusedPoint = clickedHandle.pointRef;
                activeDocument.showSelectionProperties();
            }

            if (_e.target.classList.contains('resize')) {
                if (this.mode === 'round-corners') {
                    virtualEvent.segmentToConvert = clickedHandle.pointRef;
                    TOOLS["round-corners-tool"].initDrag(virtualEvent);
                } else {
                    TOOLS['translate-points-tool'].initDrag(virtualEvent);
                }
            } else if (_e.target.classList.contains('translate')) {
                TOOLS['translate-tool'].initDrag(virtualEvent);
            }

        } else {

            if (_e.target.classList.contains('resize')) {
                const ownerPoint = clickedHandle.pointRef.ownerPoint;
                const ownerShape = ownerPoint.ownerShapeElement;

                if (_e.altKey && ownerShape.nodeName === 'path') {
                    let newSegment;

                    if (ownerPoint.type === 'C') {
                        if (clickedHandle.pointRef.type === 'CTRL2') {
                            // elimino il ctrl point 2 lascio valido il ctrl 1
                            newSegment = ownerShape.createGeometryPoint_CURVETO_QUADRATIC(ownerPoint.controlPt1.x, ownerPoint.controlPt1.y, ownerPoint.x, ownerPoint.y);
                            newSegment.editable = true;
                        } else if (clickedHandle.pointRef.type === 'CTRL1') {
                            // elimino il ctrl point 1 lascio valido il ctrl 2
                            newSegment = ownerShape.createGeometryPoint_CURVETO_QUADRATIC(ownerPoint.controlPt2.x, ownerPoint.controlPt2.y, ownerPoint.x, ownerPoint.y);
                            newSegment.editable = true;
                        }
                    } else {
                        newSegment = ownerShape.createGeometryPoint_LINETO(ownerPoint.x, ownerPoint.y);
                        newSegment.editable = true;
                    }
                    activeDocument.replacePathPoint_undable(newSegment, ownerPoint);
                    return;
                }

                TOOLS['translate-control-points-tool'].setDraggableControlPointList(activeApplication.workspace.pointsInteraction.createDraggablePathControlPoint(clickedHandle.pointRef));
                TOOLS['translate-control-points-tool'].initDrag(virtualEvent);
            }

        }
    }

    onPointerDownOnPageBackground(_e) {
        activeApplication.workspace.pointsInteraction.mode = 'translate-points';
        TOOLS['selection-points-by-rect-area-tool'].initDrag(this.currentPenEvent);
    }

    onPointerDownOnElement(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        activeDocument.setFocusedPathSegmentPoint(null);

        if (this.clickedElement.nodeName === 'path' && this.currentPenEvent.segmentListAtPoint.length > 0) {
            if (!activeDocument.isElementSelected(this.clickedElement)) {
                if (_e.shiftKey) {
                    activePage.selectionList.push(this.clickedElement);
                    activeDocument.selectElementList(activePage.selectionList);
                    activeApplication.workspace.update();
                } else {
                    activeDocument.selectElementList([this.clickedElement]);
                    activeApplication.workspace.update();
                }
            }

            const segment = this.currentPenEvent.segmentListAtPoint[0];

            if (KEYBOARD_EVENT_MANAGER.cmdKeyPressed && _e.shiftKey && _e.altKey) {
                activeDocument.splitPathAtLocation_undable(this.clickedElement, segment);
                return;
            }

            if (_e.altKey) {
                activeDocument.addPathPointAtLocation_undable(this.clickedElement, segment);
                TOOLS["translate-points-tool"].initDrag(this.currentPenEvent);
                return;
            }

            const editablePointOfSegment = segment.pt2;
            editablePointOfSegment.previousSegment = segment.pt1;

            // se ho cliccato su un segmento appartenente all'oggetto cliccato ( quello in primo piano )
            if (this.clickedElement === editablePointOfSegment.ownerShapeElement) {
                activePage.focusedPoint = null;
                activeDocument.setFocusedPathSegmentPoint(editablePointOfSegment);

                if (editablePointOfSegment.type === 'C') {
                    TOOLS['translate-segment-c-tool'].initDrag(this.currentPenEvent);
                    return;
                } else if (editablePointOfSegment.type === 'L') {
                    TOOLS['translate-segment-l-tool'].initDrag(this.currentPenEvent);
                    return;
                } else if (editablePointOfSegment.type === 'A') {
                    TOOLS['translate-segment-a-tool'].initDrag(this.currentPenEvent);
                    return;
                }
            }

        }

        super.onPointerDownOnElement(_e);

    }

    onPointerDoubleClickOnElement() {
        if (this.clickedElement.nodeName === 'path' && this.clickedElement.dataset.type !== 'object') {
            activeApplication.setActiveTool('selection-tool');
            activeApplication.workspace.update();
        } else {
            super.onPointerDoubleClickOnElement();
        }
    }

    onKeyDown(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const selectionPointList = activePage.selectionPointList;
        const maxPointSelected = selectionPointList.length;

        const translationValue = activeDocument.preferences.moveStep * activePage.content.currentScale;

        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            if (maxPointSelected === 0) {
                super.onKeyDown(_e);
                return;
            }

            activeDocument.removePathPoints_undable(selectionPointList);

            // if(selectionPointList.length>0){
            //     activeDocument.removePathPoints_undable( selectionPointList );
            //     return;
            // }else
            // {
            //     COMMANDS.delete.execute();
            //     _e.preventDefault();
            //     _e.stopPropagation();
            // }

            break;
            // case 'X':
            //     console.log('X');
            //     if(activeApplication.workspace.pointsInteraction.mode==='round-corners')
            //     {
            //         activeApplication.workspace.pointsInteraction.mode='translate-points';
            //     }else{
            //         activeApplication.workspace.pointsInteraction.mode='round-corners';
            //     }
            //
            //     activeApplication.workspace.update();
            //
            //     break;
        case 'LEFT':

            if (maxPointSelected === 0) {
                super.onKeyDown(_e);
                return;
            }

            activeDocument.translateSelectedPointList_undable(-translationValue, 0, null, true);
            // if(  _e.altKey  )
            // {
            //     const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName( 'center-center' , GeometryUtils.getElementListGlobalBBox( activePage.selectionList ) );
            //     activeDocument.rotateElementList_undable( activePage.selectionList , -activeDocument.preferences.rotateStep , bboxPivotPosition );
            // }
            // else
            // {
            //     if( maxPointSelected>0 )activeDocument.translateSelectedPointList_undable( -translationValue , 0 , null, true);
            // }
            break;

        case 'UP':

            if (maxPointSelected === 0) {
                super.onKeyDown(_e);
                return;
            }

            activeDocument.translateSelectedPointList_undable(0, -translationValue, null, true);
            //if( maxPointSelected>0 )activeDocument.translateSelectedPointList_undable( 0 ,-translationValue, null, true);
            break;

        case 'RIGHT':

            if (maxPointSelected === 0) {
                super.onKeyDown(_e);
                return;
            }

            activeDocument.translateSelectedPointList_undable(translationValue, 0, null, true);

            // if( _e.altKey  )
            // {
            //     const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName( 'center-center' , GeometryUtils.getElementListGlobalBBox( activePage.selectionList ) );
            //     activeDocument.rotateElementList_undable( activePage.selectionList , activeDocument.preferences.rotateStep , bboxPivotPosition );
            // }
            // else
            // {
            //     if( maxPointSelected>0 ) activeDocument.translateSelectedPointList_undable( translationValue , 0 , null, true);
            // }
            break;

        case 'DOWN':

            if (maxPointSelected === 0) {
                super.onKeyDown(_e);
                return;
            }

            activeDocument.translateSelectedPointList_undable(0, translationValue, null, true);

            //if( maxPointSelected>0 )  activeDocument.translateSelectedPointList_undable( 0 , translationValue , null, true );
            break;
        default:
            break;
        }
    }

}

new SelectionPoints2D_tool('selection-points-tool', 'A');

class SelectionByRectArea2D_tool extends Base2D_tool{
    constructor(_name) {
        super(_name);
    }

    initDrag(_e) {
        this.pointA = _e;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e, true);
        this.pointB = _e;
        this.updateDrawingInteraction(_e);
    }

    onDragEnd(_e) {
        this.doSelection(_e);
    }

    updateDrawingInteraction(_e) {
        let x = Math.min(this.pointA.workspaceX, this.pointB.workspaceX);
        let y = Math.min(this.pointA.workspaceY, this.pointB.workspaceY);
        let w = Math.abs(this.pointB.workspaceX - this.pointA.workspaceX);
        let h = Math.abs(this.pointB.workspaceY - this.pointA.workspaceY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        const interactiveRectangle = activeApplication.workspace.interactiveSelectionRectArea;
        interactiveRectangle.updateGeometry(x, y, w, h);
        interactiveRectangle.classList.add('showed');
    }

    doSelection(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.hitRect = SVGUtils.createSVGRect(); // creo il rect per l'hit test

        const interactiveRectArea = activeApplication.workspace.interactiveSelectionRectArea;
        this.hitRect.x = interactiveRectArea.x.baseVal.value;
        this.hitRect.y = interactiveRectArea.y.baseVal.value;
        this.hitRect.width = interactiveRectArea.width.baseVal.value;
        this.hitRect.height = interactiveRectArea.height.baseVal.value;
        this.hitRect.left = this.hitRect.x;
        this.hitRect.top = this.hitRect.y;
        this.hitRect.right = this.hitRect.x + this.hitRect.width;
        this.hitRect.bottom = this.hitRect.y + this.hitRect.height;

        activeApplication.classList.add('selection-by-rect-area');
        const hitTestElementList = activePage.elementListFromIntersection(this.hitRect);
        activeApplication.classList.remove('selection-by-rect-area');

        if (hitTestElementList.length === 0) // se l'hit test non ha risultato
        {
            if (!_e.shiftKey)
                activeDocument.deselectAll(); // se shift non è premuto deseleziono tutto
            activeApplication.workspace.update(); // aggiorno lo stato visivo della selezione
            return;
        }

        const mainElementList = [];
        let currentElement;
        let max = hitTestElementList.length;
        let i;
        for (i = 0; i < max; i++) {
            currentElement = hitTestElementList[i].closest('.layer>*'); // ottengo l'elemento di primo livello nel LAYER
            //if(currentElement.isLocked()) continue;
            if (mainElementList.indexOf(currentElement) === -1)
                mainElementList.push(currentElement); // se non è stato già inserito lo inserisco in mainElementList
        }

        if (_e.shiftKey) {
            max = mainElementList.length;
            for (i = 0; i < max; i++) {
                currentElement = mainElementList[i];
                activeDocument.selectElement(currentElement, true);
                // if ( currentElement.isSelected() ) // se l'elemento è selezionato
                // {
                //     activePage.removeElementFromSelection(currentElement); // allora deselezionalo
                // }
                // else
                // {
                //     activePage.addElementToSelection(currentElement); // selezionalo
                // }
            }
        } else {

            activeDocument.selectElementList(mainElementList); // seleziona gli elementi di primo livello
        }

        activeApplication.workspace.update(); // aggiorno lo stato visivo della selezione
    }

}

new SelectionByRectArea2D_tool('selection-by-rect-area-tool');

class SelectionPointsByRectArea2D_tool extends SelectionByRectArea2D_tool{
    constructor(_name) {
        super(_name);
    }

    doSelection(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.hitRect = SVGUtils.createSVGRect(); // creo il rect per l'hit test

        const interactiveRectArea = activeApplication.workspace.interactiveSelectionRectArea;
        this.hitRect.x = interactiveRectArea.x.baseVal.value;
        this.hitRect.y = interactiveRectArea.y.baseVal.value;
        this.hitRect.width = interactiveRectArea.width.baseVal.value;
        this.hitRect.height = interactiveRectArea.height.baseVal.value;
        this.hitRect.left = this.hitRect.x;
        this.hitRect.top = this.hitRect.y;
        this.hitRect.right = this.hitRect.x + this.hitRect.width;
        this.hitRect.bottom = this.hitRect.y + this.hitRect.height;

        activeApplication.classList.add('selection-by-rect-area');
        const hitTestElementList = activePage.elementListFromIntersection(this.hitRect);
        activeApplication.classList.remove('selection-by-rect-area');

        if (hitTestElementList.length === 0) // se l'hit test non ha risultato
        {
            if (!_e.shiftKey)
                activeDocument.deselectAll(); // se shift non è premuto deseleziono tutto
            activeApplication.workspace.update(); // aggiorno lo stato visivo della selezione
            return;
        }

        if (_e.shiftKey) {
            for (let i = 0; i < hitTestElementList.length; i++)
                activeDocument.selectElement(hitTestElementList[i]); // aggiungo gli elementi alla selezione
        } else {
            activeDocument.selectElementList(hitTestElementList); // seleziona solo gli elementi contenuti nel risultato dell' Hit test
        }

        activeDocument.selectElementList(activeDocument.elementListAsMainElements(activePage.selectionList));

        //console.log( 'activePage.selectionList',activePage.selectionList );


        activeApplication.workspace.update(); // aggiorno lo stato visivo della selezione per creare i punti che dovrò selezionare dopo con l'hit test

        activeApplication.classList.add('point-selection-by-rect-area');

        const handleList = interactiveRectArea.parentElement.getIntersectionList(this.hitRect, null);

        let handle,
        i;
        const max = handleList.length;
        for (i = 0; i < max; i++) {
            //handle = handleList[i].parentElement.parentElement;
            handle = handleList[i].parentElement;
            if (handle.classList.contains('interaction-point')) {
                // seleziono visivamente e nel documento
                if (handle.pointRef.isSelected) {
                    handle.classList.remove('selected');
                    activeDocument.deselectPoint(handle.pointRef);
                } else {
                    handle.classList.add('selected');
                    activeDocument.selectPoint(handle.pointRef);
                }
            }
        }

        activeApplication.classList.remove('point-selection-by-rect-area');
    }

}

new SelectionPointsByRectArea2D_tool('selection-points-by-rect-area-tool');

class Pan2D_tool extends Base2D_tool{
    constructor() {
        super('pan-tool', 'H');
    }

    onPointerDown(_e) {
        activeApplication.activeDocument.pointerEventToCoords(_e);
        this.initDrag(_e);
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.pan(_e.workspaceX - this.previousWorkspaceX, _e.workspaceY - this.previousWorkspaceY);
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
    }

    onDragEnd() {
        activeApplication.workspace.update();
        activeApplication.workspace.updateOrigin();
    }

}

TOOLS['pan-tool'] = new Pan2D_tool();

class Zoom2D_tool extends Base2D_tool{
    constructor() {
        super('zoom-tool', 'Z');
    }

    onPointerDown(_e) {
        activeApplication.activeDocument.pointerEventToCoords(_e);
        this.startPointEvent = _e;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.startPointEvent);
            return;
        }

        this.initDrag(_e);
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e, true);
        //activeDocument.pan ( _e.workspaceX-this.previousWorkspaceX, _e.workspaceY-this.previousWorkspaceY );
        const scale = Math.abs(1 + (_e.workspaceY - this.previousWorkspaceY) * (1 / 200));
        activeDocument.zoom(scale, this.startPointEvent.workspaceX, this.startPointEvent.workspaceY);
        this.previousWorkspaceY = _e.workspaceY;
    }

    onDragEnd() {
        activeApplication.workspace.update();
        activeApplication.workspace.updateOrigin();
    }

}

TOOLS['zoom-tool'] = new Zoom2D_tool();

class TranslateOrigin_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);

        if (Math.abs(_e.contentX) < _e.snapDistance)
            _e.contentX = 0;
        if (Math.abs(_e.contentY) < _e.snapDistance)
            _e.contentY = 0;

        activeDocument.setOrigin(_e.contentX, _e.contentY);
    }

    onDragEnd() {
        activeApplication.workspace.update();
    }
}

new TranslateOrigin_tool("translate-origin-tool");

class Translate2D_tool extends Base2D_tool{
    constructor() {
        super('translate-tool');
    }

    initDrag(_e, _onBeforeStartDragFunction) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        this.clickedElement = _e.elementAtPoint || null;
        this.createUndoRedoActions = true;
        XOS.initDragFunctions(this, _e, _onBeforeStartDragFunction);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        // this.angularSegmentSnapList =  activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX,this.startPenEvent.contentY));
    }

    onDragStart(_e) {

        if (_e.altKey) {
            COMMANDS.duplicate.execute();
            this.createUndoRedoActions = false;
        }

        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);

        activeDocument.elementFromPointerEvent(_e, true);
        //_e.customSegmentList = this.angularSegmentSnapList;// le guide
        if (_e.shiftKey)
            activeApplication.workspace.snapInteraction2D.applySnapTo_angle(_e);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        activeDocument.translateElementList(activeApplication.workspace.selectionPreviews.children, _e.workspaceX - this.previousWorkspaceX, _e.workspaceY - this.previousWorkspaceY, false);
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        function updateTransform() {
            const previewList = activeApplication.workspace.selectionPreviews.children;
            const max = previewList.length;
            let element;
            for (let i = 0; i < max; i++) {
                element = previewList[i].elementRef;
                element.getTransform().setMatrix(element.globalMatrixToLocalMatrix(previewList[i].getTransform().matrix));
            }
        }

        if (this.createUndoRedoActions) {
            const undoAction = new UndoRedoAction('translate');
            const redoAction = new UndoRedoAction('translate');
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const elementList = activePage.selectionList;

            undoAction.createAttributeSnapshot(elementList, 'transform');
            updateTransform();
            redoAction.createAttributeSnapshot(elementList, 'transform');

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(elementList);
            };
        } else {
            updateTransform();
        }

        activeDocument.onChange();
        activeApplication.workspace.update();
        activeApplication.workspace.snapInteraction2D.reset();

        const fromPoint = {
            contentX: this.startPenEvent.contentX,
            contentY: this.startPenEvent.contentY,
        }

        const toPoint = {
            contentX: activeApplication.workspace.snapInteraction2D.lastEvent.contentX,
            contentY: activeApplication.workspace.snapInteraction2D.lastEvent.contentY,
        }

        COMMANDS.duplicate.lastTransformAction = function (_elementList) {
            activeDocument.pageContentToWorkspaceCoords(fromPoint);
            activeDocument.pageContentToWorkspaceCoords(toPoint);
            activeDocument.translateElementList(_elementList, toPoint.workspaceX - fromPoint.workspaceX, toPoint.workspaceY - fromPoint.workspaceY);
        };

    }

}

TOOLS['translate-tool'] = new Translate2D_tool();

class Scale2D_tool extends Base2D_tool{
    constructor() {
        super('scale-tool');
        this.scaleX = 1;
        this.scaleY = 1;
        this.scaleAxis = null;
        this.isLocalMode = null;
        this.centerOfScaling = SVGUtils.createSVGPoint();
        this.alternateCenterOfScaling = SVGUtils.createSVGPoint();
        this.useTransformPreviews = true;
        this.mantainAspectRatio = false;
    }

    initDrag(_e) {
        this.pointerDownWorkspaceX = _e.workspaceX;
        this.pointerDownWorkspaceY = _e.workspaceY;
        this.centerOfScaling.x = _e.centerOfScaling.x;
        this.centerOfScaling.y = _e.centerOfScaling.y;
        this.alternateCenterOfScaling.x = _e.alternateCenterOfScaling.x;
        this.alternateCenterOfScaling.y = _e.alternateCenterOfScaling.y;
        this.scaleAxis = _e.scaleAxis;
        this.isLocalMode = _e.isLocalMode;
        this.mantainAspectRatio = (_e.mantainAspectRatio === true);
        this.createUndoRedoActions = true;
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (_e.altKey) {
            COMMANDS.duplicate.execute();
            this.createUndoRedoActions = false;
        }

        activeApplication.workspace.removeInteractions();

        this.elementListToScale = activeApplication.workspace.selectionPreviews.children;
        //this.elementListToScale = Array.from(ACCESSORIES.selectionPreviews.children) ;
        // creo il rettangolo se la trasformazione e globale
        if (this.isLocalMode === false) {
            const bbox = GeometryUtils.getElementListGlobalBBox(activeDocument.activePage.selectionList);
            const rect = SVGUtils.createRect(bbox.x, bbox.y, bbox.width, bbox.height); // verrà scalato anche questo ( non avrà un elementRef )
            rect.setAttribute('fill', 'none');
            rect.setAttribute('stroke', '#0047FF');
            rect.setAttribute('vector-effect', 'non-scaling-stroke');
            rect.setAttribute('stroke-dasharray', '2');
            activeApplication.workspace.selectionPreviews.appendChild(rect);
        }

        let element;
        const max = this.elementListToScale.length;
        for (let i = 0; i < max; i++) {
            element = this.elementListToScale[i];
            element.storedGlobalMatrix = element.getCTM();
        }

    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        //_e.customSegmentList = this.angularSegmentSnapList;// le guide
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        this.activeCenterOfScaling = this.centerOfScaling;
        if (_e.altKey)
            this.activeCenterOfScaling = this.alternateCenterOfScaling;
        let mantainAspectRatioFlag = this.mantainAspectRatio;

        let interactiveCenterOfScaling = this.activeCenterOfScaling;

        if (this.isLocalMode) {
            const elementToScale = this.elementListToScale[0];
            const localMatrix = elementToScale.storedGlobalMatrix.inverse();
            const innerPointerDownPos = SVGUtils.createSVGPoint(this.pointerDownWorkspaceX, this.pointerDownWorkspaceY).matrixTransform(localMatrix);
            const innerPointerMovePos = SVGUtils.createSVGPoint(_e.workspaceX, _e.workspaceY).matrixTransform(localMatrix);
            const innerCenterOfScaling = this.activeCenterOfScaling.matrixTransform(localMatrix);

            this.scaleX = (innerPointerMovePos.x - innerCenterOfScaling.x) / (innerPointerDownPos.x - innerCenterOfScaling.x);
            this.scaleY = (innerPointerMovePos.y - innerCenterOfScaling.y) / (innerPointerDownPos.y - innerCenterOfScaling.y);
            if (elementToScale.dataset.mantainAspectRatio === 'true') {
                mantainAspectRatioFlag = true
            } else {
                mantainAspectRatioFlag = false;
            }
            interactiveCenterOfScaling = innerCenterOfScaling;
        } else {
            this.scaleX = (_e.workspaceX - this.activeCenterOfScaling.x) / (this.pointerDownWorkspaceX - this.activeCenterOfScaling.x);
            this.scaleY = (_e.workspaceY - this.activeCenterOfScaling.y) / (this.pointerDownWorkspaceY - this.activeCenterOfScaling.y);
        }

        if (this.scaleAxis === 'XY' && (mantainAspectRatioFlag || _e.shiftKey)) {
            if (Math.abs(this.scaleX) > Math.abs(this.scaleY)) {
                this.scaleY = this.scaleX;
            } else {
                this.scaleX = this.scaleY;
            }
        } else if (this.scaleAxis === 'X') {
            if (mantainAspectRatioFlag || _e.shiftKey) {
                this.scaleY = this.scaleX
            } else {
                this.scaleY = 1;
            }
        } else if (this.scaleAxis === 'Y') {
            if (mantainAspectRatioFlag || _e.shiftKey) {
                this.scaleX = this.scaleY
            } else {
                this.scaleX = 1;
            }
        }

        if ((this.scaleX === Infinity) || (this.scaleX === -Infinity) || isNaN(this.scaleX))
            this.scaleX = 1;
        if ((this.scaleY === Infinity) || (this.scaleY === -Infinity) || isNaN(this.scaleY))
            this.scaleY = 1;

        activeDocument.scaleElementList(this.elementListToScale, this.scaleX, this.scaleY, interactiveCenterOfScaling, this.isLocalMode);

    }

    onDragEnd() {
        const activeDocument = activeApplication.activeDocument;
        const elementList = activeDocument.activePage.selectionList;

        if (this.createUndoRedoActions) {
            activeDocument.scaleElementList_undable(elementList, this.scaleX, this.scaleY, SVGUtils.createSVGPoint(this.activeCenterOfScaling.x, this.activeCenterOfScaling.y), this.isLocalMode);
        } else {
            activeDocument.scaleElementList(elementList, this.scaleX, this.scaleY, SVGUtils.createSVGPoint(this.activeCenterOfScaling.x, this.activeCenterOfScaling.y), this.isLocalMode);

            const scaleOptions = {};
            scaleOptions.effectScale = Math.sqrt(this.scaleX * this.scaleX + this.scaleY * this.scaleY) / Math.sqrt(2);
            scaleOptions.scaleStrokeAndEffects = activeDocument.preferences.scaleStrokeAndEffects;
            scaleOptions.scaleText = activeDocument.preferences.scaleText;
            if (this.isLocalMode && elementList[0].nodeName === 'text')
                scaleOptions.scaleText = false;

            activeDocument.normalizeScaleElementList(elementList, scaleOptions);
            activeApplication.workspace.update();
            activeDocument.onChange();
        }

        activeApplication.workspace.snapInteraction2D.reset();

        const centerOfScaling = {
            workspaceX: this.activeCenterOfScaling.x,
            workspaceY: this.activeCenterOfScaling.y
        }
        activeDocument.workspaceToPageContentCoords(centerOfScaling);

        const scaleX = this.scaleX;
        const scaleY = this.scaleY;
        const isLocalMode = this.isLocalMode;

        COMMANDS.duplicate.lastTransformAction = function (_elementList) {
            activeDocument.pageContentToWorkspaceCoords(centerOfScaling);
            activeDocument.scaleElementList(_elementList, scaleX, scaleY, SVGUtils.createSVGPoint(centerOfScaling.workspaceX, centerOfScaling.workspaceY), false);

            const scaleOptions = {};
            scaleOptions.effectScale = Math.sqrt(scaleX * scaleX + scaleY * scaleY) / Math.sqrt(2);
            scaleOptions.scaleStrokeAndEffects = activeDocument.preferences.scaleStrokeAndEffects;
            scaleOptions.scaleText = activeDocument.preferences.scaleText;
            if (isLocalMode && elementList[0].nodeName === 'text')
                scaleOptions.scaleText = false;
            activeDocument.normalizeScaleElementList(_elementList, scaleOptions);
        }

    }

}

TOOLS['scale-tool'] = new Scale2D_tool();

class Rotate2D_tool extends Base2D_tool{
    constructor() {
        super('rotate-tool');
    }

    initDrag(_e) {
        this.pointerDownWorkspaceX = _e.workspaceX;
        this.pointerDownWorkspaceY = _e.workspaceY;
        //this.isLocalMode=_e.isLocalMode;
        this.centerOfRotation = _e.centerOfRotation;
        this.createUndoRedoActions = true;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (_e.altKey) {
            COMMANDS.duplicate.execute();
            this.createUndoRedoActions = false;
        }

        activeApplication.workspace.removeInteractions();

        this.elementListToRotate = activeApplication.workspace.selectionPreviews.children;
        let element;
        const max = this.elementListToRotate.length;
        for (let i = 0; i < max; i++) {
            element = this.elementListToRotate[i];
            element.storedGlobalMatrix = element.getCTM();
        }

        this.startAngle = GeometryUtils.getAngleBetweenPoints({
            x: this.pointerDownWorkspaceX,
            y: this.pointerDownWorkspaceY
        }, this.centerOfRotation);

        activeApplication.workspace.snapInteraction2D.reset();

        // trasport il centro da workspace a content
        const contentMatrix = activeDocument.activePage.content.getTransform().matrix;
        this.centerOfRotationInContentSpace = SVGUtils.createSVGPoint((this.centerOfRotation.x - contentMatrix.e) / activeDocument.activePage.content.currentScale, (this.centerOfRotation.y - contentMatrix.f) / activeDocument.activePage.content.currentScale);
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(this.centerOfRotationInContentSpace);

    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        const centerOfRot = this.centerOfRotation;
        _e.startPenEvent = {
            workspaceX: centerOfRot.x,
            workspaceY: centerOfRot.y
        }; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        let snapAngle = null;

        //if(_e.shiftKey) snapAngle = activeDocument.preferences.snap.snapAngleList[0]*(Math.PI/180);

        this.rotationValue = GeometryUtils.getAngleBetweenPoints({
            x: _e.workspaceX,
            y: _e.workspaceY
        }, this.centerOfRotation, snapAngle, this.startAngle);
        activeDocument.rotateElementList(this.elementListToRotate, this.rotationValue / (Math.PI / 180), this.centerOfRotation);
    }

    onDragEnd() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        function updateTransform() {
            const previewList = activeApplication.workspace.selectionPreviews.children;
            const max = previewList.length;
            let element;
            for (let i = 0; i < max; i++) {
                element = previewList[i].elementRef;
                element.getTransform().setMatrix(element.globalMatrixToLocalMatrix(previewList[i].getTransform().matrix));
            }
        }

        if (this.createUndoRedoActions) {
            const undoAction = new UndoRedoAction('rotate');
            const redoAction = new UndoRedoAction('rotate');
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const elementList = activePage.selectionList;
            undoAction.createAttributeSnapshot(elementList, 'transform');
            updateTransform();
            redoAction.createAttributeSnapshot(elementList, 'transform');

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(elementList);
            };
        } else {
            updateTransform();
        }

        activeDocument.onChange();
        activeApplication.workspace.update();
        activeApplication.workspace.snapInteraction2D.reset();

        const centerOfRotation = {
            contentX: this.centerOfRotationInContentSpace.x,
            contentY: this.centerOfRotationInContentSpace.y
        }
        const rotationValue = this.rotationValue;

        COMMANDS.duplicate.lastTransformAction = function (_elementList) {
            activeDocument.pageContentToWorkspaceCoords(centerOfRotation);
            activeDocument.rotateElementList(_elementList, rotationValue / (Math.PI / 180), {
                x: centerOfRotation.workspaceX,
                y: centerOfRotation.workspaceY
            });
        }

    }

}

TOOLS['rotate-tool'] = new Rotate2D_tool();

class RotateByPivot_tool extends Base2D_tool {

    constructor(_toolName, _shortcut) {
        super(_toolName, _shortcut);
        this.delegateRotateTool = null;
    }

    onActivate() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return;

        if (activePage.selectionPointList.length > 0) {
            this.selectionMode = 'POINT_SELECTION';
            this.delegateRotateTool = TOOLS['rotate-points-tool'];
        } else {
            this.selectionMode = 'ELEMENT_SELECTION';
            this.delegateRotateTool = TOOLS['rotate-tool'];
        }

        const globalBox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
        const centerInContent = {
            workspaceX: globalBox.center.x,
            workspaceY: globalBox.center.y
        };
        activeDocument.workspaceToPageContentCoords(centerInContent);
        activeApplication.workspace.rotateByPivotInteraction.centerOfRotationInContent = centerInContent;
        super.onActivate();

    }

    showInteraction() {
        if (this.selectionMode === 'POINT_SELECTION') {
            activeApplication.workspace.pointsInteraction.show();
        }
        activeApplication.workspace.rotateByPivotInteraction.show();
    };

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        this.currentPenEvent.centerOfRotation = activeApplication.workspace.rotateByPivotInteraction.pivot.getCTM().getTranslation()
            this.delegateRotateTool.initDrag(this.currentPenEvent);
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        this.currentPenEvent = _e;
    }

}

new RotateByPivot_tool("rotate-by-pivot-tool", 'G');

class ScaleByPivot_tool extends Base2D_tool {

    constructor(_toolName, _shortcut) {
        super(_toolName, _shortcut);
        this.delegateScaleTool = null;
    }

    onActivate() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return;

        if (activePage.selectionPointList.length > 0) {
            this.selectionMode = 'POINT_SELECTION';
            this.delegateScaleTool = TOOLS['scale-points-tool'];
        } else {
            this.selectionMode = 'ELEMENT_SELECTION';
            this.delegateScaleTool = TOOLS['scale-tool'];
        }

        const globalBox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);
        const centerInContent = {
            workspaceX: globalBox.center.x,
            workspaceY: globalBox.center.y
        };
        activeDocument.workspaceToPageContentCoords(centerInContent);
        activeApplication.workspace.scaleByPivotInteraction.centerOfScaleInContent = centerInContent;
        super.onActivate();

    }

    showInteraction() {
        if (this.selectionMode === 'POINT_SELECTION') {
            activeApplication.workspace.pointsInteraction.show();
        }
        activeApplication.workspace.scaleByPivotInteraction.show();
    };

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        this.currentPenEvent.centerOfScaling = activeApplication.workspace.scaleByPivotInteraction.pivot.getCTM().getTranslation();
        this.currentPenEvent.alternateCenterOfScaling = this.currentPenEvent.centerOfScaling;
        this.currentPenEvent.scaleAxis = 'XY';
        this.currentPenEvent.isLocalMode = false;
        //this.currentPenEvent.mantainAspectRatio = activeApplication.activeDocument.preferences.mantainAspectRatio;
        this.currentPenEvent.mantainAspectRatio = false;

        this.delegateScaleTool.initDrag(this.currentPenEvent);
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        this.currentPenEvent = _e;
    }

}

new ScaleByPivot_tool("scale-by-pivot-tool", 'K');

class PerspectiveDeform_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let sourceElementList = XOS.getFilteredElementListByNodeName(activePage.selectionList, 'path');
        if (sourceElementList.length === 0) {
            DIALOGS['alert-dialog'].open(localString('Path element required'), localString('Select paths elements or convert elements to path before use this tool.'));
            return;
        }

        // activePage.createElementListPreviews(null,activePage.selectionList);
        activeApplication.workspace.perspectiveDeformInteraction.show();
    };

    onWheelChange(_e) {}

}

new PerspectiveDeform_tool("perspective-deform-tool");

class EditGradientPoints_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 1) {

            const activeGraphicSide = activeDocument.fillAndStrokeManager.focusedGraphicSideName;

            if (activeGraphicSide === 'fill' && (activeDocument.fillAndStrokeManager.fillFillingType === 'linearGradient' || activeDocument.fillAndStrokeManager.fillFillingType === 'radialGradient')) {
                activeApplication.workspace.gradientInteraction.show();
            } else if (activeGraphicSide === 'stroke' && (activeDocument.fillAndStrokeManager.strokeFillingType === 'linearGradient' || activeDocument.fillAndStrokeManager.strokeFillingType === 'radialGradient')) {
                activeApplication.workspace.gradientInteraction.show();
            }
        }

    };

    onPointerDown(_e) {
        super.onPointerDown(_e);
        if (_e.isDoubleClick)
            return;

        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(_e);
        }

    }

    onPointerUp(_e) {
        super.onPointerUp(_e);

        if (_e.isDoubleClick)
            return;

        const activeDocument = activeApplication.activeDocument;

        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);

        this.clickedElement = _e.elementAtPoint;

        if (this.clickedElement && this.clickedElement.nodeName !== 'svg') {
            if (activeDocument.preferences.selectMainNodes)
                this.clickedElement = this.clickedElement.closest('.layer>*');

            if (this.clickedElement && this.clickedElement.isLocked())
                return;
            activeDocument.selectElementList([this.clickedElement]);
            activeApplication.workspace.update();
        }

    }

}

new EditGradientPoints_tool("edit-gradient-points-tool");

class EyeDropper_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        //if( _e.elementAtPoint && _e.elementAtPoint.isLocked()  ) _e.elementAtPoint = null;
        activeApplication.workspace.snapInteraction2D.lastEvent = null; // non deve creare ne smart points ne smart guides
        this.currentPenEvent = _e;
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        if (_e.isDoubleClick)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (this.currentPenEvent.elementAtPoint) {
            const sourceElement = this.currentPenEvent.elementAtPoint.getMainElement();

            const sourceProperties = {};

            if (this.currentPenEvent.segmentListAtPoint.length > 0 || this.currentPenEvent.vertexAtPoint) {
                sourceProperties['stroke'] = sourceElement.getAttribute('stroke') || 'none';
                sourceProperties['stroke-width'] = sourceElement.getAttribute('stroke-width') || '0';
                sourceProperties['stroke-dasharray'] = sourceElement.getAttribute('stroke-dasharray') || '';
            } else {
                sourceProperties['fill'] = sourceElement.getAttribute('fill') || 'none';
            }

            //console.log('sourceProperties',sourceProperties);

            activeDocument.setAttributeElementList_undable(activePage.selectionList, sourceProperties);
            activeDocument.showSelectionProperties();
        }
    }

}

new EyeDropper_tool("eye-dropper-tool");

class Filling_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        //if( _e.elementAtPoint && _e.elementAtPoint.isLocked()  ) _e.elementAtPoint = null;
        activeApplication.workspace.snapInteraction2D.lastEvent = null; // non deve creare ne smart points ne smart guides
        this.currentPenEvent = _e;
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        if (_e.isDoubleClick)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (this.currentPenEvent.elementAtPoint) {
            const targetElement = this.currentPenEvent.elementAtPoint.getMainElement();
            const targetProperties = {};

            if (this.currentPenEvent.segmentListAtPoint.length > 0 || this.currentPenEvent.vertexAtPoint) {
                targetProperties['stroke'] = activeDocument.fillAndStrokeManager['stroke'];
                targetProperties['stroke-opacity'] = activeDocument.fillAndStrokeManager['stroke-opacity'];
                targetProperties['stroke-width'] = activeDocument.fillAndStrokeManager['stroke-width'];
                targetProperties['stroke-linecap'] = activeDocument.fillAndStrokeManager['stroke-linecap'];
                targetProperties['stroke-linejoin'] = activeDocument.fillAndStrokeManager['stroke-linejoin'];
            } else {
                targetProperties['fill'] = activeDocument.fillAndStrokeManager['fill'];
            }

            activeDocument.setAttributeElementList_undable([targetElement], targetProperties, false);
            activeDocument.showSelectionProperties();

        }
    }

}

new Filling_tool("filling-tool");

class TranslatePoints_tool extends Base2D_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        this.clickedElement = _e.elementAtPoint || null;
        this.createUndoRedoActions = true;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
    }

    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        //this.initTransformDataPointList();
        this.transformDataPointList = activeDocument.createTransformDataPointList();
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        //this.translateTransformDataPointList( this.transformDataPointList ,  _e.workspaceX-this.previousWorkspaceX,  _e.workspaceY-this.previousWorkspaceY  );
        activeDocument.translateTransformDataPointList(this.transformDataPointList, _e.workspaceX - this.previousWorkspaceX, _e.workspaceY - this.previousWorkspaceY);

        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const selectedElementList = activePage.selectionList;

        undoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        this.swapTransformDataPointListFromInteractionElementToElement();

        redoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

    // initTransformDataPointList()
    // {
    // 	//this.transformDataPointList = this.getSelectedTransformablePointData();
    // 	this.transformDataPointList = activeApplication.activeDocument.getSelectedTransformablePointData();
    //
    // 	let transformData, element;
    // 	const max = this.transformDataPointList.length;
    //
    // 	for( let i = 0; i < max; i++)
    // 	{
    // 		transformData = this.transformDataPointList[i];
    // 		element = transformData.element;
    // 		element.selectionPreview.geometryPointList = element.getGeometryPointList(); // sposto i punti in interaction element
    // 		element.setGeometryPointList( element.selectionPreview.cloneGeometryPointList() ); // clono i punti nell'elemento originale (serviranno solo allo snap a se stesso )
    // 	}
    //
    // };


    swapTransformDataPointListFromInteractionElementToElement() {
        let transformData,
        element;
        const max = this.transformDataPointList.length;

        for (let i = 0; i < max; i++) {
            transformData = this.transformDataPointList[i];
            element = transformData.element;
            element.geometryPointList = element.selectionPreview.getGeometryPointList(); // ripristino i punti da interactive element a element
            element.selectionPreview = null;
            element.render();
        }
    };

}

new TranslatePoints_tool("translate-points-tool");

class TranslateSegment_L_tool extends TranslatePoints_tool {

    constructor(_toolName) {
        super(_toolName);
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
    }

    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.selectPointList([activePage.focusedPathSegmentPoint.previousSegment, activePage.focusedPathSegmentPoint]);
        super.onDragStart(_e);
    };

    onDragEnd(_e) {
        activeApplication.activeDocument.deselectAllPoints();
        super.onDragEnd(_e);
    };

}

new TranslateSegment_L_tool("translate-segment-l-tool");

class TranslateSegment_C_tool extends TranslatePoints_tool {

    constructor() {
        super();
        this.cubicCurveSegmentTarget = null;
        this.weight = 0;
        this.t = 0;
        this.startControlPoint1 = {
            x: 0,
            y: 0
        };
        this.startControlPoint2 = {
            x: 0,
            y: 0
        };
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
    }

    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        this.initTransformDataPointList();
    }

    initTransformDataPointList() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.editablePath = activePage.focusedElement;
        this.cubicCurveSegmentTarget = activePage.focusedPathSegmentPoint;

        this.startControlPoint1.x = this.cubicCurveSegmentTarget.controlPt1.x;
        this.startControlPoint1.y = this.cubicCurveSegmentTarget.controlPt1.y;
        this.startControlPoint2.x = this.cubicCurveSegmentTarget.controlPt2.x;
        this.startControlPoint2.y = this.cubicCurveSegmentTarget.controlPt2.y;

        this.t = this.startPenEvent.segmentListAtPoint[0].pointOnSegment.t;

        if (this.t === 1)
            this.t = .9;
        else if (this.t === 0)
            this.t = .1;

        let weight,
        t = this.t;
        if (t <= 1.0 / 6.0)
            weight = 0;
        else if (t <= 0.5)
            weight = (Math.pow((6 * t - 1) / 2.0, 3)) / 2;
        else if (t <= 5.0 / 6.0)
            weight = (1 - Math.pow((6 * (1 - t) - 1) / 2.0, 3)) / 2 + 0.5;
        else
            weight = 1;

        this.weight = weight;
        if (this.weight === 1)
            this.weight = .9;
        else if (this.weight === 0)
            this.weight = .1;

        this.ctrlPt1_offset = ((1 - this.weight) / (3 * t * (1 - t) * (1 - t)));
        this.ctrlPt2_offset = (this.weight / (3 * t * t * (1 - t)));

        this.startDragOriginInLocal = this.editablePath.globalToLocal(this.previousWorkspaceX, this.previousWorkspaceY);

        this.transformDataPointList = [];
        const transformData = {
            element: this.editablePath,
            pointDataList: [{
                    point: this.cubicCurveSegmentTarget.controlPt1,
                    values: {
                        x: this.cubicCurveSegmentTarget.controlPt1.x,
                        y: this.cubicCurveSegmentTarget.controlPt1.y
                    }
                }, {
                    point: this.cubicCurveSegmentTarget.controlPt2,
                    values: {
                        x: this.cubicCurveSegmentTarget.controlPt2.x,
                        y: this.cubicCurveSegmentTarget.controlPt2.y
                    }
                }
            ]
        };
        this.transformDataPointList.push(transformData);

        this.editablePath.selectionPreview.geometryPointList = this.editablePath.getGeometryPointList(); // sposto i punti in interaction element
        this.editablePath.setGeometryPointList(this.editablePath.selectionPreview.cloneGeometryPointList()); // clono i punti nell'elemento originale (serviranno solo allo snap a se stesso )
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        if (!this.cubicCurveSegmentTarget)
            return;

        const currentPenPositionInLocal = this.editablePath.globalToLocal(_e.workspaceX, _e.workspaceY);

        const translateX = currentPenPositionInLocal.x - this.startDragOriginInLocal.x;
        const translateY = currentPenPositionInLocal.y - this.startDragOriginInLocal.y;

        this.cubicCurveSegmentTarget.controlPt1.x = this.startControlPoint1.x + translateX * this.ctrlPt1_offset;
        this.cubicCurveSegmentTarget.controlPt1.y = this.startControlPoint1.y + translateY * this.ctrlPt1_offset;

        this.cubicCurveSegmentTarget.controlPt2.x = this.startControlPoint2.x + translateX * this.ctrlPt2_offset;
        this.cubicCurveSegmentTarget.controlPt2.y = this.startControlPoint2.y + translateY * this.ctrlPt2_offset;

        this.editablePath.selectionPreview.renderRequest();
    }

    onDragEnd(_e) {
        activeApplication.activeDocument.deselectAllPoints();
        super.onDragEnd(_e);
    };

}

TOOLS["translate-segment-c-tool"] = new TranslateSegment_C_tool();

class TranslateSegment_A_tool {

    constructor() {
        this.arcSegmentTarget = null;
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        console.log('this.startPenEvent', this.startPenEvent);
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.arcSegmentTarget = activePage.focusedPathSegmentPoint;
        this.editablePath = this.startPenEvent.elementAtPoint;
        this.selectionPreview = this.editablePath.selectionPreview;
    }

    onDragStart(_e) {
        this.selectionPreview.geometryPointList = this.editablePath.getGeometryPointList(); // sposto i punti in interaction element
        this.editablePath.setGeometryPointList(this.selectionPreview.cloneGeometryPointList()); // clono i punti nell'elemento originale (serviranno solo allo snap a se stesso )
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        //activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        const currentPenPositionInLocal = this.editablePath.globalToLocal(_e.workspaceX, _e.workspaceY);

        const startPt = this.startPenEvent.segmentListAtPoint[0].pt1;
        const endPt = this.startPenEvent.segmentListAtPoint[0].pt2;
        this.selectionPreview.createGeometryPoint_ARCTO_by_3Points(startPt, endPt, currentPenPositionInLocal, this.arcSegmentTarget);

        // const distance = currentPenPositionInLocal.getDistanceFromPoint( SVGUtils.createSVGPoint(this.startPenEvent.localX,this.startPenEvent.localY));
        // //
        //  console.log(this.startPenEvent.segmentListAtPoint[0].radius+distance);
        //
        //
        //this.arcSegmentTarget.rx = this.arcSegmentTarget.ry = this.startRadius+distance;
        //this.arcSegmentTarget.rx = this.arcSegmentTarget.ry = this.startPenEvent.segmentListAtPoint[0].radius+distance;
        //
        //

        this.selectionPreview.renderRequest();
    }

    onDragEnd(_e) {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot([this.editablePath], 'd');

        this.editablePath.setGeometryPointList(this.selectionPreview.getGeometryPointList());
        this.editablePath.render();

        redoAction.createAttributeSnapshot([this.editablePath], 'd');

        const path = this.editablePath;

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();

    };

}

TOOLS["translate-segment-a-tool"] = new TranslateSegment_A_tool();

class TranslateControlPoints_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.draggableControlPointList = null;
    }

    setDraggableControlPointList(_draggableControlPointList) {
        this.draggableControlPointList = _draggableControlPointList;
    }

    initTransformDataPointList() {
        this.transformDataPointList = [];
        this.editatedPath = this.draggableControlPointList[0].ownerPoint.ownerShapeElement;
        const transformData = {
            element: this.editatedPath,
            pointDataList: []
        };
        this.transformDataPointList.push(transformData);

        for (let i = 0; i < this.draggableControlPointList.length; i++)
            transformData.pointDataList.push({
                point: this.draggableControlPointList[i],
                values: {
                    x: this.draggableControlPointList[i].x,
                    y: this.draggableControlPointList[i].y
                }
            });

        this.editatedPath.selectionPreview.geometryPointList = this.editatedPath.getGeometryPointList(); // sposto i punti in interaction element
        this.editatedPath.setGeometryPointList(this.editatedPath.selectionPreview.cloneGeometryPointList()); // clono i punti nell'elemento originale (serviranno solo allo snap a se stesso )
    };

    isSmoothedCurve(_center, _previousControlPoint, _nextControlPoint) {
        const x1 = _previousControlPoint.x - _center.x;
        const y1 = _previousControlPoint.y - _center.y;

        const x2 = _nextControlPoint.x - _center.x;
        const y2 = _nextControlPoint.y - _center.y;

        const m1 = y1 / x1;
        const m2 = y2 / x2;

        if (x1 === x2)
            return true;
        if (y1 === y2)
            return true;
        if (Math.abs(m1 - m2) < .1)
            return true;
        return false;
    };

    swapTransformDataPointListFromInteractionElementToElement() {
        let transformData,
        element;
        const max = this.transformDataPointList.length;

        for (let i = 0; i < max; i++) {
            transformData = this.transformDataPointList[i];
            element = transformData.element;

            element.geometryPointList = element.selectionPreview.geometryPointList; // ripristino i punti da interactive element a element
            element.selectionPreview = null;
            element.render();
        }
    };

    initDrag(_e, _onBeforeStartDragFunction) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        XOS.initDragFunctions(this, _e, _onBeforeStartDragFunction);

    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
        if (this.startPenEvent)
            activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        this.initTransformDataPointList();

        this.smoothCurve = false;

        if (this.draggableControlPointList.length === 2) {
            const draggedControlPoint = this.draggableControlPointList[0];
            const oppositeControlPoint = this.draggableControlPointList[1];
            let center;
            if (draggedControlPoint.type === 'CTRL1') {
                center = oppositeControlPoint.ownerPoint;
            } else {
                center = draggedControlPoint.ownerPoint;
            }
            this.smoothCurve = this.isSmoothedCurve(center, draggedControlPoint, oppositeControlPoint);
        }

    }

    onDrag(_e) {

        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        _e.dontUseSnapToAngle = true;
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        const draggedControlPoint = this.draggableControlPointList[0];
        const positionInLocal = draggedControlPoint.ownerPoint.ownerShapeElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY);
        draggedControlPoint.x = positionInLocal.x;
        draggedControlPoint.y = positionInLocal.y;

        if (this.draggableControlPointList.length === 2) {
            let smooth = this.smoothCurve;

            //if( _e.shiftKey ) smooth=false;
            if (_e.shiftKey && (!this.reflectOppositeControlPoint))
                smooth = false;

            if (smooth) {
                const oppositeControlPoint = this.draggableControlPointList[1];
                let center;
                if (draggedControlPoint.type === 'CTRL1') {
                    center = oppositeControlPoint.ownerPoint;
                } else {
                    center = draggedControlPoint.ownerPoint;
                }

                // 	creo il vettore normalizzato che va dal centro verso il ctrl point draggato
                const vector = SVGUtils.createSVGPoint(center.x - draggedControlPoint.x, center.y - draggedControlPoint.y);
                const normalizedVector = vector.normalize();
                const oppositeVector = SVGUtils.createSVGPoint(oppositeControlPoint.x, oppositeControlPoint.y);
                console.log('reflectOppositeControlPoint', this.reflectOppositeControlPoint);
                if (_e.altKey || this.reflectOppositeControlPoint) {
                    oppositeControlPoint.x = center.x + vector.x;
                    oppositeControlPoint.y = center.y + vector.y;
                } else {
                    const distance = oppositeVector.getDistanceFromPoint(center);
                    oppositeControlPoint.x = center.x + normalizedVector.x * distance;
                    oppositeControlPoint.y = center.y + normalizedVector.y * distance;
                }
            }
        }

        this.editatedPath.selectionPreview.renderRequest();
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const editatedPath = this.editatedPath;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([editatedPath]);
            editatedPath.geometryPointList = null;
        };

        undoAction.createAttributeSnapshot([editatedPath], 'd');

        this.swapTransformDataPointListFromInteractionElementToElement();

        if (this.draggableControlPointList[0].ownerPoint.type === 'Q') {
            editatedPath.convertQuandraticCurveToCubicCurve();
            editatedPath.render();
        }

        redoAction.createAttributeSnapshot([editatedPath], 'd');

        activeDocument.onChange();

        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();

        this.reflectOppositeControlPoint = false;
    };

}

new TranslateControlPoints_tool("translate-control-points-tool");

class RotatePoints_tool extends TranslatePoints_tool {

    constructor(_toolName) {
        super(_toolName);
        //this.centerOfRotation=SVGUtils.createSVGPoint();
    }

    initDrag(_e) {
        this.pointerDownWorkspaceX = _e.workspaceX;
        this.pointerDownWorkspaceY = _e.workspaceY;
        this.centerOfRotation = _e.centerOfRotation;
        XOS.initDragFunctions(this, _e);
    }

    // setCenterOfRotation(  _centerOfRotation  )
    // {
    // 	this.centerOfRotation.x = _centerOfRotation.x;
    // 	this.centerOfRotation.y = _centerOfRotation.y;
    // };
    //
    // initDrag( _e  ) {
    // 	this.previousWorkspaceX=_e.workspaceX;
    // 	this.previousWorkspaceY=_e.workspaceY;
    // 	this.clickedElement = _e.elementAtPoint || null;
    // 	XOS.initDragFunctions(this,_e);
    // 	this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
    // }


    onDragStart(_e) {
        const activeDocument = activeApplication.activeDocument;

        activeApplication.workspace.removeInteractions();

        this.startAngle = GeometryUtils.getAngleBetweenPoints({
            x: this.pointerDownWorkspaceX,
            y: this.pointerDownWorkspaceY
        }, this.centerOfRotation);

        activeApplication.workspace.snapInteraction2D.reset();

        // const centerOfRot = this.centerOfRotation;
        // _e.startPenEvent = {workspaceX:centerOfRot.x,workspaceY:centerOfRot.y}; // servirà per calcolare la perpendicolare ad un segmento esistente

        // trasport il centro da workspace a content
        const contentMatrix = activeDocument.activePage.content.getTransform().matrix;
        const centerInContentSpace = SVGUtils.createSVGPoint((this.centerOfRotation.x - contentMatrix.e) / activeDocument.activePage.content.currentScale, (this.centerOfRotation.y - contentMatrix.f) / activeDocument.activePage.content.currentScale);
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(centerInContentSpace);
        //this.initTransformDataPointList();
        this.transformDataPointList = activeDocument.createTransformDataPointList();
        //super.onDragStart( _e );
        this.previousRotation = 0;
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        const centerOfRot = this.centerOfRotation;
        _e.startPenEvent = {
            workspaceX: centerOfRot.x,
            workspaceY: centerOfRot.y
        }; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        const rotationValue = GeometryUtils.getAngleBetweenPoints({
            x: _e.workspaceX,
            y: _e.workspaceY
        }, this.centerOfRotation, null, this.startAngle);

        activeDocument.rotateTransformDataPointList(this.transformDataPointList, (rotationValue - this.previousRotation) / (Math.PI / 180), this.centerOfRotation);

        this.previousRotation = rotationValue;

        // let snapAngle = null;
        //
        // //if(_e.shiftKey) snapAngle = activeDocument.preferences.snap.snapAngleList[0]*(Math.PI/180);
        //
        // this.rotationValue = GeometryUtils.getAngleBetweenPoints( {x:_e.workspaceX,y:_e.workspaceY} , this.centerOfRotation, snapAngle, this.startAngle );
        // activeDocument.rotateElementList ( this.elementListToRotate , this.rotationValue/(Math.PI/180) ,this.centerOfRotation );
    }

    // onDrag(_e)
    // {
    // 	const activeDocument = activeApplication.activeDocument;
    // 	_e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
    // 	activeDocument.pointerEventToCoords(_e,true);
    // 	activeDocument.elementFromPointerEvent(_e , true );
    // 	activeDocument.applySnap(_e);
    // 	activeApplication.workspace.snapInteraction2D.lastEvent = _e;
    //
    // 	// const rotationValue = GeometryUtils.getAngleBetweenPoints( {x:_e.workspaceX,y:_e.workspaceY} , this.centerOfRotation, snapAngle, this.startAngle );
    // 	const rotationValue = GeometryUtils.getAngleBetweenPoints( {x:_e.workspaceX,y:_e.workspaceY} , this.centerOfRotation, null, this.startAngle );
    //
    // 	activeDocument.rotateTransformDataPointList( this.transformDataPointList , (rotationValue-this.previousRotation)/(Math.PI/180), this.centerOfRotation   );
    //
    // 	this.previousRotation=rotationValue;
    // }


}

new RotatePoints_tool("rotate-points-tool");

class ScalePoints_tool extends TranslatePoints_tool {

    constructor(_toolName) {
        super(_toolName);
        this.scaleX = 1;
        this.scaleY = 1;
        this.scaleAxis = null;
        this.centerOfScaling = SVGUtils.createSVGPoint();
        this.alternateCenterOfScaling = SVGUtils.createSVGPoint();
        this.mantainAspectRatio = false;
    }

    initDrag(_e) {
        this.pointerDownWorkspaceX = _e.workspaceX;
        this.pointerDownWorkspaceY = _e.workspaceY;
        this.centerOfScaling.x = _e.centerOfScaling.x;
        this.centerOfScaling.y = _e.centerOfScaling.y;
        this.alternateCenterOfScaling.x = _e.alternateCenterOfScaling.x;
        this.alternateCenterOfScaling.y = _e.alternateCenterOfScaling.y;
        this.scaleAxis = _e.scaleAxis;
        this.isLocalMode = _e.isLocalMode;
        this.mantainAspectRatio = (_e.mantainAspectRatio === true);
        this.createUndoRedoActions = true;
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        XOS.initDragFunctions(this, _e);
    }

    // setProperties(  _centerOfScaling , _alternateCenterOfScaling , _scaleAxis, _isLocalMode , _mantainAspectRatio )
    // {
    // 	this.centerOfScaling.x = _centerOfScaling.x;
    // 	this.centerOfScaling.y = _centerOfScaling.y;
    // 	this.alternateCenterOfScaling.x = _alternateCenterOfScaling.x;
    // 	this.alternateCenterOfScaling.y = _alternateCenterOfScaling.y;
    // 	this.scaleAxis = _scaleAxis;
    // 	this.isLocalMode=_isLocalMode;
    // 	this.mantainAspectRatio = (_mantainAspectRatio===true);
    // };


    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;
        let mantainAspectRatioFlag = this.mantainAspectRatio;

        this.scaleX = (_e.workspaceX - this.centerOfScaling.x) / (this.pointerDownWorkspaceX - this.centerOfScaling.x);
        this.scaleY = (_e.workspaceY - this.centerOfScaling.y) / (this.pointerDownWorkspaceY - this.centerOfScaling.y);

        // this.scaleX = (gPOINTER.pointerMoveEvent.workspaceX - this.centerOfScaling.x) / (gPOINTER.pointerDownEvent.workspaceX-this.centerOfScaling.x);
        // this.scaleY = (gPOINTER.pointerMoveEvent.workspaceY - this.centerOfScaling.y) / (gPOINTER.pointerDownEvent.workspaceY-this.centerOfScaling.y);

        if (this.scaleAxis === 'XY' && (mantainAspectRatioFlag || _e.shiftKey)) {
            if (Math.abs(this.scaleX) > Math.abs(this.scaleY)) {
                this.scaleY = this.scaleX;
            } else {
                this.scaleX = this.scaleY;
            }
        }

        if ((this.scaleX === Infinity) || (this.scaleX === -Infinity) || isNaN(this.scaleX))
            this.scaleX = 1;
        if ((this.scaleY === Infinity) || (this.scaleY === -Infinity) || isNaN(this.scaleY))
            this.scaleY = 1;

        // if( this.scaleAxis==='XY' && ( mantainAspectRatioFlag || _e.shiftKey ) )
        // {
        // 	if( Math.abs( this.scaleX ) > Math.abs( this.scaleY ) ) { this.scaleY = this.scaleX; } else { this.scaleX = this.scaleY; }
        // }

        // if((this.scaleX === Infinity) || (this.scaleX === -Infinity) ||  isNaN(this.scaleX)) this.scaleX=1;
        // if((this.scaleY === Infinity) || (this.scaleY === -Infinity) ||  isNaN(this.scaleY)) this.scaleY=1;


        activeDocument.scaleTransformDataPointList(this.transformDataPointList, this.scaleX, this.scaleY, this.centerOfScaling);

    }

}

new ScalePoints_tool("scale-points-tool");

class ConvertPoint_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;
        if (maxSelectedElements === 0)
            return;
        activeApplication.workspace.pointsInteraction.show();
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;
        this.clickedElement = this.currentPenEvent.elementAtPoint;

        if (this.clickedElement.nodeName === 'path') {
            if (!activeDocument.isElementSelected(this.clickedElement)) {
                activeDocument.selectElementList([this.clickedElement]);
                activeApplication.workspace.update();
            }
        }
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        if (_e.elementAtPoint && _e.elementAtPoint.isLocked())
            _e.elementAtPoint = null;
        this.currentPenEvent = _e;
    }

    onPointerDownOnInteractionPoint(_e) {
        const interactionPoint = _e.target.parentElement;
        let segmentToConvert = interactionPoint.pointRef;
        const path = segmentToConvert.ownerShapeElement;
        let pointList = path.getGeometryPointList();

        const idSegmentToConvert = pointList.indexOf(segmentToConvert);

        if (idSegmentToConvert === -1)
            return null;
        activeApplication.activeDocument.convertPathSegmentToCorner_undable(segmentToConvert);
        activeApplication.workspace.update();

        segmentToConvert = path.getGeometryPointList()[idSegmentToConvert];

        function onBeforeStartDragFunction() {
            const editableControlPointList = activeApplication.activeDocument.convertPathSegmentToCurve_undable(segmentToConvert);
            if (editableControlPointList) {
                TOOLS['translate-control-points-tool'].setDraggableControlPointList(editableControlPointList);
                TOOLS["translate-control-points-tool"].reflectOppositeControlPoint = true;
                TOOLS["translate-control-points-tool"].startPenEvent = null;
            }
        }

        TOOLS["translate-control-points-tool"].initDrag(_e, onBeforeStartDragFunction);
    }

}

new ConvertPoint_tool("convert-point-tool", 'D');

class SplitPath_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;
        if (maxSelectedElements === 0)
            return;
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.pointsInteraction.show();
    }

    onPointerDownOnInteractionPoint(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activeDocument.activePage.focusedElement;
        const clickedHandle = _e.target.parentElement;

        const result = focusedElement.splitPathAtPoint(clickedHandle.pointRef);

        if (result.length > 0) {
            focusedElement.geometryPointList = null;
            activeDocument.replaceElement_undable(focusedElement, result);
        }

        // activeDocument.splitPathAtPoint_undable( clickedHandle.pointRef  );
        activePage.focusedPoint = null;
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;

        this.clickedElement = this.currentPenEvent.elementAtPoint;

        if (this.currentPenEvent.segmentListAtPoint.length > 0) {
            if (this.clickedElement.nodeName === 'path' && this.clickedElement.dataset.type !== 'object') {
                activeDocument.splitPathAtLocation_undable(this.clickedElement, this.currentPenEvent.segmentListAtPoint[0]);
            }
        }
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        if (_e.elementAtPoint && _e.elementAtPoint.isLocked())
            _e.elementAtPoint = null;
        this.currentPenEvent = _e;
    }

}

new SplitPath_tool("split-path-tool", 'C');

class AddRemovePoint_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;
        if (maxSelectedElements === 0)
            return;
        activeApplication.workspace.pointsInteraction.show();
    }

    onPointerDownOnInteractionPoint(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const clickedHandle = _e.target.parentElement;
        activeDocument.removePathPoints_undable([clickedHandle.pointRef]);
        activePage.focusedPoint = null;
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        this.clickedElement = this.currentPenEvent.elementAtPoint;

        if (this.currentPenEvent.segmentListAtPoint.length > 0) {
            if (this.clickedElement.nodeName === 'path' && this.clickedElement.dataset.type !== 'object') {
                activeDocument.addPathPointAtLocation_undable(this.clickedElement, this.currentPenEvent.segmentListAtPoint[0]);
                TOOLS["translate-points-tool"].initDrag(this.currentPenEvent);
            }
        }
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        if (_e.elementAtPoint && _e.elementAtPoint.isLocked())
            _e.elementAtPoint = null;
        this.currentPenEvent = _e;
    }

}

new AddRemovePoint_tool("add-remove-point-tool", 'X');

class RoundCorners_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.radiusLimit = 100;
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;
        if (maxSelectedElements === 0)
            return;
        //activeApplication.workspace.pointsInteraction.show();
        activeApplication.workspace.pointsInteraction.showRoundableCornerPoints();
    }

    onPointerDown(_e) {
        super.onPointerDown(_e);

        this.clickedElement = null;

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;
        this.clickedElement = this.currentPenEvent.elementAtPoint;

        if (this.clickedElement.nodeName === 'path') {
            if (!activeDocument.isElementSelected(this.clickedElement)) {
                activeDocument.selectElementList([this.clickedElement]);
                activeApplication.workspace.update();
            }
        }
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        if (_e.elementAtPoint && _e.elementAtPoint.isLocked())
            _e.elementAtPoint = null;
        this.currentPenEvent = _e;
    }

    onPointerDownOnInteractionPoint(_e) {
        const activeDocument = activeApplication.activeDocument;
        const clickedHandle = _e.target.parentElement;
        const handlePosition = clickedHandle.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeDocument.pointerEventToCoords(virtualEvent);
        const interactionPoint = _e.target.parentElement;
        virtualEvent.segmentToConvert = interactionPoint.pointRef;
        this.initDrag(virtualEvent);
    }

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        this.createUndoRedoActions = true;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        this.segmentToConvert = _e.segmentToConvert;
    }

    onDragStart(_e) {
        // const activePage = activeApplication.activeDocument.activePage;
        // const path = this.segmentToConvert.ownerShapeElement;

        this.cornerDataList = [];
        this.editablePath = this.segmentToConvert.ownerShapeElement;
        this.interactivePath = this.editablePath.selectionPreview;

        // creo nuovi punti clonando quelli attuali
        this.segmentToConvert = this.interactivePath.getGeometryPointList()[this.segmentToConvert.id];

        this.roundAllCorners = false;

        let lineToList = [];
        let i,
        max;

        if (_e.altKey) {
            this.roundAllCorners = true;

            const pointList = this.interactivePath.getGeometryPointList();

            max = pointList.length - 1;
            for (i = 0; i < max; i++) {
                if (pointList[i].type === 'L') {
                    if (pointList[i + 1].type === 'L') {
                        lineToList.push(pointList[i]);
                    } else if (pointList[i + 1].type === 'Z') {
                        lineToList.push(pointList[i]);
                    }
                }
            }
        } else {
            lineToList = [this.segmentToConvert];
        }

        max = lineToList.length;
        for (i = 0; i < max; i++) {
            const cornerData = this.initCornerData(lineToList[i]);
            if (cornerData)
                this.cornerDataList.push(cornerData);
        }

        //console.log('this.cornerDataList',this.cornerDataList);
    }

    onDrag(_e) {

        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);

        const innerPointerDownPos = this.interactivePath.globalToLocal(this.previousWorkspaceX, this.previousWorkspaceY);
        const innerPointerMovePos = this.interactivePath.globalToLocal(_e.workspaceX, _e.workspaceY);

        const distance = innerPointerDownPos.getDistanceFromPoint(innerPointerMovePos);

        for (let i = 0; i < this.cornerDataList.length; i++)
            this.updateRoundedCorner(this.cornerDataList[i], distance);
    }

    updateRoundedCorner(_cornerData, _distance) {
        const path = this.interactivePath;
        //if( _distance > _cornerData.distanceLimit ) _distance = _cornerData.distanceLimit;
        if (_distance > this.radiusLimit)
            _distance = this.radiusLimit;
        const result = GeometryUtils.fillet(_cornerData.previousSegment, _cornerData.cornerPoint, _cornerData.endSegment, _distance);

        let counterClockwise = 0;
        if (result.area < 0)
            counterClockwise = 1;

        path.createGeometryPoint_ARCTO_by_startEndAngles(result.center, result.radius, result.startAngle, result.endAngle, _cornerData.arcSegmentPoint, counterClockwise);

        _cornerData.startSegment.x = _cornerData.arcSegmentPoint.startPt.x;
        _cornerData.startSegment.y = _cornerData.arcSegmentPoint.startPt.y;

        if (_cornerData.moveToSegment) {
            _cornerData.moveToSegment.x = _cornerData.startSegment.x;
            _cornerData.moveToSegment.y = _cornerData.startSegment.y;
        }

        //path.renderRequest();
        path.render();

    };

    // updateRoundedCorner( _cornerData ,_distance )
    // {
    // 	const path = this.interactivePath;
    // 	if( _distance > _cornerData.distanceLimit ) _distance = _cornerData.distanceLimit;
    // 	const result = GeometryUtils.fillet(_cornerData.previousSegment , _cornerData.cornerPoint, _cornerData.endSegment, _distance);
    //
    // 	path.createGeometryPoint_ARCTO_by_startEndAngles(  result.center, result.radius, result.startAngle, result.endAngle , _cornerData.arcSegmentPoint );
    //
    // 	if(result.area<0){
    //
    // 		_cornerData.arcSegmentPoint.x = _cornerData.arcSegmentPoint.startPt.x;
    // 		_cornerData.arcSegmentPoint.y = _cornerData.arcSegmentPoint.startPt.y;
    // 		_cornerData.arcSegmentPoint.startPt.x = _cornerData.arcSegmentPoint.endPt.x;
    // 		_cornerData.arcSegmentPoint.startPt.y = _cornerData.arcSegmentPoint.endPt.y;
    // 		_cornerData.arcSegmentPoint.sweepFlag = 0;
    // 	}
    //
    // 	_cornerData.startSegment.x=_cornerData.arcSegmentPoint.startPt.x;
    // 	_cornerData.startSegment.y=_cornerData.arcSegmentPoint.startPt.y;
    //
    // 	if(_cornerData.moveToSegment)
    // 	{
    // 		_cornerData.moveToSegment.x = _cornerData.startSegment.x;
    // 		_cornerData.moveToSegment.y = _cornerData.startSegment.y;
    // 	}
    //
    // 	//path.renderRequest();
    // 	path.render();
    //
    // };


    initCornerData(_segment) {
        const path = this.interactivePath;

        const pointList = path.getGeometryPointList();

        const idSegment = pointList.indexOf(_segment);

        if (idSegment === -1)
            return null;

        let editableMoveToSegment = null;
        const cornerPoint = SVGUtils.createSVGPoint(_segment.x, _segment.y);

        let previousSegment = pointList[idSegment - 1];

        let idNextSegment = idSegment + 1;

        let nextSegment = pointList[idNextSegment];

        if (nextSegment && (nextSegment.type === 'Z')) {
            const moveToSegmentId = path.getSubPathMoveToSegmentId(_segment);
            if (moveToSegmentId === -1)
                return;

            idNextSegment = moveToSegmentId + 1;
            nextSegment = pointList[idNextSegment];
            if (nextSegment.type !== 'L')
                return null;

            editableMoveToSegment = path.createGeometryPoint_MOVETO(cornerPoint.y, cornerPoint.x);
            editableMoveToSegment.ownerShapeElement = this.interactivePath;
            pointList.replaceAt(editableMoveToSegment, moveToSegmentId);
        }

        let editableSegment,
        nextEditableSegment,
        arcSegmentPoint;

        editableSegment = _segment;
        nextEditableSegment = nextSegment;
        arcSegmentPoint = path.createGeometryPoint_ARCTO();
        pointList.addAt(arcSegmentPoint, idNextSegment);
        arcSegmentPoint.ownerShapeElement = this.interactivePath;

        const previousSegmentdistance = _segment.getDistanceFromPoint(previousSegment);
        const nextSegmentdistance = nextSegment.getDistanceFromPoint(_segment);

        let distanceLimit = Math.min(previousSegmentdistance, nextSegmentdistance);
        console.log('distanceLimit', distanceLimit);
        if (this.roundAllCorners)
            distanceLimit /= 2;

        return {
            cornerPoint: cornerPoint,
            distanceLimit: distanceLimit,
            previousSegment: previousSegment,
            startSegment: editableSegment,
            endSegment: nextEditableSegment,
            moveToSegment: editableMoveToSegment,
            arcSegmentPoint: arcSegmentPoint,
        };

    }

    onDragEnd(_e) {

        const _cornerData = this.cornerDataList[0];

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const path = this.editablePath;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };
        undoAction.createAttributeSnapshot([path], 'd');

        const pointList = this.interactivePath.getGeometryPointList();
        // rimuovo le linee troppo piccole
        let max = pointList.length - 1;
        for (let i = 0; i < max; i++) {
            if (pointList[i].type === 'L') {
                if (pointList[i].getDistanceFromPoint(pointList[i - 1]) < .001) {
                    pointList.removeAt(i);
                    i--;
                    max--;
                }
            }
        }

        this.interactivePath.geometryPointList = null;

        const newGeometryPointList = this.interactivePath.getGeometryPointList();

        this.editablePath.setGeometryPointList(newGeometryPointList);
        this.editablePath.render();

        redoAction.createAttributeSnapshot([path], 'd');

        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

}

new RoundCorners_tool("round-corners-tool", 'B');

class DrawLine2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'linear-interaction');
    }

    onKeyDown(_e) {
        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();
            this.reset();
            break;

        case 'TAB':
            if (this.pointA && this.pointB) {
                this.finalize(_e);
            }
            //document.querySelector('line-inspector').setInputPropertyFocus( 'lineLength' );
            WINDOWS['mainInspectorWindow'].showMainSection('selection-section');
            PANELS['line-transform-inspector'].setInputPropertyFocus('lineLength');
            _e.preventDefault();
            break;

        case 'ESC':
            this.reset();
            _e.preventDefault();
            break;
        }

    }

    onReadyPoints_A_B(_e) {
        this.finalize(_e);
    }

    createElement() {
        const activeDocument = activeApplication.activeDocument;

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        this.createdElement = SVGUtils.createLine(this.pointA.contentX, this.pointA.contentY, this.pointB.contentX, this.pointB.contentY);

        if (activeDocument.fillAndStrokeManager['stroke'] === 'none')
            activeDocument.fillAndStrokeManager['stroke'] = '#000000';
        if (activeDocument.fillAndStrokeManager['stroke-opacity'] === '0')
            activeDocument.fillAndStrokeManager['stroke-opacity'] = '1';
        if (activeDocument.fillAndStrokeManager['stroke-width'] === '0')
            activeDocument.fillAndStrokeManager['stroke-width'] = '1';

        activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);

        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        this.createdElement.resetOrigin();
    }

}

new DrawLine2D_tool('draw-line-tool', 'L');

class DrawRect2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'rectangular-interaction');
    }

    onReadyPoints_A_B(_e) {
        this.finalize(_e);
    }

    createElement(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        let x = Math.min(this.pointA.contentX, this.pointB.contentX);
        let y = Math.min(this.pointA.contentY, this.pointB.contentY);
        let w = Math.abs(this.pointB.contentX - this.pointA.contentX);
        let h = Math.abs(this.pointB.contentY - this.pointA.contentY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        this.createdElement = SVGUtils.createRect(x, y, w, h);

        activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);

        // this.validateFillAndStrokeStyle();
        // activePage.applyActiveStrokeStyleToElement( newElement );

        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        this.createdElement.resetOrigin();
    }

}

new DrawRect2D_tool('draw-rect-tool', 'R');

class DrawEditText2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'rectangular-interaction');
    }

    onDeactivate() {
        if (activeApplication.isTextEditing)
            this.endTextEditing();
    }

    onKeyDown(_e) {
        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'TAB':
            if (this.pointA && this.pointB)
                this.finalize(_e);
            _e.preventDefault();
            break;

        case 'ESC':
            this.reset();
            _e.preventDefault();
            break;
        }

    }

    onPointerDown(_e) {
        //console.log('DrawEditText2D_tool onPointerDown');
        if (activeApplication.isTextEditing) {
            XOS.hideElement(activeApplication.workspace.TEXT_CURSOR);
            _e.elementAtPoint = activeApplication.activeDocument.shadowRoot.elementFromPoint(_e.pageX, _e.pageY);
            if (_e.elementAtPoint) {
                //console.log('_e.elementAtPoint',_e.elementAtPoint);

                let clickedElement = null;

                if (activeApplication.currentEditableTextElement.nodeName === 'text') {
                    clickedElement = _e.elementAtPoint.getMainElement();
                } else {
                    clickedElement = _e.elementAtPoint.closest('foreignObject');
                }

                if (clickedElement !== activeApplication.currentEditableTextElement)
                    this.endTextEditing();

            }
            return;
        }

        if (this.currentPenEvent.elementAtPoint) {
            const clickedElement = this.currentPenEvent.elementAtPoint.getMainElement();
            if (clickedElement && clickedElement.nodeName === 'text') {
                activeApplication.activeDocument.selectElementList([clickedElement]);
                this.startTextEditing(clickedElement);
                return;
            } else if (clickedElement.nodeName === 'foreignObject' && clickedElement.dataset.type === 'html-text') {
                activeApplication.activeDocument.selectElementList([clickedElement]);
                this.startTextEditing(clickedElement);
                return;
            }

        }

        super.onPointerDown(_e);
    }

    onPointerMove(_e) {
        if (activeApplication.isTextEditing)
            return;
        super.onPointerMove(_e);
    }

    onPointerUp(_e) {
        if (activeApplication.isTextEditing) {
            if (activeApplication.currentEditableTextElement.nodeName === 'text')
                activeApplication.currentEditableTextElement.updateSelectionState();
        }
    }

    onReadyPoints_A_B(_e) {
        //console.log('onReadyPoints_A_B', this.pointA);
        this.finalize(_e);
    }

    createElement(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        let x = Math.min(this.pointA.contentX, this.pointB.contentX);
        let y = Math.min(this.pointA.contentY, this.pointB.contentY);
        let w = Math.abs(this.pointB.contentX - this.pointA.contentX);
        let h = Math.abs(this.pointB.contentY - this.pointA.contentY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        if (_e.ctrlKey) {
            this.createdElement = SVGUtils.createForeignObjectHtmlText(x, y, w, h, 'Enter your text here');
            this.startTextEditing(this.createdElement);
        } else {
            this.createdElement = SVGUtils.createTextBox(x, y, w, h, localString('Enter your text here'), 'Roboto', 'normal', '400', 20);
            this.createdElement.setAttribute('tabindex', '1');
            const self = this;
            const textElement = this.createdElement;
            setTimeout(function () {
                self.startTextEditing(textElement);
                textElement.selectAll();
            }, 100);
        }

        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        // const self=this;
        // const foreignObjectHtmlText = this.createdElement;
        // setTimeout( function(){
        //     self.startTextEditing( foreignObjectHtmlText );
        //     foreignObjectHtmlText.selectAll();
        // }, 100);
    }

    startTextEditing(_textElementToEdit) {
        activeApplication.workspace.removeSelectionPreview();
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.isTextEditing = true;
        activeApplication.currentEditableTextElement = _textElementToEdit;
        if (_textElementToEdit.nodeName === 'text') {
            _textElementToEdit.enterToTextEditing();
        } else if (_textElementToEdit.nodeName === 'foreignObject' && _textElementToEdit.dataset.type === 'html-text') {
            const div = _textElementToEdit.querySelector('div');
            div.setAttribute('contenteditable', 'true');
            div.focus();
        }
    }

    endTextEditing() {

        if (activeApplication.currentEditableTextElement.nodeName === 'text') {
            activeApplication.currentEditableTextElement.exitFromTextEditing();
        } else {
            const div = activeApplication.currentEditableTextElement.querySelector('div');
            div.removeAttribute('contenteditable');
            div.blur();

            activeApplication.isTextEditing = false;
            activeApplication.currentEditableTextElement = null;
        }
    }

}

new DrawEditText2D_tool('draw-edit-text-tool', 'T');

class DrawEllipse2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'elliptical-interaction');
    }

    // onKeyDown(_e)
    // {
    //     _e.focusField = 'sizeX';
    //     super.onKeyDown( _e );
    // }

    onReadyPoints_A_B(_e) {
        this.finalize(_e);
    }

    // updateDrawingInteraction( _e )
    // {
    //     let x = Math.min( this.pointA.workspaceX, this.pointB.workspaceX);
    //     let y = Math.min( this.pointA.workspaceY, this.pointB.workspaceY);
    //     let w = Math.abs( this.pointB.workspaceX- this.pointA.workspaceX);
    //     let h = Math.abs( this.pointB.workspaceY- this.pointA.workspaceY);
    //
    //     if(w===0) w=1;
    //     if(h===0) h=1;
    //
    //     if( _e.altKey ) {x-= w;y-= h;w+= w;h+= h;}
    //
    //     const rx = w / 2;
    //     const ry = h / 2;
    //     const cx = x + rx;
    //     const cy = y + ry;
    //
    //     const interactiveEllipse = activeApplication.workspace.interactiveEllipse;
    //     interactiveEllipse.updateGeometry( cx , cy , rx, ry );
    //     interactiveEllipse.classList.add('showed');
    // }


    createElement(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        let x = Math.min(this.pointA.contentX, this.pointB.contentX);
        let y = Math.min(this.pointA.contentY, this.pointB.contentY);
        let w = Math.abs(this.pointB.contentX - this.pointA.contentX);
        let h = Math.abs(this.pointB.contentY - this.pointA.contentY);

        if (w === 0)
            w = 1;
        if (h === 0)
            h = 1;

        if (_e.altKey) {
            x -= w;
            y -= h;
            w += w;
            h += h;
        }

        const rx = w / 2;
        const ry = h / 2;
        const cx = x + rx;
        const cy = y + ry;

        this.createdElement = SVGUtils.createEllipse(cx, cy, rx, ry);

        activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);

        // this.validateFillAndStrokeStyle();
        // activePage.applyActiveStrokeStyleToElement( newElement );

        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        this.createdElement.resetOrigin();
    }

}

new DrawEllipse2D_tool('draw-ellipse-tool', 'E');

class DrawRegularPolygon2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.numSides = 5;
    }

    onReadyPoints_A_B(_e) {
        this.finalize(_e);
    }

    updateDrawingInteraction(_e) {
        const pt1 = SVGUtils.createSVGPoint(this.pointA.workspaceX, this.pointA.workspaceY);
        const pt2 = SVGUtils.createSVGPoint(this.pointB.workspaceX, this.pointB.workspaceY);
        const radius = pt2.getDistanceFromPoint(pt1);
        const interactiveRegularPolygon = activeApplication.workspace.interactiveRegularPolygon;
        interactiveRegularPolygon.buildRegularPolygon(pt1.x, pt1.y, this.numSides, radius);
        interactiveRegularPolygon.classList.add('showed');
    }

    createElement(_e) {
        const activeDocument = activeApplication.activeDocument;

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        const pt1 = SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY);
        const pt2 = SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY);
        const radius = pt2.getDistanceFromPoint(pt1);

        this.createdElement = SVGUtils.createPath();
        this.createdElement.buildRegularPolygon(pt1.x, pt1.y, this.numSides, radius);

        activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);

        // this.validateFillAndStrokeStyle();
        // activePage.applyActiveStrokeStyleToElement( newElement );

        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        this.createdElement.resetOrigin();
    }

}

new DrawRegularPolygon2D_tool('draw-regular-polygon-tool', 'W');

class DrawFreehand2D_tool extends Base2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.selectionMode = 'POINT_SELECTION';
        this.booleanElementTarget = null;
        this.booleanAction = 'unite';
        this.simplifyTolerance = 2.5;
        this.joinTolerance = 5;
    }

    onKeyDown(_e) {
        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();

            break;
        }

    }

    doBooleanAction() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeLayer = activeDocument.getActivePageLayer();

        this.interactiveElement.transformGeometryPointList(this.interactiveElement.getTransformToElement(activeLayer));
        this.interactiveElement.render();

        const paperScope = {};
        paper.install(paperScope);
        paper.setup([640, 480]);

        let pathSource = paperScope.project.importSVG(this.interactiveElement);
        pathSource.simplify(this.simplifyTolerance / activePage.content.currentScale);
        pathSource.join(null, this.joinTolerance / activePage.content.currentScale);

        pathSource = pathSource.exportSVG();

        const createdSVGPathList = COMMANDS.booleans.booleanPathsOperation(this.booleanElementTarget, pathSource, this.booleanAction);

        for (let i = 0; i < createdSVGPathList.length; i++) {
            this.booleanElementTarget.parentElement.insertBefore(createdSVGPathList[i], this.booleanElementTarget.nextElementSibling);
            createdSVGPathList[i].setGraphicAttributesByElement(this.booleanElementTarget);
        }

        activeDocument.replaceElement_undable(this.booleanElementTarget, createdSVGPathList);
        //activeDocument.replaceElementList_undable([this.booleanElementTarget],createdSVGPathList);
        activeDocument.selectElementList(createdSVGPathList);
        activeApplication.workspace.update();
    };

    createElement() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeLayer = activeDocument.getActivePageLayer();

        this.interactiveElement.transformGeometryPointList(this.interactiveElement.getTransformToElement(activeLayer));
        this.interactiveElement.render();

        const paperScope = {};
        paper.install(paperScope);
        paper.setup([640, 480]);

        const pathTarget = paperScope.project.importSVG(this.interactiveElement);
        pathTarget.simplify(this.simplifyTolerance / activePage.content.currentScale);
        pathTarget.join(null, this.joinTolerance / activePage.content.currentScale);

        const newPath = pathTarget.exportSVG();

        newPath.setPathData(newPath.getPathData({
                absolutize: true,
                normalize: true
            }));

        activeDocument.fillAndStrokeManager.apply_stroke(newPath);
        activeDocument.fillAndStrokeManager.apply_fill(newPath);

        activeLayer.appendChild(newPath);

        newPath.resetOrigin();

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([newPath])
        };

        redoAction.createDomNodeSnapshot([newPath], 'insert');
        undoAction.createDomNodeSnapshot([newPath], 'delete');

        activeDocument.onChange();

        // seleziono l'elemento inserito
        activeDocument.selectElementList([newPath]);

        activeApplication.workspace.update();
    };

    onPointerDown(_e) {
        super.onPointerDown(_e);

        if (_e.isDoubleClick)
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.pointerEventToCoords(_e);

        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(_e);
            return;
        }

        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        this.booleanElementTarget = null;

        // const cmd_or_ctrl = _e.metaKey || _e.ctrlKey;
        //
        // if(cmd_or_ctrl)
        // {
        //     let clickedElement =  activePage.currentPenEvent.elementAtPoint;
        //
        //     if (clickedElement && clickedElement.nodeName === 'path')
        //     {
        //         if (clickedElement.isLocked()) return;
        //         activePage.selectElementList( [clickedElement] );
        //         activePage.setActiveEditableElement(  clickedElement );
        //         activePage.updateInteraction();
        //         activePage.showSelectionProperties();
        //     }
        //     return;
        // }


        if (_e.altKey && activePage.selectionList.length === 1 && activePage.selectionList[0].nodeName === 'path') {
            this.booleanElementTarget = activePage.selectionList[0];
            if (_e.shiftKey) {
                this.booleanAction = 'subtract';
            } else {
                this.booleanAction = 'unite';
            }
        }

        activeDocument.deselectAll();
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.removeSelectionPreview();

        this.interactiveElement = SVGUtils.createPath();
        this.interactiveElement.setAttribute("d", "M" + _e.workspaceX + " " + _e.workspaceY);
        activeApplication.workspace.selectionPreviews.appendChild(this.interactiveElement);
    }

    onPointerMove(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        if (!this.interactiveElement)
            return;

        const geometryPointList = this.interactiveElement.getGeometryPointList();
        geometryPointList.push(this.interactiveElement.createGeometryPoint_LINETO(_e.workspaceX, _e.workspaceY));
        this.interactiveElement.renderRequest();
    }

    onPointerUp(_e) {
        super.onPointerUp(_e);

        if (this.booleanElementTarget) {
            this.doBooleanAction();
        } else {
            if (this.interactiveElement)
                this.createElement();
        }

        this.interactiveElement = null;
    }
}

new DrawFreehand2D_tool("draw-freehand-tool", 'N');

class DrawPath2D_tool extends BaseDraw2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut);
        this.selectionMode = 'POINT_SELECTION';
        this.currentPath = null;
    }

    onDeactivate() {
        this.finalize();
    }

    showInteraction() {

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const maxSelectedElements = activePage.selectionList.length;

        if (maxSelectedElements === 0)
            return;

        //activeApplication.workspace.pointsInteraction.show();
        //
        // if(activeDocument.preferences.elementOriginVisibility)activeApplication.workspace.elementOrigin2D.show();

        if (activePage.focusedPathSegmentPoint) {
            if (activePage.focusedPathSegmentPoint.type === 'L') {
                //activeApplication.workspace.segmentInteraction_L.showSegmentInteraction( activePage.focusedPathSegmentPoint );
                activeApplication.workspace.segmentInteraction_L.show();
            }
            // else if(activePage.focusedPathSegmentPoint.type==='C')
            // {
            //     activeApplication.workspace.segmentInteraction_C.show();
            // }
            // else if(activePage.focusedPathSegmentPoint.type==='Q')
            // {
            //     activeApplication.workspace.segmentInteraction_Q.show();
            // }
            // else if(activePage.focusedPathSegmentPoint.type==='A')
            // {
            //     activeApplication.workspace.segmentInteraction_A.show();
            // }
            // nel caso in cui cambio qualche proprietà del segmento attraverso l'inspector
            if (this.currentPath) {
                let pointPathList = this.currentPath.getGeometryPointList();
                const lastPathPoint = pointPathList[pointPathList.length - 1];
                const lastPathPointInContentSpace = lastPathPoint.matrixTransform(this.currentPath.getTransformToElement(activePage.content));
                activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(lastPathPointInContentSpace.x, lastPathPointInContentSpace.y));
            }

        }

    }

    onKeyDown(_e) {
        const activeDocument = activeApplication.activeDocument;

        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':
            if (this.currentPath)
                return;
            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();
            this.reset();
            break;

        case 'TAB':
            const newPathSegment = this.addSegmentToCurrentPath();
            if (newPathSegment.type === 'L') {
                activeDocument.selectElementList([this.currentPath]);
                activeDocument.setFocusedPathSegmentPoint(newPathSegment);
                activeApplication.workspace.update();
                this.setPointA();
                PANELS['line-to-transform-inspector'].setInputPropertyFocus('lineLength');
            }
            _e.preventDefault();
            break;

        case 'ESC':
            this.finalize();
            _e.preventDefault();
            break;

        case 'Y':
            this.createInteractiveSegment('INTERACTIVE_PATH_SEGMENT_L');
            _e.preventDefault();

            break;
        case 'U':
            this.createInteractiveSegment('INTERACTIVE_PATH_SEGMENT_C');
            _e.preventDefault();

            break;
        case 'W':
            this.createInteractiveSegment();
            _e.preventDefault();

            break;
        }

    }

    reset(_e) {
        super.reset();
        this.currentPath = null;
    }

    finalize(_e) {
        const activeDocument = activeApplication.activeDocument;
        if (this.currentPath) {
            activeDocument.fillAndStrokeManager.apply_stroke(this.currentPath);
            activeDocument.fillAndStrokeManager.apply_fill(this.currentPath);
            activeDocument.selectElementList([this.currentPath]);
        }
        this.reset();
    }

    createElement(_e) {
        const activeDocument = activeApplication.activeDocument;
        this.currentPath = SVGUtils.createPath();
        this.currentPath.setAttribute("d", "M" + this.pointA.contentX + " " + this.pointA.contentY);
        this.currentPath.setAttribute('fill', 'none');
        if (activeDocument.fillAndStrokeManager.stroke === 'none') {
            activeDocument.fillAndStrokeManager.setAttribute('stroke', '#c41298');
        } else {
            activeDocument.fillAndStrokeManager.apply_stroke(this.currentPath);
        }

        // activeDocument.fillAndStrokeManager.apply_stroke(this.currentPath);
        // activeDocument.fillAndStrokeManager.apply_fill(this.currentPath);
        activeDocument.getActivePageLayer().appendChild(this.currentPath);
        activeDocument.onChange();
        this.createUndoRedoActions(this.currentPath)
    }

    closePath() {
        const pointList = this.currentPath.getGeometryPointList();
        pointList[pointList.length - 1].x = pointList[0].x;
        pointList[pointList.length - 1].y = pointList[0].y;
        const closePathSegment = this.currentPath.createGeometryPoint_CLOSEPATH();
        pointList.push(closePathSegment);
        this.currentPath.render();
    }

    isClickedToClosePath() {
        const pointList = this.currentPath.getGeometryPointList();
        return pointList.length > 2 && pointList[0].equals(pointList[pointList.length - 1], this.currentPenEvent.snapDistance);
    }

    isClickedToStopCurveContinuity() {
        return (Math.abs(this.pointA.workspaceX - this.pointB.workspaceX) < 10) && (Math.abs(this.pointA.workspaceY - this.pointB.workspaceY) < this.currentPenEvent.snapDistance);
    }

    addSegmentToCurrentPath() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const interactiveSegmentId = this.interactiveSegment.getAttribute('id');
        const pointList = this.interactiveSegment.getGeometryPointList();

        let newPathSegment;

        if (interactiveSegmentId === 'INTERACTIVE_PATH_SEGMENT_Q') {
            newPathSegment = this.currentPath.quadraticCurveToCubicCurve(pointList[0], pointList[1]);
        } else if (interactiveSegmentId === 'INTERACTIVE_PATH_SEGMENT_C') {
            // se il secondo punto di controllo non è stato modificato
            if (pointList[1].controlPt2.x === pointList[1].x && pointList[1].controlPt2.y === pointList[1].y) {
                newPathSegment = this.currentPath.quadraticCurveToCubicCurve(pointList[0], pointList[1]);
            } else {
                newPathSegment = this.currentPath.createGeometryPoint_CURVETO_CUBIC(pointList[1].controlPt1.x, pointList[1].controlPt1.y, pointList[1].controlPt2.x, pointList[1].controlPt2.y, pointList[1].x, pointList[1].y);
            }
        } else if (interactiveSegmentId === 'INTERACTIVE_PATH_SEGMENT_L') {
            newPathSegment = this.currentPath.createGeometryPoint_LINETO(pointList[1].x, pointList[1].y);
        } else if (interactiveSegmentId === 'INTERACTIVE_PATH_SEGMENT_A') {
            newPathSegment = this.currentPath.createGeometryPoint_ARCTO(pointList[1].rx, pointList[1].ry, pointList[1].angle, pointList[1].largeArcFlag, pointList[1].sweepFlag, pointList[1].x, pointList[1].y);
        }

        this.interactiveSegment.transformGeometryPointList(this.interactiveSegment.getTransformToElement(this.currentPath), [newPathSegment]);

        newPathSegment.ownerShapeElement = this.currentPath;
        const currentPathGeometryPointList = this.currentPath.getGeometryPointList();
        currentPathGeometryPointList.push(newPathSegment);
        newPathSegment.id = currentPathGeometryPointList.length - 1;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        const path = this.currentPath;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };
        undoAction.createAttributeSnapshot([path], 'd');
        this.currentPath.render();
        redoAction.createAttributeSnapshot([path], 'd');
        //console.log( this.currentPath );

        return newPathSegment;
    }

    changeInteractiveSegment() {
        this.interactiveSegment.classList.remove('showed');
        const pointList = this.interactiveSegment.getGeometryPointList();

        switch (pointList[1].type) {
        case 'M':
        case 'L':
            //console.log('changeInteractiveSegment to Q');
            this.interactiveSegment = document.querySelector('#INTERACTIVE_PATH_SEGMENT_Q');
            break;
        case 'Q':
        case 'C':
            this.interactiveSegment = document.querySelector('#INTERACTIVE_PATH_SEGMENT_C');
            break;
        }

        this.updateDrawingInteraction();
    };

    createInteractiveSegment(_interactiveSegmentID) {
        if (this.interactiveSegment)
            this.interactiveSegment.classList.remove('showed');
        if (_interactiveSegmentID) {
            this.interactiveSegment = document.querySelector('#' + _interactiveSegmentID);
        } else {

            const pointList = this.currentPath.getGeometryPointList();
            const lastSegment = pointList[pointList.length - 1];

            switch (lastSegment.type) {
            case 'M':
            case 'L':
                this.interactiveSegment = document.querySelector('#INTERACTIVE_PATH_SEGMENT_L');
                break;
            case 'C':
            case 'Q':
                this.interactiveSegment = document.querySelector('#INTERACTIVE_PATH_SEGMENT_C');
                break;
            }
        }
        this.updateDrawingInteraction();
    };

    updateDrawingInteraction(_e) {
        let pointPathList = this.currentPath.getGeometryPointList();
        const lastPathPoint = pointPathList[pointPathList.length - 1];
        const lastPathPointGlobalPosition = this.currentPath.localToGlobal(lastPathPoint.x, lastPathPoint.y);

        const segmentPointList = this.interactiveSegment.getGeometryPointList();
        segmentPointList[0].x = lastPathPointGlobalPosition.x;
        segmentPointList[0].y = lastPathPointGlobalPosition.y;
        segmentPointList[1].x = this.pointB.workspaceX;
        segmentPointList[1].y = this.pointB.workspaceY;

        if (this.interactiveSegment.getAttribute('id') === 'INTERACTIVE_PATH_SEGMENT_L') {
            //const penContentPosition =  activePage.createSVGPoint(pen.contentX,pen.contentY);
            //const length  = penContentPosition.getDistanceFromPoint(lastPathPoint);
            //if(length>0) activeApplication.interactions.lengthPropertyLabel.show(lastPointGlobalPosition, penWorkspacePosition, activePage.valueToUnit(length), null);
        } else if (this.interactiveSegment.getAttribute('id') === 'INTERACTIVE_PATH_SEGMENT_A') {
            const previousLastPathPoint = pointPathList[pointPathList.length - 2];
            let pt1 = this.currentPath.localToGlobal(previousLastPathPoint.x, previousLastPathPoint.y);
            let pt2 = lastPathPointGlobalPosition;
            let lastPathSegmentAngle = pt1.getAngleFromPoint(pt2, true);
            const lastPathSegmentAngleRadians = pt1.getAngleFromPoint(pt2);
            const lastPathSegmentAnglePerpendicular = lastPathSegmentAngle + 90;
            let pointPerpendicularLastPathSegment = SVGUtils.createSVGPointPolar(100, lastPathSegmentAnglePerpendicular * Math.PI / 180).add(lastPathPointGlobalPosition);
            let interactiveSegmentAngle = pt2.getAngleFromPoint(segmentPointList[1], true);
            const interactiveSegmentAngleRadians = pt2.getAngleFromPoint(segmentPointList[1]);
            const interactiveSegmentAnglePerpendicular = interactiveSegmentAngle + 90;
            let centerBetweenInteractiveSegmentAB = lastPathPointGlobalPosition.add(SVGUtils.createSVGPoint((this.pointB.workspaceX - lastPathPointGlobalPosition.x) / 2, (this.pointB.workspaceY - lastPathPointGlobalPosition.y) / 2))
                let pointPerpendicularCenterOfInteractiveSegment = SVGUtils.createSVGPointPolar(100, interactiveSegmentAnglePerpendicular * Math.PI / 180).add(centerBetweenInteractiveSegmentAB);
            const centerOfArc = GeometryUtils.getLineLineIntersection(lastPathPointGlobalPosition, pointPerpendicularLastPathSegment, centerBetweenInteractiveSegmentAB, pointPerpendicularCenterOfInteractiveSegment);
            //console.log('centerOfArc',centerOfArc);

            if (centerOfArc) {
                let radius = centerOfArc.getDistanceFromPoint(lastPathPointGlobalPosition);

                /*
                let angle = interactiveSegmentAnglePerpendicular;
                if(interactiveSegmentAngle===0)interactiveSegmentAngle=360;
                if((interactiveSegmentAngle-lastPathSegmentAngle)<180) angle+=180;


                let point3 = SVGUtils.createSVGPointPolar( radius , angle *  Math.PI / 180  );
                activeApplication.showTip( 'lastPathSegmentAngle:'+lastPathSegmentAngle.toFixed(2) + 'interactiveSegmentAngle:'+interactiveSegmentAngle.toFixed(2));
                this.interactiveSegment.buildArcBy3Points( lastPathPointGlobalPosition, segmentPointList[1], centerOfArc.add( point3 ) )

                 */

                function isLeft(a, b, c) {
                    return ((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) > 0;
                }

                let angle = interactiveSegmentAnglePerpendicular;
                if (angle > 360)
                    angle -= 360;
                const largeArcFlag = angle <= 180 ? "0" : "1";
                const sweepFlag = interactiveSegmentAngle - lastPathSegmentAngle >= 180 ? "0" : "1"; // clockwise or anticlockwise
                this.interactiveSegment.setAttribute('d', 'M' + ' ' + lastPathPointGlobalPosition.x + ' ' + lastPathPointGlobalPosition.y + ' A ' + radius + ' ' + radius + ' ' + 0 + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + segmentPointList[1].x + ' ' + segmentPointList[1].y);

                // let angle = interactiveSegmentAnglePerpendicular;
                // if(angle>360) angle-=360;
                // const largeArcFlag = angle <= 180 ? "0" : "1";
                // const sweepFlag = interactiveSegmentAngle-lastPathSegmentAngle >= 180 ? "0" : "1";
                // this.interactiveSegment.setAttribute('d', 'M'+' '+lastPathPointGlobalPosition.x+' '+lastPathPointGlobalPosition.y+' A '+radius+' '+radius+' '+lastPathSegmentAngle+' '+largeArcFlag+' '+sweepFlag+' '+segmentPointList[1].x+' '+segmentPointList[1].y );

                //activeApplication.showTip( 'interactiveSegmentAngle:'+lastPathSegmentAngle+' lastPathSegmentAngle:'+lastPathSegmentAngle+'  difference: '+ (interactiveSegmentAngle-lastPathSegmentAngle)+'  Radius:'+radius+'  Angle:'+angle+'  largeArcFlag:'+largeArcFlag+'  sweepFlag:'+sweepFlag );

                //this.interactiveSegment.buildArc( centerOfArc, centerOfArc.getDistanceFromPoint(lastPathPointGlobalPosition),lastPathSegmentAnglePerpendicular+180, centerOfArc.getAngleFromPoint( segmentPointList[1]  , true  ) ) ;
                const centerView = document.querySelector('#CURRENT_PEN_LOCATION');
                centerView.placeAt(centerOfArc.x, centerOfArc.y);
                centerView.classList.add('showed');
                this.interactiveSegment.classList.add('showed');
            }
            return;
        } else if (lastPathPoint.controlPt1) {
            let ctrlPt,
            xc,
            yc;

            if (lastPathPoint.controlPt2) {
                ctrlPt = this.currentPath.localToGlobal(lastPathPoint.controlPt2.x, lastPathPoint.controlPt2.y);
            } else if (lastPathPoint.controlPt1) {
                ctrlPt = this.currentPath.localToGlobal(lastPathPoint.controlPt1.x, lastPathPoint.controlPt1.y);
            }

            xc = segmentPointList[0].x - (ctrlPt.x - segmentPointList[0].x);
            yc = segmentPointList[0].y - (ctrlPt.y - segmentPointList[0].y);

            const globalPointA = segmentPointList[0];
            const globalPointB = {
                x: xc,
                y: yc
            };
            let offset,
            x,
            y;

            // aggiusta il control point in base alla distanza dall'ultimo punto
            if (Math.abs(globalPointB.x - globalPointA.x) > Math.abs(globalPointB.y - globalPointA.y)) {
                x = this.currentPenEvent.workspaceX;
                offset = (this.currentPenEvent.workspaceX - globalPointA.x) / (globalPointB.x - globalPointA.x);
                y = globalPointA.y + ((globalPointB.y - globalPointA.y) * offset);
            } else {
                y = this.currentPenEvent.workspaceY;
                offset = (this.currentPenEvent.workspaceY - globalPointA.y) / (globalPointB.y - globalPointA.y);
                x = globalPointA.x + ((globalPointB.x - globalPointA.x) * offset);
            }

            xc = x;
            yc = y;

            segmentPointList[1].controlPt1.x = xc;
            segmentPointList[1].controlPt1.y = yc;

            if (segmentPointList[1].controlPt2) {
                segmentPointList[1].controlPt2.x = segmentPointList[1].x;
                segmentPointList[1].controlPt2.y = segmentPointList[1].y;
            }
        }

        this.interactiveSegment.render();
        this.interactiveSegment.classList.add('showed');
    }

    editSegmentCtrlPoint() {
        const segmentPointList = this.interactiveSegment.getGeometryPointList();

        const xc = segmentPointList[1].x - (this.pointC.workspaceX - segmentPointList[1].x);
        const yc = segmentPointList[1].y - (this.pointC.workspaceY - segmentPointList[1].y);

        if (segmentPointList[1].controlPt2) {
            segmentPointList[1].controlPt2.x = xc;
            segmentPointList[1].controlPt2.y = yc;
        } else {
            segmentPointList[1].controlPt1.x = xc;
            segmentPointList[1].controlPt1.y = yc;
        }

        this.interactiveSegment.render();
    };

    setPointA(_e) {
        this.pointA = this.currentPenEvent;
        this.pointB = this.currentPenEvent;
        this.pointC = null;
        if (!this.currentPath)
            this.createElement(_e);
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY));
        this.createInteractiveSegment();
    }

    setPointB(_e) {
        this.pointB = this.currentPenEvent;
        this.updateDrawingInteraction(_e);
    }

    // edit control point
    setPointC(_e) {
        this.pointC = this.currentPenEvent;
        this.editSegmentCtrlPoint();
    }

    // updateSnapStartPoint( _e)
    // {
    //     let pointPathList = this.currentPath.getGeometryPointList();
    //     const lastPathPoint = pointPathList[ pointPathList.length-1 ];
    //     const lastPathPointInContentSpace =  lastPathPoint.matrixTransform( this.currentPath.getTransformToElement(activeApplication.activeDocument.activePage.content) );
    //     activeApplication.workspace.snapInteraction2D.createVirtualOrigin( SVGUtils.createSVGPoint(lastPathPointInContentSpace.x,lastPathPointInContentSpace.y) );
    // }

    onPointerDown(_e) {
        if (KEYBOARD_EVENT_MANAGER.spaceKeyPressed) {
            TOOLS['pan-tool'].initDrag(this.currentPenEvent);
            return;
        }

        const activeDocument = activeApplication.activeDocument;
        if (activeDocument.getActivePageLayer().isLocked()) {
            DIALOGS['alert-dialog'].open(localString('The active layer is locked!'), localString('Unlock the active layer to draw in it.'));
            return;
        }

        if (this.pointA === null) {
            this.setPointA();
            return;
        }

        this.setPointB();

        XOS.initDragFunctions(this, _e);
    }

    // se è stato fatto il drag non si verifica !
    onPointerUp(_e) {
        if (this.pointA && this.pointB) {
            if (this.isClickedToStopCurveContinuity()) {
                this.createInteractiveSegment('INTERACTIVE_PATH_SEGMENT_L');
                return;
            }
            this.addSegmentToCurrentPath();
            if (this.isClickedToClosePath()) {
                this.closePath();
                this.finalize(_e);
            } else {
                this.currentPenEvent = this.pointB;
                this.setPointA(_e);
            }
        }
    }

    onPointerMove(_e) {
        this.pointerEventToCoords(_e);
        this.currentPenEvent = _e;
        if (this.pointA === null)
            return;
        this.setPointB();
    }

    onDragStart(_e) {
        if (this.pointA && this.pointB) {
            if (this.interactiveSegment.getAttribute('id') === 'INTERACTIVE_PATH_SEGMENT_L')
                this.changeInteractiveSegment();
            this.setPointC(_e);
        }
    }

    onDrag(_e) {
        if (this.pointA && this.pointB && this.pointC) {
            this.pointerEventToCoords(_e);
            this.currentPenEvent = _e;
            this.setPointC(_e);
        }
    }

    onDragEnd(_e) {
        if (this.pointA && this.pointB && this.pointC) {
            this.addSegmentToCurrentPath();
            if (this.isClickedToClosePath()) {
                this.closePath();
                this.finalize(_e);
            } else {
                this.currentPenEvent = this.pointB;
                this.setPointA(_e);
            }
        }
    }
}

new DrawPath2D_tool("draw-path-tool", 'P');

class Offset2D_tool extends BaseDraw2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'linear-interaction');
        this.offset = null;
    }

    reset(_e) {
        super.reset(_e);
        this.offset = null;
        this.cachedPath = null;
    }

    onKeyDown(_e) {
        const activeDocument = activeApplication.activeDocument;

        const KEY_NAME = KEYBOARD_EVENT_MANAGER.KEY_CODE_TO_NAME[_e.keyCode];

        switch (KEY_NAME) {

        case 'BACKSPACE':
        case 'DELETE':

            if (this.cachedPath)
                return;
            COMMANDS.delete.execute();
            _e.preventDefault();
            _e.stopPropagation();
            this.reset();
            break;

        case 'TAB':

            WINDOWS['mainInspectorWindow'].showMainSection('tool-section');
            if (this.offset)
                PANELS['offset-tool-info'].setInputPropertyFocus('offset', this.offset);

            _e.preventDefault();
            break;

        case 'ESC':
            this.reset();
            _e.preventDefault();
            break;
        }

    }

    setPointA(_e) {
        this.offset = null;
        if (!this.currentPenEvent.elementAtPoint)
            return;
        this.currentPenEvent.elementAtPoint = this.currentPenEvent.elementAtPoint.getMainElement();
        this.reset();
        //console.log('this.currentPenEvent.elementAtPoint.getMainElement()',this.currentPenEvent.elementAtPoint.getMainElement());
        activeApplication.activeDocument.selectElementList([this.currentPenEvent.elementAtPoint]);
        activeApplication.workspace.update();
        this.pointA = this.currentPenEvent;
        //activeApplication.workspace.snapInteraction2D.createVirtualOrigin( SVGUtils.createSVGPoint(this.pointA.contentX,this.pointA.contentY) );
    }

    updateDrawingInteraction(_e) {
        if (this.pointA.elementAtPoint.nodeName === 'line') {
            const line = this.pointA.elementAtPoint;
            if (_e.offsetValue) // viene settato dal pannello dello strumento
            {
                this.offset = _e.offsetValue;
            } else {
                const pointerInLocal = line.globalToLocal(this.pointB.workspaceX, this.pointB.workspaceY)
                    const pointerOnLine = GeometryUtils.getClosestPointToLine(line.getPt1(), line.getPt2(), pointerInLocal);
                const projectionPoint = SVGUtils.createSVGPoint(pointerOnLine.point.x, pointerOnLine.point.y);
                this.offset = pointerInLocal.getDistanceFromPoint(projectionPoint)
                    if (pointerOnLine.left)
                        this.offset = 0 - this.offset;
            }

            const newLinePoints = GeometryUtils.lineOffset(line.getPt1(), line.getPt2(), this.offset);
            line.selectionPreview.updateGeometry(newLinePoints.pt1.x, newLinePoints.pt1.y, newLinePoints.pt2.x, newLinePoints.pt2.y);
        } else if (this.pointA.elementAtPoint.nodeName === 'rect') {
            const rectangle = this.pointA.elementAtPoint;

            const x = parseFloat(rectangle.getAttribute('x'));
            const y = parseFloat(rectangle.getAttribute('y'));
            const width = parseFloat(rectangle.getAttribute('width'));
            const height = parseFloat(rectangle.getAttribute('height'));

            if (_e.offsetValue) // viene settato dal pannello dello strumento
            {
                this.offset = _e.offsetValue;
            } else {
                const pointerInLocal = rectangle.globalToLocal(this.pointB.workspaceX, this.pointB.workspaceY);

                const cx = x + width / 2;
                const cy = y + height / 2;

                //let offset=0;
                const newRadiusX = Math.abs(pointerInLocal.x - cx);
                const newRadiusY = Math.abs(pointerInLocal.y - cy);

                if ((newRadiusX - width / 2) > (newRadiusY - height / 2)) {
                    this.offset = newRadiusX - width / 2;
                } else {
                    this.offset = newRadiusY - height / 2;
                }
            }

            rectangle.selectionPreview.updateGeometry(x - this.offset, y - this.offset, width + (this.offset * 2), height + (this.offset * 2));
        } else if (this.pointA.elementAtPoint.nodeName === 'ellipse') {
            const ellipse = this.pointA.elementAtPoint;
            const cx = parseFloat(ellipse.getAttribute('cx'));
            const cy = parseFloat(ellipse.getAttribute('cy'));
            const rx = parseFloat(ellipse.getAttribute('rx'));
            const ry = parseFloat(ellipse.getAttribute('ry'));

            if (_e.offsetValue) // viene settato dal pannello dello strumento
            {
                this.offset = _e.offsetValue;
            } else {
                const pointerInLocal = ellipse.globalToLocal(this.pointB.workspaceX, this.pointB.workspaceY);
                const newRadiusX = Math.abs(pointerInLocal.x - cx);
                const newRadiusY = Math.abs(pointerInLocal.y - cy);

                if ((newRadiusX - rx) > (newRadiusY - ry)) {
                    this.offset = newRadiusX - rx;
                } else {
                    this.offset = newRadiusY - ry;
                }
            }

            ellipse.selectionPreview.updateGeometry(cx, cy, rx + this.offset, ry + this.offset);
        } else if (this.pointA.elementAtPoint.dataset.objectId === 'arc-object') {
            const arc = this.pointA.elementAtPoint;

            const pathArc = arc.selectionPreview.querySelector('path');

            // memorizzo il controller, per non far caricare sempre le proprietà
            if (!arc.objectController) {
                arc.objectController = arc.getObjectController();
            }

            let radius;

            if (_e.offsetValue) // viene settato dal pannello dello strumento
            {
                this.offset = _e.offsetValue;
                radius = arc.objectController.properties.radius + this.offset;
            } else {
                const pointerInLocal = arc.globalToLocal(this.pointB.workspaceX, this.pointB.workspaceY);
                radius = pointerInLocal.getDistanceFromPoint(SVGUtils.createSVGPoint());
                this.offset = radius - arc.objectController.properties.radius;
            }

            this.newRadius = radius;

            pathArc.buildArc({
                x: 0,
                y: 0
            }, radius, arc.objectController.properties.startAngle, arc.objectController.properties.endAngle);

        } else if (this.pointA.elementAtPoint.nodeName === 'path') {
            const path = this.pointA.elementAtPoint;

            if (!this.cachedPath) {
                this.cachedPath = path.cloneNode();
                this.cachedPath.setGeometryPointList(this.cachedPath.reduceCurves());

                // solo per testare quanto sono vicino al bordo per determinare il valore dell'offset tramite la distanza dalle linee
                this.cachedPath.polygonVertices = path.cloneNode().toPolygonVertices();
            }

            if (_e.offsetValue) // viene settato dal pannello dello strumento
            {
                this.offset = _e.offsetValue;
            } else {
                const pointerInLocal = path.globalToLocal(this.pointB.workspaceX, this.pointB.workspaceY);

                let offsetValue = 20000;

                const polygonVertices = this.cachedPath.polygonVertices;
                const max = polygonVertices.length;
                let isLeft = true;
                for (let i = 0; i < max - 1; i++) {
                    let result = GeometryUtils.getClosestPointToLine(polygonVertices[i], polygonVertices[i + 1], pointerInLocal, true);
                    let tempDistance = pointerInLocal.getDistanceFromPoint(result.point);
                    if (tempDistance < offsetValue) {
                        offsetValue = tempDistance;
                        isLeft = result.left;
                    }
                }

                if (isLeft)
                    offsetValue = 0 - offsetValue;

                this.offset = offsetValue;

            }

            path.selectionPreview.setAttribute('d', this.cachedPath.getOffsetPath(this.offset));

            // const offsetPath = this.cachedPath.getOffsetPath( this.offset );
            // path.selectionPreview.setAttribute('d',offsetPath.getAttribute('d'));

        }

    }

    onReadyPoints_A_B(_e) {
        this.finalize(_e);
    }

    createElement(_e) {
        if (this.pointA.elementAtPoint.nodeName === 'line') {
            const line1 = this.pointA.elementAtPoint;
            this.createdElement = line1.cloneNode(true);
            this.createdElement.updateGeometry(line1.selectionPreview.getPt1().x, line1.selectionPreview.getPt1().y, line1.selectionPreview.getPt2().x, line1.selectionPreview.getPt2().y);
        } else if (this.pointA.elementAtPoint.nodeName === 'rect') {
            const rectangle = this.pointA.elementAtPoint;
            this.createdElement = rectangle.cloneNode(true);
            this.createdElement.updateGeometry(rectangle.selectionPreview.getAttribute('x'), rectangle.selectionPreview.getAttribute('y'), rectangle.selectionPreview.getAttribute('width'), rectangle.selectionPreview.getAttribute('height'));
        } else if (this.pointA.elementAtPoint.nodeName === 'ellipse') {
            const ellipse = this.pointA.elementAtPoint;
            this.createdElement = ellipse.cloneNode(true);
            this.createdElement.updateGeometry(ellipse.selectionPreview.getAttribute('cx'), ellipse.selectionPreview.getAttribute('cy'), ellipse.selectionPreview.getAttribute('rx'), ellipse.selectionPreview.getAttribute('ry'));
        } else if (this.pointA.elementAtPoint.dataset.objectId === 'arc-object') {
            const arc = this.pointA.elementAtPoint;
            this.createdElement = arc.cloneNode(true);
            const objectController = this.createdElement.getObjectController();
            objectController.setProperties({
                radius: this.newRadius
            });
        } else if (this.pointA.elementAtPoint.nodeName === 'path') {
            const path = this.pointA.elementAtPoint;
            this.createdElement = path.cloneNode(true);
            this.createdElement.setAttribute('d', path.selectionPreview.getAttribute('d'));
        }

        activeApplication.activeDocument.getActivePageLayer().appendChild(this.createdElement);
    }

}

new Offset2D_tool("offset-tool", 'O');

class JoinFillet2D_tool extends BaseDraw2D_tool {

    constructor(_name, _shortcut) {
        super(_name, _shortcut, 'linear-interaction');
        this.filletRadius = 20;
    }

    pointerEventToCoords(_e) {
        const activeDocument = activeApplication.activeDocument;
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
    }

    onReadyPoints_A_B(_e) {
        // bo!! non va!
        // console.log('this.pointA.segmentListAtPoint',this.pointA.segmentListAtPoint);
        // console.log('this.pointB.segmentListAtPoint',this.pointB.segmentListAtPoint);
        // if( this.pointA.segmentListAtPoint && this.pointB.segmentListAtPoint )
        // {
        //     if( this.pointA.elementAtPoint && this.pointA.elementAtPoint.nodeName === 'path' &&  this.pointB.elementAtPoint && this.pointB.elementAtPoint.nodeName === 'path' )
        //     {
        //         if( this.pointA.elementAtPoint === this.pointB.elementAtPoint )
        //         {
        //             if( this.pointA.segmentListAtPoint[0] !== this.pointB.segmentListAtPoint[0] )
        //             {
        //                 if(  this.pointA.segmentListAtPoint[0].type === 'linear' && this.pointB.segmentListAtPoint[0].type === 'linear' )
        //                 {
        //                     console.log('createFillet',this.pointB.segmentListAtPoint);
        //                     const path = this.pointA.elementAtPoint;
        //                     // const geometryPointList = path.getGeometryPointList();
        //                     // const segment1 = geometryPointList[  this.pointA.segmentListAtPoint[0].pt2 ];
        //                     // const segment2 = geometryPointList[  this.pointB.segmentListAtPoint[0].idSegment ];
        //
        //                     path.createFillet( 30 , this.pointA.segmentListAtPoint[0].pt2 , this.pointB.segmentListAtPoint[0].pt2 );
        //                 }
        //             }
        //         }
        //         //this.finalize(_e);
        //     }
        //     else if( this.pointA.elementAtPoint && this.pointA.elementAtPoint.nodeName === 'line' &&  this.pointB.elementAtPoint && this.pointB.elementAtPoint.nodeName === 'line' )
        //     {
        //         this.finalize(_e);
        //         return;
        //     }
        // }

        if (this.pointA.elementAtPoint && this.pointA.elementAtPoint.nodeName === 'line' && this.pointB.elementAtPoint && this.pointB.elementAtPoint.nodeName === 'line') {
            this.finalize(_e);
        }

        this.reset();
    }

    createElement() {

        const _line1 = this.pointA.elementAtPoint;
        const _line2 = this.pointB.elementAtPoint;

        const line1_pt1 = _line1.getPt1();
        const line1_pt2 = _line1.getPt2();
        const line2_pt1 = _line2.getPt1();
        const line2_pt2 = _line2.getPt2();

        // servirà per l'undo
        this.line1OriginalPoints = _line1.getGeometryPointList();
        this.line2OriginalPoints = _line2.getGeometryPointList();

        _line1.geometryPointList = null;
        _line2.geometryPointList = null;

        // porto i punti della linea 2 all'interno della linea 1
        const line2Pts_inside_line1 = _line2.getTransformToElement(_line1).transformPointList([line2_pt1, line2_pt2]);
        let intersectionPoint_inside_line1 = GeometryUtils.getLineLineIntersection(line1_pt1, line1_pt2, line2Pts_inside_line1[0], line2Pts_inside_line1[1]);

        if (intersectionPoint_inside_line1) {

            const line1MatrixInContent = _line1.getTransformToElement(activeApplication.activeDocument.activePage.content);
            const line2MatrixInContent = _line2.getTransformToElement(activeApplication.activeDocument.activePage.content);
            const intersectionPointInContent = line1MatrixInContent.transformPointList([intersectionPoint_inside_line1])[0];
            let line1_startPointInContent,
            line2_endPointInContent;

            const distance_intersection_line1_pt1 = line1_pt1.getDistanceFromPoint(intersectionPoint_inside_line1);
            const distance_intersection_line1_pt2 = line1_pt2.getDistanceFromPoint(intersectionPoint_inside_line1);

            let line1_point_to_move_id,
            line2_point_to_move_id;

            if (distance_intersection_line1_pt1 < distance_intersection_line1_pt2) {
                _line1.updateGeometry(intersectionPoint_inside_line1.x, intersectionPoint_inside_line1.y, line1_pt2.x, line1_pt2.y);
                line1_startPointInContent = line1MatrixInContent.transformPointList([line1_pt2])[0];
                line1_point_to_move_id = 0;
            } else {
                _line1.updateGeometry(line1_pt1.x, line1_pt1.y, intersectionPoint_inside_line1.x, intersectionPoint_inside_line1.y);
                line1_startPointInContent = line1MatrixInContent.transformPointList([line1_pt1])[0];
                line1_point_to_move_id = 1;
            }

            // porto il punto di intersezione all'interno della linea 2
            const intersectionPoint_inside_line2 = _line1.getTransformToElement(_line2).transformPointList([intersectionPoint_inside_line1])[0];
            //intersectionPoint = intersectionPoint_inside_line2[0];

            const distance_intersection_line2_pt1 = line2_pt1.getDistanceFromPoint(intersectionPoint_inside_line2);
            const distance_intersection_line2_pt2 = line2_pt2.getDistanceFromPoint(intersectionPoint_inside_line2);

            if (distance_intersection_line2_pt1 < distance_intersection_line2_pt2) {
                _line2.updateGeometry(intersectionPoint_inside_line2.x, intersectionPoint_inside_line2.y, line2_pt2.x, line2_pt2.y);
                line2_endPointInContent = line2MatrixInContent.transformPointList([line2_pt2])[0];
                line2_point_to_move_id = 0;
            } else {
                _line2.updateGeometry(line2_pt1.x, line2_pt1.y, intersectionPoint_inside_line2.x, intersectionPoint_inside_line2.y);
                line2_endPointInContent = line2MatrixInContent.transformPointList([line2_pt1])[0];
                line2_point_to_move_id = 1;
            }

            let angleSeg1 = GeometryUtils.getSegmentAngle(intersectionPointInContent, line1_startPointInContent);
            let angleSeg2 = GeometryUtils.getSegmentAngle(intersectionPointInContent, line2_endPointInContent);

            const area = GeometryUtils.getPolygonArea([line1_startPointInContent, intersectionPointInContent, line2_endPointInContent]);
            //console.log('area',area);
            if (area < 0) {
                angleSeg1 = GeometryUtils.getSegmentAngle(intersectionPointInContent, line2_endPointInContent);
                angleSeg2 = GeometryUtils.getSegmentAngle(intersectionPointInContent, line1_startPointInContent);
            }

            let angleDifference = angleSeg2 - angleSeg1;

            let angleBetweenSegs = angleSeg2 - (angleDifference / 2);

            if (angleDifference > 0)
                angleBetweenSegs += Math.PI;

            let distance = Math.abs(this.filletRadius / Math.sin((angleDifference / 2)));

            const filletCenter = intersectionPointInContent.add(SVGUtils.createSVGPoint(Math.cos(angleBetweenSegs) * distance, Math.sin(angleBetweenSegs) * distance));

            let objectController = OBJECTS['arc-object'];
            const svg = SVGUtils.createSVG();
            svg.innerHTML = objectController.create();
            const newArc = svg.firstElementChild;
            objectController = newArc.getObjectController();
            newArc.setAttribute('stroke', _line1.getAttribute('stroke'));
            newArc.setAttribute('stroke-width', _line1.getAttribute('stroke-width'));
            newArc.setAttribute('fill', 'none');
            activeApplication.activeDocument.getActivePageLayer().appendChild(newArc);
            let arc_startAngle = angleSeg1 / (Math.PI / 180) + 90;
            let arc_endAngle = angleSeg2 / (Math.PI / 180) - 90;
            objectController.setProperties({
                startAngle: arc_startAngle,
                endAngle: arc_endAngle,
                radius: this.filletRadius
            })
            newArc.getTransform().setMatrix(newArc.getTransform().matrix.translate(filletCenter.x, filletCenter.y));

            const arc_points_in_Line1 = newArc.getTransformToElement(_line1).transformPointList([objectController.arcResult.startPt, objectController.arcResult.endPt]);
            const arc_points_in_Line2 = newArc.getTransformToElement(_line2).transformPointList([objectController.arcResult.startPt, objectController.arcResult.endPt]);

            if (area < 0) {
                let temp = arc_points_in_Line1[0];
                arc_points_in_Line1[0] = arc_points_in_Line1[1];
                arc_points_in_Line1[1] = temp;

                temp = arc_points_in_Line2[0];
                arc_points_in_Line2[0] = arc_points_in_Line2[1];
                arc_points_in_Line2[1] = temp;
            }

            if (line1_point_to_move_id === 0) {
                _line1.updateGeometry(arc_points_in_Line1[0].x, arc_points_in_Line1[0].y, line1_pt2.x, line1_pt2.y);
            } else {
                _line1.updateGeometry(line1_pt1.x, line1_pt1.y, arc_points_in_Line1[0].x, arc_points_in_Line1[0].y);
            }

            if (line2_point_to_move_id === 0) {
                _line2.updateGeometry(arc_points_in_Line2[1].x, arc_points_in_Line2[1].y, line2_pt2.x, line2_pt2.y);
            } else {
                _line2.updateGeometry(line2_pt1.x, line2_pt1.y, arc_points_in_Line2[1].x, arc_points_in_Line2[1].y);
            }

            this.createdElement = newArc;

        }

    }

    createUndoRedoActions(_createdElementList) {
        if (!(_createdElementList instanceof Array))
            _createdElementList = [_createdElementList];

        const historyActions = super.createUndoRedoActions(_createdElementList);

        const activeDocument = activeApplication.activeDocument;

        const _line1 = this.pointA.elementAtPoint;
        const _line2 = this.pointB.elementAtPoint;

        const line1OriginalPoints = this.line1OriginalPoints;
        const line2OriginalPoints = this.line2OriginalPoints;

        const line1CurrentPoints = _line1.getGeometryPointList();
        const line2CurrentPoints = _line2.getGeometryPointList();

        historyActions.redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(_createdElementList);
            _line1.setGeometryPointList(line1CurrentPoints);
            _line2.setGeometryPointList(line2CurrentPoints);
            _line1.render();
            _line2.render();
        };

        historyActions.undoAction.onExecuteEnd = function () {
            _line1.setGeometryPointList(line1OriginalPoints);
            _line2.setGeometryPointList(line2OriginalPoints);
            _line1.render();
            _line2.render();
        };

    }

}

new JoinFillet2D_tool("join-fillet-tool", 'J');

class DrawObject2D_tool extends BaseDraw2D_tool{
    constructor(_name, _shortcut, _interactionMode) {
        super(_name, _shortcut, _interactionMode);
        this.objectId = null; // verrà settato selezionando il tool dalla paletta degli strumenti
        this.objectController = null;
    }

    onActivate() {
        super.onActivate();
        this.objectController = OBJECTS[this.objectId];
        if (this.objectController.type === 'linear-object') {
            this.interactionMode = 'linear-interaction';
        } else if (this.objectController.type === 'rectangular-object') {
            this.interactionMode = 'rectangular-interaction';
        } else if (this.objectController.type === 'radial-object') {
            this.interactionMode = 'radial-interaction';
        }

    }

    onReadyPoints_A_B(_e) {
        if (this.objectController.type === 'radial-object') {
            if (this.objectController.drawByDiameter) {
                // A e B definiscono il diametro , imposto point A come centro
                this.pointA.workspaceX = this.pointA.workspaceX + (this.pointB.workspaceX - this.pointA.workspaceX) / 2;
                this.pointA.workspaceY = this.pointA.workspaceY + (this.pointB.workspaceY - this.pointA.workspaceY) / 2;
                activeApplication.activeDocument.workspaceToPageContentCoords(this.pointA);
                activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY));
            }
        } else if (this.objectController.type === 'linear-object' && this.objectController.createBy3Points) {
            // A e B definiscono la lunghezza
            activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY));
            // C definirà l'altezza ed il verso dell'altezza
        } else {
            this.finalize(_e);
        }

    }

    onReadyPoints_A_B_C(_e) {
        this.finalize(_e);
    }

    createElement(_e) {

        if (this.pointA.contentX === this.pointB.contentX && this.pointA.contentY === this.pointB.contentY)
            return;

        if (this.interactionMode === 'rectangular-interaction') {
            let x = Math.min(this.pointA.contentX, this.pointB.contentX);
            let y = Math.min(this.pointA.contentY, this.pointB.contentY);
            let w = Math.abs(this.pointB.contentX - this.pointA.contentX);
            let h = Math.abs(this.pointB.contentY - this.pointA.contentY);

            if (w === 0)
                w = 1;
            if (h === 0)
                h = 1;

            if (_e.altKey) {
                x -= w;
                y -= h;
                w += w;
                h += h;
            }

            this.createRectangularObject(x, y, w, h);

        } else if (this.interactionMode === 'linear-interaction') {
            this.createLinearObject();
        } else if (this.interactionMode === 'radial-interaction') {
            this.createRadialObject();
        }
    }

    createRectangularObject(x, y, w, h) {
        const activeDocument = activeApplication.activeDocument;
        const svg = SVGUtils.createSVG();
        svg.innerHTML = this.objectController.create();
        this.createdElement = svg.firstElementChild;
        this.createdElement.setAttribute('transform', 'matrix(1,0,0,1,' + x + ',' + y + ')');

        this.objectController = this.createdElement.getObjectController();
        activeApplication.activeDocument.getActivePageLayer().appendChild(this.createdElement);
        this.objectController.setProperties({
            width: w,
            height: h
        });

        //
        if (!this.createdElement.hasAttribute('stroke'))
            activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        if (!this.createdElement.hasAttribute('fill'))
            activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);
    }

    createLinearObject() {
        const activeDocument = activeApplication.activeDocument;
        const svg = SVGUtils.createSVG();
        svg.innerHTML = this.objectController.create();
        this.createdElement = svg.firstElementChild;

        this.objectController = this.createdElement.getObjectController();

        if (this.pointC && this.pointC.height) {
            this.objectController.properties.height = this.pointC.height;
        }

        activeApplication.activeDocument.getActivePageLayer().appendChild(this.createdElement);
        this.objectController.setLinearObjectPoints(SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY), SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY));

        if (!this.createdElement.hasAttribute('stroke'))
            activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        if (!this.createdElement.hasAttribute('fill'))
            activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);

    }

    createRadialObject() {
        const activeDocument = activeApplication.activeDocument;

        const svg = SVGUtils.createSVG();
        svg.innerHTML = this.objectController.create();

        this.createdElement = svg.firstElementChild;
        this.createdElement.setAttribute('transform', 'matrix(1,0,0,1,' + this.pointA.contentX + ',' + this.pointA.contentY + ')');

        const pt1 = SVGUtils.createSVGPoint(this.pointA.contentX, this.pointA.contentY);
        const pt2 = SVGUtils.createSVGPoint(this.pointB.contentX, this.pointB.contentY)
            const pt3 = SVGUtils.createSVGPoint(this.pointC.contentX, this.pointC.contentY);

        this.objectController = this.createdElement.getObjectController();

        let angleStart = 0;
        let angleEnd = 0;

        angleStart = pt1.getAngleFromPoint(pt2, true);
        angleEnd = pt1.getAngleFromPoint(pt3, true);

        if (this.inversion) {
            const temp = angleStart;
            angleStart = angleEnd;
            angleEnd = temp;
        }

        if (angleEnd < angleStart)
            angleEnd += 360;

        const radius = pt2.getDistanceFromPoint(pt1);
        activeDocument.getActivePageLayer().appendChild(this.createdElement);

        this.objectController.setProperties({
            radius: radius,
            startAngle: angleStart,
            endAngle: angleEnd
        })

        if (!this.createdElement.hasAttribute('stroke'))
            activeDocument.fillAndStrokeManager.apply_stroke(this.createdElement);
        if (!this.createdElement.hasAttribute('fill'))
            activeDocument.fillAndStrokeManager.apply_fill(this.createdElement);
    };

}

new DrawObject2D_tool('draw-object-tool');

class BaseObject2D_object {

    constructor(_objectId, _objectType = 'rectangular-object', _toolName, _shortcut) {
        this.type = _objectType;
        OBJECTS[_objectId] = this;
        this.properties = {};
        this.graphicElement = null;
        this.elements = null;
        this.isInitialized = false;
        //if(_toolName) TOOLS[ _toolName ] = TOOLS[ 'draw-object-tool' ]; // creo un riferimento a draw-object-tool ma con il nome del nuovo tool
        if (_toolName) {
            //TOOLS[ _toolName ] = TOOLS[ 'draw-object-tool' ];  // creo un riferimento a draw-object-tool ma con il nome del nuovo tool
            TOOLS[_toolName] = new DrawObject2D_tool(_toolName, _shortcut); // creo un draw-object-tool ma con il nome del nuovo tool
            TOOLS[_toolName].objectId = _objectId;
        }
    }

    init(_graphicElement) {
        this.graphicElement = _graphicElement;
        this.properties = _graphicElement.getStoredJsonData('jvs-object-properties') || this.properties;
        const editableElements = _graphicElement.querySelectorAll('[data-name]');
        this.elements = {};
        for (let i = 0; i < editableElements.length; i++)
            this.elements[editableElements[i].dataset.name] = editableElements[i];
    }

    getProperties() {
        return this.properties;
    }

    setProperties(_propertyKeyValues) {
        for (let propertyName in _propertyKeyValues)
            this.properties[propertyName] = _propertyKeyValues[propertyName];
        this.update();
    }

    update() {
        this.graphicElement.storeJsonData("jvs-object-properties", this.properties);
    }

    createResources(_resourcesAsString) {
        const svg = SVGUtils.createSVG();
        svg.innerHTML = _resourcesAsString;
        while (svg.firstElementChild)
            activeApplication.activeDocument.resources.addResource(svg.firstElementChild);
    }

    // usato da linear object
    setLinearObjectPoints(_pt1, _pt2) {
        let angleDeg = GeometryUtils.getAngleBetweenPoints(_pt2, _pt1) / (Math.PI / 180);
        let width = _pt2.getDistanceFromPoint(_pt1);
        let matrix = this.graphicElement.getTransform().matrix;
        matrix.identity();
        matrix = matrix.translate(_pt1.x, _pt1.y);
        matrix = matrix.rotate(angleDeg);

        this.graphicElement.getTransform().setMatrix(matrix);
        this.setProperties({
            width: width
        });
    }

    normalizeScale(_scaleX, _scaleY, _scaleAverageXY) {
        if (this.type === 'linear-object' || this.type === 'rectangular-object') {
            this.setProperties({
                width: this.properties.width * _scaleX,
                height: this.properties.height * _scaleY
            });
        } else if (this.type === 'radial-object') {
            const scaledRadius = this.properties.radius * _scaleAverageXY;
            this.setProperties({
                radius: scaledRadius
            });
        }
    }

    createInspector() {
        return '';
    }

    showInteraction() {
        if (this.type === 'linear-object') {
            const linearObjectInteraction2D = activeApplication.workspace.linearObjectInteraction2D;
            linearObjectInteraction2D.show();
        } else if (this.type === 'radial-object') {
            const radialObjectInteraction2D = activeApplication.workspace.radialObjectInteraction2D;
            radialObjectInteraction2D.show();
        } else {
            const bboxInteraction2D = activeApplication.workspace.bboxInteraction2D;
            bboxInteraction2D.show();
        }
    }

    create() {
        return '';
    }

    convertToPath() {
        return null;
    }

}

class Arc2D_object extends BaseObject2D_object {

    constructor() {
        super('arc-object', 'radial-object', 'draw-arc-tool', 'U');
        this.properties.startAngle = 0;
        this.properties.endAngle = 90;
        this.properties.radius = 100;
    }

    convertToPath(_graphicElement) {
        const newPath = _graphicElement.querySelector('[data-name="arc-stroke"]').cloneNode();
        newPath.getTransform().setMatrix(_graphicElement.getTransform().matrix.clone());
        newPath.setGraphicAttributesByElement(_graphicElement);
        return newPath;
    }

    update() {
        this.arcResult = this.elements['arc-stroke'].buildArc({
            x: 0,
            y: 0
        }, this.properties.radius, this.properties.startAngle, this.properties.endAngle);
        this.elements['arc-fill'].setAttribute('d', this.elements['arc-stroke'].getAttribute('d') + 'L0 0 Z');
        this.elements['arc-stroke'].geometryPointList = this.elements['arc-fill'].geometryPointList = null;
        super.update();
    }

    create() {
        return `<g data-type="object" data-object-id="arc-object" stroke="#000000" fill="none" stroke-width="1" >
                    <path  data-name="arc-fill" d="M 0 0" stroke="none" ></path>
                    <path data-name="arc-stroke" fill="none" ></path>
                </g>`;
    }

    createInspector() {
        return `
                <arc-object-inspector>
                    <div class="property-container">

                        <div class="header">
                            <div class="title">Arc</div>
                        </div>

                        <div class="content">

<!--                            <div class="input-property">-->
<!--                                <div class="label">Radius</div>-->
<!--                                <input name="radius" type="text" data-property-type="dimension" data-event="change:onChangeProperty"/>-->
<!--                            </div>-->
<!--                            -->
<!--                            <div class="input-property">-->
<!--                                <div class="label">Start angle</div>-->
<!--                                <input name="startAngle" type="text" data-property-type="angle" data-event="change:onChangeProperty"/>-->
<!--                            </div>-->
<!--                            -->
<!--                            <div class="input-property">-->
<!--                                <div class="label">End angle</div>-->
<!--                                <input name="endAngle" type="text" data-property-type="angle" data-event="change:onChangeProperty"/>-->
<!--                            </div>-->
                            
                             <div class="input-property">
                                    <button  data-event="click:executeCommand" data-event-manager-path="activeApplication" data-cmd="convertToPath" data-translate >Convert to path</button>
                                </div>

                        </div>

                    </div>
                </arc-object-inspector>
             `;
    }

}

new Arc2D_object();

/* ----------   INSPECTOR PROPERTIES  ------------------- */

class ArcObject_inspector extends BaseObjectInspector_cmp{
    constructor() {
        super();
    }
}

customElements.define("arc-object-inspector", ArcObject_inspector);

class GroupEditing_layer{
    constructor(_layer, _editableElement) {
        this.graphicLayer = _layer;
        this.editableElementRef = _editableElement;
    }

    onAdded() {
        //console.log('GroupEditing_layer onAdded');
        this.editableElementRef.classList.add('hidden');
        activeApplication.activeDocument.classList.add('isolate-layer-editing');
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        activeDocument.setActivePageLayer(this.graphicLayer);
        activeDocument.deselectAll();
        activeApplication.workspace.isolateLayerBar.update();
    };

    onRemoved() {
        this.editableElementRef.classList.remove('hidden');
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const layers = activePage.content.querySelector('.layers');
        if (!layers.lastElementChild.classList.contains('isolate-layer'))
            activeApplication.activeDocument.classList.remove('isolate-layer-editing');
        activeDocument.setActivePageLayer(layers.lastElementChild);
        activeDocument.deselectAll();
        activeApplication.workspace.update();
        activeApplication.workspace.isolateLayerBar.update();
        //console.log('onRemoved');
    };

    enterToEditing() {
        this.onAdded();
        this.cloneAndAppendElementListInPlace(this.editableElementRef.children, this.graphicLayer);
    };

    exitFromEditing() {
        this.editableElementRef.classList.remove('hidden');

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (this.graphicLayer.children.length === 0) {
            activeDocument.removeElementList_undable([this.editableElementRef]);
            // secondo me qui ci va questo
            // activeDocument.removePageLayer( this.graphicLayer );
            // this.onRemoved();
            return null;
        }
        const newGroup = this.editableElementRef.cloneNode();
        this.cloneAndAppendElementListInPlace(this.graphicLayer.children, newGroup, this.editableElementRef.getScreenCTM());

        this.createUndoRedoEditingAction(newGroup);
        activeDocument.removePageLayer(this.graphicLayer);

        this.onRemoved();

        //console.log('exitFromEditing',activePage.selectionList);
    };

    createUndoRedoEditingAction(_newElement) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (_newElement) {
            const undoAction = new UndoRedoAction('undo replace edited element in editable layer');
            const redoAction = new UndoRedoAction('redo replace edited element in editable layer');
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const parentElementTarget = this.editableElementRef.parentElement;
            const insertBeforeTarget = this.editableElementRef.nextElementSibling;

            undoAction.createDomNodeSnapshot([this.editableElementRef], 'insert');
            redoAction.createDomNodeSnapshot([this.editableElementRef], 'delete');

            XOS.removeElementList([this.editableElementRef]);

            parentElementTarget.insertBefore(_newElement, insertBeforeTarget);

            undoAction.createDomNodeSnapshot([_newElement], 'delete');
            redoAction.createDomNodeSnapshot([_newElement], 'insert');

            const graphicLayer = this.graphicLayer;

            undoAction.onExecuteEnd = function () {
                activeDocument.addPageLayer(graphicLayer);
                graphicLayer.controller.onAdded();
                activeApplication.workspace.update();
            };

            redoAction.onExecuteEnd = function () {
                activeDocument.removePageLayer(graphicLayer);
                graphicLayer.controller.onRemoved();
                activeApplication.workspace.update();
            };

        } else {

            activeDocument.removeElementList_undable([this.editableElementRef]);
        }

        //console.log('createUndoRedoEditingAction',activePage.selectionList);
    };

    // _elementList: devono essere già presenti nel dom.
    // _containerTarget se non è inserito nel dom allora  è necessario passare _containerScreenMatrix;
    cloneAndAppendElementListInPlace(_elementList, _containerTarget, _containerScreenMatrix) {
        _containerScreenMatrix = _containerScreenMatrix || _containerTarget.getScreenCTM();

        const containerInverseScreenMatrix = _containerScreenMatrix.inverse();
        const createdElements = [];
        let element,
        newElementMatrix;
        let id,
        max = _elementList.length;
        for (id = 0; id < max; id++) {
            element = _elementList[id];

            // non si sa perchè quando un foreign object entra in isolate layer editing resetta la sua matrice
            if (element.getScreenCTM) {
                newElementMatrix = containerInverseScreenMatrix.multiply(element.getScreenCTM()); // getTransformToElement
                element = element.cloneNode(true);
                element.getTransform().setMatrix(newElementMatrix);
                _containerTarget.appendChild(element);
            } else {
                element = element.cloneNode(true);
                _containerTarget.appendChild(element);
            }

            createdElements.push(element);
        }

        return createdElements;
    };

}

class SymbolEditing_layer extends GroupEditing_layer{

    constructor(_layer, _editableElement) {
        super(_layer, _editableElement);
        //this.classList.add('symbol');
        this.savedContentViewMatrix = null;
        this.savedViewMatrix = null;
    }

    onAdded() {
        const activeDocument = activeApplication.activeDocument;
        if (this.savedViewMatrix)
            activeDocument.setActivePageViewMatrix(this.savedViewMatrix)
            super.onAdded();
    };

    onRemoved() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.savedViewMatrix = activePage.content.getTransform().matrix.clone();
        activeDocument.setActivePageViewMatrix(this.savedContentViewMatrix);
        super.onRemoved();
    };

    // onEnterCalculateViewBox(  )
    // {
    // 	const localBox = this.graphicLayer.getLocalBBox();
    // 	const x = 0;
    // 	const y = 0;
    // 	const width = localBox.center.x*2;
    // 	const height = localBox.center.y*2;
    // 	this.elementViewBox = SVGUtils.createRect(x,y,width,height);
    // }


    // enterToEditing(  )
    // {
    // 	this.onAdded();
    // 	// salvo la matrice view del content
    // 	const activeDocument = activeApplication.activeDocument;
    // 	const activePage = activeDocument.activePage;
    // 	this.savedContentViewMatrix = activePage.content.getTransform().matrix.clone();
    // 	this.cloneAndAppendElementList( this.editableElementRef.children , this.graphicLayer   );
    //
    // 	if(this.editableElementRef.hasAttribute('viewBox'))
    // 	{
    // 		const viewBoxValues = this.editableElementRef.getAttribute('viewBox').split( ' ' ) ;
    // 		const x = parseFloat(viewBoxValues[0]);
    // 		const y =  parseFloat(viewBoxValues[1]);
    // 		const width =  parseFloat(viewBoxValues[2]);
    // 		const height =  parseFloat(viewBoxValues[3]);
    // 		this.elementViewBox = SVGUtils.createRect(x,y,width,height);
    //
    // 	} else {
    // 		//this.onEnterCalculateViewBox();
    //
    // 		const localBox = this.graphicLayer.getLocalBBox();
    // 		// const x = 0;
    // 		// const y = 0;
    // 		// const width = localBox.center.x*2;
    // 		// const height = localBox.center.y*2;
    // 		this.elementViewBox = SVGUtils.createRect(localBox.x,localBox.y,localBox.width,localBox.height);
    //
    // 	}
    //
    // 	// this.elementViewBox=SVGUtils.createRect(x,y,width,height);
    // 	this.elementViewBox.classList.add('view-box');
    // 	this.graphicLayer.appendChild(this.elementViewBox);
    //
    // 	const bbox = this.graphicLayer.getGlobalBBox();
    // 	const viewWidth  = activeDocument.workspaceBounding.width;
    // 	const viewHeight  = activeDocument.workspaceBounding.height;
    // 	activeDocument.fitRectToView( bbox , viewWidth/3 , viewHeight/3 );
    // };


    // onExitSetViewBox( _element , _x , _y, _width , _height )
    // {
    // 	_x = _x || 0;
    // 	_y = _y || 0;
    // 	_width = _width || this.editableElementRef.getAttribute('width') ;
    // 	_height = _height || this.editableElementRef.getAttribute('height') ;
    // 	_element.setAttribute('viewBox' , _x+' '+_y+' '+_width+' '+_height );
    // 	_element.setAttribute('width' , _width);
    // 	_element.setAttribute('height' , _height);
    // }


    // exitFromEditing()
    // {
    // 	this.editableElementRef.classList.remove('hidden');
    //
    // 	const activeDocument = activeApplication.activeDocument;
    //
    // 	if(this.graphicLayer.children.length===0) return;
    //
    // 	const newElement = this.editableElementRef.cloneNode();
    //
    // 	this.elementViewBox = this.graphicLayer.querySelector('.view-box'); // uso questo perchè quando si ridimensiona non è più quella originale ( per via dell'undo )
    //
    // 	if(this.elementViewBox.parentElement)
    // 	{
    // 		const bbox = this.elementViewBox.getBBox();
    // 		const bboxPivotPosition =  GeometryUtils.getBBoxPointByLocationName( 'left-top' , bbox ).matrixTransform( this.elementViewBox.getTransformToElement( this.elementViewBox.parentElement ) );
    // 		this.onExitSetViewBox( newElement , bboxPivotPosition.x,bboxPivotPosition.y,bbox.width,bbox.height );
    // 	}
    // 	else {
    //
    // 		this.onExitSetViewBox( newElement );
    // 	}
    //
    //
    // 	this.cloneAndAppendElementList( this.graphicLayer.children , newElement  );
    //
    // 	this.createUndoRedoEditingAction( newElement );
    //
    // 	activeDocument.removePageLayer( this.graphicLayer );
    //
    // 	this.onRemoved();
    //
    // 	//activeApplication.activeDocument.onLibraryChange();
    // };


    // eliminazione gestione viewbox


    enterToEditing() {
        this.onAdded();
        // salvo la matrice view del content
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.savedContentViewMatrix = activePage.content.getTransform().matrix.clone();
        this.cloneAndAppendElementList(this.editableElementRef.children, this.graphicLayer);

        const bbox = this.graphicLayer.getGlobalBBox();
        const viewWidth = activeDocument.workspaceBounding.width;
        const viewHeight = activeDocument.workspaceBounding.height;
        activeDocument.fitRectToView(bbox, viewWidth / 3, viewHeight / 3);
    };

    exitFromEditing() {
        this.editableElementRef.classList.remove('hidden');

        const activeDocument = activeApplication.activeDocument;

        if (this.graphicLayer.children.length === 0)
            return;

        const newElement = this.editableElementRef.cloneNode();

        this.cloneAndAppendElementList(this.graphicLayer.children, newElement);

        this.createUndoRedoEditingAction(newElement);

        activeDocument.removePageLayer(this.graphicLayer);

        this.onRemoved();

    };

    cloneAndAppendElementList(_elementList, _containerTarget) {
        let element;
        let id,
        max = _elementList.length;
        for (id = 0; id < max; id++) {
            element = _elementList[id];
            if (!element.classList.contains('view-box')) {
                element = element.cloneNode(true);
                _containerTarget.appendChild(element);
            }
        }
    };

}

class MarkerEditing_layer extends SymbolEditing_layer{
    constructor(_layer, _editableElement) {
        super(_layer, _editableElement);
        //this.classList.add('marker');
    }

    // eliminati
    // calculateViewBox(  )
    // {
    // 	const x = 0;
    // 	const y = 0;
    // 	const width = this.editableElementRef.getAttribute('markerWidth') || 20;
    // 	const height = this.editableElementRef.getAttribute('markerHeight') || 20;
    // 	this.elementViewBox=SVGUtils.createRect(x,y,width,height);
    // }
    //
    // onExitSetViewBox( _element , _x , _y, _width , _height )
    // {
    // 	_x = _x || 0;
    // 	_y = _y || 0;
    // 	_width = _width || this.editableElementRef.getAttribute('markerWidth') ;
    // 	_height = _height || this.editableElementRef.getAttribute('markerHeight') ;
    // 	_element.setAttribute('viewBox' , _x+' '+_y+' '+_width+' '+_height );
    // 	_element.setAttribute('markerWidth' , _width);
    // 	_element.setAttribute('markerHeight' , _height);
    // }
}

class PatternEditing_layer extends SymbolEditing_layer{
    constructor(_layer, _editableElement) {
        super(_layer, _editableElement);
        //this.classList.add('pattern');
    }

    onEnterCalculateViewBox() {
        const localBox = this.graphicLayer.getLocalBBox();
        const x = 0;
        const y = 0;
        const width = localBox.center.x * 2;
        const height = localBox.center.y * 2;
        return SVGUtils.createRect(x, y, width, height);
    }

    // calculateViewBox(  )
    // {
    // 	const patternUnits = this.editableElementRef.getAttribute('patternUnits');
    // 	let x,y ,width,height;
    // 	if(patternUnits==='objectBoundingBox')
    // 	{
    // 		const bbox = GeometryUtils.getElementListGlobalBBox(this.editableElementRef.children );
    // 		x = bbox.x;
    // 		y = bbox.y;
    // 		width = bbox.width;
    // 		height = bbox.height;
    // 	}
    // 	else {
    // 		x = this.editableElementRef.getAttribute('x') || 0;
    // 		y = this.editableElementRef.getAttribute('y') || 0;
    // 		width = this.editableElementRef.getAttribute('width') || 100;
    // 		height = this.editableElementRef.getAttribute('height') || 100;
    // 	}
    // 	return SVGUtils.createRect(x,y,width,height);
    // }


    onExitSetViewBox(_element, _x, _y, _width, _height) {
        if (_x === undefined) {
            const bbox = this.getBBox();
            _x = 0;
            _y = 0;
            _width = bbox.width;
            _height = bbox.height;
        }

        _element.setAttribute('viewBox', _x + ' ' + _y + ' ' + _width + ' ' + _height);
        _element.setAttribute('x', _x);
        _element.setAttribute('y', _y);
        _element.setAttribute('width', _width);
        _element.setAttribute('height', _height);
    }

    enterToEditing() {
        this.onAdded();
        // salvo la matrice view del content
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        this.savedContentViewMatrix = activePage.content.getTransform().matrix.clone();
        this.cloneAndAppendElementList(this.editableElementRef.children, this.graphicLayer);

        if (this.editableElementRef.hasAttribute('viewBox')) {
            const viewBoxValues = this.editableElementRef.getAttribute('viewBox').split(' ');
            const x = parseFloat(viewBoxValues[0]);
            const y = parseFloat(viewBoxValues[1]);
            const width = parseFloat(viewBoxValues[2]);
            const height = parseFloat(viewBoxValues[3]);
            this.elementViewBox = SVGUtils.createRect(x, y, width, height);

        } else {
            this.elementViewBox = this.onEnterCalculateViewBox();
        }

        // this.elementViewBox=SVGUtils.createRect(x,y,width,height);
        this.elementViewBox.classList.add('view-box');
        this.graphicLayer.appendChild(this.elementViewBox);

        const bbox = this.graphicLayer.getGlobalBBox();
        const viewWidth = activeDocument.workspaceBounding.width;
        const viewHeight = activeDocument.workspaceBounding.height;
        activeDocument.fitRectToView(bbox, viewWidth / 3, viewHeight / 3);
    };

    exitFromEditing() {
        this.editableElementRef.classList.remove('hidden');

        const activeDocument = activeApplication.activeDocument;

        if (this.graphicLayer.children.length === 0)
            return;

        const newElement = this.editableElementRef.cloneNode();

        this.elementViewBox = this.graphicLayer.querySelector('.view-box'); // uso questo perchè quando si ridimensiona non è più quella originale ( per via dell'undo )

        if (this.elementViewBox.parentElement) {
            const bbox = this.elementViewBox.getBBox();
            const bboxPivotPosition = GeometryUtils.getBBoxPointByLocationName('left-top', bbox).matrixTransform(this.elementViewBox.getTransformToElement(this.elementViewBox.parentElement));
            this.onExitSetViewBox(newElement, bboxPivotPosition.x, bboxPivotPosition.y, bbox.width, bbox.height);
        } else {

            this.onExitSetViewBox(newElement);
        }

        this.cloneAndAppendElementList(this.graphicLayer.children, newElement);

        this.createUndoRedoEditingAction(newElement);

        activeDocument.removePageLayer(this.graphicLayer);

        this.onRemoved();

        //activeApplication.activeDocument.onLibraryChange();
    };

}

class MaskEditing_layer extends GroupEditing_layer{
    constructor(_layer, _editableElement) {
        super(_layer, _editableElement);
        //this.classList.add('mask');
    }

    enterToEditing() {
        this.onAdded();
        this.maskRef = null;
        const maskedElementList = [];
        let max = this.editableElementRef.children.length;
        let element,
        i;

        for (i = 0; i < max; i++) {
            element = this.editableElementRef.children[i];
            if (element.nodeName === 'mask') {
                this.maskRef = element;
            } else {
                maskedElementList.push(element);
            }
        }

        this.cloneAndAppendElementListInPlace(maskedElementList, this.graphicLayer);
        if (this.maskRef)
            this.cloneAndAppendElementListInPlace(this.maskRef.children, this.graphicLayer);
    };

    exitFromEditing() {
        this.editableElementRef.classList.remove('hidden');

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (this.graphicLayer.children.length < 2) {
            activeDocument.removeElementList_undable([this.editableElementRef]);
            activeDocument.removePageLayer(this.graphicLayer);
            this.onRemoved();
            return;
        }

        const newGroup = activeDocument.createMaskedContent(this.graphicLayer.children, this.maskRef.getAttribute('id'));

        if (newGroup)
            this.createUndoRedoEditingAction(newGroup);

        activeDocument.removePageLayer(this.graphicLayer);
        this.onRemoved();
    };

}

class ClipEditing_layer extends GroupEditing_layer {
    constructor(_layer, _editableElement) {
        super(_layer, _editableElement);
        //this.classList.add('clip-path');
    }

    enterToEditing() {
        this.onAdded();
        this.clipPathRef = null;
        const clippedElementList = [];
        let max = this.editableElementRef.children.length;
        let element,
        i;

        for (i = 0; i < max; i++) {
            element = this.editableElementRef.children[i];
            if (element.nodeName === 'clipPath') {
                this.clipPathRef = element;
            } else {
                clippedElementList.push(element);
            }
        }

        this.cloneAndAppendElementListInPlace(clippedElementList, this.graphicLayer);
        if (this.clipPathRef)
            this.cloneAndAppendElementListInPlace(this.clipPathRef.children, this.graphicLayer);
    }

    exitFromEditing() {
        this.editableElementRef.classList.remove('hidden');

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (this.graphicLayer.children.length < 2) {
            activeDocument.removeElementList_undable([this.editableElementRef]);
            activeDocument.removePageLayer(this.graphicLayer);
            this.onRemoved();
            return;
        }

        const newGroup = activeDocument.createClippedContent(this.graphicLayer.children, this.clipPathRef.getAttribute('id'));

        if (newGroup)
            this.createUndoRedoEditingAction(newGroup);

        activeDocument.removePageLayer(this.graphicLayer);
        this.onRemoved();
    }
}

class BBoxInteraction_cmp {

    constructor() {

        this.graphicElement = document.querySelector('[data-custom-element="BBoxInteraction_cmp"]');

        this.selectionSizeX = 0;
        this.selectionSizeY = 0;

        //this.showElementOrigin = true;
        this.isLocalMode = false;

        this.boundsPoints = [];
        for (let id = 0; id < 4; id++)
            this.boundsPoints[id] = SVGUtils.createSVGPoint(0, 0);

        this.nw = this.graphicElement.querySelector('#nw');
        this.n = this.graphicElement.querySelector('#n');
        this.ne = this.graphicElement.querySelector('#ne');
        this.e = this.graphicElement.querySelector('#e');
        this.se = this.graphicElement.querySelector('#se');
        this.s = this.graphicElement.querySelector('#s');
        this.sw = this.graphicElement.querySelector('#sw');
        this.w = this.graphicElement.querySelector('#w');

        this.top_line = this.graphicElement.querySelector('#top_line');
        this.right_line = this.graphicElement.querySelector('#right_line');
        this.bottom_line = this.graphicElement.querySelector('#bottom_line');
        this.left_line = this.graphicElement.querySelector('#left_line');

        this.rotation = this.graphicElement.querySelector('#rotation');
        this.bboxCenterElement = this.graphicElement.querySelector('#center'); // centro delle trasformazioni

        this.labelSizeX = this.graphicElement.querySelector('#LABEL_SIZE_X');
        this.labelSizeY = this.graphicElement.querySelector('#LABEL_SIZE_Y');

        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    onClick_labelSizeX() {
        //const workspaceBounding = activeApplication.workspace.bounding;
        document.querySelector('rectangular-transform-inspector').setInputPropertyFocus('sizeX');
        //PANELS['transform-inspector'].activateAt( workspaceBounding.left + workspaceBounding.width/2, workspaceBounding.top + 30, 'center', null ,'sizeX');
    };

    onClick_labelSizeY() {
        //const workspaceBounding = activeApplication.workspace.bounding;
        document.querySelector('rectangular-transform-inspector').setInputPropertyFocus('sizeY');
        //PANELS['transform-inspector'].activateAt( workspaceBounding.left + workspaceBounding.width/2, workspaceBounding.top + 30, 'center', null ,'sizeY');
    };

    onMouseDown_handles(_e) {
        this.scaleAxis = 'XY';
        let bboxPivotPoint;

        const clickedHandle = _e.target;

        const handlePosition = clickedHandle.parentElement.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

        let clickedHandleName = clickedHandle.parentElement.getAttribute('id');

        switch (clickedHandleName) {
        case 'nw':
            bboxPivotPoint = this.boundsPoints[2];
            break;
        case 'n':
            bboxPivotPoint = this.getCenterBottom();
            this.scaleAxis = 'Y';
            break;
        case 'ne':
            bboxPivotPoint = this.boundsPoints[3];
            break;
        case 'e':
            bboxPivotPoint = this.getCenterLeft();
            this.scaleAxis = 'X';
            break;
        case 'se':
            bboxPivotPoint = this.boundsPoints[0];
            break;
        case 's':
            bboxPivotPoint = this.getCenterTop();
            this.scaleAxis = 'Y';
            break;
        case 'sw':
            bboxPivotPoint = this.boundsPoints[1];
            break;
        case 'w':
            bboxPivotPoint = this.getCenterRight();
            this.scaleAxis = 'X';
            break;
        }

        if (clickedHandle.classList.contains('resize')) {
            virtualEvent.centerOfScaling = bboxPivotPoint;
            virtualEvent.alternateCenterOfScaling = this.getCenter();
            virtualEvent.scaleAxis = this.scaleAxis;
            virtualEvent.isLocalMode = this.isLocalMode;
            virtualEvent.mantainAspectRatio = activeApplication.activeDocument.preferences.mantainAspectRatio;
            TOOLS['scale-tool'].initDrag(virtualEvent);
        } else if (clickedHandle.classList.contains('translate')) {
            if (_e.shiftKey) {
                virtualEvent.centerOfRotation = bboxPivotPoint;
                TOOLS['rotate-tool'].initDrag(virtualEvent);
            } else {
                TOOLS['translate-tool'].initDrag(virtualEvent);
            }

        } else if (clickedHandle.classList.contains('rotate')) {
            virtualEvent.centerOfRotation = this.getCenter();
            TOOLS['rotate-tool'].initDrag(virtualEvent);
        }

    };

    show() {
        const activePage = activeApplication.activeDocument.activePage;
        const selectionList = activePage.selectionList;

        this.selectionBBox = null;

        if ((selectionList.length === 1)) {
            this.isLocalMode = true;
            let element = selectionList[0];
            this.selectionBBox = element.getLocalBBox();
            this.initBoundPoints();
            element.getCTM().transformPointList(this.boundsPoints);

            this.selectionSizeX = this.selectionBBox.width;
            this.selectionSizeY = this.selectionBBox.height;
        } else {
            this.isLocalMode = false;
            this.selectionBBox = GeometryUtils.getElementListGlobalBBox(selectionList);
            this.initBoundPoints();

            let matrixInContentSpace = activePage.content.getCTM().inverse();
            let min = SVGUtils.createSVGPoint(this.selectionBBox.min.x, this.selectionBBox.min.y).matrixTransform(matrixInContentSpace);
            let max = SVGUtils.createSVGPoint(this.selectionBBox.max.x, this.selectionBBox.max.y).matrixTransform(matrixInContentSpace);

            this.selectionSizeX = max.x - min.x;
            this.selectionSizeY = max.y - min.y;
        }

        this.update();

        this.graphicElement.classList.add('showed');
    };

    initBoundPoints() {
        this.boundsPoints[0].set(this.selectionBBox.min.x, this.selectionBBox.min.y);
        this.boundsPoints[1].set(this.selectionBBox.max.x, this.selectionBBox.min.y);
        this.boundsPoints[2].set(this.selectionBBox.max.x, this.selectionBBox.max.y);
        this.boundsPoints[3].set(this.selectionBBox.min.x, this.selectionBBox.max.y);
    };

    update() {

        /*
        0	 	1
        3	 	2
        4 = elementPivot (Matrix e and f)
         */

        let x0,
        y0,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3;

        x0 = this.boundsPoints[0].x;
        y0 = this.boundsPoints[0].y;
        x1 = this.boundsPoints[1].x;
        y1 = this.boundsPoints[1].y;
        x2 = this.boundsPoints[2].x;
        y2 = this.boundsPoints[2].y;
        x3 = this.boundsPoints[3].x;
        y3 = this.boundsPoints[3].y;

        // contour lines
        this.top_line.updateGeometry(x0, y0, x1, y1);
        this.right_line.updateGeometry(x1, y1, x2, y2);
        this.bottom_line.updateGeometry(x2, y2, x3, y3);
        this.left_line.updateGeometry(x3, y3, x0, y0);

        // center
        let center = this.getCenter();
        this.bboxCenterElement.placeAt(center.x, center.y);

        // handles
        this.nw.placeAt(x0, y0);
        this.ne.placeAt(x1, y1);
        this.se.placeAt(x2, y2);
        this.sw.placeAt(x3, y3);

        // top left bottom right handles
        let centerTop = this.getCenterTop();
        this.n.placeAt(centerTop.x, centerTop.y);
        let centerRight = this.getCenterRight();
        this.e.placeAt(centerRight.x, centerRight.y);
        let centerBottom = this.getCenterBottom();
        this.s.placeAt(centerBottom.x, centerBottom.y);
        let centerLeft = this.getCenterLeft();
        this.w.placeAt(centerLeft.x, centerLeft.y);

        const toSmallToShowAll = centerTop.getDistanceFromPoint(centerBottom) < 30;

        if (toSmallToShowAll) {
            this.labelSizeX.style.display = this.labelSizeY.style.display = this.bboxCenterElement.style.display = this.nw.style.display = this.ne.style.display = this.se.style.display = this.sw.style.display = 'none';
        } else {
            this.labelSizeX.style.display = this.labelSizeY.style.display = this.bboxCenterElement.style.display = this.nw.style.display = this.ne.style.display = this.se.style.display = this.sw.style.display = 'inline';
            //if (this.isLocalMode) activeApplication.interactions.elementOrigin.show();
        }

        function getResizeAngle(_fromPoint) {
            return Math.round(GeometryUtils.getAngleBetweenPoints(_fromPoint, center) / (Math.PI / 180 * 45)) * 45;
        }

        function getAngle(_fromPoint) {
            return Math.round(GeometryUtils.getAngleBetweenPoints(_fromPoint, center) / (Math.PI / 180));
        }

        let cursorList = {
            '0': 'ew-resize',
            '45': 'nwse-resize',
            '90': 'ns-resize',
            '135': 'nesw-resize',
            '180': 'ew-resize',
            '225': 'nwse-resize',
            '270': 'ns-resize',
            '315': 'nesw-resize'
        };

        this.e.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(centerRight))];
        this.se.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(this.boundsPoints[2]))];
        this.s.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(centerBottom))];
        this.sw.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(this.boundsPoints[3]))];
        this.w.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(centerLeft))];
        this.nw.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(this.boundsPoints[0]))];
        this.n.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(centerTop))];
        this.ne.querySelector('.resize').style.cursor = cursorList[String(getResizeAngle(this.boundsPoints[1]))];

        this.rotation.setAttribute('transform', 'translate(' + centerBottom.x + ' ' + centerBottom.y + ') rotate(' + (getAngle(centerBottom) + 90 + 180) + ' 0 0)');

        const activeDocument = activeApplication.activeDocument;

        if (activeDocument.preferences.interactionLabelVisibility) {
            this.labelSizeX.setAttribute('y', '-27');
            this.labelSizeY.setAttribute('y', '27');

            let angle = (getAngle(centerRight));
            if (angle > 90 && angle < 270) {
                angle += 180;
                this.labelSizeX.setAttribute('y', '27');
            }

            this.labelSizeX.setAttribute('transform', 'translate(' + centerTop.x + ' ' + centerTop.y + ') rotate(' + angle + ' 0 0)');

            angle = getAngle(centerTop);

            if (angle > 90 && angle < 270) {
                angle += 180;
                this.labelSizeY.setAttribute('y', '-27');
            }

            this.labelSizeY.setAttribute('transform', 'translate(' + centerRight.x + ' ' + centerRight.y + ') rotate(' + angle + ' 0 0)');

            this.labelSizeX.textContent = activeApplication.activeDocument.valueToUnit(this.selectionSizeX);
            this.labelSizeY.textContent = activeApplication.activeDocument.valueToUnit(this.selectionSizeY);
        } else {
            this.labelSizeX.style.display = this.labelSizeY.style.display = 'none';
        }

    };

    getCenter() {
        return SVGUtils.createSVGPoint(this.boundsPoints[0].x + ((this.boundsPoints[2].x - this.boundsPoints[0].x) / 2), this.boundsPoints[0].y + ((this.boundsPoints[2].y - this.boundsPoints[0].y) / 2));
    };

    getCenterTop() {
        return SVGUtils.createSVGPoint(this.boundsPoints[0].x + ((this.boundsPoints[1].x - this.boundsPoints[0].x) / 2), this.boundsPoints[0].y + ((this.boundsPoints[1].y - this.boundsPoints[0].y) / 2));
    };

    getCenterLeft() {
        return SVGUtils.createSVGPoint(this.boundsPoints[0].x + ((this.boundsPoints[3].x - this.boundsPoints[0].x) / 2), this.boundsPoints[0].y + ((this.boundsPoints[3].y - this.boundsPoints[0].y) / 2));
    };

    getCenterRight() {
        return SVGUtils.createSVGPoint(this.boundsPoints[1].x + ((this.boundsPoints[2].x - this.boundsPoints[1].x) / 2), this.boundsPoints[1].y + ((this.boundsPoints[2].y - this.boundsPoints[1].y) / 2));
    };

    getCenterBottom() {
        return SVGUtils.createSVGPoint(this.boundsPoints[2].x + ((this.boundsPoints[3].x - this.boundsPoints[2].x) / 2), this.boundsPoints[2].y + ((this.boundsPoints[3].y - this.boundsPoints[2].y) / 2));
    };

}

class LineInteraction_cmp {

    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="LineInteraction_cmp"]');
        this.line = this.graphicElement.querySelector('line');
        this.pt1 = this.graphicElement.querySelector('.pt1');
        this.pt2 = this.graphicElement.querySelector('.pt2');
        this.label = this.graphicElement.querySelector('.label');
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    show() {
        const activePage = activeApplication.activeDocument.activePage;
        const selectionList = activePage.selectionList;
        let element = selectionList[0];
        const editableGeometryPointList = element.getEditableGeometryPointList();
        const length = editableGeometryPointList[1].getDistanceFromPoint(editableGeometryPointList[0]);
        let pointListInWorkspace;

        pointListInWorkspace = element.getCTM().transformPointList(editableGeometryPointList, true);

        this.line.setGeometryPointList(pointListInWorkspace);
        this.line.render();

        this.pt1.placeAt(pointListInWorkspace[0].x, pointListInWorkspace[0].y);
        this.pt2.placeAt(pointListInWorkspace[1].x, pointListInWorkspace[1].y);

        const activeDocument = activeApplication.activeDocument;
        if (activeDocument.preferences.interactionLabelVisibility) {
            this.showLabel(activeApplication.activeDocument.valueToUnit(length));
        } else {
            this.label.style.display = 'none';
        }

        this.graphicElement.classList.add('showed');
    };

    showLabel(_labelText) {
        const geometryPointList = this.line.getGeometryPointList();
        const pt1 = geometryPointList[0];
        const pt2 = geometryPointList[1];
        const posX = pt1.x + ((pt2.x - pt1.x) / 2);
        const posY = pt1.y + ((pt2.y - pt1.y) / 2);

        let angle = GeometryUtils.getAngleBetweenPoints(pt2, pt1) / (Math.PI / 180);
        if (angle >= 90 && angle < 270) {
            angle += 180;
            this.label.setAttribute('y', '27');
        } else {
            this.label.setAttribute('y', '-27');
        }

        this.label.setAttribute('transform', 'translate(' + posX + ' ' + posY + ') rotate(' + angle + ' 0 0)');
        this.label.textContent = _labelText;
        this.label.style.display = 'inline';
    };

    onClickOn_label() {
        document.querySelector('line-transform-inspector').setInputPropertyFocus('lineLength');
    };

    onMouseDown_handle(_e) {
        const clickedHandle = _e.target;
        const handlePosition = clickedHandle.parentElement.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

        if (clickedHandle.classList.contains('resize')) {

            const geometryPointList = this.line.getGeometryPointList();
            let pivotPoint;
            if (clickedHandle.parentElement.classList.contains('pt1')) {
                this.pointToDrag = geometryPointList[0];
                pivotPoint = geometryPointList[1];
            } else if (clickedHandle.parentElement.classList.contains('pt2')) {
                this.pointToDrag = geometryPointList[1];
                pivotPoint = geometryPointList[0];
            }

            this.startPenEvent = {
                workspaceX: pivotPoint.x,
                workspaceY: pivotPoint.y
            };
            activeApplication.activeDocument.workspaceToPageContentCoords(this.startPenEvent);

            this.initDrag(virtualEvent);
        } else if (clickedHandle.classList.contains('translate')) {
            TOOLS['translate-tool'].initDrag(virtualEvent);
        }
    };

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        this.pointToDrag.x += _e.workspaceX - this.previousWorkspaceX;
        this.pointToDrag.y += _e.workspaceY - this.previousWorkspaceY;

        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;

        this.line.render();
        const pointList = this.line.getGeometryPointList();
        const pointListInPreview = this.line.getTransformToElement(focusedElement.selectionPreview).transformPointList(pointList, true);
        focusedElement.selectionPreview.setGeometryPointList(pointListInPreview)
        focusedElement.selectionPreview.render();

    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        let undoRedoActions,
        keyValues;

        const localPoint = focusedElement.globalToLocal(this.pointToDrag.x, this.pointToDrag.y);
        if (this.pointToDrag.id === 0) {
            keyValues = {
                x1: localPoint.x,
                y1: localPoint.y
            }
        } else {
            keyValues = {
                x2: localPoint.x,
                y2: localPoint.y
            }
        }
        undoRedoActions = activeDocument.setAttributeElementList_undable([focusedElement], keyValues, false)
            undoRedoActions.undoAction.onExecuteEnd = undoRedoActions.redoAction.onExecuteEnd = function () {
            focusedElement.geometryPointList = null;
            activeDocument.selectElementList([focusedElement]);
        };
        focusedElement.geometryPointList = null;

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

}

class LinearObjectInteraction_cmp {

    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="LinearObjectInteraction_cmp"]');
        this.line = this.graphicElement.querySelector('line');
        this.pt1 = this.graphicElement.querySelector('.pt1');
        this.pt2 = this.graphicElement.querySelector('.pt2');
        this.pt3 = this.graphicElement.querySelector('.pt3'); // l'altezza, lo spessore, o altro
        this.label = this.graphicElement.querySelector('.label');
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    show() {
        const activePage = activeApplication.activeDocument.activePage;
        const selectionList = activePage.selectionList;
        let element = selectionList[0];
        const editableGeometryPointList = element.getEditableGeometryPointList();
        const length = editableGeometryPointList[1].getDistanceFromPoint(editableGeometryPointList[0]);

        const pointListInWorkspace = element.parentElement.getCTM().transformPointList(editableGeometryPointList, true);

        this.line.setGeometryPointList(pointListInWorkspace);
        this.line.render();

        this.pt1.placeAt(pointListInWorkspace[0].x, pointListInWorkspace[0].y);
        this.pt2.placeAt(pointListInWorkspace[1].x, pointListInWorkspace[1].y);

        if (OBJECTS[element.dataset.objectId].createBy3Points) {
            this.pt3.style.display = 'inline';
            this.pt3.placeAt(pointListInWorkspace[2].x, pointListInWorkspace[2].y);
        } else {
            this.pt3.style.display = 'none';
        }

        const activeDocument = activeApplication.activeDocument;
        if (activeDocument.preferences.interactionLabelVisibility) {
            this.showLabel(activeApplication.activeDocument.valueToUnit(length));
        } else {
            this.label.style.display = 'none';
        }

        this.graphicElement.classList.add('showed');
    };

    showLabel(_labelText) {
        const geometryPointList = this.line.getGeometryPointList();
        const pt1 = geometryPointList[0];
        const pt2 = geometryPointList[1];
        const posX = pt1.x + ((pt2.x - pt1.x) / 2);
        const posY = pt1.y + ((pt2.y - pt1.y) / 2);

        let angle = GeometryUtils.getAngleBetweenPoints(pt2, pt1) / (Math.PI / 180);
        if (angle >= 90 && angle < 270) {
            angle += 180;
            this.label.setAttribute('y', '27');
        } else {
            this.label.setAttribute('y', '-27');
        }

        this.label.setAttribute('transform', 'translate(' + posX + ' ' + posY + ') rotate(' + angle + ' 0 0)');
        this.label.textContent = _labelText;
    };

    onClickOn_label() {
        document.querySelector('linear-transform-inspector').setInputPropertyFocus('lineLength');
    };

    onMouseDown_handle(_e) {
        const clickedHandle = _e.target;
        const handlePosition = clickedHandle.parentElement.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

        if (clickedHandle.classList.contains('resize')) {

            const geometryPointList = this.line.getGeometryPointList();

            this.dragAction = 'dragPoint';

            if (clickedHandle.parentElement.classList.contains('pt1')) {
                this.pointToDrag = geometryPointList[0];
                this.pivotPoint = geometryPointList[1];
            } else if (clickedHandle.parentElement.classList.contains('pt2')) {
                this.pointToDrag = geometryPointList[1];
                this.pivotPoint = geometryPointList[0];
            } else if (clickedHandle.parentElement.classList.contains('pt3')) {
                this.pivotPoint = geometryPointList[0].add(geometryPointList[1].subtract(geometryPointList[0]).divide(2));
                this.dragAction = 'dragHeight';
            }

            this.startPenEvent = {
                workspaceX: this.pivotPoint.x,
                workspaceY: this.pivotPoint.y
            };
            activeApplication.activeDocument.workspaceToPageContentCoords(this.startPenEvent);

            this.initDrag(virtualEvent);
        } else if (clickedHandle.classList.contains('translate')) {
            TOOLS['translate-tool'].initDrag(virtualEvent);
        }
    };

    initDrag(_e) {
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));

        const activeDocument = activeApplication.activeDocument;
        const focusedElement = activeDocument.activePage.focusedElement;

        const objectController = focusedElement.getObjectController();
        this.storedObjectHeight = objectController.properties.height;

        if (this.dragAction === 'dragHeight') {
            focusedElement.selectionPreview.storedGlobalMatrix = focusedElement.selectionPreview.getCTM();
            this.pivotPoint = focusedElement.selectionPreview.globalToLocal(this.pivotPoint.x, this.pivotPoint.y);
        } else {
            // serve solo a far memorizzare la width di partenza per scalare successivamente la preview
            activeDocument.scaleAndRotateByLine(focusedElement.selectionPreview, this.line);
        }

    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;


        if (this.dragAction === 'dragHeight') {
            const localPos = focusedElement.globalToLocal(_e.workspaceX, _e.workspaceY);
            //this.scaleY = localPos.y/focusedElement.dataset.height;
            this.scaleY = localPos.y / this.storedObjectHeight;
            activeDocument.scaleElementList([focusedElement.selectionPreview], 1, this.scaleY, this.pivotPoint, true);
        } else {
            this.pointToDrag.x += _e.workspaceX - this.previousWorkspaceX;
            this.pointToDrag.y += _e.workspaceY - this.previousWorkspaceY;

            this.previousWorkspaceX = _e.workspaceX;
            this.previousWorkspaceY = _e.workspaceY;

            activeDocument.scaleAndRotateByLine(focusedElement.selectionPreview, this.line);
        }
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        if (this.dragAction === 'dragHeight') {
            activeApplication.activeDocument.setPropertyObjectElementList_undable([focusedElement], {
                'height': this.storedObjectHeight * this.scaleY
            });
        } else {
            const pointList = this.line.getGeometryPointList();
            const pointListInParent = this.line.getTransformToElement(focusedElement.parentElement).transformPointList(pointList, true);
            const newWidth = pointListInParent[1].getDistanceFromPoint(pointListInParent[0]);
            const currentTransform = focusedElement.getAttribute('transform');
            const undoRedoActions = activeApplication.activeDocument.setPropertyObjectElementList_undable([focusedElement], {
                'width': newWidth
            });
            const objectController = focusedElement.getObjectController();
            objectController.setLinearObjectPoints(pointListInParent[0], pointListInParent[1]);
            const newTransform = focusedElement.getAttribute('transform');
            undoRedoActions.undoAction.onExecuteEnd = function () {
                focusedElement.setAttribute('transform', currentTransform);
            }
            undoRedoActions.redoAction.onExecuteEnd = function () {
                focusedElement.setAttribute('transform', newTransform);
            }
        }

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

}

class RadialObjectInteraction_cmp {

    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="RadialObjectInteraction_cmp"]');

        this.arc = this.graphicElement.querySelector('.arc');
        this.center = this.graphicElement.querySelector('.center');
        this.angleStart = this.graphicElement.querySelector('.angle-start');
        this.angleEnd = this.graphicElement.querySelector('.angle-end');

        this.pt0 = this.graphicElement.querySelector('.pt0');
        this.pt1 = this.graphicElement.querySelector('.pt1');
        this.pt2 = this.graphicElement.querySelector('.pt2');
        this.pt3 = this.graphicElement.querySelector('.pt3'); // l'altezza, lo spessore, o altro
        this.label = this.graphicElement.querySelector('.label');
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    show() {
        const activePage = activeApplication.activeDocument.activePage;
        let element = activePage.focusedElement;
        const centerPosInWorkspace = element.localToGlobal(0, 0);

        this.objectProperties = element.getStoredJsonData("jvs-object-properties");
        this.graphicElement.placeAt(centerPosInWorkspace.x, centerPosInWorkspace.y);

        const rotation = element.getCTM().getRotation();
        const startPoint = SVGUtils.createSVGPointPolar(this.objectProperties.radius, this.objectProperties.startAngle * (Math.PI / 180));

        const startPointInWorkspace = element.localToGlobal(startPoint.x, startPoint.y);

        const radiusInWorkspace = startPointInWorkspace.getDistanceFromPoint(centerPosInWorkspace);
        const result = this.arc.buildArc({
            x: 0,
            y: 0
        }, radiusInWorkspace, this.objectProperties.startAngle + rotation, this.objectProperties.endAngle + rotation);

        this.angleStart.updateGeometry(0, 0, result.startPt.x, result.startPt.y);
        this.angleEnd.updateGeometry(0, 0, result.endPt.x, result.endPt.y);

        this.pt1.placeAt(result.startPt.x, result.startPt.y);
        this.pt2.placeAt(result.endPt.x, result.endPt.y);

        let angle = (this.objectProperties.endAngle - this.objectProperties.startAngle) / 2;

        if (angle < 0)
            angle += 180;
        const radiusHandlePosition = SVGUtils.createSVGPointPolar(radiusInWorkspace, (rotation + this.objectProperties.startAngle + angle) * (Math.PI / 180));

        this.pt3.placeAt(radiusHandlePosition.x, radiusHandlePosition.y);

        this.graphicElement.classList.add('showed');
    };

    onMouseDown_handle(_e) {
        const clickedHandle = _e.target;
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        let element = activePage.focusedElement;

        if (clickedHandle.classList.contains('resize')) {
            const centerPosInPage = element.localToScreen(0, 0);
            const virtualEvent = {
                pageX: centerPosInPage.x,
                pageY: centerPosInPage.y
            };
            activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

            if (clickedHandle.parentElement.classList.contains('pt1')) {
                this.dragAction = 'dragStartAngle';
            } else if (clickedHandle.parentElement.classList.contains('pt2')) {
                this.dragAction = 'dragEndAngle';
            } else if (clickedHandle.parentElement.classList.contains('pt3')) {
                this.dragAction = 'dragRadius';
            }

            this.initDrag(virtualEvent);
        } else if (clickedHandle.classList.contains('translate')) {
            const handlePosition = clickedHandle.parentElement.getScreenCTM().getTranslation();
            const virtualEvent = {
                pageX: handlePosition.x,
                pageY: handlePosition.y
            };
            activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

            TOOLS['translate-tool'].initDrag(virtualEvent);
        }
    };

    initDrag(_e) {
        this.startPenEvent = _e;
        this.previousWorkspaceX = _e.workspaceX;
        this.previousWorkspaceY = _e.workspaceY;
        XOS.initDragFunctions(this, _e);
    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
    }

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        if (this.dragAction === 'dragStartAngle') {
            this.newStartAngle = SVGUtils.createSVGPoint(0, 0).getAngleFromPoint(focusedElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY), true);
            this.newRadius = this.objectProperties.radius;
            if (_e.altKey) {
                this.newRadius = focusedElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY).getDistanceFromPoint(SVGUtils.createSVGPoint(0, 0));
            }
            let pathArc;
            if (focusedElement.selectionPreview.nodeName === 'path') {
                pathArc = focusedElement.selectionPreview;
            } else {
                pathArc = focusedElement.selectionPreview.querySelector('path');
            }
            pathArc.buildArc({
                x: 0,
                y: 0
            }, this.newRadius, this.newStartAngle, this.objectProperties.endAngle);
            //focusedElement.selectionPreview.buildArc( {x:0,y:0}, this.newRadius,this.newStartAngle,this.objectProperties.endAngle) ;

        } else if (this.dragAction === 'dragEndAngle') {
            this.newEndAngle = SVGUtils.createSVGPoint(0, 0).getAngleFromPoint(focusedElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY), true);
            this.newRadius = this.objectProperties.radius;
            if (_e.altKey) {
                this.newRadius = focusedElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY).getDistanceFromPoint(SVGUtils.createSVGPoint(0, 0));
            }
            let pathArc;
            if (focusedElement.selectionPreview.nodeName === 'path') {
                pathArc = focusedElement.selectionPreview;
            } else {
                pathArc = focusedElement.selectionPreview.querySelector('path');
            }
            pathArc.buildArc({
                x: 0,
                y: 0
            }, this.newRadius, this.objectProperties.startAngle, this.newEndAngle);
            //focusedElement.selectionPreview.buildArc( {x:0,y:0}, this.newRadius,this.objectProperties.startAngle,this.newEndAngle) ;
        } else if (this.dragAction === 'dragRadius') {
            this.newRadius = focusedElement.selectionPreview.globalToLocal(_e.workspaceX, _e.workspaceY).getDistanceFromPoint(SVGUtils.createSVGPoint(0, 0));
            let pathArc;
            if (focusedElement.selectionPreview.nodeName === 'path') {
                pathArc = focusedElement.selectionPreview;
            } else {
                pathArc = focusedElement.selectionPreview.querySelector('path');
            }
            pathArc.buildArc({
                x: 0,
                y: 0
            }, this.newRadius, this.objectProperties.startAngle, this.objectProperties.endAngle);
            //focusedElement.selectionPreview.buildArc( {x:0,y:0}, this.newRadius,this.objectProperties.startAngle,this.objectProperties.endAngle) ;
        }
    }

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const focusedElement = activePage.focusedElement;

        if (this.dragAction === 'dragStartAngle') {
            //console.log('this.newStartAngle',this.newStartAngle);
            activeApplication.activeDocument.setPropertyObjectElementList_undable([focusedElement], {
                'startAngle': this.newStartAngle,
                'radius': this.newRadius
            });
        } else if (this.dragAction === 'dragEndAngle') {
            //console.log('this.newEndAngle',this.newEndAngle);
            activeApplication.activeDocument.setPropertyObjectElementList_undable([focusedElement], {
                'endAngle': this.newEndAngle,
                'radius': this.newRadius
            });
        } else if (this.dragAction === 'dragRadius') {
            activeApplication.activeDocument.setPropertyObjectElementList_undable([focusedElement], {
                'radius': this.newRadius
            });
        }
        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

}

class PointsInteraction_cmp {

    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="PointsInteraction_cmp"]');

        this.interactionPointTemplate = document.querySelector('#INTERACTION_POINT_TEMPLATE');
        this.interactionControlPointTemplate = document.querySelector('#INTERACTION_CONTROL_POINT_TEMPLATE');
        this.interactionPointTemplate.removeAttribute('id');
        this.interactionControlPointTemplate.removeAttribute('id');

        XOS.connectEvent("mousedown", this.graphicElement, this.onMouseDown_pointHandle, this);
        XOS.connectEvent("mouseup", this.graphicElement, this.onMouseUp, this);

        //this.mode = 'round-corners';
        this.mode = 'translate-points';
    }

    onMouseDown_pointHandle(_e) {
        TOOLS.activeTool.onPointerDownOnInteractionPoint(_e);
    }

    onMouseUp(_e) {
        this.show(); // questo serve a ridisegnare i punti quando vengono selezionati cliccando su di essi
    };

    show() {
        this.removeAllInteractionPoints();

        const elementList = activeApplication.activeDocument.activePage.selectionList;
        const max = elementList.length;
        for (let i = 0; i < max; i++) {
            if (elementList[i].dataset.type === 'object')
                continue;

            if (elementList[i].nodeName === 'path') {
                if (this.mode === 'round-corners') {
                    this.showRoundableCornerPoints()
                } else {
                    this.createPathInteractionPoints(elementList[i]);
                }

            } else {
                this.createElementInteractionPoints(elementList[i]);
            }
        }
        this.graphicElement.classList.add('showed');

        //if(elementList.length===1)activeApplication.interactions.elementOrigin.show();

        //this.showElement();
    };

    showRoundableCornerPoints() {
        this.removeAllInteractionPoints();

        const elementList = activeApplication.activeDocument.activePage.selectionList;

        const max = elementList.length;
        for (let i = 0; i < max; i++) {
            if (elementList[i].nodeName === 'path') {
                this.createRoundablePathInteractionPoints(elementList[i]);
            }
        }

        this.graphicElement.classList.add('showed');
    };

    // creo la rappresentazione grafica dei punti di una path
    createRoundablePathInteractionPoints(_element) {
        //var interactionContainer = this.appendChild( SVGUtils.createGroup(0,0,'path-interaction') ); // ogni path in un suo contesto
        const interactionContainer = SVGUtils.createGroup(0, 0, 'path-interaction'); // ogni path in un suo contesto
        let interactionPointContainer,
        interactionPoint,
        interactionPointPosition;
        const matrix = _element.getCTM();

        let subPathList;
        subPathList = _element.getSubPathList();

        // if( _element.selectionInfo && _element.selectionInfo.subPathId!==undefined )
        // {
        // 	subPathList = [ subPathList[ _element.selectionInfo.subPathId ] ];
        // }

        const self = this;

        function createRoundCornerInteractionPoint(_geometryPoint) {
            interactionPoint = interactionPointContainer.appendChild(self.interactionPointTemplate.cloneNode(true));
            interactionPointPosition = _geometryPoint.matrixTransform(matrix);
            interactionPoint.placeAt(interactionPointPosition.x, interactionPointPosition.y);
            // creo dei riferimenti incrociati
            interactionPoint.pointRef = _geometryPoint;
            _geometryPoint.interactionPointRef = interactionPoint;
        }

        let idSubPath,
        maxSubPath = subPathList.length;
        for (idSubPath = 0; idSubPath < maxSubPath; idSubPath++) {
            let subPath = subPathList[idSubPath];
            let geometryPointList = subPath.geometryPointList;

            interactionPointContainer = interactionContainer.appendChild(SVGUtils.createGroup(0, 0, 'point-list')); // ogni sub path ha i punti in un suo contesto
            interactionContainer.appendChild(SVGUtils.createGroup(0, 0, 'control-point-list')); // ogni sub path ha i control points in un suo contesto

            // creo la rappresentazione grafica dei punti
            let i,
            max = geometryPointList.length - 1;
            for (i = 0; i < max; i++) {
                if (geometryPointList[i].type === 'L') {
                    if (geometryPointList[i + 1].type === 'L') {
                        createRoundCornerInteractionPoint(geometryPointList[i]);
                    } else if (geometryPointList[i + 1].type === 'Z') {
                        if (geometryPointList[1].type === 'L') {
                            createRoundCornerInteractionPoint(geometryPointList[i]);
                        }
                    }
                } else if (geometryPointList[i].type === 'C') {
                    // lo facciamo in futuro
                    /*
                    var cubicCurve = geometryPointList[i];
                    var distanceCtrlPt1 = cubicCurve.controlPt1.getDistanceFromPoint(geometryPointList[i-1]);
                    var distanceCtrlPt2 = cubicCurve.controlPt2.getDistanceFromPoint(cubicCurve);
                    console.log('distanceDifference', distanceCtrlPt2-distanceCtrlPt1 );
                    if( Math.abs(distanceCtrlPt1 - distanceCtrlPt2) < 0.0001 )
                {
                    createRoundCornerInteractionPoint(  geometryPointList[i]  );
                    }
                     */
                }
            }

        }

        this.graphicElement.appendChild(interactionContainer);
    };

    removeAllInteractionPoints() {
        const interactionPointList = this.graphicElement.querySelectorAll('.interaction-point');
        let i,
        max = interactionPointList.length;
        for (i = 0; i < max; i++) {
            // elimino i riferimenti agli elementi grafici dei punti
            delete interactionPointList[i].pointRef.interactionPointRef;
            delete interactionPointList[i].pointRef;
        }

        this.graphicElement.removeChildren();
    };

    // creo la rappresentazione grafica dei punti di un elemento generico : Esempio una linea
    createElementInteractionPoints(_element) {
        const interactionContainer = this.graphicElement.appendChild(SVGUtils.createGroup(0, 0, _element.nodeName + '-interaction')); // ogni path in un suo contesto

        let interactionPointContainer,
        interactionPoint,
        interactionPointPosition;
        let geometryPoint,
        matrix = _element.getCTM();

        const geometryPointList = _element.getGeometryPointList();

        interactionPointContainer = interactionContainer.appendChild(SVGUtils.createGroup(0, 0, 'point-list')); // ogni sub path ha i punti in un suo contesto

        let i,
        max = geometryPointList.length;
        for (i = 0; i < max; i++) {
            geometryPoint = geometryPointList[i];
            interactionPoint = interactionPointContainer.appendChild(this.interactionPointTemplate.cloneNode(true));
            interactionPointPosition = geometryPoint.matrixTransform(matrix);
            interactionPoint.placeAt(interactionPointPosition.x, interactionPointPosition.y);
            if (geometryPoint.isSelected)
                interactionPoint.classList.add('selected');
            if (geometryPoint.isFocused)
                interactionPoint.classList.add('focused');
            // creo dei riferimenti incrociati
            interactionPoint.pointRef = geometryPoint;
            geometryPoint.interactionPointRef = interactionPoint;
        }
    };

    // creo la rappresentazione grafica dei punti di una path
    createPathInteractionPoints(_element) {
        //const interactionContainer = SVGUtils.createGroup(0,0,'path-interaction') ; // ogni path in un suo contesto
        const interactionContainer = SVGUtils.createGroup(0, 0); // ogni path in un suo contesto
        interactionContainer.classList.add('path-interaction');
        let pointListContainer,
        controlPointListContainer,
        interactionPoint,
        interactionPointPosition;
        let geometryPoint,
        matrix = _element.getCTM();

        let subPathList;
        subPathList = _element.getSubPathList();

        // if( _element.selectionInfo && _element.selectionInfo.subPathId!==undefined )
        // {
        // 	subPathList = [ subPathList[ _element.selectionInfo.subPathId ] ];
        // }


        let idSubPath,
        maxSubPath = subPathList.length;
        for (idSubPath = 0; idSubPath < maxSubPath; idSubPath++) {
            let subPath = subPathList[idSubPath];
            let geometryPointList = subPath.geometryPointList;

            pointListContainer = SVGUtils.createGroup(0, 0); // ogni sub path ha i punti in un suo contesto
            pointListContainer.classList.add('point-list');
            interactionContainer.appendChild(pointListContainer); // ogni sub path ha i punti in un suo contesto

            controlPointListContainer = SVGUtils.createGroup(0, 0); // ogni sub path ha i control points in un suo contesto
            controlPointListContainer.classList.add('control-point-list');
            interactionContainer.appendChild(controlPointListContainer); // ogni sub path ha i control points in un suo contesto

            // creo la rappresentazione grafica dei punti
            let i,
            max = geometryPointList.length;
            for (i = 0; i < max; i++) {
                geometryPoint = geometryPointList[i];

                if (geometryPoint.type === 'Z') {
                    interactionPoint = pointListContainer.appendChild(SVGUtils.createGroup()); // il punto Z è un punto invisibile
                } else {
                    interactionPoint = pointListContainer.appendChild(this.interactionPointTemplate.cloneNode(true));
                    interactionPointPosition = geometryPoint.matrixTransform(matrix);
                    interactionPoint.placeAt(interactionPointPosition.x, interactionPointPosition.y);
                    if (geometryPoint.isSelected)
                        interactionPoint.classList.add('selected');
                    if (geometryPoint.isFocused)
                        interactionPoint.classList.add('focused');
                }

                // creo dei riferimenti incrociati
                interactionPoint.pointRef = geometryPoint;
                geometryPoint.interactionPointRef = interactionPoint;
            }

            // pointListContainer.firstElementChild.classList.add('start');
            // pointListContainer.lastElementChild.classList.add('end');


            // definisce quali punti di controllo dovranno essere visibili ( il segmento curva precedente e successivo ad un punto selezionato)

            let nextGeometryPoint;
            let pointListToShowControlPoints = [];

            for (i = 0; i < max; i++) {
                geometryPoint = geometryPointList[i];

                if (geometryPoint.editable) {
                    if (geometryPoint.type === 'Q' || geometryPoint.type === 'C')
                        pointListToShowControlPoints.push(geometryPoint);

                    if (i < (max - 1)) {
                        nextGeometryPoint = geometryPointList[i + 1];
                        if (nextGeometryPoint.type === 'Z')
                            nextGeometryPoint = geometryPointList[1]; // dopo il punto moveTo
                        if (nextGeometryPoint.type === 'Q' || nextGeometryPoint.type === 'C')
                            pointListToShowControlPoints.push(nextGeometryPoint);
                    }

                }
            }

            i = 0;
            max = pointListToShowControlPoints.length;
            for (i = 0; i < max; i++) {
                this.createPathInteractionControlPoints(pointListToShowControlPoints[i]);
            }
        }

        this.graphicElement.appendChild(interactionContainer);
    };

    createPathInteractionControlPoints(geometryPoint) {
        let matrix,
        interactionPointPosition,
        interactionControlPoint,
        interactionControlPointPosition,
        line;

        matrix = geometryPoint.ownerShapeElement.getCTM();
        let interactionCtrlPointContainer = geometryPoint.interactionPointRef.parentElement.nextElementSibling;

        if (geometryPoint.type === 'Q') {
            interactionPointPosition = geometryPoint.interactionPointRef.getTransform().matrix.getTranslation();

            // controlPoint 1
            interactionControlPoint = interactionCtrlPointContainer.appendChild(this.interactionControlPointTemplate.cloneNode(true));
            interactionControlPoint.pointRef = geometryPoint.controlPt1;
            interactionControlPointPosition = geometryPoint.controlPt1.matrixTransform(matrix);
            interactionControlPoint.placeAt(interactionControlPointPosition.x, interactionControlPointPosition.y);
            line = SVGUtils.createLine(interactionPointPosition.x, interactionPointPosition.y, interactionControlPointPosition.x, interactionControlPointPosition.y);
            interactionCtrlPointContainer.parentNode.insertBefore(line, interactionCtrlPointContainer.parentNode.firstChild); // le linee vengono inserite nel background
        } else if (geometryPoint.type === 'C') {
            interactionPointPosition = geometryPoint.interactionPointRef.previousElementSibling.getTransform().matrix.getTranslation();

            // controlPoint 1
            interactionControlPoint = interactionCtrlPointContainer.appendChild(this.interactionControlPointTemplate.cloneNode(true));
            interactionControlPoint.pointRef = geometryPoint.controlPt1;
            interactionControlPointPosition = geometryPoint.controlPt1.matrixTransform(matrix);
            interactionControlPoint.placeAt(interactionControlPointPosition.x, interactionControlPointPosition.y);
            line = SVGUtils.createLine(interactionPointPosition.x, interactionPointPosition.y, interactionControlPointPosition.x, interactionControlPointPosition.y);
            interactionCtrlPointContainer.parentNode.insertBefore(line, interactionCtrlPointContainer.parentNode.firstChild); // le linee vengono inserite nel background

            // controlPoint 2
            interactionPointPosition = geometryPoint.interactionPointRef.getTransform().matrix.getTranslation();
            interactionControlPoint = interactionCtrlPointContainer.appendChild(this.interactionControlPointTemplate.cloneNode(true));
            interactionControlPoint.pointRef = geometryPoint.controlPt2;
            interactionControlPointPosition = geometryPoint.controlPt2.matrixTransform(matrix);
            interactionControlPoint.placeAt(interactionControlPointPosition.x, interactionControlPointPosition.y);
            line = SVGUtils.createLine(interactionPointPosition.x, interactionPointPosition.y, interactionControlPointPosition.x, interactionControlPointPosition.y);
            interactionCtrlPointContainer.parentNode.insertBefore(line, interactionCtrlPointContainer.parentNode.firstChild); // le linee vengono inserite nel background

        }

    };

    createDraggablePathControlPoint(_geometryControlPoint) {
        // var ownerPath = _geometryControlPoint.ownerPoint.ownerShapeElement;
        const draggableControlPointList = [_geometryControlPoint];

        if (_geometryControlPoint.type === 'CTRL2') {
            let nextInteractionPoint = _geometryControlPoint.ownerPoint.interactionPointRef.nextElementSibling;

            // se c'è un punto successivo
            if (nextInteractionPoint) {
                var nextGeometryPoint = nextInteractionPoint.pointRef;
                if (nextGeometryPoint.type === 'Z') {
                    nextInteractionPoint = nextInteractionPoint.parentElement.firstChild.nextElementSibling; // dopo moveTo
                    nextGeometryPoint = nextInteractionPoint.pointRef;
                }

                if ((nextGeometryPoint.type === 'Q' || nextGeometryPoint.type === 'C')) {
                    draggableControlPointList.push(nextGeometryPoint.controlPt1);
                }

            }
        } else if (_geometryControlPoint.type === 'CTRL1') {
            let previousInteractionPoint = _geometryControlPoint.ownerPoint.interactionPointRef.previousElementSibling;

            // c'è sempre un punto precedente da moveTo in poi
            if (previousInteractionPoint) {
                var previousGeometryPoint = previousInteractionPoint.pointRef;
                if (previousGeometryPoint.type === 'M') {
                    previousInteractionPoint = previousInteractionPoint.parentElement.lastChild; // forse Z
                    previousGeometryPoint = previousInteractionPoint.pointRef;
                    if (previousGeometryPoint.type === 'Z') {
                        previousInteractionPoint = previousInteractionPoint.previousElementSibling; // prima di Z
                        previousGeometryPoint = previousInteractionPoint.pointRef;
                    } else {
                        return draggableControlPointList;
                    }
                }

                if (previousGeometryPoint.type === 'C') {
                    draggableControlPointList.push(previousGeometryPoint.controlPt2);
                }

            }
        }
        return draggableControlPointList;

    };

}

class SnapInteraction_cmp {

    constructor() {
        // this.guideX_graphicLine = document.querySelector('#GUIDE_X');
        // this.guideY_graphicLine = document.querySelector('#GUIDE_Y');
        this.guideA_graphicLine = document.querySelector('#GUIDE_A');
        this.guideB_graphicLine = document.querySelector('#GUIDE_B');
        this.parallelGuide_graphicLine = document.querySelector('#GUIDE_PARALLEL');
        this.perpendiculaGuide_graphicLine = document.querySelector('#GUIDE_PERPEDICULAR');

        this.smartPointA_graphicPoint = document.querySelector('#SMART_POINT_A');
        this.smartPointB_graphicPoint = document.querySelector('#SMART_POINT_B');

        this.smartGuideA_graphicLine = document.querySelector('#SMART_GUIDE_A');
        this.smartGuideB_graphicLine = document.querySelector('#SMART_GUIDE_B');

        // this.smartGuideTemplate = document.querySelector('#INTERACTION defs #SMART_GUIDE');
        // this.smartGuideTemplate.removeAttribute('id');

        this.angularGuide_color = '#0047FF';
        this.smartGuideA_color = '#ff00aa';
        this.smartGuideB_color = '#ff7700';

        this.reset();
    }

    showSmartPointA(_pointData) {
        const pt = _pointData.element.localToGlobal(_pointData.point.x, _pointData.point.y);
        this.smartPointA_graphicPoint.updateGeometry(pt.x, pt.y);
        XOS.showElement(this.smartPointA_graphicPoint, 'add');
    }

    showSmartPointB(_pointData) {
        const pt = _pointData.element.localToGlobal(_pointData.point.x, _pointData.point.y);
        this.smartPointB_graphicPoint.updateGeometry(pt.x, pt.y);
        XOS.showElement(this.smartPointB_graphicPoint, 'add');
    }

    showSmartGuideA(_segmentData) {
        //console.log('showSmartGuideA');
        this.showGuide(this.smartGuideA_graphicLine, _segmentData)
    }

    showSmartGuideB(_segmentData) {
        this.showGuide(this.smartGuideB_graphicLine, _segmentData)
    }

    showPerpendicularGuide(_segmentData) {
        this.showGuide(this.perpendiculaGuide_graphicLine, _segmentData)
    }

    showVirtualGuideA(_segmentData) {
        this.showGuide(this.guideA_graphicLine, _segmentData)
    }

    showVirtualGuideB(_segmentData) {
        this.showGuide(this.guideB_graphicLine, _segmentData)
    }

    // lineRectClipping( _rect, p1 , p2 )
    // {
    //     if( GeometryUtils.isPointRect( p1, _rect) && GeometryUtils.isPointRect( p2, _rect) ) return;
    //
    //     const dx = (p2.X - p1.X);
    //     const dy = (p2.Y - p1.Y);
    //
    //     const slopeY = dx / dy; // slope to use for possibly-vertical lines
    //     const slopeX = dy / dx; // slope to use for possibly-horizontal lines
    //
    //     if (clipTo.HasFlag(OutCode.Top)) {
    //         return new PointF(
    //             p1.X + slopeY * (r.Top - p1.Y),
    //             r.Top
    //         );
    //     }
    //
    //     if (clipTo.HasFlag(OutCode.Bottom)) {
    //         return new PointF(
    //             p1.X + slopeY * (r.Bottom - p1.Y),
    //             r.Bottom
    //         );
    //     }
    //
    //     if (clipTo.HasFlag(OutCode.Right)) {
    //         return new PointF(
    //             r.Right,
    //             p1.Y + slopeX * (r.Right - p1.X)
    //         );
    //     }
    //
    //     if (clipTo.HasFlag(OutCode.Left)) {
    //         return new PointF(
    //             r.Left,
    //             p1.Y + slopeX * (r.Left - p1.X)
    //         );
    //     }
    //
    // }

    hideAll() {
        // this.hideAllGuides( );
        this.hideSmartPoints();
        this.hideSmartGuides();
        this.hideVirtualGuides();
        this.hidePerpendicularGuide();
        this.hideParallelGuide();
    }

    hidePerpendicularGuide() {
        XOS.hideElement(this.perpendiculaGuide_graphicLine);
    }

    hideParallelGuide() {
        XOS.hideElement(this.parallelGuide_graphicLine);
    }

    hideSmartPoints() {
        XOS.hideElement(this.smartPointA_graphicPoint);
        XOS.hideElement(this.smartPointB_graphicPoint);
    }

    hideSmartGuides() {
        XOS.hideElement(this.smartGuideA_graphicLine);
        XOS.hideElement(this.smartGuideB_graphicLine);
    }

    hideVirtualGuides() {
        XOS.hideElement(this.guideA_graphicLine);
        XOS.hideElement(this.guideB_graphicLine);
    }

    showGuide(_guideGuide, _segment) {
        const pt1 = _segment.element.localToGlobal(_segment.pt1.x, _segment.pt1.y);
        const pt2 = _segment.element.localToGlobal(_segment.pt2.x, _segment.pt2.y);

        const screenWidth = activeApplication.workspace.bounding.width;
        const screenHeight = activeApplication.workspace.bounding.height;

        let intersectionPoint2,
        intersectionPoint1;

        if (Math.abs(pt1.x - pt2.x) < 1) {
            intersectionPoint1 = {
                x: pt1.x,
                y: 0
            };
            intersectionPoint2 = {
                x: pt1.x,
                y: screenHeight
            };

        } else if (Math.abs(pt1.y - pt2.y) < 1) {
            intersectionPoint1 = {
                x: 0,
                y: pt1.y
            };
            intersectionPoint2 = {
                x: screenWidth,
                y: pt1.y
            };
        } else {
            intersectionPoint1 = GeometryUtils.getLineLineIntersection(pt1, pt2, {
                x: 0,
                y: 0
            }, {
                x: screenWidth,
                y: 0
            });
            intersectionPoint2 = GeometryUtils.getLineLineIntersection(pt1, pt2, {
                x: 0,
                y: screenHeight
            }, {
                x: screenWidth,
                y: screenHeight
            });
        }

        if (intersectionPoint1) {
            _guideGuide.setAttribute('x1', intersectionPoint1.x);
            _guideGuide.setAttribute('y1', intersectionPoint1.y);
        }

        if (intersectionPoint2) {
            _guideGuide.setAttribute('x2', intersectionPoint2.x);
            _guideGuide.setAttribute('y2', intersectionPoint2.y);
        }

        _guideGuide.setAttribute('stroke', _segment.color || this.angularGuide_color);

        XOS.showElement(_guideGuide, 'add');
    }

    // inizio snap

    reset() {
        this.virtualOrigin = null;
        this.smartPointA = null;
        this.smartPointB = null;
        this.smartGuideA = null;
        this.smartGuideB = null;
        clearTimeout(this.holdTimeout);
        this.hideAll();
    }

    resetSmartPoints() {
        this.smartPointA = null;
        this.smartPointB = null;
        this.hideSmartPoints();
    }

    resetSmartGuides() {
        this.smartGuideA = null;
        this.smartGuideB = null;
        this.hideSmartGuides();
        if (this.virtualOrigin)
            this.createVirtualOrigin(this.virtualOrigin) // ripristino gli angoli base
    }

    snapToWorkspaceCoords(_e, _snapData) {
        _e.localX = _snapData.point.x;
        _e.localY = _snapData.point.y;
        const pointInWorkspace = _snapData.element.localToGlobal(_e.localX, _e.localY);
        _e.workspaceX = pointInWorkspace.x;
        _e.workspaceY = pointInWorkspace.y;
    }

    createVirtualOrigin(_centerPoint, _angleList, _angleListName) {
        _angleList = _angleList || activeApplication.activeDocument.preferences.snap.snapAngleList;
        this.virtualOrigin = _centerPoint;
        this.virtualOrigin.snapGuideList = this.createAngularGuideList(_centerPoint, _angleList, _angleListName, null, true);
    }

    isSmartPointDefined(_e) {
        if (this.smartPointA) {
            const workspaceToLocalPoint = this.smartPointA.element.globalToLocal(_e.workspaceX, _e.workspaceY);
            if (GeometryUtils.isPointSnappedTo(workspaceToLocalPoint, this.smartPointA.point, _e.snapDistance))
                return true;
        }

        if (this.smartPointB) {
            const workspaceToLocalPoint = this.smartPointB.element.globalToLocal(_e.workspaceX, _e.workspaceY);
            if (GeometryUtils.isPointSnappedTo(workspaceToLocalPoint, this.smartPointB.point, _e.snapDistance))
                return true;
        }

        return false;
    }

    isSmartGuideDefined(_e) {
        if (this.smartGuideA) {
            if (this.smartGuideA.element === _e.segmentListAtPoint[0].element) {
                if (this.smartGuideA.idSegment === _e.segmentListAtPoint[0].idSegment)
                    return true;
            }
        }

        if (this.smartGuideB) {
            if (this.smartGuideB.element === _e.segmentListAtPoint[0].element) {
                if (this.smartGuideB.idSegment === _e.segmentListAtPoint[0].idSegment)
                    return true;
            }
        }

        return false;
    };

    createAngularGuideList(_centerPoint, _angleList, _angleNameList = null, _color, _createHorizontalAndVerticalAxis = false, _angleStartOffset = 0) {
        if (!_centerPoint)
            return; // fix, da capire quando va in errore

        const virtualSegments = [];

        _color = _color || this.angularGuide_color;

        _centerPoint = SVGUtils.createSVGPoint(_centerPoint.x, _centerPoint.y);

        const _localElementSpaceCoords = activeApplication.activeDocument.activePage.content;

        if (_createHorizontalAndVerticalAxis) {
            virtualSegments.push({
                element: _localElementSpaceCoords,
                pt1: _centerPoint,
                pt2: SVGUtils.createSVGPoint(_centerPoint.x + 3000, _centerPoint.y),
                name: 'horizontal',
                type: 'linear'
            }); // horizontal guide from pointer
            virtualSegments.push({
                element: _localElementSpaceCoords,
                pt1: _centerPoint,
                pt2: SVGUtils.createSVGPoint(_centerPoint.x, _centerPoint.y + 3000),
                name: 'vertical',
                type: 'linear'
            }); // vertical guide from pointer
        }

        const max = _angleList.length;
        let angle,
        point,
        angleAsRadiant,
        angleSum;
        for (let i = 0; i < max; i++) {
            angle = _angleList[i];
            angleSum = _angleStartOffset + angle;
            if (_angleNameList) {
                angleAsRadiant = angleSum * (Math.PI / 180);
                //point = _centerPoint.add( SVGUtils.createSVGPointPolar(100, -angleAsRadiant  ));
                point = _centerPoint.add(SVGUtils.createSVGPointPolar(3000, angleAsRadiant));
                virtualSegments.push({
                    element: _localElementSpaceCoords,
                    pt1: _centerPoint,
                    pt2: point,
                    name: _angleNameList[i],
                    color: _color,
                    type: 'linear'
                }); // named angular guide
            } else {
                while (angleSum < (180 + _angleStartOffset)) {
                    angleAsRadiant = angleSum * (Math.PI / 180);
                    //point = _centerPoint.add( SVGUtils.createSVGPointPolar(100, -angleAsRadiant  ));
                    point = _centerPoint.add(SVGUtils.createSVGPointPolar(3000, angleAsRadiant));
                    virtualSegments.push({
                        element: _localElementSpaceCoords,
                        pt1: _centerPoint,
                        pt2: point,
                        name: 'angle: ' + angleSum + '°',
                        color: _color,
                        type: 'linear'
                    }); // angular guide
                    angleSum += angle;
                }
            }
        }

        return virtualSegments;
    }

    createSmartPoint(_vertexPointData, _timeStamp) {
        let point = SVGUtils.createSVGPoint(_vertexPointData.point.x, _vertexPointData.point.y);
        const content = activeApplication.activeDocument.activePage.content;
        const matrix = _vertexPointData.element.getTransformToElement(content);
        point = point.matrixTransform(matrix);
        let angleList = [];
        //console.log('_vertexPointData',_vertexPointData);

        _vertexPointData = {
            element: content,
            point: point
        };

        if (!this.smartPointA) {
            this.smartPointA = _vertexPointData;
            this.smartPointA.snapGuideList = this.createAngularGuideList(_vertexPointData.point, angleList, null, null, true);
            this.smartPointA.timeStamp = _timeStamp;
        } else {
            if (this.smartPointB)
                this.smartPointA = this.smartPointB;
            this.smartPointB = _vertexPointData;
            this.smartPointB.snapGuideList = this.createAngularGuideList(_vertexPointData.point, angleList, null, null, true);
            this.smartPointB.timeStamp = _timeStamp;
        }

        this.hideSmartPoints();
        if (this.smartPointA)
            this.showSmartPointA(this.smartPointA);
        if (this.smartPointB)
            this.showSmartPointB(this.smartPointB);
    }

    createSmartGuide(_segmentData, _timeStamp) {
        const content = activeApplication.activeDocument.activePage.content;
        const matrix = _segmentData.element.getTransformToElement(content);

        const pt1 = _segmentData.pt1.matrixTransform(matrix);
        const pt2 = _segmentData.pt2.matrixTransform(matrix);
        let angleParallel = pt1.getAngleFromPoint(pt2, true);
        let anglePerpendicular = angleParallel + 90;
        const offset = SVGUtils.createSVGPointPolar(activeApplication.activeDocument.preferences.snap.offsetDistance, (anglePerpendicular * Math.PI / 180));

        const self = this;
        function createGuide(_guideName, _color) {
            const coincidentGuide = self.createAngularGuideList(pt1, [angleParallel], ['coincident'], _color);
            const perpendicularStartGuide = self.createAngularGuideList(pt1, [anglePerpendicular], ['start'], _color);
            const perpendicularEndGuide = self.createAngularGuideList(pt2, [anglePerpendicular], ['end'], _color);
            const offsetGuide1 = self.createAngularGuideList(pt1.add(offset), [angleParallel], ['offset'], _color);
            const offsetGuide2 = self.createAngularGuideList(pt1.subtract(offset), [angleParallel], ['offset'], _color);

            const _guide = _segmentData;
            _guide.color = _color;
            _guide.timeStamp = _timeStamp;
            _guide.snapGuideList = coincidentGuide.concat(perpendicularStartGuide, perpendicularEndGuide, offsetGuide1, offsetGuide2);
            _guide.angleParallel = angleParallel;
            _guide.anglePerpendicular = anglePerpendicular;

            return _guide;
        }

        if (!this.smartGuideA) {

            this.smartGuideA = createGuide('A', this.smartGuideA_color);

            if (this.virtualOrigin) {
                //this.virtualOrigin.snapGuideList = this.createAngularGuideList(  this.virtualOrigin , [this.smartGuideA.angleParallel,this.smartGuideA.anglePerpendicular] ,['parallel','perpendicular'], this.smartGuideA_color );
                // creo solamente le guide 'parallel','perpendicular','horizontal','vertical', escludento gli angoli definiti dalle preferenze
                this.virtualOrigin.snapGuideList = this.createAngularGuideList(this.virtualOrigin, [this.smartGuideA.angleParallel, this.smartGuideA.anglePerpendicular, 0, 90], ['parallel', 'perpendicular', 'horizontal', 'vertical'], this.smartGuideA_color);
            }

        } else {

            if (this.smartGuideB)
                this.smartGuideA = this.smartGuideB;

            if (this.smartGuideA.color === this.smartGuideB_color) {
                const temp = this.smartGuideA_color;
                this.smartGuideA_color = this.smartGuideB_color;
                this.smartGuideB_color = temp;
            }

            this.smartGuideB = createGuide('B', this.smartGuideB_color);
            if (this.virtualOrigin) {
                // creo solamente le guide 'parallel','perpendicular','horizontal','vertical', escludento gli angoli definiti dalle preferenze
                let snapGuideList = this.createAngularGuideList(this.virtualOrigin, [this.smartGuideA.angleParallel, this.smartGuideA.anglePerpendicular, 0, 90], ['parallel', 'perpendicular', 'horizontal', 'vertical'], this.smartGuideA_color);
                this.virtualOrigin.snapGuideList = snapGuideList.concat(this.createAngularGuideList(this.virtualOrigin, [this.smartGuideB.angleParallel, this.smartGuideB.anglePerpendicular], ['parallel', 'perpendicular'], this.smartGuideB_color));
            }
        }

        this.hideSmartGuides();
        if (this.smartGuideA)
            this.showSmartGuideA(this.smartGuideA);
        if (this.smartGuideB)
            this.showSmartGuideB(this.smartGuideB);
    }

    snapToVirtualSegmentList(_e, _customLinearSegmentList, _limitToOne = true) {
        const max = _customLinearSegmentList.length;
        const result = [];
        let segment;
        for (let i = 0; i < max; i++) {
            segment = _customLinearSegmentList[i];
            const localPoint = segment.element.globalToLocal(_e.workspaceX, _e.workspaceY);
            const pointOnLine = GeometryUtils.isPointOnLine(segment.pt1, segment.pt2, localPoint, _e.snapDistance);
            if (pointOnLine) {
                //result.push({element: segment.element, point:pointOnLine, pt1: segment.pt1, pt2:segment.pt2, name:segment.name, color:segment.color });
                // creo il segmento virtuale definendo type=linear ed pointOnSegment=pointOnLine
                result.push({
                    element: segment.element,
                    point: pointOnLine,
                    pointOnSegment: pointOnLine,
                    pt1: segment.pt1,
                    pt2: segment.pt2,
                    name: segment.name,
                    color: segment.color,
                    type: 'linear'
                });
                if (_limitToOne)
                    break;
            }
        }

        if (result.length > 0) {
            this.snapToWorkspaceAndContentCoords(_e, result[0], result[0].name || 'guide');

            this.showVirtualGuideA(result[0]);
            return result;
        } else {
            return null;
        }
    }

    isIntersection(_e, _segment1, _segment2, _checkPointerNearIntersection = true) {
        // porto le coordinate del secondo segmento all'interno del primo segmento
        const segment2PointListInLocalSegment1 = _segment2.element.getTransformToElement(_segment1.element).transformPointList([_segment2.pt1, _segment2.pt2]);

        const intersectionPoint = GeometryUtils.getLineLineIntersection(_segment1.pt1, _segment1.pt2, segment2PointListInLocalSegment1[0], segment2PointListInLocalSegment1[1]);

        if (intersectionPoint) {

            if (_checkPointerNearIntersection) {
                const localPoint = _segment1.element.globalToLocal(_e.workspaceX, _e.workspaceY);
                if (!GeometryUtils.isPointSnappedTo(intersectionPoint, localPoint, _e.snapDistance))
                    return false; // corregge l'errore che si verifica quando il puntatore è su piu segmenti vicini ed hanno la stessa origine
            }

            this.snapToWorkspaceAndContentCoords(_e, {
                element: _segment1.element,
                point: intersectionPoint
            }, 'intersection: ' + _segment1.name + ' - ' + _segment2.name);
            _e.intersectionAtPoint = intersectionPoint;
            this.showVirtualGuideA(_segment1);
            this.showVirtualGuideB(_segment2);
            return true;
        }

        return false;
    }

    isSegmentSegmentIntersection(_e, segment1, segment2) {

        if (segment1.type === 'linear' && segment2.type === 'linear') {
            // porto le coordinate del secondo segmento all'interno del primo segmento
            const segment2PointListInLocalSegment1 = segment2.element.getTransformToElement(segment1.element).transformPointList([segment2.pt1, segment2.pt2]);
            const intersectionPoint = GeometryUtils.getLineLineIntersection(segment1.pt1, segment1.pt2, segment2PointListInLocalSegment1[0], segment2PointListInLocalSegment1[1]);
            if (intersectionPoint) {
                if (GeometryUtils.isPointSnappedTo(segment1.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    _e.intersectionAtPoint = intersectionPoint;
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: segment1.element,
                        point: intersectionPoint
                    }, 'intersection: linear / linear');
                    return true;
                }
            }
        } else if ((segment1.type === 'radial' && segment2.type === 'linear') || (segment2.type === 'radial' && segment1.type === 'linear')) {
            let radialSegment,
            linearSegment;
            if (segment1.type === 'radial') {
                radialSegment = segment1;
                linearSegment = segment2;
            } else {
                radialSegment = segment2;
                linearSegment = segment1;
            }

            // const radialCenter = radialSegment.center || radialSegment.pt2.center; // ellipse oppure arco
            // const radialRadius = radialSegment.radius || radialSegment.pt2.radius; // ellipse oppure arco

            const radialCenter = radialSegment.pt2.center;
            const radialRadius = radialSegment.pt2.radius;

            // porto le coordinate del secondo segmento all'interno del primo segmento
            const linearSegmentPointListInLocalRadialSegment = linearSegment.element.getTransformToElement(radialSegment.element).transformPointList([linearSegment.pt1, linearSegment.pt2]);
            //const intersectionData = GeometryUtils.getLineCircleIntersection( linearSegmentPointListInLocalRadialSegment[0], linearSegmentPointListInLocalRadialSegment[1], radialSegment.center,  radialSegment.radius );
            const intersectionData = GeometryUtils.getLineCircleIntersection(linearSegmentPointListInLocalRadialSegment[0], linearSegmentPointListInLocalRadialSegment[1], radialCenter, radialRadius);
            if (intersectionData.points) {
                let intersectionPoint = SVGUtils.createSVGPoint(intersectionData.points.intersection1.coords[0], intersectionData.points.intersection1.coords[1]);

                if (GeometryUtils.isPointSnappedTo(radialSegment.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    _e.intersectionAtPoint = intersectionPoint;
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: radialSegment.element,
                        point: intersectionPoint
                    }, 'intersection: linear / radial');
                    return true;

                }

                intersectionPoint = SVGUtils.createSVGPoint(intersectionData.points.intersection2.coords[0], intersectionData.points.intersection2.coords[1]);

                if (GeometryUtils.isPointSnappedTo(radialSegment.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    _e.intersectionAtPoint = intersectionPoint;
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: radialSegment.element,
                        point: intersectionPoint
                    }, 'intersection: linear / radial');
                    return true;
                }

                // // se non si tratta della prima intersezione con il centro
                // if( ! GeometryUtils.isPointSnappedTo ( radialSegment.pointOnSegment , intersectionPoint, _e.snapDistance  ) )
                // {
                //     // sara sicuramente la seconda
                //     intersectionPoint = SVGUtils.createSVGPoint(  intersectionData.points.intersection2.coords[0], intersectionData.points.intersection2.coords[1] );
                // }
                //
                // _e.intersectionAtPoint = intersectionPoint;
                // this.snapToWorkspaceAndContentCoords(_e,{element:radialSegment.element,point:intersectionPoint}, 'intersection: linear / radial');
                // return true;
            }
        } else if (segment1.type === 'radial' && segment2.type === 'radial') {
            // const segment1RadialCenter = segment1.center || segment1.pt2.center; // ellipse oppure arco
            // const segment1rRadialRadius = segment1.radius || segment1.pt2.radius; // ellipse oppure arco
            //
            // const segment2RadialCenter = segment2.center || segment2.pt2.center; // ellipse oppure arco
            // const segment2RadialRadius = segment2.radius || segment2.pt2.radius; // ellipse oppure arco

            const segment1RadialCenter = segment1.pt2.center;
            const segment1rRadialRadius = segment1.pt2.radius;

            const segment2RadialCenter = segment2.pt2.center;
            const segment2RadialRadius = segment2.pt2.radius;

            // porto le coordinate del secondo segmento all'interno del primo segmento
            //const centerSegment2InLocalSegment1 = segment2.element.getTransformToElement(segment1.element).transformPointList([segment2.center])[0];
            const centerSegment2InLocalSegment1 = segment2.element.getTransformToElement(segment1.element).transformPointList([segment2RadialCenter])[0];

            const intersectionData = GeometryUtils.getCircleCircleIntersection(
                    centerSegment2InLocalSegment1.x, centerSegment2InLocalSegment1.y, segment2RadialRadius,
                    segment1RadialCenter.x, segment1RadialCenter.y, segment1rRadialRadius);

            if (intersectionData) {
                let intersectionPoint = SVGUtils.createSVGPoint(intersectionData.intersection1.x, intersectionData.intersection1.y);
                if (GeometryUtils.isPointSnappedTo(segment1.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    // OK
                } else {
                    intersectionPoint = SVGUtils.createSVGPoint(intersectionData.intersection2.x, intersectionData.intersection2.y);
                    if (GeometryUtils.isPointSnappedTo(segment1.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                        // OK
                    } else {
                        return false;
                    }
                }

                _e.intersectionAtPoint = intersectionPoint;
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: segment1.element,
                    point: intersectionPoint
                }, 'intersection: radial / radial');
                return true;
            }
        } else if ((segment1.type === 'curve' && segment2.type === 'linear') || (segment2.type === 'curve' && segment1.type === 'linear')) {
            let curveSegment,
            linearSegment;
            if (segment1.type === 'curve') {
                curveSegment = segment1;
                linearSegment = segment2;
            } else {
                curveSegment = segment2;
                linearSegment = segment1;
            }

            // porto le coordinate del secondo segmento all'interno del primo segmento
            const linearSegmentPointListInLocalCurveSegment = linearSegment.element.getTransformToElement(curveSegment.element).transformPointList([linearSegment.pt1, linearSegment.pt2]);
            let curve;
            if (curveSegment.pt2.type === 'C') {
                curve = new Bezier(
                        curveSegment.pt1.x, curveSegment.pt1.y,
                        curveSegment.pt2.controlPt1.x, curveSegment.pt2.controlPt1.y,
                        curveSegment.pt2.controlPt2.x, curveSegment.pt2.controlPt2.y,
                        curveSegment.pt2.x, curveSegment.pt2.y);
            } else {
                if (curveSegment.pt2.type === 'Q') {
                    curve = new Bezier(
                            curveSegment.pt1.x, curveSegment.pt1.y,
                            curveSegment.pt2.controlPt1.x, curveSegment.pt2.controlPt1.y,
                            curveSegment.pt2.x, curveSegment.pt2.y);
                }
            }

            const line = {
                p1: {
                    x: linearSegmentPointListInLocalCurveSegment[0].x,
                    y: linearSegmentPointListInLocalCurveSegment[0].y
                },
                p2: {
                    x: linearSegmentPointListInLocalCurveSegment[1].x,
                    y: linearSegmentPointListInLocalCurveSegment[1].y
                }
            };

            const intersectionData = curve.intersects(line);

            for (let i = 0; i < intersectionData.length; i++) {
                const intersectionPoint = curve.get(intersectionData[i]);
                if (GeometryUtils.isPointSnappedTo(curveSegment.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    _e.intersectionAtPoint = intersectionPoint;
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: curveSegment.element,
                        point: intersectionPoint
                    }, 'intersection: linear / curve');
                    return true;
                }
            }
        } else if ((segment1.type === 'curve' && segment2.type === 'curve')) {
            let curve1,
            curve2,
            segment2PointListInLocalSegment1;

            if (segment1.pt2.type === 'C') {
                curve1 = new Bezier(
                        segment1.pt1.x, segment1.pt1.y,
                        segment1.pt2.controlPt1.x, segment1.pt2.controlPt1.y,
                        segment1.pt2.controlPt2.x, segment1.pt2.controlPt2.y,
                        segment1.pt2.x, segment1.pt2.y);
            } else if (segment1.pt2.type === 'Q') {
                curve1 = new Bezier(
                        segment1.pt1.x, segment1.pt1.y,
                        segment1.pt2.controlPt1.x, segment1.pt2.controlPt1.y,
                        segment1.pt2.x, segment1.pt2.y);
            }

            if (segment2.pt2.type === 'C') {
                segment2PointListInLocalSegment1 = segment2.element.getTransformToElement(segment1.element).transformPointList([segment2.pt1, segment2.pt2.controlPt1, segment2.pt2.controlPt2, segment2.pt2]);
                curve2 = new Bezier(
                        segment2PointListInLocalSegment1[0].x, segment2PointListInLocalSegment1[0].y,
                        segment2PointListInLocalSegment1[1].x, segment2PointListInLocalSegment1[1].y,
                        segment2PointListInLocalSegment1[2].x, segment2PointListInLocalSegment1[2].y,
                        segment2PointListInLocalSegment1[3].x, segment2PointListInLocalSegment1[3].y);
            } else if (segment2.pt2.type === 'Q') {
                segment2PointListInLocalSegment1 = segment2.element.getTransformToElement(segment1.element).transformPointList([segment2.pt1, segment2.pt2.controlPt1, segment2.pt2]);
                curve2 = new Bezier(
                        segment2PointListInLocalSegment1[0].x, segment2PointListInLocalSegment1[0].y,
                        segment2PointListInLocalSegment1[1].x, segment2PointListInLocalSegment1[1].y,
                        segment2PointListInLocalSegment1[2].x, segment2PointListInLocalSegment1[2].y);
            }

            const intersectionData = curve1.intersects(curve2);

            for (let i = 0; i < intersectionData.length; i++) {
                const intersectionPoint = curve1.get(parseFloat(intersectionData[i].split('/')[0]));
                if (GeometryUtils.isPointSnappedTo(segment1.pointOnSegment, intersectionPoint, _e.snapDistance)) {
                    _e.intersectionAtPoint = intersectionPoint;
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: segment1.element,
                        point: intersectionPoint
                    }, 'intersection curve / curve');
                    return true;
                }
            }
        }

        return false;
    }

    snapToLinearSegmentPerpendicular(_e, _segment) {
        const startPenEventInLocalTarget = _segment.element.globalToLocal(_e.startPenEvent.workspaceX, _e.startPenEvent.workspaceY);
        const result = GeometryUtils.getClosestPointToLine(_segment.pt1, _segment.pt2, startPenEventInLocalTarget);

        if (GeometryUtils.isPointSnappedTo(_segment.point, result.point, _e.snapDistance)) {
            this.snapToWorkspaceAndContentCoords(_e, {
                element: _segment.element,
                point: result.point
            }, 'perpendicular to ' + _segment.name);
            _e.perpendicularAtPoint = result.point;
            const perpendicularSegment = {
                element: _segment.element,
                point: null,
                pt1: startPenEventInLocalTarget,
                pt2: result.point,
                name: 'perpendicular',
                color: _segment.color,
                type: 'linear'
            };
            this.showVirtualGuideA(_segment);
            this.showPerpendicularGuide(perpendicularSegment);
            return true;
        }
        return false;
    }

    applySnapTo_angle(_e, _snapAngleRadians) {
        const preferences = activeApplication.activeDocument.preferences;

        const xDistance = Math.abs(_e.workspaceX - _e.startPenEvent.workspaceX);
        const yDistance = Math.abs(_e.workspaceY - _e.startPenEvent.workspaceY);

        const snapDistance = preferences.snap.offsetDistance;

        if ((xDistance < snapDistance) || (yDistance < snapDistance)) {
            if (xDistance < snapDistance)
                _e.workspaceX = _e.startPenEvent.workspaceX;
            if (yDistance < snapDistance)
                _e.workspaceY = _e.startPenEvent.workspaceY;
            return;
        }

        _snapAngleRadians = _snapAngleRadians || (45 * (Math.PI / 180));

        let point = {
            x: _e.workspaceX - _e.startPenEvent.workspaceX,
            y: _e.workspaceY - _e.startPenEvent.workspaceY
        };
        const vectorLength = Math.sqrt(point.x * point.x + point.y * point.y);

        const angle = Math.atan2(point.y, point.x);

        const snapId = Math.round(angle / _snapAngleRadians);
        point = SVGUtils.createSVGPointPolar(vectorLength, snapId * _snapAngleRadians);
        _e.workspaceX = _e.startPenEvent.workspaceX + point.x;
        _e.workspaceY = _e.startPenEvent.workspaceY + point.y;
        activeApplication.activeDocument.workspaceToPageContentCoords(_e);

    };

    updatePointer(_e) {
        if (_e.elementAtPoint && _e.elementAtPoint.nodeName !== 'svg') {
            activeApplication.classList.add('over-element');

            if (_e.vertexAtPoint) {
                activeApplication.classList.add('over-vertex');
            } else {
                activeApplication.classList.remove('over-vertex');
            }

            if (_e.segmentListAtPoint.length > 0) {
                activeApplication.classList.add('over-segment');
            } else {
                activeApplication.classList.remove('over-segment');
            }

        } else {
            activeApplication.classList.remove('over-element', 'over-vertex', 'over-segment');
        }

        activeApplication.workspace.showPointerTip(_e);

    };

    vertexAtPointToSmartPoint(_e) {
        const self = this;

        function smartPointTimeout() {
            if (_e === self.lastEvent) {
                if (self.isSmartPointDefined(_e)) {
                    self.resetSmartPoints();
                    return;
                }
                self.createSmartPoint(_e.vertexAtPoint, _e.timeStamp);
            }
        }
        clearTimeout(this.holdTimeout);
        this.holdTimeout = setTimeout(smartPointTimeout, 500);
    }

    segmentAtPointToSmartGuide(_e) {
        const self = this;

        function smartGuideTimeout() {
            if (_e === self.lastEvent) {
                if (self.isSmartGuideDefined(_e)) {
                    self.resetSmartGuides();
                    return;
                }
                self.createSmartGuide(_e.segmentListAtPoint[0], _e.timeStamp);
            } else {}
        }
        clearTimeout(this.holdTimeout);
        this.holdTimeout = setTimeout(smartGuideTimeout, 500);
    }

    // apply snap

    applySnap(_e, _options) {
        this.lastEvent = _e;
        // if( _e.shiftKey && _e.startPenEvent  ) this.applySnapTo_angle( _e ); // quando si converte un vertice di una path da angolo a curva startPenEvent viene settato a null

        const activeDocument = activeApplication.activeDocument;

        _e.snapOptions = _options || activeDocument.preferences.snap;
        _e.snapDistance = _e.snapOptions.distance / activeDocument.activePage.content.currentScale;
        _e.pointerDescription = '';

        this.hideAll();

        if (_e.elementListAtPoint) {
            this.hitTest(_e, _options);
            this.updatePointer(_e);

            if (_e.vertexAtPoint && _e.snapOptions.useSmartPoints) {
                this.vertexAtPointToSmartPoint(_e);
                return;
            }

            if (_e.intersectionAtPoint)
                return;
            if (_e.perpendicularAtPoint)
                return;
            if (_e.tangentAtPoint)
                return;
        }

        this.applySnapToVirtualGuides(_e, _options);
        this.updatePointer(_e);
    }

    applySnapToVirtualGuides(_e, _options) {
        const activeDocument = activeApplication.activeDocument;

        let snappedSmartPointGuideA = null;
        let snappedSmartPointGuideB = null;
        let snappedSmartGuideA = null;
        let snappedSmartGuideB = null;

        if (_e.snapOptions.useSmartPoints) {
            if (this.smartPointA) {
                this.showSmartPointA(this.smartPointA);
                snappedSmartPointGuideA = this.snapToVirtualSegmentList(_e, this.smartPointA.snapGuideList);
            }
            if (this.smartPointB) {
                this.showSmartPointB(this.smartPointB);
                snappedSmartPointGuideB = this.snapToVirtualSegmentList(_e, this.smartPointB.snapGuideList);
            }
            // //verifico l'intersezione delle guide degli smart points ( c'è sicuramente se sono sopra tutte e due guide  )
            if (_e.snapOptions.snapToIntersection && snappedSmartPointGuideA && snappedSmartPointGuideB && this.isIntersection(_e, snappedSmartPointGuideA[0], snappedSmartPointGuideB[0]))
                return;
        }

        if (_e.snapOptions.useSmartGuides) {
            if (this.smartGuideA) {
                this.showSmartGuideA(this.smartGuideA);
                snappedSmartGuideA = this.snapToVirtualSegmentList(_e, this.smartGuideA.snapGuideList, false);
                if (snappedSmartGuideA) {
                    if (snappedSmartGuideA.length > 1) {
                        if (this.isIntersection(_e, snappedSmartGuideA[0], snappedSmartGuideA[1]))
                            return;
                    }
                }
            }

            if (this.smartGuideB) {
                this.showSmartGuideB(this.smartGuideB);
                snappedSmartGuideB = this.snapToVirtualSegmentList(_e, this.smartGuideB.snapGuideList, false);
                if (snappedSmartGuideB) {
                    if (snappedSmartGuideB.length > 1) {
                        if (this.isIntersection(_e, snappedSmartGuideB[0], snappedSmartGuideB[1]))
                            return;
                    }
                }
            }

            if (_e.segmentListAtPoint && _e.segmentListAtPoint.length > 0 && _e.segmentListAtPoint[0].type === 'linear')
                this.segmentAtPointToSmartGuide(_e)

        }

        if (_e.snapOptions.snapToIntersection) {
            if (snappedSmartGuideA) {
                //verifico l'intersezione delle snappedSmartGuide ( c'è sicuramente se sono sopra tutte e due guide  )
                if (snappedSmartGuideB && this.isIntersection(_e, snappedSmartGuideA[0], snappedSmartGuideB[0]))
                    return;

                // verifico se c'è intersezione tra snappedSmartGuideA e snappedSmartPointGuideA
                if (snappedSmartPointGuideA && this.isIntersection(_e, snappedSmartGuideA[0], snappedSmartPointGuideA[0]))
                    return;

                // verifico se c'è intersezione tra snappedSmartGuideA e snappedSmartPointGuideB
                if (snappedSmartPointGuideB && this.isIntersection(_e, snappedSmartGuideA[0], snappedSmartPointGuideB[0]))
                    return;
            }

            if (snappedSmartGuideB) {
                // verifico se c'è intersezione tra snappedSmartGuideB e snappedSmartPointGuideA
                if (snappedSmartPointGuideA && this.isIntersection(_e, snappedSmartGuideB[0], snappedSmartPointGuideA[0]))
                    return;

                // verifico se c'è intersezione tra snappedSmartGuideB e snappedSmartPointGuideB
                if (snappedSmartPointGuideB && this.isIntersection(_e, snappedSmartGuideB[0], snappedSmartPointGuideB[0]))
                    return;
            }
        }

        if (_e.startPenEvent && _e.snapOptions.snapToPerpendicular) {
            // se c'è un punto da proiettare verifico se si è perpendicolari a snappedSmartGuideA
            if (snappedSmartGuideA && this.snapToLinearSegmentPerpendicular(_e, snappedSmartGuideA[0]))
                return;

            // se c'è un punto da proiettare verifico se si è perpendicolari a snappedSmartGuideB
            if (snappedSmartGuideB && this.snapToLinearSegmentPerpendicular(_e, snappedSmartGuideB[0]))
                return;
        }

        let snappedAngularGuide = null;

        // se c'è una virtual origin
        if (_e.snapOptions.snapToAngles && this.virtualOrigin !== null) {
            // verifico se il puntatore è su un segmento angolare virtuale che parte dall'origine dell'azione di disegno, traslazione o scalatura
            snappedAngularGuide = this.snapToVirtualSegmentList(_e, this.virtualOrigin.snapGuideList);
            if (snappedAngularGuide) {
                //se sono su un segmento angolare (angoli definiti come ad esempio 30,45, parallela, perpendicolare, ecc) ed esiste un segmento reale verifico l'intersezione dei due
                if (_e.snapOptions.snapToIntersection && _e.segmentListAtPoint && (_e.segmentListAtPoint.length > 0) && this.isSegmentSegmentIntersection(_e, snappedAngularGuide[0], _e.segmentListAtPoint[0])) {
                    _e.pointerDescription = 'intersection: ' + snappedAngularGuide[0].name;
                    return;
                }
            }

        }

        // se arrivo qui non c'è intersezione ne tra smart guides ne tra smart points guides


        if (_e.snapOptions.snapToIntersection && snappedAngularGuide) {
            //se c'è uno snap angolare  verifico l'intersezione con smartPoint A
            if (snappedSmartPointGuideA && this.isIntersection(_e, snappedAngularGuide[0], snappedSmartPointGuideA[0]))
                return;

            //se ce uno snap angolare e smartPointB esiste  verifico l'intersezione con smartPoint B
            if (snappedSmartPointGuideB && this.isIntersection(_e, snappedAngularGuide[0], snappedSmartPointGuideB[0]))
                return;

            //se c'è uno snap angolare  e snappedSmartGuideA esiste verifico l'intersezione
            if (snappedSmartGuideA && this.isIntersection(_e, snappedAngularGuide[0], snappedSmartGuideA[0]))
                return;

            //se ce uno snap angolare e snappedSmartGuideB esiste  verifico l'intersezione
            if (snappedSmartGuideB && this.isIntersection(_e, snappedAngularGuide[0], snappedSmartGuideB[0]))
                return;
        }

        if (snappedAngularGuide && snappedAngularGuide[0].name === 'horizontal' && _e.snapOptions.snapToGrid) {
            _e.contentX = activeDocument.preferences.origin.x + activeDocument.preferences.gridStep * Math.round((_e.contentX - activeDocument.preferences.origin.x) / activeDocument.preferences.gridStep);
            activeDocument.pageContentToWorkspaceCoords(_e);
            return;
        } else if (snappedAngularGuide && snappedAngularGuide[0].name === 'vertical' && _e.snapOptions.snapToGrid) {

            _e.contentY = activeDocument.preferences.origin.y + activeDocument.preferences.gridStep * Math.round((_e.contentY - activeDocument.preferences.origin.y) / activeDocument.preferences.gridStep);
            activeDocument.pageContentToWorkspaceCoords(_e);
            return;
        } else if (_e.segmentListAtPoint || snappedSmartPointGuideA || snappedSmartPointGuideB || snappedSmartGuideA || snappedSmartGuideB)
            return;

        if (_e.snapOptions.snapToGrid) {
            _e.contentX = activeDocument.preferences.origin.x + activeDocument.preferences.gridStep * Math.round((_e.contentX - activeDocument.preferences.origin.x) / activeDocument.preferences.gridStep);
            _e.contentY = activeDocument.preferences.origin.y + activeDocument.preferences.gridStep * Math.round((_e.contentY - activeDocument.preferences.origin.y) / activeDocument.preferences.gridStep);
            activeDocument.pageContentToWorkspaceCoords(_e);
        }

    }

    hitTest(_e, _options) {
        _e.segmentListAtPoint = [];
        _e.vertexAtPoint = null;

        if (_e.elementAtPoint)
            _e.pointerDescription = _e.elementAtPoint.nodeName;

        if (_e.elementListAtPoint) {
            const elementList = _e.elementListAtPoint;
            const max = elementList.length;
            let element;
            for (let i = 0; i < max; i++) {
                element = elementList[i];
                if (element.nodeName === 'line' && this.snapToLine(_e, element))
                    return;
                if (element.nodeName === 'path' && this.snapToPath(_e, element))
                    return;
                if ((element.nodeName === 'rect' || element.nodeName === 'image') && this.snapToRectangularElement(_e, element))
                    return;
                if (element.nodeName === 'ellipse' && this.snapToEllipse(_e, element))
                    return;

            }

        }

        if (_e.segmentListAtPoint.length > 0) {

            if (_e.snapOptions.snapToIntersection && _e.segmentListAtPoint.length > 1 && this.isSegmentSegmentIntersection(_e, _e.segmentListAtPoint[0], _e.segmentListAtPoint[1]))
                return;

            // se c'è un punto da proiettare
            if (_e.startPenEvent) {
                const segment = _e.segmentListAtPoint[0];
                const startPenEventInLocalTarget = segment.element.globalToLocal(_e.startPenEvent.workspaceX, _e.startPenEvent.workspaceY);

                if (_e.snapOptions.snapToPerpendicular) {
                    if (segment.type === 'linear') {
                        const result = GeometryUtils.getClosestPointToLine(segment.pt1, segment.pt2, startPenEventInLocalTarget);
                        // segment.pointOnSegment è il punto sul segmento in cui si trova il puntatore. Viene calcolato nella fase di verifica con i segmenti
                        if (GeometryUtils.isPointSnappedTo(segment.pointOnSegment, result.point, _e.snapDistance)) {
                            _e.perpendicularAtPoint = result.point;
                            this.snapToWorkspaceAndContentCoords(_e, {
                                element: segment.element,
                                point: result.point
                            }, 'perpendicular');
                            return;
                        }
                    } else if (segment.type === 'radial') {
                        // const radialCenter = segment.center || segment.pt2.center; // ellipse oppure arco
                        // const radialRadius = segment.radius || segment.pt2.radius; // ellipse oppure arco
                        const radialCenter = segment.pt2.center;
                        const radialRadius = segment.pt2.radius;

                        const angle = radialCenter.getAngleFromPoint(startPenEventInLocalTarget);
                        const pointOnContour = SVGUtils.createSVGPointPolar(radialRadius, angle);
                        pointOnContour.x += radialCenter.x;
                        pointOnContour.y += radialCenter.y;

                        if (GeometryUtils.isPointSnappedTo(segment.pointOnSegment, pointOnContour, _e.snapDistance)) {
                            _e.perpendicularAtPoint = pointOnContour;
                            this.snapToWorkspaceAndContentCoords(_e, {
                                element: segment.element,
                                point: pointOnContour
                            }, 'perpendicular');
                            return;
                        }
                    }
                }

                if (_e.snapOptions.snapToTangent) {
                    if (segment.type === 'radial') {
                        let tangentPointResult = null;
                        // const radialCenter = segment.center || segment.pt2.center; // ellipse oppure arco
                        // const radialRadius = segment.radius || segment.pt2.radius; // ellipse oppure arco
                        const radialCenter = segment.pt2.center;
                        const radialRadius = segment.pt2.radius;

                        //const tangents = GeometryUtils.getCircleTangentPoints( startPenEventInLocalTarget, segment.center, segment.radius );
                        const tangents = GeometryUtils.getCircleTangentPoints(startPenEventInLocalTarget, radialCenter, radialRadius);
                        if (GeometryUtils.isPointSnappedTo(segment.pointOnSegment, tangents.t1, _e.snapDistance))
                            tangentPointResult = tangents.t1;
                        if (GeometryUtils.isPointSnappedTo(segment.pointOnSegment, tangents.t2, _e.snapDistance))
                            tangentPointResult = tangents.t2;

                        if (tangentPointResult) {
                            _e.tangentAtPoint = tangentPointResult;
                            this.snapToWorkspaceAndContentCoords(_e, {
                                element: segment.element,
                                point: tangentPointResult
                            }, 'tangent');
                            return;
                        }
                    }
                }

            }
        }

    }

    snapToRectangularElement(_e, _element) {
        const pointerInLocal = _element.globalToLocal(_e.workspaceX, _e.workspaceY);
        const bbox = _element.getBBox();
        const min = {};
        const max = {};
        const center = {};
        min.x = bbox.x;
        min.y = bbox.y;
        max.x = bbox.x + bbox.width;
        max.y = bbox.y + bbox.height;
        center.x = min.x + bbox.width / 2;
        center.y = min.y + bbox.height / 2;

        let snapData;

        if (_e.snapOptions.snapToCenter) {
            snapData = {
                point: {
                    x: center.x,
                    y: min.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'top-center');
                return true;
            }

            snapData = {
                point: {
                    x: max.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'right-center');
                return true;
            }

            snapData = {
                point: {
                    x: center.x,
                    y: max.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'bottom-center');
                return true;
            }

            snapData = {
                point: {
                    x: min.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'left-center');
                return true;
            }

            snapData = {
                point: {
                    x: center.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'center');
                return true;
            }
        }

        if (_e.snapOptions.snapToPoints) {
            snapData = {
                point: {
                    x: min.x,
                    y: min.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'top-left');
                return true;
            }

            snapData = {
                point: {
                    x: max.x,
                    y: min.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'top-right');
                return true;
            }

            snapData = {
                point: {
                    x: max.x,
                    y: max.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'bottom-right');
                return true;
            }

            snapData = {
                point: {
                    x: min.x,
                    y: max.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'bottom-left');
                return true;
            }

            snapData = {
                point: {
                    x: 0,
                    y: 0
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'origin');
                return true;
            }
        }

        if (_e.snapOptions.snapToContour) {
            let pointOnLine;

            pointOnLine = GeometryUtils.isPointOnLine({
                x: min.x,
                y: min.y
            }, {
                x: max.x,
                y: min.y
            }, pointerInLocal, _e.snapDistance); // la linea up
            if (pointOnLine) {
                _e.segmentListAtPoint.push({
                    element: _element,
                    type: 'linear',
                    pointOnSegment: pointOnLine,
                    idSegment: 0,
                    pt1: SVGUtils.createSVGPoint(min.x, min.y),
                    pt2: SVGUtils.createSVGPoint(max.x, min.y),
                    name: _element.nodeName + ' top'
                });
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: _element,
                    point: pointOnLine
                }, _element.nodeName + ' top');
                return;
            }

            pointOnLine = GeometryUtils.isPointOnLine({
                x: max.x,
                y: min.y
            }, {
                x: max.x,
                y: max.y
            }, pointerInLocal, _e.snapDistance); // la linea right
            if (pointOnLine) {
                _e.segmentListAtPoint.push({
                    element: _element,
                    type: 'linear',
                    pointOnSegment: pointOnLine,
                    idSegment: 1,
                    pt1: SVGUtils.createSVGPoint(max.x, min.y),
                    pt2: SVGUtils.createSVGPoint(max.x, max.y),
                    name: _element.nodeName + ' right'
                });
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: _element,
                    point: pointOnLine
                }, _element.nodeName + ' right');
                return;
            }

            pointOnLine = GeometryUtils.isPointOnLine({
                x: max.x,
                y: max.y
            }, {
                x: min.x,
                y: max.y
            }, pointerInLocal, _e.snapDistance); // la linea bottom
            if (pointOnLine) {
                _e.segmentListAtPoint.push({
                    element: _element,
                    type: 'linear',
                    pointOnSegment: pointOnLine,
                    idSegment: 2,
                    pt1: SVGUtils.createSVGPoint(max.x, max.y),
                    pt2: SVGUtils.createSVGPoint(min.x, max.y),
                    name: _element.nodeName + ' bottom'
                });
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: _element,
                    point: pointOnLine
                }, _element.nodeName + ' bottom');
                return;
            }

            pointOnLine = GeometryUtils.isPointOnLine({
                x: min.x,
                y: max.y
            }, {
                x: min.x,
                y: min.y
            }, pointerInLocal, _e.snapDistance); // la linea left
            if (pointOnLine) {
                _e.segmentListAtPoint.push({
                    element: _element,
                    type: 'linear',
                    pointOnSegment: pointOnLine,
                    idSegment: 3,
                    pt1: SVGUtils.createSVGPoint(min.x, max.y),
                    pt2: SVGUtils.createSVGPoint(min.x, min.y),
                    name: _element.nodeName + ' left'
                });
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: _element,
                    point: pointOnLine
                }, _element.nodeName + ' left');
                return;
            }
        }

    };

    snapToLine(_e, _line) {
        //_e.pointerDescription = 'line';

        const pointerInLocal = _line.globalToLocal(_e.workspaceX, _e.workspaceY);
        const geometryPointList = _line.getGeometryPointList();

        if (_e.snapOptions.snapToPoints) {
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, geometryPointList[0], _e.snapDistance)) {
                _e.vertexAtPoint = {
                    element: _line,
                    point: geometryPointList[0]
                };
                this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'start');
                return true;
            }
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, geometryPointList[1], _e.snapDistance)) {
                _e.vertexAtPoint = {
                    element: _line,
                    point: geometryPointList[1]
                };
                this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'end');
                return true;
            }
        }

        if (_e.snapOptions.snapToCenter) {
            const centerPoint = SVGUtils.createSVGPoint(geometryPointList[0].x + ((geometryPointList[1].x - geometryPointList[0].x) / 2), geometryPointList[0].y + ((geometryPointList[1].y - geometryPointList[0].y) / 2))
                if (GeometryUtils.isPointSnappedTo(pointerInLocal, centerPoint, _e.snapDistance)) {
                    _e.vertexAtPoint = {
                        element: _line,
                        point: centerPoint
                    };
                    this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'midpoint');
                    return true;
                }
        }

        if (_e.snapOptions.snapToContour) {
            // è sicuramente online
            //const pointOnLine = GeometryUtils.isPointOnLine( geometryPointList[0], geometryPointList[1], pointerInLocal, _e.snapDistance  );
            const pointOnLine = GeometryUtils.isPointOverSegment(geometryPointList[0], geometryPointList[1], pointerInLocal, _e.snapDistance);
            if (pointOnLine) {
                _e.segmentListAtPoint.push({
                    element: _line,
                    type: 'linear',
                    pointOnSegment: pointOnLine,
                    idSegment: 1,
                    pt1: geometryPointList[0],
                    pt2: geometryPointList[1],
                    name: 'line'
                });
                this.snapToWorkspaceAndContentCoords(_e, {
                    element: _line,
                    point: pointOnLine
                }, 'line');
            }
        }

    }

    snapToPath(_e, _path) {
        //_e.pointerDescription = 'path';

        const pointerInLocal = _path.globalToLocal(_e.workspaceX, _e.workspaceY);

        if (_e.snapOptions.snapToPoints) {
            const origin = SVGUtils.createSVGPoint();
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, origin, _e.snapDistance)) {
                _e.vertexAtPoint = {
                    element: _path,
                    point: origin
                };
                this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'origin');
                return true;
            }
        }

        const geometryPointList = _path.getGeometryPointList();
        let currentPoint,
        previousPoint = {};
        const linearSegmentList = [];
        const curveSegmentList = [];
        for (let i = 0; i < geometryPointList.length; i++) {
            currentPoint = geometryPointList[i];
            // snap ai vertici
            if (_e.snapOptions.snapToPoints) {
                if (GeometryUtils.isPointSnappedTo(pointerInLocal, currentPoint, _e.snapDistance)) {
                    _e.vertexAtPoint = {
                        element: _path,
                        point: currentPoint
                    };
                    this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'vertex');
                    return true;
                }
            }

            if (currentPoint.type === 'L') {
                if (_e.snapOptions.snapToCenter) {
                    const centerPoint = SVGUtils.createSVGPoint(previousPoint.x + ((currentPoint.x - previousPoint.x) / 2), previousPoint.y + ((currentPoint.y - previousPoint.y) / 2))
                        //centerPoint.name = 'midpoint';
                        if (GeometryUtils.isPointSnappedTo(pointerInLocal, centerPoint, _e.snapDistance)) {
                            _e.vertexAtPoint = {
                                element: _path,
                                point: centerPoint
                            };
                            this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'midpoint');
                            // se si tratta di un elemento in primo piano aggiungo il segmento ( serve quando aggiungo un punto , perchè sono necessri i dati del segmento)
                            _e.segmentListAtPoint.push({
                                element: _path,
                                type: 'linear',
                                pointOnSegment: centerPoint,
                                idSegment: currentPoint.id,
                                pt1: previousPoint,
                                pt2: currentPoint,
                                name: 'line-to'
                            });
                            return true;
                        }
                }

                linearSegmentList.push({
                    element: _path,
                    pt1: previousPoint,
                    pt2: currentPoint
                });
            } else if (currentPoint.type === 'C' || currentPoint.type === 'Q') {
                curveSegmentList.push({
                    element: _path,
                    pt1: previousPoint,
                    pt2: currentPoint
                });
            } else if (currentPoint.type === 'A') {
                const curveSegment = {
                    element: _path,
                    pt1: previousPoint,
                    pt2: currentPoint
                };
                curveSegment.pt2.center = GeometryUtils.getArcCenter(curveSegment.pt1.x, curveSegment.pt1.y, curveSegment.pt2.x, curveSegment.pt2.y, curveSegment.pt2.rx, curveSegment.pt2.ry, curveSegment.pt2.angle, curveSegment.pt2.largeArcFlag, curveSegment.pt2.sweepFlag);

                if (_e.snapOptions.snapToCenter) {
                    if (GeometryUtils.isPointSnappedTo(pointerInLocal, curveSegment.pt2.center, _e.snapDistance)) {
                        _e.vertexAtPoint = {
                            element: _path,
                            point: curveSegment.pt2.center
                        };
                        this.snapToWorkspaceAndContentCoords(_e, _e.vertexAtPoint, 'arc center');
                        return true;
                    }
                }

                curveSegmentList.push(curveSegment);
                //curveSegmentList.push( {element:_path, pt1:previousPoint, pt2:currentPoint } );
            }
            previousPoint = currentPoint;
        }

        if (_e.snapOptions.snapToContour) {
            let linearSegment;
            for (let i = 0; i < linearSegmentList.length; i++) {
                linearSegment = linearSegmentList[i];
                //const pointOnLine = GeometryUtils.isPointOnLine( linearSegment.pt1, linearSegment.pt2, pointerInLocal, _e.snapDistance  );
                const pointOnLine = GeometryUtils.isPointOverSegment(linearSegment.pt1, linearSegment.pt2, pointerInLocal, _e.snapDistance);
                if (pointOnLine) {
                    _e.segmentListAtPoint.push({
                        element: _path,
                        type: 'linear',
                        pointOnSegment: pointOnLine,
                        idSegment: linearSegment.pt2.id,
                        pt1: linearSegment.pt1,
                        pt2: linearSegment.pt2,
                        name: 'line-to'
                    });
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: _path,
                        point: pointOnLine
                    }, 'line-to');
                    return;
                }
            }

            let curveSegment;

            for (let i = 0; i < curveSegmentList.length; i++) {
                curveSegment = curveSegmentList[i];
                if (curveSegment.pt2.type === 'C') {
                    const curve = new Bezier(
                            curveSegment.pt1.x, curveSegment.pt1.y,
                            curveSegment.pt2.controlPt1.x, curveSegment.pt2.controlPt1.y,
                            curveSegment.pt2.controlPt2.x, curveSegment.pt2.controlPt2.y,
                            curveSegment.pt2.x, curveSegment.pt2.y);

                    const bbox = curve.bbox();
                    const isPointInBox = (pointerInLocal.x > bbox.x.min) && (pointerInLocal.x < bbox.x.max) && (pointerInLocal.y > bbox.y.min) && (pointerInLocal.y < bbox.y.max);
                    if (isPointInBox) {
                        const pointOnCurve = curve.project(pointerInLocal);
                        if (GeometryUtils.isPointSnappedTo(pointerInLocal, pointOnCurve, _e.snapDistance)) {
                            _e.segmentListAtPoint.push({
                                element: _path,
                                type: 'curve',
                                pointOnSegment: pointOnCurve,
                                idSegment: curveSegment.pt2.id,
                                pt1: curveSegment.pt1,
                                pt2: curveSegment.pt2,
                                name: 'curve-to'
                            });
                            this.snapToWorkspaceAndContentCoords(_e, {
                                element: _path,
                                point: pointOnCurve
                            }, 'curve-to');
                            return;
                        }
                    }

                } else if (curveSegment.pt2.type === 'Q') {
                    const curve = new Bezier(
                            curveSegment.pt1.x, curveSegment.pt1.y,
                            curveSegment.pt2.controlPt1.x, curveSegment.pt2.controlPt1.y,
                            curveSegment.pt2.x, curveSegment.pt2.y);

                    const bbox = curve.bbox();
                    const isPointInBox = (pointerInLocal.x > bbox.x.min) && (pointerInLocal.x < bbox.x.max) && (pointerInLocal.y > bbox.y.min) && (pointerInLocal.y < bbox.y.max);
                    if (isPointInBox) {
                        const pointOnCurve = curve.project(pointerInLocal);
                        if (GeometryUtils.isPointSnappedTo(pointerInLocal, pointOnCurve, _e.snapDistance)) {
                            _e.segmentListAtPoint.push({
                                element: _path,
                                type: 'curve',
                                pointOnSegment: pointOnCurve,
                                idSegment: curveSegment.pt2.id,
                                pt1: curveSegment.pt1,
                                pt2: curveSegment.pt2,
                                name: 'curve-to'
                            });
                            this.snapToWorkspaceAndContentCoords(_e, {
                                element: _path,
                                point: pointOnCurve
                            }, 'curve-to');
                            return;
                        }
                    }

                } else if (curveSegment.pt2.type === 'A') {
                    const arcCenter = curveSegment.pt2.center || GeometryUtils.getArcCenter(curveSegment.pt1.x, curveSegment.pt1.y, curveSegment.pt2.x, curveSegment.pt2.y, curveSegment.pt2.rx, curveSegment.pt2.ry, curveSegment.pt2.angle, curveSegment.pt2.largeArcFlag, curveSegment.pt2.sweepFlag);

                    // const center = document.querySelector('#CURRENT_PEN_LOCATION')
                    // center.getTransform().setMatrix(_path.getCTM().translate(arcCenter.x,arcCenter.y));
                    // XOS.hideElement(center);

                    const rx = curveSegment.pt2.rx;
                    const ry = curveSegment.pt2.ry;

                    // se si tratta di un cerchio
                    if (Math.abs(rx - ry) < 0.01) {
                        const distancePointerFromCenter = pointerInLocal.getDistanceFromPoint(arcCenter);
                        const radius = curveSegment.pt2.getDistanceFromPoint(arcCenter);

                        if (Math.abs(distancePointerFromCenter - radius) < _e.snapDistance) {
                            const pointOnContour = GeometryUtils.getClosestPointToCircle(pointerInLocal, arcCenter, radius);

                            const isClockwise = GeometryUtils.getPolygonArea([curveSegment.pt1, pointOnContour, curveSegment.pt2]) > 0;
                            if (isClockwise && curveSegment.pt2.sweepFlag === 1 || !isClockwise && curveSegment.pt2.sweepFlag === 0) {
                                curveSegment.pt2.radius = radius;
                                curveSegment.pt2.center = arcCenter;
                                _e.segmentListAtPoint.push({
                                    element: _path,
                                    type: 'radial',
                                    pointOnSegment: pointOnContour,
                                    idSegment: curveSegment.pt2.id,
                                    pt1: curveSegment.pt1,
                                    pt2: curveSegment.pt2,
                                    name: 'arc-to'
                                });
                                this.snapToWorkspaceAndContentCoords(_e, {
                                    element: _path,
                                    point: pointOnContour
                                }, 'arc-to');
                                return;
                            }
                        }
                    } else {
                        const pointerInLocalEllipse = SVGUtils.createSVGPoint(pointerInLocal.x - arcCenter.x, pointerInLocal.y - arcCenter.y)
                            const closestPoint = GeometryUtils.getClosestPointToEllipse(pointerInLocalEllipse, rx, ry);
                        if (GeometryUtils.isPointSnappedTo(pointerInLocalEllipse, closestPoint, _e.snapDistance)) {
                            const isClockwise = GeometryUtils.getPolygonArea([curveSegment.pt1, pointerInLocal, curveSegment.pt2]) > 0;
                            if (isClockwise && curveSegment.pt2.sweepFlag === 1 || !isClockwise && curveSegment.pt2.sweepFlag === 0) {
                                closestPoint.x += arcCenter.x;
                                closestPoint.y += arcCenter.y;

                                // serve solamente per mostrare l'arco cliccandoci sora non serve al momento per l'intersezione
                                curveSegment.pt2.radius = rx;
                                curveSegment.pt2.center = arcCenter;
                                _e.segmentListAtPoint.push({
                                    element: _path,
                                    type: 'radial',
                                    pointOnSegment: closestPoint,
                                    idSegment: curveSegment.pt2.id,
                                    pt1: curveSegment.pt1,
                                    pt2: curveSegment.pt2,
                                    name: 'arc-to'
                                });

                                this.snapToWorkspaceAndContentCoords(_e, {
                                    element: _path,
                                    point: SVGUtils.createSVGPoint(closestPoint.x, closestPoint.y)
                                }, 'arc-to');
                                return;
                            }
                        }
                    }

                    // if( Math.abs(distanceFromCenter - radiusFromCenter) < _e.snapDistance )
                    // {
                    //     XOS.showElement(center,'add');
                    //     const pointOnContour = GeometryUtils.getClosestPointToCircle( pointerInLocal , arcCenter , radiusFromCenter );
                    //
                    //     const isClockwise = GeometryUtils.getPolygonArea( [curveSegment.pt1 , pointOnContour, curveSegment.pt2 ] )>0;
                    //     if( isClockwise && curveSegment.pt2.sweepFlag===1 || !isClockwise && curveSegment.pt2.sweepFlag===0 )
                    //     {
                    //         curveSegment.pt2.radius = radiusFromCenter;
                    //         curveSegment.pt2.center = arcCenter;
                    //         _e.segmentListAtPoint.push( {element:_path, type:'radial', pointOnSegment:pointOnContour, idSegment:curveSegment.pt2.id, pt1: curveSegment.pt1, pt2:curveSegment.pt2, name:'arc-to' } );
                    //         this.snapToWorkspaceAndContentCoords(_e,{element:_path,point:pointOnContour},'arc-to');
                    //         return;
                    //     }
                    // }
                }
                // else if(curveSegment.pt2.type==='A')
                // {
                //     const arcCenter = curveSegment.pt2.center || GeometryUtils.getArcCenter(curveSegment.pt1.x,curveSegment.pt1.y, curveSegment.pt2.x,curveSegment.pt2.y, curveSegment.pt2.rx, curveSegment.pt2.ry, curveSegment.pt2.angle, curveSegment.pt2.largeArcFlag, curveSegment.pt2.sweepFlag );
                //
                //     const distanceFromCenter = pointerInLocal.getDistanceFromPoint( arcCenter );
                //     const radiusFromCenter = curveSegment.pt2.getDistanceFromPoint( arcCenter );
                //
                //     const center = document.querySelector('#CURRENT_PEN_LOCATION')
                //     center.getTransform().setMatrix(_path.getCTM().translate(arcCenter.x,arcCenter.y));
                //     XOS.hideElement(center);
                //
                //     if( Math.abs(distanceFromCenter - radiusFromCenter) < _e.snapDistance )
                //     {
                //         XOS.showElement(center,'add');
                //         const pointOnContour = GeometryUtils.getClosestPointToCircle( pointerInLocal , arcCenter , radiusFromCenter );
                //
                //         const isClockwise = GeometryUtils.getPolygonArea( [curveSegment.pt1 , pointOnContour, curveSegment.pt2 ] )>0;
                //         if( isClockwise && curveSegment.pt2.sweepFlag===1 || !isClockwise && curveSegment.pt2.sweepFlag===0 )
                //         {
                //             curveSegment.pt2.radius = radiusFromCenter;
                //             curveSegment.pt2.center = arcCenter;
                //             _e.segmentListAtPoint.push( {element:_path, type:'radial', pointOnSegment:pointOnContour, idSegment:curveSegment.pt2.id, pt1: curveSegment.pt1, pt2:curveSegment.pt2, name:'arc-to' } );
                //             this.snapToWorkspaceAndContentCoords(_e,{element:_path,point:pointOnContour},'arc-to');
                //             return;
                //         }
                //     }
                // }

            }
        }

    }

    snapToEllipse(_e, _element) {
        let radius;
        const pointerInLocal = _element.globalToLocal(_e.workspaceX, _e.workspaceY);
        const center = SVGUtils.createSVGPoint(parseFloat(_element.getAttribute('cx')), parseFloat(_element.getAttribute('cy')));
        // const distancePointCenter = pointerInLocal.getDistanceFromPoint( center );
        //
        // if(distancePointCenter < _e.snapDistance)
        // {
        //     _e.vertexAtPoint = {element:_element,point:SVGUtils.createSVGPoint(center.x,center.y)};
        //     this.snapToWorkspaceAndContentCoords(_e,_e.vertexAtPoint, 'center' );
        //     return true;
        // }

        const rx = parseFloat(_element.getAttribute('rx'));
        const ry = parseFloat(_element.getAttribute('ry'));

        const min = {
            x: center.x - rx,
            y: center.y - ry
        };
        const max = {
            x: center.x + rx,
            y: center.y + ry
        };

        if (_e.snapOptions.snapToCenter) {
            let snapData = {
                point: {
                    x: center.x,
                    y: min.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'top-center');
                return true;
            }

            snapData = {
                point: {
                    x: max.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'right-center');
                return true;
            }

            snapData = {
                point: {
                    x: center.x,
                    y: max.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'bottom-center');
                return true;
            }

            snapData = {
                point: {
                    x: min.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'left-center');
                return true;
            }

            snapData = {
                point: {
                    x: center.x,
                    y: center.y
                },
                element: _element
            };
            if (GeometryUtils.isPointSnappedTo(pointerInLocal, snapData.point, _e.snapDistance)) {
                _e.vertexAtPoint = snapData;
                this.snapToWorkspaceAndContentCoords(_e, snapData, 'center');
                return true;
            }
        }

        if (_e.snapOptions.snapToContour) {
            // se si tratta di un cerchio
            if (Math.abs(rx - ry) < 0.01) {
                radius = rx;

                const distancePointCenter = pointerInLocal.getDistanceFromPoint(center);

                if (Math.abs(distancePointCenter - radius) < _e.snapDistance) {
                    const pointOnContour = GeometryUtils.getClosestPointToCircle(pointerInLocal, center, radius);

                    const pt2 = SVGUtils.createSVGPoint(center.x, center.y);
                    pt2.center = center;
                    pt2.radius = radius;

                    _e.segmentListAtPoint.push({
                        element: _element,
                        type: 'radial',
                        pointOnSegment: pointOnContour,
                        idSegment: 0,
                        pt1: null,
                        pt2: pt2,
                        name: 'ellipse'
                    });

                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: _element,
                        point: SVGUtils.createSVGPoint(pointOnContour.x, pointOnContour.y)
                    }, 'contour');
                }
            } else {
                const closestPoint = GeometryUtils.getClosestPointToEllipse(pointerInLocal, rx, ry);
                if (GeometryUtils.isPointSnappedTo(pointerInLocal, closestPoint, _e.snapDistance)) {
                    this.snapToWorkspaceAndContentCoords(_e, {
                        element: _element,
                        point: SVGUtils.createSVGPoint(closestPoint.x, closestPoint.y)
                    }, 'contour');
                }
            }
        }

    }

    /*

    snapToArc( _e, _element  ){
    let center, radius;
    const pointerInLocal = _element.globalToLocal( _e.workspaceX, _e.workspaceY );

    //const geometryPointList = _element.querySelector('path').getGeometryPointList({normalize:false});
    const geometryPointList = _element.querySelector('path').getGeometryPointList();

    if( GeometryUtils.isPointSnappedTo( pointerInLocal , geometryPointList[0] , _e.snapDistance ) ) {
    _e.vertexAtPoint = {element:_element,point:geometryPointList[0]};
    this.snapToWorkspaceAndContentCoords(_e,_e.vertexAtPoint, 'start' );
    return true;
    }

    if( GeometryUtils.isPointSnappedTo( pointerInLocal , geometryPointList[1] , _e.snapDistance ) ) {
    _e.vertexAtPoint = {element:_element,point:geometryPointList[1]};
    this.snapToWorkspaceAndContentCoords(_e,_e.vertexAtPoint, 'end' );
    return true;
    }

    if( GeometryUtils.isPointSnappedTo( pointerInLocal , {x:0,y:0} , _e.snapDistance ) ) {
    _e.vertexAtPoint = {element:_element,point:SVGUtils.createSVGPoint()};
    this.snapToWorkspaceAndContentCoords(_e,_e.vertexAtPoint, 'center' );
    return true;
    }


    const properties = _element.getStoredJsonData("jvs-object-properties");
    center = SVGUtils.createSVGPoint();
    radius = properties.radius;


    const distancePointCenter = pointerInLocal.getDistanceFromPoint( center );

    if(distancePointCenter < _e.snapDistance){
    _e.vertexAtPoint = {element:_element,point:SVGUtils.createSVGPoint(center.x,center.y)};
    this.snapToWorkspaceAndContentCoords(_e,_e.vertexAtPoint, 'center' );
    return true;
    }


    if(  Math.abs(distancePointCenter - radius) < _e.snapDistance ){
    const pointOnContour = GeometryUtils.getClosestPointToCircle( pointerInLocal , center , radius );

    _e.segmentListAtPoint.push( {element:_element, type:'radial', pointOnSegment:pointOnContour, idSegment:0, center: center, radius:radius, name:_element.nodeName} );

    this.snapToWorkspaceAndContentCoords(_e,{element:_element,point:SVGUtils.createSVGPoint(pointOnContour.x,pointOnContour.y)}, 'contour' );
    }

    }

     */

    snapToWorkspaceAndContentCoords(_e, _snapData, _pointerDescription = '') {
        _e.localX = _snapData.point.x;
        _e.localY = _snapData.point.y;
        const pointInWorkspace = _snapData.element.localToGlobal(_e.localX, _e.localY);
        _e.workspaceX = pointInWorkspace.x;
        _e.workspaceY = pointInWorkspace.y;
        activeApplication.activeDocument.workspaceToPageContentCoords(_e);
        _e.pointerDescription = _pointerDescription;

    }

}

class ElementOrigin_cmp {

    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="ElementOrigin_cmp"]');
        this.showTranslateButton = false;
        this.translateOriginHandle = this.graphicElement.querySelector('#translateOriginHandle');
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    show(_showTranslateButton) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const activeEditableElement = activePage.focusedElement;

        //if(activeEditableElement.nodeName ==='line') return;
        this.showTranslateButton = _showTranslateButton;

        let parentElementGlobalMatrix = activeEditableElement.getCTM();
        let originElementMatrix = this.graphicElement.getTransform().matrix.identity();
        this.graphicElement.getTransform().setMatrix(originElementMatrix.rotate(parentElementGlobalMatrix.getRotation()));
        originElementMatrix.e = parentElementGlobalMatrix.e;
        originElementMatrix.f = parentElementGlobalMatrix.f;
        this.graphicElement.classList.add('showed');
    };

    onMouseDown_translateOrigin(_e) {
        // const activePage = activeApplication.activeDocument.activePage;
        // activePage.removeAllInteractions();
        // activePage.removeSmartElements();
        // this.previousWorkspaceX=_e.workspaceX;
        // this.previousWorkspaceY=_e.workspaceY;
        this.createUndoRedoActions = true;
        XOS.initDragFunctions(this, _e);
        this.startPenEvent = _e; // servirà per calcolare la perpendicolare ad un segmento esistente
        //this.show();
    }

    onDragStart(_e) {
        activeApplication.workspace.removeInteractions();
        activeApplication.workspace.snapInteraction2D.createVirtualOrigin(SVGUtils.createSVGPoint(this.startPenEvent.contentX, this.startPenEvent.contentY));
        this.show();
    }

    onDrag(_e) {
        // const activePage = activeApplication.activeDocument.activePage;
        // activePage.createPenEvent( _e );
        //
        // if(KEYBOARD.shiftKeyPressed)
        // {
        // 	activePage.applySnapTo_angle( _e, gPOINTER.pointerDownEvent );
        // }

        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        //_e.customSegmentList = this.angularSegmentSnapList;// le guide
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        this.graphicElement.placeAt(_e.workspaceX, _e.workspaceY);
        // const matrix = this.graphicElement.getTransform().matrix;
        // matrix.e = _e.workspaceX;
        // matrix.f = _e.workspaceY;

        //activeDocument.translateElementList( activeApplication.workspace.selectionPreviews.children , _e.workspaceX-this.previousWorkspaceX, _e.workspaceY-this.previousWorkspaceY,  false );
        // this.previousWorkspaceX=_e.workspaceX;
        // this.previousWorkspaceY=_e.workspaceY;

        // const matrix = this.getTransform().matrix;
        // matrix.e = activePage.currentPenEvent.workspaceX;
        // matrix.f = activePage.currentPenEvent.workspaceY;
    }

    onDragEnd(_e) {
        const activePage = activeApplication.activeDocument.activePage;

        const matrix = this.graphicElement.getTransform().matrix;

        this.setElementOrigin_undable([activePage.focusedElement], matrix.e, matrix.f);
        //this.setElementOrigin_undable( [activePage.focusedElement], _e.workspaceX , _e.workspaceY);
        //activeApplication.workspace.removeInteractions();
    }

    setElementOrigin_undable(_elementList, _workspaceX, _workspaceY) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        _elementList = _elementList || activePage.selectionList;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        let undoElementList = [].concat(_elementList);
        // nello snapShot vanno aggiunti anche i figli dei gruppi
        for (let i = 0; i < _elementList.length; i++) {
            if (_elementList[i].nodeName === 'g') {
                undoElementList = undoElementList.concat(_elementList[i].getTransformableChildren());
            }
        }

        undoAction.createAttributeSnapshot(undoElementList, 'd,x,y,cx,cy,x1,y1,x2,y2,transform');
        for (let i = 0; i < _elementList.length; i++)
            _elementList[i].setOrigin(_workspaceX, _workspaceY);
        redoAction.createAttributeSnapshot(undoElementList, 'd,x,y,cx,cy,x1,y1,x2,y2,transform');

        function onExecuteEnd() {
            activeDocument.selectElementList(_elementList);
            for (let i = 0; i < _elementList.length; i++) {
                if (_elementList[i].nodeName === 'path')
                    _elementList[i].geometryPointList = null;
            }
        }

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = onExecuteEnd;

        activeDocument.onChange();
        activeApplication.workspace.update();
        activeApplication.workspace.snapInteraction2D.reset();

    };

}

class SegmentInteraction_A_cmp {
    constructor() {
        this.graphicElement = document.querySelector('#INTERACTIVE_PATH_SEGMENT_A');
    }

    show() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (!activePage.focusedPathSegmentPoint)
            return;

        this.graphicElement.classList.add('showed');

        const path = activePage.focusedPathSegmentPoint.ownerShapeElement;
        const previousSegment = activePage.focusedPathSegmentPoint.previousSegment;
        const currentSegment = activePage.focusedPathSegmentPoint;

        const pointList = this.graphicElement.getGeometryPointList();

        pointList[0].x = previousSegment.x;
        pointList[0].y = previousSegment.y;

        //console.log('currentSegment.rx',currentSegment.rx);

        pointList[1].x = currentSegment.x;
        pointList[1].y = currentSegment.y;

        pointList[1].rx = currentSegment.rx;
        pointList[1].ry = currentSegment.ry;
        pointList[1].angle = currentSegment.angle;
        pointList[1].largeArcFlag = currentSegment.largeArcFlag;
        pointList[1].sweepFlag = currentSegment.sweepFlag;
        this.graphicElement.render();

        this.graphicElement.getTransform().setMatrix(path.getCTM());

        // const pointList = this.graphicElement.getGeometryPointList();
        //
        // pointList[0].x =  previousSegment.x;
        // pointList[0].y =  previousSegment.y;
        //
        // console.log('currentSegment.rx',currentSegment.rx);
        //
        // pointList[1].x =  currentSegment.x;
        // pointList[1].y =  currentSegment.y;
        //
        // pointList[1].rx = currentSegment.rx;
        // pointList[1].ry = currentSegment.ry;
        // pointList[1].angle = currentSegment.angle;
        // pointList[1].largeArcFlag = currentSegment.largeArcFlag;
        // pointList[1].sweepFlag = currentSegment.sweepFlag;
        //
        // this.graphicElement.transformGeometryPointList( path.getTransformToElement( path.ownerSVGElement   ) );
        // //this.graphicElement.transformGeometryPointList(   path.getCTM()   );
        //
        // this.graphicElement.render();

    }

}

class SegmentInteraction_C_cmp {

    constructor() {
        this.graphicElement = document.querySelector('#INTERACTIVE_PATH_SEGMENT_C');
    }

    show() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (!activePage.focusedPathSegmentPoint)
            return;

        this.graphicElement.classList.add('showed');

        // const globalPointList = this.getGeometryPointList();
        // const lineLength = this.getDistanceFromPoint( this.previousSegmentRef );
        //this.appRef.interaction2D.lengthPropertyLabel.show( globalPointList[0] , globalPointList[1] , this.appRef.activeEditablePage.valueToUnit(lineLength) , this.appRef.path2DPanel.setLineToLength );

        const path = activePage.focusedPathSegmentPoint.ownerShapeElement;
        const previousSegment = activePage.focusedPathSegmentPoint.previousSegment;
        const currentSegment = activePage.focusedPathSegmentPoint;

        const pointList = this.graphicElement.getGeometryPointList();

        pointList[0].x = previousSegment.x;
        pointList[0].y = previousSegment.y;

        pointList[1].x = currentSegment.x;
        pointList[1].y = currentSegment.y;

        pointList[1].controlPt1.x = currentSegment.controlPt1.x;
        pointList[1].controlPt1.y = currentSegment.controlPt1.y;
        pointList[1].controlPt2.x = currentSegment.controlPt2.x;
        pointList[1].controlPt2.y = currentSegment.controlPt2.y;

        //this.graphicElement.transformGeometryPointList( path.getTransformToElement( activePage  ) );
        this.graphicElement.transformGeometryPointList(path.getCTM());
        this.graphicElement.render();

    };

}

class SegmentInteraction_L_cmp {

    constructor() {
        this.graphicElement = document.querySelector('#PATH_SEGMENT_L');
        this.path = this.graphicElement.querySelector('path');
        this.label = this.graphicElement.querySelector('.label');
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    showLabel(_labelText, _onChangeCallback) {
        const geometryPointList = this.path.getGeometryPointList();

        const pt1 = geometryPointList[0];
        const pt2 = geometryPointList[1];

        const posX = pt1.x + ((pt2.x - pt1.x) / 2);
        const posY = pt1.y + ((pt2.y - pt1.y) / 2);

        let angle = GeometryUtils.getAngleBetweenPoints(pt2, pt1) / (Math.PI / 180);
        if (angle >= 90 && angle < 270) {
            angle += 180;
            this.label.setAttribute('y', '27');
        } else {
            this.label.setAttribute('y', '-27');
        }

        this.label.setAttribute('transform', 'translate(' + posX + ' ' + posY + ') rotate(' + angle + ' 0 0)');

        this.label.textContent = _labelText;

        this.onChangeCallback = _onChangeCallback;

        this.label.style.display = 'inline';
    };

    show() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (!activePage.focusedPathSegmentPoint)
            return;

        const _segment = activePage.focusedPathSegmentPoint;

        const ownerPath = _segment.ownerShapeElement;

        // questo viene usato quando si trasla un punto il cui segmento è selezionato
        if (!_segment.previousSegment) {
            const geometryPointList = ownerPath.getGeometryPointList();
            _segment.previousSegment = geometryPointList[geometryPointList.indexOf(_segment) - 1];
        }

        const previousSegment = _segment.previousSegment;
        const currentSegment = _segment;

        //const pointList = this.path.getGeometryPointList( {normalize:false} );
        const pointList = this.path.getGeometryPointList();

        pointList[0].x = previousSegment.x;
        pointList[0].y = previousSegment.y;

        pointList[1].x = currentSegment.x;
        pointList[1].y = currentSegment.y;

        this.path.transformGeometryPointList(ownerPath.getTransformToElement(ownerPath.ownerSVGElement));
        this.path.render();

        // const length = currentSegment.getDistanceFromPoint(previousSegment);
        // this.showLabel( activeDocument.valueToUnit( length ), null );
        // this.graphicElement.classList.add('showed');

        if (activeDocument.preferences.interactionLabelVisibility) {
            const length = currentSegment.getDistanceFromPoint(previousSegment);
            this.showLabel(activeDocument.valueToUnit(length), null);
        } else {
            this.label.style.display = 'none';
        }

        this.graphicElement.classList.add('showed');

    };

    onClickOn_label(_e) {
        document.querySelector('line-to-transform-inspector').setInputPropertyFocus('lineLength');
    };
}

class SegmentInteraction_Q_cmp {

    constructor() {
        this.graphicElement = document.querySelector('#INTERACTIVE_PATH_SEGMENT_Q');
    }

    show() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (!activePage.focusedPathSegmentPoint)
            return;

        this.graphicElement.classList.add('showed');

        const path = activePage.focusedPathSegmentPoint.ownerShapeElement;
        const previousSegment = activePage.focusedPathSegmentPoint.previousSegment;
        const currentSegment = activePage.focusedPathSegmentPoint;

        const pointList = this.graphicElement.getGeometryPointList();

        pointList[0].x = previousSegment.x;
        pointList[0].y = previousSegment.y;

        pointList[1].x = currentSegment.x;
        pointList[1].y = currentSegment.y;

        pointList[1].controlPt1.x = currentSegment.controlPt1.x;
        pointList[1].controlPt1.y = currentSegment.controlPt1.y;

        this.graphicElement.transformGeometryPointList(path.getTransformToElement(activePage));
        this.graphicElement.render();

    };

}

class RotateByPivotInteraction_cmp{
    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="RotateInteraction_cmp"]');
        this.goniometro = this.graphicElement.querySelector('.goniometer');
        this.pivot = this.graphicElement.querySelector('#pivot'); // centro della rotazione
        this.centerOfRotationInContent = null;
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    onMouseDown_pivot(_e) {
        XOS.initDragFunctions(this, _e);
    };

    show() {
        this.graphicElement.classList.add('showed');
        this.update();
    };

    update() {
        const centerOfRotationInWorkspace = {
            contentX: this.centerOfRotationInContent.contentX,
            contentY: this.centerOfRotationInContent.contentY
        };
        activeApplication.activeDocument.pageContentToWorkspaceCoords(centerOfRotationInWorkspace);
        this.pivot.placeAt(centerOfRotationInWorkspace.workspaceX, centerOfRotationInWorkspace.workspaceY);
    };

    onDragStart(_e) {
        this.graphicElement.classList.add('showed');
        this.startPenEvent = this.centerOfRotationInContent;
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;
        this.centerOfRotationInContent = _e;
        this.update();
    };

    onDragEnd(_e) {
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

}

class ScaleByPivotInteraction_cmp{
    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="ScaleInteraction_cmp"]');
        // this.goniometro = this.graphicElement.querySelector('.goniometer');
        this.pivot = this.graphicElement.querySelector('#pivot'); // centro della scala
        this.centerOfScaleInContent = null;
        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);
    }

    onMouseDown_pivot(_e) {
        XOS.initDragFunctions(this, _e);
    };

    show() {
        this.graphicElement.classList.add('showed');
        this.update();
    };

    update() {
        const centerOfRotationInWorkspace = {
            contentX: this.centerOfScaleInContent.contentX,
            contentY: this.centerOfScaleInContent.contentY
        };
        activeApplication.activeDocument.pageContentToWorkspaceCoords(centerOfRotationInWorkspace);
        this.pivot.placeAt(centerOfRotationInWorkspace.workspaceX, centerOfRotationInWorkspace.workspaceY);
    };

    onDragStart(_e) {
        this.graphicElement.classList.add('showed');
        this.startPenEvent = this.centerOfScaleInContent;
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;
        this.centerOfScaleInContent = _e;
        this.update();
    };

    onDragEnd(_e) {
        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();
    };

}

class PerspectiveDeformInteraction_cmp{
    constructor() {
        this.graphicElement = document.querySelector('[data-custom-element="PerspectiveDeformInteraction_cmp"]');
        this.boundsPoints = [];
        this.originalBoundsPoints = [];
        for (let id = 0; id < 4; id++) {
            this.boundsPoints[id] = SVGUtils.createSVGPoint(0, 0);
            this.originalBoundsPoints[id] = SVGUtils.createSVGPoint(0, 0);
        }

        this.nw = this.graphicElement.querySelector('#nw');
        this.ne = this.graphicElement.querySelector('#ne');
        this.se = this.graphicElement.querySelector('#se');
        this.sw = this.graphicElement.querySelector('#sw');

        this.top_line = this.graphicElement.querySelector('#top_line');
        this.right_line = this.graphicElement.querySelector('#right_line');
        this.bottom_line = this.graphicElement.querySelector('#bottom_line');
        this.left_line = this.graphicElement.querySelector('#left_line');

        XOS.connectDomEvents(this.graphicElement.querySelectorAll('[data-event]'), this);

    }

    onMouseDown_handles(_e) {
        // const clickedHandle = _e.target;
        //
        // const activePage = activeApplication.activeDocument.activePage;
        //
        // const handlePosition = clickedHandle.parentElement.getTransform().matrix.getTranslation();
        // gPOINTER.pointerDownEvent.windowX = handlePosition.x+activePage.workspaceBounding.x;
        // gPOINTER.pointerDownEvent.windowY = handlePosition.y+activePage.workspaceBounding.y;
        // activePage.windowToWorkspace(gPOINTER.pointerDownEvent);

        const clickedHandle = _e.target;

        const handlePosition = clickedHandle.parentElement.getScreenCTM().getTranslation();
        const virtualEvent = {
            pageX: handlePosition.x,
            pageY: handlePosition.y
        };
        activeApplication.activeDocument.pointerEventToCoords(virtualEvent);

        if (clickedHandle.classList.contains('resize')) {
            const clickedHandleName = clickedHandle.parentElement.getAttribute('id');

            switch (clickedHandleName) {
            case 'nw':
                this.idActiveHandle = 0;
                break;
            case 'ne':
                this.idActiveHandle = 1;
                break;

            case 'se':
                this.idActiveHandle = 2;
                break;

            case 'sw':
                this.idActiveHandle = 3;
                break;
            }
        }

        XOS.initDragFunctions(this, _e);

    };

    show() {
        const activePage = activeApplication.activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return;

        this.selectionBBox = GeometryUtils.getElementListGlobalBBox(activePage.selectionList);

        this.boundsPoints[0].set(this.selectionBBox.min.x, this.selectionBBox.min.y);
        this.boundsPoints[1].set(this.selectionBBox.max.x, this.selectionBBox.min.y);
        this.boundsPoints[2].set(this.selectionBBox.max.x, this.selectionBBox.max.y);
        this.boundsPoints[3].set(this.selectionBBox.min.x, this.selectionBBox.max.y);

        this.originalBoundsPoints[0].set(this.selectionBBox.min.x, this.selectionBBox.min.y);
        this.originalBoundsPoints[1].set(this.selectionBBox.max.x, this.selectionBBox.min.y);
        this.originalBoundsPoints[2].set(this.selectionBBox.max.x, this.selectionBBox.max.y);
        this.originalBoundsPoints[3].set(this.selectionBBox.min.x, this.selectionBBox.max.y);

        this.initTransform();

        this.graphicElement.classList.add('showed');
        this.update();
    };

    initTransform() {
        this.transformableInteractivePathList = [];
        const interactiveElementList = activeApplication.workspace.selectionPreviews.querySelectorAll('g,path,line');
        let interactiveElement,
        element,
        globalPointList;
        const max = interactiveElementList.length;
        for (let i = 0; i < max; i++) {
            interactiveElement = interactiveElementList[i];
            if (interactiveElement.elementRef && ((interactiveElement.elementRef.nodeName === 'path') || (interactiveElement.elementRef.nodeName === 'line'))) {
                element = interactiveElement.elementRef;
                globalPointList = element.cloneGeometryPointList(); // clono e trasformo in globale i punti originali che serviranno alla path interattiva
                element.transformGeometryPointList(element.getCTM(), globalPointList);
                interactiveElement.originalGlobalPointList = globalPointList;
                this.transformableInteractivePathList.push(interactiveElement);
            }
            interactiveElement.getTransform().matrix.identity();
        }

        this.deformInteractivePathList();
    };

    update() {
        let x0,
        y0,
        x1,
        y1,
        x2,
        y2,
        x3,
        y3;

        x0 = this.boundsPoints[0].x;
        y0 = this.boundsPoints[0].y;
        x1 = this.boundsPoints[1].x;
        y1 = this.boundsPoints[1].y;
        x2 = this.boundsPoints[2].x;
        y2 = this.boundsPoints[2].y;
        x3 = this.boundsPoints[3].x;
        y3 = this.boundsPoints[3].y;

        // contour lines
        this.top_line.updateGeometry(x0, y0, x1, y1);
        this.right_line.updateGeometry(x1, y1, x2, y2);
        this.bottom_line.updateGeometry(x2, y2, x3, y3);
        this.left_line.updateGeometry(x3, y3, x0, y0);

        // handles
        this.nw.placeAt(x0, y0);
        this.ne.placeAt(x1, y1);
        this.se.placeAt(x2, y2);
        this.sw.placeAt(x3, y3);
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        _e.startPenEvent = this.startPenEvent; // servirà per calcolare la perpendicolare ad un segmento esistente
        activeDocument.pointerEventToCoords(_e, true);
        activeDocument.elementFromPointerEvent(_e, true);
        activeDocument.applySnap(_e);
        // activeApplication.workspace.snapInteraction2D.lastEvent = _e;

        this.boundsPoints[this.idActiveHandle].x = _e.workspaceX;
        this.boundsPoints[this.idActiveHandle].y = _e.workspaceY;
        this.update();
        if (this.canBeDeformed())
            this.deformInteractivePathList();
    };

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const selectedElementList = activePage.selectionList;

        undoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        this.swapInteractivePathPointListToElementPointList();

        redoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };

        activeDocument.onChange();
        activeApplication.workspace.snapInteraction2D.reset();
        //activeApplication.workspace.update();
    };

    swapInteractivePathPointListToElementPointList() {
        var ip,
        maxp,
        point,
        interactivePoint,
        element,
        interactivePath,
        interactiveGeometryPointList,
        elementGeometryPointList,
        matrix;
        for (var i = 0; i < this.transformableInteractivePathList.length; i++) {
            interactivePath = this.transformableInteractivePathList[i];
            element = interactivePath.elementRef;
            matrix = element.getCTM().inverse().multiply(interactivePath.getCTM());
            // interactivePath.transformGeometryPointList( interactivePath.getTransformToElement( element ) );

            // porto i punti delle previews in locale alle path originali
            interactivePath.transformGeometryPointList(matrix);
            interactiveGeometryPointList = interactivePath.getGeometryPointList();
            elementGeometryPointList = element.getGeometryPointList();
            maxp = interactiveGeometryPointList.length;

            for (ip = 0; ip < maxp; ip++) {
                interactivePoint = interactiveGeometryPointList[ip];
                point = elementGeometryPointList[ip];

                if (interactivePoint.type !== 'Z') {
                    point.x = interactivePoint.x;
                    point.y = interactivePoint.y;
                }

                if (point.type === 'Q') {
                    point.controlPt1.x = interactivePoint.controlPt1.x;
                    point.controlPt1.y = interactivePoint.controlPt1.y;
                } else if (point.type === 'C') {
                    point.controlPt1.x = interactivePoint.controlPt1.x;
                    point.controlPt1.y = interactivePoint.controlPt1.y;
                    point.controlPt2.x = interactivePoint.controlPt2.x;
                    point.controlPt2.y = interactivePoint.controlPt2.y;
                }

            }

            element.render();
        }

        this.deformInteractivePathList(); // riporto i punti delle preview alla deformazione

    };

    deformInteractivePathList() {
        for (var i = 0; i < this.transformableInteractivePathList.length; i++) {
            this.deformInteractivePath(this.transformableInteractivePathList[i]);
        }
    };

    // If angle is outside of range 0-180, it is unallowed.
    // The angle means inner angle of every corner.

    canBeDeformed(p) {
        // isPermissible uses this:
        function angle(c, b, a) {
            var ab = {
                x: b.x - a.x,
                y: b.y - a.y
            };
            var cb = {
                x: b.x - c.x,
                y: b.y - c.y
            };
            var dot = (ab.x * cb.x + ab.y * cb.y);
            var cross = (ab.x * cb.y - ab.y * cb.x);
            var alpha = Math.atan2(cross, dot);
            return alpha * 180 / Math.PI;
        }

        var p0 = this.boundsPoints[0];
        var p1 = this.boundsPoints[1];
        var p2 = this.boundsPoints[2];
        var p3 = this.boundsPoints[3];
        var a0 = angle(p3, p0, p1);
        var a1 = angle(p0, p1, p2);
        var a2 = angle(p1, p2, p3);
        var a3 = angle(p2, p3, p0);
        if (!(a0 > 0 && a0 < 180) || !(a1 > 0 && a1 < 180) || !(a2 > 0 && a2 < 180) || !(a3 > 0 && a3 < 180))
            return false;
        else
            return true;
    };

    deformInteractivePath(interactivePath) {
        var interactiveGeometryPointList = interactivePath.getGeometryPointList();
        var originalGlobalPointList = interactivePath.originalGlobalPointList;

        var point,
        globalPoint,
        deformedPoint;

        for (var i = 0; i < interactiveGeometryPointList.length; i++) {
            point = interactiveGeometryPointList[i];
            globalPoint = originalGlobalPointList[i];

            if (point.type !== 'Z') {
                deformedPoint = this.deformPoint(globalPoint.x, globalPoint.y, this.originalBoundsPoints, this.boundsPoints);
                point.x = deformedPoint.x;
                point.y = deformedPoint.y;
            }

            if (point.type === 'Q') {
                deformedPoint = this.deformPoint(globalPoint.controlPt1.x, globalPoint.controlPt1.y, this.originalBoundsPoints, this.boundsPoints);
                point.controlPt1.x = deformedPoint.x;
                point.controlPt1.y = deformedPoint.y;
            } else if (point.type === 'C') {
                deformedPoint = this.deformPoint(globalPoint.controlPt1.x, globalPoint.controlPt1.y, this.originalBoundsPoints, this.boundsPoints);
                point.controlPt1.x = deformedPoint.x;
                point.controlPt1.y = deformedPoint.y;

                deformedPoint = this.deformPoint(globalPoint.controlPt2.x, globalPoint.controlPt2.y, this.originalBoundsPoints, this.boundsPoints);
                point.controlPt2.x = deformedPoint.x;
                point.controlPt2.y = deformedPoint.y;
            }

        }

        interactivePath.renderRequest();
    };

    deformPoint(xI, yI, source, destination) {

        var ADDING = 0.001, // to avoid dividing by zero
        xA = source[0].x,
        yA = source[0].y,

        xC = source[2].x,
        yC = source[2].y,

        xAu = destination[0].x,
        yAu = destination[0].y,

        xBu = destination[1].x,
        yBu = destination[1].y,

        xCu = destination[2].x,
        yCu = destination[2].y,

        xDu = destination[3].x,
        yDu = destination[3].y;

        // Calcultations
        // if points are the same, have to add a ADDING to avoid dividing by zero
        if (xBu === xCu)
            xCu += ADDING;
        if (xAu === xDu)
            xDu += ADDING;
        if (xAu === xBu)
            xBu += ADDING;
        if (xDu === xCu)
            xCu += ADDING;
        var kBC = (yBu - yCu) / (xBu - xCu),
        kAD = (yAu - yDu) / (xAu - xDu),
        kAB = (yAu - yBu) / (xAu - xBu),
        kDC = (yDu - yCu) / (xDu - xCu);

        if (kBC === kAD)
            kAD += ADDING;
        var xE = (kBC * xBu - kAD * xAu + yAu - yBu) / (kBC - kAD),
        yE = kBC * (xE - xBu) + yBu;

        if (kAB === kDC)
            kDC += ADDING;
        var xF = (kAB * xBu - kDC * xCu + yCu - yBu) / (kAB - kDC),
        yF = kAB * (xF - xBu) + yBu;

        if (xE === xF)
            xF += ADDING;
        var kEF = (yE - yF) / (xE - xF);

        if (kEF === kAB)
            kAB += ADDING;
        var xG = (kEF * xDu - kAB * xAu + yAu - yDu) / (kEF - kAB),
        yG = kEF * (xG - xDu) + yDu;

        if (kEF === kBC)
            kBC += ADDING;
        var xH = (kEF * xDu - kBC * xBu + yBu - yDu) / (kEF - kBC),
        yH = kEF * (xH - xDu) + yDu;

        var rG = (yC - yI) / (yC - yA),
        rH = (xI - xA) / (xC - xA),
        xJ = (xG - xDu) * rG + xDu,
        yJ = (yG - yDu) * rG + yDu,
        xK = (xH - xDu) * rH + xDu,
        yK = (yH - yDu) * rH + yDu;

        if (xF === xJ)
            xJ += ADDING;
        if (xE === xK)
            xK += ADDING;
        var kJF = (yF - yJ) / (xF - xJ),
        kKE = (yE - yK) / (xE - xK);

        if (kJF === kKE)
            kKE += ADDING;
        var xIu = (kJF * xF - kKE * xE + yE - yF) / (kJF - kKE),
        yIu = kJF * (xIu - xJ) + yJ;

        return {
            x: xIu,
            y: yIu
        };

    }

}

class GradientInteraction_cmp {

    constructor() {

        this.graphicElement = document.querySelector('[data-custom-element="GradientInteraction_cmp"]');

        this.editableGradient = null;
        this.stopColorsContainer = this.graphicElement.querySelector('.stop-colors');
        this.stopColorPointTemplate = this.stopColorsContainer.querySelector('#STOP_COLOR_POINT_TEMPLATE');
        this.stopColorPointTemplate.removeAttribute('id');
        this.stopColorPointTemplate.remove();

        this.setGradientPointLocationTool = new SetGradientPointLocation2D_tool();
        this.setGradientStopColorLocationTool = new SetGradientStopColorLocation2D_tool();

        XOS.connectEvent("mousedown", this.graphicElement, this.onMouseDown, this);
        XOS.connectEvent("mouseup", this.graphicElement, this.onMouseUp, this);

    }

    show() {
        this.graphicElement.classList.add('showed');
        this.update();
        //PANELS['color-picker'].setOnChangeEvents( null,null,null); // resetto gli eventi del colorPicker precedenti

        // const colorPicker = PANELS['global-color-picker'];
        // colorPicker.set( colorValue ,alpha , onChangeEnd , onChange, onChangeStart);
        // colorPicker.activateBy( editableColorView, 'add');
    };

    update() {

        if (!this.graphicElement.classList.contains('showed'))
            return;

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const activeGraphicSide = activeDocument.fillAndStrokeManager.focusedGraphicSideName;

        if (activeGraphicSide === 'fill') {
            this.editableGradient = activeDocument.fillAndStrokeManager.fillGradient;
        } else {
            this.editableGradient = activeDocument.fillAndStrokeManager.strokeGradient;
        }

        //console.log('this.editableGradient',this.editableGradient);


        const gradientType = this.editableGradient.nodeName;
        let gradientUnits = this.editableGradient.getAttribute('gradientUnits') || 'objectBoundingBox';
        let r,
        x1,
        y1,
        x2,
        y2;
        this.globalPointA = null;
        this.globalPointB = null;
        this.globalPointC = null;

        const editableElement = activePage.selectionList[0];

        if (gradientType === 'linearGradient') {
            if (!this.editableGradient.hasAttribute('x1')) {
                this.editableGradient.initDefaultPoints();
                gradientUnits = 'objectBoundingBox';
            }

        } else {

            if (!this.editableGradient.hasAttribute('cx')) {
                this.editableGradient.initDefaultPoints();
                gradientUnits = 'objectBoundingBox';
            }
        }

        if (gradientUnits === 'objectBoundingBox') {
            const bbox = editableElement.getBBox();

            if (gradientType === 'linearGradient') {
                x1 = parseFloat(this.editableGradient.getAttribute('x1'));
                y1 = parseFloat(this.editableGradient.getAttribute('y1'));
                x2 = parseFloat(this.editableGradient.getAttribute('x2'));
                y2 = parseFloat(this.editableGradient.getAttribute('y2'));

                x1 = bbox.x + (x1 * bbox.width);
                y1 = bbox.y + (y1 * bbox.height);
                x2 = bbox.x + (x2 * bbox.width);
                y2 = bbox.y + (y2 * bbox.height);

            } else {
                x1 = parseFloat(this.editableGradient.getAttribute('cx'));
                y1 = parseFloat(this.editableGradient.getAttribute('cy'));
                r = parseFloat(this.editableGradient.getAttribute('r'));

                x1 = bbox.x + (x1 * bbox.width);
                y1 = bbox.y + (y1 * bbox.height);
                r = (r * bbox.width);
                x2 = x1 + r;
                y2 = y1;
                //var fx,fy;
                // if(this.editableGradient.hasAttribute('fx')) fx = this.editableGradient.getAttribute('fx');
                // if(this.editableGradient.hasAttribute('fy')) fy = this.editableGradient.getAttribute('fy');
            }

        } else {

            if (gradientType === 'linearGradient') {
                x1 = parseFloat(this.editableGradient.getAttribute('x1'));
                y1 = parseFloat(this.editableGradient.getAttribute('y1'));
                x2 = parseFloat(this.editableGradient.getAttribute('x2'));
                y2 = parseFloat(this.editableGradient.getAttribute('y2'));
            } else {
                x1 = parseFloat(this.editableGradient.getAttribute('cx'));
                y1 = parseFloat(this.editableGradient.getAttribute('cy'));
                r = parseFloat(this.editableGradient.getAttribute('r'));
                x2 = x1 + r;
                y2 = y1;
                //var fx,fy;
                // if(this.editableGradient.hasAttribute('fx')) fx = this.editableGradient.getAttribute('fx');
                // if(this.editableGradient.hasAttribute('fy')) fy = this.editableGradient.getAttribute('fy');
            }
        }

        const matrix = this.editableGradient.getTransform().matrix;
        let ptA = SVGUtils.createSVGPoint(x1, y1).matrixTransform(matrix);
        let ptB = SVGUtils.createSVGPoint(x2, y2).matrixTransform(matrix);

        this.globalPointA = editableElement.localToGlobal(ptA.x, ptA.y);
        this.globalPointB = editableElement.localToGlobal(ptB.x, ptB.y);

        const lines = this.graphicElement.querySelectorAll('line');
        lines[0].updateGeometry(this.globalPointA.x, this.globalPointA.y, this.globalPointB.x, this.globalPointB.y);
        lines[1].updateGeometry(this.globalPointA.x, this.globalPointA.y, this.globalPointB.x, this.globalPointB.y);

        this.createEditableStopColorViews();
    };

    createEditableStopColorViews() {
        let x,
        y,
        stopColor,
        stopColorView;

        this.editableGradient.sortStopColors();
        this.stopColorsContainer.removeChildren();
        const max = this.editableGradient.children.length;
        for (let i = 0; i < max; i++) {
            stopColor = this.editableGradient.children[i];
            stopColor.stylePropertiesToAttributes();
            stopColorView = this.stopColorPointTemplate.cloneNode(true);
            stopColorView.stopColorRef = stopColor;
            stopColorView.setAttribute('fill', stopColor.getAttribute('stop-color'));
            this.stopColorsContainer.appendChild(stopColorView);
            x = this.globalPointA.x + ((this.globalPointB.x - this.globalPointA.x) * stopColor.offset.baseVal);
            y = this.globalPointA.y + ((this.globalPointB.y - this.globalPointA.y) * stopColor.offset.baseVal);
            //stopColorView.placeAt(x, y);

            stopColorView.setAttribute('cx', x);
            stopColorView.setAttribute('cy', y);
        }
    };

    editGradientColor(editableColorView) {
        const editableGradientColor = editableColorView.stopColorRef;
        const id = Array.from(editableGradientColor.parentElement.children).indexOf(editableGradientColor);

        const colorValue = editableGradientColor.getAttribute('stop-color');
        const alpha = editableGradientColor.getAttribute('stop-opacity') || 1;

        const colorPicker = PANELS['global-color-picker'];
        colorPicker.set(colorValue, alpha, onChangeEnd, onChange, onChangeStart);
        colorPicker.activateBy(editableColorView, 'add');

        // const colorPicker = PANELS['global-color-picker'];
        // colorPicker.set( colorValue ,alpha , onChangeEnd , onChange, onChangeStart);
        // colorPicker.activateBy( editableColorView, 'add');


        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const self = this;
        let undoAction,
        redoAction;

        function onChangeStart(_colorPicker) {
            undoAction = new UndoRedoAction();
            redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);
            undoAction.createAttributeSnapshot([editableGradientColor], 'stop-color,stop-opacity');
        }

        function onChange(_colorPicker) {
            const hexColorValue = _colorPicker.hex;
            activeDocument.setAttributeElementList([editableGradientColor], {
                'stop-color': hexColorValue,
                'stop-opacity': _colorPicker.alpha
            });
            activeDocument.setAttributeElementList([editableGradientColor], {
                'stop-color': hexColorValue,
                'stop-opacity': _colorPicker.alpha
            });
        }

        function onChangeEnd(_colorPicker) {
            redoAction.createAttributeSnapshot([editableGradientColor], 'stop-color,stop-opacity');

            //activeDocument.showSelectionProperties();
            self.update();

            const selectionList = activePage.selectionList;
            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
                // activePage.updateInteraction();
            };

            undoAction = redoAction = null;
            //self.gradientColorContainer.querySelector('g[fill="'+editableGradientColor.getAttribute('stop-color')+'"]' ).selectElement();
        }

        //colorPicker.setOnChangeEvents( onChangeEnd , onChange, onChangeStart );
    };

    onMouseDown(_e) {

        if (_e.target.parentElement.classList.contains('stop-colors')) {
            //console.log('_e.target.stopColorRef parentElement', _e.target.stopColorRef.parentElement);
            //console.log('_e.target.stopColorRef nextElementSibling', _e.target.stopColorRef.nextElementSibling);
            if (!_e.target.stopColorRef.nextElementSibling) {
                this.setGradientPointLocationTool.setEditablePointName('pointB');
                XOS.initDragFunctions(this.setGradientPointLocationTool, _e);
                //gPOINTER.delegate = this.setGradientPointLocationTool;
            } else if (!_e.target.stopColorRef.previousElementSibling) {
                this.setGradientPointLocationTool.setEditablePointName('pointA');
                XOS.initDragFunctions(this.setGradientPointLocationTool, _e);
                //gPOINTER.delegate = this.setGradientPointLocationTool;
            } else {
                this.setGradientStopColorLocationTool.setEditableStopColor(_e.target.stopColorRef);
                XOS.initDragFunctions(this.setGradientStopColorLocationTool, _e);
                //gPOINTER.delegate = this.setGradientStopColorLocationTool;
            }
        } else {
            this.setGradientPointLocationTool.setEditablePointName(_e.target.getAttribute('id'));
            //gPOINTER.delegate = this.setGradientPointLocationTool;
            XOS.initDragFunctions(this.setGradientPointLocationTool, _e);
        }

    };

    onMouseUp(_e) {
        if (_e.target.parentElement.classList.contains('stop-colors')) {
            //this.editGradientColor(_e.target.stopColorRef);
            this.editGradientColor(_e.target);

            // const self = this;
            //
            // function onChangeEnd( _colorPicker )
            // {
            // 	var hexColorValue = _colorPicker.getColorAsHex();
            // 	_e.target.setAttribute('fill',hexColorValue);
            // 	console.log('onChangeEnd hexColorValue' , hexColorValue );
            // 	self.appRef.activePage.setAttributeElementList_undable([_e.target.stopColorRef],{'stop-color':hexColorValue,'stop-opacity':_colorPicker.alpha }, false );
            // 	self.appRef.fillStroke2DPanel.gradientEditor2DPanel.update();
            // }
            //
            // this.appRef.colorPickerPanel.setOnChangeEvents( onChangeEnd );
            // this.appRef.contextPanels.showContextPanel('COLOR_PICKER_CONTEXT_PANEL');
        } else if (_e.target.nodeName === 'line') {

            const activeDocument = activeApplication.activeDocument;
            const activePage = activeDocument.activePage;
            activeDocument.pointerEventToCoords(_e);

            // activePage.adjustEventCoords(gPOINTER.pointerDownEvent);

            let offset;

            // const pointInDocumentSpace = {x:gPOINTER.pointerDownEvent.workspaceX,y:gPOINTER.pointerDownEvent.workspaceY};
            const pointInDocumentSpace = {
                x: _e.workspaceX,
                y: _e.workspaceY
            };

            if (Math.abs(this.globalPointB.x - this.globalPointA.x) > Math.abs(this.globalPointB.y - this.globalPointA.y)) {
                offset = (pointInDocumentSpace.x - this.globalPointA.x) / (this.globalPointB.x - this.globalPointA.x);
            } else {
                offset = (pointInDocumentSpace.y - this.globalPointA.y) / (this.globalPointB.y - this.globalPointA.y);
            }

            const newStopColorNode = this.editableGradient.insertNewStopColor(offset);

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            redoAction.createDomNodeSnapshot([newStopColorNode], 'insert');
            undoAction.createDomNodeSnapshot([newStopColorNode], 'delete');

            const selectionList = activePage.selectionList;
            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
                // activePage.updateInteraction();
            };

            activeDocument.onChange();

            this.update();
            // activePage.updateDrawingProperties();
        }

    };

}

// tools


class SetGradientPointLocation2D_tool {

    constructor() {}

    setEditablePointName(_editablePointName) {
        this.editablePointName = _editablePointName;
        //console.log('this.editablePointName', this.editablePointName );
    };

    // se si dragga un colore
    onDragStart(_e) {
        const editableGradient = activeApplication.workspace.gradientInteraction.editableGradient;
        if (editableGradient.nodeName === 'linearGradient') {
            this.stored_x1 = editableGradient.getAttribute('x1');
            this.stored_y1 = editableGradient.getAttribute('y1');
            this.stored_x2 = editableGradient.getAttribute('x2');
            this.stored_y2 = editableGradient.getAttribute('y2');
        } else {
            this.stored_cx = editableGradient.getAttribute('cx');
            this.stored_cy = editableGradient.getAttribute('cy');
            this.stored_r = editableGradient.getAttribute('r');
        }
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const editableElement = activePage.selectionList[0];
        const editableGradient = activeApplication.workspace.gradientInteraction.editableGradient;

        //activePage.createPenEvent( _e );
        //activePage.adjustEventCoords(_e  );
        activeDocument.pointerEventToCoords(_e);

        let localPoint = editableElement.globalToLocal(_e.workspaceX, _e.workspaceY);

        const matrix = editableGradient.getTransform().matrix.inverse();
        localPoint = localPoint.matrixTransform(matrix);

        const gradientUnits = editableGradient.getAttribute('gradientUnits') || 'objectBoundingBox';

        if (gradientUnits === 'objectBoundingBox') {
            const bbox = editableElement.getBBox();
            localPoint.x = (localPoint.x - bbox.x) / bbox.width;
            localPoint.y = (localPoint.y - bbox.y) / bbox.height;
        }

        if (editableGradient.nodeName === 'linearGradient') {
            if (this.editablePointName === 'pointA') {
                editableGradient.setAttribute('x1', localPoint.x);
                editableGradient.setAttribute('y1', localPoint.y);
            } else if (this.editablePointName === 'pointB') {
                editableGradient.setAttribute('x2', localPoint.x);
                editableGradient.setAttribute('y2', localPoint.y);
            }
        } else {

            if (this.editablePointName === 'pointA') {
                editableGradient.setAttribute('cx', localPoint.x);
                editableGradient.setAttribute('cy', localPoint.y);
            } else if (this.editablePointName === 'pointB') {

                const cx = parseFloat(editableGradient.getAttribute('cx'));
                const r = localPoint.x - cx;
                //if(r<1) r = 1;
                if (r > 0)
                    editableGradient.setAttribute('r', r);
                // var cx = parseFloat(editableGradient.getAttribute('cx'));
                // var cy = parseFloat(editableGradient.getAttribute('cy'));
                // var centerPointInLocal = SVGUtils.createSVGPoint( cx,cy );
                // var r = centerPointInLocal.getDistanceFromPoint(localPoint);
                // editableGradient.setAttribute('r',r );
            }
        }

        activeApplication.workspace.gradientInteraction.update();
    };

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const editableGradient = activeApplication.workspace.gradientInteraction.editableGradient;
        let undoRedoActions = null;

        if (editableGradient.nodeName === 'linearGradient') {
            if (this.editablePointName === 'pointA') {
                const new_x1 = editableGradient.getAttribute('x1');
                const new_y1 = editableGradient.getAttribute('y1');
                editableGradient.setAttribute('x1', this.stored_x1);
                editableGradient.setAttribute('y1', this.stored_y1);
                undoRedoActions = activeDocument.setAttributeElementList_undable([editableGradient], {
                    x1: new_x1,
                    y1: new_y1
                }, false);
            } else if (this.editablePointName === 'pointB') {
                const new_x2 = editableGradient.getAttribute('x2');
                const new_y2 = editableGradient.getAttribute('y2');
                editableGradient.setAttribute('x2', this.stored_x2);
                editableGradient.setAttribute('y2', this.stored_y2);
                undoRedoActions = activeDocument.setAttributeElementList_undable([editableGradient], {
                    x2: new_x2,
                    y2: new_y2
                }, false);
            }

        } else {
            if (this.editablePointName === 'pointA') {
                const new_cx = editableGradient.getAttribute('cx');
                const new_cy = editableGradient.getAttribute('cy');
                editableGradient.setAttribute('cx', this.stored_cx);
                editableGradient.setAttribute('cy', this.stored_cy);
                undoRedoActions = activeDocument.setAttributeElementList_undable([editableGradient], {
                    cx: new_cx,
                    cy: new_cy
                }, false);
            } else if (this.editablePointName === 'pointB') {
                const new_r = editableGradient.getAttribute('r');
                editableGradient.setAttribute('r', this.stored_r);
                undoRedoActions = activeDocument.setAttributeElementList_undable([editableGradient], {
                    r: new_r
                }, false);
            }
        }

        if (undoRedoActions) {
            const selectionList = activePage.selectionList;
            undoRedoActions.undoAction.onExecuteEnd = undoRedoActions.redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(selectionList);
                //activePage.updateInteraction();
            };
        }

        activeDocument.showSelectionProperties();
        activeDocument.onChange();

    };

}

class SetGradientStopColorLocation2D_tool {

    constructor() {}

    setEditableStopColor(_editableStopColor) {
        this.editableStopColor = _editableStopColor;
    };

    // se si dragga un colore
    onDragStart(_e) {
        this.storedOffsetValue = this.editableStopColor.getAttribute('offset');
    };

    onDrag(_e) {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const editableGradient = activeApplication.workspace.gradientInteraction.editableGradient;

        const globalPointA = activeApplication.workspace.gradientInteraction.globalPointA;
        const globalPointB = activeApplication.workspace.gradientInteraction.globalPointB;

        activeDocument.pointerEventToCoords(_e);

        const pointInDocumentSpace = {
            x: _e.workspaceX,
            y: _e.workspaceY
        };

        let x,
        y,
        minX,
        minY,
        maxX,
        maxY,
        colorOffset;

        minX = Math.min(globalPointB.x, globalPointA.x);
        maxX = Math.max(globalPointB.x, globalPointA.x);
        minY = Math.min(globalPointB.y, globalPointA.y);
        maxY = Math.max(globalPointB.y, globalPointA.y);

        if (pointInDocumentSpace.x < minX) {
            pointInDocumentSpace.x = minX;
        } else if (pointInDocumentSpace.x > maxX) {
            pointInDocumentSpace.x = maxX;
        }

        if (pointInDocumentSpace.y < minY) {
            pointInDocumentSpace.y = minY;
        } else if (pointInDocumentSpace.y > maxY) {
            pointInDocumentSpace.y = maxY;
        }

        if (Math.abs(globalPointB.x - globalPointA.x) > Math.abs(globalPointB.y - globalPointA.y)) {
            x = pointInDocumentSpace.x;
            colorOffset = (pointInDocumentSpace.x - globalPointA.x) / (globalPointB.x - globalPointA.x);
            y = globalPointA.y + ((globalPointB.y - globalPointA.y) * colorOffset);
        } else {
            y = pointInDocumentSpace.y;
            colorOffset = (pointInDocumentSpace.y - globalPointA.y) / (globalPointB.y - globalPointA.y);
            x = globalPointA.x + ((globalPointB.x - globalPointA.x) * colorOffset);
        }

        this.editableStopColor.setAttribute('offset', String(colorOffset));
        editableGradient.sortStopColors();

        activeApplication.workspace.gradientInteraction.update();

    };

    onDragEnd(_e) {
        const activeDocument = activeApplication.activeDocument;

        activeDocument.showSelectionProperties();

        activeDocument.onChange();
    };
}

class EditingView_cmp extends HTMLElement {

    constructor() {
        super();
        this.horizontalRuler = this.querySelector('page-ruler.horizontal');
        this.verticalRuler = this.querySelector('page-ruler.vertical');
        this.gridPattern = this.querySelector('#grid-pattern');
        this.gridPattern.gridImage = this.gridPattern.querySelector('image');
        this.canvasUtils = document.createElement('canvas');
    }

    onResize() {
        this.horizontalRuler.onResize();
        this.verticalRuler.onResize();
    }

    update() {
        if (activeApplication.activeDocument.preferences.rulersVisibility) {
            this.classList.remove('hide-ruler');
        } else {
            this.classList.add('hide-ruler');
        }

        if (activeApplication.activeDocument.preferences.gridVisibility) {
            this.classList.remove('hide-grid');
        } else {
            this.classList.add('hide-grid');
        }
        activeApplication.workspace.updateWorkspaceBounding();
        this.onResize();
        this.redrawRulersAndGrid();
    }

    redrawRulersAndGrid() {
        activeApplication.workspace.updateOrigin();
        if (!activeApplication.activeDocument.preferences.rulersVisibility)
            return; // senza righelli niente griglia
        const rulerInfo = this.redrawRulers();
        if (activeApplication.activeDocument.preferences.gridVisibility)
            this.redrawGrid(rulerInfo.horizontalRulerInfo.markersDistance, rulerInfo.verticalRulerInfo.markersDistance, rulerInfo.horizontalRulerInfo.origin, rulerInfo.verticalRulerInfo.origin, rulerInfo.horizontalRulerInfo.divisors);
    };

    redrawRulers() {
        const activeDocument = activeApplication.activeDocument;
        const preferences = activeDocument.preferences;
        const activePage = activeDocument.activePage;
        const unitValue = preferences.unitValue;
        const origin_x = preferences.origin.x;
        const origin_y = preferences.origin.y;
        const fixedDecimals = preferences.fixedDecimals;

        const mat = activePage.content.getTransform().matrix;

        let _contentScale = activePage.content.currentScale || 1;
        const _originX = mat.e + origin_x * _contentScale;
        const _originY = mat.f + origin_y * _contentScale;

        _contentScale *= (1 / preferences.drawingScale);

        const horizontalRulerInfo = this.horizontalRuler.drawRuler(_originX, 1 / unitValue, _contentScale, fixedDecimals, preferences.gridStep);
        const verticalRulerInfo = this.verticalRuler.drawRuler(_originY, 1 / unitValue, _contentScale, fixedDecimals, preferences.gridStep);

        return {
            horizontalRulerInfo: horizontalRulerInfo,
            verticalRulerInfo: verticalRulerInfo
        };

    };

    redrawGrid(_width, _height, _originX, _originY, _divisors) {
        console.log('redrawGrid');
        // while(_width>400) {_width/=5;}
        while (_width > 400) {
            _width /= _divisors;
        }

        _height = _width;

        const canvas = this.canvasUtils;
        canvas.width = _width;
        canvas.height = _height;
        const ctx = canvas.getContext("2d");
        ctx.lineWidth = .5;
        ctx.strokeStyle = '#d4d4d4';

        ctx.beginPath();
        ctx.rect(.5, .5, (~~_width) - .5, (~~_height) - .5);
        ctx.stroke();

        const divisorSizeX = _width / _divisors;
        const divisorSizeY = _height / _divisors;
        let snappedDivisorPosition;

        for (let idDivisor = 1; idDivisor < _divisors; idDivisor++) {
            snappedDivisorPosition = (~~(divisorSizeX * idDivisor)) + .5;
            ctx.moveTo(snappedDivisorPosition, 1);
            ctx.lineTo(snappedDivisorPosition, _height - 1);
            snappedDivisorPosition = (~~(divisorSizeY * idDivisor)) + .5;
            ctx.moveTo(1, snappedDivisorPosition);
            ctx.lineTo(_width - 1, snappedDivisorPosition);
        }

        ctx.stroke();

        this.gridPattern.setAttribute('width', _width);
        this.gridPattern.setAttribute('height', _height);
        this.gridPattern.gridImage.setAttribute('width', _width);
        this.gridPattern.gridImage.setAttribute('height', _height);
        this.gridPattern.gridImage.setAttributeNS(SVGElement.XLINK_NS, 'href', canvas.toDataURL("image/png"));
        this.gridPattern.setAttribute('patternTransform', 'matrix(1 0 0 1 ' + _originX + ' ' + _originY + ')');
    };

}
customElements.define("editing-view", EditingView_cmp);

class WorkSpace_cmp extends HTMLElement {

    constructor() {
        super();
        this.pageBackground = this.querySelector('.page-background');
        this.bounding = {};
        this.updateWorkspaceBounding();

        //Gestione scrool Wheel
        //XOS.connectEvent('wheel' ,  this , this.onMouseWheel , this  );
        // const self = this;
        // this.addEventListener("wheel", function (_e) {
        //     self.onMouseWheel(_e)
        // }, {
        //     passive: true
        // });

        XOS.connectEvent("dragstart", this, this.onDragStart, this);
        XOS.connectEvent("dragover", this, this.onDragOver, this);
        XOS.connectEvent("drop", this, this.onDropOver, this);
    }

    onDomReady() {
        this.interactionContainer = this.querySelector('#INTERACTION');
        this.originXY = this.interactionContainer.querySelector("#ORIGIN_XY");

        this.pointerTip = this.interactionContainer.querySelector('#POINTER_TIP');
        this.selectionPreviews = this.querySelector('#SELECTION_PREVIEWS');
        this.bboxInteraction2D = new BBoxInteraction_cmp();
        this.lineInteraction2D = new LineInteraction_cmp();
        this.linearObjectInteraction2D = new LinearObjectInteraction_cmp();
        this.radialObjectInteraction2D = new RadialObjectInteraction_cmp();
        this.pointsInteraction = new PointsInteraction_cmp();
        this.segmentInteraction_L = new SegmentInteraction_L_cmp();
        this.segmentInteraction_A = new SegmentInteraction_A_cmp();
        this.segmentInteraction_C = new SegmentInteraction_C_cmp();
        this.segmentInteraction_Q = new SegmentInteraction_Q_cmp();

        this.rotateByPivotInteraction = new RotateByPivotInteraction_cmp();
        this.scaleByPivotInteraction = new ScaleByPivotInteraction_cmp();
        this.perspectiveDeformInteraction = new PerspectiveDeformInteraction_cmp();
        this.gradientInteraction = new GradientInteraction_cmp();

        this.snapInteraction2D = new SnapInteraction_cmp();
        this.elementOrigin2D = new ElementOrigin_cmp();
        // usati nelle fasi di disegno
        this.interactiveLine = this.interactionContainer.querySelector('#INTERACTIVE_LINE');
        this.interactiveRectangle = this.interactionContainer.querySelector('#INTERACTIVE_RECTANGLE');
        this.interactiveEllipse = this.interactionContainer.querySelector('#INTERACTIVE_ELLIPSE');
        this.interactiveSelectionRectArea = this.interactionContainer.querySelector('#INTERACTIVE_SELECTION_RECT_AREA');
        // this.interactiveArc = this.interactionContainer.querySelector('#INTERACTIVE_PATH_SEGMENT_A');
        this.interactiveArc = this.interactionContainer.querySelector('#INTERACTIVE_ARC');
        this.interactiveRegularPolygon = this.interactionContainer.querySelector('#INTERACTIVE_REGULAR_POLYGON');
        this.TEXT_CURSOR = document.querySelector('#TEXT_CURSOR');
        this.isolateLayerBar = document.querySelector('isolate-layer-bar');
    }

    updatePageBackground() {
        this.pageBackground.setAttribute('width', activeApplication.activeDocument.activePage.dataset.pageWidth);
        this.pageBackground.setAttribute('height', activeApplication.activeDocument.activePage.dataset.pageHeight);
        this.pageBackground.getTransform().setMatrix(activeApplication.activeDocument.activePage.content.getTransform().matrix);
    }

    updateOrigin() {
        //XOS.showElement(this.originXY);
        const activeDocumentPreferences = activeApplication.activeDocument.preferences;
        const globalOrigin = activeApplication.activeDocument.activePage.content.localToGlobal(activeDocumentPreferences.origin.x, activeDocumentPreferences.origin.y);
        this.originXY.firstElementChild.updateGeometry(0, globalOrigin.y, this.bounding.width, globalOrigin.y);
        this.originXY.firstElementChild.nextElementSibling.updateGeometry(globalOrigin.x, 0, globalOrigin.x, this.bounding.height);
        if (Math.abs(activeDocumentPreferences.origin.x - activeDocumentPreferences.origin.y) < 0.001) {
            this.originXY.style.display = 'none'
        } else {
            this.originXY.style.display = 'inline'
        }
    };

    onResize() {
        this.updateWorkspaceBounding();
    }

    updateWorkspaceBounding() {
        const rect = this.getBoundingClientRect();
        this.bounding.bottom = rect.bottom;
        this.bounding.height = rect.height;
        this.bounding.left = rect.left;
        this.bounding.right = rect.right;
        this.bounding.centerX = rect.left + (rect.right - rect.left) / 2;
        this.bounding.centerY = rect.top + (rect.bottom - rect.top) / 2;
        this.bounding.top = rect.top;
        this.bounding.width = rect.width;
        this.bounding.x = rect.x;
        this.bounding.y = rect.y;
    }

    onMouseWheel(_e) {
        if (window.DRAGGING_PROCESS)
            return;
        this.onWheelChange(_e);
    }

    // OLD_onWheelChange( _e )
    // {
    //     if(_e.deltaY===0)return;
    //     if(!this.lastMouseWheelEvent) {this.lastMouseWheelEvent = _e; this.onWheelStart();}
    //     this.lastMouseWheelEvent = _e;
    //
    //     this.wheelScaleY += _e.deltaY * -0.01;
    //     this.wheelScaleY = Math.min(Math.max(.125, this.wheelScaleY), 4);
    //
    //     this.wheelScaleX += _e.deltaX * -0.01;
    //     this.wheelScaleX = Math.min(Math.max(.125, this.wheelScaleX), 4);
    //
    //
    //     _e.deltaSumX = this.wheelScaleX;
    //     _e.deltaSumY = this.wheelScaleY;
    //     const self = this;
    //     setTimeout(function()
    //     {
    //         if(self.lastMouseWheelEvent.timeStamp === _e.timeStamp )
    //         {
    //             self.onWheelEnd(_e);
    //             self.lastMouseWheelEvent = null;
    //         }else
    //         {
    //             TOOLS.activeTool.onWheelChange(_e );
    //         }
    //     },50);
    //
    // }


    onWheelChange(_e) {
        if (!TOOLS.activeTool)
            return;
        if (_e.deltaY === 0)
            return;
        if (!this.lastMouseWheelEvent) {
            this.lastMouseWheelEvent = _e;
            this.onWheelStart();
        }
        this.lastMouseWheelEvent = _e;

        this.wheelScaleY = 1 + _e.deltaY * -0.01;
        this.wheelScaleY = Math.min(Math.max(.125, this.wheelScaleY), 4);
        _e.deltaSumY = this.wheelScaleY;

        // this.wheelScaleX += _e.deltaX * -0.01;
        // this.wheelScaleX = Math.min(Math.max(.125, this.wheelScaleX), 4);
        // _e.deltaSumX = this.wheelScaleX;

        TOOLS.activeTool.onWheelChange(_e);

        const self = this;
        setTimeout(function () {
            if (self.lastMouseWheelEvent.timeStamp === _e.timeStamp) {
                self.onWheelEnd();
                self.lastMouseWheelEvent = null;
            }
        }, 100);
    }

    onWheelStart() {
        this.isWheeling = true;
        TOOLS.activeTool.onWheelChangeStart();
    }

    onWheelEnd() {
        this.isWheeling = false;
        TOOLS.activeTool.onWheelChangeEnd();
    }

    onDropOver(_e) {

        //console.log('onDropOver',_e);
        DRAG_AND_DROP_MANAGER.onDropOver(_e);
        _e.preventDefault();
    }

    onDragOver(_e) {
        //console.log('onDragOver',_e);
        DRAG_AND_DROP_MANAGER.onDragOver(_e);
        _e.preventDefault();
    }

    onDragStart(_e) {
        //console.log('onDragStart',_e);
        _e.preventDefault();
    }

    removeSelectionPreview() {
        this.selectionPreviews.removeChildren();
    }

    removeInteractions() {
        //this.interactionContainer.style.display='none';
        const elementList = this.interactionContainer.querySelectorAll('.showed');
        const max = elementList.length;
        for (let i = 0; i < max; i++)
            elementList[i].classList.remove('showed');
        // this.originXY.style.display='none';
    }

    showPointerTip(_e) {
        this.pointerTip.innerHTML = _e.pointerDescription;
        this.pointerTip.setAttribute('x', _e.workspaceX);
        this.pointerTip.setAttribute('y', _e.workspaceY - 16);
        XOS.showElement(this.pointerTip, 'add');
        activeApplication.editingView.horizontalRuler.updatePointerLocation(_e.workspaceX)
        activeApplication.editingView.verticalRuler.updatePointerLocation(_e.workspaceY)
    }

    update() {
        //this.interactionContainer.style.display='inline';
        //this.originXY.style.display='inline';

        this.removeSelectionPreview();
        this.createSelectionPreview(null, activeApplication.activeDocument.activePage.selectionList);
        this.removeInteractions();
        activeApplication.workspace.bboxInteraction2D.selectionBBox = null; // cosi se il bbox interaction non verrà visualizzato, il transform inspector dovrà calcolare il bbox autonomamente
        TOOLS.activeTool.showInteraction();
        activeApplication.activeDocument.showSelectionProperties();

        // const this.snapInteraction2D = activeApplication.activeDocument.this.snapInteraction2D;
        if (this.snapInteraction2D.smartPointA)
            this.snapInteraction2D.showSmartPointA(this.snapInteraction2D.smartPointA);
        if (this.snapInteraction2D.smartPointB)
            this.snapInteraction2D.showSmartPointB(this.snapInteraction2D.smartPointB);
        if (this.snapInteraction2D.smartGuideA)
            this.snapInteraction2D.showSmartGuideA(this.snapInteraction2D.smartGuideA);
        if (this.snapInteraction2D.smartGuideB)
            this.snapInteraction2D.showSmartGuideB(this.snapInteraction2D.smartGuideB);

    }

    createSelectionPreview(_container, _elementList, _strokeColor) {
        let isRoot = false;
        if (!_container) {
            _container = this.selectionPreviews;
            isRoot = true;
        }

        let element,
        elementPreview,
        strokeColor,
        matrix;

        const maxElements = _elementList.length;
        for (let id = 0; id < maxElements; id++) {
            element = _elementList[id];

            if (element.createSelectionPreview) {
                if (isRoot) {
                    matrix = element.getCTM();
                } else {
                    matrix = element.getTransform().matrix.clone();
                }

                strokeColor = _strokeColor || element.getLayerOwner().dataset.layerColor;

                // se si tratta di un gruppo ma non di uno oggetto parametrico
                //if( element instanceof SVGGElement  &&  ( element.dataset.type===undefined ) )
                if (element instanceof SVGGElement) {
                    const elementPreview = SVGUtils.createGroup();
                    elementPreview.getTransform().setMatrix(matrix);
                    _container.appendChild(elementPreview);
                    elementPreview.elementRef = element;
                    element.selectionPreview = elementPreview;
                    this.createSelectionPreview(elementPreview, element.childNodes, strokeColor);

                } else {
                    elementPreview = element.createSelectionPreview(matrix);

                    if (elementPreview) {
                        elementPreview.style.stroke = strokeColor;
                        _container.appendChild(elementPreview);
                    }
                }
            }
        }
    };

    updateActiveEditableSegmentInteraction() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        if (activePage.focusedPathSegmentPoint) {
            if (activePage.focusedPathSegmentPoint.type === 'L') {
                this.focusedPathSegmentPointInteraction = this.segmentInteraction_L;
            } else if (activePage.focusedPathSegmentPoint.type === 'C') {
                this.focusedPathSegmentPointInteraction = this.segmentInteraction_C;
            } else if (activePage.focusedPathSegmentPoint.type === 'Q') {
                this.focusedPathSegmentPointInteraction = this.segmentInteraction_Q;
            } else if (activePage.focusedPathSegmentPoint.type === 'A') {
                this.focusedPathSegmentPointInteraction = this.segmentInteraction_A;
            }

            this.focusedPathSegmentPointInteraction.show();
        } else if (this.focusedPathSegmentPointInteraction) {
            this.focusedPathSegmentPointInteraction.graphicElement.classList.remove('showed');
            this.focusedPathSegmentPointInteraction = null;
        }
    }

}
customElements.define("work-space", WorkSpace_cmp);

class PageRuler_cmp extends HTMLElement {

    constructor() {
        super();
        this.selectionLimints = this.querySelector('.selection-range');
        this.pointerPosition = this.querySelector('.pointer-location');
        this.canvas = this.querySelector('canvas');
        this.isVertical = false;
        if (this.classList.contains('vertical'))
            this.isVertical = true;
        this.onResize();
        this.drawRuler(0, 1, 1);
        XOS.connectEvent('mousedown', this, this.onMouseDownOnRuler, this)
    }

    onResize() {
        if (this.isVertical) {
            this.canvas.height = this.offsetHeight;
        } else {
            this.canvas.width = this.offsetWidth;
        }
    }

    onMouseDownOnRuler(_e) {
        //TOOLS["create-guide-tool"].activateByRuler( this );
    }

    updatePointerLocation(_value) {
        if (this.isVertical) {
            this.pointerPosition.style.top = _value + 'px';
        } else {
            this.pointerPosition.style.left = _value + 'px';
        }
    }

    updateSelectionRange(_min, _max) {

        if (this.isVertical) {
            this.selectionLimints.style.top = _min + 'px';
            this.selectionLimints.style.height = (_max - _min) + 'px';
        } else {
            this.selectionLimints.style.left = _min + 'px';
            this.selectionLimints.style.width = (_max - _min) + 'px';
        }
    }

    // updateSelectionRange(  _bbox  )
    // {
    //     console.log('updateSelectionRange' , _bbox );
    //     if(this.isVertical)
    //     {
    //         this.selectionLimints.style.top = _bbox.min.y+'px';
    //         this.selectionLimints.style.height = _bbox.height+'px';
    //     }
    //     else {
    //         this.selectionLimints.style.left = _bbox.min.x+'px';
    //         this.selectionLimints.style.width = _bbox.width+'px';
    //     }
    // }

    drawRuler(_origin, _unitValue, _scale, _fixedDecimals, _stepUnitValue) {

        _scale = _scale || 1;
        _fixedDecimals = _fixedDecimals || 2;
        let markersDistance = _unitValue * _scale;

        let multiplier = 1;
        let minMarkersSpace = 30;
        let divisors = 10;

        const round = Math.round;
        const floor = Math.floor;

        if (markersDistance < minMarkersSpace) {
            multiplier = (floor(minMarkersSpace / markersDistance / divisors) + 1) * divisors;

            markersDistance = _unitValue * _scale * multiplier;

            let i = floor(markersDistance / minMarkersSpace);
            if (i > 1) {
                if (i > 5) {
                    divisors = 2;
                } else {
                    divisors = 5;
                }
                multiplier = (round(minMarkersSpace / markersDistance / divisors) + 1) * divisors;
                markersDistance = _unitValue * _scale * multiplier;
            }
        }

        let ctx = this.canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#afafaf';
        ctx.fillStyle = '#000';
        ctx.font = "8px arial";

        const adjustedOrigin = _origin - (Math.ceil(_origin / markersDistance) * markersDistance);

        let markerPosition = adjustedOrigin;
        let snappedMarkerPosition;
        let snappedDivisorPosition;
        let idDivisor;
        let divisorDistance = markersDistance / divisors;
        let rulerWidth;

        ctx.beginPath();

        //if((_stepUnitValue * _scale)>10)divisors=0;
        //console.log('markersDistance/_unitValue',markersDistance/(_unitValue*_scale));


        if (this.isVertical) {
            rulerWidth = this.canvas.height;
            ctx.translate(16, 0);
            ctx.rotate(0.5 * Math.PI);
            while (markerPosition < rulerWidth) {
                snappedMarkerPosition = (~~markerPosition) + .5; // fast math floor
                ctx.moveTo(snappedMarkerPosition, 0);
                ctx.lineTo(snappedMarkerPosition, 13);
                ctx.fillText(round((markerPosition - _origin) / markersDistance * multiplier), snappedMarkerPosition + 4, 12);

                for (idDivisor = 1; idDivisor < divisors; idDivisor++) {

                    snappedDivisorPosition = (~~markerPosition + (divisorDistance * idDivisor)) + .5; // fast math floor
                    ctx.moveTo(snappedDivisorPosition, 0);

                    if (idDivisor % 2) {
                        ctx.lineTo(snappedDivisorPosition, 4);
                    } else {
                        ctx.lineTo(snappedDivisorPosition, 6);
                    }

                    if (divisorDistance > 30)
                        ctx.fillText(((markerPosition - _origin + (divisorDistance * idDivisor)) / markersDistance * multiplier).toFixed(_fixedDecimals), snappedDivisorPosition + 4, 9);

                }

                markerPosition += markersDistance;
            }

        } else {

            rulerWidth = this.canvas.width;
            while (markerPosition < rulerWidth) {
                snappedMarkerPosition = (~~markerPosition) + .5; // fast math floor
                ctx.moveTo(snappedMarkerPosition, 16);
                ctx.lineTo(snappedMarkerPosition, 3);
                ctx.fillText(round((markerPosition - _origin) / markersDistance * multiplier), snappedMarkerPosition + 4, 9);

                for (idDivisor = 1; idDivisor < divisors; idDivisor++) {
                    snappedDivisorPosition = (~~markerPosition + (divisorDistance * idDivisor)) + .5; // fast math floor
                    ctx.moveTo(snappedDivisorPosition, 16);

                    if (idDivisor % 2) {
                        ctx.lineTo(snappedDivisorPosition, 12);
                    } else {
                        ctx.lineTo(snappedDivisorPosition, 10);
                    }

                    if (divisorDistance > 30)
                        ctx.fillText(((markerPosition - _origin + (divisorDistance * idDivisor)) / markersDistance * multiplier).toFixed(_fixedDecimals), snappedDivisorPosition + 4, 9);

                }

                markerPosition += markersDistance;
            }

        }

        ctx.stroke();

        return {
            origin: adjustedOrigin,
            markersDistance: markersDistance,
            divisors: divisors
        };
    }

}
customElements.define("page-ruler", PageRuler_cmp);

class MeasuringRuler_cmp extends HTMLElement {

    constructor() {
        super();
        this.selectionLimints = this.querySelector('.selection-range');
        this.pointerPosition = this.querySelector('.pointer-location');
        this.canvas = this.querySelector('canvas');
        this.isVertical = false;
        if (this.classList.contains('vertical'))
            this.isVertical = true;
        this.origin = 0;
        this.unitValue = 1;
        this.stepUnitValue = 1;
        this.stepUnitDivisor = 4;
        this.scale = 1;
        this.fixedDecimals = 2;
        //this.canvasUtils = document.createElement('canvas'); // usato per disegnare uan griglia
    }

    connectedCallback() {
        this.update();
    }

    update() {
        if (this.isVertical) {
            this.canvas.height = this.offsetHeight;
        } else {
            this.canvas.width = this.offsetWidth;
        }

        this.unitValue = this.canvas.offsetWidth / 8;
        this.stepUnitValue = this.unitValue;

        this.draw(this.origin, this.unitValue, this.scale, this.fixedDecimals, this.stepUnitValue, this.stepUnitDivisor);
    }

    // onMouseDownOnRuler( _e )
    // {
    //     TOOLS["create-guide-tool"].activateByRuler( this );
    // }


    updatePointerLocation(_value) {
        if (this.isVertical) {
            this.pointerPosition.style.top = _value + 'px';
        } else {
            this.pointerPosition.style.left = _value + 'px';
        }
    }

    updateSelectionRange(_min, _max) {

        if (this.isVertical) {
            this.selectionLimints.style.top = _min + 'px';
            this.selectionLimints.style.height = (_max - _min) + 'px';
        } else {
            this.selectionLimints.style.left = _min + 'px';
            this.selectionLimints.style.width = (_max - _min) + 'px';
        }
    }

    draw(_origin, _unitValue, _scale, _fixedDecimals, _stepUnitValue, _stepUnitDivisor) {

        _scale = _scale || 1;
        _fixedDecimals = _fixedDecimals || 2;
        let markersDistance = _unitValue * _scale;

        let multiplier = 1;
        let minMarkersSpace = 30;
        let divisors = _stepUnitDivisor || 10;

        const round = Math.round;
        const floor = Math.floor;

        if (markersDistance < minMarkersSpace) {
            multiplier = (floor(minMarkersSpace / markersDistance / divisors) + 1) * divisors;

            markersDistance = _unitValue * _scale * multiplier;

            let i = floor(markersDistance / minMarkersSpace);
            if (i > 1) {
                if (i > 5) {
                    divisors = 2;
                } else {
                    divisors = 5;
                }
                multiplier = (round(minMarkersSpace / markersDistance / divisors) + 1) * divisors;
                markersDistance = _unitValue * _scale * multiplier;
            }
        }

        let ctx = this.canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#afafaf';
        ctx.fillStyle = '#000';
        ctx.font = "8px arial";

        const adjustedOrigin = _origin - (Math.ceil(_origin / markersDistance) * markersDistance);

        let markerPosition = adjustedOrigin;
        let snappedMarkerPosition;
        let snappedDivisorPosition;
        let idDivisor;
        let divisorDistance = markersDistance / divisors;
        let rulerWidth;

        ctx.beginPath();

        //if((_stepUnitValue * _scale)>10)divisors=0;
        //console.log('markersDistance/_unitValue',markersDistance/(_unitValue*_scale));


        if (this.isVertical) {
            rulerWidth = this.canvas.height;
            ctx.translate(16, 0);
            ctx.rotate(0.5 * Math.PI);
            while (markerPosition < rulerWidth) {
                snappedMarkerPosition = (~~markerPosition) + .5; // fast math floor
                ctx.moveTo(snappedMarkerPosition, 0);
                ctx.lineTo(snappedMarkerPosition, 13);
                ctx.fillText(round((markerPosition - _origin) / markersDistance * multiplier), snappedMarkerPosition + 4, 12);

                for (idDivisor = 1; idDivisor < divisors; idDivisor++) {

                    snappedDivisorPosition = (~~markerPosition + (divisorDistance * idDivisor)) + .5; // fast math floor
                    ctx.moveTo(snappedDivisorPosition, 0);

                    if (idDivisor % 2) {
                        ctx.lineTo(snappedDivisorPosition, 4);
                    } else {
                        ctx.lineTo(snappedDivisorPosition, 6);
                    }

                    if (divisorDistance > 30)
                        ctx.fillText(((markerPosition - _origin + (divisorDistance * idDivisor)) / markersDistance * multiplier).toFixed(_fixedDecimals), snappedDivisorPosition + 4, 9);

                }

                markerPosition += markersDistance;
            }

        } else {

            rulerWidth = this.canvas.width;
            while (markerPosition < rulerWidth) {
                snappedMarkerPosition = (~~markerPosition) + .5; // fast math floor
                ctx.moveTo(snappedMarkerPosition, 16);
                ctx.lineTo(snappedMarkerPosition, 3);
                ctx.fillText(round((markerPosition - _origin) / markersDistance * multiplier), snappedMarkerPosition + 4, 9);

                for (idDivisor = 1; idDivisor < divisors; idDivisor++) {
                    snappedDivisorPosition = (~~markerPosition + (divisorDistance * idDivisor)) + .5; // fast math floor
                    ctx.moveTo(snappedDivisorPosition, 16);

                    if (idDivisor % 2) {
                        ctx.lineTo(snappedDivisorPosition, 12);
                    } else {
                        ctx.lineTo(snappedDivisorPosition, 10);
                    }

                    if (divisorDistance > 30)
                        ctx.fillText(((markerPosition - _origin + (divisorDistance * idDivisor)) / markersDistance * multiplier).toFixed(_fixedDecimals), snappedDivisorPosition + 4, 9);

                }

                markerPosition += markersDistance;
            }

        }

        ctx.stroke();

        return {
            origin: adjustedOrigin,
            markersDistance: markersDistance,
            divisors: divisors
        };
    }

    drawGridImage(_width, _height, _originX, _originY, _divisors, _imageTarget) {

        // while(_width>400) {_width/=5;}
        while (_width > 400) {
            _width /= _divisors;
        }

        _height = _width;

        const canvas = this.canvasUtils;
        canvas.width = _width;
        canvas.height = _height;
        const ctx = canvas.getContext("2d");
        ctx.lineWidth = .5;
        ctx.strokeStyle = '#d4d4d4';

        ctx.beginPath();
        ctx.rect(.5, .5, (~~_width) - .5, (~~_height) - .5);
        ctx.stroke();

        const divisorSizeX = _width / _divisors;
        const divisorSizeY = _height / _divisors;
        let snappedDivisorPosition;

        for (let idDivisor = 1; idDivisor < _divisors; idDivisor++) {
            snappedDivisorPosition = (~~(divisorSizeX * idDivisor)) + .5;
            ctx.moveTo(snappedDivisorPosition, 1);
            ctx.lineTo(snappedDivisorPosition, _height - 1);
            snappedDivisorPosition = (~~(divisorSizeY * idDivisor)) + .5;
            ctx.moveTo(1, snappedDivisorPosition);
            ctx.lineTo(_width - 1, snappedDivisorPosition);
        }

        ctx.stroke();

        return canvas.toDataURL("image/png");

        // var tmp_path = URL.createObjectURL('path/to/image.png');
        // document.getElementbyId('divId').style.background = tmp_path;
        // canvas.toBlob(function(blob) {
        //     var newImg = document.createElement('img'),
        //         url = URL.createObjectURL(blob);
        //
        //     newImg.onload = function() {
        //         // no longer need to read the blob so it's revoked
        //         URL.revokeObjectURL(url);
        //     };
        //
        //     newImg.src = url;
        //     document.body.appendChild(newImg);
        // });


        //_imageTarget.src = canvas.toDataURL("image/png") ;

        // this.gridPattern.setAttribute('width' , _width );
        // this.gridPattern.setAttribute('height' , _height );
        // this.gridPattern.gridImage.setAttribute('width' , _width );
        // this.gridPattern.gridImage.setAttribute('height' , _height );
        // this.gridPattern.gridImage.setAttributeNS( SVGElement.XLINK_NS , 'href', canvas.toDataURL("image/png") );
        // this.gridPattern.setAttribute('patternTransform','matrix(1 0 0 1 '+_originX+' '+_originY+')');
    };

}

customElements.define("measuring-ruler", MeasuringRuler_cmp);

class PageOrigin_cmp extends HTMLElement {

    constructor() {
        super();
        XOS.connectEvent('mousedown', this, this.onMouseDown, this)
    }

    onMouseDown(_e) {
        //activeApplication.tools["translate-origin-tool"].activateByRulerOrigin();

        XOS.initDragFunctions(TOOLS["translate-origin-tool"], _e);
    }

}
customElements.define("page-origin", PageOrigin_cmp);

class IsolateLayerBar_cmp extends HTMLElement {

    constructor() {
        super();
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
    }

    update() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const layers = activePage.content.querySelector('.layers').children;
        const lastLayer = layers[layers.length - 1];

        if (!lastLayer.classList.contains('isolate-layer')) {
            this.classList.add('hidden');
            return;
        }

        this.classList.remove('hidden');

        let label = '',
        isolateLayer = lastLayer;
        while (isolateLayer.classList.contains('isolate-layer')) {
            label = isolateLayer.dataset.layerName + ' / ' + label; // i nomi dei layers corrispondo ai nomi degli oggetti
            isolateLayer = isolateLayer.previousElementSibling;
        }

        this.querySelector('.label').innerHTML = label;
    };

    onClick_exitFromEditingLayer() {
        activeApplication.activeDocument.exitFrom_isolateLayerEditing();
    };

}
customElements.define("isolate-layer-bar", IsolateLayerBar_cmp);

class Document2D_cmp extends HTMLElement {

    constructor() {
        super();

        const documentTemplate = document.getElementById('DOCUMENT-2D').content.cloneNode(true);
        this.attachShadow({
            mode: 'open'
        });
        this.shadowRoot.appendChild(documentTemplate);

        this.workspaceBounding = activeApplication.workspace.bounding; // per comodità
        this.clipPathHitTestRect = this.shadowRoot.querySelector('#clip-path-hit-test rect');

        this.resources = this.shadowRoot.querySelector('.resources');
        this.pageList = this.shadowRoot.querySelector('.page-list');

        //this.snapUtils = new SnapUtils();


        this.preferences = {};
        this.preferences.unitKey = 'MILLIMETER';
        this.preferences.unitValue = 0.2645833333;
        this.preferences.drawingScale = 1;
        this.preferences.findAllElementAtPoint = 1;
        this.preferences.optimizeZoom = false;
        this.preferences.mantainAspectRatio = true;
        this.preferences.interactionLabelVisibility = false;
        this.preferences.svgAlignmentPreserveAspectRatio = "unset";

        this.preferences.snap = {};
        this.preferences.snap.distance = 10;
        this.preferences.snap.offsetDistance = 50;
        this.preferences.snap.snapToPoints = true;
        this.preferences.snap.snapToContour = true;
        this.preferences.snap.snapToPerpendicular = true;
        this.preferences.snap.snapToTangent = true;
        this.preferences.snap.snapToIntersection = true;
        this.preferences.snap.snapToCenter = true;
        this.preferences.snap.snapToGrid = true;
        this.preferences.snap.snapToOffset = true;
        this.preferences.snap.snapToAngles = true;
        this.preferences.snap.snapAngleList = [45];
        this.preferences.snap.useSmartPoints = true;
        this.preferences.snap.useSmartGuides = true;

        this.preferences.fixedDecimals = 0;
        //this.preferences.gridVisibilityState = true;
        this.preferences.rulersVisibility = true;
        this.preferences.gridVisibility = false;
        this.preferences.elementOriginVisibility = false;
        this.preferences.gridStep = 3.779527559531279;
        this.preferences.origin = {};
        this.preferences.origin.x = 0;
        this.preferences.origin.y = 0;
        this.preferences.selectMainNodes = true;
        this.preferences.scaleStrokeAndEffects = true;
        this.preferences.scaleText = true;
        this.preferences.moveStep = 1;
        this.preferences.rotateStep = 45;

        this.fillAndStrokeManager = new FillAndStrokeManager();
        this.fillAndStrokeManager.update_strokeDisplay();
        this.fillAndStrokeManager.update_fillDisplay();
        // this.activeGraphicProperties = {};
        // this.activeGraphicProperties.fill='#FFFFFF';
        // this.activeGraphicProperties.fillFillingType='color';
        // this.activeGraphicProperties.fillOpacity='1';
        // this.activeGraphicProperties.stroke='#000000';
        // this.activeGraphicProperties.strokeFillingType='color';
        // this.activeGraphicProperties.strokeOpacity='1';
        // this.activeGraphicProperties.strokeWidth='1';
        // this.activeGraphicProperties.strokeLineCap = 'butt';
        // this.activeGraphicProperties.strokeLineJoin = 'miter';


        // dovrebbero stare in workspace ma sono costretto a mettere qui per via di uno sfarfallamento
        // XOS.connectEvent ( "mousedown" , this ,this.onPointerDown , this );
        // XOS.connectEvent ( "mousemove" , this ,this.onPointerMove , this );
        // XOS.connectEvent ( "mouseup" , this ,this.onPointerUp , this );

        XOS.connectEvent("mousedown", window, this.onPointerDown, this);
        XOS.connectEvent("mousemove", this, this.onPointerMove, this);
        XOS.connectEvent("mouseup", this, this.onPointerUp, this);

    }

    onPointerDown(_e) {
        //if(activeApplication.isTextEditing) return;
        this.canPointerUpBeProcessed = false;
        if (_e.target !== this)
            return

            this.canPointerUpBeProcessed = true;

        if (_e.which === 3) {
            MENUS['context-menu'].activateAt(_e.pageX, _e.pageY);
            return;
        }

        // if( this.lastEvent)
        // {
        //     if( ( _e.timeStamp - this.lastEvent.timeStamp )< 250  )
        //     {
        //         TOOLS.activeTool.onPointerDoubleClick(_e );
        //         return;
        //     }
        // }

        //console.log('_e.target down',_e);


        TOOLS.activeTool.onPointerDown(_e);

        //this.lastEvent = _e;

    }

    onPointerUp(_e) {
        //if(activeApplication.isTextEditing) return;


        KEYBOARD_EVENT_MANAGER.onMouseUp(_e); // aggiorna lo stato dei tasti


        //console.log('_e.target up',_e);

        if (this.canPointerUpBeProcessed !== true)
            return;
        //this.canPointerUpBeProcessed = false;

        // if( this.lastEvent)
        // {
        //     if( ( _e.timeStamp - this.lastEvent.timeStamp )< 250  )
        //     {
        //         TOOLS.activeTool.onPointerDoubleClick(_e );
        //         return;
        //     }
        // }

        //this.lastEvent = _e; // todo bisogna capire come cambiare questa cosa usata da snapManager

        TOOLS.activeTool.onPointerUp(_e);
    }

    onPointerMove(_e) {
        if (activeApplication.workspace.isWheeling)
            return;
        TOOLS.activeTool.onPointerMove(_e);
    }

    onResize(_e) {
        activeApplication.editingView.redrawRulersAndGrid();
    }

    onChange() {
        this.isChanged = true;
        this.activePage.preview = null;
        this.tabItemRef.classList.add('changed');
    }

    setOrigin(_x, _y) {
        this.preferences.origin.x = _x;
        this.preferences.origin.y = _y;
        activeApplication.editingView.redrawRulersAndGrid();
        // const globalOrigin = this.content.localToGlobal(this.preferences.origin.x,this.preferences.origin.y);
        // const matrixOrigin =  this.originXY.getTransform().matrix;
        // matrixOrigin.e = globalOrigin.x;
        // matrixOrigin.f =  globalOrigin.y;
    };

    createNewPage(_width, _height) {
        const newPage = document.getElementById('PAGE-2D').content.querySelector('.page').cloneNode(true);

        if (_width && _height) {
            newPage.dataset.pageWidth = _width;
            newPage.dataset.pageHeight = _height;
            //console.log('createNewPage',newPage.dataset);
        } else {
            const lastPage = this.pageList.lastElementChild;
            if (lastPage) {
                newPage.dataset.pageWidth = lastPage.dataset.pageWidth;
                newPage.dataset.pageHeight = lastPage.dataset.pageHeight;
            }
        }

        this.pageList.appendChild(newPage);
        // this.setActivePage( newPage );
        return newPage;
    }

    setActivePage(_page) {
        if (this.activePage)
            this.exitFrom_AllIsolateLayerEditing();
        this.activePage = _page;
        this.activePage.content = this.activePage.querySelector(':scope>.content');
        this.activePage.content.currentScale = this.activePage.content.currentScale || 1;
        this.activePage.selectionList = this.activePage.selectionList || []; // se non esiste verrà creata
        this.activePage.selectionPointList = this.activePage.selectionPointList || []; // se non esiste verrà creata
        this.activePage.focusedElement = this.activePage.focusedElement || null;
        this.activePage.focusedPoint = this.activePage.focusedPoint || null;
        this.activePage.history = this.activePage.history || new UndoRedoHistory(this); // se non esiste verrà creata
        XOS.showElement(this.activePage);
        this.setActivePageScale('fit');
        activeApplication.workspace.updatePageBackground();
        activeApplication.workspace.update();
        WINDOWS['layersWindow'].update();
    }

    setActivePageSize(_width, _height, _applyToAllPages) {
        if (_applyToAllPages) {
            const max = this.pageList.children.length;
            let currentPage;
            for (let i = 0; i < max; i++) {
                currentPage = this.pageList.children[i];
                currentPage.dataset.pageWidth = _width;
                currentPage.dataset.pageHeight = _height;
                currentPage.preview = null;
            }
        } else {
            this.activePage.dataset.pageWidth = _width;
            this.activePage.dataset.pageHeight = _height;
            this.activePage.preview = null;
        }
        activeApplication.workspace.updatePageBackground();
    }

    setActivePageViewMatrix(_matrix) {
        this.activePage.content.getTransform().setMatrix(_matrix);
        activeApplication.workspace.pageBackground.getTransform().setMatrix(_matrix);
        this.activePage.content.currentScale = _matrix.getScale().x;
        activeApplication.editingView.redrawRulersAndGrid();
    };

    setActivePageScale(scale) {
        const viewWidth = this.workspaceBounding.width;
        const viewHeight = this.workspaceBounding.height;

        const pageWidth = this.activePage.dataset.pageWidth;
        const pageHeight = this.activePage.dataset.pageHeight;

        if (scale === 'fit') {
            const marginX = 20;
            const marginY = 20;
            const ratioX = (viewWidth - marginX) / pageWidth;
            const ratioY = (viewHeight - marginY) / pageHeight;
            scale = Math.min(ratioX, ratioY);
        }

        let contentMatrix = this.activePage.content.getTransform().matrix.identity();

        const centerX = viewWidth / 2 - (pageWidth * scale) / 2;
        const centerY = viewHeight / 2 - (pageHeight * scale) / 2;

        contentMatrix = contentMatrix.translate(centerX, centerY);
        contentMatrix = contentMatrix.scale(scale);

        this.activePage.content.getTransform().setMatrix(contentMatrix);
        activeApplication.workspace.pageBackground.getTransform().setMatrix(contentMatrix);

        this.activePage.content.currentScale = scale;

        activeApplication.editingView.redrawRulersAndGrid();
    };

    fitRectToView(_rect, _marginX, _marginY) {
        _marginX = _marginX || 20;
        _marginY = _marginY || 20;

        const viewWidth = this.workspaceBounding.width;
        const viewHeight = this.workspaceBounding.height;

        const rectWidth = _rect.width;
        const rectHeight = _rect.height;

        const ratioX = (viewWidth - _marginX) / rectWidth;
        const ratioY = (viewHeight - _marginY) / rectHeight;

        // const ratioX =   viewWidth  / ( rectWidth + _marginX )  ;
        // const ratioY =   viewHeight  / ( rectHeight + _marginY )  ;


        const scale = Math.min(ratioX, ratioY);

        let contentMatrix = this.activePage.content.getTransform().matrix;

        contentMatrix.e -= (_rect.x + rectWidth / 2);
        contentMatrix.f -= (_rect.y + rectHeight / 2);

        contentMatrix.e += viewWidth / 2;
        contentMatrix.f += viewHeight / 2;

        //console.log(_rect.center);

        this.zoom(scale, this.workspaceBounding.width / 2, this.workspaceBounding.height / 2);

    }

    createPageLayer(_layerName, _layerColor) {
        //_layerName = _layerName ||  localString( 'Layer' );
        _layerName = _layerName || 'Layer';
        _layerColor = _layerColor || "#fb0094";
        const layer = SVGUtils.createGroup();
        layer.dataset.layerName = _layerName;
        layer.dataset.layerColor = _layerColor;
        layer.classList.add("layer");
        return layer;
    };

    addPageLayer(_layer) {
        this.activePage.content.querySelector('.layers').appendChild(_layer);
        this.setActivePageLayer(_layer);
        return _layer;
    };

    removePageLayer(_layer) {

        const layerToActivate = _layer.previousElementSibling || _layer.nextElementSibling;
        _layer.parentElement.removeChild(_layer);
        this.setActivePageLayer(layerToActivate);
    };

    setActivePageLayer(_layer) {

        const activeLayerList = this.activePage.content.querySelectorAll('.layers>.layer[active]');
        for (let i = 0; i < activeLayerList.length; i++) {
            activeLayerList[i].removeAttribute('active');
        }

        if (_layer) {
            _layer.setAttribute('active', '');
            WINDOWS['layersWindow'].updateLayerSelection(_layer);
        }

        // const activeLayer = this.getActivePageLayer();
        // if(activeLayer) activeLayer.removeAttribute('active');
        // if(_layer) _layer.setAttribute('active','');
    };

    getActivePageLayer() {
        let activeLayer = this.activePage.content.querySelector('.layers>.layer[active]');
        if (!activeLayer) {
            activeLayer = this.activePage.content.querySelector('.layers>.layer');
            this.setActivePageLayer(activeLayer);
        }
        return activeLayer;
    };

    // questo è chiamato dalla window Animation timeline ( che al momento è stata disabilitata )
    initActivePageTimelines() {
        this.activePage.timelines = {};
        this.activePage.timelines['page-entrance-timeline'] = {
            timelineName: 'Page Entrance',
            animateCategory: 'Entrance animations',
            timelineItems: [{
                    elementId: '#background',
                    animations: [{
                            delay: 0,
                            duration: .5,
                            animationName: 'fadeIn'
                        }
                    ]
                }
            ]
        };
        this.activePage.timelines['page-exit-timeline'] = {
            timelineName: 'Page Exit',
            animateCategory: 'Exit animations',
            timelineItems: [{
                    elementId: '#background',
                    animations: [{
                            delay: 0,
                            duration: .5,
                            animationName: 'fadeOut'
                        }
                    ]
                }
            ]
        };
    };

    setUnits(_unitKey) {
        this.preferences.unitKey = _unitKey;
        const unitProperties = GeometryUtils.unitProperty[this.preferences.unitKey];
        this.preferences.unitValue = unitProperties.unitValue;
        this.preferences.gridStep = unitProperties.gridStep;
        this.preferences.fixedDecimals = unitProperties.fixedDecimals;
        this.setDrawingScale(unitProperties.drawingScale); // lo fa comunque per aggiornare le quote anche quando drawingScale rimane uguale
        // if(this.preferences.drawingScale !== unitProperties.drawingScale);
        // {
        //     this.setDrawingScale( unitProperties.drawingScale );
        // }
        // this.preferences.drawingScale = unitProperties.drawingScale;
    }

    setDrawingScale(_drawingScaleValue) {

        const activePageToReturn = this.activePage;
        const newElementScale = this.preferences.drawingScale / _drawingScaleValue;
        this.preferences.drawingScale = _drawingScaleValue;
        this.setActivePageScale('fit');
        const pageWidth = parseFloat(this.activePage.dataset.pageWidth);
        const pageHeight = parseFloat(this.activePage.dataset.pageHeight);
        const pivot = this.activePage.content.localToGlobal(pageWidth / 2, pageHeight / 2);
        const scaleOptions = {};
        scaleOptions.scaleStrokeAndEffects = false;
        scaleOptions.scaleText = true;
        scaleOptions.effectScale = Math.sqrt(newElementScale * newElementScale + newElementScale * newElementScale) / Math.sqrt(2);

        for (let i = 0; i < this.pageList.children.length; i++) {
            this.setActivePage(this.pageList.children[i]);
            const elementList = this.activePage.querySelectorAll('.layer>*');
            this.scaleElementList(elementList, newElementScale, newElementScale, pivot);
            this.normalizeScaleElementList(elementList, scaleOptions);
        }

        this.setActivePage(activePageToReturn);

        activeApplication.workspace.update();
        this.onChange();
    }

    // setDrawingScale( _drawingScaleValue )
    // {
    //     //const elementList = this.activePage.querySelectorAll('.layer>*');
    //     const elementList = this.pageList.querySelectorAll('.layer>*');
    //     const newElementScale =  this.preferences.drawingScale / _drawingScaleValue ;
    //     this.preferences.drawingScale = _drawingScaleValue;
    //
    //     const pageWidth =  parseFloat(this.activePage.dataset.pageWidth);
    //     const pageHeight = parseFloat(this.activePage.dataset.pageHeight);
    //     this.scaleElementList( elementList,   newElementScale, newElementScale ,  this.activePage.content.localToGlobal(pageWidth/2,pageHeight/2) );
    //
    //     const scaleOptions={};
    //     scaleOptions.scaleStrokeAndEffects = false;
    //     scaleOptions.scaleText = true;
    //
    //     this.normalizeScaleElementList( elementList , scaleOptions );
    //
    //     activeApplication.workspace.update();
    //     this.onChange();
    // }


    unitToValue(_value) {
        return _value / this.preferences.unitValue / this.preferences.drawingScale;
    }

    valueToUnit(_value) {
        // serve ad avere i decimali solo se diversi da .00
        return parseFloat((_value * this.preferences.unitValue * this.preferences.drawingScale).toFixed(this.preferences.fixedDecimals)) + ' ' + GeometryUtils.unitProperty[this.preferences.unitKey].unitName;
        //return  Number(parseFloat(_value) *  this.preferences.unitValue *  this.preferences.drawingScale ).toFixed( this.preferences.fixedDecimals)+' '+GeometryUtils.unitProperty[ this.preferences.unitKey ].unitName;
    }

    valueToFixed(_value) {
        // serve ad avere i decimali solo se diversi da .00
        return parseFloat(Number(_value).toFixed(this.preferences.fixedDecimals));
        //return  Number(parseFloat(_value)).toFixed(this.preferences.fixedDecimals) ;
    };

    // localToWorkspaceCoords(_e,_pointData)
    // {
    //     _e.localX = _pointData.point.x;
    //     _e.localY = _pointData.point.y;
    //     const pointInWorkspace = _pointData.element.localToGlobal( _e.localX ,  _e.localY );
    //     _e.workspaceX = pointInWorkspace.x;
    //     _e.workspaceY = pointInWorkspace.y;
    // }

    pageContentToWorkspaceCoords(_e) {
        const contentMatrix = this.activePage.content.getTransform().matrix;
        _e.workspaceX = _e.contentX * this.activePage.content.currentScale + contentMatrix.e;
        _e.workspaceY = _e.contentY * this.activePage.content.currentScale + contentMatrix.f;
    }

    workspaceToPageContentCoords(_e) {
        const contentMatrix = this.activePage.content.getTransform().matrix;
        _e.contentX = (_e.workspaceX - contentMatrix.e) / this.activePage.content.currentScale;
        _e.contentY = (_e.workspaceY - contentMatrix.f) / this.activePage.content.currentScale;
    }

    workspaceToWindowCoords(_e) {
        _e.windowX = this.workspaceBounding.x + _e.workspaceX;
        _e.windowY = this.workspaceBounding.y + _e.workspaceY;
    }

    windowToWorkspaceCoords(_e) {
        _e.workspaceX = _e.windowX - this.workspaceBounding.x;
        _e.workspaceY = _e.windowY - this.workspaceBounding.y;
    }

    pointerEventToCoords(_e, _manageScroll = false) {
        _e.windowX = _e.pageX;
        _e.windowY = _e.pageY;
        if (_manageScroll)
            this.pointerEventManageScrolling(_e);
        _e.workspaceX = _e.windowX - this.workspaceBounding.x;
        _e.workspaceY = _e.windowY - this.workspaceBounding.y;
        const contentMatrix = this.activePage.content.getTransform().matrix;
        _e.contentX = (_e.workspaceX - contentMatrix.e) / this.activePage.content.currentScale;
        _e.contentY = (_e.workspaceY - contentMatrix.f) / this.activePage.content.currentScale;
    };

    // pointerEventToCoords( _e , _manageScroll=true )
    // {
    //
    //     _e.windowX = _e.pageX ;
    //     _e.windowY = _e.pageY ;
    //     if( _manageScroll ) this.pointerEventManageScrolling(_e);
    //     _e.workspaceX = _e.windowX - this.workspaceBounding.x;
    //     _e.workspaceY = _e.windowY - this.workspaceBounding.y;
    //     const contentMatrix = this.activePage.content.getTransform().matrix;
    //     _e.contentX = (_e.workspaceX - contentMatrix.e ) / this.activePage.content.currentScale;
    //     _e.contentY = (_e.workspaceY - contentMatrix.f  ) / this.activePage.content.currentScale;
    // };

    pointerEventManageScrolling(_e) {
        _e.scrollX = 0;
        _e.scrollY = 0;

        if (_e.windowX < (this.workspaceBounding.left + 10))
            _e.scrollX = 10;
        if (_e.windowX > (this.workspaceBounding.right - 10))
            _e.scrollX =  - 10;
        if (_e.windowY < (this.workspaceBounding.top + 10))
            _e.scrollY = 10;
        if (_e.windowY > (this.workspaceBounding.bottom - 10))
            _e.scrollY =  - 10;
        if (_e.scrollX !== 0 || _e.scrollY !== 0)
            this.pan(_e.scrollX, _e.scrollY);
    }

    elementListAsMainElements(_elementList) {
        const mainElementList = [];

        const max = _elementList.length;
        let i,
        element;
        for (i = 0; i < max; i++) {
            element = _elementList[i].getMainElement();
            if (mainElementList.indexOf(element) === -1)
                mainElementList.push(element);
        }
        return mainElementList;
    }

    elementFromPointerEvent(_e, _findAllElementAtPoint) {
        _e.elementListAtPoint = _e.elementAtPoint = null;

        if (_e.pageX > this.workspaceBounding.left && _e.pageX < this.workspaceBounding.right && _e.pageY > this.workspaceBounding.top && _e.pageY < this.workspaceBounding.bottom) {
            const hitTestRect = SVGUtils.hitTestRect;
            const snapDistance = this.preferences.snap.distance;
            hitTestRect.x = _e.workspaceX - snapDistance;
            hitTestRect.y = _e.workspaceY - snapDistance;
            hitTestRect.height = hitTestRect.width = snapDistance * 2;

            // activeApplication.workspace.interactiveSelectionRectArea.updateGeometry( hitTestRect.x , hitTestRect.y, hitTestRect.width , hitTestRect.height );
            // activeApplication.workspace.interactiveSelectionRectArea.style.display='block';

            const elementListAtIntersection = this.activePage.getIntersectionList(hitTestRect, null);
            //console.log('elementListAtIntersection', elementListAtIntersection );
            if (elementListAtIntersection.length > 0) {
                const max = elementListAtIntersection.length;
                let i;
                for (i = 0; i < max; i++)
                    elementListAtIntersection[i].classList.add('precise-hit-test-element');
                if (_findAllElementAtPoint) {
                    const elementListAtPoint = this.shadowRoot.elementsFromPoint(_e.pageX, _e.pageY);

                    const validElementList = [];
                    for (i = 0; i < elementListAtPoint.length; i++) {
                        if (elementListAtPoint[i].nodeName === 'svg')
                            break;
                        validElementList.push(elementListAtPoint[i]);
                    }

                    if (validElementList.length > 0)
                        _e.elementAtPoint = elementListAtPoint[0];

                    for (i = 0; i < max; i++) {
                        // aggiungo gli elementi per lo snap
                        if (elementListAtPoint.indexOf(elementListAtIntersection[i]) === -1)
                            validElementList.push(elementListAtIntersection[i]);
                    }

                    _e.elementListAtPoint = validElementList;
                    // console.log('validElementList',validElementList);
                    // _e.elementListAtPoint =this.shadowRoot.elementsFromPoint( _e.pageX  , _e.pageY  );
                    //_e.elementAtPoint =_e.elementListAtPoint[0];
                } else {
                    _e.elementAtPoint = this.shadowRoot.elementFromPoint(_e.pageX, _e.pageY);
                    _e.elementListAtPoint = [_e.elementAtPoint];
                }
                for (i = 0; i < max; i++)
                    elementListAtIntersection[i].classList.remove('precise-hit-test-element');
            }
            // foreign object non prende l'interswezione // al momento non verrà usato
            else {

                if (_e.path && _e.path[0].nodeName === 'foreignObject') {
                    _e.elementAtPoint = _e.path[0];
                    _e.elementListAtPoint = [_e.elementAtPoint];
                }

                // _e.elementAtPoint =this.shadowRoot.elementFromPoint( _e.pageX  , _e.pageY  );
                // if( _e.elementAtPoint.nodeName === 'foreignObject') _e.elementListAtPoint=[ _e.elementAtPoint ];
            }
        }
    };

    applySnap(_e, _options) {
        activeApplication.workspace.snapInteraction2D.applySnap(_e, _options);
    }

    deselectAll() {
        this.activePage.selectionList = [];
        //this.activePage.selectionList.length = 0; // aazera tutti gli elementi dell'array, ma mantiene il riferimento a selectioList della pagina corrente
        this.activePage.focusedElement = null;
        this.deselectAllPoints();
    }

    selectAll() {
        let elementList;

        if (this.getActivePageLayer().classList.contains('isolate-layer')) {
            elementList = this.activePage.content.querySelectorAll('.layers>.layer[active]>*:not([locked])');
        } else {
            elementList = this.activePage.content.querySelectorAll('.layers>.layer:not([locked]):not([hidden])>*:not([locked]):not([hidden])');
        }

        elementList = XOS.getFilteredElementListByNodeName(elementList, 'line,rect,ellipse,path,g,text,use,image,foreignObject');

        //elementList = XOS.filterElementListByFieldValue( elementList , 'nodeName', 'line,rect,ellipse,path,g,text,use,image,foreignObject');
        this.selectElementList(elementList);
        activeApplication.workspace.update();

    };

    deselectElement(_element) {
        if (!this.isElementSelected(_element))
            return;
        this.activePage.selectionList.splice(this.activePage.selectionList.indexOf(_element), 1);
        //_element.showBoundingBox = false;
        this.activePage.focusedElement = null;
        //this.updateSelection();
        if (this.activePage.selectionList.length > 0)
            this.activePage.focusedElement = this.activePage.selectionList[this.activePage.selectionList.length - 1];
    }

    selectElement(_element, _toggle) {
		console.log('selectElement' + _element);
		
		//var event = new CustomEvent('SVGEventClick', { detail: _element })
		//window.parent.document.dispatchEvent(event)
		
		
        if (this.isElementSelected(_element)) {
            if (_toggle) {
                this.deselectElement(_element);
                this.activePage.focusedElement = null;
                if (this.activePage.selectionList.length > 0)
                    this.activePage.focusedElement = this.activePage.selectionList[this.activePage.selectionList.length - 1];
            } else {	
				var idElement = _element.id;
				const newMsg = { sender: "SVGEditor" , event: "click", objectId : idElement, eventPanel: ParentEventPanel, eventField: ParentEventField, eventProcess: ParentProcessIdField};
				window.parent.postMessage(JSON.stringify(newMsg), "*");
                this.activePage.focusedElement = _element;
            }
        } else {		
			var idElement = _element.id;
			const newMsg = { sender: "SVGEditor" , event: "click", objectId : idElement, eventPanel: ParentEventPanel, eventField: ParentEventField, eventProcess: ParentProcessIdField};
			window.parent.postMessage(JSON.stringify(newMsg), "*");
            this.activePage.focusedElement = _element;
            this.activePage.selectionList.push(_element);
        }
    }

    selectElementList(_elementList) {
        this.deselectAll();
        for (let i = 0; i < _elementList.length; i++)
            this.activePage.selectionList.push(_elementList[i]);
        if (this.activePage.selectionList.length > 0)
            this.activePage.focusedElement = this.activePage.selectionList[this.activePage.selectionList.length - 1];
        this.setFocusedPathSegmentPoint(null);
    }

    isElementSelected(_element) {
        if (this.activePage.selectionList.indexOf(_element) > -1)
            return true;
        return false;
    }

    /* POINT SELECTION */

    // deselectElementPoints( _element )
    // {
    //     const pointList = _element.getGeometryPointList();
    //     let point;
    //     const max = pointList.length;
    //     for(let i = 0; i < max; i++)
    //     {
    //         point = pointList[i];
    //         if( point.isSelected ) this.deselectPoint( point );
    //     }
    // };


    deselectAllPoints() {
        const max = this.activePage.selectionPointList.length;
        for (let i = 0; i < max; i++) {
            this.activePage.selectionPointList[i].isSelected = false;
            delete this.activePage.selectionPointList[i].editable;
        }
        this.activePage.selectionPointList = [];
        this.activePage.focusedPoint = null;
        //this.activePage.focusedPathSegmentPoint = null;
    };

    deselectPoint(_point) {
        _point.isSelected = false;
        delete _point.editable;
        this.activePage.selectionPointList.remove(_point);
    };

    selectPointList(_pointList) {
        this.deselectAllPoints();
        const max = _pointList.length;
        for (let i = 0; i < max; i++)
            this.selectPoint(_pointList[i]);
    };

    selectPoint(_point) {
        if (_point.isSelected === true)
            return;
        this.activePage.selectionPointList.push(_point);
        _point.isSelected = true;
    };

    setFocusedPathSegmentPoint(_segment) {
        if (_segment)
            this.deselectAllPoints();
        this.activePage.focusedPathSegmentPoint = _segment;
    };

    showSelectionProperties() {
        // this.fillAndStrokeManager.set_stroke( this.activePage.focusedElement );
        // this.fillAndStrokeManager.set_fill( this.activePage.focusedElement );

        activeApplication.setAttribute('data-selected-items', String(this.activePage.selectionList.length));

        if (this.activePage.focusedElement) {
            this.fillAndStrokeManager.set_stroke(this.activePage.focusedElement);
            this.fillAndStrokeManager.set_fill(this.activePage.focusedElement);

            if (this.activePage.focusedElement.hasAttribute('data-type')) {
                const elementType = this.activePage.focusedElement.getAttribute('data-type');
                activeApplication.setAttribute('data-focused-item-type', elementType);
            } else {
                activeApplication.setAttribute('data-focused-item-type', String(this.activePage.focusedElement.nodeName));
            }

            const layer = this.activePage.focusedElement.getLayerOwner();
            //console.log('layer',layer);
            //if(layer.parentElement.classList.contains('layers')) this.setActivePageLayer( layer );
            if (layer.parentElement.classList.contains('layers') && (!layer.hasAttribute('active'))) {
                this.setActivePageLayer(layer);
            }

            // if(this.activePage.focusedElement.hasAttribute('data-object-plugin'))
            // {
            //     activeApplication.setAttribute('data-focused-item-type', 'object-plugin' );
            // }else {
            //     activeApplication.setAttribute('data-focused-item-type', String(this.activePage.focusedElement.nodeName) );
            // }
        } else {
            activeApplication.removeAttribute('data-focused-item-type');
        }

        WINDOWS['mainInspectorWindow'].update();

        // WINDOWS['animationWindow'].update();

    };

    translateElementList(_elementList, _translateX, _translateY, _localMode) {
        const matrix = this.activePage.createSVGMatrix().translate(_translateX, _translateY);
        let element;
        const max = _elementList.length;
        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            if (element.transform) {
                if (_localMode) {
                    element.getTransform().setMatrix(matrix.multiply(element.getTransform().matrix));
                } else {
                    element.getTransform().setMatrix(element.globalMatrixToLocalMatrix(matrix.multiply(element.getCTM())));
                }
            }

        }
    }

    setAttributeElementList(_elementList, _attributeKeyValues) {
        for (let i = 0; i < _elementList.length; i++) {
            for (let attributeName in _attributeKeyValues) {
                _elementList[i].setAttribute(attributeName, _attributeKeyValues[attributeName]);
            }
        }
    }

    setAttributeElementList_undable(_elementList, _attributeKeyValues, _applyElementSelection = true, _updateWorkspaceTimeout = null) {
        if (_elementList.length === 0)
            return;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
        const self = this;

        if (_applyElementSelection) {

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                self.selectElementList(_elementList);
            };
            // const self = this;
            // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function()
            // {
            //     self.selectElementList(_elementList);
            //     activeApplication.workspace.update();
            // };
        }

        const attributeNames = Object.keys(_attributeKeyValues).join(',');
        undoAction.createAttributeSnapshot(_elementList, attributeNames);

        for (let i = 0; i < _elementList.length; i++) {
            for (let attributeName in _attributeKeyValues) {
                _elementList[i].setAttribute(attributeName, _attributeKeyValues[attributeName]);
            }
        }

        redoAction.createAttributeSnapshot(_elementList, attributeNames);

        activeApplication.workspace.snapInteraction2D.reset();

        if (_updateWorkspaceTimeout) {
            setTimeout(function () {
                activeApplication.workspace.update();
            }, _updateWorkspaceTimeout)
        } else {

            activeApplication.workspace.update();
        }

        this.onChange();

        return {
            undoAction: undoAction,
            redoAction: redoAction
        };
    }

    setPropertyElementList_undable(_elementList, _propertyKeyValues, _applyElementSelection = true) {
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        if (_applyElementSelection) {
            const self = this;
            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                self.selectElementList(_elementList);
            };
            // const self = this;
            // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function()
            // {
            //     self.selectElementList(_elementList);
            //     activeApplication.workspace.update();
            // };
        }

        const attributeNames = Object.keys(_propertyKeyValues).join(',');
        undoAction.createPropertySnapshot(_elementList, attributeNames);

        for (let i = 0; i < _elementList.length; i++) {
            for (let propertyName in _propertyKeyValues) {
                _elementList[i][propertyName] = _propertyKeyValues[propertyName];
            }
        }

        redoAction.createPropertySnapshot(_elementList, attributeNames);

        activeApplication.workspace.update();
        this.onChange();

        return {
            undoAction: undoAction,
            redoAction: redoAction
        };
    }

    // setPropertyObjectElementList_undable( _elementList ,_propertyName , _propertyValue )
    // {
    //     const validObjectType = this.activePage.focusedElement.dataset.objectType;
    //
    //     const validObjectElementList = [];
    //     let max = _elementList.length;
    //     for ( let i=0; i<max; i++)
    //     {
    //         if( _elementList[i].dataset.objectType === validObjectType ) validObjectElementList.push(_elementList[i]);
    //     }
    //
    //     if(validObjectElementList.length===0) return;
    //
    //     const undoDataList = [];
    //     const redoDataList = [];
    //
    //
    //     max = validObjectElementList.length;
    //     for ( let i=0; i<max; i++)
    //     {
    //         const graphicElement = validObjectElementList[i];
    //         const objectController = OBJECTS[ graphicElement.dataset.objectId ];
    //         let jvsDataNode = graphicElement.querySelector('[data-type="jvs-object-properties"]');
    //         let oldJsonTextData='';
    //         if(jvsDataNode) oldJsonTextData = jvsDataNode.textContent;
    //         const objectProperties = graphicElement.getStoredJsonData('jvs-object-properties') || objectController.properties;
    //         console.log('objectProperties',objectProperties);
    //         objectProperties[ _propertyName ] = _propertyValue;
    //         jvsDataNode = graphicElement.storeJsonData("jvs-object-properties" , objectProperties );
    //         const newJsonTextData = jvsDataNode.textContent;
    //         undoDataList.push({objectController:objectController,graphicElement:graphicElement,jsonTextData:oldJsonTextData,jvsDataNode:jvsDataNode});
    //         redoDataList.push({objectController:objectController,graphicElement:graphicElement,jsonTextData:newJsonTextData,jvsDataNode:jvsDataNode});
    //         objectController.update( graphicElement );
    //     }
    //
    //
    //     const activePage = this.activePage;
    //     const document = this;
    //     const undoAction = {
    //         execute: function () {
    //             const elementToSelect=[];
    //             let itemData;
    //             const max = undoDataList.length;
    //             for ( let i=0; i<max; i++)
    //             {
    //                 itemData=undoDataList[i];
    //                 itemData.jvsDataNode.textContent = itemData.jsonTextData;
    //                 itemData.objectController.update( itemData.graphicElement );
    //                 elementToSelect.push( itemData.graphicElement );
    //             }
    //             document.selectElementList(elementToSelect);
    //         }
    //     };
    //     const redoAction = {
    //         execute: function () {
    //             const elementToSelect=[];
    //             let itemData;
    //             const max = redoDataList.length;
    //             for ( let i=0; i<max; i++)
    //             {
    //                 itemData=redoDataList[i];
    //                 itemData.jvsDataNode.textContent = itemData.jsonTextData;
    //                 itemData.objectController.update( itemData.graphicElement );
    //                 elementToSelect.push( itemData.graphicElement );
    //             }
    //             document.selectElementList(elementToSelect);
    //         }
    //     };
    //
    //     activePage.history.addUndoRedoActions(undoAction, redoAction);
    //
    //     activeApplication.workspace.update();
    //     this.onChange();
    // }

    // setPropertyObjectElementList_undable(_elementList , _propertyKeyValues )
    // {
    //     // serve a scegliere gli oggetti dello stesso tipo
    //     const validObjectID = this.activePage.focusedElement.dataset.objectId;
    //
    //
    //     const validObjectElementList = [];
    //     let max = _elementList.length;
    //     for ( let i=0; i<max; i++)
    //     {
    //         if( _elementList[i].dataset.objectId === validObjectID ) validObjectElementList.push(_elementList[i]);
    //     }
    //
    //
    //
    //     if(validObjectElementList.length===0) return;
    //
    //     const undoDataList = [];
    //     const redoDataList = [];
    //
    //
    //     max = validObjectElementList.length;
    //     for ( let i=0; i<max; i++)
    //     {
    //         const graphicElement = validObjectElementList[i];
    //
    //         let jvsDataNode = graphicElement.querySelector('[data-type="jvs-object-properties"]');
    //
    //         let oldJsonTextData='';
    //         if( jvsDataNode ) oldJsonTextData = jvsDataNode.innerHTML;
    //
    //         const objectController = graphicElement.getObjectController();
    //         objectController.setProperties( _propertyKeyValues );
    //         const newJsonTextData = JSON.stringify( objectController.properties );
    //
    //
    //         // const objectController = graphicElement.getObjectController();
    //         //
    //         // let jvsDataNode = graphicElement.querySelector('[data-type="jvs-object-properties"]');
    //         //
    //         // let oldJsonTextData='';
    //         // if( jvsDataNode ) oldJsonTextData = jvsDataNode.textContent;
    //         //
    //         //
    //         // objectController.update( _propertyKeyValues );
    //
    //
    //         // const objectController = OBJECTS[ graphicElement.dataset.objectId ];
    //         //
    //         // let jvsDataNode = graphicElement.querySelector('[data-type="jvs-object-properties"]');
    //         //
    //         // let oldJsonTextData='';
    //         // if( jvsDataNode ) oldJsonTextData = jvsDataNode.textContent;
    //         //
    //         // objectController.setProperties( graphicElement , _propertyKeyValues );
    //
    //         // const newJsonTextData = jvsDataNode.textContent;
    //         undoDataList.push({objectController:objectController,graphicElement:graphicElement,jsonTextData:oldJsonTextData,jvsDataNode:jvsDataNode});
    //         redoDataList.push({objectController:objectController,graphicElement:graphicElement,jsonTextData:newJsonTextData,jvsDataNode:jvsDataNode});
    //         //objectController.update( graphicElement );
    //     }
    //
    //
    //     const activePage = this.activePage;
    //     const document = this;
    //     const undoAction = {
    //         execute: function () {
    //             const elementToSelect=[];
    //             let itemData;
    //             const max = undoDataList.length;
    //             for ( let i=0; i<max; i++)
    //             {
    //                 itemData=undoDataList[i];
    //                 itemData.jvsDataNode.textContent = itemData.jsonTextData;
    //                 itemData.objectController.update( itemData.graphicElement );
    //                 elementToSelect.push( itemData.graphicElement );
    //             }
    //             if(this.onExecuteEnd)this.onExecuteEnd();
    //             document.selectElementList(elementToSelect);
    //         }
    //     };
    //     const redoAction = {
    //         execute: function () {
    //             const elementToSelect=[];
    //             let itemData;
    //             const max = redoDataList.length;
    //             for ( let i=0; i<max; i++)
    //             {
    //                 itemData=redoDataList[i];
    //                 itemData.jvsDataNode.textContent = itemData.jsonTextData;
    //                 itemData.objectController.update( itemData.graphicElement );
    //                 elementToSelect.push( itemData.graphicElement );
    //             }
    //             if(this.onExecuteEnd)this.onExecuteEnd();
    //             document.selectElementList(elementToSelect);
    //         }
    //     };
    //
    //     activePage.history.addUndoRedoActions(undoAction, redoAction);
    //
    //     activeApplication.workspace.update();
    //     this.onChange();
    //     return {undoAction:undoAction,redoAction:redoAction};
    // }


    setPropertyObjectElementList_undable(_elementList, _propertyKeyValues) {
        // serve a scegliere gli oggetti dello stesso tipo
        const validObjectID = this.activePage.focusedElement.dataset.objectId;

        const validObjectElementList = [];
        let max = _elementList.length;
        for (let i = 0; i < max; i++) {
            if (_elementList[i].dataset.objectId === validObjectID)
                validObjectElementList.push(_elementList[i]);
        }

        if (validObjectElementList.length === 0)
            return;

        const undoDataList = [];
        const redoDataList = [];

        max = validObjectElementList.length;
        for (let i = 0; i < max; i++) {
            const graphicElement = validObjectElementList[i];
            const objectController = graphicElement.getObjectController();
            const oldProperties = {};
            Object.assign(oldProperties, objectController.getProperties());
            objectController.setProperties(_propertyKeyValues);
            const newProperties = {};
            Object.assign(newProperties, objectController.getProperties());

            undoDataList.push({
                graphicElement: graphicElement,
                properties: oldProperties
            });
            redoDataList.push({
                graphicElement: graphicElement,
                properties: newProperties
            });
        }

        const activePage = this.activePage;
        const document = this;
        const undoAction = {
            execute: function () {
                const elementToSelect = [];
                let itemData;
                const max = undoDataList.length;
                for (let i = 0; i < max; i++) {
                    itemData = undoDataList[i];
                    const objectController = itemData.graphicElement.getObjectController();
                    objectController.setProperties(itemData.properties);
                    elementToSelect.push(itemData.graphicElement);
                }
                if (this.onExecuteEnd)
                    this.onExecuteEnd();
                document.selectElementList(elementToSelect);
            }
        };
        const redoAction = {
            execute: function () {
                const elementToSelect = [];
                let itemData;
                const max = redoDataList.length;
                for (let i = 0; i < max; i++) {
                    itemData = redoDataList[i];
                    const objectController = itemData.graphicElement.getObjectController();
                    objectController.setProperties(itemData.properties);
                    elementToSelect.push(itemData.graphicElement);
                }
                if (this.onExecuteEnd)
                    this.onExecuteEnd();
                document.selectElementList(elementToSelect);
            }
        };

        activePage.history.addUndoRedoActions(undoAction, redoAction);

        activeApplication.workspace.update();
        this.onChange();
        return {
            undoAction: undoAction,
            redoAction: redoAction
        };
    }

    // usato solo quando si editano i parametri in inspector
    translateElementList_undable(_elementList, _translateX, _translateY, _localMode) {
        //const elementList =  Array.from( _elementList );
        const undoAction = new UndoRedoAction('translate');
        const redoAction = new UndoRedoAction('translate');
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        const self = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            self.selectElementList(_elementList);
        };

        // const self = this;
        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function()
        // {
        //     self.selectElementList(_elementList);
        //     activeApplication.workspace.update();
        //     self.onChange();
        // };

        undoAction.createAttributeSnapshot(_elementList, 'transform');
        this.translateElementList(_elementList, _translateX, _translateY, _localMode);
        redoAction.createAttributeSnapshot(_elementList, 'transform');

        activeApplication.workspace.update();
        this.onChange();
    };

    // usato solo quando si editano i parametri in inspector
    rotateElementList_undable(_elementList, _rotationValue, _pivotPt) {
        const undoAction = new UndoRedoAction('rotate');
        const redoAction = new UndoRedoAction('rotate');
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        const self = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            self.selectElementList(_elementList);
        };

        // const self = this;
        // undoAction.onExecuteEnd = redoAction.onExecuteEnd = function()
        // {
        //     self.selectElementList(_elementList);
        //     activeApplication.workspace.update();
        //     self.onChange();
        // };

        undoAction.createAttributeSnapshot(_elementList, 'transform');
        this.rotateElementList(_elementList, _rotationValue, _pivotPt);
        redoAction.createAttributeSnapshot(_elementList, 'transform');

        activeApplication.workspace.update();
        this.onChange();

    };

    scaleElementList(_elementList, _scaleX, _scaleY, _pivotPt, _localMode) {
        let element;
        const max = _elementList.length;

        let globalMatrix,
        tempMatrix = SVGUtils.createSVGMatrix();

        for (let i = 0; i < max; i++) {
            element = _elementList[i];

            if (element.storedGlobalMatrix) {
                globalMatrix = element.storedGlobalMatrix.clone();
            } else {
                globalMatrix = element.getCTM();
                if (_localMode)
                    _pivotPt = element.globalToLocal(_pivotPt.x, _pivotPt.y);
            }

            if (_localMode) {

                globalMatrix = globalMatrix.translate(_pivotPt.x, _pivotPt.y);
                globalMatrix = globalMatrix.scaleNonUniform(_scaleX, _scaleY);
                globalMatrix = globalMatrix.translate(-_pivotPt.x, -_pivotPt.y);

            } else {

                tempMatrix = tempMatrix.identity().translate(-_pivotPt.x, -_pivotPt.y);
                globalMatrix = tempMatrix.multiply(globalMatrix);

                tempMatrix = tempMatrix.identity().scaleNonUniform(_scaleX, _scaleY);
                globalMatrix = tempMatrix.multiply(globalMatrix);

                tempMatrix = tempMatrix.identity().translate(_pivotPt.x, _pivotPt.y);
                globalMatrix = tempMatrix.multiply(globalMatrix);
            }

            element.getTransform().setMatrix(element.globalMatrixToLocalMatrix(globalMatrix));
        }

    };

    scaleElementList_undable(_elementList, _scaleX, _scaleY, _pivotPt, _localMode) {
        //const elementList =  Array.from( _elementList );
        const elementList = _elementList;
        const undoAction = new UndoRedoAction('scale');
        const redoAction = new UndoRedoAction('scale');
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        const scaleOptions = {};
        scaleOptions.effectScale = Math.sqrt(_scaleX * _scaleX + _scaleY * _scaleY) / Math.sqrt(2);
        scaleOptions.scaleStrokeAndEffects = this.preferences.scaleStrokeAndEffects;
        scaleOptions.scaleText = this.preferences.scaleText;
        if (_localMode && elementList[0].nodeName === 'text')
            scaleOptions.scaleText = false;

        const undoScaleOptions = {};
        undoScaleOptions.effectScale = 1 / Math.sqrt(_scaleX * _scaleX + _scaleY * _scaleY) * Math.sqrt(2);
        undoScaleOptions.scaleStrokeAndEffects = this.preferences.scaleStrokeAndEffects;
        undoScaleOptions.scaleText = this.preferences.scaleText;
        if (_localMode && elementList[0].nodeName === 'text')
            undoScaleOptions.scaleText = false;

        this.scaleElementList(elementList, _scaleX, _scaleY, _pivotPt, _localMode);
        this.normalizeScaleElementList(elementList, scaleOptions);

        const savedContentMatrix = this.activePage.content.getTransform().matrix.clone();

        const self = this;
        const activePage = this.activePage;

        undoAction.onExecuteEnd = function () {
            const currentContentMatrix = activePage.content.getTransform().matrix.clone();
            activePage.content.getTransform().setMatrix(savedContentMatrix);
            self.scaleElementList(elementList, 1 / _scaleX, 1 / _scaleY, _pivotPt, _localMode);
            self.normalizeScaleElementList(elementList, undoScaleOptions);
            activePage.content.getTransform().setMatrix(currentContentMatrix);
            self.selectElementList(elementList);
        };
        redoAction.onExecuteEnd = function () {
            const currentContentMatrix = activePage.content.getTransform().matrix.clone();
            activePage.content.getTransform().setMatrix(savedContentMatrix);
            self.scaleElementList(elementList, _scaleX, _scaleY, _pivotPt, _localMode);
            self.normalizeScaleElementList(elementList, scaleOptions);
            activePage.content.getTransform().setMatrix(currentContentMatrix);
            self.selectElementList(elementList);
        };

        // this.scalePluginObjects( elementList );

        activeApplication.workspace.update();
        this.onChange();

    };

    // updatePluginObjects( _elementList )
    // {
    //     let element;
    //     const max = _elementList.length;
    //
    //     for( let i = 0; i < max; i++)
    //     {
    //         element = _elementList[i];
    //         if(element.dataset.objectPlugin)
    //         {
    //             const plugin = activeApplication.pluginsManager.plugins[ element.dataset.objectPlugin ];
    //             if( plugin ) plugin.updateRequest( element );
    //             console.log( 'updatePluginObjects',element );
    //         }
    //     }
    // }


    rotateElementList(_elementList, _rotationValue, _pivotPt) {
        let globalMatrix,
        tempMatrix = SVGUtils.createSVGMatrix();

        let element;
        const max = _elementList.length;

        for (let i = 0; i < max; i++) {
            element = _elementList[i];
            if (element.storedGlobalMatrix) {
                globalMatrix = element.storedGlobalMatrix;
            } else {
                globalMatrix = element.getCTM();
            }

            tempMatrix = tempMatrix.identity().translate(-_pivotPt.x, -_pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().rotate(_rotationValue);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().translate(_pivotPt.x, _pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            element.getTransform().setMatrix(element.globalMatrixToLocalMatrix(globalMatrix));
        }

    };

    resetRotationElementList_undable(_elementList) {
        _elementList = _elementList || this.activePage.selectionList;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(_elementList, 'transform');

        let element,
        matrix,
        rotation;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            matrix = element.getTransform().matrix;
            rotation = matrix.getRotation();
            element.getTransform().setMatrix(matrix.rotate(0 - rotation));
        }

        redoAction.createAttributeSnapshot(_elementList, 'transform');
        const activeDocument = this;

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(_elementList);
        };

        activeApplication.workspace.update();
        this.onChange();
    };

    resetTransformElementList_undable(_elementList) {
        _elementList = _elementList || this.activePage.selectionList;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createAttributeSnapshot(_elementList, 'transform');

        let element,
        matrix,
        x,
        y;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            matrix = element.getTransform().matrix;
            x = matrix.e;
            y = matrix.f;
            element.getTransform().setMatrix(matrix.identity().translate(x, y));
        }

        redoAction.createAttributeSnapshot(_elementList, 'transform');

        const activeDocument = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(_elementList);
        };

        activeApplication.workspace.update();
        this.onChange();
    };

    /* POINT EDITING */

    getSelectedTransformablePointData() {
        const activePage = activeApplication.activeDocument.activePage;
        const transformDataPointList = [];
        let element,
        pointList,
        point,
        transformData,
        ip,
        maxp;
        const elementList = activePage.selectionList;
        let i,
        max = elementList.length;

        for (i = 0; i < max; i++) {
            element = elementList[i];
            pointList = element.getSelectedTransformablePointList();
            transformData = {
                element: element,
                pointDataList: []
            };
            maxp = pointList.length;
            for (ip = 0; ip < maxp; ip++) {
                point = pointList[ip];
                transformData.pointDataList.push({
                    point: point,
                    values: {
                        x: point.x,
                        y: point.y
                    }
                });
            }

            if (pointList.length > 0)
                transformDataPointList.push(transformData);
        }

        return transformDataPointList;
    };

    createTransformDataPointList() {
        //this.transformDataPointList = this.getSelectedTransformablePointData();
        const transformDataPointList = this.getSelectedTransformablePointData();

        let transformData,
        element;
        const max = transformDataPointList.length;

        for (let i = 0; i < max; i++) {
            transformData = transformDataPointList[i];
            element = transformData.element;
            element.selectionPreview.geometryPointList = element.getGeometryPointList(); // sposto i punti in interaction element
            element.setGeometryPointList(element.selectionPreview.cloneGeometryPointList()); // clono i punti nell'elemento originale (serviranno solo allo snap a se stesso )
        }

        return transformDataPointList;
    };

    translateTransformDataPointList(_transformDataPointList, _translateX, _translateY, _localMode, _directMode) {

        let pointData,
        point,
        matrix,
        translatePoint,
        pointDataList;

        let transformData,
        element,
        ip,
        maxp;
        let max = _transformDataPointList.length;

        for (let i = 0; i < max; i++) {
            transformData = _transformDataPointList[i];
            element = transformData.element;

            if (_localMode) {
                translatePoint = SVGUtils.createSVGPoint(_translateX, _translateY);
            } else {
                matrix = element.getScreenCTM().inverse();
                translatePoint = SVGUtils.createSVGPoint(_translateX, _translateY).matrixTransform(matrix).subtract(SVGUtils.createSVGPoint().matrixTransform(matrix));
            }

            pointDataList = transformData.pointDataList;
            maxp = pointDataList.length;
            for (ip = 0; ip < maxp; ip++) {
                pointData = pointDataList[ip];
                point = pointData.point;
                point.x += translatePoint.x;
                point.y += translatePoint.y;
            }

            if (_directMode) {
                element.render();
            } else {
                element.selectionPreview.renderRequest();
            }
        }
    }

    translateSelectedPointList_undable(_translateX, _translateY, _localMode, _directMode) {
        const activeDocument = this;
        const activePage = this.activePage;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const selectedElementList = activePage.selectionList;
        undoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        const transformDataPointList = this.getSelectedTransformablePointData();
        this.translateTransformDataPointList(transformDataPointList, _translateX, _translateY, _localMode, _directMode);

        redoAction.createAttributeSnapshot(selectedElementList, 'd,x1,y1,x2,y2');

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };
        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(selectedElementList);
            for (let i = 0; i < selectedElementList.length; i++)
                selectedElementList[i].geometryPointList = null;
        };

        activeApplication.workspace.update();
        this.onChange();

    };

    removePathPoints_undable(_selectedPointList) {
        const activeDocument = this;
        const activePage = this.activePage;

        const ownerPathList = [];
        let i,
        segment,
        ownerPath;

        // extraggo tutte le path proprietarie dei segmenti selezionati e definisco con removable il flag usato per la rimozione successiva
        for (i = 0; i < _selectedPointList.length; i++) {
            segment = _selectedPointList[i];
            segment.removable = true;
            ownerPath = segment.ownerShapeElement;
            if (ownerPath.nodeName === 'path' && ownerPathList.indexOf(ownerPath) === -1)
                ownerPathList.push(ownerPath);
        }

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(ownerPathList);
            for (let i = 0; i < ownerPathList.length; i++)
                ownerPathList[i].geometryPointList = null;
        };

        undoAction.createAttributeSnapshot(ownerPathList, 'd');

        let subPath,
        subPathList,
        subPathPointList,
        newPathGeometryPointList;

        // per ogni path
        for (i = 0; i < ownerPathList.length; i++) {
            ownerPath = ownerPathList[i];

            newPathGeometryPointList = [];
            subPathList = ownerPath.getSubPathList();

            // per ogni subPath
            for (let i2 = 0; i2 < subPathList.length; i2++) {
                subPath = subPathList[i2];
                subPathPointList = subPath.geometryPointList;
                // creo un nuovo Geometry point list excludendo tutti i punti che contengono removable
                for (let i3 = 0; i3 < subPathPointList.length; i3++) {
                    segment = subPathPointList[i3];
                    if (segment.removable) {
                        if (segment.type === 'M' && subPathPointList.length > 1) {
                            const nextSegment = subPathPointList[i3 + 1];
                            if (nextSegment) {
                                segment.x = nextSegment.x;
                                segment.y = nextSegment.y;
                                newPathGeometryPointList.push(segment);
                                nextSegment.removable = true; // sarà il prossimo punto ad essere rimosso
                            }
                        }
                    } else {
                        newPathGeometryPointList.push(segment);
                    }
                    delete segment.removable;
                }
            }
            if (newPathGeometryPointList.length === 0) {
                alert('non ci sono più puntiu')
            }
            ownerPath.setGeometryPointList(newPathGeometryPointList);
            ownerPath.render();
        }

        redoAction.createAttributeSnapshot(ownerPathList, 'd');

        activeApplication.workspace.update();
        this.onChange();
    };

    // addPathPointAtLocation_undable( editablePath , _segment , t )
    // {
    //
    //     const previousSegment = _segment.pt1;
    //     const segmentTarget = _segment.pt2;
    //
    //
    //     console.log('_segment',_segment);
    //
    //     if(segmentTarget.type==='C')
    //     {
    //         t = t || _segment.pointOnSegment.t;
    //
    //         const curve = new Bezier(
    //             previousSegment.x, previousSegment.y,
    //             segmentTarget.controlPt1.x, segmentTarget.controlPt1.y,
    //             segmentTarget.controlPt2.x, segmentTarget.controlPt2.y,
    //             segmentTarget.x, segmentTarget.y);
    //
    //         const result = curve.split(t);
    //
    //         const curveLeft = result.left;
    //         const curveRight = result.right;
    //         let curveLeftToAdd = editablePath.createGeometryPoint_CURVETO_CUBIC(curveLeft.points[1].x, curveLeft.points[1].y, curveLeft.points[2].x, curveLeft.points[2].y, curveLeft.points[3].x, curveLeft.points[3].y);
    //         let curveRightToAdd = editablePath.createGeometryPoint_CURVETO_CUBIC(curveRight.points[1].x, curveRight.points[1].y, curveRight.points[2].x, curveRight.points[2].y, curveRight.points[3].x, curveRight.points[3].y);
    //         // curveLeftToAdd.ownerShapeElement = curveRightToAdd.ownerShapeElement = editablePath;
    //         const geometryPointList = editablePath.getGeometryPointList();
    //
    //         geometryPointList.removeAt(segmentTarget.id);
    //         geometryPointList.addAt(curveLeftToAdd, segmentTarget.id);
    //         geometryPointList.addAt(curveRightToAdd, segmentTarget.id + 1);
    //
    //         editablePath.updateGeometryPointListIds();
    //
    //         const undoAction = new UndoRedoAction();
    //         const redoAction = new UndoRedoAction();
    //         this.activePage.history.addUndoRedoActions(undoAction, redoAction);
    //         const self = this;
    //         undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
    //             self.selectElementList([editablePath]);
    //             editablePath.geometryPointList = null;
    //         };
    //
    //
    //         undoAction.createAttributeSnapshot([editablePath], 'd');
    //
    //         editablePath.render();
    //
    //         redoAction.createAttributeSnapshot([editablePath], 'd');
    //
    //         this.onChange();
    //
    //         return curveLeftToAdd;
    //     }
    //     else if(segmentTarget.type==='L')
    //     {
    //         const newLine = editablePath.createGeometryPoint_LINETO( _segment.pointOnSegment.x , _segment.pointOnSegment.y );
    //         newLine.ownerShapeElement =  editablePath;
    //         const geometryPointList = editablePath.getGeometryPointList();
    //         geometryPointList.addAt(newLine, segmentTarget.id);
    //         editablePath.updateGeometryPointListIds();
    //
    //         const undoAction = new UndoRedoAction();
    //         const redoAction = new UndoRedoAction();
    //         this.activePage.history.addUndoRedoActions(undoAction, redoAction);
    //         const self = this;
    //         undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
    //             self.selectElementList([editablePath]);
    //             editablePath.geometryPointList = null;
    //         };
    //
    //         undoAction.createAttributeSnapshot([editablePath], 'd');
    //
    //         editablePath.render();
    //
    //         redoAction.createAttributeSnapshot([editablePath], 'd');
    //
    //         this.onChange();
    //
    //         return newLine;
    //     }
    //
    //
    // }


    addPathPointAtLocation_undable(editablePath, _segment, t) {
        const addedPoint = editablePath.addPathPointAtLocation(_segment, t);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
        const self = this;
        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            self.selectElementList([editablePath]);
            editablePath.geometryPointList = null;
        };

        undoAction.createAttributeSnapshot([editablePath], 'd');
        editablePath.render();
        redoAction.createAttributeSnapshot([editablePath], 'd');

        this.selectElementList([editablePath]);
        this.selectPointList([addedPoint]);
        addedPoint.editable = true;
        activeApplication.workspace.update();

        this.onChange();

        //return addedPoint;
    }

    splitPathAtLocation_undable(editablePath, _segment, t) {
        const path = editablePath.cloneNode();
        path.setGeometryPointList(editablePath.cloneGeometryPointList());
        const addedPoint = path.addPathPointAtLocation(_segment, t);
        const result = path.splitPathAtPoint(addedPoint);

        if (result.length > 0) {
            this.replaceElement_undable(editablePath, result);
        }
    };

    convertPathSegmentToCurve_undable(segmentToConvert) {
        let editableSegment,
        nextEditableSegment;
        const path = segmentToConvert.ownerShapeElement;

        const pointList = path.getGeometryPointList();

        const idSegmentToConvert = pointList.indexOf(segmentToConvert);

        if (idSegmentToConvert === -1)
            return null;

        let idNextSegmentToConvert = idSegmentToConvert + 1;
        let nextSegmentToConvert = pointList[idNextSegmentToConvert];

        if (!nextSegmentToConvert)
            return null;

        if (nextSegmentToConvert && (nextSegmentToConvert.type === 'Z')) {
            let moveToSegmentId = path.getSubPathMoveToSegmentId(segmentToConvert);
            if (moveToSegmentId === -1)
                return null;
            idNextSegmentToConvert = moveToSegmentId + 1;
            nextSegmentToConvert = pointList[idNextSegmentToConvert];
        }

        const activeDocument = this;
        const activePage = this.activePage;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };
        undoAction.createAttributeSnapshot([path], 'd');

        // current segmentToConvert
        if (segmentToConvert.type === 'L') {
            editableSegment = path.createGeometryPoint_CURVETO_QUADRATIC(segmentToConvert.x, segmentToConvert.y, segmentToConvert.x, segmentToConvert.y);
        } else {
            editableSegment = path.cloneSegment(segmentToConvert);
        }

        // next segmentToConvert
        if (nextSegmentToConvert.type === 'L') {
            nextEditableSegment = path.createGeometryPoint_CURVETO_QUADRATIC(nextSegmentToConvert.x, nextSegmentToConvert.y, nextSegmentToConvert.x, nextSegmentToConvert.y);
        } else {
            nextEditableSegment = path.cloneSegment(nextSegmentToConvert);
        }

        var editableControlPointList = [];

        if (editableSegment.type === 'C') {
            editableSegment.controlPt2.x = segmentToConvert.x;
            editableSegment.controlPt2.y = segmentToConvert.y;
            editableControlPointList.push(editableSegment.controlPt2);
        } else {
            editableSegment.controlPt1.x = segmentToConvert.x;
            editableSegment.controlPt1.y = segmentToConvert.y;
            editableControlPointList.push(editableSegment.controlPt1);
        }

        nextEditableSegment.controlPt1.x = segmentToConvert.x;
        nextEditableSegment.controlPt1.y = segmentToConvert.y;

        editableSegment.ownerShapeElement = nextEditableSegment.ownerShapeElement = path;

        editableControlPointList.push(nextEditableSegment.controlPt1);

        editableControlPointList.reverse();

        pointList.replaceAt(editableSegment, idSegmentToConvert);
        pointList.replaceAt(nextEditableSegment, idNextSegmentToConvert);
        path.render();

        redoAction.createAttributeSnapshot([path], 'd');

        return editableControlPointList;
    };

    convertPathSegmentToCorner_undable(segmentToConvert) {
        let editableSegment,
        nextEditableSegment;
        const path = segmentToConvert.ownerShapeElement;

        const pointList = path.getGeometryPointList();

        const idSegmentToConvert = pointList.indexOf(segmentToConvert);

        if (idSegmentToConvert === -1)
            return false;

        if (segmentToConvert.type === 'M')
            return false;

        let idNextSegmentToConvert = idSegmentToConvert + 1;
        let nextSegmentToConvert = pointList[idNextSegmentToConvert];

        if (!nextSegmentToConvert)
            return false;

        if (nextSegmentToConvert && (nextSegmentToConvert.type === 'Z')) {
            let moveToSegmentId = path.getSubPathMoveToSegmentId(segmentToConvert);
            if (moveToSegmentId === -1)
                return false;
            idNextSegmentToConvert = moveToSegmentId + 1;
            nextSegmentToConvert = pointList[idNextSegmentToConvert];
        }

        const activeDocument = this;
        const activePage = this.activePage;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([path]);
            path.geometryPointList = null;
        };
        undoAction.createAttributeSnapshot([path], 'd');

        // current segmentToConvert
        if (segmentToConvert.type !== 'L') {
            editableSegment = path.createGeometryPoint_LINETO(segmentToConvert.x, segmentToConvert.y);
        } else {
            editableSegment = path.cloneSegment(segmentToConvert);
        }

        // next segmentToConvert
        if (nextSegmentToConvert.type !== 'L') {
            nextEditableSegment = path.createGeometryPoint_LINETO(nextSegmentToConvert.x, nextSegmentToConvert.y);
        } else {
            nextEditableSegment = path.cloneSegment(nextSegmentToConvert);
        }

        editableSegment.ownerShapeElement = nextEditableSegment.ownerShapeElement = path;

        pointList.replaceAt(editableSegment, idSegmentToConvert);
        pointList.replaceAt(nextEditableSegment, idNextSegmentToConvert);
        path.render();

        redoAction.createAttributeSnapshot([path], 'd');

        this.onChange();

        return true;
    };

    replacePathPoint_undable(_newSegment, _segmentToReplace) {
        const activeDocument = this;
        const activePage = this.activePage;

        const ownerShape = _segmentToReplace.ownerShapeElement;
        const geometryPointList = ownerShape.getGeometryPointList();
        const idSegmentToReplace = geometryPointList.indexOf(_segmentToReplace);
        _newSegment.ownerShapeElement = ownerShape;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([ownerShape]);
            ownerShape.geometryPointList = null;
        };

        undoAction.createAttributeSnapshot([ownerShape], 'd');

        geometryPointList.replaceAt(_newSegment, idSegmentToReplace);

        ownerShape.render();

        redoAction.createAttributeSnapshot([ownerShape], 'd');

        activeApplication.workspace.update();
        this.onChange();
    };

    // splitPathAtLocation_undable( _path , _subPathId , _workspaceX , _workspaceY )
    // {
    //     this.deselectAll();
    //
    //     const _location = _path.parentElement.globalToLocal( _workspaceX , _workspaceY  );
    //
    //     const paperScope={};
    //     paper.install(paperScope);
    //     paper.setup([640, 480]);
    //
    //     let subPathList;
    //     let subPathTarget;
    //     let subPathElement;
    //
    //     //_path.removeAttribute('selected');
    //     subPathList = _path.getSubPathList();
    //     subPathTarget = subPathList[ _subPathId ];
    //     // creo un elemento path con solo i punti della subPath
    //     subPathElement = _path.cloneNode();
    //     subPathElement.setGeometryPointList( subPathTarget.geometryPointList );
    //     subPathElement.render();
    //
    //     const pathTarget = paperScope.project.importSVG(subPathElement);
    //
    //     const location = pathTarget.getNearestLocation( _location );
    //
    //     pathTarget.splitAt(location);
    //
    //     const resultList = paperScope.project.layers[0].children;
    //
    //
    //     if(resultList.length===0) return;
    //
    //     let resultPath;
    //     let newPath;
    //     const newPathList = [];
    //
    //     if(subPathList.length===1)
    //     {
    //         for(let i=0; i<resultList.length;i++)
    //         {
    //             resultPath = resultList[i].exportSVG();
    //             resultPath.transformGeometryPointList(  _path.getTransform().matrix.inverse() ); // serve a riportare i punti nello spazio di coordinate della shape originale
    //
    //             newPath = _path.cloneNode();
    //             newPath.setGeometryPointList( resultPath.getGeometryPointList() );
    //             newPath.render();
    //             newPathList.push(newPath);
    //         }
    //     } else {
    //
    //         newPath = _path.cloneNode();
    //
    //         newPath.setSubPathGeometryPointList( _subPathId , [] );
    //
    //         for(let i=0; i<resultList.length;i++)
    //         {
    //             resultPath = resultList[i].exportSVG();
    //             resultPath.transformGeometryPointList(  newPath.getTransform().matrix.inverse() ); // serve a riportare i punti nello spazio di coordinate della shape originale
    //             newPath.setGeometryPointList( newPath.getGeometryPointList().concat( resultPath.getGeometryPointList()  ) );
    //         }
    //         newPathList.push(newPath);
    //
    //         newPath.render();
    //     }
    //
    //
    //     const undoRedoActions = this.replaceElement_undable( _path , newPathList  );
    //
    //     const activeDocument = this;
    //     undoRedoActions.undoAction.onExecuteEnd = function(){activeDocument.selectElementList([_path])};
    //     undoRedoActions.redoAction.onExecuteEnd = function(){activeDocument.selectElementList(newPathList)};
    //
    //     this.selectElementList( [newPath] );
    //
    //     activeApplication.workspace.update();
    //     this.onChange();
    //
    // };


    rotateTransformDataPointList(_transformDataPointList, _rotationValue, _pivotPt, _directMode) {

        let point,
        pointDataList,
        pointData,
        resultPoint,
        resultMatrix,
        globalMatrix,
        tempMatrix = SVGUtils.createSVGMatrix();

        let transformData,
        element,
        ip,
        maxp;
        const max = _transformDataPointList.length;

        for (let i = 0; i < max; i++) {
            transformData = _transformDataPointList[i];
            element = transformData.element;
            globalMatrix = element.getCTM();

            tempMatrix = tempMatrix.identity().translate(-_pivotPt.x, -_pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().rotate(_rotationValue);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().translate(_pivotPt.x, _pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            resultMatrix = element.getCTM().inverse().multiply(globalMatrix); // getTransformToElement

            pointDataList = transformData.pointDataList;
            maxp = pointDataList.length;
            for (ip = 0; ip < maxp; ip++) {
                pointData = pointDataList[ip];
                point = pointData.point;
                resultPoint = point.matrixTransform(resultMatrix);
                point.x = resultPoint.x;
                point.y = resultPoint.y;
            }

            if (_directMode) {
                element.render();
            } else {
                element.selectionPreview.renderRequest();
            }
        }
    }

    scaleTransformDataPointList(_transformDataPointList, _scaleXValue, _scaleYValue, _pivotPt, _directMode) {
        var pointData,
        point,
        resultPoint,
        svgPoint = SVGUtils.createSVGPoint();
        var resultMatrix,
        globalMatrix,
        tempMatrix = SVGUtils.createSVGMatrix();

        var transformData,
        element;
        var max = _transformDataPointList.length;

        for (var i = 0; i < max; i++) {
            transformData = _transformDataPointList[i];
            element = transformData.element;

            globalMatrix = element.getCTM();

            tempMatrix = tempMatrix.identity().translate(-_pivotPt.x, -_pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().scaleNonUniform(_scaleXValue, _scaleYValue);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            tempMatrix = tempMatrix.identity().translate(_pivotPt.x, _pivotPt.y);
            globalMatrix = tempMatrix.multiply(globalMatrix);

            resultMatrix = element.getCTM().inverse().multiply(globalMatrix); // getTransformToElement

            var pointDataList = transformData.pointDataList;
            var maxp = pointDataList.length;
            for (var ip = 0; ip < maxp; ip++) {
                pointData = pointDataList[ip];
                point = pointData.point;
                svgPoint.set(pointData.values.x, pointData.values.y);
                resultPoint = svgPoint.matrixTransform(resultMatrix);
                point.x = resultPoint.x;
                point.y = resultPoint.y;
            }

            //element.renderRequest();
            //element.interactiveElement.renderRequest();

            if (_directMode) {
                element.render();
            } else {
                element.selectionPreview.renderRequest();
            }
        }
    };

    joinPaths_undable(_itemList, _tolerance = 3) {
        const activeDocument = this;
        const activePage = this.activePage;
        _itemList = _itemList || activePage.selectionList;
        this.deselectAll();

        // _itemList = this.sortElementListByLevel(_itemList);

        const pathList = [];
        let element;
        for (let i = 0; i < _itemList.length; i++) {
            element = _itemList[i];
            if (element.nodeName === 'path') {
                const path = element.cloneNode();
                element.parentElement.insertBefore(path, element.nextElementSibling);
                pathList.push(path);
            } else if (element.nodeName === 'line' || (element.nodeName === 'g' && element.dataset.objectId)) {
                function onConversionComplete(convertedPathList) {
                    if (convertedPathList.length > 0) {
                        const path = convertedPathList[0]
                            element.parentElement.insertBefore(path, element.nextElementSibling);
                        pathList.push(path);
                    }
                }

                this.activePage.convertElementListToPath([element], onConversionComplete);
            } else {
                _itemList.removeAt(i);
            }
        }

        if (pathList.length < 2)
            return;

        const pathListToJoin = [];
        // clono l'array delle path da congiungere
        for (let i = 0; i < pathList.length; i++)
            pathListToJoin.push(pathList[i]);
        const resultPath = pathListToJoin[0];
        pathListToJoin.shift();

        function joinPaths() {
            for (let i = 0; i < pathListToJoin.length; i++) {
                if (resultPath.joinPath(pathListToJoin[i], _tolerance)) {
                    pathListToJoin.splice(i, 1);
                    joinPaths();
                }
            }
        }

        joinPaths();
        resultPath.render();
        if (!resultPath.hasAttribute('fill'))
            resultPath.setAttribute('fill', '#FFFFFF');

        const geometryPointList = resultPath.getGeometryPointList();
        const firstSegment = geometryPointList[0];
        const lastSegment = geometryPointList[geometryPointList.length - 1];
        if ((Math.abs(firstSegment.x - lastSegment.x) < _tolerance) && (Math.abs(firstSegment.y - lastSegment.y) < _tolerance)) {
            if (lastSegment.type === 'L')
                geometryPointList.pop();
            geometryPointList.add(resultPath.createGeometryPoint_CLOSEPATH());
            resultPath.render();
            resultPath.geometryPointList = null;
        }

        XOS.removeElementList(pathList);

        this.replaceElementList_undable(_itemList, [resultPath]);

        // const undoRedoActions = this.replaceElementList_undable( _itemList , [resultPath] );
        //
        // undoRedoActions.undoAction.onExecuteEnd = function(){activeDocument.selectElementList(_itemList)};
        // undoRedoActions.redoAction.onExecuteEnd = function(){activeDocument.selectElementList([resultPath])};
        //
        // activeDocument.selectElementList([resultPath]);
        // activeApplication.workspace.update();

    }

    // joinPaths_undable( _itemList )
    //  {
    //      const activeDocument = this;
    //      const activePage = this.activePage;
    //      _itemList = _itemList || activePage.selectionList;
    //      this.deselectAll();
    //
    //      let pathList = XOS.getFilteredElementListByNodeName( _itemList , 'path');
    //      let lineList = XOS.getFilteredElementListByNodeName( _itemList , 'line');
    //      let groupList = XOS.getFilteredElementListByNodeName( _itemList , 'g');
    //
    //      if(groupList.length>0)
    //      {
    //          groupList = this.sortElementListByLevel(groupList);
    //          function onConversionComplete( convertedPathList )
    //          {
    //              activeDocument.replaceElementList_undable( groupList , convertedPathList );
    //              pathList = pathList.concat( convertedPathList );
    //          }
    //
    //          this.activePage.convertElementListToPath( groupList , onConversionComplete );
    //      }
    //
    //      if(lineList.length>0)
    //      {
    //          lineList = this.sortElementListByLevel(lineList);
    //          function onConversionComplete( convertedPathList )
    //          {
    //              activeDocument.replaceElementList_undable( lineList , convertedPathList );
    //              pathList = pathList.concat( convertedPathList );
    //          }
    //          // con le linee e sincrono quindi si può fare
    //          this.activePage.convertElementListToPath(lineList , onConversionComplete );
    //      }
    //
    //      //pathList = GeometryUtils.sortByDeep( pathList );
    //      pathList = this.sortElementListByLevel(pathList);
    //
    //      if(pathList.length<2) return;
    //
    //      const pathListToJoin = [];
    //      for( let i=0; i<pathList.length; i++) pathListToJoin.push(pathList[i]);
    //      const resultPath = pathListToJoin[0].cloneNode();
    //
    //
    //      pathListToJoin[0].parentElement.insertBefore( resultPath, pathListToJoin[0].nextElementSibling); // lo devo inserire
    //      pathListToJoin.shift();
    //
    //      function joinPaths()
    //      {
    //          for(let i=0; i<pathListToJoin.length; i++)
    //          {
    //              if( resultPath.joinPath( pathListToJoin[i] ) )
    //              {
    //                  pathListToJoin.splice( i, 1);
    //                  joinPaths();
    //              }
    //          }
    //      }
    //
    //      joinPaths();
    //      resultPath.render();
    //      resultPath.remove();
    //
    //
    //      const undoRedoActions = this.replaceElementList_undable( pathList , [resultPath] );
    //
    //      undoRedoActions.undoAction.onExecuteEnd = function(){activeDocument.selectElementList(pathList)};
    //      undoRedoActions.redoAction.onExecuteEnd = function(){activeDocument.selectElementList([resultPath])};
    //
    //      activeDocument.selectElementList([resultPath]);
    //      activeApplication.workspace.update();
    //
    //  }


    closePath_undable() {
        const activeDocument = this;
        const activePage = this.activePage;

        if (activePage.focusedElement && activePage.focusedElement.nodeName === 'path') {
            const path = activePage.focusedElement;

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList([path]);
                path.geometryPointList = null;
            };
            undoAction.createAttributeSnapshot([path], 'd');

            if (activePage.focusedPathSegmentPoint) {
                path.closePath(activePage.focusedPathSegmentPoint.subPathId);
            } else {
                path.closePath();
            }

            redoAction.createAttributeSnapshot([path], 'd');

            activeApplication.workspace.update();
        }
    }

    unifyPaths_undable(_pathList) {
        const activeDocument = this;
        const activePage = this.activePage;

        _pathList = _pathList || activePage.selectionList;

        let sourcePathList = XOS.getFilteredElementListByNodeName(_pathList, 'path');

        if (sourcePathList.length < 2)
            return;

        //sourcePathList = GeometryUtils.sortElementListByIndexZ(sourcePathList);
        sourcePathList = this.sortElementListByLevel(sourcePathList);

        const parentElement = sourcePathList[sourcePathList.length - 1].parentElement;
        const nextElement = sourcePathList[sourcePathList.length - 1].nextElementSibling;

        this.deselectAll();

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(sourcePathList);
        };

        undoAction.createDomNodeSnapshot(sourcePathList, 'insert');
        redoAction.createDomNodeSnapshot(sourcePathList, 'delete');

        const newPath = sourcePathList[0].cloneNode();
        parentElement.insertBefore(newPath, nextElement); // lo devo aggiungere al documento per viao della matrice usata dal metodo unify

        for (let i = 1; i < sourcePathList.length; i++)
            newPath.unifyPathSegments(sourcePathList[i]);

        newPath.render();

        XOS.removeElementList(sourcePathList);

        undoAction.createDomNodeSnapshot([newPath], 'delete');
        undoAction.snapshotDataList.reverse();
        redoAction.createDomNodeSnapshot([newPath], 'insert');

        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList([newPath]);
        };

        this.selectElementList([newPath]);

        activeApplication.workspace.update();
    };

    separateSubPaths_undable(_elementList) {
        const activeDocument = this;
        const activePage = this.activePage;

        _elementList = _elementList || activePage.selectionList;

        let sourcePathList = XOS.getFilteredElementListByNodeName(_elementList, 'path');

        if (sourcePathList.length === 0)
            return;

        sourcePathList = this.sortElementListByLevel(sourcePathList);

        this.deselectAll(); // attenzione è dpo per via del fatto che deselectAll setta this.focusedPathSegmentPoint a null

        const path = sourcePathList[0];

        let selectedSubPathId = null;
        if (activePage.focusedPathSegmentPoint)
            selectedSubPathId = path.getSubPathIdBySegment(activePage.focusedPathSegmentPoint);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(sourcePathList);
        };
        undoAction.createDomNodeSnapshot([path], 'insert');
        redoAction.createDomNodeSnapshot([path], 'delete');

        const parentElement = path.parentElement;
        const nextElement = path.nextElementSibling;
        let newPath;
        let createdSVGPathList = [];

        const subPathList = path.getSubPathList();

        parentElement.removeChild(path); // rimuovo la path

        if (selectedSubPathId) {
            // creo la path senza la subPath selezionata
            newPath = path.cloneNode();
            newPath.removeSubPath(selectedSubPathId);
            //parentElement.replaceChild( newPath , path );
            parentElement.appendChild(newPath);
            newPath.render();
            createdSVGPathList.push(newPath);

            // creo la path con la subPath selezionata
            newPath = path.cloneNode();
            newPath.setGeometryPointList(newPath.clonePointList(subPathList[selectedSubPathId].geometryPointList));
            parentElement.appendChild(newPath);
            //parentElement.insertBefore( newPath , nextElement );
            newPath.render();
            createdSVGPathList.push(newPath);
        } else {
            // separo ogni subPath
            for (let i = 0; i < subPathList.length; i++) {
                newPath = path.cloneNode();
                newPath.setGeometryPointList(newPath.clonePointList(subPathList[i].geometryPointList));
                parentElement.appendChild(newPath);
                //parentElement.insertBefore( newPath , nextElement );
                newPath.render();
                createdSVGPathList.push(newPath);
            }

            // parentElement.removeChild( path ); // rimuovo la path
        }

        //createdSVGPathList = CoordsUtils.sortElementListByIndexZ(createdSVGPathList);
        createdSVGPathList.reverse(); // devono essere inseriti al contrario di come sono stati stipati nell'array createdSVGPathList
        undoAction.createDomNodeSnapshot(createdSVGPathList, 'delete');
        undoAction.snapshotDataList.reverse();
        redoAction.createDomNodeSnapshot(createdSVGPathList, 'insert');

        redoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(createdSVGPathList);
        };

        this.selectElementList(createdSVGPathList);
        activeApplication.workspace.update();

    };

    reversePath_undable() {
        const activeDocument = this;
        const activePage = this.activePage;
        const focusedElement = activePage.focusedElement;

        if (focusedElement && focusedElement.nodeName === 'path') {
            const path = focusedElement;

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList([path]);
                path.geometryPointList = null;
            };
            undoAction.createAttributeSnapshot([path], 'd');

            if (activePage.focusedPathSegmentPoint) {
                let selectedSubPathId = path.getSubPathIdBySegment(activePage.focusedPathSegmentPoint);
                //console.log( 'selectedSubPathId', selectedSubPathId );
                if (selectedSubPathId) {
                    path.reverseSegments(selectedSubPathId);
                    activePage.focusedPathSegmentPoint = null;
                }
            } else {
                path.reverseSegments();
            }

            redoAction.createAttributeSnapshot([path], 'd');

            activeApplication.workspace.update();
        }

    };

    bakeTransformElementList_undable(_elementList) {
        _elementList = _elementList || this.activePage.selectionList;
        const activeDocument = this;
        const activePage = this.activePage;
        this.deselectAll();
        let allElementList = [];
        let elementListAsPath = [];
        let element;

        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            if (element.nodeName === 'ellipse' || element.nodeName === 'rect') {
                elementListAsPath.push(element);
            } else {
                allElementList.push(element);
            }
        }

        function doBakeTransform() {
            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            let undoElementList = [].concat(allElementList);
            // nello snapShot vanno aggiunti anche i figli dei gruppi
            for (let i = 0; i < allElementList.length; i++) {
                if (allElementList[i].nodeName === 'g') {
                    undoElementList = undoElementList.concat(_elementList[i].getTransformableChildren());
                }
            }

            undoAction.createAttributeSnapshot(undoElementList, 'd,transform');
            for (let i = 0; i < allElementList.length; i++) {
                // lo devo fare 2 volte se vooglio il centro esatto
                allElementList[i].bakeTransform();
                allElementList[i].bakeTransform();
            }
            redoAction.createAttributeSnapshot(undoElementList, 'd,transform');

            function onExecuteEnd() {
                activeDocument.selectElementList(allElementList);
                for (let i = 0; i < allElementList.length; i++) {
                    if (allElementList[i].nodeName === 'path')
                        allElementList[i].geometryPointList = null;
                }
            }

            undoAction.onExecuteEnd = redoAction.onExecuteEnd = onExecuteEnd;

            activeDocument.selectElementList(allElementList);
            activeApplication.workspace.update();
        }

        if (elementListAsPath.length > 0) {
            elementListAsPath = this.sortElementListByLevel(elementListAsPath);
            function onConversionComplete(convertedPathList) {
                activeDocument.replaceElementList_undable(elementListAsPath, convertedPathList);
                allElementList = allElementList.concat(convertedPathList);
            }
            this.activePage.convertElementListToPath(elementListAsPath, onConversionComplete);

            doBakeTransform();

        } else {
            doBakeTransform();
        }

    };

    resetOriginElementList_undable(_elementList) {
        const activeDocument = this;
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;
        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        let undoElementList = [].concat(_elementList);
        // nello snapShot vanno aggiunti anche i figli dei gruppi
        for (let i = 0; i < _elementList.length; i++) {
            if (_elementList[i].nodeName === 'g') {
                //undoElementList = undoElementList.concat( [].slice.call(_elementList[i].children, 0)  );
                undoElementList = undoElementList.concat(_elementList[i].getTransformableChildren());
            }
        }

        undoAction.createAttributeSnapshot(undoElementList, 'd,x,y,cx,cy,x1,y1,x2,y2,transform');
        for (let i = 0; i < _elementList.length; i++)
            _elementList[i].resetOrigin();
        redoAction.createAttributeSnapshot(undoElementList, 'd,x,y,cx,cy,x1,y1,x2,y2,transform');

        function onExecuteEnd() {
            activeDocument.selectElementList(_elementList);
            for (let i = 0; i < _elementList.length; i++) {
                if (_elementList[i].nodeName === 'path')
                    _elementList[i].geometryPointList = null;
            }
        }

        undoAction.onExecuteEnd = redoAction.onExecuteEnd = onExecuteEnd;

        activeApplication.workspace.update();
        this.onChange();

    };

    groupElementList_undable(_e) {
        const activeDocument = this;
        const activePage = activeDocument.activePage;

        if (activePage.selectionList.length === 0)
            return null;

        if (GeometryUtils.areElementsInEqualParent(activePage.selectionList) !== true) {
            DIALOGS['alertDialog'].open(localString('Invalid operation'), localString('To make a group the elements must be inside the same level or group!'));
            return null;
        }

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        const elementListToGroup = activeDocument.sortElementListByLevel(activePage.selectionList);

        activeDocument.deselectAll();

        undoAction.createDomNodeSnapshot(elementListToGroup, 'insert');
        redoAction.createDomNodeSnapshot(elementListToGroup, 'delete');

        const parentElementTarget = elementListToGroup[0].parentElement;
        const insertBeforeTarget = elementListToGroup[elementListToGroup.length - 1].nextElementSibling;

        const bbox = GeometryUtils.getElementListGlobalBBox(elementListToGroup);
        const centerInParent = parentElementTarget.globalToLocal(bbox.center.x, bbox.center.y);

        XOS.removeElementList(elementListToGroup);

		const newID = 'objg-' + Math.floor(Math.random() * 1000000000) + 1;
        const newGroup = SVGUtils.createGroup(centerInParent.x, centerInParent.y, newID);

        const tempMatrix = SVGUtils.createSVGMatrix().translate(-centerInParent.x, -centerInParent.y);

        let clonedElement;
        let i,
        max = elementListToGroup.length;
        for (i = 0; i < max; i++) {
            clonedElement = elementListToGroup[i].cloneNode(true);
            clonedElement.getTransform().setMatrix(tempMatrix.multiply(clonedElement.getTransform().matrix));
            newGroup.appendChild(clonedElement);
        }

        parentElementTarget.insertBefore(newGroup, insertBeforeTarget);

        undoAction.createDomNodeSnapshot([newGroup], 'delete');
        undoAction.snapshotDataList.reverse();
        redoAction.createDomNodeSnapshot([newGroup], 'insert');

        redoAction.onExecuteEnd = function onExecuteEnd() {
            activeDocument.selectElementList([newGroup]);
        }

        undoAction.onExecuteEnd = function onExecuteEnd() {
            activeDocument.selectElementList(elementListToGroup);
        }

        activeDocument.selectElementList([newGroup]);
        activeApplication.workspace.update();
        activeDocument.onChange();
    }

    ungroupElementList_undable(_elementList) {
        const activeDocument = this;
        const activePage = this.activePage;

        _elementList = _elementList || activePage.selectionList;

        if (_elementList.length === 0)
            return null;

        const groupList = this.sortElementListByLevel(XOS.getFilteredElementListByNodeName(_elementList, 'g'));

        if (groupList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(groupList, 'insert');
        redoAction.createDomNodeSnapshot(groupList, 'delete');

        let idGroup,
        maxGroups,
        currentGroup,
        localGroupMatrix,
        parentElementTarget,
        insertPositionTarget;
        let idChild,
        maxChildren,
        currentChild,
        localChildMatrix,
        clonedChild;
        const newElementList = [];

        maxGroups = groupList.length;
        for (idGroup = 0; idGroup < maxGroups; idGroup++) {
            currentGroup = groupList[idGroup];
            parentElementTarget = currentGroup.parentElement;
            insertPositionTarget = currentGroup.nextElementSibling;
            localGroupMatrix = currentGroup.getTransform().matrix;

            function appendChildren(_children) {
                maxChildren = _children.length;
                for (idChild = 0; idChild < maxChildren; idChild++) {
                    currentChild = _children[idChild];
                    if (currentChild instanceof SVGGraphicsElement) {
                        if (currentChild.nodeName === 'clipPath' || currentChild.nodeName === 'mask')
                            continue;
                        localChildMatrix = currentChild.getTransform().matrix;
                        clonedChild = currentChild.cloneNode(true); // clone child
                        parentElementTarget.insertBefore(clonedChild, insertPositionTarget);
                        clonedChild.getTransform().setMatrix(localGroupMatrix.multiply(localChildMatrix));
                        newElementList.push(clonedChild);
                    }

                }
            }

            appendChildren(currentGroup.children);

            if (currentGroup.hasAttribute('clip-path')) {
                const clipPath = currentGroup.querySelector('clipPath').cloneNode(true);
                appendChildren(clipPath.children);
            } else if (currentGroup.hasAttribute('mask')) {
                const mask = currentGroup.querySelector('mask').cloneNode(true);
                appendChildren(mask.children);
            }

            currentGroup.remove();
        }

        redoAction.createDomNodeSnapshot(newElementList, 'insert');
        redoAction.snapshotDataList.reverse();

        undoAction.createDomNodeSnapshot(newElementList, 'delete');
        undoAction.snapshotDataList.reverse();

        redoAction.onExecuteEnd = function onExecuteEnd() {
            activeDocument.selectElementList(newElementList);
        }

        undoAction.onExecuteEnd = function onExecuteEnd() {
            activeDocument.selectElementList(groupList);
        }

        activeDocument.selectElementList(newElementList);

        activeApplication.workspace.update();
        this.onChange();

        return newElementList;
    };

    expandUseElementList_undable(_elementList) {
        const activeDocument = this;
        const activePage = activeDocument.activePage;

        _elementList = _elementList || activePage.selectionList;

        if (_elementList.length === 0)
            return null;

        //const useElementList = CoordsUtils.sortByDeep( activePage.getFilteredElementListByNodeName( _elementList , 'use'));
        const useElementList = this.sortElementListByLevel(XOS.getFilteredElementListByNodeName(_elementList, 'use'));

        if (useElementList.length === 0)
            return null;

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(useElementList, 'insert');
        redoAction.createDomNodeSnapshot(useElementList, 'delete');

        let idUseElement,
        maxUseElement,
        currentUseElement,
        localUseMatrix,
        parentElementTarget,
        insertPositionTarget;
        let idChild,
        maxChildren,
        currentChild,
        localChildMatrix,
        clonedChild;
        const newElementList = [];

        maxUseElement = useElementList.length;
        for (idUseElement = 0; idUseElement < maxUseElement; idUseElement++) {
            currentUseElement = useElementList[idUseElement];

            const href = currentUseElement.getAttribute('href') || currentUseElement.getAttribute('xlink:href');
            const symbolID = href.split('#')[1];
            const symbolToExpand = activeDocument.resources.getResourceById(symbolID);

            parentElementTarget = currentUseElement.parentElement;
            insertPositionTarget = currentUseElement.nextElementSibling;
            localUseMatrix = currentUseElement.getTransform().matrix;

            function appendChildren(_children) {
                maxChildren = _children.length;
                for (idChild = 0; idChild < maxChildren; idChild++) {
                    currentChild = _children[idChild];
                    localChildMatrix = currentChild.getTransform().matrix;
                    clonedChild = currentChild.cloneNode(true); // clone child
                    parentElementTarget.insertBefore(clonedChild, insertPositionTarget);
                    clonedChild.getTransform().setMatrix(localUseMatrix.multiply(localChildMatrix));
                    newElementList.push(clonedChild);
                }
            }

            appendChildren(symbolToExpand.children);
            currentUseElement.remove();
        }

        //activePage.normalizeScaleElementList(newElementList); // non serve ed incasina lo spessore delle linee

        redoAction.createDomNodeSnapshot(newElementList, 'insert');
        redoAction.snapshotDataList.reverse();

        undoAction.createDomNodeSnapshot(newElementList, 'delete');
        undoAction.snapshotDataList.reverse();

        activeDocument.selectElementList(newElementList);
        activeApplication.workspace.update();
        this.onChange();

        return newElementList;
    };

    convertElementListToPath_undable(_elementList) {
        const activeDocument = this;
        const activePage = this.activePage;

        _elementList = _elementList || activePage.selectionList;

        //const elementListToConvert = this.sortElementListByLevel( XOS.getFilteredElementListByNodeName( _elementList , 'ellipse,rect,line,text') );
        const elementListToConvert = this.sortElementListByLevel(XOS.getFilteredElementListByNodeName(_elementList, 'ellipse,rect,line,text,path,g'));

        if (elementListToConvert.length === 0)
            return;

        activePage.convertElementListToPath(elementListToConvert, onConversionComplete);

        function onConversionComplete(convertedPathList) {
            if (convertedPathList.length === 0)
                return;

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            undoAction.createDomNodeSnapshot(elementListToConvert, 'insert');
            redoAction.createDomNodeSnapshot(elementListToConvert, 'delete');

            const max = elementListToConvert.length;
            for (let i = 0; i < max; i++) {
                elementListToConvert[i].parentElement.replaceChild(convertedPathList[i], elementListToConvert[i]);
            }

            undoAction.createDomNodeSnapshot(convertedPathList, 'delete');
            undoAction.snapshotDataList.reverse();
            redoAction.createDomNodeSnapshot(convertedPathList.reverse(), 'insert');

            undoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(elementListToConvert)
            };
            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(convertedPathList)
            };

            activeDocument.selectElementList(convertedPathList);

            activeApplication.workspace.update();
            activeDocument.onChange();
        }
    };

    convertElementToBitmap(_element, _onCompleteCallback, _margin, _scale) {
        if (!_margin) {
            if (_element.hasAttribute('stroke-width')) {
                _margin = parseFloat(_element.getAttribute('stroke-width')) / 2;
            } else if (_element.hasAttribute('clip-path')) {
                _margin = 0;
            } else if (_element.nodeName === 'image') {
                _margin = 0;
            } else {
                _margin = 20;
            }
        }

        _scale = _scale || 1;

        const activeDocument = this;
        const activePage = activeDocument.activePage;

        let textElementList = [];

        const savedContentMatrix = activePage.content.getTransform().matrix.clone();
        activePage.content.getTransform().matrix.identity();
        const elementBBox = _element.getGlobalBBox();
        const imageWidth = elementBBox.width + _margin * 2;
        const imageHeight = elementBBox.height + _margin * 2;
        const translateX = -elementBBox.x + _margin;
        const translateY = -elementBBox.y + _margin;
        const matrixTranslate = SVGUtils.createSVGMatrix().translate(translateX, translateY);
        const globalMatrix = matrixTranslate.multiply(_element.getTransformToElement(activePage));
        activePage.content.getTransform().setMatrix(savedContentMatrix);

        function onBitmapComplete(_dataURL) {
            const imageElement = document.createElementNS(SVGSVGElement.SVG_NS, "image");
            imageElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', _dataURL);
            const globalMatrix = SVGUtils.createSVGMatrix().translate(elementBBox.x - _margin, elementBBox.y - _margin);
            imageElement.getTransform().setMatrix(globalMatrix);
            _onCompleteCallback(imageElement);
        }

        function convertElementToBitmap(elementToGetAsBitmap) {
            const svg = activePage.createSVG(Math.round(imageWidth), Math.round(imageHeight));
            svg.appendChild(activeDocument.resources.querySelector('defs').cloneNode(true));
            //let elementToGetAsBitmap = _element.cloneNode(true);
            elementToGetAsBitmap.getTransform().setMatrix(globalMatrix);
            svg.appendChild(elementToGetAsBitmap);
            svg.getAsBitmap(onBitmapComplete);
        }

        if (_element.nodeName === 'text') {
            this.convertElementListToPath([_element], function (convertedPathList) {
                convertElementToBitmap(convertedPathList[0])
            });
        } else {
            textElementList = _element.querySelectorAll('text'); // se l'elemento è un gruppo potrebbe avere dei testi da convertire in bitmap (al momento i testi dentro i simboli eentualmente contenuti nell'elemento non vengono convertiti in paths)

            if (textElementList.length > 0) {
                function onConversionTextToPathComplete(convertedPathList) {
                    // converto i testi in path
                    for (let i = 0; i < textElementList.length; i++)
                        textElementList[i].parentElement.replaceChild(convertedPathList[i], textElementList[i]);
                    convertElementToBitmap(_element.cloneNode(true));
                    // ripristino i testi originali
                    for (let i = 0; i < convertedPathList.length; i++)
                        convertedPathList[i].parentElement.replaceChild(textElementList[i], convertedPathList[i]);
                }

                this.convertElementListToPath(textElementList, onConversionTextToPathComplete);
            } else {
                convertElementToBitmap(_element.cloneNode(true))
            }
        }

    };

    convertElementToBitmap_undable(_element) {
        const activeDocument = this;
        const activePage = activeDocument.activePage;

        function onConversionComplete(_imageElement) {
            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();

            undoAction.createDomNodeSnapshot([_element], 'insert');
            redoAction.createDomNodeSnapshot([_element], 'delete');
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            _element.parentNode.insertBefore(_imageElement, _element);
            _imageElement.getTransform().setMatrix(_imageElement.getTransformToElement(_element.parentNode));

            _element.parentNode.removeChild(_element);

            undoAction.createDomNodeSnapshot([_imageElement], 'delete');
            undoAction.snapshotDataList.reverse();
            redoAction.createDomNodeSnapshot([_imageElement], 'insert');

            // activePage.selectElementList( [_imageElement] );
            // activePage.updateInteraction();

            setTimeout(function () {
                activeDocument.selectElementList([_imageElement]);
                activeApplication.workspace.update();
            }, 100);
        }

        this.deselectAll();

        this.convertElementToBitmap(_element, onConversionComplete);
    };

    // createUndoRedoElementListSelection( _elementList , _undoAction , _redoAction )
    // {
    //     const activeDocument = this;
    //     _undoAction.onExecuteEnd = _redoAction.onExecuteEnd = function() { activeDocument.selectElementList(_elementList);};
    // }

    centerElementListAtGlobalPoint(_elementList, _x, _y) {
        if (_elementList.length > 0) {
            const bbox = GeometryUtils.getElementListGlobalBBox(_elementList);
            const tranlationX = _x - bbox.center.x;
            const tranlationY = _y - bbox.center.y;
            this.translateElementList(_elementList, tranlationX, tranlationY);
            activeApplication.workspace.update();
            this.onChange();
        }
    };

    scaleAndRotateByLine(_element, _LineElement) {
        const pointList = _LineElement.getGeometryPointList();
        const pointListInParent = _LineElement.getTransformToElement(_element.parentElement).transformPointList(pointList, true);
        const width = pointListInParent[1].getDistanceFromPoint(pointListInParent[0]);
        if (!_element.startWidth) {
            _element.startWidth = width;
            return;
        }

        const angleDeg = GeometryUtils.getAngleBetweenPoints(pointListInParent[1], pointListInParent[0]) / (Math.PI / 180);
        let matrix = _element.getTransform().matrix.identity().translate(pointListInParent[0].x, pointListInParent[0].y).rotate(angleDeg);
        matrix = matrix.scaleNonUniform(width / _element.startWidth * this.activePage.content.currentScale, 1 * this.activePage.content.currentScale);
        _element.getTransform().setMatrix(matrix);
    }

    normalizeScaleElementList(_elementList, _options) {
        if (!_options) {
            _options = {};
            _options.scaleStrokeAndEffects = this.preferences.scaleStrokeAndEffects;
            _options.scaleText = this.preferences.scaleText;
        }
        const max = _elementList.length;
        let i;
        for (i = 0; i < max; i++)
            _elementList[i].prepareToNormalizeScale(_options);
        for (i = 0; i < max; i++)
            _elementList[i].normalizeScale(_options);
        for (i = 0; i < max; i++)
            if (_elementList[i].normalizationData)
                delete _elementList[i].normalizationData;
    };

    pan(dx, dy) {
        const mat = this.activePage.content.getTransform().matrix;
        mat.e += dx;
        mat.f += dy;
        activeApplication.workspace.pageBackground.getTransform().setMatrix(mat);
        //activeApplication.workspace.updateOrigin();

        if (activeApplication.activeDocument.preferences.rulersVisibility) // senza righelli niente griglia
        {
            const rulerInfo = activeApplication.editingView.redrawRulers();
            activeApplication.editingView.gridPattern.setAttribute('patternTransform', 'matrix(1 0 0 1 ' + rulerInfo.horizontalRulerInfo.origin + ' ' + rulerInfo.verticalRulerInfo.origin + ')');
        }

        TOOLS.activeTool.onDocumentViewChange();
    }

    zoom(scale, _centerX, _centerY) {
        const currentContentScale = this.activePage.content.currentScale;
        const nextContentScale = currentContentScale * scale;
        if ((nextContentScale > 250) || (nextContentScale < 0.01))
            return;

        this.activePage.content.currentScale = nextContentScale; // salvo questa in quanto mi può tornare utile

        const mat = this.activePage.content.getTransform().matrix;
        mat.a *= scale;
        mat.b *= scale;
        mat.c *= scale;
        mat.d *= scale;
        mat.e *= scale;
        mat.f *= scale;
        mat.e += (1 - scale) * _centerX;
        mat.f += (1 - scale) * _centerY;

        activeApplication.workspace.pageBackground.getTransform().setMatrix(mat);

        activeApplication.editingView.redrawRulersAndGrid();

        TOOLS.activeTool.onDocumentViewChange();
    }

    hideElementsNotInViewport() {
        this.activePage.classList.remove('only-viewport');
        this.activePage.classList.add('check-viewport');
        //if( ! this.elementListInViewport ) this.elementListInViewport =  this.elementListInViewport || this.activePage.querySelectorAll('.in-viewport');

        if (this.elementListInViewport)
            for (let i = 0; i < this.elementListInViewport.length; i++)
                this.elementListInViewport[i].classList.remove('in-viewport');
        // si potrebbe dire di mostrare solo gli elementi presenti nel layer attivo e nascondere i layers non attivi durante lo zoom
        this.elementListInViewport = this.activePage.getIntersectionList(this.workspaceBounding, null);
        for (let i = 0; i < this.elementListInViewport.length; i++)
            this.elementListInViewport[i].classList.add('in-viewport');
        this.activePage.classList.add('only-viewport');
        this.activePage.classList.remove('check-viewport');
    }

    // updateOrigin( )
    // {
    //     // const globalOrigin = this.pageToWorkspaceCoords( {contentX:this.preferences.origin.x, contentY:this.preferences.origin.y}  );
    //     // this.originXY.firstElementChild.updateGeometry(  0, globalOrigin.y, activeApplication.workspace.bounding.width, globalOrigin.y );
    //     // this.originXY.firstElementChild.nextElementSibling.updateGeometry(  globalOrigin.x,0, globalOrigin.x ,activeApplication.workspace.bounding.height );
    //     // if( Math.abs(this.preferences.origin.x -  this.preferences.origin.y)< 0.001 )
    //     // {
    //     //     this.setPageOriginVisibility( false );
    //     // }
    //     // else {
    //     //     this.setPageOriginVisibility( true );
    //     // }
    // };


    getPagePreview(_page, _maxWidth, _maxHeight) {

        _page = _page || this.activePage;
        if (_page.preview)
            return _page.preview;

        _maxWidth = _maxWidth || 80;
        _maxHeight = _maxHeight || 80;

        const pageWidth = _page.dataset.pageWidth;
        const pageHeight = _page.dataset.pageHeight;
        const scale = Math.min(_maxWidth / pageWidth, _maxHeight / pageHeight);

        const svg = _page.cloneNode(true);

        const imageList = svg.querySelectorAll('image[*|href^="http"]');

        //console.log('updatePreview imageList',imageList);
        const imageAlternative = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABXklEQVRYR+2Uvy5FQRCHv1vqbq/w5wloRCN4AvEEKHQKpY7CA9CJhjfgDe7N7UQiXkCotDRyO5Ffsldknd0Z2XPcZqc5ydndmW/mNzM9YMwUrRcAZqbEMK4AtQK1Al1W4AA4Aj6BU+CyYdQ7G8NF4CkKOAu8Rv86A1gDRlGwFeC+BKAPbAC3zq35ACyHu3fAaqkEh8BxcPrigBDwfuiBC+CjFEBB54BHYBN4d0BYV9w9sAtc/fB2DexZ3h3nboAhsB45FIBASswFoMYbNESRBJJCksQm/T0SuQDU9VuJNJv64QzYARYcECbAPPBs1FiA24CyvgmjqieT/7nnJoA0VjaWKWtJtRRdFFhub2QBlNGbFdk41+hqGaX6IQtwEhZPIQPngJZYkyUBlL2017cN07RolGNLAsSLpxQiJUUWQBPQpqkZ451hTkGbAH/qga4DT/zXCtQKfFfgv5ruV5wvelhvAbHhJ0UAAAAASUVORK5CYII=";

        for (let i = 0; i < imageList.length; i++) {
            imageList[i].setAttributeNS(SVGSVGElement.XLINK_NS, 'href', imageAlternative);
            imageList[i].setAttribute('preserveAspectRatio', 'none');
        }

        svg.setAttribute('width', Math.round(pageWidth * scale));
        svg.setAttribute('height', Math.round(pageHeight * scale));
        const svgTransform = svg.querySelector('.content').getTransform();
        svgTransform.setMatrix(svgTransform.matrix.identity().scale(scale));

        svg.appendChild(this.resources.querySelector('defs').cloneNode(true));

        const xml = new XMLSerializer().serializeToString(svg).normalize('NFD').replace(/[\u00A0-\u2666]/g, function (c) {
            return '&#' + c.charCodeAt(0) + ';';
        });
        //console.log('getPagePreview',xml);
        //if(!_page.preview) _page.preview = new Image();
        _page.preview = new Image();
        _page.preview.src = 'data:image/svg+xml;base64,' + btoa(xml);
        return _page.preview;
    };

    convertPageToBitmap(_page, _onCompleteCallback, _mimeType, _asBlob) {
        _page = _page || this.activePage;

        function onBitmapComplete(_imageBlobOrDataURL) {
            _onCompleteCallback(_imageBlobOrDataURL);
        }

        function startConversionToBitmap() {
            const svgToGetAsBitmap = _page.createSVG(_page.dataset.pageWidth, _page.dataset.pageHeight);
            svgToGetAsBitmap.appendChild(activeApplication.activeDocument.resources.querySelector('defs').cloneNode(true));
            svgToGetAsBitmap.appendChild(_page.querySelector('.layers').cloneNode(true));
            svgToGetAsBitmap.getAsBitmap(onBitmapComplete, _mimeType, 1, _asBlob);
        }

        let textElementList = _page.querySelectorAll('text');

        if (textElementList.length > 0) {
            function onConversionTextToPathComplete(convertedPathList) {
                for (let i = 0; i < textElementList.length; i++)
                    textElementList[i].parentElement.replaceChild(convertedPathList[i], textElementList[i]);
                startConversionToBitmap();
                for (let i = 0; i < convertedPathList.length; i++)
                    convertedPathList[i].parentElement.replaceChild(textElementList[i], convertedPathList[i]);
            }

            _page.convertElementListToPath(textElementList, onConversionTextToPathComplete);

        } else {
            startConversionToBitmap()
        }
    };

    refactorElementID(_sourceElement, _newID, _rootNode) {
        _rootNode = _rootNode || this.shadowRoot;

        const oldID = _sourceElement.getAttribute('id');

        _sourceElement.setAttribute('id', _newID);

        let referencedElementList;

        switch (_sourceElement.nodeName) {
        case 'symbol':
            referencedElementList = _rootNode.querySelectorAll('use[href="#' + oldID + '"]');
            this.setAttributeElementList(referencedElementList, {
                'href': '#' + _newID
            });
            break;
        case 'filter':
            referencedElementList = _rootNode.querySelectorAll('*[filter*="#' + oldID + '"]');
            this.setAttributeElementList(referencedElementList, {
                'filter': 'url(#' + _newID + ')'
            });
            break;
        case 'marker':
            referencedElementList = _rootNode.querySelectorAll('*[marker-start*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'marker-start': 'url(#' + _newID + ')'
            });
            referencedElementList = _rootNode.querySelectorAll('*[marker-mid*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'marker-mid': 'url(#' + _newID + ')'
            });
            referencedElementList = _rootNode.querySelectorAll('*[marker-end*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'marker-end': 'url(#' + _newID + ')'
            });
            break;
        case 'linearGradient':
        case 'radialGradient':
        case 'pattern':
            referencedElementList = _rootNode.querySelectorAll('*[fill*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'fill': 'url(#' + _newID + ')'
            });
            referencedElementList = _rootNode.querySelectorAll('*[stroke*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'stroke': 'url(#' + _newID + ')'
            });
            break;

        default:
            referencedElementList = _rootNode.querySelectorAll('*[clip-path*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'clip-path': 'url(#' + _newID + ')'
            });
            referencedElementList = _rootNode.querySelectorAll('*[mask*="url(#' + oldID + ')"]');
            this.setAttributeElementList(referencedElementList, {
                'mask': 'url(#' + _newID + ')'
            });
            referencedElementList = _rootNode.querySelectorAll('*[*|href="#' + oldID + '"]');
            this.setAttributeElementList(referencedElementList, {
                'href': '#' + _newID
            });
            break;
        }

        return referencedElementList;
    }

    // qui non non aggiung gli element in quanto viene usato da paste con oggetti già inseriti
    /* addElementList_undable( _elementList  )
{
    if( _elementList.length===0 ) return null;

    const undoAction = new UndoRedoAction();
    const redoAction = new UndoRedoAction();
    this.activePage.history.addUndoRedoActions( undoAction , redoAction );

    const max = _elementList.length;
    for (let i = 0; i < max; i++) {
    undoAction.createDomNodeSnapshot( [_elementList[i]]  , 'delete' );
    redoAction.createDomNodeSnapshot( [_elementList[i] ] , 'insert') ;
    // qui non fa niente in quanto viene usato da paste con oggetti già inseriti
    }

    redoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

    const activeDocument = this;
    redoAction.onExecuteEnd = function(){activeDocument.selectElementList(_elementList)};

    activeApplication.workspace.update();
    this.onChange();

    }*/

    removeElementList_undable(_elementList) {
        if (_elementList.length === 0)
            return null;

        this.deselectAll();

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        const max = _elementList.length;
        for (let i = 0; i < max; i++) {
            undoAction.createDomNodeSnapshot([_elementList[i]], 'insert');
            redoAction.createDomNodeSnapshot([_elementList[i]], 'delete');
            _elementList[i].remove();
            //  this.removeElementList( [_elementList[i]] );

        }

        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato

        const activeDocument = this;
        undoAction.onExecuteEnd = function () {
            activeDocument.selectElementList(_elementList)
        };

        activeApplication.workspace.update();
        this.onChange();

    }

    replaceElementList_undable(_elementListToReplace, _elementListToInsert, _selectElementList = true) {
        _elementListToReplace = this.sortElementListByLevel(_elementListToReplace);

        const undoAction = new UndoRedoAction('undo replace element list');
        const redoAction = new UndoRedoAction('redo replace element list');
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(_elementListToReplace, 'insert');
        redoAction.createDomNodeSnapshot(_elementListToReplace, 'delete');

        let max = _elementListToReplace.length;

        const parentElement = _elementListToReplace[max - 1].parentElement;
        const nextElement = _elementListToReplace[max - 1].nextElementSibling;

        for (let i = 0; i < max; i++)
            _elementListToReplace[i].parentElement.removeChild(_elementListToReplace[i]);

        max = _elementListToInsert.length;
        for (let i = 0; i < max; i++)
            parentElement.insertBefore(_elementListToInsert[i], nextElement);

        undoAction.createDomNodeSnapshot(_elementListToInsert, 'delete');
        redoAction.createDomNodeSnapshot(_elementListToInsert, 'insert');

        redoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo inserito
        undoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo inserito

        const activeDocument = this;

        if (_selectElementList) {
            undoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(_elementListToReplace)
            };
            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(_elementListToInsert)
            };
        }

        this.selectElementList(_elementListToInsert);

        activeApplication.workspace.update();
        activeDocument.onChange();

        return {
            undoAction: undoAction,
            redoAction: redoAction
        };

    };

    replaceElement_undable(_elementToReplace, _elementListToInsert, _selectElementList = true) {
        const undoAction = new UndoRedoAction('undo replace element');
        const redoAction = new UndoRedoAction('redo replace element');
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);

        const parentElementTarget = _elementToReplace.parentElement;
        const insertBeforeTarget = _elementToReplace.nextElementSibling;

        undoAction.createDomNodeSnapshot([_elementToReplace], 'insert');
        redoAction.createDomNodeSnapshot([_elementToReplace], 'delete');

        XOS.removeElementList([_elementToReplace]);

        const max = _elementListToInsert.length;
        for (let i = 0; i < max; i++) {
            parentElementTarget.insertBefore(_elementListToInsert[i], insertBeforeTarget);
        }

        undoAction.createDomNodeSnapshot(_elementListToInsert, 'delete');
        redoAction.createDomNodeSnapshot(_elementListToInsert, 'insert');

        redoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo inserito

        const activeDocument = this;

        if (_selectElementList) {
            undoAction.onExecuteEnd = function () {
                activeDocument.selectElementList([_elementToReplace])
            };
            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(_elementListToInsert)
            };
        }

        this.selectElementList(_elementListToInsert);

        activeApplication.workspace.update();
        activeDocument.onChange();

        return {
            undoAction: undoAction,
            redoAction: redoAction
        };

    };

    placeImage_undable(_dataURL, _imageWidth, _imageHeight, _onPlacedCallback) {
        const activePage = this.activePage;
        const currentLayer = this.getActivePageLayer();
        const self = this;
        function onImageCompleteReady() {
            newImageElement.resetOrigin();
            self.selectElementList([newImageElement]);
            self.centerElementListAtGlobalPoint([newImageElement], self.workspaceBounding.width / 2, self.workspaceBounding.height / 2);
            activeApplication.workspace.snapInteraction2D.reset();
            activeApplication.workspace.update();
            if (_onPlacedCallback)
                _onPlacedCallback(newImageElement);
        }

        const newImageElement = SVGUtils.createImage(_dataURL, 0, 0, _imageWidth, _imageHeight, onImageCompleteReady);
        newImageElement.dataset.mantainAspectRatio = 'true';
        currentLayer.appendChild(newImageElement);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);
        redoAction.onExecuteEnd = function () {
            self.selectElementList([newImageElement])
        };

        redoAction.createDomNodeSnapshot([newImageElement], 'insert');
        undoAction.createDomNodeSnapshot([newImageElement], 'delete');
        this.onChange();
    };

    importLocalImageAsDataURL_undable(_onPlacedCallback) {

        const self = this;

        function onOpenFile(_e) {
            LOCAL_FILE_SYSTEM.readImageFileAsDataUrl(_e.target.files[0], function (_dataURL) {
                self.placeImage_undable(_dataURL, null, null, _onPlacedCallback);
            });
        }
        LOCAL_FILE_SYSTEM.chooseFile("image/*", onOpenFile);
    };

    createMaskedContent(_elementList, _maskID) {

        if (_elementList.length < 2)
            return null;

        if (GeometryUtils.areElementsInEqualParent(_elementList) !== true) {
            DIALOGS['alertDialog'].open(localString('Invalid operation'), localString('To make a masked content the elements must be inside the same level or group!'));
            return null;
        }

        // _elementList = CoordsUtils.sortElementListByIndexZ(_elementList);
        _elementList = this.sortElementListByLevel(_elementList);

        if (!_elementList)
            return;

        let elementToMask = _elementList[0];
        const parentTarget = elementToMask.parentElement;

        const mask = SVGUtils.createMask(_maskID);

        const maskedContent = SVGUtils.createGroup();
        maskedContent.getTransform().setMatrix(elementToMask.getTransform().matrix.clone());
        parentTarget.appendChild(maskedContent);
        maskedContent.appendChild(mask);
        const newMaskTargetMatrix = elementToMask.getTransformToElement(maskedContent);
        elementToMask = elementToMask.cloneNode(true);
        maskedContent.appendChild(elementToMask);
        elementToMask.getTransform().setMatrix(newMaskTargetMatrix);

        function addGraphicElementToMask(_graphicElementToAdd) {
            //const newGraphicElementMatrix = _graphicElementToAdd.getTransformToElement( mask );
            const newGraphicElementMatrix = _graphicElementToAdd.getTransformToElement(maskedContent);
            _graphicElementToAdd = _graphicElementToAdd.cloneNode(true);
            mask.appendChild(_graphicElementToAdd);
            _graphicElementToAdd.getTransform().setMatrix(newGraphicElementMatrix);
        }

        for (let i = 1; i < _elementList.length; i++)
            addGraphicElementToMask(_elementList[i]);

        maskedContent.setAttribute('mask', 'url(#' + _maskID + ')');
        return maskedContent;
    };

    createMaskedContent_undable(_elementList, _maskID) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;
        if (_elementList.length < 2)
            return null;

        _maskID = _maskID || XOS.createUniqueIDI('mask');

        this.deselectAll();

        //_elementList = CoordsUtils.sortByDeep( _elementList );
        _elementList = this.sortElementListByLevel(_elementList);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');

        const newGroup = this.createMaskedContent(_elementList, _maskID);

        XOS.removeElementList(_elementList);
        if (newGroup) {
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            undoAction.createDomNodeSnapshot([newGroup], 'delete');
            undoAction.snapshotDataList.reverse();
            redoAction.createDomNodeSnapshot([newGroup], 'insert');

            this.selectElementList([newGroup]);
            activeApplication.workspace.update();
        }
    };

    createClippedContent(_elementList, _clipPathID) {
        if (_elementList.length < 2)
            return null;

        if (GeometryUtils.areElementsInEqualParent(_elementList) !== true) {
            DIALOGS['alertDialog'].open(localString('Invalid operation'), localString('To make a clipped content the elements must be inside the same level or group!'));
            return null;
        }

        // _elementList = [].slice.call(_elementList, 0);
        // _elementList = CoordsUtils.sortElementListByIndexZ(_elementList);
        _elementList = this.sortElementListByLevel(_elementList);

        if (!_elementList)
            return;

        let elementToClip = _elementList[0];
        const parentTarget = elementToClip.parentElement;

        // var clipPathID = CreateUniqueIDI();
        const clipPath = SVGUtils.createClipPath(_clipPathID);

        const clippedContent = SVGUtils.createGroup();
        clippedContent.getTransform().setMatrix(elementToClip.getTransform().matrix.clone());
        parentTarget.appendChild(clippedContent);
        clippedContent.appendChild(clipPath);
        const newClipPathTargetMatrix = elementToClip.getTransformToElement(clippedContent);
        elementToClip = elementToClip.cloneNode(true);
        clippedContent.appendChild(elementToClip);
        elementToClip.getTransform().setMatrix(newClipPathTargetMatrix);

        function addGraphicElementToClipPath(_graphicElementToAdd) {
            const newGraphicElementMatrix = _graphicElementToAdd.getTransformToElement(clipPath);
            _graphicElementToAdd = _graphicElementToAdd.cloneNode(true);
            clipPath.appendChild(_graphicElementToAdd);
            _graphicElementToAdd.getTransform().setMatrix(newGraphicElementMatrix);
        }

        for (let i = 1; i < _elementList.length; i++)
            addGraphicElementToClipPath(_elementList[i]);

        clippedContent.setAttribute('clip-path', 'url(#' + _clipPathID + ')');
        return clippedContent;
    };

    createClippedContent_undable(_elementList, _clipPathID) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;
        if (_elementList.length < 2)
            return null;

        _clipPathID = _clipPathID || XOS.createUniqueIDI('clipPath');

        this.deselectAll();

        //_elementList = CoordsUtils.sortByDeep( _elementList );
        _elementList = this.sortElementListByLevel(_elementList);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');

        const newGroup = this.createClippedContent(_elementList, _clipPathID);

        XOS.removeElementList(_elementList);

        if (newGroup) {
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            undoAction.createDomNodeSnapshot([newGroup], 'delete');
            undoAction.snapshotDataList.reverse();
            redoAction.createDomNodeSnapshot([newGroup], 'insert');

            this.selectElementList([newGroup]);
            activeApplication.workspace.update();
        }
    };

    createSymbolFromElementList(_elementList, _symbolID, _scale) {
        if (_elementList.length === 0)
            return null;

        _scale = 1;

        const idSymbol = _symbolID || XOS.createUniqueIDI('symbol');

        this.deselectAll();

        const newSymbol = SVGUtils.createSymbol(idSymbol);
        const activePage = this.activePage;
        this.scaleElementList(_elementList, _scale, _scale, {
            x: activePage.clientWidth / 2,
            y: activePage.clientHeight / 2
        });

        let element;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            newSymbol.appendChild(_elementList[i].cloneNode(true));
        }

        this.resources.addResource(newSymbol);

        const useSymbol = SVGUtils.createUse(idSymbol);

        XOS.removeElementList(_elementList);
        this.getActivePageLayer().appendChild(useSymbol);
        activeApplication.workspace.update();
    };

    createSymbol_undable(_elementList, _symbolID) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;
        if (_elementList.length === 0)
            return null;

        const idSymbol = _symbolID || XOS.createUniqueIDI('symbol');

        this.deselectAll();

        //_elementList = [].slice.call(_elementList, 0);
        // _elementList = CoordsUtils.sortElementListByIndexZ(_elementList);
        _elementList = this.sortElementListByLevel(_elementList);

        const parentElement = _elementList[0].parentElement;
        const nextElement = _elementList[_elementList.length - 1].nextElementSibling;

        const newSymbol = SVGUtils.createSymbol(idSymbol);

        const bbox = GeometryUtils.getElementListGlobalBBox(_elementList);

        const pt = activePage.content.globalToLocal(bbox.x, bbox.y);

        this.translateElementList(_elementList, -pt.x, -pt.y, true);

        let element;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            newSymbol.appendChild(_elementList[i].cloneNode(true));
        }

        this.translateElementList(_elementList, pt.x, pt.y, true);

        this.resources.addResource(newSymbol);

        const useSymbol = SVGUtils.createUse(idSymbol);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');
        XOS.removeElementList(_elementList);

        parentElement.insertBefore(useSymbol, nextElement);

        this.translateElementList([useSymbol], pt.x, pt.y, true);

        undoAction.createDomNodeSnapshot([useSymbol], 'delete');
        undoAction.createDomNodeSnapshot([newSymbol], 'delete');
        undoAction.snapshotDataList.reverse(); // le azioni di undo devono essere eseguite in ordine inverso
        redoAction.createDomNodeSnapshot([newSymbol], 'insert');
        redoAction.createDomNodeSnapshot([useSymbol], 'insert');

        this.selectElementList([useSymbol]);
        activeApplication.workspace.update();

    };

    createPattern_undable(_elementList, _patternID) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;
        if (_elementList.length === 0)
            return null;

        const idPattern = _patternID || XOS.createUniqueIDI('pattern');

        this.deselectAll();

        const bbox = GeometryUtils.getElementListGlobalBBox(_elementList);
        const pt = activePage.content.globalToLocal(bbox.x, bbox.y);

        const newPattern = SVGUtils.createPattern(idPattern, 0, 0, bbox.width * (1 / activePage.content.currentScale), bbox.height * (1 / activePage.content.currentScale));

        this.translateElementList(_elementList, -pt.x, -pt.y, true);

        let element;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            newPattern.appendChild(_elementList[i].cloneNode(true));
        }

        this.translateElementList(_elementList, pt.x, pt.y, true);

        this.resources.addResource(newPattern);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');
        XOS.removeElementList(_elementList);

        undoAction.createDomNodeSnapshot([newPattern], 'delete');
        undoAction.snapshotDataList.reverse(); // le azioni di undo devono essere eseguite in ordine inverso
        redoAction.createDomNodeSnapshot([newPattern], 'insert');

        this.enterTo_isolateLayerEditing(newPattern);

        activeApplication.workspace.update();

    };

    createMarker_undable(_elementList, _markerID) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;

        if (_elementList.length === 0)
            return null;

        const idMarker = _markerID || XOS.createUniqueIDI('marker');

        this.deselectAll();

        const bbox = GeometryUtils.getElementListGlobalBBox(_elementList);
        const pt = activePage.content.globalToLocal(bbox.x, bbox.y);

        const newMarker = SVGUtils.createMarker(idMarker, bbox.width * (1 / activePage.content.currentScale), bbox.height * (1 / activePage.content.currentScale));

        this.translateElementList(_elementList, -pt.x, -pt.y, true);

        let element;
        for (let i = 0; i < _elementList.length; i++) {
            element = _elementList[i];
            newMarker.appendChild(_elementList[i].cloneNode(true));
        }

        this.translateElementList(_elementList, pt.x, pt.y, true);

        this.resources.addResource(newMarker);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');
        XOS.removeElementList(_elementList);

        undoAction.createDomNodeSnapshot([newMarker], 'delete');
        undoAction.snapshotDataList.reverse(); // le azioni di undo devono essere eseguite in ordine inverso
        redoAction.createDomNodeSnapshot([newMarker], 'insert');

        this.enterTo_isolateLayerEditing(newMarker);

        activeApplication.workspace.update();

    };

    createTextOnPath_undable(_elementList) {
        const activePage = this.activePage;
        _elementList = _elementList || activePage.selectionList;

        this.deselectAll();

        let textElement,
        pathElement;

        if (_elementList.length === 1 && _elementList[0].nodeName === 'text') {

            textElement = _elementList[0];
            const bbox = textElement.getLocalBBox();
            const newEllipse = SVGUtils.createEllipse(bbox.center.x, bbox.center.x, bbox.width / 2, bbox.width / 2);
            pathElement = SVGUtils.createPath();
            pathElement.setPathData(newEllipse.getPathData());
            pathElement.getTransform().setMatrix(textElement.getTransform().matrix.clone());
            pathElement.setAttribute('fill', 'none');
            pathElement.setAttribute('stroke', '#000000');
            pathElement.setAttribute('stroke-width', '0');
            textElement.parentElement.insertBefore(pathElement, textElement.nextElementSibling);

        } else {

            if (_elementList.length !== 2)
                return null;

            if (_elementList[0]instanceof SVGTextElement) {
                textElement = _elementList[0];
                pathElement = _elementList[1];
            } else {
                pathElement = _elementList[0];
                textElement = _elementList[1];
            }
        }

        //_elementList = CoordsUtils.sortByDeep( _elementList );
        _elementList = this.sortElementListByLevel(_elementList);

        const parentElement = _elementList[_elementList.length - 1].parentElement;
        const nextElement = _elementList[_elementList.length - 1].nextElementSibling;

        const pathID = XOS.createUniqueIDI('path');

        const newGroup = SVGUtils.createGroup();
        newGroup.getTransform().setMatrix(pathElement.getTransform().matrix.clone());

        let newPath;

        if (pathElement.nodeName !== 'path') {
            newPath = SVGUtils.createPath();
            newPath.setPathData(pathElement.getPathData({
                    normalize: true
                }));
        } else {
            newPath = pathElement.cloneNode();
        }

        newPath.getTransform().matrix.identity();
        newPath.setAttribute('id', pathID);
        newPath.setAttribute('data-type', 'EditableTextPath');

        newGroup.appendChild(newPath);

        const newTextElement = textElement.cloneNode(false); // la funzione assegna già il controller e texdata
        newTextElement.setAttribute('data-type', 'TextOnPath');
        newTextElement.getTransform().matrix.identity();

        const newTextPathElement = document.createElementNS(SVGSVGElement.SVG_NS, 'textPath');
        newTextPathElement.setAttributeNS(SVGSVGElement.XLINK_NS, 'href', '#' + pathID);

        newTextElement.appendChild(newTextPathElement);

        newGroup.appendChild(newTextElement);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();

        undoAction.createDomNodeSnapshot(_elementList, 'insert');
        redoAction.createDomNodeSnapshot(_elementList, 'delete');
        activePage.history.addUndoRedoActions(undoAction, redoAction);

        XOS.removeElementList(_elementList);

        parentElement.insertBefore(newGroup, nextElement);

        undoAction.createDomNodeSnapshot([newGroup], 'delete');
        undoAction.snapshotDataList.reverse();
        redoAction.createDomNodeSnapshot([newGroup], 'insert');

        this.selectElementList([newGroup]);
        activeApplication.workspace.update();

    };

    // -----------------------------   TEXT EDITING ---------------------------------//


    createInsertTextDataUndoRedoActions(_textElement, _textData) {
        var undoAction = new DeleteTextData_action(this);
        undoAction.setDeleteTextDataProperties(_textElement, _textData.offset, _textData.text.length);
        var redoAction = new InsertTextData_action(this);
        redoAction.setInsertTextDataProperties(_textElement, _textData);

        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
    };

    createDeleteTextDataUndoRedoActions(_textElement, _textData) {
        var undoAction = new InsertTextData_action(this);
        undoAction.setInsertTextDataProperties(_textElement, _textData);
        var redoAction = new DeleteTextData_action(this);
        redoAction.setDeleteTextDataProperties(_textElement, _textData.offset, _textData.text.length);

        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
    };

    setTextAttribute_undable(_textElement, _keyValues, _textDataStartOffset, _textDataEndOffset) {
        var undoAction,
        redoAction;

        var textDataStartOffset = _textDataStartOffset || _textElement.storedTextSelectionRange.textDataStartOffset;
        var textDataEndOffset = _textDataEndOffset || _textElement.storedTextSelectionRange.textDataEndOffset;

        undoAction = new SetTextDataStyle_action(this);
        undoAction.setTextDataStyleRange(_textElement, textDataStartOffset, textDataEndOffset);
        this.setAttributeElementList([_textElement], _keyValues);
        redoAction = new SetTextDataStyle_action(this);
        redoAction.setTextDataStyleRange(_textElement, textDataStartOffset, textDataEndOffset);
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
    };

    applyFontElementList_undable(_elementList, _googleFontObject, _variant) {
        if (_elementList.length === 0)
            return;

        var filteredElementList = XOS.getFilteredElementListByNodeName(_elementList, 'text');

        if (filteredElementList.length === 0)
            return;

        _variant = _variant || _googleFontObject.variants[0];

        var styleAndWeight = window.GoogleFonts.getGoogleFontStyleAndWeightByVariantName(_variant);
        this.setAttributeElementList_undable(filteredElementList, {
            'font-family': _googleFontObject.family,
            'font-style': styleAndWeight['font-style'],
            'font-weight': styleAndWeight['font-weight']
        }, true);

        this.onChange();

        const progressWindow = WINDOWS['progressWindow'];
        progressWindow.open(true).setProgressBarValue(1).startVirtualProgress(100000);

        window.GoogleFonts.loadGoogleFont(_googleFontObject, _variant, null, function () {
            progressWindow.endVirtualProgress();
            activeApplication.workspace.update();
        });
    };

    serialize() {
        return new XMLSerializer().serializeToString(new DocumentSerializer().serialize(this));
    }

    /* copy paste cut */

    onPaste(_e) {
        this.pasteElements(_e);
        _e.stopPropagation();
        _e.preventDefault();
        activeApplication.workspace.update();
    }

    onCopy(_e) {
        if (this.copyAndCutListener) {
            this.copyAndCutListener.onCopy(_e);
            this.copyAndCutListener = null;
            _e.preventDefault();
            return;
        }

        this.copySelectedElements(_e);
        _e.preventDefault();
    }

    onCut(_e) {
        if (this.copyAndCutListener) {
            this.copyAndCutListener.onCut(_e);
            this.copyAndCutListener = null;
            _e.preventDefault();
            return;
        }

        this.cutSelectedElements(_e);
        _e.preventDefault();
    }

    cutSelectedElements(_e) {
        this.copySelectedElements(_e);
        this.removeElementList_undable(activeApplication.activeDocument.activePage.selectionList);
        this.onChange();
    }

    sortElementListByLevel(_elementList) {
        const max = _elementList.length;
        let i;
        for (i = 0; i < max; i++)
            _elementList[i].classList.add('sortable');
        _elementList = this.activePage.querySelectorAll('.sortable');
        for (i = 0; i < max; i++)
            _elementList[i].classList.remove('sortable');
        return [].slice.call(_elementList, 0); // ritorna sempre un array
    };

    copySelectedElements(_e) {
        if (window.preventCopy) {
            _e.clipboardData.setData('text/plain', 'jango');
            return;
        }
        const sortedElementList = this.sortElementListByLevel(this.activePage.selectionList);
        const clipboardDocument = new DocumentSerializer().serializeForClipboard(sortedElementList);
        //console.log('clipboardDocument' , new XMLSerializer().serializeToString(clipboardDocument));
        _e.clipboardData.setData('text/plain', new XMLSerializer().serializeToString(clipboardDocument));
    };

    pasteElements(_pasteEvent) {

        //console.log('_pasteEvent',_pasteEvent);
        if (!_pasteEvent.clipboardData)
            return;
        if (!_pasteEvent.clipboardData.items)
            return;

        const activeDocument = this;
        const activePage = activeDocument.activePage;
        const items = _pasteEvent.clipboardData.items;
        let item;

        function onParseEnd(_elementList) {
            // console.log('onParseEnd', _importedNodes )
            // self.addElementList_undable( _importedNodes  );

            if (_elementList.length === 0)
                return null;

            const undoAction = new UndoRedoAction();
            const redoAction = new UndoRedoAction();
            activePage.history.addUndoRedoActions(undoAction, redoAction);

            const max = _elementList.length;
            for (let i = 0; i < max; i++) {
                undoAction.createDomNodeSnapshot([_elementList[i]], 'delete');
                redoAction.createDomNodeSnapshot([_elementList[i]], 'insert');
                // qui non fa niente in quanto viene usato da paste con oggetti già inseriti
            }

            redoAction.snapshotDataList.reverse(); // il primo elemento da inserire deve essere l'ultimo eliminato


            redoAction.onExecuteEnd = function () {
                activeDocument.selectElementList(_elementList)
            };

            activeApplication.workspace.update();
            activeDocument.onChange();

        }

        for (let i = 0; i < items.length; i++) {

            item = items[i];

            if (item.kind === "file") {
                if (item.type.indexOf("image") > -1) {
                    LOCAL_FILE_SYSTEM.readImageFileAsDataUrl(item.getAsFile(), function (_dataURL) {
                        activeDocument.placeImage_undable(_dataURL);
                    });
                }
            } else if (item.kind === "string" && item.type === "text/plain") {
                let string = _pasteEvent.clipboardData.getData('text/plain');
                let startID = string.indexOf('<svg');
                if (startID === -1)
                    continue;

                if (string.indexOf('xmlns="http://www.w3.org/2000/svg"') === -1)
                    string = string.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg" ');

                string = string.substring(startID, string.lastIndexOf('</svg>') + 6);

                const xmlDocument = new DOMParser().parseFromString(string, "image/svg+xml").querySelector('svg');
                activeApplication.documentsManager.unserializeDocument(xmlDocument, {
                    import: true,
                    importInPlace: KEYBOARD_EVENT_MANAGER.shiftKeyPressed || _pasteEvent.shiftKey
                }, onParseEnd);
            } else if (item.kind === "string" && item.type === "image/svg+xml") {

                const xmlDocument = new DOMParser().parseFromString(_pasteEvent.clipboardData.getData('image/svg+xml'), "image/svg+xml").documentElement;
                activeApplication.documentsManager.unserializeDocument(xmlDocument, {
                    import: true,
                    importInPlace: KEYBOARD_EVENT_MANAGER.shiftKeyPressed || _pasteEvent.shiftKey
                }, onParseEnd);
            } else if (item.kind === "string" && item.type === "text/html") {
                // const string = _pasteEvent.clipboardData.getData('text/html');
                // const xmlDocument = new DOMParser().parseFromString( string ,"text/html").documentElement.querySelector('svg');
                // console.log('_pasteEvent.clipboardData.getData', xmlDocument );
                // if(xmlDocument)activeApplication.unserializeDocument( xmlDocument , {import: true, shiftKey: KEYBOARD.shiftKeyPressed || _pasteEvent.shiftKey }  );
            }
        }
    }

    enterTo_isolateLayerEditing(_editableElement) {
        this.deselectAll();

        let layerName = _editableElement.nodeName.toUpperCase();
        if (_editableElement.hasAttribute('id'))
            layerName = _editableElement.getAttribute('id');

        const editingLayer = this.createPageLayer(layerName);
        editingLayer.classList.add('isolate-layer');

        if (_editableElement.hasAttribute('clip-path')) {
            editingLayer.setAttribute('data-custom-element', 'ClipEditing_layer');
            editingLayer.controller = new ClipEditing_layer(editingLayer, _editableElement);
        } else if (_editableElement.hasAttribute('mask')) {
            editingLayer.setAttribute('data-custom-element', 'MaskEditing_layer');
            editingLayer.controller = new MaskEditing_layer(editingLayer, _editableElement);
        } else if (_editableElement.nodeName === 'symbol') {
            editingLayer.setAttribute('data-custom-element', 'SymbolEditing_layer');
            editingLayer.controller = new SymbolEditing_layer(editingLayer, _editableElement);
        } else if (_editableElement.nodeName === 'pattern') {
            editingLayer.setAttribute('data-custom-element', 'PatternEditing_layer');
            editingLayer.controller = new PatternEditing_layer(editingLayer, _editableElement);
        } else if (_editableElement.nodeName === 'marker') {
            editingLayer.setAttribute('data-custom-element', 'MarkerEditing_layer');
            editingLayer.controller = new MarkerEditing_layer(editingLayer, _editableElement);
        } else if (_editableElement.nodeName === 'g') {
            editingLayer.setAttribute('data-custom-element', 'GroupEditing_layer');
            editingLayer.controller = new GroupEditing_layer(editingLayer, _editableElement);
        }

        this.addPageLayer(editingLayer);

        const undoAction = new UndoRedoAction();
        const redoAction = new UndoRedoAction();
        this.activePage.history.addUndoRedoActions(undoAction, redoAction);
        undoAction.createDomNodeSnapshot([editingLayer], 'delete');
        redoAction.createDomNodeSnapshot([editingLayer], 'insert');

        redoAction.onExecuteEnd = function () {
            editingLayer.controller.onAdded()
        };
        undoAction.onExecuteEnd = function () {
            editingLayer.controller.onRemoved()
        };

        editingLayer.controller.enterToEditing();

        activeApplication.workspace.snapInteraction2D.reset();
        activeApplication.workspace.update();

    };

    exitFrom_isolateLayerEditing() {
        //if( activeApplication.isTextEditing  ) activeApplication.currentEditableTextElement.exitFromTextEditing();
        if (activeApplication.isTextEditing)
            this.exitFromTextEditing();

        this.deselectAll();
        const layers = this.activePage.content.querySelector('.layers').children;
        let isolateLayerEditing = layers[layers.length - 1];
        //console.log('exitFrom_isolateLayerEditing', isolateLayerEditing );
        isolateLayerEditing.controller.exitFromEditing();
    };

    exitFrom_AllIsolateLayerEditing() {
        //if( activeApplication.isTextEditing  ) activeApplication.currentEditableTextElement.exitFromTextEditing();
        if (activeApplication.isTextEditing)
            this.exitFromTextEditing();

        this.deselectAll();
        const layers = this.activePage.content.querySelector('.layers');
        while (layers.lastElementChild.classList.contains('isolate-layer'))
            this.exitFrom_isolateLayerEditing();
    };

    exitFromTextEditing() {

        if (activeApplication.currentEditableTextElement.nodeName === 'text') {
            activeApplication.currentEditableTextElement.exitFromTextEditing();
        } else {
            const div = activeApplication.currentEditableTextElement.querySelector('div');
            div.removeAttribute('contenteditable');
            div.blur();
            activeApplication.isTextEditing = false;
            activeApplication.currentEditableTextElement = null;
        }
    }

}

customElements.define("document-2d", Document2D_cmp);

class DocumentSerializer {

    constructor(_options) {
        this.timestamp = new Date().getTime();
        this.options = _options || {};
        this.documentToSerialize = null;
        this.svgOutputDocument = null;
        this.pagePosY = 0;
    }

    serialize(_documentToSerialize, _options) {
        this.options = _options || {};
        this.svgOutputDocument = null;
        this.documentToSerialize = _documentToSerialize || activeApplication.activeDocument;
        const activePage = this.documentToSerialize.activePage; // uso le dimensione della corrente pagina attiva CAMBIARE
        this.svgOutputDocument = activePage.createSVG(activePage.dataset.width, activePage.dataset.height);

        if (this.documentToSerialize.preferences.svgAlignmentPreserveAspectRatio !== 'unset') {
            this.svgOutputDocument.setAttribute('preserveAspectRatio', this.documentToSerialize.preferences.svgAlignmentPreserveAspectRatio);
        } else {
            this.svgOutputDocument.setAttribute('style', 'height:unset;');
            // questo potrebbe essere utilizzato per siti che si sviuppano orizzontalmente
            //this.svgOutputDocument.setAttribute( 'style', 'width:unset;' );
        }

        this.svgOutputDocument.storeJsonData('jvs-doc-preferences', this.documentToSerialize.preferences); // vedere se va

        this.svgOutputDocument.dataset.version = '6.4';
        //this.svgOutputDocument.appendChild( this.createPrintingStyle() );
        const documentDefs = this.documentToSerialize.resources.querySelector('defs').cloneNode(true);
        this.svgOutputDocument.appendChild(documentDefs);
        this.serializePageList();
        this.serializeCssClasses();
        this.fixAttributes();
        this.svgOutputDocument.removeUnusedResources(this.options);
        this.serializeFontLinks();
        this.serializeSVGXlinks();
        this.serializeImages();
        return this.svgOutputDocument;
    }

    serializeForClipboard(_itemList) {
        this.documentToSerialize = activeApplication.activeDocument;
        const activePage = this.documentToSerialize.activePage; // uso le dimensione della corrente pagina attiva CAMBIARE
        this.svgOutputDocument = activePage.createSVG(activePage.dataset.width, activePage.dataset.height);
        this.svgOutputDocument.storeJsonData('jvs-doc-preferences', this.documentToSerialize.preferences); // vedere se va
        this.svgOutputDocument.dataset.version = '6.4';
        this.svgOutputDocument.setAttribute('clipboard-id', activeApplication.activeDocument.getAttribute('id'));

        const documentDefs = this.documentToSerialize.resources.querySelector('defs').cloneNode(true);
        this.svgOutputDocument.appendChild(documentDefs);

        let element,
        clonedElement,
        layerRef,
        transformInLayer;

        for (let i = 0; i < _itemList.length; i++) {
            element = _itemList[i];
            layerRef = element.getLayerOwner();
            transformInLayer = element.getTransformToElement(layerRef);
            clonedElement = element.cloneNode(true);
            clonedElement.getTransform().setMatrix(transformInLayer);
            this.svgOutputDocument.appendChild(clonedElement);
        }

        this.serializeCssClasses();
        this.fixAttributes();
        this.svgOutputDocument.removeUnusedResources(this.options);
        this.serializeFontLinks();
        this.serializeSVGXlinks();
        this.serializeImages();
        return this.svgOutputDocument;

    };

    // serializeForClipboard(_itemList )
    // {
    //     this.svgOutputDocument = SVGUtils.createSVG( '100%' ,  '100%' );
    //     this.documentToSerialize = activeApplication.activeDocument;
    //
    //     // this.svgOutputDocument.setAttribute('clipboard-id' , this.documentToSerialize.getAttribute('id') );
    //     const documentDefs =  this.documentToSerialize.resources.querySelector('defs').cloneNode( true);
    //     this.svgOutputDocument.appendChild( documentDefs );
    //
    //     let element,clonedElement,layerRef,transformInLayer;
    //
    //     for (let i = 0; i < _itemList.length; i++)
    //     {
    //         element = _itemList[i];
    //         layerRef = element.getLayerOwner();
    //         transformInLayer = element.getTransformToElement( layerRef );
    //         clonedElement = element.cloneNode(true);
    //         clonedElement.removeAttribute('selected');
    //         clonedElement.getTransform().setMatrix(transformInLayer);
    //         this.svgOutputDocument.appendChild(clonedElement);
    //     }
    //
    //     this.fixAttributes();
    //     this.svgOutputDocument.removeUnusedResources( this.options );
    //     this.serializeFontLinks();
    //     this.serializeSVGXlinks();
    //     this.serializeImages();
    //     return  this.svgOutputDocument;
    //
    // };


    createPrintingStyle() {
        const styleNode = document.createElement('style');
        styleNode.innerHTML = `

        @page { size: A4; margin: 0; }

        @media print {
            .resources { position: absolute; top: 0; left: 0; }
            .page { display: inline!important; margin: 0; padding: 0; page-break-after: always; width: 100%; height: 100%; }
            .page:last-child {  page-break-after: auto;  }
            .page .background-layers{ display:none; }
            .page .foreground-layers{ display:none; }
        }
    `;
        return styleNode;
    }

    serializePageList() {
        this.pagePosY = 0;
        const pageList = this.options.pageList || this.documentToSerialize.pageList.children;
        let currentPage,
        svgOutputPage,
        pagePreferenceNode;
        const max = pageList.length;
        for (let i = 0; i < max; i++) {
            currentPage = pageList[i];
            svgOutputPage = this.serializePage(currentPage);
            svgOutputPage.setAttribute('y', this.pagePosY);
            this.svgOutputDocument.appendChild(svgOutputPage);
            this.pagePosY += parseFloat(currentPage.dataset.pageHeight);
        }

        // proviamo a toglierla
        //this.svgOutputDocument.setAttribute('height' , this.pagePosY );

        // if(this.documentToSerialize.preferences.svgAlignmentPreserveAspectRatio!=='unset')
        // {
        //     this.svgOutputDocument.setAttribute('viewBox' , '0 0 '+ pageList[0].dataset.pageWidth + ' ' + this.pagePosY );
        // }

        this.svgOutputDocument.setAttribute('viewBox', '0 0 ' + pageList[0].dataset.pageWidth + ' ' + this.pagePosY);

    }

    serializePage(_page) {
        const svgOutputPage = _page.cloneNode(true);
        svgOutputPage.querySelector('.content').removeAttribute('transform');
        svgOutputPage.setAttribute('width', _page.dataset.pageWidth);
        svgOutputPage.setAttribute('height', _page.dataset.pageHeight);
        svgOutputPage.setAttribute('viewBox', '0 0 ' + _page.dataset.pageWidth + ' ' + _page.dataset.pageHeight);

        if (_page.timelines) {
            svgOutputPage.storeJsonData('jvs-page-timelines', _page.timelines); // vedere se va
        }
        //remove elements from publishing
        // svgOutputPage.querySelector('rect.grid').remove();
        // svgOutputPage.querySelector('.printable-area').remove();

        // data node
        // const jvsDataNode = document.createElement( 'jvs:data' );
        // jvsDataNode.setAttribute('xmlns:jvs', 'http://www.janvas.com/jvs');

        // preferences node
        // const jvsPagePreferencesNode = document.createElement( 'jvs:data' );
        // jvsPagePreferencesNode.setAttribute('id',"page-preferences");
        // jvsPagePreferencesNode.innerText = JSON.stringify(_page.preferences);
        // jvsDataNode.appendChild(jvsPagePreferencesNode);
        //
        // svgOutputPage.appendChild(jvsDataNode);

        return svgOutputPage;
    }

    serializeFontLinks() {
        let fontLinkElement,
        fontFamily,
        fontStyle,
        fontWeight,
        fontUrl,
        element;
        const elementsListWithFontFamily = this.svgOutputDocument.querySelectorAll('[font-family]');
        const fontLinkList = [];
        let i;
        for (i = 0; i < elementsListWithFontFamily.length; i++) {
            element = elementsListWithFontFamily[i];
            fontFamily = element.getAttribute('font-family').split(' ').join('+');
            fontStyle = element.getAttribute('font-style') || 'regular';
            fontWeight = element.getAttribute('font-weight') || '';
            fontUrl = window.GoogleFonts.getFontUrlByFontFamilyStyleAndWeight(fontFamily, fontStyle, fontWeight, null);

            fontLinkElement = document.head.querySelector('*[href*="' + fontUrl + '"]');
            if (fontLinkElement && (fontLinkList.indexOf(fontLinkElement) === -1)) {
                fontLinkList.push(fontLinkElement);
            }
        }

        const defsNode = this.svgOutputDocument.querySelector('defs');
        let clonedNode;
        for (i = 0; i < fontLinkList.length; i++) {
            clonedNode = fontLinkList[i].cloneNode();
            clonedNode.appendChild(document.createTextNode('')); // fix per far creare il tag di chiusura
            defsNode.appendChild(clonedNode);
        }

    };

    serializeSVGXlinks() {
        let i,
        xlink,
        href,
        target,
        element;
        const elementList = this.svgOutputDocument.querySelectorAll('[data-xlink-href]');
        for (i = 0; i < elementList.length; i++) {
            element = elementList[i];
            href = element.getAttribute('data-xlink-href');
            element.removeAttribute('data-xlink-href'); // rimuovo l'attributo

            if (element.hasAttribute('data-xlink-target')) {
                target = element.getAttribute('data-xlink-target').trim();
                element.removeAttribute('data-xlink-target'); // rimuovo l'attributo
                if (target === '')
                    target = null;
            }

            xlink = SVGUtils.createXlink(href, target);

            xlink.appendChild(element.cloneNode(true));

            element.parentNode.replaceChild(xlink, element);
        }
    };

    serializeImages() {
        const elementList = this.svgOutputDocument.querySelectorAll('[data-full-path]');
        let i,
        element;

        for (i = 0; i < elementList.length; i++) {
            element = elementList[i];
            element.setAttributeNS(SVGElement.XLINK_NS, 'href', element.dataset.fullPath.slice(1));
            element.removeAttribute('data-full-path');
        }
    };

    serializeCssClasses() {
        const elementList = this.svgOutputDocument.querySelectorAll('[data-css-class]');
        let i,
        element;

        for (i = 0; i < elementList.length; i++) {
            element = elementList[i];
            element.__setAttribute('class', element.getAttribute('data-css-class'));
            element.removeAttribute('data-css-class');
        }
    };

    fixAttributes() {
        let elementList = this.svgOutputDocument.querySelectorAll('[systemLanguage]');
        let i,
        max = elementList.length;
        for (i = 0; i < max; i++)
            elementList[i].removeAttribute('systemLanguage');

        elementList = this.svgOutputDocument.querySelectorAll('[requiredExtensions]');
        max = elementList.length;
        for (i = 0; i < max; i++)
            elementList[i].removeAttribute('requiredExtensions');

        elementList = this.svgOutputDocument.querySelectorAll('[selected]');
        max = elementList.length;
        for (i = 0; i < max; i++)
            elementList[i].removeAttribute('selected');

        elementList = this.svgOutputDocument.querySelectorAll('.pointer-hover');
        max = elementList.length;
        for (i = 0; i < max; i++)
            elementList[i].classList.remove('pointer-hover');

        elementList = this.svgOutputDocument.querySelectorAll('tspan[data-start-offset]');
        max = elementList.length;
        for (i = 0; i < max; i++)
            elementList[i].removeAttribute('data-start-offset');

        elementList = this.svgOutputDocument.querySelectorAll('title');
        max = elementList.length;
        for (i = 0; i < max; i++)
            if (elementList[i].textContent.length === 0)
                elementList[i].remove();

        elementList = this.svgOutputDocument.querySelectorAll('desc');
        max = elementList.length;
        for (i = 0; i < max; i++)
            if (elementList[i].textContent.length === 0)
                elementList[i].remove();
    };

}

class DocumentUnserializer{
    constructor() {
        this.parsedFonts = null;
        this.targetDocument = null;
        this.sourceSVG = null;
        this.options = null;
        this.importedNodes = null;
        this.isJanvasDocument = null;
    }

    askBeforeForImportPages() {
        const dialog = DIALOGS['import-pages-action-request-dialog'];
        const self = this;
        function on_Ok() {
            self.options.importPagesBehaviourAction = this.controlledElements.importPagesBehaviourAction.value;
            self.onBeforeParser();
            this.close();
        }

        dialog.open(null, null, on_Ok);
    }

    askBeforeForImportDefs() {
        const dialog = DIALOGS['defs-action-request-dialog'];
        const self = this;
        function on_Ok() {
            self.options.defsBehaviourAction = this.controlledElements.defsBehaviourAction.value;
            self.onBeforeParser();
            this.close();
        }

        dialog.open(null, null, on_Ok);
    }

    askBeforeForImportInnerSVG() {
        const dialog = DIALOGS['inner-svg-action-request-dialog'];
        const self = this;
        function on_Ok() {
            self.options.importInnerSvgAs = this.controlledElements.importInnerSvgAs.value;
            self.onBeforeParser();
            this.close();
        }

        dialog.open(null, null, on_Ok);
    }

    fixSymbolAndMarkerViewBox() {
        // elimino la viewbox dai simboli ed aggiungo overflow=visible
        const elementList = this.sourceSVG.querySelectorAll('symbol,marker');
        for (let i = 0; i < elementList.length; i++) {
            elementList[i].removeAttribute('viewBox');
            elementList[i].setAttribute('overflow', 'visible');
        }
    }

    parse(xmlDocument, _options, _completeCallback) {
        this.options = _options || {};
        this.sourceSVG = xmlDocument;

        // se non si tratta di un documento di janvas
        this.isJanvasDocument = !!(this.sourceSVG.dataset && this.sourceSVG.dataset.version);

        this.importedNodes = [];

        this.targetDocument = activeApplication.activeDocument;

        this.onBeforeParser();

        //console.log('this.importedNodes',this.importedNodes);


        if (_completeCallback)
            _completeCallback(this.importedNodes);
    }

    onBeforeParser() {
        // dalla versione 6.4 simboli e markers non hanno più viewbox
        this.fixSymbolAndMarkerViewBox()

        let targetDefs = null;

        if (this.options.import) {
            targetDefs = this.targetDocument.resources.querySelector('defs');

            if (this.isJanvasDocument) {
                if (this.sourceSVG.hasAttribute('clipboard-id')) {
                    if (this.sourceSVG.getAttribute('clipboard-id') === this.targetDocument.getAttribute('id')) {
                        this.options.defsBehaviourAction = 'defsMantainTarget';
                    }
                } else {
                    if (!this.options.importPagesBehaviourAction) {
                        this.askBeforeForImportPages();
                        return;
                    }
                }
            }

            // if( this.isJanvasDocument && ( ! this.options.importPagesBehaviourAction ) )
            // {
            //     this.askBeforeForImportPages();
            //     return;
            // }
            //
            // if( this.sourceSVG.hasAttribute('clipboard-id') && (this.sourceSVG.getAttribute('clipboard-id') === this.targetDocument.getAttribute('id') ) )
            // {
            //     this.options.defsBehaviourAction = 'defsMantainTarget';
            // }

            if (!this.options.defsBehaviourAction) {
                const sourceDefs = this.sourceSVG.querySelector('defs');
                if (sourceDefs) {
                    if (this.sourceSVG.areSourceDefsInTargetDefs(targetDefs)) {
                        this.askBeforeForImportDefs();
                        return;
                    }
                }
            }
        }

        if (!this.isJanvasDocument && !this.options.importInnerSvgAs && this.sourceSVG.querySelector('svg')) {
            this.askBeforeForImportInnerSVG();
            return;
        }

        this.parseAll(targetDefs);

    }

    parseAll(targetDefs) {

        this.sourceSVG.parse_clear();
        this.sourceSVG.parse_scripts();
        this.sourceSVG.consolidateMatrix();
        this.sourceSVG.parse_clipPaths();
        this.sourceSVG.parse_masks();
        this.sourceSVG.parse_cssToAttributes();
        this.sourceSVG.parse_styleToAttributes();
        this.sourceSVG.parse_class();
        this.parsedFonts = this.sourceSVG.parse_fonts();
        this.sourceSVG.parse_gradients();
        this.sourceSVG.parse_anchors();
        if (!this.isJanvasDocument)
            this.sourceSVG.sanitize_geometry();
        //this.sourceSVG.parse_adjustAttributes(); per il momento non modifico i valori di default
        this.sourceSVG.parse_text();
        this.sourceSVG.parse_defs(targetDefs);
        this.finalize();
        activeApplication.editingView.update();

        // const functionList= [
        //     function(){self.sourceSVG.parse_clear()},
        //     function(){self.sourceSVG.parse_scripts()},
        //     function(){self.sourceSVG.consolidateMatrix()},
        //     function(){self.sourceSVG.parse_clipPaths()},
        //     function(){self.sourceSVG.parse_masks()},
        //     //function(){self.sourceSVG.parse_cssToAttributes()},
        //     function(){self.sourceSVG.parse_styleToAttributes()},
        //     function(){self.sourceSVG.parse_class()},
        //     function(){self.parsedFonts = self.sourceSVG.parse_fonts();},
        //     function(){self.sourceSVG.parse_gradients()},
        //     function(){self.sourceSVG.parse_anchors()},
        //     function(){self.sourceSVG.sanitize_geometry()},
        //     function(){self.sourceSVG.parse_text()},
        //     function(){self.sourceSVG.parse_defs( targetDefs )},
        //     function(){self.finalize()}
        // ];
        //
        // let currentFunctionID=0;
        // function executeAsyncFunction()
        // {
        //     functionList[currentFunctionID]();
        //     currentFunctionID++;
        //     if( currentFunctionID<functionList.length) setTimeout( executeAsyncFunction,50) ;
        // }
        //
        // setTimeout( executeAsyncFunction,50) ;

        // this.sourceSVG.parse_clear();
        // this.sourceSVG.parse_scripts();
        // this.sourceSVG.consolidateMatrix();
        // this.sourceSVG.parse_clipPaths();
        // this.sourceSVG.parse_masks();
        // this.sourceSVG.parse_cssToAttributes();
        // this.sourceSVG.parse_styleToAttributes();
        // this.parsedFonts = this.sourceSVG.parse_fonts();
        // this.sourceSVG.parse_gradients();
        // this.sourceSVG.parse_anchors();
        // this.sourceSVG.sanitize_geometry();
        // this.sourceSVG.parse_text();
        // this.sourceSVG.parse_defs( targetDefs );

        // this.finalize()
    }

    finalize() {
        this.convertInnerSvg();
        this.addDefsElementsInDocument();
        this.addFontsInDocument();
        this.addContentInDocument();
        activeApplication.documentTabBar.update();
        //XOS.initDefinedCustomElements(activeApplication.activeDocument.shadowRoot );

        //activeApplication.propertyPanels['page-list-inspector'].drawPageList();
        //activeApplication.propertyPanels['page-inspector'].update();


        // const self=this;
        //
        // const functionList= [
        //     function(){self.addDefsElementsInDocument()},
        //     function(){self.addFontsInDocument()},
        //     function(){self.addContentInDocument()},
        //     function(){XOS.initDefinedCustomElements(activeApplication.activeDocument.shadowRoot )}
        // ];
        //
        // let currentFunctionID=0;
        // function executeAsyncFunction()
        // {
        //     functionList[currentFunctionID]();
        //     currentFunctionID++;
        //     if( currentFunctionID<functionList.length) setTimeout( executeAsyncFunction,50) ;
        // }
        //
        // setTimeout( executeAsyncFunction,50) ;


        // BOOO queste due righe devono essere fatte sul documento target alla fine del parsing
        // textElement.parseText();
        // textElement.consolidateAllStyles();
    }

    convertInnerSvg() {
        if (this.options.importInnerSvgAs === 'pattern') {
            const targetDefs = this.targetDocument.resources.querySelector('defs');
            const svgList = this.sourceSVG.querySelectorAll('svg');
            let svgElement,
            width,
            height,
            newPattern,
            idPattern,
            newRect;
            for (let i = 0; i < svgList.length; i++) {
                svgElement = svgList[i];
                width = svgElement.getAttribute('width') || svgElement.getLocalBBox().width;
                height = svgElement.getAttribute('height') || svgElement.getLocalBBox().height;
                idPattern = svgElement.getAttribute('id') || XOS.createUniqueIDI('pattern')
                    newPattern = this.sourceSVG.createPattern(idPattern, 0, 0, width, height);
                svgElement.cloneChildrenTo(newPattern);
                targetDefs.appendChild(newPattern);
                newRect = this.sourceSVG.createRect(0, 0, 100, 100);
                newRect.setAttribute('fill', 'url(#' + idPattern + ')');
                svgElement.parentElement.replaceChild(newRect, svgElement);
            }
        }
    };

    addDefsElementsInDocument() {
        const sourceDefs = this.sourceSVG.querySelector('defs');
        const targetDefs = this.targetDocument.resources.querySelector('defs');

        if (!sourceDefs)
            return;

        if (this.options.import) {
            if (this.options.defsBehaviourAction === 'defsReplaceTarget') {
                const itemList = sourceDefs.querySelectorAll('[data-item-exists]');
                let item;
                for (let i = 0; i < itemList.length; i++) {
                    item = itemList[i];
                    item.removeAttribute('data-item-exists');
                    // se non è già stato sostituito ( tolto dal documento in quanto figlio di un altro elemento defs precedentemente rimpiazzato )
                    if (item.targetDefsItem.ownerSVGElement) {
                        // lo toglie da source lo mette in target sosituendo l'esistente
                        item.targetDefsItem.parentElement.replaceChild(item, item.targetDefsItem);
                    } else {
                        //elemento già sostituito
                    }
                    delete (item.targetDefsItem);
                }
            } else if (this.options.defsBehaviourAction === 'defsMantainTarget') {
                const itemList = sourceDefs.querySelectorAll('[data-item-exists]');
                let item;
                for (let i = 0; i < itemList.length; i++) {
                    item = itemList[i];
                    item.removeAttribute('data-item-exists');
                    if (item.ownerSVGElement)
                        item.remove();
                    delete (item.targetDefsItem);
                } // lo toglie da source
            } else if (this.options.defsBehaviourAction === 'defsRefactorSource') {
                const itemList = sourceDefs.querySelectorAll('[data-item-exists]');
                let item;
                for (let i = 0; i < itemList.length; i++) {
                    item = itemList[i];
                    item.removeAttribute('data-item-exists');
                    const newID = this.targetDocument.resources.createResourceIdFromExistentId(item.getAttribute('id'));
                    //this.sourceSVG.refactorElementID(item, newID);
                    this.targetDocument.refactorElementID(item, newID, this.sourceSVG);
                    delete (item.targetDefsItem);
                }
            } else if (this.options.defsBehaviourAction === 'defsRefactorTarget') {
                const itemList = sourceDefs.querySelectorAll('[data-item-exists]');
                let item;
                for (let i = 0; i < itemList.length; i++) {
                    item = itemList[i];
                    item.removeAttribute('data-item-exists');
                    const newID = this.targetDocument.resources.createResourceIdFromExistentId(item.getAttribute('id'));
                    //this.targetDocument.resources.refactorElementID( item.targetDefsItem , newID , this.targetDocument.shadowRoot );
                    this.targetDocument.refactorElementID(item.targetDefsItem, newID);
                    delete (item.targetDefsItem);
                }
            }
        }
        while (sourceDefs.firstElementChild)
            targetDefs.appendChild(sourceDefs.firstElementChild);

        sourceDefs.remove();
    }

    addFontsInDocument() {
        const addedElements = [];

        let fontLinkElement,
        href,
        urlVars,
        fontFamily;
        for (let i = 0; i < this.parsedFonts.length; i++) {
            href = this.parsedFonts[i].href;
            fontLinkElement = document.head.querySelector('link[href="' + href + '"]');
            if (!fontLinkElement) {
                addedElements.push(XOS.includeCSS(href));
            }
            urlVars = XOS.extractUrlVars(href);
            fontFamily = urlVars.family.split(':')[0].replace(/\+/g, ' ');
            window.GoogleFonts.selectFontByFamilyName(fontFamily);
        }

        return addedElements;
    }

    // addContentInActiveLayer() {
    //     const activeLayer = this.targetDocument.activePage.getActiveLayer();
    //     while(this.sourceSVG.firstElementChild) activeLayer.appendChild( this.sourceSVG.firstElementChild );
    // }


    // addContentInDocument()
    // {
    //     // se NON si tratta di un documento di janvas
    //     if( ! this.isJanvasDocument )
    //     {
    //         // per il momento li rimuovo da qui
    //         const titleAndDescList = this.sourceSVG.querySelectorAll('title,desc');
    //         for(let i=0;i<titleAndDescList.length;i++)titleAndDescList[i].remove();
    //
    //         const activeDocument = activeApplication.activeDocument;
    //
    //         if( ! this.sourceSVG.hasAttribute('clipboard-id')  )
    //         {
    //             const newPage = activeDocument.createNewPage();
    //             activeDocument.setActivePage( newPage );
    //         }
    //
    //         const activePage = activeDocument.activePage;
    //         const activeLayer = activeDocument.getActivePageLayer();
    //         const addedElements = [];
    //         while(this.sourceSVG.firstElementChild)
    //         {
    //             this.importedNodes.push(  this.sourceSVG.firstElementChild );
    //             addedElements.push(  this.sourceSVG.firstElementChild );
    //             activeLayer.appendChild( this.sourceSVG.firstElementChild );
    //         }
    //
    //         if( ! this.options.importInPlace )  activeDocument.centerElementListAtGlobalPoint( addedElements , activePage.clientWidth/2 , activePage.clientHeight/2);
    //
    //         activeDocument.selectElementList( addedElements );
    //
    //         return;
    //     }
    //
    //     const svgPageList = this.sourceSVG.querySelectorAll('svg.page,.page-2D');  // la query contempla anche le pagine della versione 6.0.2
    //
    //     if(this.options.import)
    //     {
    //         let startBeforePage=null;
    //         let page;
    //
    //         if(this.options.importPagesBehaviourAction==='start')
    //         {
    //             startBeforePage = this.targetDocument.pageList.firstElementChild;
    //         }
    //         else if(this.options.importPagesBehaviourAction==='end')
    //         {
    //             startBeforePage=null
    //         }
    //         else if(this.options.importPagesBehaviourAction==='afterActivePage')
    //         {
    //             startBeforePage = this.targetDocument.activePage.nextElementSibling;
    //         }
    //
    //         for (let i = 0; i < svgPageList.length; i++)
    //         {
    //             page = this.parseAndCreatePage(svgPageList[i]);
    //             this.targetDocument.pageList.insertBefore( page ,  startBeforePage );
    //         }
    //
    //         this.targetDocument.setActivePage( page );
    //
    //     } else {
    //         if(this.sourceSVG.dataset.version==='6.4') this.parsePreferences();
    //         for (let i = 0; i < svgPageList.length; i++) this.targetDocument.pageList.appendChild( this.parseAndCreatePage(svgPageList[i]) );
    //         this.targetDocument.setActivePage(this.targetDocument.pageList.firstElementChild);
    //     }
    //
    // };


    addContentInDocument() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        let scale = 1;

        if (this.isJanvasDocument) {
            if (this.sourceSVG.dataset.version === '6.4')
                this.sourcePreferences = this.parsePreferences();

            //console.log('this.sourcePreferences', this.sourcePreferences.svgAlignmentPreserveAspectRatio);

            if (this.sourceSVG.hasAttribute('clipboard-id')) {
                //console.log('clipboard-id',this.sourceSVG.getAttribute('clipboard-id'));

                this.sourceSVG.removeChild(this.sourceSVG.querySelector('[data-type="jvs-doc-preferences"]')); // non docrà essere aggiunto questo nondo

                // clipboard non ha pagine

                const activeLayer = activeDocument.getActivePageLayer();
                const addedElements = [].slice.call(this.sourceSVG.children, 0);
                this.sourceSVG.moveChildrenTo(activeLayer);
                scale = this.sourcePreferences.drawingScale / activeDocument.preferences.drawingScale;
                if (scale !== 1) {
                    activeDocument.scaleElementList(addedElements, scale, scale, {
                        x: 0,
                        y: 0
                    });
                    const scaleOptions = {};
                    scaleOptions.effectScale = Math.sqrt(scale * scale + scale * scale) / Math.sqrt(2);
                    scaleOptions.scaleStrokeAndEffects = activeDocument.preferences.scaleStrokeAndEffects;
                    scaleOptions.scaleText = activeDocument.preferences.scaleText;
                    activeDocument.normalizeScaleElementList(addedElements, scaleOptions);
                }
                if (!this.options.importInPlace)
                    activeDocument.centerElementListAtGlobalPoint(addedElements, activePage.clientWidth / 2, activePage.clientHeight / 2);
                activeDocument.selectElementList(addedElements);

                //console.log('addedElements',addedElements);

                this.importedNodes = addedElements;

            } else {
                const loadedPageList = this.sourceSVG.querySelectorAll('svg.page,.page-2D'); // la query contempla anche le pagine della versione 6.0.2

                let startBeforePage = null;
                if (this.options.import) {
                    if (this.options.importPagesBehaviourAction === 'start') {
                        startBeforePage = this.targetDocument.pageList.firstElementChild;
                    } else if (this.options.importPagesBehaviourAction === 'afterActivePage') {
                        startBeforePage = this.targetDocument.activePage.nextElementSibling;
                    }

                    if (this.sourcePreferences)
                        scale = this.sourcePreferences.drawingScale / activeDocument.preferences.drawingScale;
                } else {
                    if (this.sourcePreferences)
                        activeDocument.preferences = this.sourcePreferences;
                }

                let newPage;
                for (let i = 0; i < loadedPageList.length; i++) {
                    const loadedPage = loadedPageList[i];
                    const pageWidth = parseFloat(loadedPage.dataset.width || loadedPage.dataset.pageWidth || loadedPage.getAttribute('width') || 1024);
                    const pageHeight = parseFloat(loadedPage.dataset.height || loadedPage.dataset.pageHeight || loadedPage.getAttribute('height') || 768);

                    newPage = activeDocument.createNewPage(pageWidth, pageHeight);
                    newPage.querySelector('.layers .layer').remove(); // rimuovo il layer di default
                    newPage.setAttribute('id', loadedPage.getAttribute('id') || '');

                    const titleElement = loadedPage.querySelector(':scope > title');
                    if (titleElement)
                        newPage.insertBefore(titleElement, newPage.firstChild);

                    const descElement = loadedPage.querySelector(':scope > desc');
                    if (descElement)
                        newPage.insertBefore(descElement, newPage.firstChild);

                    const loadedLayerList = loadedPage.querySelectorAll('.layers .layer');
                    let newLayer,
                    loadedLayer;
                    const layerListContainer = newPage.querySelector('.layers');
                    for (let i = 0; i < loadedLayerList.length; i++) {
                        loadedLayer = loadedLayerList[i];
                        const layerName = loadedLayer.dataset.layerName || loadedLayer.dataset.name || loadedLayer.getAttribute('name');
                        const layerColor = loadedLayer.dataset.layerColor || loadedLayer.dataset.color || loadedLayer.getAttribute('color');
                        newLayer = activeDocument.createPageLayer(layerName, layerColor);
                        layerListContainer.appendChild(newLayer);
                        loadedLayer.moveChildrenTo(newLayer);
                    }

                    this.targetDocument.pageList.insertBefore(newPage, startBeforePage);

                    if (this.options.import && scale !== 1) {
                        XOS.showElement(newPage);
                        const elementListToScale = newPage.querySelectorAll('.layers .layer >*');
                        activeDocument.scaleElementList(elementListToScale, scale, scale, {
                            x: 0,
                            y: 0
                        });
                        const scaleOptions = {};
                        scaleOptions.effectScale = Math.sqrt(scale * scale + scale * scale) / Math.sqrt(2);
                        scaleOptions.scaleStrokeAndEffects = activeDocument.preferences.scaleStrokeAndEffects;
                        scaleOptions.scaleText = activeDocument.preferences.scaleText;
                        activeDocument.normalizeScaleElementList(elementListToScale, scaleOptions);
                    }

                }

                let pageToActivate = this.targetDocument.pageList.firstElementChild
                    if (this.options.import)
                        pageToActivate = newPage;

                    this.targetDocument.setActivePage(pageToActivate);
            }
        } else {
            // per il momento li rimuovo da qui
            const titleAndDescList = this.sourceSVG.querySelectorAll('title,desc');
            for (let i = 0; i < titleAndDescList.length; i++)
                titleAndDescList[i].remove();

            const activeDocument = activeApplication.activeDocument;

            if (!this.options.import) {
                const newPage = activeDocument.createNewPage();
                activeDocument.setActivePage(newPage);
            }

            const activePage = activeDocument.activePage;
            const activeLayer = activeDocument.getActivePageLayer();

            const addedElements = [].slice.call(this.sourceSVG.children, 0);
            this.sourceSVG.moveChildrenTo(activeLayer);
            if (!this.options.importInPlace)
                activeDocument.centerElementListAtGlobalPoint(addedElements, activePage.clientWidth / 2, activePage.clientHeight / 2);

            activeDocument.selectElementList(addedElements);
        }
    };

    parsePreferences() {
        const loadedPreferences = this.sourceSVG.getStoredJsonData('jvs-doc-preferences');
        //console.log('loadedPreferences',loadedPreferences.svgAlignmentPreserveAspectRatio );
        //Object.assign( this.targetDocument.preferences  , preferences ); // update changed properties in janvas

        const sanitizedPreferences = {};

        for (const p in this.targetDocument.preferences)
            sanitizedPreferences[p] = (p in loadedPreferences ? loadedPreferences : this.targetDocument.preferences)[p];

        for (const p in this.targetDocument.preferences.snap)
            sanitizedPreferences.snap[p] = (p in loadedPreferences.snap ? loadedPreferences.snap : this.targetDocument.preferences.snap)[p];

        delete sanitizedPreferences.snap.snapToLinearSegments; // una vecchia proprietà (ora si chiama snap to contour)

        return sanitizedPreferences;
        // this.targetDocument.preferences = sanitizedPreferences;

    }

    // parseAndCreatePage(_loadedSvgPage)
    // {
    //     const activeDocument = activeApplication.activeDocument;
    //
    //     const _pageWidth = _loadedSvgPage.dataset.width || _loadedSvgPage.dataset.pageWidth ||_loadedSvgPage.getAttribute('width') || 1024;
    //     const _pageHeight =_loadedSvgPage.dataset.height || _loadedSvgPage.dataset.pageHeight || _loadedSvgPage.getAttribute('height') || 768  ;
    //
    //     const pageWidth = parseFloat( _pageWidth ) ;
    //     const pageHeight = parseFloat( _pageHeight ) ;
    //
    //     const newSvgPage = activeDocument.createNewPage( pageWidth , pageHeight );
    //     // rimuovo il layer di default
    //     newSvgPage.querySelector('.layers .layer').remove();
    //
    //     newSvgPage.setAttribute('id',_loadedSvgPage.getAttribute('id')||'');
    //
    //     const loadedLayerList = _loadedSvgPage.querySelectorAll('.layers .layer');
    //     let newLayer,layerName,layerColor,loadedLayer;
    //     const layerListContainer = newSvgPage.querySelector('.layers');
    //     for (let i = 0; i < loadedLayerList.length; i++) {
    //         loadedLayer = loadedLayerList[i];
    //         layerName = loadedLayer.getAttribute('name');
    //         layerColor = loadedLayer.getAttribute('data-color');
    //         newLayer = activeDocument.createPageLayer( layerName , layerColor );
    //         layerListContainer.appendChild(newLayer);
    //         const addedElements = [].slice.call( loadedLayer.children, 0);
    //         loadedLayer.moveChildrenTo(newLayer);
    //         if(this.sourcePreferences)
    //         {
    //             let scale = this.sourcePreferences.drawingScale /activeDocument.preferences.drawingScale ;
    //             if( scale !== 1 ) activeDocument.scaleElementList( addedElements , scale , scale, {x:0,y:0} );
    //         }
    //
    //     }
    //
    //     // const guidesLayer = _loadedSvgPage.querySelector('.layer.guides');
    //     // guidesLayer.moveChildrenTo(newSvgPage.querySelector('.layer.guides'));
    //
    //     return newSvgPage;
    // };


}

class DXF_importer{

    constructor() {
        this.svgDocument = null;
        this.contentNode = null;
        this.activeLayer = null;
        this.scale = 1;
        this.createdEementsNum = 0;
        this.totalEntities = 0;
        this.parsedEntities = 0;
    }

    import(_data, _scale) {
        this.scale = _scale || this.scale;

        const parser = new DxfParser(); // la libreria che trasforma in json
        this.dxf = null;

        try {
            this.dxf = parser.parseSync(_data);
            console.log('DXF', this.dxf);
        } catch (err) {
            return console.error(err.stack);
        }

        this.parsedEntities = 0;
        this.totalEntities = this.dxf.entities.length;
        console.log('this.totalEntities', this.totalEntities);

        //this.parseEntitiesInLayerList( this.groupEntitiesByLayer(this.dxf.entities) , this.contentNode  );
        this.parseUnits();
        this.parseLayers();
        this.parseEntities();

    };

    colorToRGB(num) {
        num >>>= 0;
        var b = num & 0xFF,
        g = (num & 0xFF00) >>> 8,
        r = (num & 0xFF0000) >>> 16,
        a = 1;
        return "rgba(" + [r, g, b, a].join(",") + ")";
    };

    parseUnits() {
        // $INSUNITS
        // Default drawing units for AutoCAD DesignCenter blocks:
        // 0 = Unitless; 1 = Inches; 2 = Feet; 3 = Miles; 4 = Millimeters;
        // 5 = Centimeters; 6 = Meters; 7 = Kilometers; 8 = Microinches;
        // 9 = Mils; 10 = Yards; 11 = Angstroms; 12 = Nanometers;
        // 13 = Microns; 14 = Decimeters; 15 = Decameters;
        // 16 = Hectometers; 17 = Gigameters; 18 = Astronomical units;
        // 19 = Light years; 20 = Parsecs
        let unitKey = 'MILLIMETER';

        const dxfUnit = this.dxf.header['$INSUNITS'];
        switch (dxfUnit) {
        case 1:
            unitKey = 'INCH';
            break;
        case 2:
            unitKey = 'FEET';
            break;
        case 3:
            unitKey = 'MILE';
            break;
        case 4:
            unitKey = 'MILLIMETER';
            break;
        case 5:
            unitKey = 'CENTIMETER';
            break;
        case 6:
            unitKey = 'METER';
            break;
        case 7:
            unitKey = 'KILOMETER';
            break;
        }

        const activeDocument = activeApplication.activeDocument;
        activeDocument.setUnits(unitKey)

    }

    parseLayers() {
        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        const svgLayers = activePage.content.querySelector('.layers');

        const layerList = this.dxf.tables.layer.layers;

        for (let layerName in layerList) {
            const layerData = layerList[layerName];
            //const newSVGLayer = activeDocument.createPageLayer( layerData.name,this.colorToRGB( layerData.color ) );
            const newSVGLayer = activeDocument.createPageLayer(layerData.name);
            layerData.svgLayer = newSVGLayer;
            svgLayers.appendChild(newSVGLayer);
        }
    }

    parseEntities(entityList, _svgNodeTarget) {
        entityList = entityList || this.dxf.entities;
        //console.log('entityList',entityList);
        for (let i = 0; i < entityList.length; i++) {
            const entity = entityList[i];
            this.parseEntity(entity, _svgNodeTarget)
        }
    }

    parseEntity(_entity, _svgNodeTarget) {
        console.log('_entity.type', _entity.type);

        switch (_entity.type) {
        case "POLYLINE":
            if (_entity.includesCurveFitVertices) {
                console.log('-------includesCurveFitVertices-----------', _entity);
            }
            if (_entity.includesSplineFitVertices) {
                console.log('-------includesSplineFitVertices-----------', _entity);
            }
            this.parsePolyline(_entity, _svgNodeTarget);
            break;
        case "LINE":
            this.parseLine(_entity, _svgNodeTarget);
            break;
        case "LWPOLYLINE":
            this.parsePolyline(_entity, _svgNodeTarget);
            break;
        case "SPLINE":
            this.parseSpline(_entity, _svgNodeTarget);
            break;
        case "CIRCLE":
            this.parseCircle(_entity, _svgNodeTarget);
            break;
        case "ELLIPSE":
            this.parseEllipse(_entity, _svgNodeTarget);
            break;
        case "ARC":
            this.parseArc(_entity, _svgNodeTarget);
            break;
        case "DIMENSION":
            this.parseDimension(_entity, _svgNodeTarget);
            break;
        case "MTEXT":
            this.parseMText(_entity, _svgNodeTarget);
            break;
        case "INSERT":
            this.parseInsert(_entity, _svgNodeTarget);
            break;
        default:
            console.log('entity', _entity);
            break;
        }

        this.createdEementsNum++;
    }

    parsePolyline(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;
        const vertices = _entity.vertices;
        if (vertices.length === 0)
            return;

        if (vertices.length === 2) {
            this.parseLine(_entity);
            return;
        }

        const svgPath = SVGUtils.createPath();
        const geometryPointList = [];

        const self = this;

        function computeBulgeArc(p1, p2, bulge) {
            // https://github.com/mfarquhar/netDXF/blob/master/netDxf/Entities/LwPolyline.cs
            const theta = 4 * Math.atan(Math.abs(bulge));
            const c = p1.getDistanceFromPoint(p2);
            const r = (c / 2) / Math.sin(theta / 2);
            const gamma = (Math.PI - theta) / 2;
            const phi = GeometryUtils.getSegmentAngle(p1, p2) + Math.sign(bulge) * gamma;
            const center = SVGUtils.createSVGPoint(p1.x + r * Math.cos(phi), p1.y + r * Math.sin(phi));

            let startAngle = 0;
            let endAngle = 0;
            if (bulge > 0) {
                startAngle = GeometryUtils.getSegmentAngle(p1, center)
                    endAngle = startAngle + theta;
            } else {
                endAngle = GeometryUtils.getSegmentAngle(p1, center);
                startAngle = endAngle - theta;
            }

            return {
                'startAngle': startAngle,
                'endAngle': endAngle,
                'center': center,
                'radius': r,
                'clockwise': bulge < 0
            }
        }

        function createBulge(vertex1, vertex2, bulge) {
            const arcProperties = computeBulgeArc(SVGUtils.createSVGPoint(vertex1.x, -vertex1.y), SVGUtils.createSVGPoint(vertex2.x, -vertex2.y), bulge);
            let largeArcFlag = 0;
            if ((arcProperties.endAngle - arcProperties.startAngle) > Math.PI)
                largeArcFlag = 1;
            let sweepFlag = 0;
            if (arcProperties.clockwise)
                sweepFlag = 1;
            const radius = activeDocument.unitToValue(arcProperties.radius * self.scale);

            geometryPointList.push(
                svgPath.createGeometryPoint_ARCTO(radius, radius, 0, largeArcFlag, sweepFlag, activeDocument.unitToValue(vertex2.x * self.scale), activeDocument.unitToValue(-vertex2.y * self.scale)))
        }

        const vertex_moveTo = vertices[0];
        geometryPointList.push(svgPath.createGeometryPoint_MOVETO(activeDocument.unitToValue(vertex_moveTo.x * this.scale), activeDocument.unitToValue(-vertex_moveTo.y * this.scale)));

        let startIndex = 1;
        if (vertex_moveTo.bulge) {
            createBulge(vertices[0], vertices[1], vertex_moveTo.bulge);
            startIndex++;
        }

        for (let i = startIndex; i < vertices.length; i++) {
            const vertex = vertices[i];
            geometryPointList.push(svgPath.createGeometryPoint_LINETO(activeDocument.unitToValue(vertex.x * this.scale), activeDocument.unitToValue(-vertex.y * this.scale)));
            if (vertex.bulge) {
                if (i === (vertices.length - 1)) {
                    createBulge(vertices[i], vertices[0], vertex.bulge);
                } else {
                    createBulge(vertices[i], vertices[i + 1], vertex.bulge);
                    i++;
                }
            }
        }

        if (_entity.shape === true) {
            geometryPointList.push(svgPath.createGeometryPoint_CLOSEPATH());
            svgPath.setAttribute('fill', this.colorToRGB(_entity.color));
        } else {
            svgPath.setAttribute('fill', 'none');
        }

        svgPath.setGeometryPointList(geometryPointList);

        //svgPath.setAttribute('stroke' , this.colorToRGB( _entity.color ));
        svgPath.setAttribute('stroke', '#000000');
        svgPath.setAttribute('stroke-width', '1');

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgPath);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgPath);

        svgPath.renderRequest();
    }

    // NON USATO IN QUANTO IL RISULTATO è LO STESSO
    parseSpline_interpolate(_entity, _svgNodeTarget) {

        function interpolate(t, degree, points, knots, weights, result) {

            var i,
            j,
            s,
            l; // function-scoped iteration variables
            var n = points.length; // points count
            var d = points[0].length; // point dimensionality

            if (degree < 1)
                throw new Error('degree must be at least 1 (linear)');
            if (degree > (n - 1))
                throw new Error('degree must be less than or equal to point count - 1');

            if (!weights) {
                // build weight vector of length [n]
                weights = [];
                for (i = 0; i < n; i++) {
                    weights[i] = 1;
                }
            }

            if (!knots) {
                // build knot vector of length [n + degree + 1]
                var knots = [];
                for (i = 0; i < n + degree + 1; i++) {
                    knots[i] = i;
                }
            } else {
                if (knots.length !== n + degree + 1)
                    throw new Error('bad knot vector length');
            }

            var domain = [
                degree,
                knots.length - 1 - degree
            ];

            // remap t to the domain where the spline is defined
            var low = knots[domain[0]];
            var high = knots[domain[1]];
            t = t * (high - low) + low;

            if (t < low || t > high)
                throw new Error('out of bounds');

            // find s (the spline segment) for the [t] value provided
            for (s = domain[0]; s < domain[1]; s++) {
                if (t >= knots[s] && t <= knots[s + 1]) {
                    break;
                }
            }

            // convert points to homogeneous coordinates
            var v = [];
            for (i = 0; i < n; i++) {
                v[i] = [];
                for (j = 0; j < d; j++) {
                    v[i][j] = points[i][j] * weights[i];
                }
                v[i][d] = weights[i];
            }

            // l (level) goes from 1 to the curve degree + 1
            var alpha;
            for (l = 1; l <= degree + 1; l++) {
                // build level l of the pyramid
                for (i = s; i > s - degree - 1 + l; i--) {
                    alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i]);

                    // interpolate each component
                    for (j = 0; j < d + 1; j++) {
                        v[i][j] = (1 - alpha) * v[i - 1][j] + alpha * v[i][j];
                    }
                }
            }

            // convert back to cartesian and return
            var result = result || [];
            for (i = 0; i < d; i++) {
                result[i] = v[s][i] / v[s][d];
            }

            return result;
        }

        const activeDocument = activeApplication.activeDocument;

        const svgPath = SVGUtils.createPath();
        const geometryPointList = [];
        geometryPointList.push(svgPath.createGeometryPoint_MOVETO(activeDocument.unitToValue(_entity.controlPoints[0].x * this.scale), activeDocument.unitToValue(-_entity.controlPoints[0].y * this.scale)));

        const controlPoints = _entity.controlPoints.map(function (value) {
            return [value.x, value.y]
        });

        const vertices = [];

        for (let t = 0; t <= 100; t++) {
            vertices.push(interpolate(t / 100, _entity.degreeOfSplineCurve, controlPoints, _entity.knotValues));
        }

        for (let i = 0; i < vertices.length; i++) {
            let vertexX = vertices[i][0];
            let vertexY = vertices[i][1];
            geometryPointList.push(svgPath.createGeometryPoint_LINETO(activeDocument.unitToValue(vertexX * this.scale), activeDocument.unitToValue(-vertexY * this.scale)));
        }

        svgPath.setAttribute('stroke', '#000000');
        svgPath.setAttribute('stroke-width', '1');
        svgPath.setAttribute('fill', 'none');

        svgPath.setGeometryPointList(geometryPointList);
        svgPath.render();

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgPath);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgPath);

    }

    // Non funziona correttamente ( meglio convertire le spline in polyline dal programma che esporta in dxf)
    parseSpline(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;

        const svgPath = SVGUtils.createPath();
        const geometryPointList = [];
        geometryPointList.push(svgPath.createGeometryPoint_MOVETO(activeDocument.unitToValue(_entity.controlPoints[0].x * this.scale), activeDocument.unitToValue(-_entity.controlPoints[0].y * this.scale)));

        if (_entity.degreeOfSplineCurve === 2) {
            for (let i = 1; i < _entity.controlPoints.length - 1; i = i + 2) {
                const ctrlPoint1 = _entity.controlPoints[i];
                const targetPoint = _entity.controlPoints[i + 1];
                geometryPointList.push(svgPath.createGeometryPoint_CURVETO_QUADRATIC(
                        activeDocument.unitToValue(ctrlPoint1.x * this.scale),
                        activeDocument.unitToValue(-ctrlPoint1.y * this.scale),
                        activeDocument.unitToValue(targetPoint.x * this.scale),
                        activeDocument.unitToValue(-targetPoint.y * this.scale)))

            }
        } else if (_entity.degreeOfSplineCurve === 3) {
            for (let i = 0; i + 2 < _entity.controlPoints.length; i = i + 2) {
                const ctrlPoint1 = _entity.controlPoints[i];
                const ctrlPoint2 = _entity.controlPoints[i + 1];
                const targetPoint = _entity.controlPoints[i + 2];
                geometryPointList.push(svgPath.createGeometryPoint_CURVETO_CUBIC(
                        activeDocument.unitToValue(ctrlPoint1.x * this.scale),
                        activeDocument.unitToValue(-ctrlPoint1.y * this.scale),
                        activeDocument.unitToValue(ctrlPoint2.x * this.scale),
                        activeDocument.unitToValue(-ctrlPoint2.y * this.scale),
                        activeDocument.unitToValue(targetPoint.x * this.scale),
                        activeDocument.unitToValue(-targetPoint.y * this.scale)))

            }
        }

        svgPath.setAttribute('stroke', '#000000');
        svgPath.setAttribute('stroke-width', '1');
        svgPath.setAttribute('fill', 'none');

        svgPath.setGeometryPointList(geometryPointList);
        svgPath.render();

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgPath);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgPath);

    }

    parseCircle(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;

        const svgCircle = SVGUtils.createEllipse(
                activeDocument.unitToValue(_entity.center.x * this.scale),
                activeDocument.unitToValue(-_entity.center.y * this.scale),
                activeDocument.unitToValue(_entity.radius * this.scale),
                activeDocument.unitToValue(_entity.radius * this.scale));
        //svgCircle.setAttribute('stroke' , this.colorToRGB( _entity.color ));
        svgCircle.setAttribute('stroke', '#000000');
        svgCircle.setAttribute('stroke-width', '1');
        //svgCircle.setAttribute('fill' , 'none');
        svgCircle.setAttribute('fill', this.colorToRGB(_entity.color));

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgCircle);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgCircle);
    }

    parseEllipse(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;
        const radiusX = Math.sqrt(_entity.majorAxisEndPoint.x * _entity.majorAxisEndPoint.x + _entity.majorAxisEndPoint.y * _entity.majorAxisEndPoint.y);
        const radiusY = _entity.axisRatio * radiusX;
        const rotation = (Math.atan2(-_entity.majorAxisEndPoint.y, _entity.majorAxisEndPoint.x) / (Math.PI / 180));

        const svgEllipse = SVGUtils.createEllipse(0, 0, activeDocument.unitToValue(radiusX * this.scale), activeDocument.unitToValue(radiusY * this.scale));

        svgEllipse.setAttribute('stroke', '#000000');
        svgEllipse.setAttribute('stroke-width', '1');
        svgEllipse.setAttribute('fill', this.colorToRGB(_entity.color));

        let matrix = svgEllipse.getTransform().matrix;
        matrix = matrix.translate(activeDocument.unitToValue(_entity.center.x) * this.scale, activeDocument.unitToValue(((-_entity.center.y) * this.scale)));
        matrix = matrix.rotate(rotation);
        svgEllipse.getTransform().setMatrix(matrix);

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgEllipse);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgEllipse);
    }

    parseLine(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;
        const svgLine = SVGUtils.createLine(
                activeDocument.unitToValue(_entity.vertices[0].x * this.scale),
                activeDocument.unitToValue( - _entity.vertices[0].y * this.scale),
                activeDocument.unitToValue(_entity.vertices[1].x * this.scale),
                activeDocument.unitToValue( - _entity.vertices[1].y * this.scale));
        // svgLine.setAttribute('stroke' , this.colorToRGB( _entity.color ));
        svgLine.setAttribute('stroke', '#000000');
        svgLine.setAttribute('stroke-width', '1');

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgLine);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgLine);
    }

    parseMText(_entity, _svgNodeTarget) {
        console.log('parseMText _entity', _entity);
        const activeDocument = activeApplication.activeDocument;

        const splittedText = _entity.text.split(';');
        let textBox_x = activeDocument.unitToValue(_entity.position.x * this.scale);
        let textBox_y = activeDocument.unitToValue(-_entity.position.y * this.scale);
        let textBox_width = activeDocument.unitToValue(_entity.width * this.scale) || 100;
        let textBox_height = activeDocument.unitToValue(_entity.height * this.scale) || 26;
        let text = splittedText[1];
        text = text.replace(/\\P/g, '\n');
        const svgText = SVGUtils.createTextBox(textBox_x, textBox_y, textBox_width, textBox_height, text);

        svgText.__setAttribute('fill', this.colorToRGB(_entity.color));

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgText);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgText);
    }

    parseBlock(_entity, _svgNodeTarget) {
        // console.log('block' , _entity );
        // const svgUse = this.svgDocument.createUse ( 'symbol_'+_entity.name, _entity.position.x*this.scale , -_entity.position.y*this.scale  );
        // _svgLayer.appendChild(svgUse);
    };

    parseInsert(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;
        const symbolName = _entity.name;

        const block = this.dxf.blocks[symbolName];

        if (!block.svgSymbol) {
            const newSymbol = SVGUtils.createSymbol(symbolName);
            block.svgSymbol = newSymbol;
            this.parseEntities(block.entities, newSymbol);
            activeDocument.resources.addResource(newSymbol);
            newSymbol.style = "overflow:visible";
            newSymbol.setAttribute('overflow', "visible");
        }

        const position = SVGUtils.createSVGPoint(activeDocument.unitToValue(_entity.position.x * this.scale), activeDocument.unitToValue(-_entity.position.y * this.scale));
        const rotation = -_entity.rotation || 0;

        const svgUse = SVGUtils.createUse(symbolName);
        let matrix = svgUse.getTransform().matrix;
        matrix = matrix.translate(position.x, position.y)
            matrix = matrix.rotate(rotation);
        svgUse.getTransform().setMatrix(matrix);

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(svgUse);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(svgUse);

    };

    parseArc(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;

        const radius = activeDocument.unitToValue(_entity.radius * this.scale);
        // aggiusto gli angoli invertendoli
        const endAngle = -_entity.startAngle / (Math.PI / 180);
        const startAngle = -_entity.endAngle / (Math.PI / 180);
        const centerX = activeDocument.unitToValue(_entity.center.x * this.scale);
        const centerY = activeDocument.unitToValue(-_entity.center.y * this.scale);

        const objectController = OBJECTS['arc-object'];

        const svg = SVGUtils.createSVG();
        svg.innerHTML = objectController.create();

        const graphicElement = svg.firstElementChild;

        let matrix = graphicElement.getTransform().matrix;
        matrix = matrix.translate(centerX, centerY)
            graphicElement.getTransform().setMatrix(matrix);

        if (_svgNodeTarget) {
            _svgNodeTarget.appendChild(graphicElement);
            return;
        }

        const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
        svgLayer.appendChild(graphicElement);

        objectController.init(graphicElement);
        objectController.setProperties({
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle
        });

        // const svgPath = SVGUtils.createPath();
        // svgPath.buildArc( SVGUtils.createSVGPoint(), radius,startAngle,endAngle) ;
        //
        // svgPath.setAttribute('data-type' , 'object' );
        // svgPath.setAttribute('data-object-id' , 'arc-object' );
        // svgPath.storeJsonData("jvs-object-properties" , {radius:radius,startAngle:startAngle, endAngle:endAngle} );
        //
        // svgPath.setAttribute('stroke' , '#000000');
        // svgPath.setAttribute('stroke-width' , '1');
        // svgPath.setAttribute('fill' , 'none');
        //
        // svgPath.getTransform().setMatrix(svgPath.getTransform().matrix.translate(centerX,centerY));
        //


    };

    parseDimension(_entity, _svgNodeTarget) {
        const activeDocument = activeApplication.activeDocument;

        if (_entity.dimensionType === 32) {
            const pt1 = SVGUtils.createSVGPoint(activeDocument.unitToValue(_entity.linearOrAngularPoint1.x * this.scale), activeDocument.unitToValue(-_entity.linearOrAngularPoint1.y * this.scale));
            const pt2 = SVGUtils.createSVGPoint(activeDocument.unitToValue(_entity.linearOrAngularPoint2.x * this.scale), activeDocument.unitToValue(-_entity.linearOrAngularPoint2.y * this.scale));

            const svg = SVGUtils.createSVG();
            const objectController = OBJECTS["linear-dimension"];
            svg.innerHTML = objectController.create();
            const graphicElement = svg.firstElementChild;
            objectController.init(graphicElement);

            let height = 30;
            let startWitnessLineOffsetY = 3;
            let endWitnessLineOffsetY = 3;

            if (_entity.angle === -90) {
                const minX = Math.min(pt1.x, pt2.x);
                const maxX = Math.max(pt1.x, pt2.x);

                if (pt1.y < pt2.y) {
                    height = minX - activeDocument.unitToValue(_entity.anchorPoint.x * this.scale);
                    startWitnessLineOffsetY = minX - pt1.x + 5;
                    endWitnessLineOffsetY = minX - pt2.x + 5;
                    objectController.setLinearObjectPoints(SVGUtils.createSVGPoint(minX, pt1.y), SVGUtils.createSVGPoint(minX, pt2.y));
                } else {
                    height = activeDocument.unitToValue(_entity.anchorPoint.x * this.scale) - maxX;
                    startWitnessLineOffsetY = pt1.x - maxX + 5;
                    endWitnessLineOffsetY = pt2.x - maxX + 5;
                    objectController.setLinearObjectPoints(SVGUtils.createSVGPoint(maxX, pt1.y), SVGUtils.createSVGPoint(maxX, pt2.y));
                }

            } else {
                const minY = Math.min(pt1.y, pt2.y);
                const maxY = Math.max(pt1.y, pt2.y);

                if (pt1.x > pt2.x) {
                    height = minY - activeDocument.unitToValue(-_entity.anchorPoint.y * this.scale);
                    startWitnessLineOffsetY = minY - pt1.y + 5;
                    endWitnessLineOffsetY = minY - pt2.y + 5;
                    objectController.setLinearObjectPoints(SVGUtils.createSVGPoint(pt1.x, minY), SVGUtils.createSVGPoint(pt2.x, minY));
                } else {
                    height = activeDocument.unitToValue(-_entity.anchorPoint.y * this.scale) - maxY;
                    startWitnessLineOffsetY = pt1.y - maxY + 5;
                    endWitnessLineOffsetY = pt2.y - maxY + 5;
                    objectController.setLinearObjectPoints(SVGUtils.createSVGPoint(pt1.x, maxY), SVGUtils.createSVGPoint(pt2.x, maxY));
                }

            }

            objectController.setProperties({
                height: height,
                startWitnessLineOffsetY: startWitnessLineOffsetY,
                endWitnessLineOffsetY: endWitnessLineOffsetY
            })

            if (_svgNodeTarget) {
                _svgNodeTarget.appendChild(graphicElement);
                return;
            }

            const svgLayer = this.dxf.tables.layer.layers[_entity.layer].svgLayer;
            svgLayer.appendChild(graphicElement);
        }

        // if(_entity.dimensionType === 32)
        // {
        // 	const pt2 = SVGUtils.createSVGPoint( activeDocument.unitToValue(_entity.linearOrAngularPoint1.x * this.scale),  activeDocument.unitToValue(-_entity.linearOrAngularPoint1.y * this.scale) );
        // 	const pt1 = SVGUtils.createSVGPoint( activeDocument.unitToValue(_entity.linearOrAngularPoint2.x * this.scale),  activeDocument.unitToValue(-_entity.linearOrAngularPoint2.y * this.scale) );
        //
        // 	const svg = SVGUtils.createSVG();
        // 	const objectController = OBJECTS["linear-dimension"];
        // 	svg.innerHTML = objectController.create();
        // 	const graphicElement = svg.firstElementChild;
        // 	objectController.init( graphicElement );
        // 	objectController.setLinearObjectPoints( pt1,pt2 );
        //
        // 	objectController.setProperties({height:_entity.dimensionType})
        //
        // 	if(_svgNodeTarget)
        // 	{
        // 		_svgNodeTarget.appendChild(graphicElement);
        // 		return;
        // 	}
        //
        // 	const svgLayer = this.dxf.tables.layer.layers[ _entity.layer ].svgLayer;
        // 	svgLayer.appendChild(graphicElement);
        // }


    };

    // parseArc( _entity , _svgLayer )
    // {
    // 	//console.log('parseArc _entity' , _entity);
    // 	var radius = _entity.radius*this.scale;
    // 	var startAngle = _entity.startAngle;
    // 	var endAngle = _entity.endAngle;
    // 	var largeArc = 0;
    // 	var sweepFlag = 0;
    // 	var centerX = _entity.center.x*this.scale;
    // 	var centerY = -_entity.center.y*this.scale;
    //
    // 	var startAngleRadians = -startAngle;
    // 	var endAngleRadians = -endAngle;
    //
    //
    // 	var startX = Math.cos(startAngleRadians) * radius + centerX;
    // 	var startY = Math.sin(startAngleRadians) * radius + centerY;
    // 	var endX = Math.cos(endAngleRadians) * radius + centerX;
    // 	var endY = Math.sin(endAngleRadians) * radius + centerY;
    //
    // 	// Determine if it is a large arc
    // 	if ( (endAngle > startAngle) && ( (endAngle - startAngle) > Math.PI) ) largeArc=1;
    //
    // 	var svgPath = SVGUtils.createPath();
    // 	var pathData = [{type: "M", values:[startX,startY]},{ type: "A", values: [radius, radius, 0, largeArc, sweepFlag, endX, endY ] }];
    // 	svgPath.setPathData( pathData );
    // 	svgPath.setPathData( svgPath.getPathData({normalize:true}) );
    //
    // 	//svgPath.setAttribute('stroke' , this.colorToRGB( _entity.color ));
    // 	svgPath.setAttribute('stroke' , '#000000');
    // 	svgPath.setAttribute('stroke-width' , '1');
    // 	svgPath.setAttribute('fill' , 'none');
    //
    // 	const svgLayer = this.dxf.tables.layer.layers[ _entity.layer ].svgLayer;
    // 	svgLayer.appendChild(svgPath);
    //
    //
    //
    // };


    // parseBlocks( _blockList )
    // {
    // 	const activeDocument = activeApplication.activeDocument;
    // 	const defsNode = activeDocument.resources;
    // 	let blockName,svgSymbol;
    // 	for(  blockName in _blockList )
    // 	{
    // 		const block = _blockList[blockName];
    // 		svgSymbol = SVGUtils.createSymbol( 'symbol_'+blockName );
    // 		defsNode.appendChild(svgSymbol);
    // 		if(block.entities) this.parseEntitiesInLayerList( this.groupEntitiesByLayer(block.entities) , svgSymbol );
    // 	}
    // };


}

class WindowMenu_cmp extends PopUpMenu {

    constructor() {
        super();
        XOS.connectEvent("click", this, this.onclickMenuItem, this);
    }

    activateBy(_activatorElement) {
        this.update();
        super.activateBy(_activatorElement)
    }

    update() {
        const windowList = document.querySelectorAll('#FLOATING_WINDOWS .palette');
        //while(this.children.length>3)this.removeChild(this.firstElementChild ); questo quando c'è installa plugins
        while (this.firstElementChild)
            this.removeChild(this.firstElementChild);

        for (let i = 0; i < windowList.length; i++) {
            const menuItem = document.createElement('div');
            menuItem.windowRef = windowList[i];
            const windowTitle = windowList[i].querySelector('.head>.title').textContent;
            // menuItem.textContent=windowList[i].querySelector('.head>.title').textContent;
            menuItem.innerHTML = `<div class="checkbox"></div><span>${windowTitle}</span>`;
            this.insertBefore(menuItem, this.firstElementChild);
            if (!windowList[i].classList.contains('closed'))
                menuItem.classList.add('checked');
        }

    }

    onclickMenuItem(_e) {
        if (_e.target.windowRef) {
            _e.target.windowRef.open(true);

        } else {
            alert('install plugin...');
        }
    }

}
customElements.define("window-menu", WindowMenu_cmp);

class SymbolLibrary_cmp extends HTMLElement {

    constructor() {
        super();
        //activeApplication.libraryPanels[this.nodeName.toLowerCase()] = this;
        this.controlledElements = null;
        this.icon = this.querySelector('.icon');
        this.loadingProgress = this.querySelector('.loading-progress');
        this.svgContainer = this.querySelector('.svg-container');
        this.itemListElement = this.querySelector('ul');
        this.initTemplates();
        this.initShadowRoot();
        this.createEventHandlers();
        this.isEmpty = true;
        this.documentLibraryRef = null;
        this.iconsUrl = 'resources/icons/janvas-app-icons.svg';
    }

    initShadowRoot() {
        this.isolateContext = this.querySelector('.isolate-context');
        const itemListForShadowRoot = [].slice.call(this.isolateContext.children, 0);
        this.isolateContext.attachShadow({
            mode: 'open'
        });
        const max = itemListForShadowRoot.length;
        for (let id = 0; id < max; id++)
            this.isolateContext.shadowRoot.appendChild(itemListForShadowRoot[id]);
    };

    initTemplates() {
        this.itemPreviewTemplate = this.querySelector('ul li');
        this.itemPreviewTemplate.remove();
    };

    createEventHandlers() {
        this.controlledElements = XOS.connectDomEvents(this.querySelectorAll('[data-event]'), this);
        XOS.connectDomEvents(this.isolateContext.shadowRoot.querySelectorAll('[data-event]'), this);
    };

    onShow() {
        if (this.isEmpty) {
            this.onChange_libraryMenu();
            this.isEmpty = false;
        }

        //if(this.controlledElements.libraryMenu.value==='active-document') this.update();
    }

    onChange_libraryMenu() {
        const libraryMenu = this.controlledElements.libraryMenu;

        let option = libraryMenu.querySelector('[value="loaded-from-file"]');
        if (option)
            option.classList.add('hidden');

        option = libraryMenu.querySelector('[value="active-document"]');
        if (option)
            option.classList.add('hidden');

        if (libraryMenu.value === 'load-from-active-document') {
            libraryMenu.value = 'active-document';
            this.documentLibraryRef = activeApplication.activeDocument;
            //this.update();
            const option = libraryMenu.querySelector('[value="active-document"]');
            option.classList.remove('hidden');
            //option.text = document.querySelector('document-tab-bar>ul>li.selected .label').innerHTML;
            this.createLibraryFromActiveDocument();
            return;
        }

        if (libraryMenu.value === 'load-from-file') {
            //this.loadingProgress.showElement();
            XOS.showElement(this.loadingProgress);
            const self = this;

            function onFileChoosed(_e) {
                const file = _e.target.files[0];
                const option = libraryMenu.querySelector('[value="loaded-from-file"]');
                option.classList.remove('hidden');
                option.text = "File:" + file.name;
                LOCAL_FILE_SYSTEM.readXMLFile(file, function (xmlDocument) {
                    self.createLibrary(xmlDocument);
                });
                //XOS.showElement(self.icon);
                libraryMenu.value = 'loaded-from-file';
            }
            LOCAL_FILE_SYSTEM.chooseFile('image/svg+xml', onFileChoosed);
            return;
        }

        if (libraryMenu.options[libraryMenu.selectedIndex].dataset.url) {
            //this.loadingProgress.showElement();
            XOS.showElement(this.loadingProgress);
            const self = this;
            function onLoadRemoteFile(_e) {
                self.createLibrary(_e.target.responseXML.querySelector('svg'));
                //self.icon.showElement();
            }
            XOS.sendAndLoad(libraryMenu.options[libraryMenu.selectedIndex].dataset.url, null, null, onLoadRemoteFile);
            return;
        }

    };

    update() {
        console.log('UPDATE');
        //if( (this.parentElement.offsetParent === null) ) return;

        // if(  this.isEmpty )
        // {
        // 	this.onChange_libraryMenu();
        // 	this.isEmpty=false;
        // }

        // if(this.controlledElements.libraryMenu.value==='active-document' || this.isEmpty===true )
        // {
        // 	const libraryMenu = this.controlledElements.libraryMenu;
        // 	if(libraryMenu.value==='active-document')
        // 	{
        // 		const option = libraryMenu.querySelector('[value="active-document"]');
        // 		option.classList.remove('hidden');
        // 		option.text = document.querySelector('document-tab-bar>ul>li.selected .label').innerHTML;
        // 		this.createLibraryFromActiveDocument();
        // 	}
        //
        // 	this.isEmpty=false;
        // }


    }

    createLibraryFromActiveDocument() {
        this.createLibrary(activeApplication.activeDocument.resources);
    }

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        const svg = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
        const defsNode = _svgDocument.querySelector('defs').cloneNode(true);
        svg.appendChild(defsNode);
        this.svgContainer.appendChild(svg);
        this.drawLibraryItemList(this.svgContainer.querySelectorAll('symbol'));
    }

    drawLibraryItemList(_itemList) {
        console.log('drawLibraryItemList');
        const itemList = _itemList;
        this.itemListElement.removeChildren();
        let symbol,
        use,
        item,
        svg,
        bbox,
        idSymbol;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            symbol = itemList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            idSymbol = symbol.getAttribute('id');
            item.querySelector('.label').innerHTML = idSymbol;
            item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
            use = SVGUtils.createUse(idSymbol);
            svg = item.querySelector('svg');
            svg.appendChild(use);
            this.itemListElement.appendChild(item);
            bbox = use.getBBox();
            svg.setAttribute('viewBox', 0 + ' ' + 0 + ' ' + (bbox.x + (bbox.width / 2)) * 2 + ' ' + (bbox.x + (bbox.width / 2)) * 2);
        }
    };

    onStartDragItem(_e) {
        const symbolID = _e.target.querySelector('use').getAttribute('href');
        const symbol = this.svgContainer.querySelector(symbolID);
        XOS.setTransferData({
            type: 'svg-symbol',
            symbol: symbol
        });
    }

    checkForDoubleClick(_e) {
        if (this.lastPointerDownEvent) {
            if ((_e.timeStamp - this.lastPointerDownEvent.timeStamp) < 250) {
                _e.isDoubleClick = true;
            }
        }
        this.lastPointerDownEvent = _e;
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;

        XOS.selectElement(clickedItem);

        this.checkForDoubleClick(_e);

        if (_e.isDoubleClick) {
            if (this.controlledElements.libraryMenu.value === 'active-document') {
                const elementID = clickedItem.querySelector('use').getAttribute('href').split("#")[1];
                const defItem = activeApplication.activeDocument.resources.getResourceById(elementID);
                if (defItem)
                    this.renameItem(defItem);
            }
        }
    }

    renameItem(_defItem) {
        const promptDialog = DIALOGS['promptDialog'];
        const alertDialog = DIALOGS['alert-dialog'];
        const itemType = _defItem.nodeName;
        const itemName = localString(itemType);
        const itemID = _defItem.getAttribute('id');

        const activeLibrary = this;

        function onClick_ok() {
            let newItemID = promptDialog.getPromptValue();
            if (newItemID === '') {
                this.close();
                return;
            }

            if (activeApplication.activeDocument.resources.getResourceById(newItemID)) {
                alertDialog.open(localString('Existent ID'), localString('The document already contains an element with ID:') + ': ' + newItemID);
                return;
            }

            const activeDocument = activeApplication.activeDocument;
            const activePage = activeDocument.activePage;
            activeDocument.refactorElementID(_defItem, newItemID); // non è undable

            //activeLibrary.update();
            activeLibrary.createLibraryFromActiveDocument();

            this.close();

            activeDocument.showSelectionProperties();
        }

        const dialogIconUrl = this.icon.querySelector('use').getAttribute('xlink:href');
        promptDialog.open(localString('Rename element'), localString('Insert a new name.'), onClick_ok, null, dialogIconUrl);
        promptDialog.setPromptValue(itemID, localString(itemName + ' name'));
    }

}

customElements.define("symbol-library", SymbolLibrary_cmp);

class ShapeLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
        //this.libraryItemType = 'svg-symbol-as-shape';
    }

    onStartDragItem(_e) {
        const symbolID = _e.target.querySelector('use').getAttribute('href');
        const symbol = this.svgContainer.querySelector(symbolID);
        XOS.setTransferData({
            type: 'svg-symbol-as-shape',
            symbol: symbol
        });
    }

}

customElements.define("shape-library", ShapeLibrary_cmp);

class FilterLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    initTemplates() {
        this.itemGraphicFilterPreviewTemplate = this.querySelector('ul li.graphic-filter-preview');
        this.itemGraphicFilterPreviewTemplate.remove();
        this.itemImageFilterPreviewTemplate = this.querySelector('ul li.image-filter-preview');
        this.itemImageFilterPreviewTemplate.remove();
    };

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        const svg = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
        const defsNode = _svgDocument.querySelector('defs').cloneNode(true);
        svg.appendChild(defsNode);
        this.svgContainer.appendChild(svg);
        this.drawLibraryItemList(this.svgContainer.querySelectorAll('filter'));
    }

    drawLibraryItemList(_itemList) {
        this.itemListElement.removeChildren();
        const itemList = _itemList;
        let filter,
        item,
        filterDisplay,
        filterID;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            filter = itemList[i];
            if (filter.hasAttribute("data-preview") && filter.getAttribute("data-preview") === 'graphic-filter-preview') {
                item = this.itemGraphicFilterPreviewTemplate.cloneNode(true);
            } else {
                item = this.itemImageFilterPreviewTemplate.cloneNode(true);
            }

            filterID = filter.getAttribute('id');
            item.querySelector('.label').innerHTML = filterID;
            filterDisplay = item.querySelector('.filterDisplay');
            item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
            filterDisplay.setAttribute('filter', 'url(#' + filterID + ')');

            this.itemListElement.appendChild(item);
        }
    }

    onStartDragItem(_e) {
        const itemId = SVGUtils.extractIdFromIRI(_e.target.querySelector('.filterDisplay').getAttribute('filter'));
        const filter = this.svgContainer.querySelector('#' + itemId);
        XOS.setTransferData({
            type: 'svg-filter',
            filter: filter
        });
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        //clickedItem.selectElement();
        XOS.selectElement(clickedItem);

        const filterID = SVGUtils.extractIdFromIRI(clickedItem.querySelector('.filterDisplay').getAttribute('filter'));
        let filter = activeApplication.activeDocument.resources.getResourceById(filterID);

        this.checkForDoubleClick(_e);

        if (_e.isDoubleClick && filter) {

            if (this.controlledElements.libraryMenu.value === 'active-document') {
                this.renameItem(filter);
                return;
            }
        }

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return;

        // const filterID =   SVGUtils.extractIdFromIRI(clickedItem.querySelector('.filterDisplay').getAttribute('filter'));
        // let filter  = activeApplication.activeDocument.resources.getResourceById(filterID);
        if (!filter) {
            filter = this.svgContainer.querySelector('#' + filterID).cloneNode(true);
            activeDocument.resources.addResource(filter);
        }

        const propertyObject = {};
        propertyObject['filter'] = 'url(#' + filterID + ')';
        activeDocument.setAttributeElementList_undable(activePage.selectionList, propertyObject);
        //activeDocument.showSelectionProperties();


    };

}

customElements.define("filter-library", FilterLibrary_cmp);

class FontLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    onChange_libraryMenu() {
        const libraryMenu = this.controlledElements.libraryMenu;

        if (libraryMenu.value === 'searchFonts') {
            this.classList.add('search-fonts');
            this.querySelector('input[type="search"]').value = '';
        } else {
            this.classList.remove('search-fonts');
        }

        this.drawLibraryItemList();
    }

    drawLibraryItemList(_fontFamilyList) {
        //this.loadingProgress.showElement();

        const libraryMenu = this.controlledElements.libraryMenu;
        const selectedFontCategory = libraryMenu.value;
        let showCheckbox;

        if (_fontFamilyList) {
            showCheckbox = true;
        } else {
            if (selectedFontCategory === 'selectedFonts') {
                _fontFamilyList = GoogleFonts.getSelectedFontList();
                showCheckbox = true;
            } else if (selectedFontCategory === 'defaultFonts') {
                _fontFamilyList = GoogleFonts.defaultFontFamilyList;
                showCheckbox = false;
            } else {
                _fontFamilyList = GoogleFonts.fontCategories[selectedFontCategory];
                showCheckbox = true;
            }
        }

        this.itemListElement.removeChildren();

        let fontData,
        item,
        checkBox;
        const max = _fontFamilyList.length;
        for (let i = 0; i < max; i++) {
            fontData = _fontFamilyList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            item.data = fontData;
            item.querySelector('img').setAttribute('src', '/data/janvas_6.2/fonts/_previews/' + (fontData.family.replace(/ /g, '-')) + '.png');
            //item.querySelector('.title').innerHTML = fontData.family;
            item.querySelector('.label').innerHTML = fontData.family;
            checkBox = item.querySelector('input[type="checkbox"]');
            if (showCheckbox) {
                if (fontData.isSelected)
                    checkBox.checked = true;
            } else {
                checkBox.remove();
            }
            this.itemListElement.appendChild(item);
        }

        //this.icon.showElement();
    }

    onStartDragItem(_e) {
        //const colorValue = _e.target.querySelector('rect.colorDisplay').getAttribute('fill');
        //XOS.setTransferData( { type:'svg-font', colorValue:colorValue } );
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        XOS.selectElement(clickedItem);

        const fontData = clickedItem.data;
        if (_e.target.nodeName === 'INPUT') {
            fontData.isSelected = _e.target.checked;
            if (this.controlledElements.libraryMenu.value === 'selectedFonts')
                this.drawLibraryItemList();
        } else {
            const activeDocument = activeApplication.activeDocument;
            const activePage = activeDocument.activePage;
            if (activePage.selectionList.length === 0)
                return;
            activeDocument.applyFontElementList_undable(activePage.selectionList, fontData);
        }
    };

    onChange_searchFont(_e) {
        const self = this;
        function onTimeout() {
            self.searchChangeTimeout = undefined;
            self.drawLibraryItemList(GoogleFonts.findFontList(_e.target.value));
        }

        clearTimeout(this.searchChangeTimeout);
        this.searchChangeTimeout = setTimeout(onTimeout, 250);
    }
}

customElements.define("font-library", FontLibrary_cmp);

class MarkerLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        const svg = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
        const defsNode = _svgDocument.querySelector('defs').cloneNode(true);
        svg.appendChild(defsNode);
        this.svgContainer.appendChild(svg);
        this.drawLibraryItemList(this.svgContainer.querySelectorAll('marker'));
    }

    drawLibraryItemList(_itemList) {
        this.itemListElement.removeChildren();
        //const itemList = this.svgContainer.firstElementChild.children;
        const itemList = _itemList;
        let marker,
        item,
        idMarker;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            marker = itemList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            idMarker = marker.getAttribute('id');
            // item.querySelector('.title').innerHTML = idMarker;
            item.querySelector('.label').innerHTML = idMarker;
            item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
            item.querySelector('line').setAttribute('marker-end', 'url(#' + idMarker + ')');
            this.itemListElement.appendChild(item);
        }
    };

    onStartDragItem(_e) {
        const itemId = SVGUtils.extractIdFromIRI(_e.target.querySelector('line').getAttribute('marker-end'));
        const marker = this.svgContainer.querySelector('#' + itemId);
        XOS.setTransferData({
            type: 'svg-marker',
            marker: marker
        });
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        XOS.selectElement(clickedItem)

        const markerID = SVGUtils.extractIdFromIRI(clickedItem.querySelector('line').getAttribute('marker-end'));
        let marker = activeApplication.activeDocument.resources.getResourceById(markerID);

        this.checkForDoubleClick(_e);

        if (_e.isDoubleClick && marker) {

            if (this.controlledElements.libraryMenu.value === 'active-document') {
                this.renameItem(marker);
                return;
            }
        }

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return;

        if (!marker) {
            marker = this.svgContainer.querySelector('#' + markerID).cloneNode(true);
            activeApplication.activeDocument.resources.addResource(marker);
        }

        const activeMarkerSide = PANELS['markers-inspector'].getActiveMarkerSideName();
        const propertyObject = {};
        propertyObject[activeMarkerSide] = 'url(#' + markerID + ')';
        activeDocument.setAttributeElementList_undable(activePage.selectionList, propertyObject);
        //activePage.showSelectionProperties();

    };

}

customElements.define("marker-library", MarkerLibrary_cmp);

class ColorLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    createLibraryFromActiveDocument() {
        this.createLibrary(activeApplication.activeDocument.shadowRoot);
    }

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        this.itemListElement.removeChildren();
        this.definedColorList = []; // serve solo a controllare che non ci siano doppioni
        this.drawLibraryItemList(_svgDocument.querySelectorAll('[fill]:not([fill^="url"]):not([fill="none"]):not([fill=""])'), 'fill');
        this.drawLibraryItemList(_svgDocument.querySelectorAll('[stroke]:not([stroke^="url"]):not([stroke="none"]):not([stroke=""])'), 'stroke');
    }

    drawLibraryItemList(_itemList, _graphicSide) {
        const itemList = _itemList;
        let graphicElement,
        item,
        colorValue,
        opacity,
        colorDisplay;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            graphicElement = itemList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            colorValue = graphicElement.getAttribute(_graphicSide);
            opacity = graphicElement.getAttribute(_graphicSide + '-opacity') || 1;
            if (this.definedColorList.indexOf(colorValue + ',' + opacity) === -1) {
                item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
                colorDisplay = item.querySelector('rect.colorDisplay');
                colorDisplay.setAttribute('fill', colorValue);
                colorDisplay.setAttribute('fill-opacity', opacity);
                this.itemListElement.appendChild(item);
                this.definedColorList.push(colorValue + ',' + opacity);
            }
        }
    };

    onStartDragItem(_e) {
        const colorValue = _e.target.querySelector('rect.colorDisplay').getAttribute('fill');
        XOS.setTransferData({
            type: 'svg-color',
            colorValue: colorValue
        });
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        XOS.selectElement(clickedItem);

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;
        if (activePage.selectionList.length === 0)
            return;

        const activeGraphicSide = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const propertyObject = {};
        propertyObject[activeGraphicSide] = clickedItem.querySelector('rect.colorDisplay').getAttribute('fill');
        activeDocument.setAttributeElementList_undable(activePage.selectionList, propertyObject);
        //activePage.showSelectionProperties();
    };

}

customElements.define("color-library", ColorLibrary_cmp);

class GradientLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        const svg = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
        const defsNode = _svgDocument.querySelector('defs').cloneNode(true);
        svg.appendChild(defsNode);
        this.svgContainer.appendChild(svg);
        this.drawLibraryItemList(this.svgContainer.querySelectorAll('linearGradient ,radialGradient'));
    }

    drawLibraryItemList(_itemList) {
        this.itemListElement.removeChildren();
        const itemList = _itemList;
        //const itemList = this.svgContainer.firstElementChild.children;
        let gradient,
        item,
        gradientDisplay,
        idGradient;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            gradient = itemList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            idGradient = gradient.getAttribute('id');
            //item.querySelector('.title').innerHTML = idGradient;
            item.querySelector('.label').innerHTML = idGradient;
            gradientDisplay = item.querySelector('rect.gradientDisplay');
            item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
            gradientDisplay.setAttribute('fill', 'url(#' + idGradient + ')');
            this.itemListElement.appendChild(item);
        }
    }

    onStartDragItem(_e) {
        const itemId = SVGUtils.extractIdFromIRI(_e.target.querySelector('rect.gradientDisplay').getAttribute('fill'));
        const gradient = this.svgContainer.querySelector('#' + itemId);
        XOS.setTransferData({
            type: 'svg-gradient',
            gradient: gradient
        });
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        XOS.selectElement(clickedItem);

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const gradientID = SVGUtils.extractIdFromIRI(clickedItem.querySelector('rect.gradientDisplay').getAttribute('fill'));
        let gradient = activeDocument.resources.getResourceById(gradientID);

        this.checkForDoubleClick(_e);

        if (_e.isDoubleClick && gradient) {

            if (this.controlledElements.libraryMenu.value === 'active-document') {
                this.renameItem(gradient);
                return;
            }
        }

        if (activePage.selectionList.length === 0)
            return;

        if (!gradient) {
            gradient = this.svgContainer.querySelector('#' + gradientID).cloneNode(true);
            activeDocument.resources.addResource(gradient);
        }

        const activeGraphicSide = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const propertyObject = {};
        propertyObject[activeGraphicSide] = 'url(#' + gradientID + ')';
        propertyObject[activeGraphicSide + '-opacity'] = '1';
        activeDocument.setAttributeElementList_undable(activePage.selectionList, propertyObject);
        //activePage.showSelectionProperties();

    };

}

customElements.define("gradient-library", GradientLibrary_cmp);

class PatternLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    createLibrary(_svgDocument) {
        XOS.hideElement(this.loadingProgress);
        this.svgContainer.removeChildren();
        const svg = document.createElementNS(SVGSVGElement.SVG_NS, "svg");
        const defsNode = _svgDocument.querySelector('defs').cloneNode(true);
        svg.appendChild(defsNode);
        this.svgContainer.appendChild(svg);
        this.drawLibraryItemList(this.svgContainer.querySelectorAll('pattern'));
    }

    drawLibraryItemList(_itemList) {
        this.itemListElement.removeChildren();
        const itemList = _itemList;
        // const itemList = this.svgContainer.firstElementChild.children;
        let pattern,
        item,
        patternDisplay,
        idPattern;
        const max = itemList.length;
        for (let i = 0; i < max; i++) {
            pattern = itemList[i];
            item = this.itemPreviewTemplate.cloneNode(true);
            idPattern = pattern.getAttribute('id');
            // item.querySelector('.title').innerHTML = idPattern;
            item.querySelector('.label').innerHTML = idPattern;
            patternDisplay = item.querySelector('rect.patternDisplay');
            item.ondragstart = XOS.bindFunction(this, this.onStartDragItem);
            patternDisplay.setAttribute('fill', 'url(#' + idPattern + ')');
            this.itemListElement.appendChild(item);
        }
    };

    onStartDragItem(_e) {
        const itemId = SVGUtils.extractIdFromIRI(_e.target.querySelector('rect.patternDisplay').getAttribute('fill'));
        const pattern = this.svgContainer.querySelector('#' + itemId);
        XOS.setTransferData({
            type: 'svg-pattern',
            pattern: pattern
        });
    }

    onClickItemList(_e) {
        const clickedItem = _e.target.closest('li');
        if (!clickedItem)
            return;
        XOS.selectElement(clickedItem);

        const activeDocument = activeApplication.activeDocument;
        const activePage = activeDocument.activePage;

        const patternID = SVGUtils.extractIdFromIRI(clickedItem.querySelector('rect.patternDisplay').getAttribute('fill'));
        let pattern = activeDocument.resources.getResourceById(patternID);

        this.checkForDoubleClick(_e);

        if (_e.isDoubleClick && pattern) {
            if (this.controlledElements.libraryMenu.value === 'active-document') {
                this.renameItem(pattern);
                return;
            }
        }

        if (activePage.selectionList.length === 0)
            return;

        if (!pattern) {
            pattern = this.svgContainer.querySelector('#' + patternID).cloneNode(true);
            activeDocument.resources.addResource(pattern);
        }

        const activeGraphicSide = activeDocument.fillAndStrokeManager.focusedGraphicSideName;
        const propertyObject = {};
        propertyObject[activeGraphicSide] = 'url(#' + patternID + ')';
        propertyObject[activeGraphicSide + '-opacity'] = '1';
        activeDocument.setAttributeElementList_undable(activePage.selectionList, propertyObject);
        //activePage.showSelectionProperties();

    };

}

customElements.define("pattern-library", PatternLibrary_cmp);

class WidgetLibrary_cmp extends SymbolLibrary_cmp {

    constructor() {
        super();
    }

    onStartDragItem(_e) {
        const symbolID = _e.target.querySelector('use').getAttribute('href');
        const symbol = this.svgContainer.querySelector(symbolID);
        XOS.setTransferData({
            type: 'svg-symbol-as-widget',
            symbol: symbol
        });
    }

}

customElements.define("widget-library", WidgetLibrary_cmp);
