/**
 * English translations for the Gantt component
 * including English translations for the Scheduler component
 *
 * NOTE: To change locale for month/day names you have to use the corresponding Ext JS language file.
 */
Ext.define('Gnt.locale.En', {
    extend: 'Sch.locale.Locale',
    requires: 'Sch.locale.En',
    singleton: true,
    l10n: {
        'Gnt.util.DurationParser': {
            unitsRegex: {
                MILLI: /^ms$|^mil/i,
                SECOND: /^s$|^sec/i,
                MINUTE: /^m$|^min/i,
                HOUR: /^h$|^hr$|^hour/i,
                DAY: /^d$|^day/i,
                WEEK: /^w$|^wk|^week/i,
                MONTH: /^mo|^mnt/i,
                QUARTER: /^q$|^quar|^qrt/i,
                YEAR: /^y$|^yr|^year/i
            }
        },
        'Gnt.util.DependencyParser': {
            typeText: {
                SS: 'SS',
                SF: 'SF',
                FS: 'FS',
                FF: 'FF'
            }
        },
        'Gnt.panel.Timeline': {
            start: 'Start',
            end: 'End',
            format: 'm/d/Y'
        },
        'Gnt.field.ShowInTimeline': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.column.ShowInTimeline': {
            text: 'Show in timeline'
        },
        'Gnt.field.ConstraintType': {
            none: 'None',
            invalidText: 'Invalid value'
        },
        'Gnt.field.Duration': {
            invalidText: 'Invalid value'
        },
        'Gnt.field.Cost': {
            invalidText: 'Invalid value',
            currencySymbol: '$',
            currencySymbolAlign: 'left'
        },
        'Gnt.field.Effort': {
            invalidText: 'Invalid effort value'
        },
        'Gnt.field.Percent': {
            invalidText: 'Invalid value'
        },
        'Gnt.field.SchedulingMode': {
            Normal: 'Normal',
            FixedDuration: 'Fixed duration',
            EffortDriven: 'Effort driven',
            DynamicAssignment: 'Dynamic assignment',
            invalidText: 'Invalid value'
        },
        'Gnt.template.Deadline': {
            deadline: 'Deadline'
        },
        'Gnt.column.DeadlineDate': {
            text: 'Deadline'
        },
        'Gnt.Tooltip': {
            startText: 'Starts: ',
            endText: 'Ends: ',
            durationText: 'Duration: '
        },
        'Gnt.template.TaskTooltip': {
            startText: 'Start',
            endText: 'End',
            percentText: 'Complete',
            format: 'm/d/Y',
            overflowText: 'There {[values.nbrOverflowing > 1 ? "are" : "is"]} {nbrOverflowing} more {[values.nbrOverflowing > 1 ? "tasks" : "task"]}'
        },
        'Gnt.plugin.ProjectLines': {
            startOf: 'Start of:',
            endOf: 'End of:'
        },
        'Gnt.plugin.TaskContextMenu': {
            taskInformation: 'Task information...',
            projectInformation: 'Project information...',
            newTaskText: 'New task',
            deleteTask: 'Delete task(s)',
            editLeftLabel: 'Edit left label',
            editRightLabel: 'Edit right label',
            add: 'Add...',
            deleteDependency: 'Delete dependency...',
            addTaskAbove: 'Task above',
            addTaskBelow: 'Task below',
            addMilestone: 'Milestone',
            addSubtask: 'Sub-task',
            addSuccessor: 'Successor',
            addPredecessor: 'Predecessor',
            convertToMilestone: 'Convert to milestone',
            convertToRegular: 'Convert to regular task',
            splitTask: 'Split task'
        },
        'Gnt.plugin.DependencyEditor': {
            fromText: 'From',
            toText: 'To',
            typeText: 'Type',
            lagText: 'Lag',
            endToStartText: 'Finish-To-Start',
            startToStartText: 'Start-To-Start',
            endToEndText: 'Finish-To-Finish',
            startToEndText: 'Start-To-Finish',
            okButtonText: 'Ok',
            cancelButtonText: 'Cancel',
            deleteButtonText: 'Delete'
        },
        'Gnt.widget.calendar.Calendar': {
            format: 'm/d/Y',
            dateInTextFormat: 'M j, Y',
            dayOverrideNameHeaderText: 'Name',
            overrideName: 'Name',
            startDate: 'Start Date',
            endDate: 'End Date',
            error: 'Error',
            dateText: 'Date',
            addText: 'Add',
            editText: 'Edit',
            removeText: 'Remove',
            workingDayText: 'Working day',
            weekendsText: 'Weekends',
            overriddenDayText: 'Overridden day',
            overriddenWeekText: 'Overridden week',
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time',
            dayOverridesText: 'Day overrides',
            weekOverridesText: 'Week overrides',
            okText: 'OK',
            cancelText: 'Cancel',
            parentCalendarText: 'Parent calendar',
            noParentText: 'No parent',
            selectParentText: 'Select parent',
            newDayName: '[Without name]',
            calendarNameText: 'Calendar name',
            isProjectCalendarText: 'Project calendar',
            tplTexts: {
                tplWorkingHours: 'Working hours for',
                tplIsNonWorking: 'is non-working',
                tplOverride: 'override',
                tplInCalendar: 'in calendar',
                tplDayInCalendar: 'standard day in calendar',
                tplBasedOn: 'Based on'
            },
            overrideErrorText: 'There is already an override for this day',
            overrideDateError: 'There is already a week override on this date: {0}',
            startAfterEndError: 'Start date should be less than end date',
            weeksIntersectError: 'Week overrides should not intersect'
        },
        'Gnt.widget.calendar.AvailabilityGrid': {
            startText: 'Start',
            endText: 'End',
            addText: 'Add',
            removeText: 'Remove',
            error: 'Error'
        },
        'Gnt.widget.calendar.DayEditor': {
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time'
        },
        'Gnt.widget.calendar.WeekEditor': {
            defaultTimeText: 'Default time',
            workingTimeText: 'Working time',
            nonworkingTimeText: 'Non-working time',
            error: 'Error',
            noOverrideError: "Week override contains only 'default' days - can't save it"
        },
        'Gnt.widget.calendar.ResourceCalendarGrid': {
            name: 'Name',
            calendar: 'Calendar'
        },
        'Gnt.widget.calendar.CalendarWindow': {
            title: 'Calendar',
            ok: 'Ok',
            cancel: 'Cancel'
        },
        'Gnt.widget.calendar.CalendarManager': {
            addText: 'Add',
            removeText: 'Remove',
            add_child: 'Add child',
            add_node: 'Add calendar',
            add_sibling: 'Add sibling',
            remove: 'Remove',
            calendarName: 'Calendar',
            confirm_action: 'Confirm action',
            confirm_message: 'Calendar has unsaved changes. Would you like to save your changes?'
        },
        'Gnt.widget.calendar.CalendarManagerWindow': {
            title: 'Calendar manager',
            ok: 'Apply changes',
            cancel: 'Close',
            confirm_action: 'Confirm action',
            confirm_message: 'Calendar has unsaved changes. Would you like to save your changes?'
        },
        'Gnt.field.Assignment': {
            cancelText: 'Cancel',
            closeText: 'Save and Close'
        },
        'Gnt.column.AssignmentUnits': {
            text: 'Units'
        },
        'Gnt.column.Duration': {
            text: 'Duration'
        },
        'Gnt.column.Effort': {
            text: 'Effort'
        },
        'Gnt.column.BaselineEffort': {
            text: 'Baseline Effort'
        },
        'Gnt.column.ActualEffort': {
            text: 'Actual Effort'
        },
        'Gnt.column.EffortVariance': {
            text: 'Effort Variance'
        },
        'Gnt.column.Cost': {
            text: 'Cost'
        },
        'Gnt.column.BaselineCost': {
            text: 'Baseline Cost'
        },
        'Gnt.column.ActualCost': {
            text: 'Actual Cost'
        },
        'Gnt.column.CostVariance': {
            text: 'Cost Variance',
            currencySymbol: '$',
            currencySymbolAlign: 'left'
        },
        'Gnt.column.EndDate': {
            text: 'Finish'
        },
        'Gnt.column.PercentDone': {
            text: '% Done'
        },
        'Gnt.column.ResourceAssignment': {
            text: 'Assigned Resources'
        },
        'Gnt.column.ResourceName': {
            text: 'Resource Name'
        },
        'Gnt.column.Rollup': {
            text: 'Rollup task',
            no: 'No',
            yes: 'Yes'
        },
        'Gnt.field.ManuallyScheduled': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.field.ReadOnly': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.column.ManuallyScheduled': {
            text: 'Manual mode'
        },
        'Gnt.column.SchedulingMode': {
            text: 'Mode'
        },
        'Gnt.column.Predecessor': {
            text: 'Predecessors'
        },
        'Gnt.column.Successor': {
            text: 'Successors'
        },
        'Gnt.column.StartDate': {
            text: 'Start'
        },
        'Gnt.column.WBS': {
            text: 'WBS'
        },
        'Gnt.column.Sequence': {
            text: '#'
        },
        'Gnt.column.Calendar': {
            text: 'Calendar'
        },
        'Gnt.column.ReadOnly': {
            text: 'Read Only'
        },
        'Gnt.widget.taskeditor.ProjectForm': {
            nameText: 'Name',
            startText: 'Start',
            finishText: 'Finish',
            calendarText: 'Calendar',
            readOnlyText: 'Read Only',
            allowDependenciesText: 'Allow cross-project dependencies',
            'Schedule from': 'Schedule from'
        },
        'Gnt.widget.taskeditor.TaskForm': {
            taskNameText: 'Name',
            durationText: 'Duration',
            datesText: 'Dates',
            baselineText: 'Baseline',
            startText: 'Start',
            finishText: 'Finish',
            percentDoneText: 'Percent Complete',
            baselineStartText: 'Start',
            baselineFinishText: 'Finish',
            baselinePercentDoneText: 'Percent Complete',
            baselineEffortText: 'Effort',
            effortText: 'Effort',
            invalidEffortText: 'Invalid effort value',
            calendarText: 'Calendar',
            manuallyScheduledText: 'Manually Scheduled',
            schedulingModeText: 'Scheduling Mode',
            rollupText: 'Rollup',
            wbsCodeText: 'WBS code',
            "Constraint Type": "Constraint Type",
            "Constraint Date": "Constraint Date",
            readOnlyText: 'Read Only'
        },
        'Gnt.widget.DependencyGrid': {
            addDependencyText: 'Add new',
            dropDependencyText: 'Remove',
            idText: 'ID',
            snText: 'SN',
            taskText: 'Task Name',
            blankTaskText: 'Please select task',
            invalidDependencyText: 'Invalid dependency',
            parentChildDependencyText: 'Dependency between child and parent found',
            duplicatingDependencyText: 'Duplicate dependency found',
            transitiveDependencyText: 'Transitive dependency',
            cyclicDependencyText: 'Cyclic dependency',
            typeText: 'Type',
            lagText: 'Lag',
            clsText: 'CSS class',
            endToStartText: 'Finish-To-Start',
            startToStartText: 'Start-To-Start',
            endToEndText: 'Finish-To-Finish',
            startToEndText: 'Start-To-Finish',
            predecessorsText: 'Predecessors',
            successorsText: 'Successors'
        },
        'Gnt.widget.AssignmentEditGrid': {
            confirmAddResourceTitle: 'Confirm',
            confirmAddResourceText: 'Resource &quot;{0}&quot; not found in list. Would you like to add it?',
            noValueText: 'Please select resource to assign',
            noResourceText: 'No resource &quot;{0}&quot; found in the list',
            'Resource is already assigned': 'Resource is already assigned',
            addAssignmentText: 'Add new',
            dropAssignmentText: 'Remove'
        },
        'Gnt.widget.taskeditor.TaskEditor': {
            generalText: 'General',
            resourcesText: 'Resources',
            notesText: 'Notes',
            advancedText: 'Advanced'
        },
        'Gnt.widget.taskeditor.ProjectEditor': {
            generalText: 'General',
            descriptionText: 'Description'
        },
        'Gnt.plugin.taskeditor.BaseEditor': {
            title: 'Task Information',
            alertCaption: 'Information',
            alertText: 'Please correct marked errors to save changes',
            okText: 'Ok',
            cancelText: 'Cancel'
        },
        'Gnt.plugin.taskeditor.ProjectEditor': {
            title: 'Project Information'
        },
        'Gnt.field.EndDate': {
            endBeforeStartText: 'End date is before start date'
        },
        'Gnt.field.ConstraintDate': {
            format: 'm/d/Y H:i'
        },
        'Gnt.column.Note': {
            text: 'Note'
        },
        'Gnt.column.AddNew': {
            text: 'Add new column...'
        },
        'Gnt.column.EarlyStartDate': {
            text: 'Early Start'
        },
        'Gnt.column.EarlyEndDate': {
            text: 'Early Finish'
        },
        'Gnt.column.LateStartDate': {
            text: 'Late Start'
        },
        'Gnt.column.LateEndDate': {
            text: 'Late Finish'
        },
        'Gnt.field.Calendar': {
            calendarNotApplicable: 'Task calendar has no overlapping with assigned resources calendars',
            invalidText: 'Invalid value'
        },
        'Gnt.field.ScheduleBackwards': {
            'Project start date': 'Project start date',
            'Project finish date': 'Project finish date'
        },
        'Gnt.column.Slack': {
            text: 'Free Slack'
        },
        'Gnt.column.TotalSlack': {
            text: 'Total Slack'
        },
        'Gnt.column.Name': {
            text: 'Task Name'
        },
        'Gnt.column.BaselineStartDate': {
            text: 'Baseline Start Date'
        },
        'Gnt.column.BaselineEndDate': {
            text: 'Baseline End Date'
        },
        'Gnt.column.Milestone': {
            text: 'Milestone'
        },
        'Gnt.field.Milestone': {
            yes: 'Yes',
            no: 'No'
        },
        'Gnt.field.Dependency': {
            invalidFormatText: 'Invalid dependency format',
            invalidDependencyText: 'Invalid dependency found, please make sure you have no cyclic paths between your tasks',
            invalidDependencyType: 'Invalid dependency type {0}. Allowed values are: {1}.'
        },
        'Gnt.constraint.Base': {
            name: "A constraint",
            // {0} constraint name
            "Remove the constraint": "Continue. Remove the {0} constraint",
            "Cancel the change and do nothing": "Cancel the change and do nothing",
            // {0} task name, {1} constraint name
            "This action will cause a scheduling conflict": 'This action will cause a scheduling conflict for summary task "{0}". The {1} constraint on the summary task puts it in conflict with one of its subtasks.'
        },
        'Gnt.constraint.AsLateAsPossible': {
            name: 'As late as possible'
        },
        'Gnt.constraint.AsSoonAsPossible': {
            name: 'As soon as possible'
        },
        'Gnt.constraint.implicit.Dependency': {
            // {0} dependency type
            // {1} from task
            // {2} to task
            'You moved the task away': 'You moved the task "{2}" away from "{1}" and the two tasks are linked ({0}). As a result the link between the tasks will not drive the later task position.',
            'You moved the task before': 'You moved the task "{2}" before "{1}" and the two tasks are linked ({0}). As a result the link cannot be honored.',
            'Remove the constraint': 'Remove the dependency',
            depType0: 'Start-To-Start',
            depType1: 'Start-To-Finish',
            depType2: 'Finish-To-Start',
            depType3: 'Finish-To-Finish',
            'Keep the dependency & move the task': 'Keep the dependency and move the task to {0}'
        },
        'Gnt.constraint.implicit.PotentialConflict': {
            'This could result in a scheduling conflict': 'You set a {0} constraint on the task "{1}". This could result in a scheduling conflict since the task has a predecessor.',
            'Remove the constraint': 'Continue. Set the {0} constraint',
            'Replace the constraint': 'Continue but avoid the conflict by using a {0} constraint instead'
        },
        'Gnt.constraint.FinishNoEarlierThan': {
            name: "Finish no earlier than",
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.FinishNoLaterThan": {
            name: "Finish no later than",
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.MustFinishOn": {
            name: "Must finish on",
            "Move the task to finish on {0}": "Move the task to finish on {0}"
        },
        "Gnt.constraint.MustStartOn": {
            name: "Must start on",
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.constraint.StartNoEarlierThan": {
            name: "Start no earlier than",
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.constraint.StartNoLaterThan": {
            name: "Start no later than",
            // {0} potential start date
            "Move the task to start at {0}": "Move the task to start at {0}"
        },
        "Gnt.column.ConstraintDate": {
            text: "Constraint date",
            format: 'm/d/Y H:i'
        },
        "Gnt.column.ConstraintType": {
            text: "Constraint"
        },
        "Gnt.widget.ConstraintResolutionForm": {
            dateFormat: "m/d/Y H:i",
            "OK": "OK",
            "Cancel": "Cancel",
            "Resolution options": "Resolution options",
            "Don't ask again": "Don't ask again",
            // {0} task name, {1} constraint name
            "Task {0} violates constraint {1}": "Task \"{0}\" violates constraint {1}",
            // {0} task name, {1} constraint name, {2} constraint date
            "Task {0} violates constraint {1} {2}": "Task \"{0}\" violates constraint {1} {2}"
        },
        "Gnt.widget.ConstraintResolutionWindow": {
            "Constraint violation": "Constraint violation"
        },
        "Gnt.panel.ResourceHistogram": {
            resourceText: 'Resource'
        },
        "Gnt.panel.ResourceUtilization": {
            "calculating {0}% done": "calculating {0}% done"
        }
    },
    apply: function(classNames) {
        // apply corresponding scheduler locale first
        Sch.locale.En.apply(classNames);
        this.callParent(arguments);
    }
});

/**
@class Gnt.mixin.Localizable

A mixin providing localization functionality to the consuming class.
*/
Ext.define('Gnt.mixin.Localizable', {
    extend: 'Sch.mixin.Localizable',
    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Gnt.locale.En class
    //      requires    : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Gnt.locale.En' ]
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires: [
        'Gnt.locale.En'
    ]
});

/*
@class Gnt.Tooltip
@extends Ext.ToolTip
@private

Internal tooltip class showing task start/end/duration information for a single task.
*/
Ext.define("Gnt.Tooltip", {
    extend: 'Ext.tip.ToolTip',
    alias: 'widget.gantt_task_tooltip',
    requires: [
        'Ext.Template'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    anchor: 'bottom',
    // anhor direction advise
    autoHide: false,
    maskOnDisable: false,
    adjustMilestones: true,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText       : 'Starts: ',
            - endText         : 'Ends: ',
            - durationText    : 'Duration:'
     */
    /*
     * @cfg {String} mode Either "startend" - showing start date and end date, or "duration" to show start date and duration
     */
    mode: 'startend',
    /*
     * @cfg {Number} durationDecimalPrecision The number of decimals to show for a duration string
     */
    durationDecimalPrecision: 1,
    /*
     * @cfg {Ext.Template} template An HTML snippet used for the tooltip display.
     * In "startend" mode, it will receive a data object containing "startText", "endText" and "task" (the entire task) properties.
     * In "duration" mode, it will receive a data object containing "startText", "duration", "unit" and "task" (the entire task) properties.
     */
    template: null,
    /**
     * @cfg {Boolean} avoidPointer Whether to move the tip out of the pointer way
     */
    avoidPointer: false,
    gantt: null,
    lastTarget: null,
    defaultAlign: 'b-t',
    reverseDefaultAlign: 't-b',
    initComponent: function() {
        var me = this;
        me.initialDefaultAlign = me.defaultAlign;
        me.rtl = me.gantt.rtl;
        me.startLabel = me.L('startText');
        me.label2Text = me.mode === 'duration' ? me.L('durationText') : me.L('endText');
        if (!me.template) {
            me.template = new Ext.Template('<div class="sch-timetipwrap x-fa {cls}">' + '<table cellpadding="0" cellspacing="0">' + '<tpl if="value1"><tr><td class="sch-gantt-tip-desc">{label1}</td><td class="sch-gantt-tip-value">{value1}</td></tr></tpl>' + '<tr><td class="sch-gantt-tip-desc">{label2}</td><td class="sch-gantt-tip-value">{value2}</td></tr>' + '</table>' + '</div>').compile();
        }
        me.callParent(arguments);
        me.update(me.template.apply({
            value1: '',
            value2: ''
        }));
        me.addCls('gnt-tooltip');
        if (me.avoidPointer) {
            me.on({
                scope: me,
                'mouseover': {
                    'element': 'el',
                    fn: me.onTipElementMouseOver
                }
            });
        }
    },
    updateContent: function(start, end, valid, taskRecord) {
        var me = this,
            content;
        if (me.mode === 'duration') {
            content = me.getDurationContent(start, end, valid, taskRecord);
        } else {
            content = me.getStartEndContent(start, end, valid, taskRecord);
        }
        me.update(content);
    },
    // private
    getStartEndContent: function(start, end, valid, taskRecord) {
        var gantt = this.gantt,
            startText = start && gantt.getFormattedDate(start),
            endText;
        if (start) {
            if (end - start > 0) {
                endText = gantt.getFormattedEndDate(end, start);
            } else {
                endText = startText;
            }
        } else {
            // Single point in time
            endText = gantt.getFormattedEndDate(end);
        }
        var retVal = {
                cls: valid ? 'sch-tip-ok fa-check' : 'sch-tip-notok fa-ban',
                label2: this.label2Text,
                value2: endText,
                task: taskRecord
            };
        if (start) {
            retVal.label1 = this.startLabel;
            retVal.value1 = start && gantt.getFormattedDate(start);
        }
        return this.template.apply(retVal);
    },
    getDurationContent: function(start, end, valid, taskRecord) {
        var unit = taskRecord.getDurationUnit();
        var duration = taskRecord.calculateDuration(start, end, unit);
        return this.template.apply({
            cls: valid ? 'sch-tip-ok fa-check' : 'sch-tip-notok fa-ban',
            label1: this.startLabel,
            value1: this.gantt.getFormattedDate(start),
            label2: this.label2Text,
            value2: parseFloat(Ext.Number.toFixed(duration, this.durationDecimalPrecision)) + ' ' + Sch.util.Date.getReadableNameOfUnit(unit, duration > 1),
            task: taskRecord
        });
    },
    onTipElementMouseOver: function() {
        var me = this,
            align = me.defaultAlign;
        me.defaultAlign = me.reverseDefaultAlign;
        me.reverseDefaultAlign = align;
        me.lastTarget && me.showBy(me.lastTarget);
    },
    // In ExtJS 6.0.2 this method is defined on Ext.Component and has signature (cmp, [pos], [off])
    // Whereas in ExtJS 6.2.0 and later this method is defined on Ext.tip.Tip this (target) signature
    // and doesn't goes to Ext.Component::showBy() - no callParent() there.
    showBy: function(el) {
        var me = this,
            targetRegion, tipRegion, anchorRegion, newAnchor, newAlign, targetOffset;
        me.defaultAlign = me.initialDefaultAlign;
        me.lastTarget = el;
        if (me.anchor) {
            me.anchorTarget = el;
        }
        me.callParent([
            el
        ]);
        // there call to alignTo() in parent call
        if (Ext.getVersion().isLessThanOrEqual('6.0.2.*') && me.syncAnchor) {
            targetRegion = Ext.fly(el).getRegion();
            tipRegion = me.getEl().getRegion();
            if (targetRegion.bottom <= tipRegion.top && me.tipAnchor != 'top') {
                newAnchor = 'top';
                newAlign = 'tl-bl?';
            } else if (targetRegion.top >= tipRegion.bottom && me.tipAnchor != 'bottom') {
                newAnchor = 'bottom';
                newAlign = 'bl-tl?';
            } else if (targetRegion.right <= tipRegion.left && me.tipAnchor != 'left') {
                newAnchor = 'left';
                newAlign = 'l-r?';
            } else if (targetRegion.left >= tipRegion.right && me.tipAnchor != 'right') {
                newAnchor = 'right';
                newAlign = 'r-l?';
            }
            if (me.tipAnchor != newAnchor) {
                me.tipAnchor = me.anchor = newAnchor;
                me.syncAnchor();
                anchorRegion = Ext.fly(me.getEl().down('.' + Ext.baseCSSPrefix + 'tip-anchor')).getRegion();
                switch (newAnchor) {
                    case 'top':
                        targetOffset = [
                            0,
                            (anchorRegion.bottom - anchorRegion.top) / 2
                        ];
                        break;
                    case 'bottom':
                        targetOffset = [
                            0,
                            (anchorRegion.top - anchorRegion.bottom) / 2
                        ];
                        break;
                    case 'left':
                        targetOffset = [
                            (anchorRegion.left - anchorRegion.right) / 2,
                            0
                        ];
                        break;
                    case 'right':
                        targetOffset = [
                            (anchorRegion.right - anchorRegion.left) / 2,
                            0
                        ];
                        break;
                }
                me.alignTo(el, newAlign, targetOffset);
                me.getTargetXY();
            }
        }
    },
    // Just, don't ask. It should be here.
    afterHide: function(animateTarget, callback, scope) {
        var me = this;
        me.callParent([
            animateTarget,
            callback,
            scope
        ]);
        me.lastTarget = null;
    }
});

/**
 * A mixin with common functionality for all fields used to edit {@link Gnt.model.Task} information.
 *
 * Custom field implementation example:
 *
 * ```javascript
 *     Ext.define('MyApp.model.Task', {
 *         extend : 'Gnt.model.Task',
 *
 *         customizableFields : [
 *             // task manager identifier
 *             { name : 'ManagerId', type : 'int' }
 *         ],
 *
 *         managerIdField : 'bigBossId'
 *     });
 *
 *     // drop down list of task managers
 *     Ext.define('MyApp.field.ManagerField', {
 *         extend             : 'Ext.form.field.ComboBox',
 *         mixins             : ['Gnt.field.mixin.TaskField'],
 *
 *         fieldProperty      : 'managerIdField',
 *         setTaskValueMethod : 'setManagerId',
 *         getTaskValueMethod : 'getManagerId',
 *
 *         ...
 *     });
 * ```
 */
Ext.define('Gnt.field.mixin.TaskField', {
    extend: 'Ext.Mixin',
    /**
     * @cfg {String} fieldProperty A task property holding the matching data field name.
     * Task model has special properties for all its fields. Their names look like "xxxField"
     * (for example: {@link Gnt.model.Task#startDateField}, {@link Gnt.model.Task#endDateField}, {@link Gnt.model.Task#durationField} etc.).
     * The properties support comes from extended {@link Sch.model.Customizable} class.
     * Those properties hold real field names that are used for storing the data (and communicating with the server).
     *
     * So this config should be set to the corresponding property name. For example:
     *
     * ```javascript
     *     Ext.define('MyApp.model.Task', {
     *         extend : 'Gnt.model.Task',
     *
     *         customizableFields : [
     *             // task manager identifier
     *             { name : 'ManagerId', type : 'int' }
     *         ],
     *
     *         managerIdField : 'bigBossId'
     *     });
     *
     *     // drop down list of task managers
     *     Ext.define('MyApp.field.ManagerField', {
     *         extend             : 'Ext.form.field.ComboBox',
     *         mixins             : ['Gnt.field.mixin.TaskField'],
     *
     *         fieldProperty      : 'managerIdField',
     *         setTaskValueMethod : 'setManagerId',
     *         getTaskValueMethod : 'getManagerId',
     *
     *         ...
     *     });
     * ```
     */
    fieldProperty: '',
    /**
     * @cfg {String} getTaskValueMethod Task method name that should be used to get the field value from the task.
     */
    getTaskValueMethod: '',
    /**
     * @cfg {String} setTaskValueMethod Task method name that should be used to put the field value into the task.
     */
    setTaskValueMethod: '',
    isTaskField: true,
    /**
     * @cfg {Gnt.model.Task} task Task being edited. Field will apply all it's value changes directly to this task (if {@link #instantUpdate} is `true`).
     */
    task: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore Task store should provided if task being edited is not in any task store yet and thus does not have a calendar.
     * In such case we'll retrieve a calendar from the task store (project calendar).
     */
    taskStore: null,
    /**
     * @cfg {Number} suppressTaskUpdate A number flag, when greater than 0 prevents task updates.
     */
    suppressTaskUpdate: 0,
    /**
     * @cfg {Boolean} highlightTaskUpdates When set to `true`, field will highlight itself when its value is changed due to changes in some other field.
     * For example when changing the end date of the task, its duration will change as well and will highlight itself.
     */
    highlightTaskUpdates: true,
    /**
     * @cfg {String} highlightColor A color to use when highlighting the field. See {@link #highlightTaskUpdates} option.
     */
    highlightColor: '#009900',
    lastHighlight: 0,
    /**
     * @cfg {Boolean} instantUpdate Set to `false` to prevent automatic applying changes to the task on each {@link #setValue} call.
     * To apply changes manually one can use {@link #applyChanges} method.
     */
    instantUpdate: true,
    originalInstantUpdate: null,
    readOnlyUpdateSuspended: 0,
    mixinConfig: {
        before: {
            constructor: 'beforeConstructed',
            destroy: 'beforeDestroyed'
        },
        after: {
            constructor: 'afterConstructed'
        }
    },
    selectOnFocus: false,
    getTaskStore: function(task) {
        task = task || this.task;
        return task.getTaskStore(true) || this.taskStore;
    },
    beforeConstructed: function() {
        this.setSuppressTaskUpdate(true);
        // If implementer configures field as readOnly, make sure it stays this way and does not
        if (this.readOnly)  {
            this.forceReadOnly = true;
        }
        
    },
    afterConstructed: function() {
        this.task && this.setTask(this.task);
        this.setSuppressTaskUpdate(false);
    },
    setInstantUpdate: function(value) {
        this.instantUpdate = value;
    },
    beforeDestroyed: function() {
        this.destroyTaskListener();
    },
    /**
     * Binds task to the field.
     * @param {Gnt.model.Task} task Task to bind.
     */
    setTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.settingTask = true;
        this.destroyTaskListener();
        this.updateReadOnly(task);
        this.task = task;
        task.on('taskupdated', this.onTaskUpdateProcess, this);
        // we need calendar to be assigned to task or task should be part of taskStore with
        // assigned calendar, if we dont`t have it lets imitate it by binding task to provided taskStore
        if (!task.getCalendar(true) && !task.getTaskStore(true)) {
            task.taskStore = task.getTaskStore(true) || this.taskStore;
            if (!task.taskStore)  {
                throw 'Configuration issue: Gnt.data.taskStore instance should be provided.';
            }
            
            if (!task.getCalendar(true) && !task.taskStore.getCalendar())  {
                throw 'Configuration issue: Gnt.data.Calendar instance should be provided.';
            }
            
        }
        this.setSuppressTaskUpdate(true);
        this.onSetTask(task);
        this.setSuppressTaskUpdate(false);
        this.resetOriginalValue();
        this.settingTask = false;
    },
    onSetTask: function(task) {
        task = task || this.task;
        this.setValue(this.getTaskValue(task));
    },
    setSuppressTaskUpdate: function(inc) {
        inc ? this.suppressTaskUpdate++ : this.suppressTaskUpdate--;
    },
    getSuppressTaskUpdate: function() {
        return this.suppressTaskUpdate;
    },
    isReadOnlyUpdateSuspended: function() {
        return this.readOnlyUpdateSuspended;
    },
    suspendReadOnlyUpdate: function() {
        this.readOnlyUpdateSuspended++;
    },
    resumeReadOnlyUpdate: function() {
        if (this.isReadOnlyUpdateSuspended())  {
            this.readOnlyUpdateSuspended--;
        }
        
        // if readOnly mechanics is no longer suppressed let's update the field readOnly state
        if (!this.readOnlyUpdateSuspended) {
            this.updateReadOnly(this.task);
        }
        return this.readOnlyUpdateSuspended;
    },
    updateReadOnly: function(task) {
        if (this.fieldProperty && !this.disabled && !this.forceReadOnly && !this.isReadOnlyUpdateSuspended()) {
            if (this.editable === false) {
                // let's take into account Task.isEditable() result
                if (!task.isEditable(task[this.fieldProperty])) {
                    this.setReadOnly(true);
                } else // when editable is false `readOnly` should be set to `true`
                {
                    this.setReadOnly(false);
                    if (this.inputEl)  {
                        this.inputEl.dom.readOnly = true;
                    }
                    
                }
            } else {
                // let's take into account Task.isEditable() result
                this.setReadOnly(!task.isEditable(task[this.fieldProperty]));
            }
        }
    },
    onTaskUpdateProcess: function(task, initiator) {
        if (initiator !== this) {
            var prev = this.getValue();
            this.processingTaskUpdate = true;
            // update field editability
            this.updateReadOnly(task);
            this.setSuppressTaskUpdate(true);
            if (this.onTaskUpdate) {
                this.onTaskUpdate(task, initiator);
            } else {
                this.onSetTask(task);
            }
            this.setSuppressTaskUpdate(false);
            if (this.highlightTaskUpdates) {
                var curr = this.getValue(),
                    isDate = Ext.isDate(prev);
                if (isDate && (prev - curr !== 0) || (!isDate && String(prev) !== String(curr))) {
                    this.highlightField();
                }
            }
            this.processingTaskUpdate = false;
        }
    },
    highlightField: function(color, options) {
        if (this.rendered && (new Date() - this.lastHighlight > 1000)) {
            this.lastHighlight = new Date();
            this.inputEl.highlight(color || this.highlightColor, options || {
                attr: 'color'
            });
        }
    },
    destroyTaskListener: function() {
        if (this.task) {
            this.task.un('taskupdated', this.onTaskUpdateProcess, this);
        }
    },
    callTaskMethod: function(task, method, args) {
        task = task || this.task;
        return task && task[method].apply(task, args);
    },
    getTaskValue: function(task) {
        return this.callTaskMethod(task, this.getTaskValueMethod, Ext.Array.slice(arguments, 1));
    },
    setTaskValue: function(task) {
        // TODO: HACK: If the task being modified is already in the middle of propagation we cannot start a new propagation process
        // and this happens in ext6 where we have issues w/ uncontrollable "blur" events.
        // (Note: and we assume that "setTaskValueMethod" invokes a propagation (it is true for most of our out-of-the-box fields))
        // The issue is covered by columns/1030_duration.t.js test (and seems fixed in ext > 6.0.1)
        if (task.propagating)  {
            return;
        }
        
        return this.callTaskMethod(task, this.setTaskValueMethod, Ext.Array.slice(arguments, 1));
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue());
        toTask.fireEvent('taskupdated', toTask, this);
    }
});

/**
 * A specialized field to enter cost values.
 * This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number` configs can be used.
 */
Ext.define('Gnt.field.Cost', {
    extend: 'Ext.form.field.Number',
    alias: 'widget.costfield',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: 'Gnt.widget.CostField',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - invalidText         : 'Invalid value',
     - currencySymbol      : '$',
     - currencySymbolAlign : 'left'
     */
    disableKeyFilter: false,
    minValue: 0,
    allowExponential: false,
    baseChars: '0123456789',
    fieldProperty: 'costField',
    setTaskValueMethod: 'setCost',
    getTaskValueMethod: 'getCost',
    instantUpdate: true,
    /**
     * @cfg {String} currencySymbol The currency to set on display. By default the value is taken from the class locale.
     */
    currencySymbol: null,
    /**
     * @cfg {String} currencySymbolAlign The currency symbol align. Defines where the symbol should be rendered.
     * Possible options are:
     *
     *  - 'left' - left to the value,
     *  - 'right' - right to the value.
     *
     * By default the value is taken from the class locale.
     */
    currencySymbolAlign: null,
    initComponent: function() {
        this.invalidText = this.L('invalidText');
        this.currencySymbol = this.currencySymbol || this.L('currencySymbol');
        this.currencySymbolAlign = this.currencySymbolAlign || this.L('currencySymbolAlign');
        this.baseChars = this.baseChars + this.currencySymbol;
        this.callParent(arguments);
    },
    valueToRaw: function(value) {
        return this.valueToVisible(value);
    },
    valueToVisible: function(value) {
        var result = '';
        if (Ext.isNumber(value)) {
            result = Ext.Number.toFixed(value, this.decimalPrecision);
            if (this.currencySymbolAlign == 'left') {
                result = this.currencySymbol + ' ' + result;
            } else {
                result += ' ' + this.currencySymbol;
            }
        }
        return result;
    },
    rawToValue: function(value) {
        if (value)  {
            return this.parseValue(value);
        }
        
        return value;
    },
    parseValue: function(value) {
        return this.callParent([
            value && value.replace(this.currencySymbol, '')
        ]);
    },
    getErrors: function(value) {
        var cost = this.parseValue(value);
        if (cost === null) {
            if (value !== null && value !== '') {
                return [
                    this.invalidText
                ];
            } else {
                cost = '';
            }
        }
        return this.callParent([
            cost
        ]);
    },
    setValue: function(value) {
        this.callParent([
            value
        ]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/**
 * This class implements common logic for fields that have a field mixed with {@link Gnt.field.mixin.TaskField} class as an editor.
 * Also it makes the column localizable by mixing it with {@link Gnt.mixin.Localizable} class.
 */
Ext.define('Gnt.column.mixin.TaskFieldColumn', {
    extend: 'Ext.Mixin',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Boolean} instantUpdate Set to `true` to instantly apply any changes in the field to the task.
     * This option is just translated to the {@link Gnt.field.mixin.TaskField#instantUpdate} config option.
     */
    instantUpdate: false,
    /**
     * @property {Ext.form.field.Field} field Reference to the field used by the editor
     */
    field: null,
    fieldProperty: '',
    fieldConfigs: 'instantUpdate,fieldProperty',
    defaultEditor: 'textfield',
    useRenderer: true,
    htmlEncode: true,
    mixinConfig: {
        after: {
            initComponent: 'afterInitComponent',
            onRender: '_beforeRender'
        },
        // "afterIf" adds a post-action exactly like normal "after" does
        // except in case the method being extended doesn't exist it adds it
        // So for example having this config:
        //      afterIf        : {
        //          applyColumnCls : 'applyColumnCls'
        //      }
        // Will result appending mixin's applyColumnCls code after the existing applyColumnCls method code
        // ..or creating a new applyColumnCls method using mixin's applyColumnCls method
        afterIf: {
            applyColumnCls: 'applyColumnCls'
        }
    },
    _beforeRender: function() {
        // Save original state so we can enable/disable this when needed
        var ed = this.getEditor && this.getEditor();
        if (ed && ed.setInstantUpdate) {
            ed.originalInstantUpdate = ed.instantUpdate;
            ed.setInstantUpdate(false);
        }
    },
    initTaskFieldColumn: function(editorCfg) {
        this.text = this.config.text || this.L('text');
        this.initColumnEditor(editorCfg);
        this.scope = this.scope || this;
        if (this.useRenderer) {
            this.renderer = this.renderer || this.taskFieldRenderer;
        }
        this.on('added', this.onColumnAdded, this);
    },
    applyColumnCls: function(value, meta, task) {
        if (!task.isEditable(this.dataIndex)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        }
    },
    afterInitComponent: function() {
        // Make sure Ext 'understands' this column has its own renderer which makes sure this column is always updated
        // if any task field is changed
        this.hasCustomRenderer = true;
    },
    initColumnEditor: function(editorCfg) {
        var editor = this.editor;
        // if editor provided
        if (editor) {
            // xtype provided
            if (typeof editor === 'string') {
                editor = {
                    xtype: editor
                };
            }
            // if it's not a made instance yet
            if (!editor.isInstance) {
                if (!editor.xtype && !editor.xclass) {
                    editor.xtype = this.defaultEditor;
                }
                // relay configs listed in "fieldConfigs" to the editor
                var cfg = Ext.copy(Ext.apply({}, editorCfg), this, this.fieldConfigs, true);
                this.editor = Ext.ComponentManager.create(Ext.apply(cfg, editor));
            }
            this.field = this.editor;
        }
    },
    onColumnAdded: function() {
        var panel = this.up('[taskStore]') || this.up('[store]');
        var store = panel.taskStore || panel.store;
        if (!this.dataIndex && this.fieldProperty) {
            this.dataIndex = store.model.prototype[this.fieldProperty];
        }
    },
    getValueToRender: function(value, meta, task) {
        var field = this.field;
        return field && field.valueToVisible && field.valueToVisible(value, task) || value;
    },
    taskFieldRenderer: function(value, meta, task) {
        var displayValue = this.getValueToRender.apply(this, arguments);
        var result = this.htmlEncode ? Ext.htmlEncode(displayValue) : displayValue;
        this.applyColumnCls(value, meta, task);
        return result;
    },
    afterClassMixedIn: function(cls) {
        var mixin = this.prototype,
            mixinConfig = mixin.mixinConfig,
            befores = mixinConfig && mixinConfig.beforeIf,
            afters = mixinConfig && mixinConfig.afterIf;
        befores && Ext.Object.each(befores, function(key, value) {
            if (key in cls.prototype) {
                cls.addMember(key, function() {
                    if (mixin[value].apply(this, arguments) !== false) {
                        return this.callParent(arguments);
                    }
                });
            } else {
                cls.addMember(key, function() {
                    mixin[value].apply(this, arguments);
                });
            }
        });
        afters && Ext.Object.each(afters, function(key, value) {
            if (key in cls.prototype) {
                cls.addMember(key, function() {
                    this.callParent(arguments);
                    mixin[value].apply(this, arguments);
                });
            } else {
                cls.addMember(key, function() {
                    mixin[value].apply(this, arguments);
                });
            }
        });
    }
});

/**
 * A Column representing {@link Gnt.model.Task#Cost Cost} field of a task. The column is editable when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is set to `false`, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *        var gantt = Ext.create('Gnt.panel.Gantt', {
 *            height  : 600,
 *            width   : 1000,
 *
 *            // Setup your grid columns
 *            columns : [
 *                ...
 *                {
 *                    xtype : 'costcolumn',
 *                    width : 70
 *                }
 *                ...
 *            ],
 *
 *            plugins : [
 *                Ext.create('Sch.plugin.TreeCellEditing', {
 *                    clicksToEdit : 1
 *                })
 *            ],
 *            ...
 *        })
 * ```
 *
 * This column uses a field - {@link Gnt.field.Cost} which allows the
 * user to specify the cost value.
 */
Ext.define('Gnt.column.Cost', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.costcolumn',
        'widget.ganttcolumn.cost'
    ],
    requires: [
        'Gnt.field.Cost'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     *  - text : 'Cost'
     *
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 80,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    decimalPrecision: 2,
    instantUpdate: true,
    fieldProperty: 'costField',
    fieldConfigs: [
        'instantUpdate',
        'decimalPrecision',
        'currencySymbol',
        'currencySymbolAlign',
        'fieldProperty'
    ],
    /**
     * @cfg {String} currencySymbol The currency to set on display. By default the value is taken from the associated field locale.
     */
    currencySymbol: null,
    /**
     * @cfg {String} currencySymbolAlign The currency symbol align. Defines where the symbol should be rendered.
     * Possible options are:
     *
     *  - 'left' - left to the value,
     *  - 'right' - right to the value.
     *
     * By default the value is taken from the associated field locale.
     */
    currencySymbolAlign: null,
    editor: 'costfield',
    defaultEditor: 'costfield',
    editorConfig: null,
    initComponent: function() {
        this.initTaskFieldColumn(this.editorConfig);
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(value);
    },
    putRawData: function(data, task) {
        task.set(task[this.fieldProperty], data);
    }
});

/**
 @class Gnt.field.ActualCost

 A specialized field, for showing the actual cost value.
 This class inherits from the {@link Gnt.field.Cost} field, which inherits from `Ext.form.field.Number` so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).
 */
Ext.define('Gnt.field.ActualCost', {
    extend: 'Gnt.field.Cost',
    alias: 'widget.actualcostfield',
    alternateClassName: 'Gnt.widget.ActualCostField',
    fieldProperty: 'actualCostField',
    setTaskValueMethod: 'setActualCost',
    getTaskValueMethod: 'getActualCost'
});

/**
 * @class Gnt.column.ActualCost
 *
 * A Column representing the {@link Gnt.model.Task#ActualCost ActualCost} field of a task. The column is editable when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is set to `false`, however to enable the editing you will need to add a
 * {@link Sch.plugin.TreeCellEditing} plugin to your gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *         var gantt = Ext.create('Gnt.panel.Gantt', {
 *                height  : 600,
 *                width   : 1000,
 *
 *                // Setup your grid columns
 *                columns : [
 *                    ...
 *                    {
 *                        xtype : 'actualcostcolumn',
 *                        width : 70
 *                    }
 *                    ...
 *                ],
 *
 *                plugins : [
 *                    Ext.create('Sch.plugin.TreeCellEditing', {
 *                        clicksToEdit : 1
 *                    })
 *                ],
 *                ...
 *         })
 * ```
 *
 * This column internally uses a field - {@link Gnt.field.ActualCost} which allows the
 * user to specify the actual cost value.
 */
Ext.define('Gnt.column.ActualCost', {
    extend: 'Gnt.column.Cost',
    alias: [
        'widget.actualcostcolumn',
        'widget.ganttcolumn.actualcost'
    ],
    requires: [
        'Gnt.field.ActualCost'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     *  - text : 'Actual Cost'
     *
     */
    fieldProperty: 'actualCostField',
    editor: 'actualcostfield',
    defaultEditor: 'actualcostfield'
});

/**
 * @class Gnt.util.DurationParser
 * @private
 * Internal class handling the duration parsing.
 *
 *  Recognizable values for duration unit part are (the trailing `..` symbols means anything will match):
 *
 * - Milliseconds: `ms` or `mil..`
 * - Seconds: `s` or `sec..`
 * - Minutes: `m` or `min..`
 * - Hours: `h` or `hr` or `hour..`
 * - Days: `d` or `day..`
 * - Weeks: `w` or `wk` or `week..`
 * - Months: `mo..` or `mnt..`
 * - Quarters: `q` or `quar..` or `qrt..`
 * - Years: `y` or `yr..` or `year..`
 *
 * You can change that using the {@link #l10n} `unitsRegex` configuration option.
 */
Ext.define("Gnt.util.DurationParser", {
    requires: [
        "Sch.util.Date"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    parseNumberFn: null,
    durationRegex: null,
    /*
     * @cfg {Boolean} allowDecimals Set to `false` to disable parsing duration values with decimals component
     */
    allowDecimals: true,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - unitsRegex : {
     *     - MILLI       : /^ms$|^mil/i,
     *     - SECOND      : /^s$|^sec/i,
     *     - MINUTE      : /^m$|^min/i,
     *     - HOUR        : /^h$|^hr$|^hour/i,
     *     - DAY         : /^d$|^day/i,
     *     - WEEK        : /^w$|^wk|^week/i,
     *     - MONTH       : /^mo|^mnt/i,
     *     - QUARTER     : /^q$|^quar|^qrt/i,
     *     - YEAR        : /^y$|^yr|^year/i
     * }
     */
    constructor: function(config) {
        Ext.apply(this, config);
        if (this.unitsRegex)  {
            Ext.apply(this.l10n.unitsRegex, this.unitsRegex);
        }
        
        if (!this.durationRegex) {
            if (this.allowDecimals) {
                this.durationRegex = /^\s*([\-+]?\d+(?:[.,]\d*)?|[\-+]?(?:[.,]\d+))\s*(.*?)(?=\s*$)/i;
            } else {
                this.durationRegex = /^\s*([\-+]?\d+)(?![.,])\s*(.*?)(?=\s*$)/i;
            }
        }
    },
    parse: function(value) {
        var match = this.durationRegex.exec(value);
        if (value == null || !match)  {
            return null;
        }
        
        var durationValue = this.parseNumberFn(match[1]);
        var durationUnitName = match[2];
        var durationUnit;
        if (durationUnitName) {
            Ext.iterate(this.L('unitsRegex'), function(name, regex) {
                if (regex.test(durationUnitName)) {
                    durationUnit = Sch.util.Date.getUnitByName(name);
                    return false;
                }
            });
            if (!durationUnit)  {
                return null;
            }
            
        }
        return {
            value: durationValue,
            unit: durationUnit
        };
    }
});

// https://www.assembla.com/spaces/bryntum/tickets/2424
// This spinner is used in duration field to keep it visible in IE
Ext.define('Gnt.field.trigger.DurationSpinner', {
    extend: 'Ext.form.trigger.Spinner',
    alias: 'trigger.gantt_durationspinner',
    initEvents: function() {
        var me = this,
            isFieldEnabled = me.isFieldEnabled,
            stateEl = me.getStateEl(),
            el = me.el;
        stateEl.addClsOnOver(me.overCls, isFieldEnabled, me);
        stateEl.addClsOnClick(me.clickCls, isFieldEnabled, me);
        if (me.repeatClick) {
            me.clickRepeater = new Ext.util.ClickRepeater(el, Ext.apply({
                preventDefault: true,
                handler: me.onClick,
                // increase delay to avoid one click to start infinite spinning
                delay: Ext.isIE ? 1000 : 250,
                listeners: {
                    mousedown: me.onClickRepeaterMouseDown,
                    scope: me
                },
                scope: me
            }, this.repeaterConfig));
        } else {
            me.field.mon(el, {
                click: me.onClick,
                mousedown: me.onMouseDown,
                scope: me
            });
        }
    },
    onClick: function() {
        var me = this,
            args = arguments,
            e = me.clickRepeater ? args[1] : args[0],
            field = me.field;
        if (!field.readOnly && !field.disabled) {
            if (me.upEl.contains(e.target)) {
                Ext.callback(me.upHandler, me.scope, [
                    field,
                    me,
                    e
                ], 0, field);
            } else if (me.downEl.contains(e.target)) {
                Ext.callback(me.downHandler, me.scope, [
                    field,
                    me,
                    e
                ], 0, field);
            }
        }
        // When changing duration with click, some itemupdates will be fired and ext will try to restore focus to field,
        // but following focusing will cause field to loose focus and view to exit actionable mode.
        !Ext.isIE && field.inputEl.focus();
    }
});

/**
 * A specialized field allowing a user to also specify duration unit when editing the duration value.
 * This class inherits from the standard Ext JS "number" field, so any usual Ext.form.field.Number
 * configs can be used (like `minValue/maxValue` etc).
 */
Ext.define('Gnt.field.Duration', {
    extend: 'Ext.form.field.Number',
    requires: [
        'Gnt.util.DurationParser',
        'Gnt.field.trigger.DurationSpinner'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.durationfield',
    alternateClassName: 'Gnt.widget.DurationField',
    disableKeyFilter: true,
    allowExponential: false,
    minValue: 0,
    /**
     * @cfg {String} durationUnit The duration unit to use when editing the value.
     * **Beware:** If provided this option will force to use the provided duration unit for all the edited tasks
     * and will change the tasks {@link Gnt.model.Task#DurationUnit DurationUnit} field value.
     *
     * When the option is not provided the field using unit from the `DurationUnit` field of the task.
     */
    durationUnit: '',
    config: {
        triggers: {
            spinner: {
                type: 'gantt_durationspinner',
                upHandler: 'onSpinnerUpClick',
                downHandler: 'onSpinnerDownClick',
                scope: 'this'
            }
        }
    },
    /**
     * @cfg {String} invalidText Text shown when field value cannot be parsed to valid duration.
     * If you want to change the text for all instances of this class please use {@link #l10n l10n} instead.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - invalidText : 'Invalid duration value'
     */
    /**
     * @cfg {Boolean} useAbbreviation When set to `true` the field will use short names of unit durations
     * (as returned by {@link Sch.util.Date#getShortNameOfUnit})
     */
    useAbbreviation: false,
    getDurationUnitMethod: 'getDurationUnit',
    setTaskValueMethod: 'setDuration',
    getTaskValueMethod: 'getDuration',
    fieldProperty: 'durationField',
    durationParser: null,
    durationParserConfig: null,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        // durationUnit is used for all calculations, store config value to special property to reset later
        this.originalDurationUnit = this.durationUnit;
        this.durationParser = new Gnt.util.DurationParser(Ext.apply({
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn: function() {
                return me.parseValue.apply(me, arguments);
            },
            allowDecimals: this.decimalPrecision > 0
        }, this.durationParserConfig));
        this.callParent(arguments);
        this.invalidText = this.L('invalidText');
    },
    onSetTask: function() {
        // If field is configured with some duration unit - use it and convert value accordingly.
        // Otherwise - take from task
        this.durationUnit = this.originalDurationUnit || this.task[this.getDurationUnitMethod]();
        var value = this.getTaskValueMethod ? this.getTaskValue(null, this.durationUnit) : this.task.get(this.task[this.fieldProperty]);
        this.setValue(value);
        this.setSpinUpEnabled(value == null || value < this.maxValue, true);
        this.setSpinDownEnabled(value > this.minValue, true);
    },
    rawToValue: function(rawValue) {
        var parsed = this.parseDuration(rawValue);
        if (!parsed)  {
            return null;
        }
        
        this.durationUnit = parsed.unit;
        return parsed.value != null ? parsed.value : null;
    },
    valueToVisible: function(value, durationUnit) {
        if (Ext.isNumber(value)) {
            var valueInt = parseInt(value, 10),
                valueFixed = Ext.Number.toFixed(value, this.decimalPrecision);
            return String(valueInt == valueFixed ? valueInt : valueFixed).replace('.', this.decimalSeparator) + ' ' + Sch.util.Date[this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit'](durationUnit || this.durationUnit, value !== 1);
        }
        return '';
    },
    valueToRaw: function(value) {
        // Duration unit is empty string by default, in case it is missing - use hours
        return this.valueToVisible(value, this.durationUnit || 'h', this.decimalPrecision, this.useAbbreviation);
    },
    parseDuration: function(value) {
        if (value == null) {
            return null;
        }
        var duration = this.durationParser.parse(value);
        if (!duration) {
            return null;
        }
        duration.unit = duration.unit || this.durationUnit;
        return duration;
    },
    /**
     * Returns an object, representing the current value of the field:

    {
        value   : ... // duration value,
        unit    : ... // duration unit
    }

     * @return {Object}
     */
    getDurationValue: function() {
        return this.parseDuration(this.getRawValue());
    },
    getErrors: function(value) {
        var parsed;
        if (value) {
            parsed = this.parseDuration(value);
            if (!parsed) {
                return [
                    this.L('invalidText')
                ];
            }
            value = parsed.value;
        }
        // https://www.sencha.com/forum/showthread.php?306347-Number-field-throw-exception-when-validating-value
        if (arguments.length > 0 && value == null) {
            value = '';
        }
        return this.callParent(arguments);
    },
    // @OVERRIDE
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var me = this,
                newVal = me.getDurationValue(),
                oldVal = me.lastValue;
            var isDifferent = newVal && !oldVal || !newVal && oldVal || newVal && oldVal && (newVal.value != oldVal.value || newVal.unit != oldVal.unit);
            if (isDifferent && !me.isDestroyed) {
                me.lastValue = newVal;
                me.fireEvent('change', me, newVal, oldVal);
                me.onChange(newVal, oldVal);
            }
        }
    },
    // @OVERRIDE
    getValue: function() {
        return this.value;
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue(), this.durationUnit);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        toTask.fireEvent('taskupdated', toTask, this);
    },
    // @OVERRIDE
    onBlur: function(e) {
        var me = this;
        // Field only return duration value, not unit. When editing stops and instantUpdate is disabled duration
        // unit change will be ignored, unless we force it.
        me.blurring = true;
        var result = me.callParent(arguments);
        me.blurring = false;
        return result;
    },
    // @OVERRIDE
    setValue: function(value, forceUpdate) {
        var val = value;
        if (Ext.isObject(value)) {
            this.durationUnit = value.unit;
            val = value.value;
        }
        this.callParent([
            val
        ]);
        if (!this.readOnly && (forceUpdate || this.blurring || this.instantUpdate) && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    },
    // @private
    // it's called in editor.completeEdit()
    assertValue: function() {
        var me = this,
            oldVal = me.getValue(),
            oldUnit = me.durationUnit,
            newVal = me.getDurationValue();
        if (this.isValid()) {
            var isDifferent = /*newVal && !oldVal ||*/
                !newVal && oldVal || newVal && (newVal.value != oldVal || newVal.unit != oldUnit);
            if (isDifferent) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newVal, true);
            }
        }
    },
    // @OVERRIDE
    beforeBlur: function() {
        this.assertValue();
    },
    onSpinUp: function() {
        var me = this;
        if (!me.readOnly) {
            var value = me.getValue() || 0;
            me.setSpinValue(Ext.Number.constrain(value + me.step, me.minValue, me.maxValue));
        }
    },
    onSpinDown: function() {
        var me = this;
        if (!me.readOnly) {
            var value = me.getValue() || 0;
            me.setSpinValue(Ext.Number.constrain(value - me.step, me.minValue, me.maxValue));
        }
    }
});

/**
 * A column representing {@link Gnt.model.Task#Duration Duration} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 *
 *         // Setup your grid columns
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'durationcolumn',
 *                 width       : 70
 *             }
 *             ...
 *         ],
 *
 *         plugins             : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit: 1
 *             })
 *         ],
 *         ...
 *     })
 *
 * {@img gantt/images/duration-field.png}
 *
 * This column uses a field - {@link Gnt.field.Duration} which allows the
 * user to specify not only the duration value, but also the duration units.
 *
 * When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
 * method will be used to retrieve the name of the unit.
 */
Ext.define('Gnt.column.Duration', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.durationcolumn',
        'widget.ganttcolumn.duration'
    ],
    requires: [
        'Gnt.field.Duration'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    isDurationColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Duration'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 80,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the duration values containing decimals part (like "6.5 days") will be considered invalid.
     */
    decimalPrecision: 2,
    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated duration unit name, not full. Abbreviation will also be used
     * when editing the value. Useful if the column width is limited.
     */
    useAbbreviation: false,
    instantUpdate: true,
    fieldProperty: 'durationField',
    fieldConfigs: [
        'instantUpdate',
        'useAbbreviation',
        'decimalPrecision',
        'fieldProperty'
    ],
    editor: 'durationfield',
    defaultEditor: 'durationfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    afterRender: function() {
        this.callParent(arguments);
        this.setSorter(Ext.Function.bind(this.sorterFn, this));
    },
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        var unit = this.field.originalDurationUnit || task.getDurationUnit();
        value = task.getDuration(unit);
        return this.field.valueToVisible(value, unit);
    },
    putRawData: function(data, task) {
        task.setDuration(data);
    },
    eraseData: function(task) {
        this.putRawData(null, task);
    },
    sorterFn: function(task1, task2) {
        var ms1 = task1.getCalendar().convertDurationToMs(task1.getDuration(), task1.getDurationUnit()),
            ms2 = task2.getCalendar().convertDurationToMs(task2.getDuration(), task2.getDurationUnit());
        return ms1 === ms2 ? 0 : (ms1 < ms2 ? -1 : 1);
    }
});

/**
@class Gnt.field.Effort
@extends Gnt.field.Duration

A specialized field, allowing a user to also specify a duration unit when editing the effort value.
This class inherits from the {@link Gnt.field.Duration} field, which inherits from `Ext.form.field.Number` so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).

*/
Ext.define('Gnt.field.Effort', {
    extend: 'Gnt.field.Duration',
    alias: 'widget.effortfield',
    alternateClassName: 'Gnt.widget.EffortField',
    fieldProperty: 'effortField',
    getDurationUnitMethod: 'getEffortUnit',
    setTaskValueMethod: 'setEffort',
    getTaskValueMethod: 'getEffort',
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.getValue() || null, this.durationUnit);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        toTask.fireEvent('taskupdated', toTask, this);
    }
});

/**
 @class Gnt.field.ActualEffort
 A specialized field, allowing a user to also specify a duration unit when editing the actual effort value.
 This class inherits from the {@link Gnt.field.Effort} field, which inherits from `Ext.form.field.Number` so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).
 */
Ext.define('Gnt.field.ActualEffort', {
    extend: 'Gnt.field.Effort',
    alias: 'widget.actualeffortfield',
    alternateClassName: 'Gnt.widget.ActualEffortField',
    fieldProperty: 'actualEffortField',
    setTaskValueMethod: 'setActualEffort',
    getTaskValueMethod: 'getActualEffort'
});

/**
 * @class Gnt.column.ActualEffort
 *
 * A Column representing the {@link Gnt.model.Task#ActualEffort ActualEffort} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *        var gantt = Ext.create('Gnt.panel.Gantt', {
 *            height  : 600,
 *            width   : 1000,
 *
 *            // Setup your grid columns
 *            columns : [
 *                ...
 *                {
 *                    xtype       : 'actualeffortcolumn',
 *                    width       : 70
 *                }
 *                ...
 *            ],
 *
 *            plugins : [
 *                Ext.create('Sch.plugin.TreeCellEditing', {
 *                    clicksToEdit: 1
 *                })
 *            ],
 *            ...
 *        })
 * ```
 *
 * This column uses a field - {@link Gnt.field.ActualEffort} which allows the
 * user to specify not only the effort value, but also the duration units.
 *
 * When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
 * method will be used to retrieve the name of the unit.
 *
 */
Ext.define('Gnt.column.ActualEffort', {
    extend: 'Gnt.column.Duration',
    alias: [
        'widget.actualeffortcolumn',
        'widget.ganttcolumn.actualeffort'
    ],
    requires: [
        'Gnt.field.ActualEffort'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text : 'Actual Effort'
     */
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the effort values containing decimals part (like "6.5 days") will be considered invalid.
     */
    fieldProperty: 'actualEffortField',
    editor: 'actualeffortfield',
    defaultEditor: 'actualeffortfield',
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        return this.field.valueToVisible(value, task.getEffortUnit());
    },
    putRawData: function(data, task) {
        task.setActualEffort(data);
    }
});

/**
@class Gnt.field.Percent
A specialized field to enter percent values.
This class inherits from the standard Ext JS "number" field, so any usual Ext.form.field.Number configs can be used.
*/
Ext.define('Gnt.field.Percent', {
    extend: 'Ext.form.field.Number',
    alias: 'widget.percentfield',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: 'Gnt.widget.PercentField',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - invalidText : 'Invalid value'
     */
    disableKeyFilter: false,
    minValue: 0,
    maxValue: 100,
    allowExponential: false,
    baseChars: '0123456789%',
    selectOnFocus: false,
    constructor: function() {
        this.callParent(arguments);
        this.invalidText = this.L('invalidText');
    },
    valueToRaw: function(value) {
        if (Ext.isNumber(value)) {
            // Prevent Ext from showing a task as fully completed (100%) when it's not
            if (value > 99 && value < 100) {
                var precisionCoef = Math.pow(10, this.decimalPrecision);
                value = Math.floor(value * precisionCoef) / precisionCoef;
            }
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + '%';
        }
        return '';
    },
    getErrors: function(value) {
        var percent = this.parseValue(value);
        if (percent === null) {
            if (value !== null && value !== '') {
                return [
                    this.invalidText
                ];
            } else {
                percent = '';
            }
        }
        return this.callParent([
            percent
        ]);
    }
});

/*
 * @class Gnt.column.AssignmentUnits
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define("Gnt.column.AssignmentUnits", {
    extend: "Ext.grid.column.Number",
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    requires: [
        "Gnt.field.Percent"
    ],
    alias: "widget.assignmentunitscolumn",
    dataIndex: 'Units',
    format: '0 %',
    align: 'left',
    editor: {
        xtype: 'percentfield',
        minValue: 0,
        maxValue: undefined,
        step: 10,
        selectOnFocus: true
    },
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.scope = this;
        this.callParent(arguments);
    },
    // HACK, without 3 arguments the grid doesn't behave sanely
    renderer: function(value, meta, record) {
        if (value) {
            return Ext.util.Format.number(value, this.format);
        }
    }
});

// Basic internal date picker that colors dates based on the Task Calendar
Ext.define('Gnt.widget.DatePickerWithDateHighlighting', {
    extend: 'Ext.picker.Date',
    alias: 'widget.datepickerwithdatehighlighting',
    workingDayCls: 'gnt-datepicker-workingday',
    nonWorkingDayCls: 'gnt-datepicker-nonworkingday',
    overriddenDayCls: 'gnt-datepicker-overriddenday',
    overriddenWeekDayCls: 'gnt-datepicker-overriddenweekday',
    weekOverridesStore: null,
    dayOverridesCalendar: null,
    // @OVERRIDE
    // Adds custom classes to certain day cells
    update: function() {
        this.callParent(arguments);
        this.refreshCssClasses();
    },
    removeCustomCls: function() {
        this.cells.removeCls([
            this.overriddenDayCls,
            this.nonWorkingDayCls,
            this.workingDayCls,
            this.overriddenWeekDayCls
        ]);
    },
    refreshCssClasses: function() {
        var me = this;
        if (!me.cells || !me.cells.elements) {
            return;
        }
        var cells = me.cells.elements;
        this.removeCustomCls();
        for (var i = 0; i < me.numDays; i++) {
            // will contain number of ms since Epoch, so need to convert it into Date on the next line
            var timestamp = cells[i].firstChild.dateValue;
            cells[i].className += ' ' + this.getDateCls(new Date(timestamp));
        }
    },
    getCalendarDayCls: function(calendar, date) {
        var calendarDay = calendar.getCalendarDay(date),
            clsField = calendarDay.getField(calendarDay.clsField),
            defaultDayCls = clsField.getDefaultValue().trim(),
            dayCls = calendarDay.getCls().trim();
        // historically default value equals to 'sch-nonworkingtime' or 'gnt-holiday', so need to add only manually specified classes, otherwise all days will be marked as non working time
        return dayCls != defaultDayCls ? dayCls : '';
    },
    getDateCls: function(date) {
        var cls = this.workingDayCls;
        if (date.getMonth() !== this.getActive().getMonth()) {
            return;
        }
        if (this.calendar) {
            if (!this.calendar.isWorkingDay(date)) {
                cls = this.nonWorkingDayCls;
            }
            cls += ' ' + this.getCalendarDayCls(this.calendar, date);
        }
        return cls;
    }
});

/**
 * A specialized base class used for task fields of `Date` type.
 */
Ext.define('Gnt.field.Date', {
    extend: 'Ext.form.field.Date',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Gnt.widget.DatePickerWithDateHighlighting'
    ],
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: false,
    reAssertValue: true,
    validateOnFocusLeave: false,
    /**
     * @cfg {Boolean} keepTime Pass `true` to keep the timepart of the passed date value.
     * Works only if the field format does not contain hours info (so a user is not able to edit time part of the field value).
     */
    keepTime: true,
    // @OVERRIDE
    onExpand: function() {
        var value = this.valueToVisible(this.getValue());
        this._expanding = false;
        if (!this.isValid()) {
            value = this.getRawValue();
            if (value) {
                value = Ext.Date.parse(value, this.format);
            }
        }
        this.picker.setValue(Ext.isDate(value) ? value : new Date());
    },
    // @OVERRIDE to allow using our own custom date picker
    createPicker: function() {
        var old = Ext.picker.Date;
        Ext.picker.Date = Gnt.widget.DatePickerWithDateHighlighting;
        var retVal = this.callParent(arguments);
        Ext.picker.Date = old;
        return retVal;
    },
    applyKeptTimeToValue: function(value) {
        if (this.keepTime && !Ext.Date.formatContainsHourInfo(this.format)) {
            this.applyTimeToValue(value, this.getTaskValue());
        }
        return value;
    },
    applyTimeToValue: function(value, time) {
        time = time || this.getTaskValue();
        if (Ext.isDate(value) && time) {
            value.setHours(time.getHours());
            value.setMinutes(time.getMinutes());
        }
        return value;
    },
    // @OVERRIDE
    onSelect: function(picker, pickerDate) {
        var me = this;
        // if we display the date with hours, then we (probably) want to keep the task end date's hour/minutes
        // after selecting the date from the picker. In the same time picker will clear the time portion
        // so we need to restore it from original date
        // see also: https://www.bryntum.com/forum/viewtopic.php?f=9&t=4294
        if (this.keepTime || Ext.Date.formatContainsHourInfo(this.format)) {
            me.applyTimeToValue(pickerDate, this.getTaskValue());
        }
        var oldValue = me.getValue();
        var newValue = this.visibleToValue(pickerDate);
        var rawValue = Ext.Date.format(pickerDate, this.format);
        if (oldValue != newValue) {
            if (this.getErrors(rawValue).length > 0) {
                me.setRawValue(rawValue);
                me.onTabOut(picker);
                me.validate();
            } else {
                me.setValue(newValue, true);
                me.fireEvent('select', me, newValue);
                me.onTabOut(picker);
            }
        }
    },
    // @OVERRIDE
    /**
     * Sets the value of the field.
     *
     * **Note**, that this method accept the actual date value, as it is stored in the data model.
     * The displayed value can be different, when editing milestones.
     *
     * @param {Date} value New value of the field.
     */
    setValue: function(value, forceUpdate) {
        // Field looses focus when picker is expanded. We need to prevent setValue calls in case
        // they are originated from expanding picker.
        if (this._expanding)  {
            return;
        }
        
        this.callParent([
            value
        ]);
        var task = this.task;
        if (!this.readOnly && (forceUpdate || this.instantUpdate) && !this.getSuppressTaskUpdate() && task && // in 6.5.3 there is a new 'validateOnFocusLeave' config which conflicts with validate on blur, used in 6.5.2
        task.taskStore && (value || this.allowBlank) && (!(this.validateOnBlur || this.validateOnFocusLeave) || this.isValid())) {
            // apply changes to task
            this.applyChanges();
            // potentially value can be changed during set model call
            // so let`s check it after call and set final value again
            if (this.reAssertValue) {
                var taskValue = this.getTaskValue();
                if (taskValue - this.getValue() !== 0) {
                    this.callParent([
                        taskValue
                    ]);
                }
            }
            task.fireEvent('taskupdated', task, this);
        }
    },
    // @OVERRIDE
    rawToValue: function(rawValue) {
        if (!rawValue)  {
            return null;
        }
        
        var parsedDate = this.applyKeptTimeToValue(this.parseDate(rawValue));
        return this.visibleToValue(parsedDate) || rawValue || null;
    },
    // @OVERRIDE
    valueToRaw: function(value) {
        if (!value)  {
            return value;
        }
        
        return Ext.Date.format(this.valueToVisible(value), this.format);
    },
    /**
     * Returns the value of the field.
     *
     * **Note**, that this method returns the actual end date value, as it is stored in the data model.
     * The displayed value can be different, when date does not contain time information or when editing milestones.
     *
     * @return {Date}
     */
    getValue: function() {
        return Ext.isEmpty(this.value) ? null : this.value;
    },
    visibleToValue: function() {
        throw 'Abstract visibleToValue method called';
    },
    valueToVisible: function() {
        throw 'Abstract valueToVisible method called';
    },
    /*
     * We overrode 'getValue' method and broke default 'checkChange' method.
     * This fix is required for validation on-the-fly (as user type).
     * https://www.assembla.com/spaces/bryntum/tickets/1361
     */
    checkChange: function() {
        if (!this.suspendCheckChange) {
            var me = this,
                // we use raw value since 'getValue' method doesn't fire this goal after override
                newVal = me.rawToValue((me.inputEl ? me.inputEl.getValue() : Ext.valueFrom(me.rawValue, ''))),
                oldVal = me.lastValue;
            if (!me.isEqual(newVal, oldVal) && !me.isDestroyed) {
                me.lastValue = newVal;
                me.fireEvent('change', me, newVal, oldVal);
                me.onChange(newVal, oldVal);
            }
        }
    },
    // @private
    // it's called in editor.completeEdit()
    assertValue: function() {
        var me = this,
            oldRaw = me.rawValue,
            newRaw = me.getRawValue(),
            oldValue = me.getValue(),
            newValue = me.rawToValue(newRaw),
            //this can be wrong value should be set
            focusTask = me.focusTask;
        if (focusTask) {
            focusTask.cancel();
        }
        // AND changed to OR because raw values check always return false and values check seem to be enough
        if ((oldRaw != newRaw) || (newValue - oldValue !== 0)) {
            // set value only if field is valid
            if (!me.validateOnBlur || me.isValid()) {
                // at this point `setValue` should apply any changes from the field to the task
                // even if `instantUpdate` is disabled
                me.setValue(newValue, true);
            }
        }
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     * If {@link #instantUpdate} option is enabled this method is called automatically after any change in the field.
     *
     * @param {Gnt.model.Task} [toTask] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(toTask) {
        toTask = toTask || this.task;
        var taskStore = toTask.getTaskStore(true) || this.taskStore;
        if (this.value) {
            this.setTaskValue(toTask, this.value, this.keepDuration, taskStore.skipWeekendsDuringDragDrop);
        } else {
            this.setTaskValue(toTask, null);
        }
    },
    expand: function() {
        this._expanding = true;
        this.callParent(arguments);
    },
    // @OVERRIDE
    beforeBlur: function() {
        this.assertValue();
    }
});

/**
 * A specialized field for editing the task end date value. This class inherits from the Ext.form.field.Date field
 * and any of its configuration options can be used. You can find this field used in the {@link Gnt.widget.TaskForm}
 * and in the {@link Gnt.column.StartDate} classes but you can also use it in your own components.
 * See "Using field standalone" in the documentation of {@link Gnt.field.StartDate}.
 *
 * This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
 * (calendars, holidays etc).
 *
 * #Task interaction
 *
 * By default the field instantly applies all changes to the bound task. This can be turned off with the {@link #instantUpdate} option.
 *
 * #Using field standalone
 *
 * Please refer to {@link Gnt.field.StartDate} for details.
 */
Ext.define('Gnt.field.EndDate', {
    extend: 'Gnt.field.Date',
    alias: 'widget.enddatefield',
    requires: [
        'Sch.util.Date'
    ],
    fieldProperty: 'endDateField',
    getTaskValueMethod: 'getEndDate',
    setTaskValueMethod: 'setEndDate',
    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the field will validate a "startDate <= endDate" condition and will not allow user to save invalid value.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate: true,
    isBaseline: false,
    valueToVisible: function(value, task) {
        var me = this;
        task = task || me.task;
        if (task) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                value = task.getDisplayEndDate(me.format, me.adjustMilestones, value, true, me.isBaseline);
            }
        }
        return value;
    },
    visibleToValue: function(value, task) {
        var me = this;
        task = task || me.task;
        if (value && task) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                // "getDisplayEndDate" uses this condition to subtract 1 day - so here we do opposite
                if ((!task.isMilestone(me.isBaseline) || me.adjustMilestones) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(me.format)) {
                    value = Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
                }
            }
        } else {
            value = null;
        }
        return value;
    },
    isValidAgainstStartDate: function(value) {
        var task = this.task;
        var startDate = task && task.getStartDate();
        return !value || !startDate || (!task.getDuration() ? value >= startDate : value > startDate);
    },
    // @OVERRIDE
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        if (this.validateStartDate) {
            if (!this.isValidAgainstStartDate(this.rawToValue(value))) {
                return [
                    this.L('endBeforeStartText')
                ];
            }
        }
        return [];
    },
    onSetTask: function(task) {
        var picker = this.getPicker();
        picker.calendar = task.getCalendar();
        this.callParent(arguments);
    }
});

/**
 * A column showing the {@link Gnt.model.Task#EndDate EndDate} field of the tasks. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'enddatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit: 1
 *             })
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this column by default provides only a day-level editor (using {@link Gnt.field.EndDate} which subclasses Ext JS Ext.form.field.Date).
 * If you need a more precise editing (ie also specify the end hour/minute) you will need to either provide a {@link #format} including time info
 * or use your own field (which should extend {@link Gnt.field.EndDate}). See this [forum thread][1] for more information.
 *
 * [1]: https://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964
 *
 * Also **note**, that this class inherits from Ext.grid.column.Date and supports its configuration options (notably the {@link #format} option).
 */
Ext.define("Gnt.column.EndDate", {
    extend: "Ext.grid.column.Date",
    alias: [
        'widget.enddatecolumn',
        'widget.ganttcolumn.enddate'
    ],
    requires: [
        'Ext.grid.CellEditor',
        'Gnt.field.EndDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    isEndDateColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Finish'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {String} format
     * A formatting string to format a Date for this Column (see Ext.Date `format` method for details).
     */
    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as {@link #format} configuration
     * option of the column itself.
     */
    editorFormat: null,
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} validateStartDate When set to `true`, the column will validate a "startDate <= endDate" condition and won't allow user to save the invalid end date.
     * Set it to `false` if you use different validation mechanism.
     */
    validateStartDate: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: false,
    fieldProperty: 'endDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'validateStartDate',
        'fieldProperty'
    ],
    editor: 'enddatefield',
    defaultEditor: 'enddatefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    },
    // When copying from end date column, take display value, not real value
    // #4061
    getRawData: function(record) {
        var data = record.getEndDate();
        return data ? Ext.Date.parse(this.getValueToRender(data, null, record), this.format) : null;
    },
    // When pasting data to end date column value should be converted back to get correct visible value
    prepareNewEndDate: function(date, task) {
        if (date) {
            if (!(date instanceof Date)) {
                date = Ext.Date.parse(date, this.format);
            }
            date = this.field.visibleToValue(date, task);
        }
        return date;
    },
    // TODO: check this method it launches 2 propagations
    putRawData: function(data, task) {
        if (data) {
            data = this.prepareNewEndDate(data, task);
            if (task.getStartDate() && task.getStartDate() > data) {
                task.setDuration(0);
            }
        }
        task.setEndDate(data, task.isMilestone(), false);
    }
});

/**
 * A specialized field for editing the task baseline end date value. This class inherits from the `Ext.form.field.Date` field
 * and any of its configuration options can be used. You can find this field used in the {@link Gnt.widget.TaskForm}
 * and in the {@link Gnt.column.BaselineStartDate} classes but you can also use it in your own components.
 */
Ext.define('Gnt.field.BaselineEndDate', {
    extend: 'Gnt.field.EndDate',
    alias: 'widget.baselineenddatefield',
    /**
     * @hide
     * @cfg keepDuration
     */
    fieldProperty: 'baselineEndDateField',
    getTaskValueMethod: 'getBaselineEndDate',
    setTaskValueMethod: 'setBaselineEndDate',
    isBaseline: true,
    isValidAgainstStartDate: function(value) {
        return !this.task || !value || value >= this.task.getBaselineStartDate();
    },
    applyChanges: function(toTask, silent) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.value || null);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        if (!silent)  {
            toTask.fireEvent('taskupdated', toTask, this);
        }
        
    },
    onSetTask: function(task) {
        var picker = this.getPicker();
        picker.calendar = task.getCalendar();
        this.callParent(arguments);
    }
});

/**
 * A column displaying the {@link Gnt.model.Task#BaselineEndDate baseline end date} of a task.
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'baselineenddatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format" option.
 */
Ext.define('Gnt.column.BaselineEndDate', {
    extend: 'Gnt.column.EndDate',
    requires: [
        'Gnt.field.BaselineEndDate'
    ],
    alias: [
        'widget.baselineenddatecolumn',
        'widget.ganttcolumn.baselineenddate'
    ],
    width: 100,
    fieldProperty: 'baselineEndDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'validateStartDate',
        'fieldProperty'
    ],
    editor: 'baselineenddatefield',
    defaultEditor: 'baselineenddatefield',
    // When copying from end date column, take display value, not real value
    // #4061
    getRawData: function(record) {
        var date = record.getBaselineEndDate();
        return date ? Ext.Date.parse(this.getValueToRender(date, null, record), this.format) : null;
    },
    putRawData: function(data, task) {
        if (data) {
            data = this.prepareNewEndDate(data, task);
        }
        task.setBaselineEndDate(data);
    }
});

/**
 @class Gnt.field.BaselineCost

 A specialized field for editing the baseline cost value.
 This class inherits from the {@link Gnt.field.Cost} field, which inherits from Ext.form.field.Number so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).
 */
Ext.define('Gnt.field.BaselineCost', {
    extend: 'Gnt.field.Cost',
    alias: 'widget.baselinecostfield',
    alternateClassName: 'Gnt.widget.BaselineCostField',
    fieldProperty: 'baselineCostField',
    setTaskValueMethod: 'setBaselineCost',
    getTaskValueMethod: 'getBaselineCost'
});

/**
 * A Column representing the {@link Gnt.model.Task#BaselineCost BaselineCost} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *         var gantt = Ext.create('Gnt.panel.Gantt', {
 *                height      : 600,
 *                width       : 1000,
 *
 *                // Setup your grid columns
 *                columns         : [
 *                    ...
 *                    {
 *                        xtype       : 'baselinecostcolumn',
 *                        width       : 70
 *                    }
 *                    ...
 *                ],
 *
 *                plugins             : [
 *                    Ext.create('Sch.plugin.TreeCellEditing', {
 *                        clicksToEdit: 1
 *                    })
 *                ],
 *                ...
 *         })
 *
 * This column uses a field - {@link Gnt.field.BaselineCost} which allows the
 * user to specify the baseline cost value.
 */
Ext.define('Gnt.column.BaselineCost', {
    extend: 'Gnt.column.Cost',
    alias: [
        'widget.baselinecostcolumn',
        'widget.ganttcolumn.baselinecost'
    ],
    requires: [
        'Gnt.field.BaselineCost'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text : 'Baseline Cost'
     */
    fieldProperty: 'baselineCostField',
    editor: 'baselinecostfield',
    defaultEditor: 'baselinecostfield'
});

/**
 @class Gnt.field.BaselineEffort
 A specialized field, allowing a user to also specify a duration unit when editing the baseline effort value.
 This class inherits from the {@link Gnt.field.Effort} field, which inherits from `Ext.form.field.Number` so any regular {@link Ext.form.field.Number} configs can be used (like `minValue/maxValue` etc).
 */
Ext.define('Gnt.field.BaselineEffort', {
    extend: 'Gnt.field.Effort',
    alias: 'widget.baselineeffortfield',
    alternateClassName: 'Gnt.widget.BaselineEffortField',
    fieldProperty: 'baselineEffortField',
    setTaskValueMethod: 'setBaselineEffort',
    getTaskValueMethod: 'getBaselineEffort'
});

/**
 * A column representing {@link Gnt.model.Task#BaselineEffort BaselineEffort} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *         var gantt = Ext.create('Gnt.panel.Gantt', {
 *                height      : 600,
 *                width       : 1000,
 *
 *                // Setup your grid columns
 *                columns         : [
 *                    ...
 *                    {
 *                        xtype       : 'baselineeffortcolumn',
 *                        width       : 70
 *                    }
 *                    ...
 *                ],
 *
 *                plugins             : [
 *                    Ext.create('Sch.plugin.TreeCellEditing', {
 *                        clicksToEdit: 1
 *                    })
 *                ],
 *                ...
 *         })
 *
 * This column uses a field - {@link Gnt.field.BaselineEffort} which allows the
 * user to specify not only the effort value, but also the duration units.
 *
 * When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
 * method will be used to retrieve the name of the unit.
 *
 */
Ext.define('Gnt.column.BaselineEffort', {
    extend: 'Gnt.column.Duration',
    alias: [
        'widget.baselineeffortcolumn',
        'widget.ganttcolumn.baselineeffort'
    ],
    requires: [
        'Gnt.field.BaselineEffort'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text : 'Baseline Effort'
     */
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the effort values containing decimals part (like "6.5 days") will be considered invalid.
     */
    fieldProperty: 'baselineEffortField',
    editor: 'baselineeffortfield',
    defaultEditor: 'baselineeffortfield',
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        return this.field.valueToVisible(value, task.getEffortUnit());
    },
    putRawData: function(data, task) {
        task.setEffort(data);
    }
});

/**
 * A specialized field for editing the task start date value. This class inherits from the Ext.form.field.Date field
 * so any of its configuration options can be used. You can find this field in {@link Gnt.widget.TaskForm}
 * and in {@link Gnt.column.StartDate} but you can use it in your own components as well (see "Using field standalone" below).
 *
 * This field requires to be bound to {@link Gnt.model.Task task} instance, which is used for date value processing
 * (calendars, holidays etc).
 *
 * ## Task interacting
 *
 * By default the field instantly applies all changes to the {@link #task bound task}. This can be turned off with the {@link #instantUpdate} option.
 *
 * ## Using field standalone
 *
 * To use this field standalone you have to provide {@link Gnt.model.Task task} instance to it. You can make it by two ways:
 *
 * - Set the {@link #task} configuration option at field constructing step. Like this:
 *
 * ```javascript
 * var startDateField = Ext.create('Gnt.field.StartDate', {
 *     task : someTask
 * });
 * ```
 * - Or by calling {@link #setTask} method after field was created. Like this:
 *
 * ```javascript
 * startDateField.setTask(someTask);
 * ```
 *
 * **Note:** If task does not belong to any {@link Gnt.data.TaskStore} you also **have to** specify {@link #taskStore} config option for this field otherwise it won't work:
 *
 * ```javascript
 * // some tasks are not inserted in the task store yet
 * var someTask = new Gnt.model.Task({ ... });
 *
 * var startDateField = Ext.create('Gnt.field.StartDate', {
 *     task : someTask,
 *     // need to provide a task store instance in this case
 *     taskStore : taskStore
 * });
 * ```
 */
Ext.define('Gnt.field.StartDate', {
    extend: 'Gnt.field.Date',
    alias: 'widget.startdatefield',
    keepDuration: true,
    fieldProperty: 'startDateField',
    getTaskValueMethod: 'getStartDate',
    setTaskValueMethod: 'setStartDate',
    isBaseline: false,
    valueToVisible: function(value, task) {
        var me = this;
        task = task || me.task;
        if (task) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                value = task.getDisplayStartDate(me.format, me.adjustMilestones, value, true, me.isBaseline);
            }
        }
        return value;
    },
    visibleToValue: function(value, task) {
        var me = this;
        task = task || me.task;
        // Special treatment of milestone task dates
        if (task && value) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                var isMidnight = !Ext.isDate(me.lastValue) || me.lastValue - Ext.Date.clearTime(me.lastValue, true) === 0;
                // "getDisplayStartDate" uses this condition to subtract 1 day - so here we do opposite
                if (me.adjustMilestones && task.isMilestone(me.isBaseline) && value - Ext.Date.clearTime(value, true) === 0 && isMidnight && !Ext.Date.formatContainsHourInfo(me.format)) {
                    value = Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
                }
            }
        }
        return value;
    },
    onSetTask: function(task) {
        var picker = this.getPicker();
        picker.calendar = task.getCalendar();
        this.callParent(arguments);
    }
});

/**
 * A column representing the {@link Gnt.model.Task#StartDate StartDate} field of a task. The column is editable, however to enable the editing you will need to add a
 * {@link Sch.plugin.TreeCellEditing} plugin to your gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'startdatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit : 1
 *             })
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this column by default provides only a day-level editor (using {@link Gnt.field.StartDate} which subclasses Ext JS Ext.form.field.Date).
 * If you need a more precise editing (ie also specify the start hour/minute) you will need to either provide a {@link #format} including time info
 * or use your own field (which should extend {@link Gnt.field.StartDate}). See this [forum thread][1] for more information.
 *
 * Also **note**, that this class inherits from Ext.grid.column.Date and supports its configuration options (notably the {@link #format} option).
 *
 * [1]: https://bryntum.com/forum/viewtopic.php?f=16&t=2277&start=10#p13964
 */
Ext.define('Gnt.column.StartDate', {
    extend: 'Ext.grid.column.Date',
    alias: [
        'widget.startdatecolumn',
        'widget.ganttcolumn.startdate'
    ],
    requires: [
        'Gnt.field.StartDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    isStartDateColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Start'
     */
    /**
     * @cfg {Number} width A width of the column, default value is 100
     */
    width: 100,
    /**
     * @cfg {String} align An align of the text in the column, default value is 'left'
     */
    align: 'left',
    /**
     * @cfg {String} format
     * A formatting string to format a Date for this Column (see Ext.Date `format` method for details).
     */
    /**
     * @cfg {String} editorFormat A date format to be used when editing the value of the column. By default it is the same as `format` configuration
     * option of the column itself.
     */
    editorFormat: null,
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    /**
     * @cfg {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     */
    keepDuration: true,
    fieldProperty: 'startDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'keepDuration',
        'fieldProperty'
    ],
    editor: 'startdatefield',
    defaultEditor: 'startdatefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    },
    /**
     * Will validate and insert previously prepared assignment data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        task.setStartDate(data);
    }
});

/**
 * A specialized field for editing the task baseline start date value. This class inherits from the `Ext.form.field.Date` field
 * so any of its configuration options can be used. You can find this field in {@link Gnt.widget.TaskForm}
 * and in {@link Gnt.column.BaselineStartDate} but you can use it in your own components as well.
 */
Ext.define('Gnt.field.BaselineStartDate', {
    extend: 'Gnt.field.StartDate',
    alias: 'widget.baselinestartdatefield',
    fieldProperty: 'baselineStartDateField',
    getTaskValueMethod: 'getBaselineStartDate',
    setTaskValueMethod: 'setBaselineStartDate',
    isBaseline: true,
    /**
     * @hide
     * @cfg keepDuration
     */
    applyChanges: function(toTask, silent) {
        toTask = toTask || this.task;
        this.setTaskValue(toTask, this.value);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        if (!silent)  {
            toTask.fireEvent('taskupdated', toTask, this);
        }
        
    },
    onSetTask: function(task) {
        var picker = this.getPicker();
        picker.calendar = task.getCalendar();
        this.callParent(arguments);
    }
});

/**
 * A column displaying {@link Gnt.model.Task#BaselineStartDate the baseline start date} of a task.
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'baselinestartdatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format" option.
 */
Ext.define('Gnt.column.BaselineStartDate', {
    extend: 'Gnt.column.StartDate',
    requires: [
        'Gnt.field.BaselineStartDate'
    ],
    alias: [
        'widget.baselinestartdatecolumn',
        'widget.ganttcolumn.baselinestartdate'
    ],
    width: 100,
    fieldProperty: 'baselineStartDateField',
    fieldConfigs: [
        'instantUpdate',
        'adjustMilestones',
        'fieldProperty'
    ],
    editor: 'baselinestartdatefield',
    defaultEditor: 'baselinestartdatefield',
    putRawData: function(data, task) {
        if (data && !(data instanceof Date)) {
            data = Ext.Date.parse(data, this.format);
        }
        task.setBaselineStartDate(data);
    }
});

/**
@class Gnt.model.Calendar

A collection of this models is supposed to be provided for the {@link Gnt.data.CalendarManager calendar manager}.
A model represents a single calendar.
After a model instance is added to a calendar manager it automatically gets linked
with the {@link Gnt.data.Calendar} instance, created based on the model data.

The fields of the model correspond to the properties of {@link Gnt.data.Calendar} class.

*/
Ext.define('Gnt.model.Calendar', {
    extend: 'Sch.model.Customizable',
    requires: [
        'Ext.data.NodeInterface'
    ],
    idProperty: 'Id',
    calendar: null,
    /**
     * @cfg {String} nameField The name of {@link #Name the field} specifying the calendar name.
     */
    nameField: 'Name',
    /**
     * @cfg {String} daysPerMonthField The name of {@link #DaysPerMonth the field} specifying the number of days per month
     * (used when converting the big duration units like month/year to days).
     */
    daysPerMonthField: 'DaysPerMonth',
    /**
     * @cfg {String} daysPerWeekField The name of {@link #DaysPerWeek the field} specifying the number of days per week
     * (used when converting the duration only).
     */
    daysPerWeekField: 'DaysPerWeek',
    /**
     * @cfg {String} hoursPerDayField The name of {@link #HoursPerDay the field} specifying the number of hours per day
     * (used when converting the duration only).
     */
    hoursPerDayField: 'HoursPerDay',
    /**
     * @cfg {String} weekendsAreWorkdaysField The name of {@link #WeekendsAreWorkdays the field} specifying if all weekdays are working.
     */
    weekendsAreWorkdaysField: 'WeekendsAreWorkdays',
    /**
     * @cfg {String} weekendFirstDayField The name of {@link #WeekendFirstDay the field} specifying the index of the first day in a weekend.
     */
    weekendFirstDayField: 'WeekendFirstDay',
    /**
     * @cfg {String} weekendSecondDayField The name of {@link #WeekendSecondDay the field} specifying the index of the second day in a weekend.
     */
    weekendSecondDayField: 'WeekendSecondDay',
    /**
     * @cfg {String} defaultAvailabilityField The name of {@link #DefaultAvailability the field} specifying the calendar default availability
     */
    defaultAvailabilityField: 'DefaultAvailability',
    /**
     * @cfg {String} daysField The name of {@link #Days the field} specifying the calendar content ({@link Gnt.data.Calendar} instance)
     */
    daysField: 'Days',
    /**
     * @cfg {String} calendarClassField The name of {@link #CalendarClass the field} specifying the class that should be used to
     * to create {@link Gnt.data.Calendar the calendar} instance
     */
    calendarClassField: 'CalendarClass',
    /**
     * @cfg {String} phantomIdField The name of {@link #PhantomId the field} specifying the phantom id when this record is being 'realized' by the server.
     */
    phantomIdField: 'PhantomId',
    /**
     * @cfg {String} phantomParentIdField The name of {@link #PhantomParentId the field} specifying the parent calendar phantom id when this record is being 'realized' by the server.
     */
    phantomParentIdField: 'PhantomParentId',
    customizableFields: [
        /**
         * @field Id
         * The record identifier (corresponds to {@link Gnt.data.Calendar#calendarId}).
         */
        /**
         * @field
         * The calendar name.
         *
         * Corresponds to {@link Gnt.data.Calendar#name}.
         */
        {
            name: 'Name'
        },
        /**
         * @field
         * The number of days per a month
         * (is used when converting the big duration units like month/year to days).
         *
         * Corresponds to {@link Gnt.data.Calendar#daysPerMonth}.
         */
        {
            name: 'DaysPerMonth',
            type: 'number'
        },
        /**
         * @field
         * The number of days per week (is used when converting the duration only).
         *
         * Corresponds to {@link Gnt.data.Calendar#daysPerWeek}.
         */
        {
            name: 'DaysPerWeek',
            type: 'number'
        },
        /**
         * @field
         * The number of hours per day (used when converting the duration only).
         *
         * Corresponds to {@link Gnt.data.Calendar#hoursPerDay}.
         */
        {
            name: 'HoursPerDay',
            type: 'number'
        },
        /**
         * @field
         * The number of hours per day (used when converting the duration only).
         *
         * corresponds to {@link Gnt.data.Calendar#weekendsAreWorkdays}
         */
        {
            name: 'WeekendsAreWorkdays',
            type: 'boolean'
        },
        /**
         * @field
         * The index of the first day in a weekend.
         *
         * Corresponds to {@link Gnt.data.Calendar#weekendFirstDay}
         */
        {
            name: 'WeekendFirstDay',
            type: 'integer'
        },
        /**
         * @field
         * The index of the second day in a weekend.
         *
         * Corresponds to {@link Gnt.data.Calendar#weekendSecondDay}
         */
        {
            name: 'WeekendSecondDay',
            type: 'integer'
        },
        /**
         * @field
         * The calendar default availability.
         *
         * Corresponds to {@link Gnt.data.Calendar#defaultAvailability}
         */
        {
            name: 'DefaultAvailability'
        },
        /**
         * @field
         * A reference to the {@link Gnt.data.Calendar} instance bound.
         */
        {
            name: 'Days'
        },
        /**
         * @field
         * Calendar class that should be used to create {@link Gnt.data.Calendar} instance.
         */
        {
            name: 'CalendarClass',
            defaultValue: 'Gnt.data.Calendar'
        },
        /**
         * @field
         * Phantom record identifier.
         */
        {
            name: 'PhantomId'
        },
        /**
         * @field
         * Phantom parent record identifier.
         */
        {
            name: 'PhantomParentId'
        }
    ],
    constructor: function(config, id, node) {
        var cfg = config || node || {};
        var days = cfg.calendar || cfg.Days;
        config && delete config.calendar;
        node && delete node.calendar;
        // keep originally provided fields
        this.rawConfig = Ext.apply({}, config);
        this.callParent(arguments);
        this.setDays(days);
        this.data[this.phantomIdField] = this.getId();
    },
    get: function(field) {
        if (field === 'Days') {
            return this.getCalendar() || this.data[this.daysField];
        } else {
            return this.callParent(arguments);
        }
    },
    set: function(field, value) {
        if (field === 'Days') {
            if (value instanceof Gnt.data.Calendar) {
                this.setCalendar(value);
            } else {
                this.data[this.daysField] = value;
            }
        } else {
            return this.callParent(arguments);
        }
    },
    /**
     * Gets a calendar assigned to the record.
     */
    getCalendar: function() {
        return this.calendar;
    },
    /**
     * @private
     * Assign a calendar to the record.
     * @param {Gnt.data.Calendar} calendar The calendar to assign.
     */
    setCalendar: function(calendar) {
        this.calendar = calendar;
    },
    getCalendarConfig: function() {
        var me = this;
        var config = {
                calendarId: me.getId(),
                parent: me.parentNode && me.parentNode.getCalendar()
            };
        // properties we map to the calendar being created
        var properties = [
                'daysPerMonth',
                'daysPerWeek',
                'hoursPerDay',
                'name',
                'weekendFirstDay',
                'weekendSecondDay',
                'weekendsAreWorkdays',
                'defaultAvailability'
            ];
        for (var i = 0,
            l = properties.length; i < l; i++) {
            var property = properties[i],
                fieldName = me[property + 'Field'],
                fieldSpecified = me.rawConfig.hasOwnProperty(fieldName),
                fieldDef = me.getField(fieldName);
            // we map only properties that were explicitly provided to the model constructor
            // to give calendar class ability to retrieve others from prototype or parent calendars
            if (fieldSpecified && me.rawConfig[fieldName] != null) {
                // a customizable field getter
                config[property] = me['get' + Ext.String.capitalize(property)]();
            }
            // also allow override Calendar model by providing default values for its fields
            else if (!fieldSpecified && fieldDef && fieldDef.hasOwnProperty('defaultValue')) {
                config[property] = fieldDef.getDefaultValue();
            }
        }
        return config;
    },
    getModelConfig: function(calendar, isPrototype) {
        var result = {};
        // if we retrieve data from class prototype we should not
        // set reference to "calendar" instance ..since "calendar" is not an instance really
        if (!isPrototype) {
            result.parentId = calendar.parent && calendar.parent.calendarId;
            result.calendar = calendar;
        }
        result[this.daysPerMonthField] = calendar.daysPerMonth;
        result[this.daysPerWeekField] = calendar.daysPerWeek;
        result[this.hoursPerDayField] = calendar.hoursPerDay;
        result[this.nameField] = calendar.name;
        result[this.weekendFirstDayField] = calendar.weekendFirstDay;
        result[this.weekendSecondDayField] = calendar.weekendSecondDay;
        // the following two options might be inherited from the calendar parents
        // in this case they should be omitted in the model configuration
        if (calendar.hasOwnProperty('weekendsAreWorkdays')) {
            result[this.weekendsAreWorkdaysField] = calendar.weekendsAreWorkdays;
        }
        if (calendar.hasOwnProperty('defaultAvailability')) {
            result[this.defaultAvailabilityField] = calendar.defaultAvailability;
        }
        result[this.calendarClassField] = Ext.getClassName(calendar);
        return result;
    },
    setCalendarManager: function(calendarManager) {
        this.calendarManager = calendarManager;
    },
    getCalendarManager: function() {
        return this.calendarManager;
    },
    getParentCalendarClass: function() {
        var parent = this.parentNode,
            result;
        while (parent && !result) {
            result = parent.getCalendarClass();
            parent = parent.parentNode;
        }
        return result;
    },
    fillDataFromPrototype: function(nodeData) {
        // try to get proper calendar class:
        //  1. from the "nodeData" itself
        var cls = nodeData[this.calendarClassField] || //  2. from this.treeStore if presented
            this.treeStore && this.treeStore.getCalendarClass() || //  2. from "this" or its parents ("this" is supposed to become the "nodeData" parent)
            this.getCalendarClass() || this.getParentCalendarClass() || this.getField(this.calendarClassField).getDefaultValue();
        if (cls) {
            if (!nodeData[this.calendarClassField])  {
                nodeData[this.calendarClassField] = cls;
            }
            
            var children = nodeData.children;
            if (children && children.length) {
                for (var i = 0; i < children.length; i++) {
                    this.fillDataFromPrototype(children[i]);
                }
            }
        }
    },
    prepareCalendarNode: function(node) {
        // fill model fields with data retrieved from the calendar
        if (node instanceof Gnt.data.Calendar) {
            node = this.getModelConfig(node);
        }
        // .. or from associated CalendarClass prototype
        else if (Ext.isObject(node) && !(node instanceof Gnt.model.Calendar)) {
            this.fillDataFromPrototype(node);
        }
        node = this.createNode(node);
        if (this.phantom) {
            if (this.getId() !== node.data[this.phantomParentIdField]) {
                node.modified = node.modified || {};
                node.modified[this.phantomParentIdField] = node.data[this.phantomParentIdField];
                node.data[this.phantomParentIdField] = this.getId();
            }
        }
        return node;
    }
}, function() {
    // Do this first to be able to override NodeInterface methods
    Ext.data.NodeInterface.decorate(this);
    this.override({
        // @OVERRIDE
        insertBefore: function(node) {
            node = this.prepareCalendarNode(node);
            return this.callParent(arguments);
        },
        // @OVERRIDE
        appendChild: function(node) {
            if (node instanceof Array) {
                for (var i = 0; i < node.length; i++) {
                    node[i] = this.prepareCalendarNode(node[i]);
                }
            } else {
                node = this.prepareCalendarNode(node);
            }
            return this.callParent(arguments);
        }
    });
});

/**
 * @class Gnt.model.CalendarDay
 *
 * A model representing a single day in the calendar. Depending from the `Type` field, day may be a concrete day per se (2012/01/01),
 * a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
 * (all Fridays between 2012/01/01 - 2012/01/15, inclusive).
 *
 * A collection CalendarDay instances is supposed to be provided for the {@link Gnt.data.Calendar calendar}
 *
 * The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.
 */
Ext.define('Gnt.model.CalendarDay', {
    extend: 'Sch.model.CalendarDay',
    customizableFields: [
        /**
         * @field
         * @inheritdoc
         */
        {
            name: 'Cls',
            defaultValue: 'gnt-holiday'
        }
    ]
});
// For backwards compatibility

/**

@class Gnt.data.Calendar
@extends Sch.data.Calendar
@aside guide gantt_calendars

A class representing a customizable calendar with weekends, holidays and availability information for any day.
Internally, it's just a subclass of the Ext.data.Store class which should be loaded with a collection
of {@link Gnt.model.CalendarDay} instances. Additionally, calendars may have parent-child relations, allowing "child" calendars to "inherit"
all special dates from its "parent" and add its own. See {@link #parent} property for details.

* **Note, that this calendar class is configured for backward compatibility and sets whole 24 hours of every day except weekends,
as available time. If you are looking for a calendar with regular business hours and availability, use {@link Gnt.data.calendar.BusinessTime}**

A calendar can be instantiated like this:

    var calendar        = new Gnt.data.Calendar({
        data    : [
            {
                Date            : new Date(2010, 0, 13),
                Cls             : 'gnt-national-holiday'
            },
            {
                Date            : new Date(2010, 1, 1),
                Cls             : 'gnt-company-holiday'
            },
            {
                Date            : new Date(2010, 0, 16),
                IsWorkingDay    : true
            }
        ]
    });

It can then be provided as a {@link Gnt.data.TaskStore#calendar configuration option} for the {@link Gnt.data.TaskStore}. Note that the calendar should be
loaded prior to loading the taskStore where it's consumed.

Please refer to the {@link Gnt.model.CalendarDay} class to know with what data calendar can be loaded with.

To edit the data in the calendar visually you can use {@link Gnt.widget.calendar.Calendar}

*/
Ext.define('Gnt.data.Calendar', {
    extend: 'Sch.data.Calendar',
    model: 'Gnt.model.CalendarDay',
    defaultNonWorkingTimeCssCls: 'gnt-holiday'
});

/**
 * A specialized field allowing a user to select particular calendar for a task.
 * This class inherits from the standard Ext JS "combo box" field, so any standard `Ext.form.field.ComboBox` configs can be used.
 */
Ext.define('Gnt.field.Calendar', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.Store',
        'Sch.patches.BoundList',
        'Gnt.model.Calendar',
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarfield',
    alternateClassName: 'Gnt.widget.CalendarField',
    fieldProperty: 'calendarIdField',
    getTaskValueMethod: 'getCalendarId',
    setTaskValueMethod: 'setCalendarId',
    listConfig: {
        htmlEncode: true
    },
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Defines if the picker dropdown width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: true,
    editable: true,
    triggerAction: 'all',
    valueField: 'Id',
    displayField: 'Name',
    queryMode: 'local',
    forceSelection: true,
    allowBlank: true,
    initComponent: function() {
        var me = this,
            config = me.getInitialConfig();
        if (!config.store || me.store.isEmptyStore) {
            me.store = {
                xclass: 'Ext.data.Store',
                autoDestroy: true,
                model: 'Gnt.model.Calendar'
            };
        }
        if (!(me.store instanceof Ext.data.Store)) {
            me.store = Ext.create(me.store);
        }
        me.callParent(arguments);
        me.updateCalendarsStore();
        // listen to new calendars creation/removal and update the field store
        me.mon(Ext.data.StoreManager, {
            add: function(index, store, key) {
                if (store instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore();
                }
            },
            remove: function(index, store, key) {
                if (store instanceof Gnt.data.Calendar) {
                    this.updateCalendarsStore();
                }
            },
            scope: me
        });
        me.on({
            expand: me.updateCalendarsStore,
            show: function() {
                me.setReadOnly(me.readOnly);
            },
            change: me.onFieldChange,
            scope: me
        });
    },
    updateCalendarsStore: function() {
        var calendars = Ext.Array.map(Gnt.data.Calendar.getAllCalendars(), function(cal) {
                return {
                    Id: cal.calendarId,
                    Name: cal.name || cal.calendarId
                };
            });
        this.store.loadData(calendars);
    },
    setReadOnly: function(readOnly) {
        this.updateCalendarsStore();
        readOnly = readOnly || this.store.count() === 0;
        this.callParent([
            readOnly
        ]);
    },
    onSetTask: function(task) {
        // set field to readonly if no calendars
        this.setReadOnly(this.readOnly);
        var taskCalendarId = this.getTaskValue();
        // Fallback to project calendar if task does not have value assigned
        if (!taskCalendarId && typeof (taskCalendarId) !== "number") {
            var projectCalendar = task.getProjectCalendar();
            taskCalendarId = (projectCalendar && projectCalendar.calendarId) || taskCalendarId;
        }
        this.setValue(taskCalendarId);
    },
    // Used in the column renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        // When you type in a value that does not exist, for example "xxx",
        // the result in the combo list will be filtered out, so this.findRecordByValue(value) returns null.
        // forceSelection is true, so not valid value will force to select lastSelectedRecords[0], see combo.assertValue.
        // store.getById searches even in filtered out records
        var record = this.store.getById(value);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText) && typeof me.valueNotFoundText == 'string') {
            displayTplData.push(me.valueNotFoundText);
        }
        return me.displayTpl.apply(displayTplData);
    },
    // @OVERRIDE
    getValue: function() {
        return this.value || '';
    },
    getErrors: function(value) {
        if (value) {
            var record = this.findRecordByDisplay(value);
            if (record) {
                if (this.task && !this.task.isCalendarApplicable(record.getId())) {
                    return [
                        this.L('calendarNotApplicable')
                    ];
                }
            }
        }
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    onFieldChange: function(field, value) {
        this.setValue(value);
    },
    // @OVERRIDE
    // We need to have both onFieldChange and setValue
    // since setValue is not called when user select an option from the dropdown list
    setValue: function(value) {
        this.callParent([
            value
        ]);
        // we keep '' for empty field
        if (undefined === value || null === value || '' === value)  {
            this.value = '';
        }
        
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.getTaskValue() != this.value) {
                // apply changes to task
                this.applyChanges();
            }
        }
    },
    // @OVERRIDE
    assertValue: function() {
        var raw = this.getRawValue();
        if (!raw && this.value) {
            this.setValue('');
        } else {
            this.callParent(arguments);
        }
    }
});

/**
 * A column representing {@link Gnt.model.Task#CalendarId CalendarId} field of a task. The column is editable, however to enable the editing you will
 * need to add a Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *        var gantt = Ext.create('Gnt.panel.Gantt', {
 *            height  : 600,
 *            width   : 1000,
 *
 *            // Setup your static columns
 *            columns : [
 *                ...
 *                {
 *                    xtype : 'calendarcolumn',
 *                    width : 80
 *                }
 *                ...
 *            ],
 *
 *            plugins : [
 *                // add Sch.plugin.TreeCellEditing plugin
 *                {
 *                    ptype        : 'scheduler_treecellediting'
 *                    clicksToEdit : 1
 *                }
 *            ],
 *            ...
 *        });
 *
 * This column uses a field - {@link Gnt.field.Calendar} as the editor.
 */
Ext.define('Gnt.column.Calendar', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.calendarcolumn',
        'widget.ganttcolumn.calendar'
    ],
    requires: [
        'Gnt.model.Calendar',
        'Gnt.field.Calendar'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     *  - text : 'Calendar'
     */
    /**
     * @cfg {Number} width
     * The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align
     * The alignment of the text in the column.
     */
    align: 'left',
    instantUpdate: true,
    store: null,
    fieldProperty: 'calendarIdField',
    fieldConfigs: [
        'instantUpdate',
        'store',
        'fieldProperty'
    ],
    editor: 'calendarfield',
    defaultEditor: 'calendarfield',
    initComponent: function() {
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format || Ext.Date.defaultFormat
        });
        this.callParent(arguments);
    },
    applyColumnCls: function(value, meta, task, col, index, store) {
        if (!value) {
            meta.tdCls = (meta.tdCls || '') + ' gnt-default';
        }
    },
    getValueToRender: function(value, meta, task, col, index, store) {
        value = value || (store.calendar ? store.calendar.calendarId : '');
        return this.field.valueToVisible(value, task) || value;
    },
    putRawData: function(value, record) {
        record.setCalendar(value);
    }
});

/**
 * A specialized field, allowing a user to specify task constraint date.
 * This class inherits from the standard Ext JS "date" field, so any usual `Ext.form.field.Date` configs can be used.
 */
Ext.define('Gnt.field.ConstraintDate', {
    extend: 'Gnt.field.Date',
    alias: 'widget.constraintdatefield',
    // This is required to properly handle the field's read only state as designated in task's isEditable() method
    fieldProperty: 'constraintDateField',
    getTaskValueMethod: 'getConstraintDate',
    setTaskValueMethod: 'setConstraintDate',
    reAssertValue: false,
    constructor: function(config) {
        config = config || {};
        this.format = config.format || this.L('format');
        return this.callParent(arguments);
    },
    valueToVisible: function(value, task) {
        var me = this,
            format = me.format || Ext.Date.defaultFormat;
        task = task || me.task;
        var constraintClass = task && task.getConstraintClass();
        if (constraintClass) {
            value = constraintClass.getDisplayableConstraintDateForFormat(value, format, task);
        }
        return value;
    },
    visibleToValue: function(value) {
        var me = this,
            format = me.format || Ext.Date.defaultFormat,
            task = me.task,
            constraintClass = task && task.getConstraintClass();
        if (constraintClass && !Ext.isEmpty(value)) {
            value = constraintClass.adjustConstraintDateFromDisplayableWithFormat(value, format, task);
        }
        return value;
    }
});

/**
 * A column displaying a task {@link Gnt.modelTask#ConstraintDate ConstraintDate} field. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your Gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'constraintdatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             // add Sch.plugin.TreeCellEditing plugin
 *             {
 *                 ptype        : 'scheduler_treecellediting'
 *                 clicksToEdit : 1
 *             }
 *         ],
 *         ...
 *     })
 *
 * Note that this class inherits from {@link Ext.grid.column.Date} and supports its configuration options, notably the "format".
*/
Ext.define('Gnt.column.ConstraintDate', {
    extend: 'Ext.grid.column.Date',
    alias: [
        'widget.constraintdatecolumn',
        'widget.ganttcolumn.constraintdate'
    ],
    requires: [
        'Gnt.field.ConstraintDate'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n A object, purposed for the class localization.
     * @cfg {String} l10n.text The text to show in the column header
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    // Need to properly obtain the data index if none is given
    fieldProperty: 'constraintDateField',
    editor: 'constraintdatefield',
    defaultEditor: 'constraintdatefield',
    initComponent: function() {
        this.format = this.format || this.L('format');
        this.initTaskFieldColumn({
            format: this.editorFormat || this.format,
            fieldProperty: this.fieldProperty
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    },
    putRawData: function(data, task) {
        task.setConstraintDate(data);
    }
});

/**
 * A specialized field, allowing a user to specify task constraint type.
 * This class inherits from the standard Ext JS "combo" field, so any usual `Ext.form.field.ComboBox` configs can be used.
 *
 * In default setup the value of this field can be one of the following strings:
 *
 * - "finishnoearlierthan"
 * - "finishnolaterthan"
 * - "mustfinishon"
 * - "muststarton"
 * - "startnoearlierthan"
 * - "startnolaterthan"
 * - "assoonaspossible"
 * - "aslateaspossible"
 *
 * but if one has created a new constraint class (see {@link Gnt.constraint.Base}) then this field value
 * might be that new class alias part after the 'gntconstraint.' prefix.
 */
Ext.define('Gnt.field.ConstraintType', {
    extend: 'Ext.form.field.ComboBox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Sch.patches.BoundList'
    ],
    uses: [
        'Gnt.constraint.Base'
    ],
    alias: 'widget.constrainttypefield',
    alternateClassName: 'Gnt.widget.ConstraintType.Field',
    fieldProperty: 'constraintTypeField',
    getTaskValueMethod: 'getConstraintType',
    setTaskValueMethod: 'setConstraint',
    listConfig: {
        htmlEncode: true
    },
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: false,
    forceSelection: true,
    triggerAction: 'all',
    /**
     * Localication object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - none : 'None'
     */
    initComponent: function() {
        var me = this;
        var noneString = me.L('none');
        me.store = me.store || Gnt.field.ConstraintType.buildDefaultConstraintTypeList(noneString);
        me.emptyText = me.emptyText || noneString;
        this.on('change', this.onFieldChange, this);
        me.callParent(arguments);
        this.optionsFilter = new Ext.util.Filter({
            id: me.getId() + '-filter',
            filterFn: me.filterOptions,
            scope: me
        });
        me.store.addFilter(this.optionsFilter);
    },
    filterOptions: function(record) {
        var constraintType = record.get(this.valueField),
            constraint = Gnt.constraint.Base.getConstraintClass(constraintType);
        // we show only options applicable to the task being edited
        return !this.task || !constraintType || constraint && constraint.isApplicable(this.task);
    },
    onSetTask: function(task) {
        task = task || this.task;
        this.store && this.store.addFilter(this.optionsFilter);
        this.setValue(this.getTaskValue(task));
    },
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    // will be used in the column's renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        var record = this.findRecordByValue(!Ext.isEmpty(value) ? value : null);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText || "");
        }
        return me.displayTpl.apply(displayTplData);
    },
    applyChanges: function(task) {
        var me = this,
            value = me.getValue(),
            constraintClass;
        task = task || me.task;
        constraintClass = Gnt.constraint.Base.getConstraintClass(value);
        me.setTaskValue(task, value, constraintClass && constraintClass.getInitialConstraintDate(task) || null);
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        task.fireEvent('taskupdated', task, me);
    },
    findRecordByDisplay: function(value) {
        if (!value)  {
            return this.store.first();
        }
        
        return this.callParent(arguments);
    },
    onFieldChange: function(field, value) {
        var me = this;
        if (!me.getSuppressTaskUpdate() && me.task && (value || this.getRawValue() == me.L('none') || (!value && !this.getRawValue()))) {
            // apply changes to task
            me.applyChanges();
        }
    },
    statics: {
        /**
         * Builds default constraint type list by scanning Gnt.constraint namespace for suitable constraint classes
         *
         * @param {String} [noneText] Text to use for no constraint item, no constraint will be prepended to the list
         *  if text is given.
         */
        buildDefaultConstraintTypeList: function(noneText) {
            var result = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression('gntconstraint.*'), function(name) {
                var singleton = Ext.ClassManager.get(name),
                    alias = singleton.alias[0],
                    id = alias.split('.').pop();
                singleton && (result.push([
                    id,
                    singleton.L('name')
                ]));
            });
            result = Ext.Array.sort(result, function(a, b) {
                return a[1] > b[1] ? 1 : -1;
            });
            noneText && result.unshift([
                null,
                noneText
            ]);
            return result;
        }
    }
});

/**
 * A Column showing the {@link Gnt.model.Task#ConstraintType ConstraintType} field of a task. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your Gantt panel. The overall setup will look like this:
 *
 *      var gantt = Ext.create('Gnt.panel.Gantt', {
 *           height      : 600,
 *           width       : 1000,
 *
 *           columns         : [
 *               ...
 *               {
 *                   xtype       : 'constrainttypecolumn',
 *                   width       : 80
 *               }
 *               ...
 *           ],
 *
 *           plugins             : [
 *               Ext.create('Sch.plugin.TreeCellEditing', {
 *                   clicksToEdit: 1
 *               })
 *           ],
 *           ...
 *       })
 *
 */
Ext.define("Gnt.column.ConstraintType", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.ConstraintType'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        'widget.constrainttypecolumn',
        'widget.ganttcolumn.constrainttype'
    ],
    /**
     * @cfg {Object} l10n A object, purposed for the class localization.
     * @cfg {String} l10n.text Column title
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Array} data The to pass to Constraint Type field to be created in case the column is not configured with one already.
     * @cfg {String} data[][0] Valid constraint type
     * @cfg {String} data[][1] Constraint name
     */
    data: null,
    // Need to properly obtain the data index if none is given
    fieldProperty: 'constraintTypeField',
    editor: 'constrainttypefield',
    defaultEditor: 'constrainttypefield',
    initComponent: function() {
        this.initTaskFieldColumn({
            store: this.data,
            fieldProperty: this.fieldProperty
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && this.field.valueToVisible(value, task) || '';
    },
    putRawData: function(data, task) {
        task.setConstraintType(data);
    }
});

/**
 * A "calculated" column which displays the difference between {@link Gnt.model.Task#BaselineCost BaselineCost} and {@link Gnt.model.Task#Cost Cost} of a task.
 * See {@link Gnt.model.Task#getCostVariance} for details.
 */
Ext.define("Gnt.column.CostVariance", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        "widget.costvariancecolumn",
        "widget.ganttcolumn.costvariance"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Cost Variance'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 80,
    decimalPrecision: 2,
    /**
     * @cfg {String} decimalSeparator
     * The character that the {@link #number} function uses as a decimal point.
     *
     */
    decimalSeparator: null,
    fieldProperty: 'costVarianceField',
    /**
     * @cfg {String} currencySymbol The currency to set on display. By default the value is taken from the class locale.
     */
    currencySymbol: null,
    /**
     * @cfg {String} currencySymbolAlign The currency symbol align. Defines where the symbol should be rendered.
     * Possible options are:
     *
     *  - 'left' - left to the value,
     *  - 'right' - right to the value.
     *
     * By default the value is taken from the class locale.
     */
    currencySymbolAlign: null,
    initComponent: function() {
        this.currencySymbol = this.currencySymbol || this.L('currencySymbol');
        this.currencySymbolAlign = this.currencySymbolAlign || this.L('currencySymbolAlign');
        this.initTaskFieldColumn();
        this.decimalSeparator = this.decimalSeparator || Ext.util.Format.decimalSeparator;
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        var result = '';
        if (Ext.isNumber(value)) {
            result = Ext.Number.toFixed(value, this.decimalPrecision);
            if (this.currencySymbolAlign == 'left') {
                result = this.currencySymbol + ' ' + result;
            } else {
                result += ' ' + this.currencySymbol;
            }
        }
        return result;
    }
});

/**
 * A specialized field for editing the task deadline date value. This class inherits from the Ext.form.field.Date field
 * and any of its configuration options can be used.
 *
 * This field must be bound to a {@link Gnt.model.Task task} instance, which is used for date value processing
 * (calendars, holidays etc).
 *
 * #Using field standalone
 *
 * Please refer to {@link Gnt.field.StartDate} for details.
 */
Ext.define('Gnt.field.DeadlineDate', {
    extend: 'Gnt.field.Date',
    requires: [
        'Sch.util.Date'
    ],
    alias: 'widget.deadlinedatefield',
    fieldProperty: 'deadlineDateField',
    getTaskValueMethod: 'getDeadlineDate',
    setTaskValueMethod: 'setDeadlineDate',
    valueToVisible: function(value, task) {
        var me = this;
        task = task || me.task;
        if (value && task) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                value = task.getDisplayEndDate(me.format, true, value, true);
            }
        }
        return value;
    },
    visibleToValue: function(value, task) {
        var me = this;
        task = task || me.task;
        if (value && task) {
            var store = me.getTaskStore(task);
            if (!store || !store.disableDateAdjustments) {
                if (value - Ext.Date.clearTime(value, true) === 0) {
                    value = Sch.util.Date.add(value, Sch.util.Date.DAY, 1);
                }
            }
        }
        return value;
    },
    onSetTask: function(task) {
        var picker = this.getPicker();
        picker.calendar = task.getCalendar();
        this.callParent(arguments);
    }
});

/**
 * A column representing the {@link Gnt.model.Task#DeadlineDate DeadlineDate} date field of a task.
 * The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel.
 */
Ext.define('Gnt.column.DeadlineDate', {
    extend: 'Ext.grid.column.Date',
    requires: [
        'Gnt.field.DeadlineDate'
    ],
    alias: [
        'widget.deadlinecolumn',
        'widget.ganttcolumn.deadline'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Deadline'
     */
    // Ext 5.1.0 sets this to false
    draggable: true,
    fieldProperty: 'deadlineDateField',
    editor: 'deadlinedatefield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return value && Ext.Date.format(this.field.valueToVisible(value, task), this.format) || '';
    }
});

/**
 * @class Gnt.util.DependencyParser
 * @private
 * Internal class handling the dependency string parsing related functionality. Used by {@link Gnt.field.Dependency} field.
 */
Ext.define('Gnt.util.DependencyParser', {
    requires: [
        'Sch.util.Date',
        'Gnt.util.DurationParser'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     - typeText :
     - SS : 'SS'
     - SF : 'SF'
     - FS : 'FS'
     - FF : 'FF'
     */
    separator: /\s*;\s*/,
    parseNumberFn: null,
    dependencyRegex: null,
    types: null,
    constructor: function(config) {
        Ext.apply(this, config);
        // fill types array with values
        this.initTypes();
        var typeText = this.L('typeText');
        for (var i = 0; i < this.types.length; i++) {
            this.types[i] = (typeText[this.types[i]] || this.types[i]);
        }
        var re = '(-?\\d+)(' + this.types.join('|') + ')?([\\+\\-].*)?';
        this.dependencyRegex = this.dependencyRegex || new RegExp(re, 'i');
        this.durationParser = new Gnt.util.DurationParser({
            parseNumberFn: this.parseNumberFn
        });
    },
    initTypes: function() {
        this.types = this.types || [
            'SS',
            // Start-To-Start     //0
            'SF',
            // Start-To-Finish    //1
            'FS',
            // Finish-To-Start    //2
            'FF'
        ];
    },
    // Finish-To-Finish   //3
    /*
     * Returns an object with the following properties (or null if the parsing fails):
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            }
    **/
    parse: function(value, defaultType) {
        if (!value) {
            return [];
        }
        var parts = value.split(this.separator),
            result = [],
            depRe = this.dependencyRegex;
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            // allow ";" at the end of the string - will lead to empty element
            if (!part && i === parts.length - 1)  {
                
                continue;
            }
            
            var match = depRe.exec(part);
            var data = {};
            // Tolerate no sloppy input
            if (!match) {
                return null;
            }
            data.taskId = parseInt(match[1], 10);
            data.type = match[2] != null ? Ext.Array.indexOf(this.types, match[2].toUpperCase()) : (defaultType != null ? defaultType : 2);
            // FS is default
            var lagValue = match[3];
            if (lagValue) {
                var lag = this.durationParser.parse(lagValue);
                if (!lag) {
                    // Tolerate no sloppy input
                    return null;
                }
                data.lag = lag.value;
                data.lagUnit = lag.unit || Sch.util.Date.DAY;
            }
            result.push(data);
        }
        return result;
    }
});

/**
 * @class Gnt.model.Dependency
 *
 * This class represents a single Dependency in your gantt chart. It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familiar with the base interface of this class.
 *
 * Subclassing the Dependency class
 * --------------------
 *
 * The name of any field can be customized in the subclass, see the example below. Please also refer to {@link Sch.model.Customizable} for details.
 *
 * ```javascript
 *     Ext.define('MyProject.model.Dependency', {
 *         extend      : 'Gnt.model.Dependency',
 *
 *         toField     : 'targetId',
 *         fromField   : 'sourceId',
 *
 *         ...
 *     })
 * ```
 */
Ext.define('Gnt.model.Dependency', {
    extend: 'Sch.model.DependencyBase',
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg bidirectionalField
     * @hide
     */
    customizableFields: [
        /**
         * @field Bidirectional
         * @hide
         */
        /**
         * @field From
         * The id of the task at which the dependency starts
         */
        /**
         * @field To
         * The id of the task at which the dependency ends
         */
        /**
         * @field
         * A numeric part of the lag (lead) value between the tasks. Negative values can be used to provide lead.
         * Please note, that only working time is counted as "lag" time.
         * By default any lag-related calculations are performed using the successor task
         * calendar (can be changed with {@link Gnt.data.TaskStore#dependenciesCalendar} config).
         */
        {
            name: 'Lag',
            type: 'number',
            defaultValue: 0
        },
        /**
         * @field
         * A duration unit part of the lag value between the tasks. Valid values are:
         *
         * - "ms" (milliseconds)
         * - "s" (seconds)
         * - "mi" (minutes)
         * - "h" (hours)
         * - "d" (days)
         * - "w" (weeks)
         * - "mo" (months)
         * - "q" (quarters)
         * - "y" (years)
         */
        {
            name: 'LagUnit',
            type: 'string',
            defaultValue: "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert: function(value) {
                return value || Sch.util.Date.DAY;
            }
        }
    ],
    /**
     * @cfg {String} lagField The name of the field that contains the lag amount.
     */
    lagField: 'Lag',
    /**
     * @cfg {String} lagUnitField The name of the field that contains the lag unit duration.
     */
    lagUnitField: 'LagUnit',
    isHighlighted: false,
    getTaskStore: function() {
        return Ext.isFunction(this.store.getTaskStore) ? this.store.getTaskStore() : this.store.taskStore;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Returns the source task of the dependency
     *
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask: function(taskStore) {
        return this.getSourceEvent(taskStore);
    },
    /**
     * Sets the source task of the dependency
     *
     * @param {Gnt.model.Task} task The new source task of this dependency
     */
    setSourceTask: function(task) {
        return this.setSourceEvent(task);
    },
    /**
     * Returns the target task of the dependency
     *
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask: function(taskStore) {
        return this.getTargetEvent(taskStore);
    },
    /**
     * Sets the target task of the dependency
     *
     * @param {Gnt.model.Task} task The new target task of this dependency
     */
    setTargetTask: function(task) {
        return this.setTargetEvent(task);
    },
    /**
     * @method getLag
     *
     * Returns the amount of lag for the dependency
     *
     * @return {Number} The amount of lag for the dependency
     */
    /**
     * @method setLag
     *
     * Sets the amount of lag for the dependency
     *
     * @param {Number} amount The amount of lag for the dependency
     * @param {String} [unit] Lag duration unit
     */
    setLag: function(amount, unit) {
        var me = this;
        me.beginEdit();
        me.set(me.lagField, amount);
        if (arguments.length > 1) {
            me.setLagUnit(unit);
        }
        me.endEdit();
    },
    /**
     * Returns the duration unit of the lag.
     * @return {String} Lag duration unit
     */
    getLagUnit: function() {
        var me = this;
        return me.get(me.lagUnitField) || Sch.util.Date.DAY;
    },
    /**
     * @method setLagUnit
     * Updates the lag unit of the dependency.
     * @param {String} unit Lag duration unit
     */
    /**
     * Returns `true` if the dependency is valid. Note, this method assumes that the model is part of a {@link Gnt.data.DependencyStore}.
     * Invalid dependencies are:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid (this check is optional, see Gnt.data.DependencyStore#transitiveDependencyValidation)
     * @param {Gnt.data.TaskStore} [taskStore] Task store reference.
     * @return {Boolean} `true` is the dependency is valid and `false` otherwise.
     */
    isValid: function(taskStore) {
        var me = this,
            valid = me.callParent(arguments),
            sourceId = me.getSourceId(),
            targetId = me.getTargetId(),
            type = me.getType();
        if (valid && taskStore !== false && me.store) {
            valid = me.store.isValidDependency(sourceId, targetId, type, null, null, me);
        }
        return valid;
    },
    // Determines the type of dependency based on fromSide and toSide
    getTypeFromSides: function(fromSide, toSide) {
        var types = this.self.Type,
            startSide = 'start',
            endSide = 'end';
        if (fromSide === startSide) {
            return (toSide === startSide) ? types.StartToStart : types.StartToEnd;
        }
        return (toSide === endSide) ? types.EndToEnd : types.EndToStart;
    },
    /**
     * Returns `true` if the duration between the dependency source and target are less than {@link #Lag lag value}.
     * @return {Boolean} `true` if there is no slack between the dependency source and target tasks.
     */
    isCritical: function() {
        var me = this,
            source = me.getSourceTask(),
            target = me.getTargetTask(),
            lag = me.getLag(),
            depType = Gnt.model.Dependency.Type,
            result = false,
            calendar, sourceDate, targetDate, tasksDistance;
        if (source && target) {
            calendar = me.getCalendar();
            switch (me.getType()) {
                case depType.StartToStart:
                    sourceDate = source.getStartDate();
                    targetDate = target.getStartDate();
                    break;
                case depType.StartToEnd:
                    sourceDate = source.getStartDate();
                    targetDate = target.getEndDate();
                    break;
                case depType.EndToStart:
                    sourceDate = source.getEndDate();
                    targetDate = target.getStartDate();
                    break;
                case depType.EndToEnd:
                    sourceDate = source.getEndDate();
                    targetDate = target.getEndDate();
                    break;
            }
            if (lag < 0) {
                tasksDistance = calendar.calculateDuration(targetDate, sourceDate, me.getLagUnit());
                result = tasksDistance <= -lag;
            } else {
                tasksDistance = calendar.calculateDuration(sourceDate, targetDate, me.getLagUnit());
                result = tasksDistance <= lag;
            }
        }
        return result;
    },
    getCalendar: function(taskStore) {
        taskStore = taskStore || this.getTaskStore();
        var me = this,
            mode = taskStore && taskStore.dependenciesCalendar || 'target',
            source = me.getSourceTask(taskStore),
            target = me.getTargetTask(taskStore),
            result;
        if (source && target) {
            switch (mode) {
                case 'project':
                    result = target.getProjectCalendar();
                    break;
                case 'source':
                    result = source.getCalendar();
                    break;
                case 'target':
                    result = target.getCalendar();
                    break;
                default:
                    throw "Unsupported value for `dependenciesCalendar` config option";
            }
        }
        return result;
    }
});

/**
@class Gnt.field.Dependency
@extends Ext.form.field.Text

A specialized field allowing a user to change the dependencies of a task. The type of dependecies
created by this field is controlled by the {@link #type} config.

The text describing a dependency can be one or more values in the following format, separated with a {@link #separator} string:

    [TaskId][DependencyType][Lag]

where:

- `TaskId` is the id of the predecessor/successor task, can be a "real" or "sequential" id, see below.
- `DependencyType` (optional, default value is equal to Dependency model Type field default value) is one of the following (based on the {@link Gnt.util.DependencyParser#l10n}) property.
* **Please note** that dependency types are localized and depend on selected language (following values present English translation):
    - `FS` - for "Finish-To-Start"
    - `FF` - for "Finish-To-Finish"
    - `SF` - for "Start-To-Finish"
    - `SS` - for "Start-To-Start"
- `Lag` (optional). Should start with `+` or `-` followed by a number indicating the lag amount
and duration unit.


The `TaskId` part can contain either "real" id of the task (the id that is stored in the database) or "sequential" id.
The sequential id corresponds to the ordinal position of the task in the whole dataset. When you add or remove tasks
from the dataset, the sequential id of the tasks may change. Which type of id is used is controled by the
{@link #useSequenceNumber} config.

For example:
    10          - Finish to start dependency from task with Id 10
    10SS        - Start to start dependency from task with Id 10
    3FS+1d      - Finish to start dependency from task with Id 3, with +1 day lag
    3FS-10h      - Finish to start dependency from task with Id 3, with -10 hours lag

*/
Ext.define("Gnt.field.Dependency", {
    extend: "Ext.form.field.Text",
    alternateClassName: "Gnt.widget.DependencyField",
    alias: "widget.dependencyfield",
    requires: [
        'Sch.util.Date',
        'Gnt.util.DependencyParser',
        'Gnt.model.Dependency'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {String} type Either `predecessors` or `successors`. Defines the type of dependencies managed by this field. Defaults to 'predecessors'.
     */
    type: 'predecessors',
    // Or successors
    /**
     * @cfg {String} separator A separator between the dependency values in the text field.
     */
    separator: ';',
    task: null,
    /**
     * @property {Gnt.util.DependencyParser} dependencyParser
     * An object used to parse entered string to a proper dependency data.
     * **See also** {@link #dependencyParserConfig} config.
     */
    dependencyParser: null,
    /**
     * @cfg {Object} dependencyParserConfig
     * A config object to be passed to {@link Gnt.util.DependencyParser} constructor.
     */
    dependencyParserConfig: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - invalidFormatText   : 'Invalid dependency format',
            - invalidDependencyText : 'Invalid dependency found, please make sure you have no cyclic paths between your tasks',
            - invalidDependencyType : 'Invalid dependency type {0}. Allowed values are: {1}.'
     */
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false`then "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        this.dependencyParser = new Gnt.util.DependencyParser(Ext.apply({
            separator: new RegExp('\\s*' + me.separator + '\\s*'),
            // Since we're reusing the NumberField's parsing of numbers, we have to pass this on to the parser
            // to avoid having the same definitions in the parser too
            parseNumberFn: function() {
                return Gnt.field.Duration.prototype.parseValue.apply(me, arguments);
            }
        }, this.dependencyParserConfig));
        this.callParent(arguments);
        this.addCls('gnt-field-dependency');
    },
    isPredecessor: function() {
        return this.type === 'predecessors';
    },
    /**
     * Set the task this field is bound to.
     *
     * @param {Gnt.model.Task} task
     */
    setTask: function(task) {
        this.task = task;
        this.setRawValue(this.getFieldDisplayValue(task));
    },
    /**
     * Returns an array of dependency objects representing the current value of the field:

        [
            {
                taskId  : 3,    // Int, always present
                type    : "FS", // String, always present
                lag     : 3,    // Int, optional
                lagUnit : 'd'   // String, optional
            },
            ...
        ]

     * @return {Object} The dependencies
     */
    getDependencies: function(task) {
        return this.dependencyParser.parse(this.getRawValue(), this.getDefaultDependencyType(task));
    },
    getTaskIdFromDependency: function(dependencyData) {
        var store = this.task.getTaskStore(),
            taskId = dependencyData.taskId,
            task;
        if (this.useSequenceNumber) {
            task = store.getBySequenceNumber(taskId);
            taskId = task && task.getId();
        }
        return taskId;
    },
    getErrors: function(value) {
        if (!value)  {
            return [];
        }
        
        var dependencies;
        if (!Ext.isArray(value)) {
            dependencies = this.dependencyParser.parse(value, this.getDefaultDependencyType());
            if (!dependencies) {
                return [
                    this.L('invalidFormatText')
                ];
            }
        } else {
            dependencies = value;
        }
        if (this.task) {
            var isPredecessor = this.isPredecessor(),
                task = this.task,
                dependencyStore = task.getTaskStore().getDependencyStore(),
                depClass = dependencyStore.model,
                // existing dependencies
                oldDependencies = task[isPredecessor ? 'predecessors' : 'successors'],
                typeAbbrs = this.dependencyParser.types,
                allowedTypes = dependencyStore.allowedDependencyTypes,
                typeCodes = depClass.Type,
                // 'Type' is not a field name (look at Sch.model.DependencyBase -> inheritableStatics -> Type)
                taskId;
            // build list of tasks to be created, we need to provide it to isValidDependency() for correct validation
            var newDeps = [];
            for (var i = 0; i < dependencies.length; i++) {
                var depData = dependencies[i];
                taskId = this.getTaskIdFromDependency(depData);
                if (!taskId) {
                    return [
                        this.L('invalidDependencyText')
                    ];
                }
                // validate dependency type used
                if (dependencyStore.allowedDependencyTypes && !dependencyStore.isValidDependencyType(depData.type)) {
                    var allowed = '';
                    for (var j = 0,
                        k = allowedTypes.length; j < k; j++) {
                        allowed += typeAbbrs[typeCodes[allowedTypes[j]]] + ',';
                    }
                    return [
                        Ext.String.format(this.L('invalidDependencyType'), typeAbbrs[depData.type], allowed.substring(0, allowed.length - 1))
                    ];
                }
                var dep = new dependencyStore.model();
                dep.setSourceId(isPredecessor ? taskId : task.getId());
                dep.setTargetId(isPredecessor ? task.getId() : taskId);
                dep.setType(depData.type);
                dep.setLag(depData.lag, depData.lagUnit);
                newDeps.push(dep);
            }
            // loop over dependencies to be created
            for (i = 0; i < newDeps.length; i++) {
                // validate dependency: we ask store if `newDeps[i]` is valid if we remove `oldDependencies` and add `newDeps` dependencies
                if (!dependencyStore.isValidDependency(newDeps[i], newDeps, oldDependencies)) {
                    return [
                        this.L('invalidDependencyText')
                    ];
                }
            }
        }
        return this.callParent([
            value
        ]);
    },
    getDefaultDependencyType: function(task) {
        task = task || this.task;
        var depStore = task && task.getTaskStore() && task.getTaskStore().getDependencyStore(),
            depClass = depStore ? depStore.model : Gnt.model.Dependency,
            typeFieldDef = depClass.getField(depClass.prototype.typeField);
        return typeFieldDef && typeFieldDef.defaultValue || null;
    },
    getFieldDisplayValue: function(task) {
        var isPredecessor = this.isPredecessor(),
            deps = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            dpTypes = this.dependencyParser.types,
            strings = [],
            depTask;
        for (var i = 0; i < deps.length; i++) {
            var dep = deps[i];
            depTask = isPredecessor ? dep.getSourceTask() : dep.getTargetTask();
            if (depTask && dep.isValid(false)) {
                var type = dep.getType(),
                    lag = dep.getLag(),
                    lagUnit = dep.getLagUnit();
                strings.push(Ext.String.format('{0}{1}{2}{3}{4}', this.useSequenceNumber ? depTask.getSequenceNumber() : depTask.getId(), lag || type !== this.getDefaultDependencyType(task) ? dpTypes[type] : '', lag > 0 ? '+' : '', lag || '', lag && lagUnit !== Sch.util.Date.DAY ? lagUnit : ''));
            }
        }
        return strings.join(this.separator);
    },
    isDirty: function(task) {
        task = task || this.task;
        if (!task)  {
            return false;
        }
        
        var isPredecessor = this.isPredecessor(),
            depStore = task.getTaskStore().dependencyStore,
            deps = isPredecessor ? task.getIncomingDependencies() : task.getOutgoingDependencies(),
            taskId = task.getId();
        // check if some of task dependencies are dirty
        for (var i = 0,
            l = deps.length; i < l; i++) {
            if (deps[i].dirty || deps[i].phantom)  {
                return true;
            }
            
        }
        if (depStore) {
            var fn = isPredecessor ? 'getTargetId' : 'getSourceId';
            // check if there are some unsaved removed dependencies
            deps = depStore.getRemovedRecords();
            for (i = 0 , l = deps.length; i < l; i++) {
                if (deps[i][fn]() == taskId)  {
                    return true;
                }
                
            }
        }
        return false;
    },
    /**
     * This method applies the changes from the field to the bound task or to the task provided as 1st argument.
     *
     * @param {Gnt.model.Task} [task] The task to apply the changes to. If not provided, changes will be applied to the last bound task
     * (with {@link #task} config option or {@link #setTask) method)
     */
    applyChanges: function(task) {
        task = task || this.task;
        var depStore = task.getTaskStore().dependencyStore,
            dependencies = this.getDependencies(task),
            isPredecessor = this.isPredecessor(),
            currentDeps = isPredecessor ? task.getIncomingDependencies(true) : task.getOutgoingDependencies(true),
            toRemove = [],
            i;
        var ids = Ext.Array.map(dependencies, function(dep) {
                return this.getTaskIdFromDependency(dep);
            }, this);
        // First remove deleted dependencies
        for (i = 0; i < currentDeps.length; i++) {
            if (!Ext.Array.contains(ids, currentDeps[i][isPredecessor ? 'getSourceId' : 'getTargetId']())) {
                toRemove.push(currentDeps[i]);
            }
        }
        if (toRemove.length > 0) {
            depStore.remove(toRemove);
        }
        var toAdd = [];
        // Now iterate cell value, to update or add new dependencies
        for (i = 0; i < dependencies.length; i++) {
            var depData = dependencies[i];
            var predId = this.getTaskIdFromDependency(depData);
            var dep = depStore.getTasksLinkingDependency(predId, task.getId());
            if (dep) {
                dep.beginEdit();
                dep.setType(depData.type);
                dep.setLag(depData.lag, depData.lagUnit);
                dep.endEdit();
            } else {
                dep = new depStore.model();
                dep.setSourceId(isPredecessor ? predId : task.getId());
                dep.setTargetId(isPredecessor ? task.getId() : predId);
                dep.setType(depData.type);
                dep.setLag(depData.lag, depData.lagUnit);
                toAdd.push(dep);
            }
        }
        if (toAdd.length > 0) {
            depStore.add(toAdd);
        }
    }
});

/**
 * @class Gnt.column.Dependency
 * @private
 *
 * An internal private class serving as base class for {@link Gnt.column.Predecessor} and {@link Gnt.column.Successor} column classes.
*/
Ext.define("Gnt.column.Dependency", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.Dependency'
    ],
    isDependencyColumn: true,
    separator: ';',
    type: 'predecessors',
    // Or 'successors'
    // Reference to the field used by the Editor
    field: null,
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false`then the "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    constructor: function(config) {
        config = config || {};
        var field = config.editor;
        delete config.editor;
        Ext.apply(this, config);
        config.editor = field || Ext.create('Gnt.field.Dependency', {
            type: this.type,
            separator: this.separator,
            useSequenceNumber: this.useSequenceNumber
        });
        if (!(config.editor instanceof Gnt.field.Dependency)) {
            config.editor = Ext.ComponentManager.create(config.editor, 'dependencyfield');
        }
        config.field = config.editor;
        this.scope = this;
        this.callParent([
            config
        ]);
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    getContainingPanel: function() {
        if (!this.panel) {
            this.panel = this.up('tablepanel');
        }
        return this.panel;
    },
    setDirtyClass: function(meta, task) {
        var view = this.getContainingPanel().getView();
        if (view.markDirty && this.field.isDirty(task)) {
            meta.tdCls = view.dirtyCls;
        }
    },
    /**
     * @protected
     * Gantt panel is aware of this method and uses it (if the method is presented)
     * to check if corresponding column is editable.
     * @param  {Gnt.model.Task}  task Task about to being edited
     * @return {Boolean}      Return false to prevent editing
     */
    isEditable: function(task) {
        var panel = this.gantt || this.up('ganttpanel');
        if (task.isProject)  {
            return false;
        }
        
        return !task.isProject && (panel && panel.allowParentTaskDependencies || task.isLeaf());
    },
    /**
     * Return dependencies to be copied to memory, only works with 'raw' format
     * @param {Gnt.model.Task} task Task being copied
     * @return {Object[]}
     */
    getRawData: function(task) {
        var dependencies;
        if (this.type === 'predecessors') {
            dependencies = task.getIncomingDependencies(true);
        } else {
            dependencies = task.getOutgoingDependencies(true);
        }
        return Ext.Array.map(dependencies, function(dependency) {
            var data = dependency.copy(null).data;
            delete data[dependency.idProperty];
            return data;
        });
    },
    renderer: function(value, meta, task) {
        if (!task.isEditable(this.dataIndex) || !this.isEditable(task)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        } else {
            this.setDirtyClass(meta, task);
        }
        return this.field.getFieldDisplayValue(task);
    }
});

/**
 * A column displaying the earliest possible end date of a task.
 * This value is calculated based on the earliest end dates of the task predecessors.
 * If a task has no predecessors then its end date will be equal to its earliest end date.
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'earlyenddatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format" option.
 */
Ext.define('Gnt.column.EarlyEndDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        'widget.earlyenddatecolumn',
        'widget.ganttcolumn.earlyenddate'
    ],
    isEarlyEndDateColumn: true,
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    earlyEndDateFnOptions: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        var me = this,
            result = '';
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        var store = task.getTaskStore(true),
            isUndoingOrRedoing = store && store.isUndoingOrRedoing();
        // if Undo/Redo operations are in progress it makes no sense to render since anyway ..early/late dates will be reset on completion
        if (!isUndoingOrRedoing) {
            var date = task.getEarlyEndDate(me.earlyEndDateFnOptions);
            if (store && store.disableDateAdjustments) {
                result = Ext.util.Format.date(date, me.format);
            } else {
                result = task.getDisplayEndDate(me.format, me.adjustMilestones, date);
            }
        }
        return result;
    }
});

/**
 * A column displaying the earliest possible start date of a task.
 * This value is calculated based on earliest end dates of task's incoming dependencies.
 * If a task has no incoming dependencies then its start date is taken as earliest start date.
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 *
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'earlystartdatecolumn',
 *                 width       : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format".
 */
Ext.define('Gnt.column.EarlyStartDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        'widget.earlystartdatecolumn',
        'widget.ganttcolumn.earlystartdate'
    ],
    isEarlyStartDateColumn: true,
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    earlyStartDateFnOptions: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        var me = this,
            result = '';
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        var store = task.getTaskStore(true),
            isUndoingOrRedoing = store && store.isUndoingOrRedoing();
        // if Undo/Redo operations are in progress it makes no sense to render since anyway ..early/late dates will be reset on completion
        if (!isUndoingOrRedoing) {
            var date = task.getEarlyStartDate(me.earlyStartDateFnOptions);
            if (store && store.disableDateAdjustments) {
                result = Ext.util.Format.date(date, me.format);
            } else {
                result = task.getDisplayStartDate(me.format, me.adjustMilestones, date);
            }
        }
        return result;
    }
});

/**
 * A column representing {@link Gnt.model.Task#Effort Effort} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         // Setup your grid columns
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'effortcolumn',
 *                 width : 70
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit : 1
 *             })
 *         ],
 *         ...
 *     })
 *
 * {@img gantt/images/duration-field.png}
 *
 * This column uses a field - {@link Gnt.field.Effort} which allows the
 * user to specify not only the duration value, but also the duration units.
 *
 * When rendering the name of the duration unit, the {@link Sch.util.Date#getReadableNameOfUnit}
 * method will be used to retrieve the name of the unit.
 */
Ext.define('Gnt.column.Effort', {
    extend: 'Gnt.column.Duration',
    alias: [
        'widget.effortcolumn',
        'widget.ganttcolumn.effort'
    ],
    requires: [
        'Gnt.field.Effort'
    ],
    isEffortColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - text : 'Effort'
     */
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the field or when editing it.
     * When set to 0, the effort values containing decimals part (like "6.5 days") will be considered invalid.
     */
    fieldProperty: 'effortField',
    editor: 'effortfield',
    defaultEditor: 'effortfield',
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        return this.field.valueToVisible(value, task.getEffortUnit());
    },
    putRawData: function(data, task) {
        task.setEffort(data);
    },
    sorterFn: function(task1, task2) {
        var ms1 = task1.getCalendar().convertDurationToMs(task1.getEffort(), task1.getEffortUnit()),
            ms2 = task2.getCalendar().convertDurationToMs(task2.getEffort(), task2.getEffortUnit());
        return ms1 < ms2 ? -1 : 1;
    }
});

/**
 * A "calculated" column which displays the difference between {@link Gnt.model.Task#BaselineEffort BaselineEffort} and {@link Gnt.model.Task#Effort Effort} of a task.
 * See {@link Gnt.model.Task#getEffortVariance} for details.
 */
Ext.define("Gnt.column.EffortVariance", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        "widget.effortvariancecolumn",
        "widget.ganttcolumn.effortvariance"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Effort Variance'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 80,
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the column.
     * When set to 0, the duration values containing decimals part (like "6.5 days") will be considered invalid.
     */
    decimalPrecision: 2,
    /**
     * @cfg {String} decimalSeparator
     * The character that the {@link #number} function uses as a decimal point.
     *
     */
    decimalSeparator: null,
    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated duration unit name, not full. Abbreviation will also be used
     * when displaying the value. Useful if the column width is limited.
     */
    useAbbreviation: false,
    fieldProperty: 'effortVarianceField',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.decimalSeparator = this.decimalSeparator || Ext.util.Format.decimalSeparator;
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        if (!Ext.isNumber(value))  {
            return '';
        }
        
        var valueInt = parseInt(value, 10),
            valueFixed = Ext.Number.toFixed(value, this.decimalPrecision),
            unit = task.getEffortUnit();
        return String(valueInt == valueFixed ? valueInt : valueFixed).replace('.', this.decimalSeparator) + ' ' + Sch.util.Date[this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit'](unit, value !== 1);
    }
});

/**
 * A column displaying the latest possible end date of a task.
 * This value is calculated based on the latest start date of the task successors.
 * If a task has no successors then the project end date is used as its latest end date.
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'lateenddatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherit from Ext.grid.column.Date and supports its configuration options, notably the "format".
 */
Ext.define('Gnt.column.LateEndDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        'widget.lateenddatecolumn',
        'widget.ganttcolumn.lateenddate'
    ],
    isLateEndDateColumn: true,
    width: 100,
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    lateEndDateFnOptions: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        var me = this,
            result = '';
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        var store = task.getTaskStore(true),
            isUndoingOrRedoing = store && store.isUndoingOrRedoing();
        // if Undo/Redo operations are in progress it makes no sense to render since anyway ..early/late dates will be reset on completion
        if (!isUndoingOrRedoing) {
            var date = task.getLateEndDate(me.lateEndDateFnOptions);
            if (store && store.disableDateAdjustments) {
                result = Ext.util.Format.date(date, me.format);
            } else {
                result = task.getDisplayEndDate(me.format, me.adjustMilestones, date);
            }
        }
        return result;
    }
});

/**
 * A Column displaying the latest possible start date of a task.
 * This value is calculated as the latest start date of the dependent tasks for this task.
 * If a task has no successors then the column value is calculated as the project end date minus the task duration
 * (_project end date_ is the latest end date of all the tasks in the task store).
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'latestartdatecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *         ...
 *     });
 * ```
 *
 * **Note**, that this class inherits from Ext.grid.column.Date and supports its configuration options, notably the "format".
 */
Ext.define('Gnt.column.LateStartDate', {
    extend: 'Ext.grid.column.Date',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Format'
    ],
    alias: [
        'widget.latestartdatecolumn',
        'widget.ganttcolumn.latestartdate'
    ],
    isLateStartDateColumn: true,
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Boolean} adjustMilestones
     * If `true`, the start/end dates of the milestones will be adjusted -1 day *during rendering and editing*.
     * The task model will still hold the raw unmodified date.
     *
     * **Note:** No adjustments will be applied if {@link Gnt.panel.Gantt#disableDateAdjustments} is set to `true`.
     */
    adjustMilestones: true,
    lateStartDateFnOptions: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    rendererFunc: function(value, meta, task) {
        var me = this,
            result = '';
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        var store = task.getTaskStore(true),
            isUndoingOrRedoing = store && store.isUndoingOrRedoing();
        // if Undo/Redo operations are in progress it makes no sense to render since anyway ..early/late dates will be reset on completion
        if (!isUndoingOrRedoing) {
            var date = task.getLateStartDate(me.lateStartDateFnOptions);
            if (store && store.disableDateAdjustments) {
                result = Ext.util.Format.date(date, me.format);
            } else {
                result = task.getDisplayStartDate(me.format, me.adjustMilestones, date);
            }
        }
        return result;
    }
});

/**
 * A specialized field, allowing a user to also specify task manually scheduled value.
 * This class inherits from the standard Ext JS "checkbox" field, so any usual `Ext.form.field.Checkbox` configs can be used.
 */
Ext.define('Gnt.field.ManuallyScheduled', {
    extend: 'Ext.form.field.Checkbox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.manuallyscheduledfield',
    alternateClassName: [
        'Gnt.widget.ManuallyScheduledField'
    ],
    fieldProperty: 'manuallyScheduledField',
    setTaskValueMethod: 'setManuallyScheduled',
    getTaskValueMethod: 'getManuallyScheduled',
    instantUpdate: true,
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    getValue: function() {
        return this.value;
    },
    initEvents: function() {
        var me = this;
        me.on('change', me.onFieldValueChange, me);
        return me.callParent();
    },
    onFieldValueChange: function(me, newValue, oldValue) {
        if (me.instantUpdate && !me.getSuppressTaskUpdate() && me.task) {
            // apply changes to task
            me.applyChanges();
        }
    }
});

/**
 * A column showing the {@link Gnt.model.Task#ManuallyScheduled ManuallyScheduled} field of a task.
 */
Ext.define("Gnt.column.ManuallyScheduled", {
    extend: "Ext.grid.Column",
    alias: [
        'widget.manuallyscheduledcolumn',
        'widget.ganttcolumn.manuallyscheduledcolumn'
    ],
    requires: [
        'Gnt.field.ManuallyScheduled'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    width: 50,
    align: 'center',
    instantUpdate: false,
    fieldProperty: 'manuallyScheduledField',
    editor: 'manuallyscheduledfield',
    defaultEditor: 'manuallyscheduledfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(task.getManuallyScheduled());
    },
    putRawData: function(data, task) {
        task.setManuallyScheduled(data);
    }
});

/**
 * A specialized field allowing a user to convert regular task to milestone and back.
 */
Ext.define('Gnt.field.Milestone', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.JsonStore',
        'Sch.patches.BoundList'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.milestonefield',
    instantUpdate: false,
    allowBlank: false,
    forceSelection: true,
    displayField: 'text',
    valueField: 'value',
    queryMode: 'local',
    listConfig: {
        htmlEncode: true
    },
    constructor: function(config) {
        Ext.apply(this, config);
        this.store = new Ext.data.JsonStore({
            fields: [
                'value',
                'text'
            ],
            autoDestroy: true,
            data: [
                {
                    value: 0,
                    text: this.L('no')
                },
                {
                    value: 1,
                    text: this.L('yes')
                }
            ]
        });
        this.callParent(arguments);
        this.on('change', this.onFieldChange, this);
    },
    onSetTask: function() {
        this.setValue(this.task.isMilestone() ? 1 : 0);
    },
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    onFieldChange: function(field, value) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.task.isMilestone() != Boolean(this.value)) {
                // apply changes to task
                this.applyChanges();
            }
        }
    },
    getValue: function() {
        return this.value;
    },
    applyChanges: function(task) {
        task = task || this.task;
        if (this.getValue()) {
            task.convertToMilestone();
        } else {
            task.convertToRegular();
        }
        // since we have an "applyChanges" method different from the one provided by "TaskField" mixin
        // we need to fire "taskupdated" ourself
        task.fireEvent('taskupdated', task, this);
    }
});

/**
 @class Gnt.column.Milestone
 @extends Ext.grid.column.Column

 A Column showing if a task is a milestone or not.

        var gantt = Ext.create('Gnt.panel.Gantt', {
            height      : 600,
            width       : 1000,

            // Setup your static columns
            columns         : [
                ...
                {
                    xtype       : 'milestonecolumn',
                    width       : 80
                }
                ...
            ],

            plugins             : [
                Ext.create('Sch.plugin.TreeCellEditing', {
                    clicksToEdit: 1
                })
            ],
            ...
        });


 */
Ext.define('Gnt.column.Milestone', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.milestonecolumn',
        'widget.ganttcolumn.milestone'
    ],
    requires: [
        'Gnt.field.Milestone'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    isMilestoneColumn: true,
    width: 50,
    align: 'center',
    editor: 'milestonefield',
    defaultEditor: 'milestonefield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(task.isMilestone());
    },
    applyColumnCls: function(value, meta, task) {
        // There's no milestone field that we can use, so we check if both fields that can set task to be a milestone
        // are not editable
        if (!task.isEditable(task.durationField) && !task.isEditable(task.endDateField)) {
            meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        }
    },
    getRawData: function(record) {
        return record.isMilestone();
    },
    putRawData: function(value, record) {
        record[value ? 'convertToMilestone' : 'convertToRegular']();
    }
});

/**
 * A column representing the {@link Gnt.model.Task#Name Name} field of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your Gantt panel. The overall setup will look like this:
 *
 * ```javascript
 * var gantt = Ext.create('Gnt.panel.Gantt', {
 *     height      : 600,
 *     width       : 1000,
 *
 *     // Setup your grid columns
 *     columns         : [
 *         ...
 *         {
 *             xtype       : 'namecolumn',
 *             width       : 200
 *         }
 *         ...
 *     ],
 *
 *     plugins             : [
 *         Ext.create('Sch.plugin.TreeCellEditing', {
 *             clicksToEdit: 1
 *         })
 *     ],
 *     ...
 * })
 * ```
 */
Ext.define('Gnt.column.Name', {
    extend: 'Ext.tree.Column',
    alias: [
        'widget.namecolumn',
        'widget.ganttcolumn.name'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    // Ext 5.1.0 sets this to false
    draggable: true,
    fieldProperty: 'nameField',
    editor: 'textfield',
    cachedColumns: null,
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    applyColumnCls: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-gantt-name-cell';
        if (task.isProject) {
            meta.tdCls += ' sch-gantt-project-name';
        }
        if (!task.isLeaf()) {
            meta.tdCls += ' sch-gantt-parent-cell';
        }
    }
});

/**
 * A specialized field to be used for editing in the {@link Gnt.column.Note} column.
 */
Ext.define('Gnt.field.Note', {
    extend: 'Ext.form.field.Picker',
    alias: [
        'widget.notefield',
        'widget.noteeditor'
    ],
    alternateClassName: 'Gnt.widget.NoteField',
    requires: [
        'Ext.form.field.TextArea'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    matchFieldWidth: false,
    editable: false,
    selectOnFocus: false,
    /**
     * @cfg {Object} pickerConfig Configuration of the field picker (Ext.form.field.HtmlEditor instance)
     */
    pickerConfig: null,
    /**
     * @cfg {Function} previewFn
     * Function to return raw field value. If not provided the field uses text stripped of tags
     */
    previewFn: null,
    /**
     * @cfg {Function} previewFnScope
     * Scope for {!link #previewFn} function to return raw field value
     */
    previewFnScope: null,
    fieldProperty: 'noteField',
    getTaskValueMethod: 'getNote',
    setTaskValueMethod: 'setNote',
    afterRender: function() {
        this.callParent(arguments);
        this.on('collapse', this.onPickerCollapse, this);
    },
    valueToVisible: function(value) {
        if (this.previewFn) {
            return this.previewFn.call(this.previewFnScope || this, value);
        } else {
            return Ext.util.Format.stripTags(value);
        }
    },
    createPicker: function() {
        var field = Ext.widget(Ext.apply({
                xtype: 'textareafield',
                frame: true,
                shadow: false,
                floating: true,
                height: 200,
                width: 300,
                listeners: {
                    change: this.onPickerChange,
                    specialkey: this.onSpecialKey,
                    scope: this
                }
            }, this.pickerConfig || {}));
        return field;
    },
    onSpecialKey: function(picker, e) {
        var me = this;
        if (e.getKey() === e.ESC) {
            me.collapse();
        }
    },
    onPickerChange: function(picker, value) {
        var div = document.createElement('div');
        div.innerHTML = value;
        var text = div.innerText || div.textContent;
        this.setRawValue(this.valueToVisible(text));
    },
    getValue: function() {
        return this.getPicker().getValue();
    },
    setValue: function(value) {
        this.callParent([
            this.valueToVisible(value)
        ]);
        this.getPicker().setValue(value);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            this.applyChanges();
        }
    },
    onPickerCollapse: function() {
        this.setValue(this.getPicker().getValue());
    },
    onTriggerClick: function() {
        var me = this;
        if (!me.readOnly && !me.disabled) {
            if (me.isExpanded) {
                me.collapse();
            } else {
                me.expand();
            }
        }
    }
});

/**
 * A column showing the {@link Gnt.model.Task#Note Note} field of the task.
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 *
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'notecolumn',
 *                 width       : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins             : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit: 1
 *             })
 *         ],
 *         ...
 *     })
 *
 */
Ext.define("Gnt.column.Note", {
    extend: "Ext.grid.column.Column",
    requires: [
        'Gnt.field.Note'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        "widget.notecolumn",
        "widget.ganttcolumn.note"
    ],
    editor: 'notefield',
    defaultEditor: 'notefield',
    fieldProperty: 'noteField',
    previewFn: null,
    previewFnScope: null,
    htmlEncode: true,
    fieldConfigs: [
        'instantUpdate',
        'previewFn',
        'previewFnScope',
        'fieldProperty'
    ],
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    }
});

/**
 * A specialized field for editing the task percent complete value.
 * This class inherits from the standard Ext JS "number" field, so any usual `Ext.form.field.Number` configs can be used.
 */
Ext.define('Gnt.field.PercentDone', {
    extend: 'Gnt.field.Percent',
    alias: 'widget.percentdonefield',
    mixins: [
        'Gnt.field.mixin.TaskField'
    ],
    alternateClassName: 'Gnt.widget.PercentDoneField',
    fieldProperty: 'percentDoneField',
    setTaskValueMethod: 'setPercentDone',
    getTaskValueMethod: 'getPercentDone',
    instantUpdate: true,
    setValue: function(value) {
        this.callParent([
            value
        ]);
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/**
 * A Column representing the {@link Gnt.model.Task#PercentDone PercentDone} field of the task. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your Gantt panel. The overall setup will look like this:
 *
 * ```javascript
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'percentdonecolumn',
 *                 width : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit : 1
 *             })
 *         ],
 *         ...
 *     })
 * ```
 */
Ext.define("Gnt.column.PercentDone", {
    extend: "Ext.grid.column.Number",
    requires: [
        'Gnt.field.PercentDone'
    ],
    alias: [
        "widget.percentdonecolumn",
        "widget.ganttcolumn.percentdone"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    width: 90,
    format: '##0.##',
    align: 'center',
    editor: 'percentdonefield',
    defaultEditor: 'percentdonefield',
    fieldProperty: 'percentDoneField',
    useRenderer: false,
    fieldConfigs: 'instantUpdate,fieldProperty,decimalPrecision',
    /**
     * @cfg {Number} decimalPrecision The maximum precision to display after the decimal separator. The config value is used by the column editor.
     */
    decimalPrecision: 2,
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    putRawData: function(data, task) {
        task.setPercentDone(data);
    }
});

/**
 * A Column showing the predecessors of a task. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         // Setup your grid columns
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'predecessorcolumn',
 *                 width : 70
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit : 1
 *             })
 *         ],
 *         ...
 *     })
 *
 * This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
 * user to specify multiple predecessor including lag. Please refer to {@link Gnt.field.Dependency}
 * documentation for expected value format.
 */
Ext.define("Gnt.column.Predecessor", {
    extend: "Gnt.column.Dependency",
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        "widget.predecessorcolumn",
        "widget.ganttcolumn.predecessor"
    ],
    isPredecessorColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : 'Predecessors'
     */
    type: 'predecessors',
    constructor: function(config) {
        var me = this;
        config = config || {};
        me.text = config.text || me.L('text');
        me.filter = me.filter || {
            type: 'string',
            filterFn: function(task, filterValue) {
                return Boolean(Ext.Array.findBy(task.predecessors, function(predecessorDependency) {
                    var predecessor = predecessorDependency.getSourceTask();
                    return predecessor && filterValue == (me.useSequenceNumber ? predecessor.getSequenceNumber() : predecessor.id);
                }));
            }
        };
        me.callParent(arguments);
    },
    /**
     * Will validate and insert previously prepared predecessors data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        var dependencyStore = task.getDependencyStore();
        var toAdd = [];
        dependencyStore.remove(task.getIncomingDependencies(true));
        Ext.isArray(data) && Ext.Array.each(data, function(item) {
            // check if source task exists
            if (task.getTaskStore().getById(item[dependencyStore.model.prototype.fromField])) {
                var newDependency = new dependencyStore.model(item);
                newDependency.setTargetId(task.getId());
                if (dependencyStore.isValidDependency(newDependency)) {
                    toAdd.push(newDependency);
                }
            }
        });
        dependencyStore.add(toAdd);
    },
    eraseData: function(task) {
        this.putRawData([], task);
    }
});

/**

 @class Gnt.column.ReadOnly
 @extends Ext.grid.Column

 A Column which displays if the task is readonly.
 */
Ext.define("Gnt.column.ReadOnly", {
    extend: "Ext.grid.Column",
    alias: [
        "widget.readonlycolumn",
        "widget.ganttcolumn.readonly"
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    fieldProperty: 'readOnlyField',
    defaultEditor: 'readonlyfield',
    editor: 'readonlyfield',
    initComponent: function() {
        this.initTaskFieldColumn();
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.field.valueToVisible(value);
    }
});

/*
 * @class Gnt.column.ResourceName
 * @extends Ext.grid.Column
 * @private
 * Private class used inside Gnt.widget.AssignmentGrid.
 */
Ext.define('Gnt.column.ResourceName', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.resourcenamecolumn',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    flex: 1,
    align: 'left',
    resourceStore: null,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        Ext.apply(this, config);
        this.scope = this.scope || this;
        this.sorter = this.sorter || new Ext.util.Sorter({
            sorterFn: Ext.Function.bind(this.sortFn, this)
        });
        this.callParent(arguments);
    },
    renderer: function(value, m, assignment) {
        var resource = assignment.getResource(this.resourceStore);
        return Ext.htmlEncode(resource && resource.getName() || value);
    },
    sortFn: function(as1, as2) {
        return as1.getResourceName(this.resourceStore) < as2.getResourceName(this.resourceStore) ? -1 : 1;
    }
});

/**
 * @class Gnt.widget.AssignmentGrid
 * @extends Ext.grid.Panel
 *
 * A class used to display and edit the task assignments. You can configure this through the {@link Gnt.widget.AssignmentField#gridConfig gridConfig} object
 * available on the {@link Gnt.widget.AssignmentField} class.
 *
 * **Note:** AssignmentGrid edits assignments but it doesn't show assignments directly from the {@link #assignmentStore assignment store}!
 * It creates a new {@link #store Ext store} and copies records from the {@link #resourceStore resource store} and mixes assignments info into the new records.
 */
Ext.define('Gnt.widget.AssignmentGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.assignmentgrid',
    requires: [
        'Ext.data.Store',
        'Ext.grid.plugin.CellEditing',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits'
    ],
    /**
     * @cfg {Boolean} propagateChanges `true` to use task model methods and launch {@link Gnt.model.Task#propagateChanges changes propagation} (default).
     * Provide `false` to switch to backward compatible mode when the widget dealt with stores directly.
     */
    propagateChanges: true,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore
     * The assignment store
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore
     * The resource store
     */
    resourceStore: null,
    /**
     * @cfg {Ext.data.Store} store
     * The data source to which the grid is bound. Usually shouldn't be provided manually.
     * By default it's native Ext store with memory proxy and model definition equal to the {@link #assignmentStore}'s model.
     * Records are copied from the {@link #resourceStore} with mixed assignment data taken from the {@link #assignmentStore}.
     */
    store: null,
    /**
     * @property
     * @readonly
     * The task ID of the task for which assignments are being edited, or `null` if no tasks assigned.
     */
    taskId: null,
    readOnly: false,
    cls: 'gnt-assignmentgrid',
    height: 200,
    width: 300,
    frame: true,
    floating: true,
    focusOnToFront: false,
    // We do focusing ourselves in onExpand()
    cellEditing: null,
    // The sorting function defining the order of the resources
    sortResourcesFn: null,
    assignmentUnitsEditor: null,
    selModel: {
        selType: 'checkboxmodel',
        mode: 'MULTI',
        checkOnly: true
    },
    viewConfig: {
        markDirty: false
    },
    initComponent: function(config) {
        var me = this;
        if (!this.readOnly) {
            this.plugins = this.buildPlugins();
        }
        this.store = this.store || new Ext.data.Store({
            proxy: 'memory',
            autoDestroy: true,
            model: this.assignmentStore.getModel()
        });
        this.columns = this.columns || this.buildColumns();
        this.sortResourcesFn = this.sortResourcesFn || function(assignment1, assignment2) {
            var units1 = assignment1.getUnits(),
                units2 = assignment2.getUnits();
            // If both resources are assigned, sort them by Name
            if ((!units1 && !units2) || (units1 && units2)) {
                return assignment1.getResource(me.resourceStore).getName() < assignment2.getResource(me.resourceStore).getName() ? -1 : 1;
            }
            return units1 ? -1 : 1;
        };
        this.loadResources();
        this.mon(this.resourceStore, {
            datachanged: this.loadResources,
            scope: this
        });
        this.callParent(arguments);
        this.getSelectionModel().on({
            select: this.onSelect,
            deselect: this.onDeselect,
            scope: this
        });
    },
    onSelect: function(sm, rec) {
        if ((!this.cellEditing || !this.cellEditing.getActiveEditor()) && !rec.getUnits()) {
            rec.setUnits(rec.getField(rec.unitsField).defaultValue);
        }
    },
    onDeselect: function(sm, rec) {
        rec.setUnits(0);
    },
    loadResources: function() {
        var model = this.assignmentStore.getModel(),
            resourceIdField = model.prototype.resourceIdField,
            unitsField = model.prototype.unitsField;
        var data = Ext.Array.map(this.resourceStore.getRange(), function(resource) {
                var assignmentData = {};
                assignmentData[resourceIdField] = resource.getId();
                assignmentData[unitsField] = '';
                return assignmentData;
            });
        this.store.loadData(data);
    },
    // @private
    buildPlugins: function() {
        this.cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
            clicksToEdit: 1,
            listeners: {
                edit: this.onEditingDone,
                scope: this
            }
        });
        return [
            this.cellEditing
        ];
    },
    hide: function() {
        this.cellEditing.cancelEdit();
        this.callParent(arguments);
    },
    onEditingDone: function(ed, e) {
        // Make sure row is selected after editing a cell
        if (e.value) {
            this.getSelectionModel().select(e.record, true);
        } else {
            this.getSelectionModel().deselect(e.record);
            e.record.reject();
        }
    },
    // @private
    buildColumns: function() {
        return [
            {
                xtype: 'resourcenamecolumn',
                resourceStore: this.resourceStore
            },
            {
                xtype: 'assignmentunitscolumn'
            }
        ];
    },
    setEditableFields: function(taskId) {
        if (!this.assignmentUnitsEditor) {
            var column = this.down('assignmentunitscolumn');
            this.assignmentUnitsEditor = column && column.getEditor();
        }
        if (this.assignmentUnitsEditor) {
            var taskStore = this.assignmentStore && this.assignmentStore.getTaskStore(),
                task = taskStore && taskStore.getModelById(taskId);
            if (task) {
                switch (task.getSchedulingMode()) {
                    case 'DynamicAssignment':
                        this.assignmentUnitsEditor.setReadOnly(true);
                        break;
                    default:
                        this.assignmentUnitsEditor.setReadOnly(false);
                }
            }
        }
    },
    /**
     * @protected
     * @param {String/Number} taskId the task id
     */
    loadTaskAssignments: function(taskId) {
        var store = this.store,
            sm = this.getSelectionModel();
        this.taskId = taskId;
        // clear all checkboxes
        sm.deselectAll(true);
        // Reset all "Units" values of all resource assignment records first
        for (var i = 0; i < store.getCount(); i++) {
            // should be ok to use field names here, since we are inheriting directly from Gnt.model.Assignment
            var record = store.getAt(i);
            record.data[record.unitsField] = 0;
            record.data[record.idProperty] = null;
            // after each saveTaskAssignments we should call loadTaskAssignments to set proper __id__'s on task assignments
            delete record.__id__;
        }
        var taskAssignments = this.assignmentStore.getAssignmentsForTask(taskId);
        Ext.Array.each(taskAssignments, function(assignment) {
            var resourceAssignmentRecord = store.findRecord(assignment.resourceIdField, assignment.getResourceId(), 0, false, true, true);
            if (resourceAssignmentRecord) {
                var data = Ext.apply({}, assignment.data);
                delete data[assignment.idProperty];
                resourceAssignmentRecord.set(data);
                // can't assign to "idProperty" of the record because if "id" is missing
                // the store internal mapping will be broken (and "indexOf" method of the store will stop working)
                resourceAssignmentRecord.__id__ = assignment.getId();
                // mark the record with checkbox
                sm.select(resourceAssignmentRecord, true, true);
            }
        });
        // Apply sort to show assigned resources at the top
        store.sort({
            sorterFn: this.sortResourcesFn
        });
        // HACK Ext JS saves the sorter, remove it explicitly
        store.getSorters().removeAll();
        this.setEditableFields(taskId);
    },
    // @private
    // Old way of changes persisting: inserts records right into the store
    saveTaskAssignmentsDirectly: function(assignmentsToStay, newAssignments) {
        var me = this,
            aStore = me.assignmentStore,
            taskId = me.taskId,
            assignmentsToRemove = [];
        aStore.each(function(assignment) {
            //   assignment is for our task       | not phantom |       was unchecked
            if (assignment.getTaskId() == taskId && !assignmentsToStay[assignment.getId() || assignment.internalId]) {
                assignmentsToRemove.push(assignment);
            }
        });
        aStore.suspendAutoSync();
        aStore.remove(assignmentsToRemove);
        // Add selected assignments for this task
        aStore.add(newAssignments);
        aStore.resumeAutoSync();
        // Fire this event so UI can just react and update the row for the task
        aStore.fireEvent('taskassignmentschanged', aStore, taskId, newAssignments);
        if (aStore.autoSync) {
            aStore.sync();
        }
    },
    // @private
    // New way of changes persisting:
    // launches the propagation and supports changes rollback in case of a constraint violation.
    saveTaskAssignmentsWithPropagation: function(assignmentsToStay, newAssignments, callback) {
        var me = this,
            taskId = me.taskId,
            taskStore = me.assignmentStore && me.assignmentStore.getTaskStore(),
            task = taskStore && taskStore.getModelById(taskId),
            toUnassign = [];
        Ext.each(task.getAssignments(), function(assignment) {
            if (!assignmentsToStay[assignment.getId() || assignment.internalId]) {
                toUnassign.push(assignment.getResource(me.resourceStore));
            }
        });
        task.assignAndUnassignAssignments(toUnassign, newAssignments, callback);
    },
    saveTaskAssignments: function(callback) {
        var me = this,
            aStore = me.assignmentStore,
            taskStore = me.assignmentStore && me.assignmentStore.getTaskStore(),
            taskId = me.taskId,
            task = taskStore && taskStore.getModelById(taskId),
            assignmentsToStay = {},
            newAssignments = [];
        // Fire this event so UI can ignore the datachanged events possibly fired below
        aStore.fireEvent('beforetaskassignmentschange', aStore, taskId, newAssignments);
        me.getSelectionModel().selected.each(function(resourceAssignmentRecord) {
            var units = resourceAssignmentRecord.getUnits();
            if (units > 0) {
                // if not undefined that means resource was assigned to another task
                var id = resourceAssignmentRecord.__id__;
                if (id) {
                    var newData = Ext.apply({}, resourceAssignmentRecord.data);
                    delete newData[resourceAssignmentRecord.idProperty];
                    assignmentsToStay[id] = true;
                    aStore.getModelById(id).set(newData);
                } else {
                    var newAssignment = resourceAssignmentRecord.copy();
                    newAssignment.setTaskId(taskId);
                    assignmentsToStay[newAssignment.internalId] = true;
                    newAssignments.push(newAssignment);
                }
            }
        });
        if (task && this.propagateChanges) {
            me.saveTaskAssignmentsWithPropagation(assignmentsToStay, newAssignments, callback);
        } else // BW compat mode: deals directly w/ assignment store
        {
            me.saveTaskAssignmentsDirectly(assignmentsToStay, newAssignments);
        }
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    isDataValid: function() {
        return this.store.findBy(function(record) {
            return !record.isValid();
        }) < 0;
    },
    isEditing: function() {
        return Boolean(this.cellEditing.getActiveEditor());
    },
    /**
     * Return the task for which assignments are being edited, or `null` if no tasks assigned
     * @return {Gnt.model.Task} task
     */
    getTask: function() {
        var taskStore = this.assignmentStore && this.assignmentStore.getTaskStore();
        return this.taskId && taskStore && taskStore.getNodeById(this.taskId) || null;
    }
});

/**

 @class Gnt.field.Assignment
 @extends Ext.form.field.Picker

 A specialized field to be used for editing in the {@link Gnt.column.ResourceAssignment} column.

 */
Ext.define('Gnt.field.Assignment', {
    extend: 'Ext.form.field.Picker',
    alias: [
        'widget.assignmentfield',
        'widget.assignmenteditor'
    ],
    alternateClassName: 'Gnt.widget.AssignmentField',
    requires: [
        'Gnt.widget.AssignmentGrid'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    matchFieldWidth: false,
    editable: false,
    selectOnFocus: false,
    task: null,
    focusTimer: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - cancelText : 'Cancel',
     - closeText  : 'Save and Close'
     */
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources
     */
    resourceStore: null,
    /**
     * @cfg {Object} gridConfig A custom config object used to configure the Gnt.widget.AssignmentGrid instance
     */
    gridConfig: null,
    /**
     * @cfg {String} formatString A string defining how an assignment should be rendered. Defaults to '{0} [{1}%]'
     */
    formatString: '{0} [{1}%]',
    /**
     * @cfg {String} unitDecimalPrecision The number of decimals to show after the unit value (e.g. a value of 1 would produce [Mike 46.3%])
     */
    unitDecimalPrecision: 1,
    /**
     * @cfg {Boolean} [expandPickerOnFocus=false] true to show the grid picker when this field receives focus.
     */
    expandPickerOnFocus: false,
    /**
     * @cfg {Boolean} [returnFocusToField=true] Weither picker should return focus to the field after collapsing
     */
    returnFocusToField: true,
    initEvents: function() {
        var me = this;
        me.callParent();
        me.on({
            'expand': me.onExpandHandler,
            'collapse': me.onCollapseHandler,
            scope: me
        });
    },
    onFocusEnter: function(e) {
        var me = this;
        me.callParent([
            e
        ]);
        me.expandPickerOnFocus && me.expand();
    },
    focusPickerView: function() {
        var me = this,
            pickerView = me.getPicker().getView();
        // Transfering focus to picker
        pickerView.focusCell((new Ext.grid.CellContext(pickerView)).setPosition(0, 0));
    },
    // TODO: transform it to onExpand() template method as soon as it will be documented as @template/@protected
    onExpandHandler: function() {
        var me = this,
            picker = me.getPicker(),
            timeout = (Ext.versions.extjs.isGreaterThanOrEqual('6.6.0') && Ext.isIE) ? 100 : 10;
        // Select the assigned resource in the grid
        picker.loadTaskAssignments(this.task.getId());
        // Can't use me.getFocusTask().delay() here, since the focus task is shared among all the currently
        // instantiated components, and the delayed me.focusPickerView() call will be cancelled by the grid's navigation
        // model, in case the field is used as grid's editor, due to some cumbersome grid's navigation model logic
        // I have no time to investigate.
        this.focusTimer = Ext.Function.defer(function() {
            me.focusPickerView();
        }, timeout);
    },
    // TODO: transform it to onCollapse() template method as soon as it will be documented as @template/@protected
    onCollapseHandler: function() {
        var me = this;
        // #4612 Force editing to stop to apply changes
        me.picker.setActionableMode(false);
        // Returning focus back to field's input element if requested and field still marked as the one obtained
        // the focus (me.hasFocus == true), the field won't has focus in case we are collapsed due to actual focus
        // lost (see Ext.form.field.Picker::onFocusLeave())
        me.returnFocusToField && me.hasFocus && me.focus(true);
    },
    // This should focus field's input element
    createPicker: function() {
        var grid = Ext.widget(Ext.apply({
                xclass: 'Gnt.widget.AssignmentGrid',
                ownerCmp: this,
                resourceStore: this.task.getResourceStore(),
                assignmentStore: this.task.getAssignmentStore(),
                fbar: this.buildButtons(),
                listeners: {
                    cellkeydown: function(view, cell, cellIndex, record, tr, rowIndex, e) {
                        var column = view.headerCt.getComponent(cellIndex);
                        // Collapse picker on ESC key press
                        if (e.getKey() === e.ESC && !grid.isEditing()) {
                            this.collapse();
                        } else if (e.getKey() === e.ENTER && !grid.isEditing() && !(column.field || column.editor)) {
                            this.onSaveClick();
                        }
                    },
                    scope: this
                }
            }, this.gridConfig || {}));
        return grid;
    },
    buildButtons: function() {
        return [
            '->',
            {
                text: this.L('closeText'),
                handler: function() {
                    // When clicking on `close` button with editor visible
                    // the grid will be destroyed right away and seems in IE (and sporadically in FF)
                    // there will be no `blur` event for the editor.
                    // Doing a defer to let the editor to process the `blur` first
                    // and only then close the editor window.
                    this.saveTimer = Ext.defer(this.onSaveClick, Ext.isIE ? 60 : 30, this);
                },
                scope: this
            },
            {
                text: this.L('cancelText'),
                handler: function() {
                    this.collapse();
                },
                scope: this
            }
        ];
    },
    setTask: function(task) {
        this.task = task;
        this.setRawValue(this.getFieldDisplayValue(task));
    },
    onSaveClick: function() {
        // Update the assignment store with the assigned resource data
        var sm = this.picker.getSelectionModel(),
            selections = sm.selected;
        this.picker.saveTaskAssignments();
        this.collapse();
        this.setRawValue(this.getFieldDisplayValue(this.task));
        this.fireEvent('select', this, selections);
    },
    isDirty: function(task) {
        task = task || this.task;
        if (!task)  {
            return false;
        }
        
        var assignmentStore = this.picker && this.picker.assignmentStore || task.getAssignmentStore(),
            assignments = task.getAssignments();
        // check if some of task assignments are dirty
        for (var i = 0,
            l = assignments.length; i < l; i++) {
            if (assignments[i].dirty || assignments[i].phantom)  {
                return true;
            }
            
        }
        if (assignmentStore) {
            assignments = assignmentStore.getRemovedRecords();
            // check if there are some unsaved assignments removed from the task
            for (i = 0 , l = assignments.length; i < l; i++) {
                if (assignments[i].getTaskId() == task.getId())  {
                    return true;
                }
                
            }
        }
        return false;
    },
    getFieldDisplayValue: function(task) {
        task = task || this.task;
        var precision = this.unitDecimalPrecision;
        var resourceNames = Ext.Array.map(task.getAssignments(), function(assignment) {
                var units = parseFloat(Ext.Number.toFixed(assignment.getUnits(), precision));
                var formattedName = Ext.String.format(this.formatString, assignment.getResourceName(), units);
                return Ext.htmlEncode(formattedName);
            }, this);
        return resourceNames.join(', ');
    },
    destroy: function() {
        clearTimeout(this.focusTimer);
        clearTimeout(this.saveTimer);
        this.callParent(arguments);
    }
});

/**
 * @class Gnt.column.ResourceAssignment
 * @extends Ext.grid.column.Column
 * 
 * A Column showing the resource assignments of a task. To make the column editable,
 * add the {@link Sch.plugin.TreeCellEditing} plugin to your gantt panel:
 * 
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 * 
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'resourceassignmentcolumn',
 *                 width       : 80
 *             }
 *             ...
 *         ],
 * 
 *         plugins             : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit: 1
 *             })
 *         ],
 *         ...
 *     })
 * 
 * {@img gantt/images/resource-assignment.png 2x}
 * 
 */
Ext.define("Gnt.column.ResourceAssignment", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.resourceassignmentcolumn",
        "widget.ganttcolumn.resourceassignment"
    ],
    requires: [
        'Gnt.field.Assignment'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    tdCls: 'sch-assignment-cell',
    isResourceAssignmentColumn: true,
    /**
     * @cfg {Boolean} showUnits Set to `true` to show the assignment units (in percent). Default value is `true`.
     */
    showUnits: true,
    /**
     * @cfg {String} unitDecimalPrecision The number of decimals to show after the unit value (e.g. a value of 1 would produce [Mike 46.3%])
     */
    unitDecimalPrecision: 1,
    // Reference to the field used by the Editor
    field: null,
    // Copied from the panel view if cells for this columns should be marked dirty
    dirtyCls: null,
    /**
     * @cfg {Boolean} finalizeEditingOnPickerClose Set this to 'true' to finalize the cell editing after the resource picker is hidden.
     */
    finalizeEditingOnPickerClose: false,
    initComponent: function() {
        var me = this;
        me.text = me.L('text');
        me.editor = me.editor || {};
        if (!this.editor.isFormField) {
            me.editor = Ext.ComponentManager.create(Ext.applyIf(me.editor, {
                returnFocusToField: true,
                unitDecimalPrecision: me.unitDecimalPrecision,
                formatString: '{0}' + (me.showUnits ? ' [{1}%]' : '')
            }), 'assignmentfield');
        }
        me.filter = me.filter || {
            type: 'string',
            filterFn: function(task, filterValue) {
                return Boolean(Ext.Array.findBy(task.getResources(), function(resource) {
                    return resource.getName().match(new RegExp(filterValue, 'i'));
                }));
            }
        };
        me.field = me.editor;
        me.callParent(arguments);
        me.scope = me;
    },
    /**
     * @template
     * @private
     */
    getTableView: function() {
        // 'tablepanel' is used just for commonality this will work for both gridpanel and treepanel
        return this.up('tablepanel').getView();
    },
    sorterFn: function(task1, task2) {
        var me = this;
        var name1 = me.field.getFieldDisplayValue(task1),
            name2 = me.field.getFieldDisplayValue(task2);
        return name1 && (name1 > name2) ? -1 : 1;
    },
    afterRender: function() {
        var me = this,
            view = me.getTableView();
        // Check if the current view is configured to highlight dirty cells
        if (view.markDirty) {
            me.dirtyCls = view.dirtyCls;
        }
        me.callParent(arguments);
        // #4305
        // complete editing when the field is collapsed
        if (me.field && me.finalizeEditingOnPickerClose) {
            me.field.on('collapse', function() {
                me.getTableView().setActionableMode(false);
            });
        }
        me.setSorter(Ext.Function.bind(me.sorterFn, me));
    },
    getGroupValue: function(task) {
        var resourceNames = Ext.Array.map(task.getResources(), function(resource) {
                return resource.getName();
            });
        return resourceNames.sort().join(', ');
    },
    /**
     * Return assignment data to be saved to memory, only works with 'raw' format
     * @param {Gnt.model.Task} task Task being copied
     * @return {Gnt.model.Assignment[]}
     */
    getRawData: function(task) {
        return task.getAssignments();
    },
    /**
     * Will validate and insert previously prepared assignment data
     * @param {Gnt.model.Task[]} assignments Assignments to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(assignments, task) {
        var assignmentStore = task.getAssignmentStore();
        var toAdd = [];
        assignmentStore.removeAssignmentsForTask(task);
        Ext.isArray(assignments) && assignments.forEach(function(assignment) {
            var assignmentData = Ext.clone(assignment.isAssignmentModel ? assignment.data : assignment);
            if (task.getResourceStore().getById(assignmentData[assignmentStore.model.prototype.resourceIdField])) {
                delete assignmentData[assignmentStore.model.prototype.idProperty];
                assignmentData[assignmentStore.model.prototype.taskIdField] = task.getId();
                toAdd.push(Ext.clone(assignmentData));
            }
        });
        assignmentStore.add(toAdd);
    },
    eraseData: function(task) {
        this.putRawData([], task);
    },
    renderer: function(value, meta, task) {
        if (this.dirtyCls && this.field.isDirty(task)) {
            meta.tdCls = this.dirtyCls;
        }
        return this.field.getFieldDisplayValue(task);
    }
});

/**

@class Gnt.column.Rollup
@extends Ext.tree.Column

A Column which displays if the task should rollup to the parent task.
*/
Ext.define("Gnt.column.Rollup", {
    extend: 'Ext.grid.Column',
    alias: [
        'widget.rollupcolumn',
        'widget.ganttcolumn.rollup'
    ],
    requires: [
        'Ext.form.field.ComboBox',
        'Sch.patches.BoundList'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    fieldProperty: 'rollupField',
    editor: {
        xtype: 'combobox',
        listConfig: {
            htmlEncode: true
        }
    },
    defaultEditor: 'combobox',
    initComponent: function() {
        this.initTaskFieldColumn({
            store: [
                [
                    false,
                    this.L('no')
                ],
                [
                    true,
                    this.L('yes')
                ]
            ]
        });
        this.callParent(arguments);
    },
    getValueToRender: function(value, meta, task) {
        return this.L(value ? 'yes' : 'no');
    }
});

/**
 * A specialized field, allowing a user to also specify task scheduling mode value.
 * This class inherits from the standard Ext JS "combo" field, so any usual `Ext.form.field.ComboBox` configs can be used.
 *
 * The value of this field can be one of the following strings: `Normal`, `FixedDuration`, `EffortDriven`, `DynamicAssignment`.
 */
Ext.define('Gnt.field.SchedulingMode', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Sch.patches.BoundList'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.schedulingmodefield',
    alternateClassName: 'Gnt.widget.SchedulingmodeField',
    fieldProperty: 'schedulingModeField',
    setTaskValueMethod: 'setSchedulingMode',
    getTaskValueMethod: 'getSchedulingMode',
    listConfig: {
        htmlEncode: true
    },
    /**
     * @cfg {String} pickerAlign The align for combo-box's picker.
     */
    pickerAlign: 'tl-bl?',
    /**
     * @cfg {Boolean} matchFieldWidth Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
     */
    matchFieldWidth: true,
    editable: false,
    selectOnFocus: false,
    forceSelection: true,
    triggerAction: 'all',
    constructor: function(config) {
        config = config || {};
        if (!config.store)  {
            this.initStore(config);
        }
        
        this.callParent([
            config
        ]);
        this.on('change', this.onFieldChange, this);
    },
    initStore: function(config) {
        var me = this;
        config.store = me.getDefaultSchedulingModes();
    },
    getDefaultSchedulingModes: function() {
        var me = this;
        return [
            [
                'Normal',
                me.L('Normal')
            ],
            [
                'FixedDuration',
                me.L('FixedDuration')
            ],
            [
                'EffortDriven',
                me.L('EffortDriven')
            ],
            [
                'DynamicAssignment',
                me.L('DynamicAssignment')
            ]
        ];
    },
    // will be used in the column's renderer
    valueToVisible: function(value, task) {
        var me = this,
            displayTplData = [];
        var record = this.findRecordByValue(value);
        if (record) {
            displayTplData.push(record.data);
        } else if (Ext.isDefined(me.valueNotFoundText)) {
            displayTplData.push(me.valueNotFoundText);
        }
        return me.displayTpl.apply(displayTplData);
    },
    getErrors: function(value) {
        var errors = this.callParent(arguments);
        if (errors && errors.length) {
            return errors;
        }
        // allow empty values by default
        if (!Ext.isEmpty(value) && !(this.findRecordByDisplay(value) || this.findRecordByValue(value))) {
            return [
                this.L('invalidText')
            ];
        } else {
            return [];
        }
    },
    getValue: function() {
        return this.value;
    },
    onFieldChange: function(field, value) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task && this.value) {
            // apply changes to task
            this.applyChanges();
        }
    }
});

/**
 * A column showing the {@link Gnt.model.Task#SchedulingMode SchedulingMode} field of a task. The column is editable when adding a
 * Sch.plugin.TreeCellEditing plugin to your Gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height      : 600,
 *         width       : 1000,
 *
 *         columns         : [
 *             ...
 *             {
 *                 xtype       : 'schedulingmodecolumn',
 *                 width       : 80
 *             }
 *             ...
 *         ],
 *
 *         plugins             : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit: 1
 *             })
 *         ],
 *         ...
 *     })
 *
 */
Ext.define("Gnt.column.SchedulingMode", {
    extend: 'Ext.grid.column.Column',
    requires: [
        'Gnt.field.SchedulingMode'
    ],
    mixins: [
        'Gnt.column.mixin.TaskFieldColumn'
    ],
    alias: [
        'widget.schedulingmodecolumn',
        'widget.ganttcolumn.schedulingmode'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'Mode'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 100,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    /**
     * @cfg {Array} data A 2-dimensional array used for editing in combobox. The first item of inner arrays will be treated as "value" and 2nd - as "display"
     */
    data: null,
    fieldProperty: 'schedulingModeField',
    editor: 'schedulingmodefield',
    defaultEditor: 'schedulingmodefield',
    instantUpdate: false,
    initComponent: function() {
        this.initTaskFieldColumn({
            store: this.data
        });
        this.callParent(arguments);
    },
    // selection replicator can take display value, we need real value always
    getRawData: function(record) {
        return record.getSchedulingMode();
    },
    putRawData: function(value, record) {
        record.setSchedulingMode(value);
    }
});

/**

@class Gnt.column.Sequence
@extends Ext.grid.column.Column

A "calculated" column which displays the sequential position of the task in the project.
See {@link Gnt.model.Task#getSequenceNumber} for details.


*/
Ext.define("Gnt.column.Sequence", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.sequencecolumn",
        "widget.ganttcolumn.sequence"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    isSequenceColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - text : '#'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 40,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'right',
    sortable: false,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
    },
    renderer: function(value, meta, task) {
        return task.getSequenceNumber();
    }
});

/**

@class Gnt.column.Slack
@extends Ext.grid.column.Column

A column showing the available amount of _free slack_ for a task. The _free slack_ (or _free float_) is the amount of time that a task can be delayed
without causing a delay to any of its successors.

The slack is displayed in units specified by the {@link #slackUnit} config (by default it's displayed in _days_).


    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'slackcolumn',
                width       : 70
            }
            ...
        ],
        ...
    })

*/
Ext.define('Gnt.column.Slack', {
    extend: 'Ext.grid.column.Column',
    alternateClassName: [
        'Gnt.column.FreeSlack'
    ],
    requires: [
        'Ext.Number',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        'widget.slackcolumn',
        'widget.freeslackcolumn',
        'widget.ganttcolumn.slack'
    ],
    isFreeSlackColumn: true,
    /**
     * @cfg {Number} decimalPrecision A number of digits to show after the dot when rendering the value of the slack.
     */
    decimalPrecision: 2,
    /**
     * @cfg {Boolean} useAbbreviation When set to `true`, the column will render the abbreviated slack unit name, not full.
     * Useful if the column width is limited.
     */
    useAbbreviation: false,
    /**
     * @cfg {String} slackUnit The time unit to use when displaying the slack amount.
     */
    slackUnit: 'd',
    width: 100,
    align: 'left',
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.renderer = config.renderer || this.rendererFunc;
        this.scope = config.scope || this;
        this.hasCustomRenderer = true;
    },
    afterRender: function() {
        var panel = this.up('ganttpanel');
        // Make top Gantt panel aware of the need for refreshing locked grid after changes in the dependency store
        panel.registerLockedDependencyListeners();
        this.callParent(arguments);
    },
    getSlackValue: function(task) {
        return task.getFreeSlack(this.slackUnit);
    },
    rendererFunc: function(value, meta, task) {
        meta.tdCls = (meta.tdCls || '') + ' sch-column-readonly';
        value = this.getSlackValue(task);
        if (Ext.isNumber(value)) {
            return parseFloat(Ext.Number.toFixed(value, this.decimalPrecision)) + ' ' + Sch.util.Date[this.useAbbreviation ? 'getShortNameOfUnit' : 'getReadableNameOfUnit'](this.slackUnit, value !== 1);
        }
        return '';
    }
});

/**
 * A Column showing the successors of a task. The column is editable, however to enable the editing you will need to add a
 * Sch.plugin.TreeCellEditing plugin to your gantt panel. The overall setup will look like this:
 *
 *     var gantt = Ext.create('Gnt.panel.Gantt', {
 *         height  : 600,
 *         width   : 1000,
 *
 *         // Setup your grid columns
 *         columns : [
 *             ...
 *             {
 *                 xtype : 'successorcolumn',
 *                 width : 70
 *             }
 *             ...
 *         ],
 *
 *         plugins : [
 *             Ext.create('Sch.plugin.TreeCellEditing', {
 *                 clicksToEdit : 1
 *             })
 *         ],
 *         ...
 *     })
 *
 * This column uses a specialized field - {@link Gnt.field.Dependency} which allows the
 * user to specify multiple successors including lag. Please refer to {@link Gnt.field.Dependency}
 * documentation for the expected format when editing data in this column.
 */
Ext.define("Gnt.column.Successor", {
    extend: "Gnt.column.Dependency",
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: [
        "widget.successorcolumn",
        "widget.ganttcolumn.successor"
    ],
    isSuccessorColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text : 'Successors'
     */
    type: 'successors',
    constructor: function(config) {
        var me = this;
        config = config || {};
        me.text = config.text || me.L('text');
        me.filter = me.filter || {
            type: 'string',
            filterFn: function(task, filterValue) {
                return Boolean(Ext.Array.findBy(task.successors, function(successorDependency) {
                    var successor = successorDependency.getTargetTask();
                    return successor && filterValue == (me.useSequenceNumber ? successor.getSequenceNumber() : successor.id);
                }));
            }
        };
        me.callParent(arguments);
    },
    /**
     * Will validate and insert previously prepared predecessors data
     * @param {Object[]} data Data to insert, should be valid input for store.add method
     * @param {Gnt.model.Task} task Record being populated with this data
     */
    putRawData: function(data, task) {
        var dependencyStore = task.getDependencyStore();
        var toAdd = [];
        dependencyStore.remove(task.getOutgoingDependencies(true));
        Ext.isArray(data) && Ext.Array.each(data, function(item) {
            // check if source task exists
            if (task.getTaskStore().getById(item[dependencyStore.model.prototype.toField])) {
                var newDependency = new dependencyStore.model(item);
                newDependency.setSourceId(task.getId());
                if (dependencyStore.isValidDependency(newDependency)) {
                    toAdd.push(newDependency);
                }
            }
        });
        dependencyStore.add(toAdd);
    },
    eraseData: function(task) {
        this.putRawData([], task);
    }
});

/**
 * A "calculated" column which displays the _WBS_ (_Work Breakdown Structure_) for the tasks - the position of the task in the project tree structure.
 */
Ext.define("Gnt.column.WBS", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.wbscolumn",
        "widget.ganttcolumn.wbs"
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    isWBSColumn: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - text : 'WBS'
     */
    /**
     * @cfg {Number} width The width of the column.
     */
    width: 40,
    /**
     * @cfg {String} align The alignment of the text in the column.
     */
    align: 'left',
    sortable: false,
    constructor: function(config) {
        config = config || {};
        this.text = config.text || this.L('text');
        this.callParent(arguments);
        this.tdCls = (this.tdCls || '') + ' gnt-wbs-cell';
    },
    renderer: function(value, meta, task) {
        return task.getWBSCode();
    }
});

/**

@class Gnt.column.TotalSlack
@extends Ext.grid.column.Column

A column showing the available amount of _total slack_ for a task. The _total slack_ (or _total float_) is the amount of time that this task can be delayed without causing a delay
to the project end.

The slack is displayed in units specified by the {@link #slackUnit} config (by default it's displayed in _days_).


    var gantt = Ext.create('Gnt.panel.Gantt', {
        height      : 600,
        width       : 1000,

        // Setup your grid columns
        columns         : [
            ...
            {
                xtype       : 'totalslackcolumn',
                width       : 70
            }
            ...
        ],
        ...
    })

*/
Ext.define('Gnt.column.TotalSlack', {
    extend: 'Gnt.column.Slack',
    isTotalSlackColumn: true,
    alias: [
        'widget.totalslackcolumn',
        'widget.ganttcolumn.totalslack'
    ],
    getSlackValue: function(task) {
        return task.getTotalSlack(this.slackUnit);
    }
});

/**
 * @class Gnt.column.AddNew
 * @extends Ext.grid.column.Column
 *
 * A column allowing the user to add a new column to the Gantt chart. To include your own custom columns in this list,
 * just create an alias for them starting with 'widget.ganttcolumn.XXX'. Example:
 *
 * ```javascript
 *     Ext.define('Your.column.DeadlineDate', {
 *         extend : 'Ext.grid.column.Date',
 *
 *         alias  : [
 *             'widget.ganttcolumn.mydeadlinedate'
 *         ],
 *
 *         ...
 *     });
 * ```
 */
Ext.define("Gnt.column.AddNew", {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.addnewcolumn",
        "widget.ganttcolumn.addnew"
    ],
    requires: [
        'Ext.form.field.ComboBox',
        'Ext.Editor',
        'Sch.patches.BoundList',
        'Gnt.column.ActualCost',
        'Gnt.column.ActualEffort',
        'Gnt.column.AssignmentUnits',
        'Gnt.column.BaselineEndDate',
        'Gnt.column.BaselineCost',
        'Gnt.column.BaselineEffort',
        'Gnt.column.BaselineStartDate',
        'Gnt.column.Calendar',
        'Gnt.column.ConstraintDate',
        'Gnt.column.ConstraintType',
        'Gnt.column.Cost',
        'Gnt.column.CostVariance',
        'Gnt.column.DeadlineDate',
        'Gnt.column.Dependency',
        'Gnt.column.Duration',
        'Gnt.column.EarlyEndDate',
        'Gnt.column.EarlyStartDate',
        'Gnt.column.Effort',
        'Gnt.column.EffortVariance',
        'Gnt.column.EndDate',
        'Gnt.column.LateEndDate',
        'Gnt.column.LateStartDate',
        'Gnt.column.ManuallyScheduled',
        'Gnt.column.Milestone',
        'Gnt.column.Name',
        'Gnt.column.Note',
        'Gnt.column.PercentDone',
        'Gnt.column.Predecessor',
        'Gnt.column.ReadOnly',
        'Gnt.column.ResourceAssignment',
        'Gnt.column.ResourceName',
        'Gnt.column.Rollup',
        'Gnt.column.SchedulingMode',
        'Gnt.column.Sequence',
        /*  */
        'Gnt.column.Slack',
        'Gnt.column.StartDate',
        'Gnt.column.Successor',
        'Gnt.column.WBS',
        'Gnt.column.TotalSlack'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - text  : 'Add new column...'
     */
    width: 100,
    resizable: false,
    menuDisabled: true,
    sortable: false,
    draggable: false,
    colEditor: null,
    colEditorStore: null,
    ignoreInAddMenu: true,
    ignoreInExport: true,
    // Sencha flag for copy/paste operations
    ignoreExport: true,
    /**
     * @cfg {Array} [columnList] An array of column definition objects. It should be a list containing data as seen below
     *
     * ```json
     *      [
     *          { clsName : 'Gnt.column.StartDate', text : 'Start Date', config : {...} },
     *          { clsName : 'Gnt.column.Duration', text : 'Duration', config : {...} },
     *          ...
     *      ]
     * ```
     *
     * If not provided, a list containing all the columns from the `Gnt.column.*` namespace will be created.
     * This default list can also be retrieved by {@link #buildDefaultColumnList} static method:
     *
     * ```javascript
     *     // get default column list
     *     var columns  = Gnt.column.AddNew.buildDefaultColumnList();
     *
     *     // find Gnt.column.StartDate column entry
     *     var column   = Ext.Array.findBy(columns, function (c) { return c.clsName == 'Gnt.column.StartDate'; });
     *
     *     // set custom date format to Gnt.column.StartDate
     *     column.config    = { format : 'Y' };
     *     column.text      = 'Start year';
     *
     *     Ext.create('Gnt.panel.Gantt', {
     *         ...
     *         columns  : [
     *             ...
     *             {
     *                 xtype        : 'addnewcolumn',
     *                 // provide customized list
     *                 columnList   : columns
     *             }
     *         ]
     *     });
     * ```
     */
    columnList: null,
    initComponent: function() {
        this.addCls('gnt-addnewcolumn');
        // The text to render in the column's visibility selection menu for this column
        this.menuText = this.L('text');
        this.items = this.getColEditor();
        this.callParent(arguments);
    },
    /**
     * @protected
     */
    getColEditor: function() {
        var me = this,
            editor;
        if (!me.colEditor) {
            editor = me.colEditor = new Ext.form.field.ComboBox({
                itemId: 'addNewEditor',
                displayField: 'text',
                valueField: 'clsName',
                hideTrigger: true,
                queryMode: 'local',
                multiSelect: false,
                emptyText: me.menuText,
                listConfig: {
                    htmlEncode: true,
                    itemId: 'addNewEditorComboList',
                    minWidth: 150
                },
                store: me.getColEditorStore(),
                pickerAlign: 'tl-bl',
                // never risk that the editor appears above the column
                listeners: {
                    focus: me.onInputFocus,
                    blur: me.onFieldBlur,
                    select: me.onSelect,
                    scope: me
                }
            });
        }
        return me.colEditor;
    },
    onFieldBlur: function(field, e) {
        var picker = field.getPicker();
        var pickerNode = picker.el && picker.el.dom;
        // Clicks on scrollbar in the picker should not trigger anything
        if (!e.relatedTarget || e.relatedTarget !== pickerNode) {
            this.resetField();
        }
    },
    resetField: function() {
        this.getColEditor().store.clearFilter();
        this.getColEditor().reset();
        this.getColEditor().getPicker().refresh();
        // To update the bound list and not show stale filtered state
        this.getColEditor().collapse();
    },
    /**
     * @protected
     */
    getColEditorStore: function() {
        var me = this;
        if (!me.colEditorStore) {
            me.columnList = me.columnList || Gnt.column.AddNew.buildDefaultColumnList();
            me.colEditorStore = new Ext.data.Store({
                fields: [
                    'text',
                    'clsName',
                    'config'
                ],
                data: me.columnList,
                sorters: [
                    {
                        property: 'text',
                        direction: 'ASC'
                    }
                ]
            });
        }
        return me.colEditorStore;
    },
    /**
     * @private
     */
    onInputFocus: function(field, e) {
        // Slight delay to allow Ext JS to bring column fully into view before expanding
        // updateLayout needed for failing test 1008_add_custom. Focus messes up column layout, withou moves field on top of element
        Ext.asap(function() {
            field.expand();
        });
    },
    /**
     * @private
     */
    onSelect: function(combo, records) {
        this.resetField();
        this.getColEditor().blur();
        this.addColumn(Ext.isArray(records) ? records[0] : records);
    },
    /**
     * @protected
     */
    addColumn: function(record) {
        var me = this;
        var rec = record;
        var owner = me.up('headercontainer');
        var text = rec.get('text');
        var config = Ext.apply({}, rec.get('config'));
        var clsName = rec.get('clsName') || config.xclass || 'Ext.grid.column.Column';
        Ext.require(clsName, function() {
            config.xclass = clsName;
            config.text = text;
            config.lockable = false;
            var col = Ext.create(config);
            owner.insert(owner.items.indexOf(me), col);
        });
    },
    destroy: function() {
        this.colEditorStore && this.colEditorStore.destroy();
        this.callParent(arguments);
    },
    statics: {
        /**
         * Builds the default column list to show in the combo box picker. The list will contain all columns matching the "widget.ganttcolumn.XXX" alias.
         *
         * @return {Object[]} Returns array of objects having following properties:
         * @return {String} return.clsName  Column class name
         * @return {String} return.text     Column label
         * @return {String} return.config   (optional) Column instance configuration
         */
        buildDefaultColumnList: function() {
            var list = [];
            Ext.Array.each(Ext.ClassManager.getNamesByExpression('widget.ganttcolumn.*'), function(name) {
                var cls = Ext.ClassManager.get(name);
                if (cls && !cls.prototype.ignoreInAddMenu) {
                    list.push({
                        clsName: name,
                        text: cls.prototype.localize ? cls.prototype.localize('text') : cls.prototype.text
                    });
                }
            });
            return list.sort(function(a, b) {
                return a.text > b.text ? 1 : -1;
            });
        }
    }
});

/**
 * A column used to allow row reordering when using the SpreadSheet selection model
 *
 * ```javascript
 * var gantt = Ext.create('Gnt.panel.Gantt', {
 *     height      : 600,
 *     width       : 1000,
 *
 *     // Setup your grid columns
 *     columns         : [
 *         ...
 *         { xtype : 'dragdropcolumn' },
 *         ...
 *     ],
 *     ...
 * })
 * ```
 */
Ext.define('Gnt.column.DragDrop', {
    extend: 'Ext.grid.column.Column',
    alias: [
        'widget.dragdropcolumn',
        'widget.ganttcolumn.dragdrop'
    ],
    width: 35,
    tdCls: 'sch-gantt-column-dragdrop',
    cls: 'sch-gantt-column-dragdrop-header',
    ignoreInAddMenu: true,
    ignoreExport: true,
    ignoreInExport: true,
    sortable: false,
    resizable: false,
    hideable: false,
    menuDisabled: true,
    draggable: false,
    align: 'center',
    // private override
    processEvent: function(type) {
        return type !== 'click';
    }
});

/**

@class Gnt.column.Scale
@extends Ext.grid.column.Template

A Column used to to display a vertical coordinate axis (numeric scale). This column is used by the {@link Gnt.panel.ResourceHistogram ResourceHistogram} panel.

Usage example:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 0, 21),
        renderTo            : Ext.getBody(),
        columns             : [
            {
                flex      : 1,
                dataIndex : 'Name'
            },
            {
                xtype           : 'scalecolumn'
            }
        ]
    });

#Defining the scale

The column supports two configuration modes for the numeric scale. The first one is incremental and the second one is using a fixed set of points.

#Incremental approach

To use this approach you must define the following parameters: {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep}.
Based on them, the column will build scale points taking the {@link #scaleMin} value as a start value and the {@link #scaleMax} as the last scale point.
Values between {@link #scaleMin} and {@link #scaleMax} will be calculated as:

    valueN = scaleMin + N * scaleStep

Normally this approach is meant to be used for linear scales.

#Fixed set of points

As an option to the earlier approach, you can use the {@link #scalePoints} config. This config can be used to specify an array af scale points.
The array should contain objects describing the scale points, having the following properties:

 - `value`   Scale point value. **This property is required**.
 - `label`   Label for the scale point
 - `cls`     CSS class for corresponding scale point.

For example:

    var scaleColumn = new Gnt.column.Scale({
        scalePoints : [
            {
                value   : 0
            },
            {
                value   : 1,
                label   : 'Day',
                cls     : 'dayend'
            },
            {
                value   : 0.5
            }
        ]
    });

*/
Ext.define('Gnt.column.Scale', {
    extend: 'Ext.grid.column.Template',
    alias: 'widget.scalecolumn',
    sortable: false,
    /**
     * @cfg {Object[]} scalePoints An array of scale points. Each point should be represented as an object containing the following properties:
     *
     * - `value`   Scale point value **(required)**.
     * - `label`   Label for the scale point
     * - `cls`     CSS class for corresponding scale point.
     */
    scalePoints: null,
    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale points.
     *
     * **Also,** this value is used as the margin between the top scale line (defined by {@link #scaleMax} option) and the top border of the cell.
     */
    scaleStep: 2,
    /**
     * @cfg {Number} scaleLabelStep Defines the interval between the scale points with labels.
     * By default the scale values are used for the labels. To use custom labels please use the {@link #scalePoints} config.
     */
    scaleLabelStep: 4,
    /**
     * @cfg {Number} scaleMin Minimum scale point value.
     */
    scaleMin: 0,
    /**
     * @cfg {Number} scaleMax Maximum scale point value.
     */
    scaleMax: 24,
    width: 40,
    //availableHeight     : 48,
    scaleCellCls: 'gnt-scalecolumn',
    tpl: '<div class="gnt-scalecolumn-wrap" style="height:{scaleHeight}px;">' + '<tpl for="scalePoints">' + '<tpl if="label !== \'\'">' + '<span class="gnt-scalecolumn-label-line {cls}" style="bottom:{bottom}px"><span class="gnt-scalecolumn-label">{label}</span></span>' + '<tpl else>' + '<span class="gnt-scalecolumn-line {cls}" style="bottom:{bottom}px"></span>' + '</tpl>' + '</tpl>' + '</div>',
    initComponent: function() {
        this.tdCls = (this.tdCls || '') + ' ' + this.scaleCellCls;
        this.callParent(arguments);
    },
    onAdded: function() {
        this.callParent(arguments);
        this.setAvailableHeight(this.up('timelinegrid').rowHeight, true);
    },
    setAvailableHeight: function(height, initial) {
        this.availableHeight = height;
        // if no ready scalePoints array specified
        if (!this.scalePoints) {
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            // build scale point based on min/max/step size params
            this.scalePoints = this.buildScalePoints();
        } else // if scale points array provided
        {
            if (initial) {
                this.scalePoints.sort(function(a, b) {
                    return a.value - b.value;
                });
                this.scaleMin = this.scalePoints[0].value;
                this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
                this.scaleStep = (this.scaleMax - this.scaleMin) / 10;
            }
            this.scaleStepHeight = this.availableHeight / (this.scaleMax - this.scaleMin + this.scaleStep);
            // let's fill it with calculated coordinates
            this.updateScalePoints();
        }
    },
    defaultRenderer: function(value, meta, record) {
        var data = {
                record: Ext.apply({}, record.data, record.getAssociatedData()),
                scaleHeight: this.availableHeight,
                scalePoints: this.scalePoints
            };
        return this.tpl.apply(data);
    },
    buildScalePoints: function() {
        var minValue = this.scaleMin,
            value = minValue,
            step = this.scaleStep,
            labelStep = this.scaleLabelStep,
            stepHeight = this.scaleStepHeight,
            availableHeight = this.availableHeight,
            scaleCellCls = this.scaleCellCls,
            // additional css class for scaleMin point
            cls = scaleCellCls + '-min',
            result = [];
        // shorthand
        var makePoint = function(value, label, cls) {
                return {
                    bottom: Math.round((value - minValue) * stepHeight),
                    value: value,
                    label: label != 'undefined' ? label : '',
                    cls: cls || ''
                };
            };
        // push scale points starting from scaleMin
        while (value < this.scaleMax) {
            if (value > 0) {
                result.push(makePoint(value, value % labelStep || value === minValue ? '' : value, cls));
            }
            cls = '';
            value += step;
        }
        // push scaleMax point
        result.push(makePoint(this.scaleMax, this.scaleMax, scaleCellCls + '-max'));
        return result;
    },
    updateScalePoints: function() {
        var stepHeight = this.scaleStepHeight,
            availableHeight = this.availableHeight;
        Ext.Array.each(this.scalePoints, function(point) {
            point.bottom = Math.round(point.value * stepHeight);
        });
    }
});

/**
 * @abstract
 * Base class for constraints. Each task constraint should subclass this class.
 */
Ext.define('Gnt.constraint.Base', {
    requires: [
        'Ext.String'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    isConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "A constraint",
     *      - "Remove the constraint" : "Remove the constraint",
     *      - "Cancel the change and do nothing" : "Cancel the change and do nothing"
     */
    getId: function() {
        var alias = this.alias && this.alias[0];
        return alias && alias.split('.')[1];
    },
    /**
     * Indicates whether the constraint is satisfied or not for the provided task.
     * @param {Gnt.model.Task} task A task to check the constraint for.
     * @param {Date} [date] The constraint date (if applicable for this type of constraint).
     * @return {Boolean} `true` if the constraint is satisfied and `false` otherwise.
     */
    isSatisfied: function(task, date) {
        throw "Abstract method";
    },
    /**
     * Indicates if the constraint is applicable for the provided task.
     * The method is used by the {@link Gnt.field.ConstraintType constraint UI field} to define which constraints should be available for certain types of tasks.
     * For example {@link Gnt.constraint.MustStartOn Must start on} and {@link Gnt.constraint.MustFinishOn Must finish on} constraints can't be used for summary tasks.
     * @param {Gnt.model.Task} task Task to check the constraint applicability for.
     * @return {Boolean} `true` if the constraint is applicable and `false` otherwise.
     */
    isApplicable: function(task) {
        return true;
    },
    getResolution: function(callback, task, date) {
        var me = this,
            called = false;
        date = date || task.getConstraintDate();
        var next = function() {
                if (!called) {
                    called = true;
                    callback.apply(this, arguments);
                }
            };
        var resolution = {
                title: me.L("name"),
                task: task,
                date: date,
                constraintClassName: Ext.getClassName(me),
                resolutions: this.getResolutionOptions(next, task, date),
                getCancelActionOption: function() {
                    return this.resolutions[0];
                },
                cancelAction: function() {
                    return this.getCancelActionOption().resolve();
                },
                proceedAction: function() {
                    next();
                },
                getResolution: function(id) {
                    return Ext.Array.findBy(this.resolutions, function(item) {
                        return item.id == id;
                    });
                }
            };
        // cancelAction is default (used when no user input can be provided)
        resolution.defaultAction = resolution.cancelAction;
        var store = task.getTaskStore(true);
        // If scheduling by constraints is enabled and if the task is summary and propagating
        if (store && store.scheduleByConstraints && me.hasThisConstraintApplied(task) && task.propagating && task.childNodes.length) {
            var oldConstraintType = task.getUnprojected(task.constraintTypeField),
                oldConstraintDate = task.getUnprojected(task.constraintDateField),
                newConstraintType = task.getConstraintType(),
                newConstraintDate = task.getConstraintDate();
            // ..and the initial change was of its constraint type/date
            // we consider it a case when setting of the constraint caused its violation eventually
            // after child nodes has recalculated the parent
            if ((oldConstraintType != newConstraintType) || (!oldConstraintDate && newConstraintDate) || (oldConstraintDate && !newConstraintDate) || (oldConstraintDate - newConstraintDate)) {
                resolution.description = Ext.String.format(me.L("This action will cause a scheduling conflict"), task.getName(), me.L("name"));
            }
        }
        return resolution;
    },
    getCancelResolutionOption: function(callback, task, date) {
        date = date || task.getConstraintDate();
        var me = this;
        return {
            id: 'cancel',
            title: me.L("Cancel the change and do nothing"),
            resolve: function() {
                callback(true);
            }
        };
    },
    getRemoveConstraintResolutionOption: function(callback, task, date) {
        date = date || task.getConstraintDate();
        var me = this,
            store = task.getTaskStore(true);
        return {
            id: 'remove-constraint',
            title: Ext.String.format(me.L("Remove the constraint"), me.L("name")),
            resolve: function() {
                task.setConstraintWithoutPropagation('');
                // if scheduling by constraints is enabled and the task got hanging w/o any reason - let's pin it
                if (store.scheduleByConstraints && (task.getEarlyStartDate() < task.getStartDate())) {
                    task.pinWithoutPropagation();
                }
                callback();
            }
        };
    },
    getResolutionOptions: function(callback, task, date) {
        date = date || task.getConstraintDate();
        var me = this;
        var resolutions = [
                me.getCancelResolutionOption(callback, task, date)
            ];
        me.hasThisConstraintApplied(task) && resolutions.push(me.getRemoveConstraintResolutionOption(callback, task, date));
        return resolutions;
    },
    /**
     * @protected
     * Indicates if the constraint is able to resolve its violation automatically without notifying a user.
     * This method works together with {@link #resolve} method. It goes like this: once the Gantt detects the constraint violation
     * it first calls {@link #canResolve} and if `true` is returned it calls {@link #resolve} method that should fix the violation.
     * @param {Gnt.model.Task} task Task the constraint violation detected on.
     * @param {Date} date The constraint date (if applicable for this type of constraint).
     * @return {Boolean} `true` if the constraint can be resolved automatically.
     */
    canResolve: function(task, date) {
        return false;
    },
    /**
     * @protected
     * Resolves the constraint violation without notifying a user. The method is called if {@link #canResolve} returns `true`.
     * @param {Gnt.model.Task} task Task the constraint violation detected on.
     * @param {Date} date The constraint date (if applicable for this type of constraint).
     */
    resolve: function(task, date) {},
    /**
     * Indicates if the constraint is applied for the provided task.
     * @param {Gnt.model.Task} task Task to check the constraint for.
     * @return {Boolean} `true` if the constraint is applied.
     */
    hasThisConstraintApplied: function(task) {
        return task.getConstraintClass() === this;
    },
    /**
     * @protected
     * Returns the default constraint date value to be used when a user sets the constraint on the provided task.
     * @param {Gnt.model.Task} task Task to set the constraint on.
     * @return {Date} Default constraint date value.
     */
    getInitialConstraintDate: function(task) {
        return task.getConstraintDate();
    },
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        return date;
    },
    statics: {
        /**
         * Returns constraint instance by its type, if type is null or empty string returns null
         *
         * @param {String} type Constraint type to return instance for.
         * @return {Gnt.constraint.Base/null} Constraint class singleton
         */
        getConstraintClass: function(type) {
            var result = !Ext.isEmpty(type) && Ext.ClassManager.getByAlias('gntconstraint.' + type);
            return result || null;
        }
    }
});

/**
 * Class implementing "As late as possible" constraint.
 * The constraint schedules the task as late as possible.
 *
 * Please note, that this constraint is available only when {@link Gnt.data.TaskStore#scheduleByConstraints scheduleByConstraints} mode is enabled.
 */
Ext.define('Gnt.constraint.AsLateAsPossible', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.aslateaspossible',
    singleton: true,
    isFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "As late as possible"
     */
    getInitialConstraintDate: function() {
        return null;
    },
    isApplicable: function(task) {
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints,
            scheduleBackwards = task.getProjectScheduleBackwards(store);
        // This type of constraints is available for leaves when "scheduleByConstraints" mode is enabled
        return scheduleByConstraints && (task.isLeaf() || scheduleBackwards);
    },
    isSatisfied: function(task) {
        var endDate = task.getEndDate(),
            lateEndDate = task.getLateEndDate();
        return !endDate || !lateEndDate || endDate - lateEndDate === 0;
    },
    canResolve: function(task, date) {
        return true;
    },
    resolve: function(task) {
        task.setEndDateWithoutPropagation(task.getLateEndDate());
    },
    // The constraint is flexible and does not apply some exact restricting values
    getRestrictions: function(task) {}
});

/**
 * Class implementing "As soon as possible" constraint.
 * The constraint schedules the task as early as possible.
 *
 * Please note, that this constraint is available only when {@link Gnt.data.TaskStore#scheduleByConstraints scheduleByConstraints} mode is enabled.
 */
Ext.define('Gnt.constraint.AsSoonAsPossible', {
    extend: 'Gnt.constraint.Base',
    alias: 'gntconstraint.assoonaspossible',
    singleton: true,
    isFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "As soon as possible"
     */
    getInitialConstraintDate: function() {
        return null;
    },
    isApplicable: function(task) {
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints,
            scheduleBackwards = task.getProjectScheduleBackwards(store);
        // This type of constraints is available for leaves when "scheduleByConstraints" mode is enabled
        return scheduleByConstraints && (task.isLeaf() || !scheduleBackwards);
    },
    isSatisfied: function(task) {
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints,
            startDate = task.getStartDate(),
            earlyStartDate = task.getEarlyStartDate();
        return !scheduleByConstraints || !startDate || !earlyStartDate || startDate - earlyStartDate === 0;
    },
    canResolve: function(task, date) {
        return true;
    },
    resolve: function(task) {
        task.setStartDateWithoutPropagation(task.getEarlyStartDate());
    },
    // The constraint is flexible and does not apply some exact restricting values
    getRestrictions: function(task) {}
});

/**
 * @abstract
 */
Ext.define('Gnt.constraint.BaseEndDate', {
    extend: 'Gnt.constraint.Base',
    requires: [
        'Ext.Date',
        'Sch.util.Date'
    ],
    getDisplayableConstraintDateForFormat: function(date, format, task) {
        var taskStore = task.getTaskStore(true),
            disableDateAdjustments = taskStore && taskStore.disableDateAdjustments;
        if (!disableDateAdjustments && date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, -1);
        }
        return date;
    },
    adjustConstraintDateFromDisplayableWithFormat: function(date, format, task) {
        var taskStore = task.getTaskStore(true),
            disableDateAdjustments = taskStore && taskStore.disableDateAdjustments;
        if (!disableDateAdjustments && date && !Ext.Date.formatContainsHourInfo(format) && (date - Ext.Date.clearTime(date, true) === 0)) {
            date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1);
        }
        return date;
    },
    getInitialConstraintDate: function(task) {
        return task.getEndDate();
    }
});

/**
 * @abstract
 */
Ext.define('Gnt.constraint.BaseStartDate', {
    extend: 'Gnt.constraint.Base',
    getInitialConstraintDate: function(task) {
        return task.getStartDate();
    }
});

/**
 * Class implementing "Finish no earlier than" constraint.
 * Restricting the task to finish on or after a {@link Gnt.model.Task#ConstraintDate specified date}.
 *
 * The constraint cannot be used for a summary task.
 */
Ext.define('Gnt.constraint.FinishNoEarlierThan', {
    extend: 'Gnt.constraint.BaseEndDate',
    alias: 'gntconstraint.finishnoearlierthan',
    singleton: true,
    isSemiFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Finish no earlier than",
     *      - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isApplicable: function(task) {
        return task.get('leaf');
    },
    isSatisfied: function(task, date) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        return !date || !endDate || endDate >= date;
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints;
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to finish on {0}"),
                resolve: function() {
                    task.setEndDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            min: {
                endDate: task.getConstraintDate()
            }
        };
    }
});

/**
 * Class implementing "Finish no later than" constraint.
 * Restricting the task to finish on or before a {@link Gnt.model.Task#ConstraintDate specified date}.
 */
Ext.define('Gnt.constraint.FinishNoLaterThan', {
    extend: 'Gnt.constraint.BaseEndDate',
    alias: 'gntconstraint.finishnolaterthan',
    singleton: true,
    isSemiFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *       - "name" : "Finish no later than",
     *       - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isSatisfied: function(task, date) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        return !date || !endDate || endDate <= date;
    },
    getRemoveConstraintResolutionOption: function(callback, task, date) {
        var result = this.callParent(arguments);
        result.getTitleValues = function() {
            return [
                task.getEndDate()
            ];
        };
        return result;
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to finish on {0}"),
                resolve: function() {
                    task.setEndDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            max: {
                endDate: task.getConstraintDate()
            }
        };
    }
});

/**
 * Class implementing "Must finish on" constraint.
 * Restricting the task to finish on a {@link Gnt.model.Task#ConstraintDate specified date}.
 *
 * The constraint cannot be used for a summary task.
 */
Ext.define('Gnt.constraint.MustFinishOn', {
    extend: 'Gnt.constraint.BaseEndDate',
    alias: 'gntconstraint.mustfinishon',
    singleton: true,
    isInflexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Must finish on",
     *      - "Move the task to finish on {0}" : "Move the task to finish on {0}"
     */
    isApplicable: function(task) {
        return task.get('leaf');
    },
    isSatisfied: function(task, date) {
        var endDate = task.getEndDate();
        date = date || task.getConstraintDate();
        return !date || !endDate || (endDate.valueOf() == date.valueOf());
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints;
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to finish on {0}"),
                resolve: function() {
                    task.setEndDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRemoveConstraintResolutionOption: function(callback, task, date) {
        var result = this.callParent(arguments);
        result.getTitleValues = function() {
            return [
                task.getEndDate()
            ];
        };
        return result;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            endDate: task.getConstraintDate()
        };
    }
});

/**
 * Class implementing "Must start on" constraint.
 * Restricting the task to start on a {@link Gnt.model.Task#ConstraintDate specified date}.
 *
 * The constraint cannot be used for a summary task.
 */
Ext.define('Gnt.constraint.MustStartOn', {
    extend: 'Gnt.constraint.BaseStartDate',
    alias: 'gntconstraint.muststarton',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    isInflexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Must start on",
     *      - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isApplicable: function(task) {
        return task.get('leaf');
    },
    isSatisfied: function(task, date) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !startDate || (startDate.valueOf() == date.valueOf())
        return !date || !startDate || (startDate.valueOf() == date.valueOf());
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints;
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to start at {0}"),
                resolve: function() {
                    task.setStartDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRemoveConstraintResolutionOption: function(callback, task, date) {
        var result = this.callParent(arguments);
        result.getTitleValues = function() {
            return [
                task.getStartDate()
            ];
        };
        return result;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            startDate: task.getConstraintDate()
        };
    }
});

/**
 * Class implementing "Start no earlier than" constraint.
 * Restricting the task to start on or after a {@link Gnt.model.Task#ConstraintDate specified date}.
 */
Ext.define('Gnt.constraint.StartNoEarlierThan', {
    extend: 'Gnt.constraint.BaseStartDate',
    alias: 'gntconstraint.startnoearlierthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    isSemiFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - "name" : "Start no earlier than",
     *      - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isSatisfied: function(task, date) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        return !date || !startDate || (startDate >= date);
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints;
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to start at {0}"),
                resolve: function() {
                    task.setStartDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            min: {
                startDate: task.getConstraintDate()
            }
        };
    }
});

/**
 * Class implementing "Start no later than" constraint.
 * Restricting the task to start on or before a {@link Gnt.model.Task#ConstraintDate specified date}.
 *
 * The constraint cannot be used for a summary task.
 */
Ext.define('Gnt.constraint.StartNoLaterThan', {
    extend: 'Gnt.constraint.BaseStartDate',
    alias: 'gntconstraint.startnolaterthan',
    singleton: true,
    requires: [
        'Sch.util.Date'
    ],
    isSemiFlexibleConstraint: true,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *     - "name" : "Start no later than",
     *     - "Move the task to start at {0}" : "Move the task to start at {0}"
     */
    isApplicable: function(task) {
        return task.get('leaf');
    },
    isSatisfied: function(task, date) {
        var startDate = task.getStartDate();
        date = date || task.getConstraintDate();
        // read the following as: !date || !startDate || (startDate <= date)
        return !date || !startDate || (startDate <= date);
    },
    getResolutionOptions: function(callback, task, date) {
        var me = this,
            resolutions = me.callParent(arguments);
        // Support of the "old" constraints mode:
        // If constrainst are not used for tasks scheduling we show an option to fix
        // the task position by putting it to the constraint date manually
        var store = task.getTaskStore(true),
            scheduleByConstraints = store && store.scheduleByConstraints;
        if (!scheduleByConstraints) {
            date = date || task.getConstraintDate();
            resolutions.push({
                id: 'move-task',
                title: me.L("Move the task to start at {0}"),
                resolve: function() {
                    task.setStartDateWithoutPropagation(date, true);
                    callback();
                }
            });
        }
        return resolutions;
    },
    getRemoveConstraintResolutionOption: function(callback, task, date) {
        var result = this.callParent(arguments);
        result.getTitleValues = function() {
            return [
                task.getStartDate()
            ];
        };
        return result;
    },
    getRestrictions: function(task) {
        return this.hasThisConstraintApplied(task) && {
            max: {
                startDate: task.getConstraintDate()
            }
        };
    }
});

/**
 * A class implementing the pseudo-constraint alerting a user when moving a task
 * causes either a dependency breaking or making a dependency to not drive the task position:
 *
 * {@img gantt/images/constraint-dependency.png}
 *
 * The constraint is used when {@link Gnt.data.TaskStore#checkDependencyConstraint checkDependencyConstraint} config is set to `true`.
 */
Ext.define('Gnt.constraint.implicit.Dependency', {
    extend: 'Gnt.constraint.Base',
    singleton: true,
    requires: [
        'Ext.String'
    ],
    getId: function() {
        return 'dependency';
    },
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - 'You moved the task away'             : 'You moved the task "{2}" away from "{1}" and the two tasks are linked ({0}). As a result the link between tasks will not drive the later task position.',
     *      - 'You moved the task before'           : 'You moved the task "{2}" before "{1}" and the two tasks are linked ({0}). As a result the link cannot be honored.',
     *      - 'Remove the constraint'               : 'Remove the dependency',
     *      - depType0                              : 'Start-To-Start',
     *      - depType1                              : 'Start-To-Finish',
     *      - depType2                              : 'Finish-To-Start',
     *      - depType3                              : 'Finish-To-Finish',
     *      - 'Keep the dependency & move the task' : 'Keep the dependency & move the task at {0}'
     *
     */
    getTaskDrivingDependenciesContexts: function(task) {
        var dependenciesLimits = task.getIncomingDependenciesConstraintContext({
                ignoreParents: true,
                fetchAll: true,
                skipNonWorkingTime: true
            }),
            earlyStartDate = task.getEarlyStartDate(),
            result = [];
        if (dependenciesLimits) {
            for (var i = 0; i < dependenciesLimits.all.length; i++) {
                var limit = dependenciesLimits.all[i];
                if (limit.startDate - earlyStartDate === 0) {
                    result.push(limit);
                }
            }
        }
        return result;
    },
    canResolve: function(task, date) {
        var dependenciesLimits = this.getTaskDrivingDependenciesContexts(task),
            startDate = task.getStartDate(),
            earlyStartDate = task.getEarlyStartDate();
        // If there are multiple dependencies we don't ask user for a resolution
        return (startDate - earlyStartDate) && dependenciesLimits.length > 1 && task.isPinnable();
    },
    resolve: function(task) {
        // pin the task if possible
        task.pinWithoutPropagation();
        // place the task to its earliest allowed position
        task.setStartDateWithoutPropagation(task.getEarlyStartDate());
    },
    isSatisfied: function(task, date) {
        var dependenciesLimits = this.getTaskDrivingDependenciesContexts(task),
            taskStore = task.getTaskStore(true),
            scheduleBackwards = task.getScheduleBackwards(taskStore),
            startDate = task.getStartDate(),
            earlyStartDate = task.getEarlyStartDate();
        // Satisfied if:
        return scheduleBackwards || !startDate || // task is not scheduled
        task.isManuallyScheduled() || // task is manually scheduled
        task.isReadOnly() || // task is read only
        task.isCompleted() || // task is completed
        !dependenciesLimits.length || // task is not dependency driven
        startDate - earlyStartDate === 0;
    },
    // task is scheduled according to its early start date
    hasThisConstraintApplied: function(task) {
        return !task.isManuallyScheduled() && task.getIncomingDependencies().length;
    },
    getResolution: function(callback, task, date) {
        var me = this,
            dependenciesLimits = task.getIncomingDependenciesConstraintContext(),
            resolution = me.callParent([
                callback,
                task,
                dependenciesLimits
            ]);
        resolution.dependenciesLimits = dependenciesLimits;
        resolution.date = null;
        var dependency = dependenciesLimits.constrainingDependency,
            sourceTask = dependency.getSourceTask(),
            targetTask = dependency.getTargetTask();
        // we need to show the violated dependency info in the UI
        resolution.description = Ext.String.format(/*
            Satisfy "902_unused" test to let it know the following locales are used:
            this.L('You moved the task away')
            this.L('You moved the task before')
            */
        me.L(task.getStartDate() > dependenciesLimits.startDate ? 'You moved the task away' : 'You moved the task before'), /*
            Satisfy "902_unused" test to let it know the following locales are used:
            this.L('depType0')
            this.L('depType1')
            this.L('depType2')
            this.L('depType3')
            */
        me.L('depType' + dependency.getType()), sourceTask.getName(), targetTask.getName());
        // defaultAction is to silently resolve
        resolution.defaultAction = function() {
            me.resolve(task);
        };
        // Override the "remove constraint" option to remove the dependency instead
        // plus pin the task w/ SNET constraint to not allow it to fall back
        var taskStore = task.getTaskStore(true),
            scheduleByConstraints = taskStore && taskStore.scheduleByConstraints,
            dependencyStore = task.getDependencyStore(),
            removeOption = resolution.getResolution('remove-constraint');
        removeOption.resolve = function() {
            dependencyStore.remove(dependency);
            scheduleByConstraints && task.pinWithoutPropagation();
            callback();
        };
        if (task.getStartDate() > dependenciesLimits.startDate) {
            resolution.resolutions.push({
                id: 'pin-task',
                title: me.L('Keep the dependency & move the task'),
                getTitleValues: function() {
                    return [
                        task.getStartDate()
                    ];
                },
                resolve: function() {
                    scheduleByConstraints && task.pinWithoutPropagation();
                    callback();
                }
            });
        }
        return resolution;
    }
});

/**
 * A class implementing the pseudo-constraint alerting a user when setting a
 * "Start no later than", "Finish no later than", "Must start on" or "Must finish on" constraint
 * on a task having a predecessor (which might cause a conflict in the future):
 *
 * {@img gantt/images/constraint-potential-conflict.png}
 *
 * The constraint is used when {@link Gnt.data.TaskStore#checkPotentialConflictConstraint checkPotentialConflictConstraint} config is set to `true`.
 */
Ext.define('Gnt.constraint.implicit.PotentialConflict', {
    extend: 'Gnt.constraint.Base',
    singleton: true,
    requires: [
        'Ext.String'
    ],
    getId: function() {
        return 'potentialconflict';
    },
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     *      - 'This could result in a scheduling conflict' : 'You set a {0} constraint on the task "{1}". This could result in a scheduling conflict since the task has a predecessor.',
     *      - 'Remove the constraint'                      : 'Continue. Set the {0} constraint',
     *      - 'Replace the constraint'                     : 'Continue but avoid the conflict by using a {0} constraint instead'
     */
    isSatisfied: function(task) {
        var result = true;
        // If scheduling by constraints is enabled and if the task is summary and propagating
        if (this.hasThisConstraintApplied(task)) {
            var oldConstraintType = task.getUnprojected(task.constraintTypeField),
                newConstraintType = task.getConstraintType();
            result = !(oldConstraintType != newConstraintType && this.isConstraintTypeHandled(newConstraintType));
        }
        return result;
    },
    isConstraintTypeHandled: function(constraintType) {
        return Boolean(this.getConstraintTypeForReplacement(constraintType));
    },
    hasThisConstraintApplied: function(task) {
        var store = task.getTaskStore(true),
            scheduleBackwards = task.getProjectScheduleBackwards();
        return Boolean(store && store.scheduleByConstraints && !scheduleBackwards && task.propagating && task.getIncomingDependencies().length);
    },
    getConstraintTypeForReplacement: function(originalConstraintType) {
        var result;
        switch (originalConstraintType) {
            case 'startnolaterthan':
            case 'muststarton':
                result = 'startnoearlierthan';
                break;
            case 'finishnolaterthan':
            case 'mustfinishon':
                result = 'finishnoearlierthan';
                break;
        }
        return result;
    },
    getResolution: function(callback, task) {
        var me = this,
            resolution = me.callParent(arguments);
        // proceedAction is default (used when no user input can be provided)
        resolution.defaultAction = resolution.proceedAction;
        if (me.hasThisConstraintApplied(task)) {
            var oldConstraintType = task.getUnprojected(task.constraintTypeField),
                newConstraintType = task.getConstraintType();
            if (oldConstraintType != newConstraintType && me.isConstraintTypeHandled(newConstraintType)) {
                var constraintName = Gnt.constraint.Base.getConstraintClass(newConstraintType).L('name'),
                    removeOption = resolution.getResolution('remove-constraint');
                resolution.description = Ext.String.format(me.L('This could result in a scheduling conflict'), constraintName, task.getName());
                // "remove-constraint" will mean proceedAction since nothing to remove really
                Ext.apply(removeOption, {
                    title: Ext.String.format(me.L("Remove the constraint"), constraintName),
                    resolve: resolution.proceedAction
                });
                var constraintTypeToSuggest = me.getConstraintTypeForReplacement(task.getConstraintType()),
                    constraintNameToSuggest = Gnt.constraint.Base.getConstraintClass(constraintTypeToSuggest).L('name');
                // Put replace the dangerous constraint option before the proceed option
                Ext.Array.insert(resolution.resolutions, Ext.Array.indexOf(resolution.resolutions, removeOption), [
                    {
                        id: 'replace-constraint',
                        title: Ext.String.format(me.L("Replace the constraint"), constraintNameToSuggest),
                        resolve: function() {
                            task.setConstraintWithoutPropagation(constraintTypeToSuggest);
                            callback();
                        }
                    }
                ]);
            }
        }
        return resolution;
    }
});

/**
 * @class Gnt.model.Assignment
 *
 * This class represent a single assignment of a resource to a task in your gantt chart. It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * Field names of the model can be customized by subclassing this class. Please refer to {@link Sch.model.Customizable} for details.
 *
 * See also: {@link Gnt.column.ResourceAssignment}
 */
Ext.define('Gnt.model.Assignment', {
    extend: 'Sch.model.Assignment',
    uses: [
        'Sch.util.Date'
    ],
    customizableFields: [
        /**
         * @field EventId
         * @hide
         */
        /**
         * @field TaskId
         * The id of the task to which the resource is assigned
         */
        {
            name: 'TaskId'
        },
        /**
         * @field
         * A float value representing the percent of how much of the resource's availability that is dedicated to this task
         */
        {
            name: 'Units',
            type: 'float',
            defaultValue: 100
        }
    ],
    /**
     * @cfg {String} taskIdField The name of the {@link #TaskId field identifying the task} to which an event belongs.
     */
    taskIdField: 'TaskId',
    eventIdField: 'TaskId',
    /**
     * @cfg {String} unitsField The name of the {@link #Units field identifying the units} of this assignment.
     */
    unitsField: 'Units',
    constructor: function(data, session) {
        var me = this;
        me.eventIdField = me.taskIdField;
        me.callParent([
            data,
            session
        ]);
    },
    getEventId: function() {
        var me = this;
        return me.get(me.taskIdField);
    },
    setEventId: function(eventId) {
        var me = this;
        return me.set(me.taskIdField, eventId);
    },
    /**
     * Returns the associated task store instance
     *
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.taskStore || (this.store && this.store.getTaskStore()) || null;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Returns the units of this assignment
     *
     * @return {Number} units
     */
    getUnits: function() {
        var me = this;
        return Math.max(0, me.get(me.unitsField));
    },
    /**
     * Sets the units of this assignment
     *
     * @param {Number} value The new value for units
     */
    setUnits: function(value) {
        var me = this;
        me.set(me.unitsField, value);
    },
    /**
     * @method getTask
     * Returns the task associated with this assignment.
     * @return {Gnt.model.Task} The associated task
     */
    /** @ignore */
    getTask: function(taskStore) {
        var me = this;
        return me.getEvent(taskStore);
    },
    /**
     * @method getTaskName
     * Returns the associated task name.
     * @return {String} The associated task name.
     */
    /** @ignore */
    getTaskName: function(taskStore) {
        var task = this.getTask(taskStore);
        return task && task.getName() || '';
    },
    /**
     * Returns the effort contributed by the assigned resource to the task.
     * @param {String} unit Unit to return the effort in. Defaults to the task {@link Gnt.model.Task#EffortUnit EffortUnit} value.
     * @return {Number} Effort contributed by the assigned resource.
     */
    getEffort: function(unit, taskStore, resourceStore) {
        var me = this,
            task = me.getTask(taskStore),
            totalEffort = 0;
        // task can be unreachable when we call this method during Task identifier modification
        if (task && task.getStartDate()) {
            task.forEachAvailabilityIntervalWithResources({
                startDate: task.getStartDate(),
                endDate: task.getEndDate(),
                resources: [
                    me.getResource(resourceStore)
                ]
            }, function(intervalStartDate, intervalEndDate, currentAssignments) {
                var i, totalUnits;
                for (i in currentAssignments) {
                    totalUnits = currentAssignments[i].units;
                }
                totalEffort += (intervalEndDate - intervalStartDate) * totalUnits / 100;
            });
            totalEffort = task.getProjectCalendar().convertMSDurationToUnit(totalEffort, unit || task.getEffortUnit());
        }
        return totalEffort;
    },
    /**
     * Returns the cost based on assigned resource rates
     * @returns {Number}
     */
    getCost: function() {
        var me = this,
            resource = me.getResource(),
            cost = 0;
        // task can be unreachable when we call this method during Task identifier modification
        if (me.getTask()) {
            cost = resource.getRate() * me.getEffort(resource.getRateUnit());
        }
        return cost;
    },
    /**
     * Returns an effort which will be spent by the resource assignment designated resource on the assignment
     * designated task at the given date.
     *
     * @param {Date} date
     * @param {String} [unit]
     */
    getEffortAtDate: function(date, unit) {
        var SUD = Sch.util.Date,
            me = this,
            task = me.getTask(),
            startDate = task && task.getStartDate(),
            endDate = task && task.getEndDate(),
            resource = me.getResource(),
            totalEffort = 0;
        if (task && resource && startDate && endDate) {
            date = SUD.constrain(date, startDate, endDate);
            task.forEachAvailabilityIntervalWithResources({
                startDate: startDate,
                endDate: date,
                resources: [
                    resource
                ]
            }, function(from, till, assignments) {
                var totalUnits = 0;
                // Actually we have an object with one key, and the loop here is just to get to that key
                // since it's name is unknown
                for (var i in assignments) totalUnits = assignments[i].units;
                totalEffort += (till - from) * totalUnits / 100;
            });
            totalEffort = task.getCalendar().convertMSDurationToUnit(totalEffort, unit || task.getEffortUnit());
        }
        return totalEffort;
    }
});

/**
 * @class Gnt.data.AssignmentStore
 * @extends Schdata.AssignmentStore
 *
 * A class representing a collection of assignments between tasks in the {@link Gnt.data.TaskStore} and resources
 * in the {@link Gnt.data.ResourceStore}.
 *
 * Contains a collection of {@link Gnt.model.Assignment} records.
 */
Ext.define('Gnt.data.AssignmentStore', {
    extend: 'Sch.data.AssignmentStore',
    requires: [
        'Gnt.model.Assignment'
    ],
    model: 'Gnt.model.Assignment',
    alias: 'store.gantt_assignmentstore',
    storeId: 'assignments',
    // Overriden from Sch.data.AssignmentStore due to the logic required is handled by the Gantt codebase
    attachToEventStore: Ext.emptyFn,
    attachToResourceStore: Ext.emptyFn,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.on({
            remove: me.onRecordsRemove,
            clear: me.onRecordsRemove,
            scope: me
        });
    },
    // https://app.assembla.com/spaces/bryntum/tickets/7284
    onRecordsRemove: function(store, records) {
        var taskStore = this.eventStore || null;
        if (records && records.length) {
            Ext.Array.each(records, function(record) {
                record.taskStore = taskStore;
            });
        }
    },
    /**
     * Returns the associated task store instance.
     *
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.getEventStore();
    },
    /**
     * Sets associated task store instance.
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        return this.setEventStore(store);
    },
    /**
     * Maps over task assignments.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForTask: function(task, fn, filterFn) {
        return this.mapAssignmentsForEvent(task, fn, filterFn);
    },
    /**
     * Returns all assignments for a given task.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @return {Gnt.model.Assignment[]}
     */
    getAssignmentsForTask: function(task) {
        return this.getAssignmentsForEvent(task);
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Gnt.model.Task/Mixed} task
     */
    removeAssignmentsForTask: function(task) {
        return this.removeAssignmentsForEvent(task);
    },
    /**
     * Returns all resources assigned to a task.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @return {Gnt.model.Resource[]}
     */
    getResourcesForTask: function(task) {
        return this.getResourcesForEvent(task);
    },
    /**
     * Returns all tasks assigned to a resource
     *
     * @param {Gnt.model.Resource/Mixed} resource
     * @return {Gnt.model.Task[]}
     */
    getTasksForResource: function(resource) {
        return this.getEventsForResource(resource);
    },
    /**
     * Creates and adds an Assignment record for a given task and a resource.
     *
     * @param {Gnt.model.Task/Mixed} task The task record
     * @param {Gnt.model.Resource/Mixed} resource The resource record
     * @param {Object} [assignmentData] Additional data for the assignment record
     * @return {Gnt.model.Assignment[]} An array with the created assignment(s)
     */
    assignTaskToResource: function(task, resource, assignmentData) {
        return this.assignEventToResource(task, resource, function(assignment) {
            if (Ext.isObject(assignmentData)) {
                delete assignmentData[assignment.idProperty];
                Ext.apply(assignment.data, assignmentData);
            }
            return assignment;
        });
    },
    /**
     * Removes assignment record for a given task and a resource.
     *
     * @param {Gnt.model.Task/Mixed} task
     * @param {Gnt.model.Resource/Mixed} resource
     * @return {Gnt.model.Assignment}
     */
    unassignTaskFromResource: function(task, resource) {
        return this.unassignEventFromResource(task, resource);
    },
    /**
     * Checks whether a task is assigned to a resource.
     *
     * @param {Gnt.model.Task/Mixed} evnt
     * @param {Gnt.model.Resource/Mixed} resource
     * @param {Function} [fn] Function which will resieve assignment record if one present
     * @return {Boolean}
     */
    isTaskAssignedToResource: function(task, resource, fn) {
        return this.isEventAssignedToResource(task, resource, fn);
    },
    /**
     * Returns assignment record for given task and resource
     *
     * @param {Gnt.model.Task} event
     * @param {Gnt.model.Resource} resource
     * @return {Gnt.model.Assignment}
     */
    getAssignmentForTaskAndResource: function(task, resource) {
        return this.getAssignmentForEventAndResource(task, resource);
    }
}, function() {
    // #4904
    // @OVERRIDE 6.2.1 doesn't fire commit event
    if (Ext.getVersion().isLessThan('6.5.0')) {
        Ext.override(this, {
            commitChanges: function() {
                this.callParent(arguments);
                this.fireEvent('commit', this);
            }
        });
    }
});

/**
 * @class Gnt.data.CalendarManager
 * @extends Ext.data.TreeStore
 *
 * Class implements a central storage of all project calendars. Technically it's a collection of {@link Gnt.model.Calendar} records.
 *
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager');
 *
 * # Calendars loading
 *
 * This class is mainly designed to facilitate calendars loading/persisting. You can use both default Ext JS proxies approach:
 *
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager', {
 *         proxy : {
 *             type : 'ajax',
 *             url  : 'calendars.php'
 *         },
 *         listeners : {
 *             load : function () {
 *                 // set project calendar when all calendars get loaded
 *                 taskStore.setCalendar(123);
 *             }
 *         }
 *     });
 *
 * Or the {@link Gnt.data.CrudManager} class to load all project stores by batch:
 *
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager');
 *
 *     var taskStore = Ext.create('Gnt.data.TaskStore', {
 *         // taskStore calendar will automatically be set when calendarManager gets loaded
 *         calendarManager : calendarManager,
 *         resourceStore   : resourceStore,
 *         dependencyStore : dependencyStore,
 *         assignmentStore : assignmentStore
 *     });
 *
 *     var crudManager = Ext.create('Gnt.data.CrudManager', {
 *         taskStore       : taskStore,
 *         transport       : {
 *             load    : {
 *                 url     : 'php/read.php'
 *             },
 *             sync    : {
 *                 url     : 'php/save.php'
 *             }
 *         }
 *     });
 *
 * Each record in the store, except the root node, automatically gets linked to its {@link Gnt.data.Calendar calendar instance}
 * which can be retrieved by {@link #getCalendar} method.
 *
 *     // gets calendar instance having calendar Id equal to 'general'
 *     var calendar = calendarManager.getCalendar('general');
 *
 *     // and here we do the same using {@link Gnt.model.Calendar} {@link Gnt.model.Calendar#getCalendar getCalendar} method.
 *     calendar = calendarManager.getById('general').getCalendar();
 *
 * Please note that root node does not correspond to the project calendar (main calendar of the task store).
 * Any node can be the project calendar. See {@link #setProjectCalendar} for details.
 *
 * # Automatic calendar building
 *
 * When you add a new record to the store a new calendar is automatically gets created:
 *
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager');
 *
 *     // append new record to the calendar manager
 *     var record = calendarManager.getRoot().appendChild({
 *         leaf                : true,
 *         Name                : 'General II',
 *         DaysPerMonth        : 30,
 *         DaysPerWeek         : 7,
 *         HoursPerDay         : 24,
 *         WeekendsAreWorkdays : true,
 *         WeekendFirstDay     : 6,
 *         WeekendSecondDay    : 0,
 *         DefaultAvailability : [ '00:00-24:00' ]
 *     });
 *
 *     // get newly created calendar to calendar2 variable
 *     var calendar2 = record.getCalendar();
 *
 * # Calendar class customization
 *
 * The class that should be used to instantiate a calendar (during loading or manual adding) can be customized by the {@link #calendarClass} config:
 *
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager', {
 *         // by default we will create BusinessTime calendars
 *         calendarClass   : 'Gnt.data.calendar.BusinessTime'
 *     });
 *
 */
Ext.define('Gnt.data.CalendarManager', {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Robo.data.Store',
        'Sch.data.mixin.UniversalModelGetter'
    ],
    model: 'Gnt.model.Calendar',
    alias: 'store.calendarmanager',
    storeId: 'calendars',
    /**
     * @cfg {String} calendarClass
     * The name of a class that will be used to create calendar instances.
     * If {@link Gnt.model.Calendar.calendarClass calendarClass} field is specified on a {@link Gnt.model.Calendar record} then it will be used instead.
     */
    calendarClass: 'Gnt.data.Calendar',
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}.
     */
    calendarConfig: null,
    projectCalendar: null,
    myListeners: null,
    proxy: 'memory',
    ownedCalendars: null,
    constructor: function(config) {
        this.ownedCalendars = [];
        this.callParent(arguments);
        this.myListeners = this.on({
            idchanged: this.onChangeId,
            rootchange: this.onNewRoot,
            nodeappend: this.onNewNode,
            nodeinsert: this.onNewNode,
            noderemove: this.onRemoveNode,
            load: this.onNodesLoaded,
            destroyable: true,
            scope: this
        });
        var root = this.getRoot();
        if (root) {
            this.bindCalendars(root);
        } else {
            this.setRoot({
                expanded: true
            });
        }
    },
    destroy: function() {
        var me = this;
        me.ownedCalendars = [];
        me.myListeners.destroy();
        // Destroy any registered child calendars
        var root = me.getRoot();
        root && root.cascadeBy(function(node) {
            node.getCalendar() && me.destroyCalendar(node.calendar);
        });
        me.callParent(arguments);
    },
    onChangeId: function(store, node, oldId, newId, oldInternalId) {
        if (!(node instanceof Gnt.model.Calendar))  {
            return;
        }
        
        var calendar = this.getCalendar(oldId || oldInternalId);
        calendar.setCalendarId(newId);
    },
    onNewNode: function(parent, node) {
        if (!parent || (parent.getId() !== node.getId())) {
            // create/bind calendar for the new node and for each of its children
            this.bindCalendars(node);
            if (node !== this.getRoot()) {
                this.fixCalendarParent(node);
            }
            var me = this;
            node.cascadeBy(function(node) {
                node.setCalendarManager(me);
            });
        }
    },
    onNewRoot: function(root) {
        this.onNewNode(null, root);
        this.cleanupOwnedCalendars();
    },
    onNodesLoaded: function() {
        // we suppose that nodes are already bound at this point
        // so here we just need to drop orphan Gnt.data.Calendar instances
        this.cleanupOwnedCalendars();
    },
    destroyCalendar: function(calendar) {
        Ext.data.StoreManager.unregister(calendar);
        calendar.destroy();
        Ext.Array.remove(this.ownedCalendars, calendar);
    },
    onRemoveNode: function(parent, node, isMove) {
        if (!isMove) {
            var calendar = node.calendar;
            if (calendar) {
                this.unbindCalendarEvents(calendar);
                // if we remove the project calendar we need to reset the corresponding property and signal about that
                if (this.getProjectCalendar() == calendar) {
                    this.setProjectCalendar(null);
                }
                // if we're not in the middle of calendar manager loading
                // let's destroy the calendar instance
                if (!this.__loading) {
                    this.destroyCalendar(calendar);
                }
                node.setCalendarManager(null);
            }
        }
    },
    cleanupOwnedCalendars: function() {
        var me = this;
        if (me.ownedCalendars.length) {
            var calendars = me.ownedCalendars.slice(0);
            // loop over the calendars created by the calendar manager
            Ext.Array.each(calendars, function(calendar) {
                // if the calendar is no longer bound to some node -> destroy it
                if (!me.getNodeByCalendar(calendar))  {
                    me.destroyCalendar(calendar);
                }
                
            });
        }
    },
    suspendCalendarsEvents: function(queueSuspended) {
        var root = this.getRoot();
        root && root.cascadeBy(function(node) {
            var c = node.getCalendar();
            if (c)  {
                c.suspendEvents(queueSuspended);
            }
            
        }, this);
    },
    resumeCalendarsEvents: function() {
        var root = this.getRoot();
        root && root.cascadeBy(function(node) {
            var c = node.getCalendar();
            if (c)  {
                c.resumeEvents();
            }
            
        }, this);
    },
    getCalendarClass: function() {
        return this.calendarClass;
    },
    /**
     * Returns the project calendar.
     * @return {Gnt.data.Calendar} The project calendar.
     */
    getProjectCalendar: function() {
        return this.projectCalendar;
    },
    /**
     * Sets the project calendar.
     * @param {Gnt.data.Calendar/String} calendar The project calendar or its identifier.
     */
    setProjectCalendar: function(calendar) {
        // to avoid nested calls
        if (this.settingProjectCalendar)  {
            return;
        }
        
        if (typeof calendar !== 'object') {
            calendar = this.getCalendar(calendar) || Gnt.data.Calendar.getCalendar(calendar);
        }
        // if we assign another calendar
        if (this.getProjectCalendar() !== calendar) {
            this.settingProjectCalendar = true;
            this.projectCalendar = calendar;
            /**
             * @event projectcalendarset
             * Fires after {@link #setProjectCalendar} completion.
             * @param {Gnt.data.CalendarManager} calendarManager The calendar manager.
             * @param {Gnt.data.Calendar} calendar The calendar that was set as a project calendar.
             */
            this.fireEvent('projectcalendarset', this, calendar);
            this.settingProjectCalendar = false;
        }
    },
    /**
     * Returns the calendar instance by specified identifier.
     * @param {String} calendarId Calendar identified.
     * @return {Gnt.data.Calendar}
     */
    getCalendar: function(calendarId) {
        var record = this.getModelById(calendarId);
        return record && record.getCalendar();
    },
    /**
     * Returns the node associated with the provided calendar ({@link Gnt.data.Calendar} instance).
     * @param  {Gnt.data.Calendar} calendar Calendar instance.
     * @return {Gnt.model.Calendar}         Associated node.
     */
    getNodeByCalendar: function(calendar) {
        // only root node is supposed to not have a calendar assigned
        if (!calendar)  {
            return this.getRoot();
        }
        
        var result = this.getModelById(calendar.calendarId);
        if (!result) {
            var root = this.getRoot();
            root && root.cascadeBy(function(node) {
                var c = node.getCalendar();
                if (c === calendar) {
                    result = node;
                    return false;
                }
            }, this);
        }
        return result;
    },
    onParentChange: function(calendar, parent, oldParent) {
        var node = this.getNodeByCalendar(calendar);
        if (node && !node.syncingCalendarParent) {
            this.fixNodeParent(node);
        }
    },
    bindCalendarEvents: function(calendar) {
        /**
         * @event calendarload
         * Fires after a calendar instance was loaded.
         * @param {Gnt.data.Calendar} calendar Calendar that was loaded.
         * @param {Gnt.model.CalendarDay[]} days An array of records
         * @param {Boolean} successful True if the operation was successful.
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        this.relayEvents(calendar, [
            'load'
        ], 'calendar');
        /**
         * @event dayadd
         * Fired when a {@link Gnt.model.CalendarDay} instance has been added to a calendar.
         * @param {Gnt.data.Calendar} calendar Calendar that got new record.
         * @param {Gnt.model.CalendarDay[]} days The days that were added.
         * @param {Number} index The index at which the instances were inserted
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        /**
         * @event dayupdate
         * Fired when a {@link Gnt.model.CalendarDay} instance has been updated.
         * @param {Gnt.data.Calendar} calendar Calendar that holds the modified record.
         * @param {Gnt.model.CalendarDay} day The day record that was added.
         * @param {String} operation The update operation being performed. Value may be one of:
         *
         *  - `Ext.data.Model.EDIT`
         *  - `Ext.data.Model.REJECT`
         *  - `Ext.data.Model.COMMIT`
         * @param {String[]} modifiedFieldNames Array of field names changed during edit.
         * @param {Object} eOpts The options object passed to Ext.util.Observable.addListener.
         */
        /**
         * @event dayremove
         * Fired when a {@link Gnt.model.CalendarDay} instance has been removed from a calendar.
         *
         * **If many days may be removed in one go, then it is more efficient to listen for the {@link #event-daybulkremove} event
         * and perform any processing for a bulk remove than to listen for this {@link #event-dayremove} event.**
         * @param {Gnt.data.Calendar} calendar The calendar object.
         * @param {Gnt.model.CalendarDay} day The day record that was removed.
         * @param {Number} index The index of the day record that was removed.
         */
        /**
         * @event daybulkremove
         * Fired at the *end* of the {@link Gnt.data.Calendar#method-remove remove} method when all days in the passed array have been removed.
         *
         * If many records may be removed in one go, then it is more efficient to listen for this event
         * and perform any processing for a bulk remove than to listen for many {@link #event-dayremove} events.
         * @param {Gnt.data.Calendar} calendar The calendar object.
         * @param {Gnt.model.CalendarDay[]} days The array of days that were removed (In the order they appear in the calendar).
         * @param {Number[]} indexes The indexes of the days that were removed.
         */
        this.relayEvents(calendar, [
            'add',
            'update',
            'remove',
            'bulkremove'
        ], 'day');
        /**
         * @event calendarchange
         * Fired after calendar data has been changed (like day add, edit, remove).
         * @param {Gnt.data.Calendar} calendar The calendar object.
         */
        this.relayEvents(calendar, [
            'calendarchange'
        ]);
        calendar.on('parentchange', this.onParentChange, this);
        // we listen to relayed versions of events here since they fired before
        // original calendar add/update/remove events and we need our onDayAdd/onDayUpdate/onDayRemove to get executed
        // before gantt CRUD manager notice changes (and it listens to dayadd/dayupdate/dayremove)
        this.on({
            dayadd: this.onDayAdd,
            dayupdate: this.onDayUpdate,
            dayremove: this.onDayRemove,
            scope: this
        });
    },
    unbindCalendarEvents: function(calendar) {
        this.un({
            dayadd: this.onDayAdd,
            dayupdate: this.onDayUpdate,
            dayremove: this.onDayRemove,
            scope: this
        });
        calendar && calendar.un({
            parentchange: this.onParentChange,
            scope: this
        });
    },
    onDayAdd: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    onDayUpdate: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    onDayRemove: function(store, record) {
        this.getModelById(store.getCalendarId()).dirty = true;
    },
    fixCalendarParent: function(node) {
        if (node.syncingCalendarParent)  {
            return;
        }
        
        var parentNodeCalendar = node.parentNode.getCalendar(),
            nodeCalendar = node.getCalendar();
        if (parentNodeCalendar !== nodeCalendar.parent) {
            node.syncingCalendarParent = true;
            nodeCalendar.setParent(parentNodeCalendar);
            node.syncingCalendarParent = false;
        }
    },
    fixNodeParent: function(node) {
        var parentNodeCalendar = node.parentNode.getCalendar(),
            calendarParent = node.getCalendar().parent;
        // here we put "node" to the proper "parentNode" based on "calendar.parent"
        if (parentNodeCalendar !== calendarParent) {
            var properParentNode = this.getNodeByCalendar(calendarParent);
            properParentNode && properParentNode.appendChild(node);
        }
    },
    bindCalendar: function(record) {
        if (!record || this.getRoot() === record)  {
            return;
        }
        
        var calendar = record.getCalendar();
        var days = record.getDays();
        var id = record.getId() || record.internalId;
        days = Ext.isArray(days) && days;
        // if no calendar specified on the record or provided array of days to build new calendar
        if (!calendar || days) {
            if (!calendar) {
                // // let's try to get calendar by record identifier
                // calendar    = this.getCalendar(id);
                // // if this calendar is already bound to calendar manager
                // if (calendar) {
                //     // let's set link to it from the record
                //     record.setCalendar(calendar);
                //     return;
                // }
                // try to find calendar by record Id
                calendar = Gnt.data.Calendar.getCalendar(id);
            }
            // if we don't have the calendar registered yet
            if (!calendar) {
                // get parent calendar
                var parent = record.parentNode && record.parentNode.getCalendar();
                var calendarClass = Ext.ClassManager.get(record.getCalendarClass() || this.calendarClass);
                var calendarConfig = Ext.applyIf(record.getCalendarConfig(), {
                        data: days,
                        parent: parent
                    });
                // create calendar instance
                calendar = Ext.create(calendarClass, Ext.apply(calendarConfig, this.calendarConfig));
                this.ownedCalendars.push(calendar);
            }
            record.setCalendar(calendar);
            this.bindCalendarEvents(calendar);
        }
        // if calendar specified on the record but not registered in the calendar manager
        else if (!this.getCalendar(calendar.calendarId)) {
            // bind calendar manager listeners to it
            this.bindCalendarEvents(calendar);
        }
        /**
         * @event calendarbound
         * Fires after a calendar instance has been assigned to a record.
         * @param {Gnt.data.CalendarManager} calendarManager Calendar manager instance.
         * @param {Gnt.data.Calendar} calendar Calendar assigned to a record.
         * @param {Gnt.model.Calendar} record Record that was bound to a calendar.
         */
        this.fireEvent('calendarbound', this, calendar, record);
    },
    unbindCalendar: function(record) {
        if (!record || this.getRoot() === record)  {
            return;
        }
        
        var calendar = record.getCalendar();
        if (!calendar)  {
            return;
        }
        
        this.unbindCalendarEvents(calendar);
        this.fireEvent('calendarunbound', this, calendar, record);
    },
    bindCalendars: function(node) {
        var me = this;
        if (node) {
            Ext.Array.each([].concat(node), function(node) {
                node.cascadeBy(me.bindCalendar, me);
            });
        }
    },
    unbindCalendars: function(node) {
        var me = this;
        if (node) {
            Ext.Array.each([].concat(node), function(node) {
                node.cascadeBy(me.unbindCalendar, me);
            });
        }
    }
});

/* global Ext */
/**
 * @singleton
 */
Ext.define('Gnt.data.linearizator.CycleResolvers', function(thisClass) {
    /**
     * Doesn't resolve dependency cycle.
     *
     * @method none
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleNone() {
        return false;
    }
    /**
     * Doesn't resolve dependency cycle and throws exception.
     *
     * @method exception
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleByException() {
        Ext.Error.raise("Can't linearize dependent tasks, there's a cycle in the dependency chain!");
    }
    /**
     * Resolve a dependency cycle by cutting (forcefully marking one or more dependencies as resolved ('green')).
     *
     * @method cut
     * @member Gnt.data.linearizator.CycleResolvers
     */
    function resolveCycleByCuttingLinks$(sourceSet, depsData) {
        // The code assuming that nodes in source set form strict upward vertical hierarchy i.e. there can't be child
        // nodes missing parents but the opposite (downward) might be possible, i.e. it is possible for parent node to
        // miss children in the source set, as well as horizontal hierarchy might be lax, i.e. there might be nodes
        // whose siblings are not present in the source set.
        var sourceTree = buildSourceTreeFromSourceSet(sourceSet, depsData),
            cuts = {},
            cutsCollector = function(from, to) {
                (cuts[from] || (cuts[from] = [])).push(to);
            };
        // Folding order is the following:
        //   A
        // +-+-+
        // B C D
        //
        // B - skipped
        // C - folded with B
        // D - folded with C and then folded with A
        traverseSourceTreePostOrder(sourceTree, function foldNode$(node) {
            // First we fold a node with it's previous sibling if one exists
            if (node.prevSibling) {
                // Folding previous sibling with the node, as the result node will represent both
                // folded previous sibling and itself
                node.foldedDeps = foldDepsForNodesHorizontaly(node.prevSibling.foldedDeps, node.foldedDeps, cutsCollector);
            }
            // Next if a node is the last sibling in a parent node then we fold it with parent node
            if (!node.nextSibling && node.parentNode) {
                // Folding node with it's parent, as the result parent node will represent both
                // folded child and itself
                node.parentNode.foldedDeps = foldDepsForNodesVerticaly(node.foldedDeps, node.parentNode.foldedDeps, cutsCollector);
            }
        });
        cutCycles$(depsData.fromById, cuts);
        return true;
    }
    // --- Private functions --------------------------------------------------------------------------------------- //
    // Source set represents a set of colored nodes, which might or might not have vertical links among themselves
    // regardless of that fact we have to build a traversable tree from that linear data structure, so if a task
    // from colored node has some siblings which are not in the sources set then those siblings shouldn't be present
    // in resulting tree, same goes for children and parent nodes. Due to this node skipping we might end with several
    // nodes having no parent nodes, such nodes will be then joined together under common pseudo root node.
    function buildSourceTreeFromSourceSet(sourceSet, depsData) {
        var root,
            roots = [],
            nodes = {},
            internalId, node;
        // In this loop we transform each colored node from a source set into a tree node (an object we use
        // to represent a tree node), and collecting each transformed node for furher realization as well as each
        // root node, i.e. nodes whose parents are not in the source set, for further processing.
        for (internalId in sourceSet) {
            if (sourceSet.hasOwnProperty(internalId)) {
                node = nodes[internalId] = createRawSourceTreeNode(sourceSet[internalId].task, sourceSet, depsData);
                if (!sourceSet.hasOwnProperty(node.parentNode)) {
                    roots.push(node);
                }
            }
        }
        // In this loop we relize collected tree nodes to point to other tree nodes instead of ids.
        for (internalId in nodes) {
            if (nodes.hasOwnProperty(internalId)) {
                nodes[internalId] = realizeRawSourceTreeNode$(nodes[internalId], nodes);
            }
        }
        if (roots.length == 1) {
            root = roots[0];
        } else {
            // The data structure is the same as createRawSourceTreeNode() returns
            root = {
                parentNode: null,
                prevSibling: null,
                nextSibling: null,
                children: roots,
                foldedDeps: {}
            };
        }
        return root;
    }
    function createRawSourceTreeNode(storeNode, sourceSet, depsData) {
        var EO = Ext.Object,
            fromDeps = depsData.fromById,
            foldedDeps = {},
            internalId = storeNode.internalId,
            toIds, parentNode, nextSibling, prevSibling, children, childInternalId, childrenInternalIds, i, len;
        // We count outgoing horizontal (i.e. successors)  dependencies only, this is ok, since if we would count
        // both successors and predecessors then each successor - predecessor pair will create a direct loop
        // NOTE: It is important for following code that folded dependencies map contained node's internal id
        //       even if node has no outgoing dependencies
        toIds = EO.getKeys(fromDeps[internalId]);
        if (toIds.length) {
            foldedDeps[internalId] = toIds;
        } else {
            foldedDeps[internalId] = {};
        }
        // Vertical upward hierarchy might be either present or not, if it's present then it's present up to root
        parentNode = storeNode.parentNode && sourceSet.hasOwnProperty(storeNode.parentNode.internalId) && storeNode.parentNode.internalId;
        // Vertical downward hierarchy might be lax
        children = storeNode.childNodes || [];
        childrenInternalIds = [];
        for (i = 0 , len = children.length; i < len; i++) {
            childInternalId = children[i].internalId;
            if (sourceSet.hasOwnProperty(childInternalId)) {
                childrenInternalIds.push(childInternalId);
            }
        }
        // Horizontal hierarchy might be lax.
        prevSibling = storeNode.previousSibling;
        while (prevSibling && !sourceSet.hasOwnProperty(prevSibling.internalId)) {
            prevSibling = prevSibling.previousSibling;
        }
        prevSibling = prevSibling && prevSibling.internalId;
        nextSibling = storeNode.nextSibling;
        while (nextSibling && !sourceSet.hasOwnProperty(nextSibling.internalId)) {
            nextSibling = nextSibling.nextSibling;
        }
        nextSibling = nextSibling && nextSibling.internalId;
        // That'll be our source node
        // now it references related nodes by ids.
        // Each original node which is referenced by a task but not present in source set has been skipped
        // The resulting data structure will be further realized to reference other tree nodes instances instead of ids.
        return {
            parentNode: parentNode,
            prevSibling: prevSibling,
            nextSibling: nextSibling,
            children: childrenInternalIds,
            foldedDeps: foldedDeps
        };
    }
    function realizeRawSourceTreeNode$(node, nodes) {
        var i, len,
            children = node.children;
        for (i = 0 , len = children.length; i < len; i++) {
            children[i] = nodes[children[i]];
        }
        node.parentNode = (node.parentNode || node.parentNode === 0) && nodes[node.parentNode] || null;
        node.prevSibling = (node.prevSibling || node.prevSibling === 0) && nodes[node.prevSibling] || null;
        node.nextSibling = (node.nextSibling || node.nextSibling === 0) && nodes[node.nextSibling] || null;
        return node;
    }
    function traverseSourceTreePostOrder(branchRoot, stepFn) {
        var children = branchRoot.children,
            i, len;
        for (i = 0 , len = children.length; i < len; i++) {
            traverseSourceTreePostOrder(children[i], stepFn);
        }
        stepFn(branchRoot);
        return branchRoot;
    }
    function foldDepsForNodesHorizontaly(aDeps, bDeps, cutsCollector) {
        var crossDeps = getHorizontalCrossDeps(aDeps, bDeps),
            fromAtoB = crossDeps.fromAtoB,
            fromBtoA = crossDeps.fromBtoA,
            fromAtoBtotal = crossDeps.fromAtoBtotal,
            fromBtoAtotal = crossDeps.fromBtoAtotal,
            cuts = {};
        // A cycle is when A references some ids from B and B references some ids from A simultaneously
        if (fromAtoBtotal > 0 && fromBtoAtotal > 0) {
            cuts = fromAtoBtotal < fromBtoAtotal ? fromAtoB : fromBtoA;
        }
        // Now in cuts we have a minimal map of links to cut, collecting them
        collectCuts(cuts, cutsCollector);
        // Joining two nodes dependencies removing ones which are in cuts
        return joinDeps(aDeps, bDeps, cuts);
    }
    function foldDepsForNodesVerticaly(aDeps, bDeps, cutsCollector) {
        var EO = Ext.Object,
            crossDeps = getHorizontalCrossDeps(aDeps, bDeps),
            fromAtoB = crossDeps.fromAtoB,
            fromBtoA = crossDeps.fromBtoA,
            cuts;
        // During vertical fold all horizontal links from A to B and vise versa should be removed
        cuts = EO.merge({}, fromAtoB, fromBtoA);
        // Collecting cuts
        collectCuts(cuts, cutsCollector);
        // Joining two nodes dependencies removing ones which are in cuts
        return joinDeps(aDeps, bDeps, cuts);
    }
    function getHorizontalCrossDeps(aDeps, bDeps) {
        var EO = Ext.Object,
            EA = Ext.Array,
            aIds = EO.getKeys(aDeps),
            bIds = EO.getKeys(bDeps),
            fromAtoB = {},
            fromBtoA = {},
            fromAtoBtotal = 0,
            fromBtoAtotal = 0,
            i, len, id, toX;
        // Searching for outgoing links from A to B
        for (i = 0 , len = aIds.length; i < len; ++i) {
            id = aIds[i];
            toX = EA.intersect(bIds, aDeps[id]);
            if (toX.length) {
                fromAtoB[id] = toX;
                fromAtoBtotal += toX.length;
            }
        }
        // Searching for outgoing links from B to A
        for (i = 0 , len = bIds.length; i < len; ++i) {
            id = bIds[i];
            toX = EA.intersect(aIds, bDeps[id]);
            if (toX.length) {
                fromBtoA[id] = toX;
                fromBtoAtotal += toX.length;
            }
        }
        return {
            fromAtoB: fromAtoB,
            fromBtoA: fromBtoA,
            fromAtoBtotal: fromAtoBtotal,
            fromBtoAtotal: fromBtoAtotal
        };
    }
    function collectCuts(cuts, cutsCollector) {
        var id, i, len, toX;
        for (id in cuts) {
            if (cuts.hasOwnProperty(id)) {
                toX = cuts[id];
                for (i = 0 , len = toX.length; i < len; ++i) {
                    cutsCollector(id, toX[i]);
                }
            }
        }
    }
    function joinDeps(aDeps, bDeps, cuts) {
        var EO = Ext.Object,
            EA = Ext.Array,
            result, id;
        // Joining two nodes dependencies removing ones which are in cuts
        result = EO.merge({}, aDeps, bDeps);
        for (id in cuts) {
            if (cuts.hasOwnProperty(id) && result.hasOwnProperty(id)) {
                result[id] = EA.difference(result[id], cuts[id]);
            }
        }
        return result;
    }
    function cutCycles$(fromDeps, cuts) {
        var fromId, tos, toId, i, len;
        for (fromId in cuts) {
            if (cuts.hasOwnProperty(fromId)) {
                tos = cuts[fromId];
                for (i = 0 , len = tos.length; i < len; ++i) {
                    toId = tos[i];
                    fromDeps[fromId][toId][0] = 'green';
                }
            }
        }
        return fromDeps;
    }
    // --- Public interface ---------------------------------------------------------------------------------------- //
    return {
        singleton: true,
        'none': resolveCycleNone,
        'exception': resolveCycleByException,
        'cut': resolveCycleByCuttingLinks$
    };
});

Ext.define('Gnt.data.Linearizator', function(thisClass) {
    var walkingSpecificationsCache = {};
    // {{{ linearWalkBySpecification
    /**
     * Linearly walks source task list and it's members dependent tasks in dependency resolution order.
     *
     * @param {Gnt.model.Task|[Gnt.model.Task]} sourceTasksList
     *  Walking source points
     * @param {Function}       processorFn
     *  Function to call at each walking step
     * @param {Gnt.model.Task} processorFn.task
     *  A task which dependencies are considered to be resolved at the step
     * @param {String}         processorFn.color
     *  Task dependencies resolution state, might be either **'green'** or **'yellow'**. Leaf tasks might be visited
     *  with **'green'** color only, but parent tasks will be visited twice, first with **'yellow'** color and then,
     *  after visiting all node's **'green'** children, the node will be visited again but with **'green'** color.
     *  Parent node **'yellow'** dependencies resolution state means that all it's horizontal dependencies, i.e.
     *  dependencies from node's predecessors, has been visited (and probably processed somehow during the visit),
     *  **'green'** (for any node) means that all node's dependencies, both horizontal and vertical has been visitied
     *  (and processed).
     * @param {Object}         processorFn.sourceSet
     *  Set of all tasks involved into the walking alongside with their dependency resolution state color.
     * @param {Gnt.model.Task} processor.sourceSet.task
     *  Step task
     * @param {String}         processorFn.sourceSet.color
     *  Step color
     * @param {Object}         processorFn.depsMap
     *  **Private**. Dependecies map, this parameter is currently considered to be private.
     * @param {Object}         walkingSpec
     *  Walking specification, contains information describing how to walk and process task dependencies
     * @param {Boolean}        walkingSpec.self
     *  Whether to include tasks from source tasks list into a walking sequence
     * @param {Boolean}        walkingSpec.ancestors
     *  Whether to include tasks' ancestors into a walking sequence
     * @param {Boolean}        walkingSpec.descendants
     *  Whether to include tasks' descendants into a walking sequence
     * @param {Boolean}        walkingSpec.successors
     *  Whether to include tasks's successors into a walking sequece
     * @param {String}         walkingSpec.cycles
     *  Cycles resolution strategy. See {@link Gnt.data.linearizator.CycleResolvers} public method for possible values.
     *
     * @member Gnt.data.Linearizator
     * @method linearWalkBySpecification
     */
    function linearWalkBySpecification(sourceTasksList, processorFn, walkingSpec) {
        walkingSpec = resolveWalkingSpecification(walkingSpec);
        return linearWalk([].concat(sourceTasksList), processorFn, walkingSpec.tasksDepsCollectingFn, walkingSpec.cycleSolverFn);
    }
    // }}}
    // {{{ linearWalk
    function linearWalk(sourceTasksList, processorFn, tasksDepsCollectingFn, cycleSolverFn) {
        var done = false,
            hadCycle = true,
            tasksColorMap$, depsColorMap$, taskId, task, color;
        tasksColorMap$ = createEmptyTasksColorMap();
        depsColorMap$ = createEmptyDepsColorMap();
        collectTasksAndDepsIntoColorMaps$(sourceTasksList, tasksDepsCollectingFn, tasksColorMap$, depsColorMap$);
        while (hadCycle) {
            done = false;
            while (!done) {
                done = true;
                hadCycle = false;
                for (taskId in tasksColorMap$) {
                    if (tasksColorMap$.hasOwnProperty(taskId) && tasksColorMap$[taskId].color != 'green') {
                        task = tasksColorMap$[taskId].task;
                        color = calculateTaskColor(task, depsColorMap$);
                        if (color != 'red') {
                            setCalculatedTaskColor$(color, task, tasksColorMap$, depsColorMap$);
                            processorFn(task, color, tasksColorMap$, depsColorMap$);
                            done = false;
                        } else {
                            hadCycle = true;
                        }
                    }
                }
            }
            if (hadCycle) {
                hadCycle = cycleSolverFn && cycleSolverFn(tasksColorMap$, depsColorMap$);
            }
        }
    }
    // }}}
    // {{{ resolveWalkingSpecification
    function resolveWalkingSpecification(spec) {
        var walkingSpecificationKey = getWalkingSpecificationKey(spec),
            cycleSolverFn, tasksDepsCollectingFn, result;
        result = walkingSpecificationsCache[walkingSpecificationKey];
        if (!result) {
            cycleSolverFn = Gnt.data.linearizator.CycleResolvers[spec.cycles || 'none'];
            tasksDepsCollectingFn = [];
            spec.self && (tasksDepsCollectingFn.push(selfTasksDepsCollector$));
            spec.ancestors && (tasksDepsCollectingFn.push(ancestorsTasksDepsCollector$));
            spec.descendants && (tasksDepsCollectingFn.push(descendantsTasksDepsCollector$));
            spec.successors && (tasksDepsCollectingFn.push(successorsTasksDepsCollector$));
            spec.predecessors && (tasksDepsCollectingFn.push(predecessorsTasksDepsCollector$));
            tasksDepsCollectingFn = composeTasksDepsCollectors(tasksDepsCollectingFn);
            result = {
                tasksDepsCollectingFn: tasksDepsCollectingFn,
                cycleSolverFn: cycleSolverFn
            };
            walkingSpecificationsCache[walkingSpecificationKey] = result;
        }
        return result;
    }
    // }}}
    // {{{ getWalkingSpecificationKey
    function getWalkingSpecificationKey(spec) {
        var result = [],
            prop;
        for (prop in spec) {
            if (spec.hasOwnProperty(prop)) {
                result.push(prop, '=', String(spec[prop]));
            }
        }
        return result.join(';');
    }
    // }}}
    // {{{ composeTasksDepsCollectors
    function composeTasksDepsCollectors(collectors) {
        return function(task, tasksColorMap$, depsColorMap$) {
            var collectedTasks = [];
            Ext.Array.each(collectors, function(collectorFn) {
                collectedTasks = collectedTasks.concat(collectorFn(task, tasksColorMap$, depsColorMap$));
            });
            return collectedTasks;
        };
    }
    // }}}
    // {{{ collectTasksAndDepsIntoColorMaps$
    function collectTasksAndDepsIntoColorMaps$(tasksList, stepTasksDepsCollectorFn$, tasksMap$, depsMap$) {
        Ext.Array.each(tasksList, function(task) {
            var collectedTasks = stepTasksDepsCollectorFn$(task, tasksMap$, depsMap$);
            if (collectedTasks.length > 0) {
                collectTasksAndDepsIntoColorMaps$(collectedTasks, stepTasksDepsCollectorFn$, tasksMap$, depsMap$);
            }
        });
    }
    // }}}
    // {{{ selfTasksDepsCollector$
    function selfTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            taskId = task.internalId;
        if (!tasksColorMap$.hasOwnProperty(taskId)) {
            // Collecting task
            tasksColorMap$[taskId] = {
                task: task,
                color: 'red'
            };
            collectedTasks = [
                task
            ];
        }
        return collectedTasks;
    }
    // }}}
    // {{{ ancestorsTasksDepsCollector$
    function ancestorsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            downFromByIdMap = depsColorMap$.downFromById,
            downToByIdMap = depsColorMap$.downToById,
            upFromByIdMap = depsColorMap$.upFromById,
            upToByIdMap = depsColorMap$.upToById,
            taskId = task.internalId,
            parentTask = task.parentNode,
            parentId = parentTask && parentTask.internalId,
            downColor, upColor;
        // Collecting task
        if (parentTask && !tasksColorMap$.hasOwnProperty(parentId)) {
            tasksColorMap$[parentId] = {
                task: parentTask,
                color: 'red'
            };
            collectedTasks.push(parentTask);
        }
        // Collecting dependencies
        // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
        if (parentTask) {
            downColor = [
                'red'
            ];
            upColor = [
                'red'
            ];
            !downFromByIdMap[parentId] && (downFromByIdMap[parentId] = {});
            !downFromByIdMap[parentId][taskId] && (downFromByIdMap[parentId][taskId] = downColor);
            !downToByIdMap[taskId] && (downToByIdMap[taskId] = downColor);
            !upToByIdMap[parentId] && (upToByIdMap[parentId] = {});
            !upToByIdMap[parentId][taskId] && (upToByIdMap[parentId][taskId] = upColor);
            !upFromByIdMap[taskId] && (upFromByIdMap[taskId] = upColor);
        }
        return collectedTasks;
    }
    // }}}
    // {{{ descendantsTasksDepsCollector$
    function descendantsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            downFromByIdMap = depsColorMap$.downFromById,
            downToByIdMap = depsColorMap$.downToById,
            upFromByIdMap = depsColorMap$.upFromById,
            upToByIdMap = depsColorMap$.upToById,
            children = !task.isRoot() && task.childNodes,
            taskId = task.internalId;
        children && Ext.Array.each(children, function(childTask) {
            var childId = childTask.internalId,
                downColor, upColor;
            // Collecting tasks
            if (!tasksColorMap$.hasOwnProperty(childId)) {
                tasksColorMap$[childId] = {
                    task: childTask,
                    color: 'red'
                };
                collectedTasks.push(childTask);
            }
            // Collecting dependencies
            // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
            downColor = [
                'red'
            ];
            upColor = [
                'red'
            ];
            !downFromByIdMap[taskId] && (downFromByIdMap[taskId] = {});
            !downFromByIdMap[taskId][childId] && (downFromByIdMap[taskId][childId] = downColor);
            !downToByIdMap[childId] && (downToByIdMap[childId] = downColor);
            !upToByIdMap[taskId] && (upToByIdMap[taskId] = {});
            !upToByIdMap[taskId][childId] && (upToByIdMap[taskId][childId] = upColor);
            !upFromByIdMap[childId] && (upFromByIdMap[childId] = upColor);
        });
        return collectedTasks;
    }
    // }}}
    // {{{ successorsTasksDepsCollector$
    function successorsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            fromByIdMap = depsColorMap$.fromById,
            toByIdMap = depsColorMap$.toById,
            successors = task.getSuccessors(),
            taskId = task.internalId;
        Ext.Array.each(successors, function(successorTask) {
            var successorId = successorTask.internalId,
                color;
            // Collecting tasks
            if (!tasksColorMap$.hasOwnProperty(successorId)) {
                tasksColorMap$[successorId] = {
                    task: successorTask,
                    color: 'red'
                };
                collectedTasks.push(successorTask);
            }
            // Collecting dependencies
            // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
            color = [
                'red'
            ];
            !fromByIdMap[taskId] && (fromByIdMap[taskId] = {});
            !fromByIdMap[taskId][successorId] && (fromByIdMap[taskId][successorId] = color);
            !toByIdMap[successorId] && (toByIdMap[successorId] = {});
            !toByIdMap[successorId][taskId] && (toByIdMap[successorId][taskId] = color);
        });
        return collectedTasks;
    }
    // }}}
    // {{{ predecessorsTasksDepsCollector$
    function predecessorsTasksDepsCollector$(task, tasksColorMap$, depsColorMap$) {
        var collectedTasks = [],
            fromByIdMap = depsColorMap$.fromById,
            toByIdMap = depsColorMap$.toById,
            predecessors = task.getPredecessors(),
            taskId = task.internalId;
        Ext.Array.each(predecessors, function(predecessorTask) {
            var predecessorId = predecessorTask.internalId,
                color;
            // Collecting tasks
            if (!tasksColorMap$.hasOwnProperty(predecessorId)) {
                tasksColorMap$[predecessorId] = {
                    task: predecessorTask,
                    color: 'red'
                };
                collectedTasks.push(predecessorTask);
            }
            // Collecting dependencies
            // NOTE: if a task is collected it doesn't mean all it's directional dependencies are collected
            color = [
                'red'
            ];
            !fromByIdMap[taskId] && (fromByIdMap[taskId] = {});
            !fromByIdMap[taskId][predecessorId] && (fromByIdMap[taskId][predecessorId] = color);
            !toByIdMap[predecessorId] && (toByIdMap[predecessorId] = {});
            !toByIdMap[predecessorId][taskId] && (toByIdMap[predecessorId][taskId] = color);
        });
        return collectedTasks;
    }
    // }}}
    // {{{ createEmptyTasksColorMap
    function createEmptyTasksColorMap() {
        return {};
    }
    // }}}
    // {{{ createEmptyDepsColorMap
    function createEmptyDepsColorMap() {
        return {
            // Horizontal successor dependencies from a task
            // {
            //     taskId : {
            //         successorTaskId : [dependency color]
            //         ...
            //     }
            //     ...
            //     1 : {
            //         2 : ['red'] // the array instance is shared with toById
            //     }
            // }
            fromById: {},
            // Horizontal predecessor dependencies to a task
            // {
            //     taskId : {
            //         predecessorTaskId : [dependency color]
            //         ...
            //     }
            //     ...
            //     2 : {
            //         1 : ['red'] // the array instance is shared with fromById
            //     }
            // }
            toById: {},
            // Vertical (virtual) downward dependencies from a parent task to a children tasks
            // {
            //     parentTaskId : {
            //         childTaskId : [dependency color] // the array instance is shared with downToById
            //         ...
            //     }
            //     ...
            // }
            downFromById: {},
            // Vertical (virtual) downward dependency to a child task from a parent task
            // {
            //    childTaskId : [dependency color] // the array instance is shared with downFromById
            //    ...
            // }
            // The other participant is uniquely identified by child task parent node
            downToById: {},
            // Vertical (virtual) upward dependencies from a child task to a parent task
            // {
            //    childTaskId : [dependency color] // the array instance is shared with upToById
            //    ...
            // }
            // The other participant is uniquely identified by child task parent node
            upFromById: {},
            // Vertical (virtual) upward dependencies to a parent task from a child task
            // {
            //    parentTaskId : {
            //        childTaskId : [dependency color] // the array instance is shared with upFromById
            //        ...
            //    }
            //    ...
            // }
            upToById: {}
        };
    }
    // }}}
    // {{{ hasRedDepsTo
    function hasRedDepsTo(task, depsMap) {
        var toByIdMap = depsMap.toById[task.internalId],
            result = false,
            i;
        for (i in toByIdMap) {
            if (toByIdMap.hasOwnProperty(i) && toByIdMap[i] && toByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsFrom
    function hasRedDepsFrom(task, depsMap) {
        var fromByIdMap = depsMap.fromById[task.internalId],
            result = false,
            i;
        for (i in fromByIdMap) {
            if (fromByIdMap.hasOwnProperty(i) && fromByIdMap[i] && fromByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsDownTo
    function hasRedDepsDownTo(task, depsMap) {
        var downToByIdMap = depsMap.downToById,
            internalId = task.internalId;
        return downToByIdMap[internalId] && downToByIdMap[internalId][0] == 'red';
    }
    // }}}
    // {{{ hasRedDepsDownFrom
    function hasRedDepsDownFrom(task, depsMap) {
        var downFromByIdMap = depsMap.downFromById[task.internalId],
            result = false,
            i;
        for (i in downFromByIdMap) {
            if (downFromByIdMap.hasOwnProperty(i) && downFromByIdMap[i] && downFromByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsUpTo
    function hasRedDepsUpTo(task, depsMap) {
        var upToByIdMap = depsMap.upToById[task.internalId],
            result = false,
            i;
        for (i in upToByIdMap) {
            if (upToByIdMap.hasOwnProperty(i) && upToByIdMap[i] && upToByIdMap[i][0] == 'red') {
                result = true;
                break;
            }
        }
        return result;
    }
    // }}}
    // {{{ hasRedDepsUpFrom
    function hasRedDepsUpFrom(task, depsMap) {
        var internalId = task.internalId,
            upToByIdMap = depsMap.upToById;
        return upToByIdMap[internalId] && upToByIdMap[internalId][0] == 'red';
    }
    // }}}
    // {{{ calculateTaskColor
    function calculateTaskColor(task, depsMap) {
        var color = 'red';
        if (!hasRedDepsTo(task, depsMap) && !hasRedDepsDownTo(task, depsMap) && !hasRedDepsUpTo(task, depsMap)) {
            color = 'green';
        } else if (!hasRedDepsTo(task, depsMap) && !hasRedDepsDownTo(task, depsMap) && hasRedDepsDownFrom(task, depsMap)) {
            color = 'yellow';
        } else {
            color = 'red';
        }
        return color;
    }
    // }}}
    // {{{ setCalculatedTaskColor$
    function setCalculatedTaskColor$(color, task, tasksColorMap$, depsColorMap$) {
        var taskId = task.internalId,
            fromByIdMap = depsColorMap$.fromById[taskId],
            downFromByIdMap = depsColorMap$.downFromById[taskId],
            upFromByIdMap = depsColorMap$.upFromById[taskId],
            i;
        tasksColorMap$[taskId].color = color;
        if (color == 'green') {
            if (fromByIdMap) {
                for (i in fromByIdMap) {
                    if (fromByIdMap.hasOwnProperty(i)) {
                        fromByIdMap[i][0] = color;
                    }
                }
            }
            if (downFromByIdMap) {
                for (i in downFromByIdMap) {
                    if (downFromByIdMap.hasOwnProperty(i)) {
                        downFromByIdMap[i][0] = color;
                    }
                }
            }
            if (upFromByIdMap) {
                upFromByIdMap[0] = color;
            }
        } else if (color == 'yellow') {
            if (downFromByIdMap) {
                for (i in downFromByIdMap) {
                    if (downFromByIdMap.hasOwnProperty(i)) {
                        downFromByIdMap[i][0] = color;
                    }
                }
            }
        }
    }
    // else red and do nothing
    // }}}
    // {{{ Class descriptor
    return {
        // Class behaviour
        singleton: true,
        requires: [
            'Gnt.data.linearizator.CycleResolvers'
        ],
        // Public interface
        linearWalkBySpecification: linearWalkBySpecification
    };
});
// }}}

/**
 * This mixin adds transaction alike functionality into a model and works in pair with {@link Gnt.data.mixin.ProjectableStore}.
 * If you mix-in this class into a model, make sure you also mix-in {@link Gnt.model.mixin.ProjectableStore} into the store(s)
 * which will work with this model class.
 */
Ext.define('Gnt.model.mixin.ProjectableModel', function() {
    // Private
    function getUnprojected(fieldName) {
        return this.data[fieldName];
    }
    function getProjectionStack() {
        var me = this,
            store = me.getTreeStore && me.getTreeStore() || me.store;
        return store && store.projectionStack;
    }
    function getProjection() {
        var me = this,
            store = me.getTreeStore && me.getTreeStore() || me.store,
            projection = store && store.getProjection && store.getProjection();
        return projection && projection.hasOwnProperty(me.internalId) ? projection[me.internalId] : null;
    }
    /**
     * Checks whether the record is projected, i.e. a projection has changed values for this record.
     * @param {String} [fieldName] Field name. If provided the method will check if this specific record field is projected (the field value has been changed).
     * @return {Boolean} `true` if the record (or its specific field) has been changed.
     */
    function isProjected(fieldName, currentProjectionOnly) {
        if (typeof fieldName === 'boolean') {
            currentProjectionOnly = fieldName;
            fieldName = undefined;
        }
        var result = false,
            hasProjectedField = false;
        var projection = this.getProjection(currentProjectionOnly),
            projectionStack = getProjectionStack();
        if (projection) {
            if (fieldName) {
                hasProjectedField = currentProjectionOnly ? projection.hasOwnProperty(fieldName) : projection[fieldName];
            } else if (currentProjectionOnly && this.getProjectionStack().length > 1) {
                for (var prop in projection) {
                    if (Object.prototype.hasOwnProperty.call(projection, prop)) {
                        hasProjectedField = true;
                        break;
                    }
                }
            } else {
                hasProjectedField = true;
            }
            result = Boolean(projection && hasProjectedField);
        }
        return result;
    }
    // See the following function
    var flexSetProjectionResultContext = {
            record: null,
            projection: null,
            result: null
        };
    // This function works in pair with previous object
    var flexSetProjectionResult = Ext.Function.flexSetter(function(fieldName, value) {
            var me = this,
                record = flexSetProjectionResultContext.record,
                projection = flexSetProjectionResultContext.projection,
                result = flexSetProjectionResultContext.result,
                internalId = record.internalId,
                currentValue = record.get(fieldName),
                //me.getUnprojected(fieldName);
                prevVals = record.previousValues,
                // see https://app.assembla.com/spaces/bryntum/tickets/3676
                valueAdopted, currentValueAdopted, data;
            valueAdopted = (value !== undefined && value !== null) ? (value).valueOf() : value;
            currentValueAdopted = (currentValue !== undefined && currentValue !== null) ? (currentValue).valueOf() : currentValue;
            if (((valueAdopted === undefined || valueAdopted === null) && valueAdopted !== currentValueAdopted) || valueAdopted != currentValueAdopted) {
                data = projection[internalId] = projection.hasOwnProperty(internalId) && projection[internalId] || {};
                data[fieldName] = value;
                // see https://app.assembla.com/spaces/bryntum/tickets/3676
                (prevVals || (record.previousValues = prevVals = {}))[fieldName] = currentValue;
                result.push(fieldName);
            }
        });
    // Ext.override modifies $owner of the overridables object functions, thus we need to re-create it eachtime
    // we pass new overridables to Ext.override
    function makeOverridables() {
        var overridables = {};
        overridables.get = function get(fieldName) {
            var me = this,
                store = me.getTreeStore && me.getTreeStore() || me.store,
                projection = store && store.getProjection && store.getProjection(),
                internalId = me.internalId,
                data, value;
            if (projection && projection.hasOwnProperty(internalId)) {
                data = projection[internalId];
                if (fieldName in data) {
                    value = data[fieldName];
                } else {
                    value = me.callParent([
                        fieldName
                    ]);
                }
            } else {
                value = me.callParent([
                    fieldName
                ]);
            }
            return value;
        };
        // TODO we should probably handle 'options' object as well
        overridables.set = function set(fieldName, value, options) {
            var me = this,
                store = me.getTreeStore && me.getTreeStore() || me.store,
                projection = store && store.getProjection && store.getProjection(),
                internalId = me.internalId,
                result;
            if (projection) {
                flexSetProjectionResultContext.record = me;
                flexSetProjectionResultContext.projection = projection;
                flexSetProjectionResultContext.result = [];
                flexSetProjectionResult(fieldName, value);
                result = flexSetProjectionResultContext.result;
                flexSetProjectionResultContext.record = null;
                flexSetProjectionResultContext.result = null;
                flexSetProjectionResultContext.projection = null;
            } else {
                result = me.callParent(arguments);
            }
            return result;
        };
        return overridables;
    }
    return {
        getUnprojected: getUnprojected,
        isProjected: isProjected,
        getProjection: getProjection,
        getProjectionStack: getProjectionStack,
        onClassMixedIn: function(targetClass) {
            Ext.override(targetClass, makeOverridables());
        }
    };
});

/**

@class Gnt.model.task.More
@mixin
@protected

Internal mixin class providing additional logic and functionality belonging to the Task model class.

*/
Ext.define('Gnt.model.task.More', {
    propagating: false,
    /**
     * @propagating
     * Increases the indentation level of this task in the tree
     *
     * @param {Function} [callback] Callback function to call after task has been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    indent: function(callback) {
        var me = this,
            previousSibling = me.previousSibling,
            cancelFn;
        if (previousSibling) {
            var taskStore = me.getTaskStore();
            taskStore.beginIndent();
            me.propagateChanges(function() {
                return me.indentWithoutPropagation(function(fn) {
                    cancelFn = fn;
                });
            }, function(cancelChanges, affectedTasks) {
                if (cancelChanges || Object.keys(affectedTasks).length === 0) {
                    cancelFn && cancelFn();
                } else {
                    previousSibling.expand();
                }
                taskStore.endIndent();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            // TODO: actually an exception should be thrown here, but BC is such BC
            callback && callback(false, {});
        }
    },
    indentWithoutPropagation: function(cancelAndResultFeedback) {
        var me = this,
            previousSibling = me.previousSibling,
            result;
        if (previousSibling) {
            var removeContext = {
                    parentNode: me.parentNode,
                    previousSibling: me.previousSibling,
                    nextSibling: me.nextSibling
                };
            // we put the task as the last child of the previous sibling
            var insertAt = previousSibling.childNodes ? previousSibling.childNodes.length : 0;
            result = previousSibling.insertSubtaskWithoutPropagation(insertAt, me, cancelAndResultFeedback);
            // http://www.sencha.com/forum/showthread.php?270802-4.2.1-NodeInterface-removeContext-needs-to-be-passed-as-an-arg
            me.removeContext = removeContext;
        }
        return result;
    },
    /**
     * @propagating
     * Decreases the indentation level of this task in the tree
     * @param {Function} [callback] Callback function to call after task has been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    outdent: function(callback) {
        var me = this,
            parentNode = me.parentNode,
            cancelFn;
        if (parentNode && !parentNode.isRoot()) {
            var taskStore = me.getTaskStore();
            // need to do view refresh after indent to sync scroll between locked/normal view
            // and get rid of extra nodes
            taskStore.beginIndent();
            me.propagateChanges(function() {
                return me.outdentWithoutPropagation(function(fn) {
                    cancelFn = fn;
                });
            }, function(cancelChanges, affectedTasks) {
                cancelChanges && cancelFn && cancelFn();
                taskStore.endIndent();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            // TODO: actually an exception should be thrown here, but BC is such BC
            callback && callback(false, {});
        }
    },
    outdentWithoutPropagation: function(cancelAndResultFeedback) {
        var me = this,
            originalParent = me.parentNode,
            removeContext, result;
        if (originalParent && !originalParent.isRoot()) {
            var newParent = originalParent.parentNode,
                newNextSibling = originalParent.nextSibling;
            removeContext = {
                parentNode: originalParent,
                previousSibling: me.previousSibling,
                nextSibling: me.nextSibling
            };
            // we put the task as the last child of the previous sibling
            var insertAt = newNextSibling ? newParent.indexOf(newNextSibling) : newParent.childNodes.length;
            result = newParent.insertSubtaskWithoutPropagation(insertAt, me, cancelAndResultFeedback);
            // http://www.sencha.com/forum/showthread.php?270802-4.2.1-NodeInterface-removeContext-needs-to-be-passed-as-an-arg
            me.removeContext = removeContext;
        }
        return result;
    },
    removeInvalidDependencies: function() {
        var depStore = this.getDependencyStore(),
            deps = this.getAllDependencies();
        for (var i = 0; i < deps.length; i++) {
            if (!deps[i].isValid()) {
                depStore.remove(deps[i]);
            }
        }
    },
    removeDependenciesToParents: function(newParentNode) {
        var me = this,
            linkedTasks = me.getSuccessors().concat(me.getPredecessors());
        newParentNode.bubble(function(parent) {
            if (Ext.Array.indexOf(linkedTasks, parent) >= 0) {
                me.removeLinkToTask(parent);
            }
        });
    },
    /**
     * Returns true if the task has at least one dependency
     *
     * @return {Boolean}
     */
    hasDependencies: function() {
        return this.hasIncomingDependencies() || this.hasOutgoingDependencies();
    },
    /**
     * Returns all dependencies of this task (both incoming and outgoing)
     *
     * @return {Gnt.model.Dependency[]}
     */
    getAllDependencies: function() {
        return this.predecessors.concat(this.successors);
    },
    /**
     * Returns true if this task has at least one incoming dependency
     *
     * @return {Boolean}
     */
    hasIncomingDependencies: function() {
        return this.predecessors.length > 0;
    },
    /**
     * Returns true if this task has at least one outgoing dependency
     *
     * @return {Boolean}
     */
    hasOutgoingDependencies: function() {
        return this.successors.length > 0;
    },
    /**
     * Returns all incoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#predecessors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case.
     *
     * @return {Gnt.model.Dependency[]}
     */
    getIncomingDependencies: function(doNotClone) {
        return doNotClone ? this.predecessors : this.predecessors.slice();
    },
    getParentsOutgoingDependencies: function(parentNode) {
        var parent = this.parentNode,
            result = [],
            toAppend;
        while (parent) {
            // provided parentNode restricts to take into account dependencies from only its descendants
            if (parentNode) {
                toAppend = Ext.Array.filter(parent.getOutgoingDependencies(true), function(dependency) {
                    var task = dependency.getTargetTask();
                    return task && task.isAncestor(parentNode);
                });
            } else {
                toAppend = parent.getOutgoingDependencies(true);
            }
            result = result.concat(toAppend);
            parent = parent.parentNode;
        }
        return result;
    },
    getParentsIncomingDependencies: function(parentNode) {
        var parent = this.parentNode,
            result = [],
            toAppend;
        while (parent) {
            // provided parentNode restricts to take into account dependencies from only its descendants
            if (parentNode) {
                toAppend = Ext.Array.filter(parent.getIncomingDependencies(true), function(dependency) {
                    var sourceTask = dependency.getSourceTask();
                    return sourceTask && sourceTask.isAncestor(parentNode);
                });
            } else {
                toAppend = parent.getIncomingDependencies(true);
            }
            result = result.concat(toAppend);
            parent = parent.parentNode;
        }
        return result;
    },
    /**
     * Returns all outcoming dependencies of this task
     *
     * @param {Boolean} [doNotClone=false] Whether to **not** create a shallow copy of the underlying {@link Gnt.model.Task#successors} property.
     * Passing `true` is more performant, but make sure you don't modify the array in this case.
     *
     * @return {Gnt.model.Dependency[]}
     */
    getOutgoingDependencies: function(doNotClone) {
        return doNotClone ? this.successors : this.successors.slice();
    },
    scheduleByEarlyDates: function(options) {
        options = options || {};
        // if the task has no duration we set it to 1 duration unit
        if (!Ext.isNumber(this.getDuration())) {
            this.set(this.durationField, 1);
        }
        var earlyStart = this.getEarlyStartDate(options),
            earlyEnd = this.getEarlyEndDate(options),
            currentCascadeBatch = options.currentCascadeBatch,
            result = false;
        // If the task calculated position differs the current one
        if ((earlyStart && earlyStart - this.getStartDate() !== 0) || (earlyEnd && earlyEnd - this.getEndDate() !== 0)) {
            currentCascadeBatch && currentCascadeBatch.addAffected(this);
            this.setStartEndDateWithoutPropagation(earlyStart, earlyEnd, false);
            result = true;
        }
        return result;
    },
    scheduleByLateDates: function(options) {
        options = options || {};
        // if the task has no duration we set it to 1 duration unit
        if (!Ext.isNumber(this.getDuration())) {
            this.set(this.durationField, 1);
        }
        var lateStart = this.getLateStartDate(options),
            lateEnd = this.getLateEndDate(options),
            currentCascadeBatch = options.currentCascadeBatch,
            result = false;
        // If the task calculated position differs the current one
        if ((lateStart && lateStart - this.getStartDate() !== 0) || (lateEnd && lateEnd - this.getEndDate() !== 0)) {
            currentCascadeBatch && currentCascadeBatch.addAffected(this);
            this.setStartEndDateWithoutPropagation(lateStart, lateEnd, false);
            result = true;
        }
        return result;
    },
    getScheduleBackwards: function(taskStore) {
        taskStore = taskStore || this.getTaskStore(true);
        // We schedule backwards ...
        switch (this.getConstraintType()) {
            // if ASAP constraint cannot be applied at the moment
            case 'assoonaspossible':
                return !this.areEarlyDatesAvailable();
            // if ALAP constraint can be applied at the moment
            case 'aslateaspossible':
                return this.areLateDatesAvailable();
        }
        return this.getProjectScheduleBackwards(taskStore);
    },
    scheduleWithoutPropagation: function(options) {
        options = options || {};
        var result = false;
        // reset "needsRescheduling" flag if it was set
        this.isMarkedForRescheduling() && this.unmarkForRescheduling();
        var taskStore = options.taskStore = options.taskStore || this.getTaskStore(true);
        // we don't affect the task by incoming dependencies if it's either:
        //  - a manually scheduled task
        //  - a read only task
        if (taskStore && !this.isProject && !this.isManuallyScheduled() && !this.isCompleted() && !this.isReadOnly()) {
            // By default we use deep scan which provides correct results but is more "expensive"
            if (typeof options.shallow !== 'boolean') {
                options.shallow = !taskStore.scheduleByConstraints;
            }
            // Let's decide how we should scheduled the tasks either ASAP or ALAP
            // depending on the task and taskStore settings
            if (this.getScheduleBackwards(taskStore)) {
                result = this.scheduleByLateDates(options);
            } else {
                result = this.scheduleByEarlyDates(options);
            }
        }
        return result;
    },
    schedule: function(options, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.scheduleWithoutPropagation(options);
        }, callback, true);
    },
    /**
     * @private
     * Internal method, called recursively to query for the longest duration of the chain structure
     * @return {Gnt.model.Task[]} chain An array forming a chain of linked tasks
     */
    getCriticalPaths: function() {
        var toProcess = [
                this
            ],
            cPath = [
                [
                    this
                ]
            ],
            task;
        while (task = toProcess.shift()) {
            var dependencies = task.getIncomingDependencies(),
                criticalPredecessors = [];
            for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i],
                    predecessor = dependency.getSourceTask();
                if (predecessor.isCritical() && dependency.isCritical(dependency)) {
                    criticalPredecessors.push(predecessor);
                }
            }
            if (criticalPredecessors.length) {
                toProcess = toProcess.concat(criticalPredecessors);
                cPath.push(criticalPredecessors);
            }
        }
        return cPath;
    },
    /**
     * @propagating
     * Adds the passed task to the collection of child tasks.
     * @param {Gnt.model.Task} subtask The new subtask
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} The added subtask task
     */
    addSubtask: function(subtask, callback) {
        var me = this;
        return me.insertSubtask(me.childNodes ? me.childNodes.length : 0, subtask, callback);
    },
    /**
     * @propagating
     * Inserts the passed task to the collection of child tasks at the given index.
     * @param {Integer} index Tne new subtask index
     * @param {Gnt.model.Task} subtask The new subtask
     * @param {Function} [callback] Callback function to call after task has been inserted and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} The inserted subtask
     */
    insertSubtask: function(index, subtask, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.insertSubtaskWithoutPropagation(index, subtask, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    insertSubtaskWithoutPropagation: function(index, subtask, cancelAndResultFeedback) {
        var me = this,
            originalParent, originalIndex, propagationSources, wasLeaf, segments;
        originalParent = subtask.parentNode;
        originalIndex = originalParent && originalParent.indexOf(subtask);
        wasLeaf = me.get('leaf');
        subtask = me.insertChild(index, subtask);
        // Subtask might exist in the tree and implementer can decide it's not movable
        if (!subtask) {
            return [];
        }
        if (wasLeaf) {
            segments = me.getSegments();
            me.markAsParent();
        }
        me.expand();
        // since subtask gets into a new inherited constraints setup it needs rescheduling
        subtask.markForRescheduling();
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            if (originalParent) {
                originalParent.insertChild(originalIndex, subtask);
            } else {
                me.removeChild(subtask);
            }
            wasLeaf && me.set('leaf', true);
            wasLeaf && segments && me.setSegmentsWithoutPropagation(segments);
        }, subtask);
        // Changes propagation will be collected using affected parents as the source points
        if (!originalParent) {
            propagationSources = subtask;
        } else if (me !== originalParent && me.getTaskStore(true) === originalParent.getTaskStore(true)) {
            propagationSources = [
                subtask,
                originalParent
            ];
        }
        return propagationSources;
    },
    /**
     * @propagating
     * Constraints aware removes the passed subtask from this task child nodes.
     *
     * @param {Gnt.model.Task} [subtask] The subtask to remove
     * @param {Function} [callback] Callback function to call after the subtask has been removed and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    removeSubtask: function(subtask, callback) {
        var me = this,
            cancelFn;
        // if the subtask is already removed then we have nothing to do
        if (me.indexOf(subtask) !== -1) {
            me.propagateChanges(function() {
                return me.removeSubtaskWithoutPropagation(subtask, function cancelFeedback(fn) {
                    cancelFn = fn;
                });
            }, function onPropagationComplete(cancelChanges, affectedTasks) {
                cancelChanges && cancelFn && cancelFn();
                callback && callback(cancelChanges, affectedTasks);
            });
        } else {
            callback && callback(false, {});
        }
    },
    removeSubtaskWithoutPropagation: function(subtask, cancelFeedback) {
        var me = this,
            indexOfSubtask = me.indexOf(subtask),
            subtree, dependencyStore, assignmentStore, dependencies, assignments, dependenciesIndices, assignmentsIndices, i, len, r;
        dependencyStore = me.getDependencyStore();
        assignmentStore = me.getAssignmentStore();
        dependencies = subtask.getAllDependencies();
        assignments = assignmentStore && subtask.getAssignments();
        subtree = [];
        dependenciesIndices = [];
        assignmentsIndices = [];
        // Collecting all the descendants of the subtask.
        subtask.cascadeBy(function(node) {
            subtree.push(node);
        });
        // Collecting dependencies and assignments of the subtree
        for (i = 0 , len = subtree.length; (dependencyStore || assignmentStore) && i < len; i++) {
            r = subtree[i];
            dependencyStore && (dependencies = dependencies.concat(r.getAllDependencies()));
            assignmentStore && (assignments = assignments.concat(r.getAssignments()));
        }
        // Sorting dependencies in index order for future restoration
        dependencies = dependencyStore && Ext.Array.unique(dependencies);
        dependencies = dependencyStore && Ext.Array.sort(dependencies, function(a, b) {
            return dependencyStore.indexOf(a) < dependencyStore.indexOf(b) ? -1 : 1;
        });
        // 0 is not an option here
        // Collecting dependencies indices
        for (i = 0 , len = dependencies && dependencies.length; dependencyStore && i < len; i++) {
            dependenciesIndices.push(dependencyStore.indexOf(dependencies[i]));
        }
        // Sorting assignments in index order for future restoration
        assignments = assignmentStore && Ext.Array.sort(assignments, function(a, b) {
            return assignmentStore.indexOf(a) < assignmentStore.indexOf(b) ? -1 : 1;
        });
        // 0 is not an option here
        // Collecting assignments indicies
        for (i = 0 , len = assignments && assignments.length; assignmentStore && i < len; i++) {
            assignmentsIndices.push(assignmentStore.indexOf(assignments[i]));
        }
        // It's important to remove subtask/subtree first. If we will remove assignments/dependencies first then
        // subtree tasks might be adjusted and such adjustments might envolve pricy calculations which then will be
        // made void by removing a task they affecting.
        // Removing subtask (which will remove subtree as well)
        subtask = me.removeChild(subtask);
        // Removing all assignments
        assignmentStore && assignmentStore.remove(assignments);
        // Removing all dependencies
        dependencyStore && dependencyStore.remove(dependencies);
        // Converting self to leaf if required
        if (me.childNodes.length === 0 && me.convertEmptyParentToLeaf) {
            me.set('leaf', true);
        }
        cancelFeedback && cancelFeedback(function() {
            // Restoring everything back
            me.insertChild(indexOfSubtask, subtask);
            for (i = 0 , len = assignments && assignments.length; assignmentStore && i < len; i++) {
                assignmentStore.insert(assignmentsIndices[i], assignments[i]);
            }
            for (i = 0 , len = dependencies && dependencies.length; dependencyStore && i < len; i++) {
                dependencyStore.insert(dependenciesIndices[i], dependencies[i]);
            }
        });
        return me;
    },
    /**
     * @propagating
     * Adds the passed task as a successor and creates a new Finish-To-Start dependency between the two tasks.
     * @param {Gnt.model.Task} [successor] The new successor
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the successor task
     */
    addSuccessor: function(successor, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.addSuccessorWithoutPropagation(successor, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    addSuccessorWithoutPropagation: function(successor, cancelAndResultFeedback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            sources = [],
            insertCancelFn, linkCancelFn;
        successor = successor || new me.self();
        // TODO: similar code is executed during propagation so we might want to remove this ..as long as
        // we use this method followed (or wrapped) by propagation
        if (me.getEndDate()) {
            successor.beginEdit();
            var calendar = successor.getOwnCalendar() || me.getProjectCalendar();
            // preserve provided "successor" duration
            if (!Ext.isNumber(successor.getDuration())) {
                successor.set(me.durationField, 1);
            }
            if (successor.isUnscheduled()) {
                successor.set(me.startDateField, calendar.skipNonWorkingTime(me.getEndDate()));
                if (!successor.getEndDate()) {
                    successor.set(me.endDateField, calendar.calculateEndDate(me.getEndDate(), successor.getDuration(), successor.getDurationUnit()));
                }
            }
            successor.endEdit();
        } else // if the task is not scheduled yet we need it to be processed in the propagation
        // (the task will be marked as needing re-scheduling in the linkToWithoutPropagation() call)
        {
            sources = [
                me
            ];
        }
        sources = Ext.Array.merge(sources, // adding successor below
        parentNode.insertSubtaskWithoutPropagation(index + 1, successor, function(fn, result) {
            insertCancelFn = fn;
            successor = result;
        }), // and link the task to the added successor
        me.linkToWithoutPropagation(successor, Gnt.model.Dependency.Type.EndToStart, function(fn) {
            linkCancelFn = fn;
        }));
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            linkCancelFn();
            insertCancelFn();
        }, successor);
        // return propagation sources
        return sources;
    },
    /**
     * @propagating
     * Adds the passed task as a milestone below this task.
     * @param {Gnt.model.Task} milestone (optional) The milestone
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the new milestone.
     */
    addMilestone: function(milestone, callback) {
        var me = this,
            date = me.getEndDate();
        if (!milestone) {
            milestone = new me.self();
        } else if (Ext.isObject(milestone) && !(milestone instanceof Gnt.model.Task)) {
            milestone = new me.self(milestone);
        }
        if (date && !milestone.isMilestone()) {
            milestone.calendar = milestone.calendar || me.getCalendar();
            milestone.setStartEndDate(date, date);
        }
        return me.addTaskBelow(milestone, callback);
    },
    /**
     * @propagating
     * Adds the passed task as a predecessor and creates a new dependency between the two tasks.
     * @param {Gnt.model.Task} [predecessor] The new predecessor
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the new predecessor
     */
    addPredecessor: function(predecessor, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.addPredecessorWithoutPropagation(predecessor, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    addPredecessorWithoutPropagation: function(predecessor, cancelAndResultFeedback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            sources = [],
            insertCancelFn, linkCancelFn;
        predecessor = predecessor || new me.self();
        if (me.getStartDate()) {
            predecessor.beginEdit();
            // preserve provided "predecessor" duration
            if (!Ext.isNumber(predecessor.getDuration())) {
                predecessor.set(me.durationField, 1);
            }
            if (predecessor.isUnscheduled()) {
                var calendar = predecessor.getOwnCalendar() || me.getProjectCalendar();
                predecessor.set(me.startDateField, calendar.calculateStartDate(me.getStartDate(), predecessor.getDuration(), predecessor.getDurationUnit()));
                predecessor.set(me.endDateField, calendar.skipNonWorkingTime(me.getStartDate()));
            }
            predecessor.endEdit();
        } else // if the task is not scheduled yet we need it to be processed in the propagation
        // (the task will be marked as needing re-scheduling in the linkToWithoutPropagation() call)
        {
            sources = [
                me
            ];
        }
        sources = Ext.Array.merge(sources, // add predecessor
        parentNode.insertSubtaskWithoutPropagation(index, predecessor, function(fn, result) {
            insertCancelFn = fn;
            predecessor = result;
        }), // ... and link it to the task
        predecessor.linkToWithoutPropagation(me, Gnt.model.Dependency.Type.EndToStart, function(fn) {
            linkCancelFn = fn;
        }));
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            linkCancelFn();
            insertCancelFn();
        }, predecessor);
        // return propagation sources
        return sources;
    },
    /**
     * Returns all the successor tasks of this task
     *
     * @return {Gnt.model.Task[]}
     */
    getSuccessors: function() {
        var deps = this.successors,
            res = [];
        for (var i = 0,
            len = deps.length; i < len; i++) {
            var task = deps[i].getTargetTask(this.getTaskStore());
            if (task)  {
                res.push(task);
            }
            
        }
        return res;
    },
    /**
     * Returns all the predecessor tasks of a this task.
     *
     * @return {Gnt.model.Task[]}
     */
    getPredecessors: function() {
        var deps = this.predecessors,
            res = [];
        for (var i = 0,
            len = deps.length; i < len; i++) {
            var task = deps[i].getSourceTask(this.getTaskStore());
            if (task)  {
                res.push(task);
            }
            
        }
        return res;
    },
    /**
     * @propagating
     * Adds the passed task (or creates a new task) before itself.
     * @param {Gnt.model.Task/Object} [task] The task to add (or its configuration).
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskAbove: function(task, callback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me),
            compatResult, cancelFn;
        task = task || new me.self();
        me.propagateChanges(function() {
            return parentNode.insertSubtaskWithoutPropagation(index, task, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    /**
     * @propagating
     * Adds the passed task (or creates a new task) after itself
     * @param {Gnt.model.Task} task (optional) The task to add
     * @param {Function} [callback] Callback function to call after task has been added and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @return {Gnt.model.Task} the newly added task
     */
    addTaskBelow: function(task, callback) {
        var me = this,
            parentNode = me.parentNode,
            index = parentNode.indexOf(me) + 1,
            compatResult, cancelFn;
        task = task || new me.self();
        me.propagateChanges(function() {
            return parentNode.insertSubtaskWithoutPropagation(index, task, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    // Returns true if this task model is 'above' the passed task model
    isAbove: function(otherTask) {
        var me = this,
            minDepth = Math.min(me.data.depth, otherTask.data.depth);
        var current = this;
        // Walk upwards until tasks are on the same level
        while (current.data.depth > minDepth) {
            current = current.parentNode;
            if (current == otherTask)  {
                return false;
            }
            
        }
        while (otherTask.data.depth > minDepth) {
            otherTask = otherTask.parentNode;
            if (otherTask == me)  {
                return true;
            }
            
        }
        // At this point, depth of both tasks should be identical.
        // Walk up to find common parent, to be able to compare indexes
        while (otherTask.parentNode !== current.parentNode) {
            otherTask = otherTask.parentNode;
            current = current.parentNode;
        }
        return otherTask.data.index > current.data.index;
    },
    /**
     * Cascades the children of a task. The given function is not called for this node itself.
     * @param {Function} fn The function to call for each child
     * @param {Object} scope The 'this' object to use for the function, defaults to the current node.
     */
    cascadeChildren: function(fn, scope) {
        var me = this;
        if (me.isLeaf())  {
            return;
        }
        
        var childNodes = this.childNodes;
        for (var i = 0,
            len = childNodes.length; i < len; i++) childNodes[i].cascadeBy(fn, scope);
    },
    /**
     * Returns whether the task is critical or not.
     * The task is __critical__ if there is zero or less than zero {@link #getTotalSlack total slack}.
     * This means that if the task is delayed, successor tasks and the project finish date are delayed.
     * @return {Boolean} Returns `true` if the task is critical and `false` if it's not.
     */
    isCritical: function() {
        return this.getTotalSlack() <= 0;
    },
    /**
     * Returns the _start slack_ of this task.
     * The _start slack_ is calculated as the duration between
     * the {@link #getEarlyStartDate Early Start} and {@link #getLateStartDate Late Start} dates.
     * The value is used to calculate _total slack_.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _start slack_ of this task.
     */
    getStartSlack: function(unit) {
        return this.calculateStartSlack({
            unit: unit
        });
    },
    calculateSlackByDates: function(earlyDate, lateDate, unit) {
        var taskStore = this.getTaskStore(true),
            result;
        // is the task doesn't belong to a task store we cannot calculate its slack
        if (taskStore && earlyDate && lateDate) {
            var sign = 1;
            // flip dates if needed
            if (earlyDate > lateDate) {
                var tmp = earlyDate;
                earlyDate = lateDate;
                lateDate = tmp;
                sign = -1;
            }
            // slack takes into account only working period of time
            result = this.getCalendar().calculateDuration(earlyDate, lateDate, unit || Sch.util.Date.DAY);
            if (result)  {
                result *= sign;
            }
            
        }
        return result;
    },
    calculateStartSlack: function(options) {
        options = options || {};
        options.limitByConstraints = options.limitByConstraints === true;
        return this.calculateSlackByDates(this.getEarlyStartDate(options), this.getLateStartDate(options), options.unit);
    },
    /**
     * Returns the _end slack_ of this task.
     * The _end slack_ is calculated as the duration between
     * the {@link #getEarlyEndDate Early End} and {@link #getLateEndDate Late End} dates.
     * The value is used to calculate _total slack_.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _end slack_ of this task.
     */
    getEndSlack: function(unit) {
        return this.calculateEndSlack({
            unit: unit
        });
    },
    calculateEndSlack: function(options) {
        options = options || {};
        options.limitByConstraints = options.limitByConstraints === true;
        return this.calculateSlackByDates(this.getEarlyEndDate(options), this.getLateEndDate(options), options.unit);
    },
    calculateSlack: function(options) {
        options = options || {};
        var store = this.getTaskStore(true),
            result;
        // is the task doesn't belong to a task store we cannot calculate its slack
        if (store) {
            var startSlack = this.calculateStartSlack(options),
                // for summary tasks start slack might differ from the end slack value
                endSlack = this.isLeaf() ? startSlack : this.calculateEndSlack(options);
            result = Math.min(startSlack, endSlack);
        }
        return result;
    },
    /**
     * Returns the _total slack_ (or _total float_) of this task.
     * The _total slack_ is the amount of time that this task can be delayed without causing a delay
     * to the project end.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _total slack_ of this task.
     */
    getTotalSlack: function(unit) {
        return this.calculateSlack({
            unit: unit || Sch.util.Date.DAY
        });
    },
    /**
     * Returns the _free slack_ (or _free float_) of this task.
     * The _free slack_ is the amount of time that this task can be delayed without causing a delay
     * to any of its successors.
     *
     * @param {String} unit The time unit used to calculate the slack.
     * @return {Number} The _free slack_ of this task.
     */
    getFreeSlack: function(unit) {
        unit = unit || Sch.util.Date.DAY;
        var me = this,
            taskStore = me.getTaskStore(true),
            result;
        if (taskStore) {
            // Academic definition of Free Slack is something like: duration between successors minimal early start (ES) and the task early finish (EF).
            // Which is really far from the real life. It doesn't cover constraints, summary tasks, dufferent dependency types etc.
            var maxAllowedByConstraints, constraintLimits;
            if (taskStore.scheduleByConstraints && (constraintLimits = me.getInheritedConstraintRestrictions({
                translateTo: 'endDate'
            }))) {
                // "Must start/finish on" is used which means the task cannot be moved - so slack is zero
                if (constraintLimits.startDate || constraintLimits.endDate) {
                    return 0;
                }
                // if there is a late position limitation
                else if (constraintLimits.max) {
                    maxAllowedByConstraints = constraintLimits.max.endDate;
                }
            }
            var options = {
                    skipNonWorkingTime: false,
                    limitByConstraints: false
                },
                endDate = me.getEndDate();
            // make sure we have a date to calculate based on
            if (endDate) {
                // get finish date allowed by successors
                var maxAllowedBySuccessors = me.getOutgoingDependenciesConstraintContext(Ext.apply(options, {
                        // this option will force to use successors end dates (instead of late end dates, by default)
                        shallow: true
                    }));
                // Free Slack is duration between task EndDate and minimum of:
                // 1) max end date allowed by successors (or project end if no successors)
                // 2) max end date allowed by task constraints (own plus parent ones)
                result = me.calculateSlackByDates(endDate, Sch.util.Date.min(maxAllowedBySuccessors ? maxAllowedBySuccessors.endDate : me.getProjectEndDate() || endDate, maxAllowedByConstraints || Sch.util.Date.MAX_VALUE), unit);
            }
        }
        return result;
    },
    endDateToStartDate: function(endDate) {
        var duration, result;
        // if the task is effort dirven and effort is provided
        if (this.isEffortDriven() && this.get(this.effortField) !== undefined) {
            result = this.calculateEffortDrivenStartDate(endDate, this.getEffort());
        } else {
            if (this.isSegmented()) {
                duration = this.calculateDuration(this.getStartDate(), this.getEndDate(), null, {
                    segments: false
                });
            } else {
                duration = this.getDuration();
            }
            result = this.calculateStartDate(endDate, duration, null, {
                segments: false
            });
        }
        return result;
    },
    startDateToEndDate: function(startDate) {
        var result, duration;
        // if the task is effort dirven and effort is provided
        if (this.isEffortDriven() && this.get(this.effortField) !== undefined) {
            result = this.calculateEffortDrivenEndDate(startDate, this.getEffort());
        } else {
            if (this.isSegmented()) {
                duration = this.calculateDuration(this.getStartDate(), this.getEndDate(), null, {
                    segments: false
                });
            } else {
                duration = this.getDuration();
            }
            result = this.calculateEndDate(startDate, duration, null, {
                segments: false
            });
        }
        return result;
    },
    getInheritedConstraintRestrictions: function(options) {
        options = options || {};
        var me = this,
            translateTo = options.translateTo || 'startDate',
            shallow = Boolean(options.shallow),
            otherSide = translateTo == 'startDate' ? 'endDate' : 'startDate',
            flipSideFn = translateTo == 'startDate' ? me.endDateToStartDate : me.startDateToEndDate,
            lateDate = Sch.util.Date.MAX_VALUE,
            earlyDate = Sch.util.Date.MIN_VALUE,
            result;
        me.bubble(function(task) {
            var constraints = task.getConstraintClasses();
            for (var i = 0; i < constraints.length; i++) {
                var constraint = constraints[i],
                    restrictions = constraint && constraint.getRestrictions(task),
                    dt;
                if (restrictions) {
                    // minimal allowed start/end dates
                    if (restrictions.min) {
                        dt = restrictions.min[translateTo] || restrictions.min[otherSide] && flipSideFn.call(me, restrictions.min[otherSide]);
                        // get maximum of such values
                        if (dt && (dt > earlyDate))  {
                            earlyDate = dt;
                        }
                        
                    }
                    // maximal allowed start/end dates
                    else if (restrictions.max) {
                        dt = restrictions.max[translateTo] || restrictions.max[otherSide] && flipSideFn.call(me, restrictions.max[otherSide]);
                        // get minimum of such values
                        if (dt && (dt < lateDate))  {
                            lateDate = dt;
                        }
                        
                    }
                    // check for MSO/MFO
                    else if (restrictions.startDate || restrictions.endDate) {
                        // TODO: do we need to swap end/start dates here??
                        result = restrictions;
                        return false;
                    }
                }
            }
            if (shallow)  {
                return false;
            }
            
        });
        if (!result) {
            // if the earliest possible date is found
            if (earlyDate - Sch.util.Date.MIN_VALUE) {
                result = {};
                result.min = {};
                result.min[translateTo] = earlyDate;
            }
            // if the latest possible date is found
            if (lateDate - Sch.util.Date.MAX_VALUE) {
                result = result || {};
                result.max = {};
                result.max[translateTo] = lateDate;
            }
        }
        return result;
    },
    getIncomingDependenciesConstraintContext: function(options) {
        options = options || {};
        var me = this,
            deep = !options.shallow,
            deps = me.getIncomingDependencies(true),
            depType = Gnt.model.Dependency.Type,
            translateTo = options.translateTo || 'startDate',
            swapDatesFn = translateTo == 'startDate' ? me.endDateToStartDate : me.startDateToEndDate,
            getEarlyStartDateFn = deep ? me.getEarlyStartDate : me.getStartDate,
            getEarlyEndDateFn = deep ? me.getEarlyEndDate : me.getEndDate,
            getLateStartDateFn = deep ? me.getLateStartDate : me.getStartDate,
            getLateEndDateFn = deep ? me.getLateEndDate : me.getEndDate,
            parentNode = options.parentNode,
            taskStore = options.taskStore || me.getTaskStore(true),
            scheduleBackwards = me.getProjectScheduleBackwards(taskStore),
            fetchAll = options.fetchAll,
            getStartDateFn, getEndDateFn, result, resultDate, dt;
        // for nested calls we never want to enumerate all the dependencies
        options.fetchAll = false;
        // a task inherits its parents incoming dependencies restrictions
        if (!options.ignoreParents) {
            deps = deps.concat(me.getParentsIncomingDependencies(parentNode));
        }
        // Early Start Date is the largest of Early Finish Dates of the preceding tasks
        for (var i = 0,
            l = deps.length; i < l; i++) {
            var dependency = deps[i],
                fromTask = dependency.getSourceTask(),
                swapDate = false,
                dependencyCalendar;
            if (fromTask && (!parentNode || fromTask.isAncestor(parentNode))) {
                // for ALAP tasks in FW projects we use Late dates (if Late dates can be calculated)
                if (!scheduleBackwards && fromTask.isContraryScheduled(taskStore, null, scheduleBackwards) && fromTask.areLateDatesAvailable()) {
                    getStartDateFn = getLateStartDateFn;
                    getEndDateFn = getLateEndDateFn;
                } else {
                    getStartDateFn = getEarlyStartDateFn;
                    getEndDateFn = getEarlyEndDateFn;
                }
                // get calendar instance to use for lag calculations
                dependencyCalendar = dependency.getCalendar(taskStore);
                switch (dependency.getType()) {
                    case depType.StartToStart:
                        dt = getStartDateFn.call(fromTask, options);
                        swapDate = translateTo == 'endDate';
                        break;
                    case depType.StartToEnd:
                        dt = getStartDateFn.call(fromTask, options);
                        // If we are working with task end date restricting dependency we'll convert it to start date later (after we take lag into account).
                        // #5218 covered with 033_task_lag
                        swapDate = translateTo == 'startDate';
                        break;
                    case depType.EndToStart:
                        dt = getEndDateFn.call(fromTask, options);
                        swapDate = translateTo == 'endDate';
                        break;
                    case depType.EndToEnd:
                        dt = getEndDateFn.call(fromTask, options);
                        // If we are working with task end date restricting dependency we'll convert it to start date later (after we take lag into account).
                        // #5218 covered with 033_task_lag
                        swapDate = translateTo == 'startDate';
                        break;
                }
                // if we've got some date
                if (dt) {
                    // let's plus dependency Lag (if any)
                    var lag = dependency.getLag();
                    if (lag)  {
                        dt = dependencyCalendar.skipWorkingTime(dt, lag, dependency.getLagUnit());
                    }
                    
                    // if we got the end date restriction we turn it to the start date one
                    if (swapDate)  {
                        dt = swapDatesFn.call(me, dt);
                    }
                    
                    // if it was asked to return all the dependencies restrictions as well
                    if (fetchAll) {
                        result = result || {
                            all: []
                        };
                        var _dt = dt;
                        var obj = {
                                constrainingTask: fromTask,
                                constrainingDependency: dependency
                            };
                        // skip non-working time here if requested
                        if (options.skipNonWorkingTime && !me.isMilestone()) {
                            _dt = me.skipNonWorkingTime(_dt, true);
                        }
                        obj[translateTo] = _dt;
                        result.all.push(obj);
                    }
                    if ((dt > resultDate) || !resultDate) {
                        resultDate = dt;
                        result = result || {};
                        result[translateTo] = dt;
                        result.constrainingTask = fromTask;
                        result.constrainingDependency = dependency;
                    }
                }
            }
        }
        // restore initial "fetchAll" option state
        options.fetchAll = fetchAll;
        // skip non-working time here if requested
        if (options.skipNonWorkingTime && result && !me.isMilestone()) {
            result[translateTo] = me.skipNonWorkingTime(result[translateTo], true);
        }
        return result;
    },
    getOutgoingDependenciesConstraintContext: function(options) {
        options = options || {};
        var me = this,
            depth = options.depth,
            shallow = Ext.isNumber(depth) ? depth === 0 : options.shallow,
            dependencies = me.getOutgoingDependencies(true),
            depType = Gnt.model.Dependency.Type,
            translateTo = options.translateTo || 'endDate',
            swapDatesFn = translateTo == 'endDate' ? me.startDateToEndDate : me.endDateToStartDate,
            getLateStartDateFn = options.getLateStartDateFn || (shallow ? me.getStartDate : me.getLateStartDate),
            getLateEndDateFn = options.getLateEndDateFn || (shallow ? me.getEndDate : me.getLateEndDate),
            getEarlyStartDateFn = options.getEarlyStartDateFn || (shallow ? me.getStartDate : me.getEarlyStartDate),
            getEarlyEndDateFn = options.getEarlyEndDateFn || (shallow ? me.getEndDate : me.getEarlyEndDate),
            parentNode = options.parentNode,
            taskStore = options.taskStore || me.getTaskStore(true),
            scheduleBackwards = me.getProjectScheduleBackwards(taskStore),
            fetchAll = options.fetchAll,
            getStartDateFn, getEndDateFn, result, resultDate, dt;
        if (Ext.isNumber(depth)) {
            options.depth--;
        }
        // for nested calls we never want to enumerate all the dependencies
        options.fetchAll = false;
        // a task inherits its parents dependencies restrictions
        if (!options.ignoreParents) {
            dependencies = dependencies.concat(me.getParentsOutgoingDependencies(parentNode));
        }
        // Late Finish Date is the smallest of Late Start Dates of succeeding tasks
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
            var dependency = dependencies[i],
                toTask = dependency.getTargetTask(),
                swapDate = false,
                dependencyCalendar;
            if (toTask && (!parentNode || toTask.isAncestor(parentNode))) {
                // in BW projects for ASAP tasks we use Early dates (if Early dates can be calculated)
                if (scheduleBackwards && toTask.isContraryScheduled(taskStore, null, scheduleBackwards) && toTask.areEarlyDatesAvailable()) {
                    getStartDateFn = getEarlyStartDateFn;
                    getEndDateFn = getEarlyEndDateFn;
                } else {
                    getStartDateFn = getLateStartDateFn;
                    getEndDateFn = getLateEndDateFn;
                }
                // get calendar instance to use for lag calculations
                dependencyCalendar = dependency.getCalendar(taskStore);
                switch (dependency.getType()) {
                    case depType.StartToStart:
                        dt = getStartDateFn.call(toTask, options);
                        swapDate = translateTo == 'endDate';
                        break;
                    case depType.StartToEnd:
                        dt = getEndDateFn.call(toTask, options);
                        swapDate = translateTo == 'endDate';
                        break;
                    case depType.EndToStart:
                        dt = getStartDateFn.call(toTask, options);
                        swapDate = translateTo == 'startDate';
                        break;
                    case depType.EndToEnd:
                        dt = getEndDateFn.call(toTask, options);
                        swapDate = translateTo == 'startDate';
                        break;
                }
                // if we've got some date
                if (dt) {
                    // minus dependency Lag
                    var lag = dependency.getLag();
                    if (lag)  {
                        dt = dependencyCalendar.skipWorkingTime(dt, -lag, dependency.getLagUnit());
                    }
                    
                    // swap dates using duration value
                    if (swapDate)  {
                        dt = swapDatesFn.call(me, dt);
                    }
                    
                    // if it was asked to return all the dependencies restrictions as well
                    if (fetchAll) {
                        result = result || {
                            all: []
                        };
                        var _dt = dt;
                        // skip non-working time here if requested
                        if (options.skipNonWorkingTime) {
                            _dt = me.skipNonWorkingTime(_dt, false);
                        }
                        var _obj = {
                                constrainingTask: toTask,
                                constrainingDependency: dependency
                            };
                        _obj[translateTo] = _dt;
                        result.all.push(_obj);
                    }
                    if (!resultDate || (dt < resultDate)) {
                        resultDate = dt;
                        result = result || {};
                        result[translateTo] = dt;
                        result.constrainingTask = toTask;
                        result.constrainingDependency = dependency;
                    }
                }
            }
        }
        // restore initial "fetchAll" option state
        options.fetchAll = fetchAll;
        // skip non-working time here if requested
        if (options.skipNonWorkingTime && result && !me.isMilestone()) {
            result[translateTo] = me.skipNonWorkingTime(result[translateTo], false);
        }
        return result;
    },
    getEarlyLateDateCacheKey: function(prefix, options) {
        if (typeof options == 'string')  {
            return options;
        }
        
        return '' + prefix + '-' + this.internalId + '-' + (options.skipNonWorkingTime !== false) + '-' + Boolean(options.shallow) + '-' + (options.limitByConstraints !== false) + '-' + Boolean(options.ignoreConstraint) + '-' + Boolean(options.treatAsLeaf) + // these are used in getIncomingDependenciesConstraintContext / getOutgoingDependenciesConstraintContext
        // which in turn affects early/late dates
        '-' + Boolean(options.ignoreParents) + '-' + (options.parentNode && options.parentNode.getId());
    },
    hasEarlyDateCachedValue: function(prefix, options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true);
        return store.hasEarlyDateCachedValue(me.getEarlyLateDateCacheKey(prefix, options));
    },
    getEarlyDateCachedValue: function(prefix, options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true);
        return store.getEarlyDateCachedValue(me.getEarlyLateDateCacheKey(prefix, options));
    },
    hasLateDateCachedValue: function(prefix, options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true);
        return store.hasLateDateCachedValue(me.getEarlyLateDateCacheKey(prefix, options));
    },
    getLateDateCachedValue: function(prefix, options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true);
        return store.getLateDateCachedValue(me.getEarlyLateDateCacheKey(prefix, options));
    },
    processEarlyStartDateValue: function(result, context) {
        var me = this,
            options = context.options,
            store = options.taskStore || me.getTaskStore(true),
            maxValue = context.maxValue;
        if (result && !context.skipValueProcessing) {
            if (context.options.skipNonWorkingTime && me.getDuration() && !me.hasChildNodes()) {
                result = me.skipNonWorkingTime(result, true);
            }
            // and finally if result is limited with allowed maximum
            if (maxValue && store.limitEarlyLateDatesMutually && result >= maxValue) {
                result = maxValue;
            }
        }
        return result;
    },
    getEarlyStartDateDefaultValue: function(options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            project = me.getProject();
        return project ? project.getStartDate() : store.getProjectStartDate();
    },
    /**
     * Returns the _early start date_ of this task.
     * The _early start date_ is the earliest possible start date of a task.
     * This value is calculated based on the earliest end dates of the task predecessors.
     * If the task has no predecessors, its start date is the early start date.
     *
     * @return {Date} The early start date.
     */
    getEarlyStartDate: function(options) {
        options = options || {};
        delete options.translateTo;
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            skipNonWorkingTime = (typeof options.skipNonWorkingTime == 'boolean' ? options.skipNonWorkingTime : store.skipWeekendsDuringDragDrop),
            updateCache = options.updateCache,
            treatAsLeaf = options.treatAsLeaf,
            cacheKey, cachedResult;
        if (!updateCache) {
            cacheKey = me.getEarlyLateDateCacheKey('es', options);
            if (store.hasEarlyDateCachedValue(cacheKey))  {
                return store.getEarlyDateCachedValue(cacheKey);
            }
            
        }
        if (!me.areEarlyDatesAvailable())  {
            return;
        }
        
        // For nested calls in this method we don't want excessive not working time skipping (too expensive).
        // But for milestones we have to do that since otherwise it won't be placed correctly.
        // Since we don't skip non-working time for milestones.
        if (!me.isMilestone()) {
            options.skipNonWorkingTime = false;
        }
        options.updateCache = false;
        // treatAsLeaf should work only for this exact task
        options.treatAsLeaf = false;
        var limitByConstraints = options.limitByConstraints !== false,
            internalId = me.internalId,
            skipValueProcessing = false,
            constraintLimits, dependenciesLimits, context, max, result;
        // If we are in the "full dependencies scan" mode
        // let's protect from infinite loops (in case of bad data structure)
        // by storing the flag informing that we stepped into "getEarlyStartDate" method for the task
        // till this method is done
        if (!options.shallow) {
            context = options.context || {
                calls: {}
            };
            context.calls.getEarlyStartDate = context.calls.getEarlyStartDate || {};
            if (context.calls.getEarlyStartDate[internalId]) {
                return;
            }
            context.calls.getEarlyStartDate[internalId] = true;
            options.context = context;
        }
        // for a task outside a task store, a project, a manually scheduled or completed task we simply return start date
        if (!store || me.isProject || me.isManuallyScheduled() || me.isCompleted()) {
            result = me.getStartDate();
            skipValueProcessing = true;
        }
        // we can also use a value w/ not skipped non-working time (if cached)
        else if (!updateCache && me.hasEarlyDateCachedValue('es', options)) {
            result = me.getEarlyDateCachedValue('es', options);
        }
        // for a parent task we take the minimum Early Start from its children
        else if (me.childNodes.length && !treatAsLeaf) {
            options.skipNonWorkingTime = true;
            Ext.each(me.childNodes, function(child) {
                var dt = child.getEarlyStartDate(options);
                if (dt && !result || dt < result) {
                    result = dt;
                }
            });
        } else {
            var ignoreDependencies = false,
                ignoreConstraint = options.ignoreConstraint === true || !store.scheduleByConstraints;
            if (!ignoreConstraint) {
                // take the task constraint into account
                if (constraintLimits = me.getInheritedConstraintRestrictions()) {
                    // if exact start (or end) dates are passed we use those values (Must-Start-On/Must-Finish-On cases)
                    if (constraintLimits.startDate) {
                        result = constraintLimits.startDate;
                        // Dependencies can be skipped since MSO is a non-flexible constraint
                        ignoreDependencies = true;
                        // ..and we cannot change the constraint date value
                        skipValueProcessing = true;
                    } else if (constraintLimits.endDate) {
                        result = me.endDateToStartDate(constraintLimits.endDate);
                        // Dependencies can be skipped since MFO is a non-flexible constraint
                        ignoreDependencies = true;
                    } else // if minimal allowed start/end dates are provided
                    // we use them as Early Start date unless there are incoming dependencies found on next steps
                    {
                        if (constraintLimits.min) {
                            result = constraintLimits.min.startDate;
                        }
                        if (limitByConstraints && constraintLimits.max) {
                            max = constraintLimits.max.startDate;
                        }
                    }
                }
            }
            // get minimal allowed start date based on incoming dependencies
            if (!ignoreDependencies) {
                dependenciesLimits = me.getIncomingDependenciesConstraintContext(options);
                // TODO: BW compat ..this case can be removed when we make aligning by constraints non-optional
                if (ignoreConstraint && !dependenciesLimits && !result) {
                    result = me.getStartDate() || me.getEarlyStartDateDefaultValue(options);
                } else if (dependenciesLimits && (!result || dependenciesLimits.startDate > result)) {
                    result = dependenciesLimits.startDate;
                }
            }
            // We use project start date for tasks not limited w/ constraints or dependencies
            if (store.scheduleByConstraints && !result) {
                result = me.getEarlyStartDateDefaultValue(options);
            }
        }
        // restore flags back
        options.treatAsLeaf = treatAsLeaf;
        options.skipNonWorkingTime = skipNonWorkingTime;
        result = me.processEarlyStartDateValue(result, {
            options: options,
            cacheKey: cacheKey,
            maxValue: max,
            skipValueProcessing: skipValueProcessing,
            dependencyLimits: dependenciesLimits,
            constraintLimits: constraintLimits
        });
        // store found value into the cache
        store.setEarlyDateCachedValue(cacheKey, result);
        // reset the "anti-loop" flag we set in the beginning
        if (context)  {
            delete context.calls.getEarlyStartDate[internalId];
        }
        
        return result;
    },
    processEarlyEndDateValue: function(value, context) {
        var me = this,
            result = value,
            options = context.options,
            store = options.taskStore || me.getTaskStore(true),
            minValue = context.minValue,
            maxValue = context.maxValue;
        if (result && !context.skipValueProcessing) {
            // make sure it does not violate its allowed maximum
            if (maxValue && store.limitEarlyLateDatesMutually && result > maxValue) {
                result = maxValue;
            }
            // skip non working time backwards if requested (do this only if the value is greater than its allowed minimum)
            if (options.skipNonWorkingTime && me.getDuration() && !me.hasChildNodes() && (!minValue || result > minValue)) {
                result = me.skipNonWorkingTime(result, false);
            }
            // make sure the value does not violate its allowed minimum
            if (minValue && result < minValue) {
                result = minValue;
            }
        }
        return result;
    },
    /**
     * Returns the _early end date_ of the task.
     * The _early end date_ is the earliest possible end date of the task.
     * This value is calculated based on the earliest end dates of predecessors.
     * If the task has no predecessors then its end date is used as its earliest end date.
     *
     * @return {Date} The early end date.
     */
    getEarlyEndDate: function(options) {
        options = options || {};
        delete options.translateTo;
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            skipNonWorkingTime = (typeof options.skipNonWorkingTime == 'boolean' ? options.skipNonWorkingTime : store.skipWeekendsDuringDragDrop),
            updateCache = options.updateCache,
            treatAsLeaf = options.treatAsLeaf,
            cacheKey = me.getEarlyLateDateCacheKey('ee', options);
        if (!updateCache && store.hasEarlyDateCachedValue(cacheKey))  {
            return store.getEarlyDateCachedValue(cacheKey);
        }
        
        // treatAsLeaf should work only for this exact task
        options.treatAsLeaf = false;
        // for nested calls we don't need excessive not working time skipping
        options.skipNonWorkingTime = false;
        var limitByConstraints = options.limitByConstraints !== false,
            internalId = me.internalId,
            skipValueProcessing = false,
            ignoreDependencies = false,
            constraintLimits, dependenciesLimits, result, context, min, max;
        // If we are in the "full dependencies scan" mode
        // let's protect from infinite loops (in case of bad data structure)
        // by storing the flag informing that we stepped into "getEarlyEndDate" method for the task
        // till this method is done
        if (!options.shallow) {
            context = options.context || {
                calls: {}
            };
            context.calls.getEarlyEndDate = context.calls.getEarlyEndDate || {};
            if (context.calls.getEarlyEndDate[internalId]) {
                return;
            }
            context.calls.getEarlyEndDate[internalId] = true;
            options.context = context;
        }
        if (!store) {
            result = me.getEndDate();
            skipValueProcessing = true;
        }
        // we can also use a value w/ not skipped non-working time (if cached)
        else if (!updateCache && me.hasEarlyDateCachedValue('ee', options)) {
            result = me.getEarlyDateCachedValue('ee', options);
        }
        // for a project or a manually scheduled task we simply return its end date
        else if (me.isProject || me.isManuallyScheduled() || me.isCompleted()) {
            result = me.getEndDate();
        }
        // for a parent task we take the max Early Finish of its children
        else if (me.childNodes.length && !treatAsLeaf) {
            options.skipNonWorkingTime = true;
            Ext.each(me.childNodes, function(child) {
                var dt = child.getEarlyEndDate(options);
                if (dt && !result || dt > result) {
                    result = dt;
                }
            });
        } else {
            if (store.scheduleByConstraints && !options.ignoreConstraint) {
                // Take the task constraint into account.
                if (constraintLimits = me.getInheritedConstraintRestrictions({
                    translateTo: 'endDate'
                })) {
                    // if exact end date is passed we use those values (Must-Finish-On case)
                    if (constraintLimits.endDate) {
                        result = constraintLimits.endDate;
                        // Dependencies can be skipped since MFO is a non-flexible constraint
                        ignoreDependencies = true;
                        // ..and we cannot change the constraint date value
                        skipValueProcessing = true;
                    } else if (constraintLimits.startDate) {
                        result = me.startDateToEndDate(constraintLimits.startDate);
                        // Dependencies can be skipped since MFO is a non-flexible constraint
                        ignoreDependencies = true;
                    } else // if minimal allowed start/end dates are provided
                    // we use them as Early Start date unless there are incoming dependencies found on next steps
                    {
                        if (constraintLimits.min) {
                            min = result = constraintLimits.min.endDate;
                        }
                        if (limitByConstraints && constraintLimits.max) {
                            max = constraintLimits.max.endDate;
                        }
                    }
                }
            }
            // get minimal allowed start date based on incoming dependencies
            if (!ignoreDependencies) {
                dependenciesLimits = me.getIncomingDependenciesConstraintContext(Ext.apply({
                    translateTo: 'endDate'
                }, options));
                if (dependenciesLimits && (!result || dependenciesLimits.endDate > result)) {
                    min = result = dependenciesLimits.endDate;
                }
            }
        }
        // If minimum & maximum are provided due to dependencies and (or) constraints setup
        // we check if minimum is less than maximum (this means constraints conflict).
        // And in this case we ignore minimum limit.
        if (min && max && min >= max) {
            min = null;
        }
        // restore flags back
        options.treatAsLeaf = treatAsLeaf;
        options.skipNonWorkingTime = skipNonWorkingTime;
        // Let's fall back to formula:
        // Early Finish Date = Early Start Date + duration
        // 1) If we couldn't calculate date based on constraints & dependencies (if the task has no incoming dependencies & constraints for example)
        // 2) in BW compatible mode
        if (!result) {
            var value = me.getEarlyStartDate(options);
            if (value)  {
                result = me.startDateToEndDate(value);
            }
            
        }
        // TODO: check if below approach can be used
        // var value = me.getProjectStartDate();
        // if (value) result = me.startDateToEndDate(value);
        result = me.processEarlyEndDateValue(result, {
            options: options,
            cacheKey: cacheKey,
            minValue: min,
            maxValue: max,
            skipValueProcessing: skipValueProcessing,
            dependencyLimits: dependenciesLimits,
            constraintLimits: constraintLimits
        });
        // store found value into the cache
        store.setEarlyDateCachedValue(cacheKey, result);
        // reset the "anti-loop" flag we set in the beginning
        if (context)  {
            delete context.calls.getEarlyEndDate[internalId];
        }
        
        return result;
    },
    processLateEndDateValue: function(value, context) {
        var me = this,
            result = value,
            options = context.options,
            store = options.taskStore || me.getTaskStore(true),
            minValue = context.minValue;
        if (result && !context.skipValueProcessing) {
            if (options.skipNonWorkingTime && me.getDuration() && !me.hasChildNodes()) {
                result = me.skipNonWorkingTime(result, false);
            }
            // and finally if result is limited by "minValue"
            if (minValue && store.limitEarlyLateDatesMutually && result < minValue) {
                result = minValue;
            }
        }
        return result;
    },
    getLateEndDateDefaultValue: function(options) {
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            project = me.getProject();
        return project ? project.getEndDate() : store.getProjectEndDate();
    },
    /**
     * Returns the _late end date_ of the task.
     * The _late end date_ is the latest possible end date of the task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, the project end date is used as its latest end date.
     *
     * @return {Date} The late end date.
     */
    getLateEndDate: function(options) {
        options = options || {};
        delete options.translateTo;
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            skipNonWorkingTime = (typeof options.skipNonWorkingTime == 'boolean' ? options.skipNonWorkingTime : store.skipWeekendsDuringDragDrop),
            updateCache = options.updateCache,
            treatAsLeaf = options.treatAsLeaf,
            limitByConstraints = options.limitByConstraints !== false,
            cacheKey = me.getEarlyLateDateCacheKey('le', options);
        if (!updateCache && store.hasLateDateCachedValue(cacheKey))  {
            return store.getLateDateCachedValue(cacheKey);
        }
        
        if (!me.areLateDatesAvailable())  {
            return;
        }
        
        // treatAsLeaf should work only for this exact task
        options.treatAsLeaf = false;
        // for nested calls we don't need excessive not working time skipping
        options.skipNonWorkingTime = false;
        options.updateCache = false;
        var internalId = me.internalId,
            skipValueProcessing = false,
            constraintLimits, dependenciesLimits, result, context, min;
        // If we are in the "full dependencies scan" mode
        // let's protect from infinite loops (in case of bad data structure)
        // by storing the flag informing that we stepped into "getLateEndDate" method for the task
        // till this method is done
        if (!options.shallow) {
            context = options.context || {
                calls: {}
            };
            context.calls.getLateEndDate = context.calls.getLateEndDate || {};
            if (context.calls.getLateEndDate[internalId]) {
                return;
            }
            context.calls.getLateEndDate[internalId] = true;
            options.context = context;
        }
        // for a project or a manually scheduled task we simply return its end date
        if (!store || me.isProject || me.isManuallyScheduled() || me.isCompleted()) {
            result = me.getEndDate();
            skipValueProcessing = true;
        }
        // we can also use a value w/ not skipped non-working time (if cached)
        else if (!updateCache && me.hasLateDateCachedValue('le', options)) {
            result = me.getLateDateCachedValue('le', options);
        }
        // for parent task we take maximum Late Finish from its children
        else if (me.childNodes.length) {
            options.skipNonWorkingTime = true;
            Ext.each(me.childNodes, function(child) {
                var dt = child.getLateEndDate(options);
                if (dt && !result || dt > result) {
                    result = dt;
                }
            });
        } else {
            var ignoreConstraint = options.ignoreConstraint === true || !store.scheduleByConstraints,
                ignoreDependencies = false;
            if (!ignoreConstraint) {
                // take the task constraint into account
                if (constraintLimits = me.getInheritedConstraintRestrictions({
                    translateTo: 'endDate'
                })) {
                    // if exact start (or end) dates are passed we use those values (Must-Start-On/Must-Finish-On cases)
                    if (constraintLimits.startDate) {
                        result = me.startDateToEndDate(constraintLimits.startDate);
                        ignoreDependencies = true;
                    } else if (constraintLimits.endDate) {
                        result = constraintLimits.endDate;
                        ignoreDependencies = true;
                        skipValueProcessing = true;
                    } else // if maximal allowed start/end dates are provided
                    // we use them as Late End date unless there are outgoing dependencies found on next steps
                    {
                        if (constraintLimits.max) {
                            result = constraintLimits.max.endDate;
                        }
                        if (limitByConstraints && constraintLimits.min) {
                            min = constraintLimits.min.endDate;
                        }
                    }
                }
            }
            if (!ignoreDependencies) {
                dependenciesLimits = me.getOutgoingDependenciesConstraintContext(options);
                if (dependenciesLimits && (!result || dependenciesLimits.endDate < result)) {
                    result = dependenciesLimits.endDate;
                }
            }
            // We use project end date for tasks not limited w/ constraints or dependencies
            if (!result) {
                result = me.getLateEndDateDefaultValue(options);
            }
        }
        // restore flags back
        options.treatAsLeaf = treatAsLeaf;
        options.skipNonWorkingTime = skipNonWorkingTime;
        result = me.processLateEndDateValue(result, {
            options: options,
            cacheKey: cacheKey,
            minValue: min,
            skipValueProcessing: skipValueProcessing,
            dependencyLimits: dependenciesLimits,
            constraintLimits: constraintLimits
        });
        // store found value into the cache
        store.setLateDateCachedValue(cacheKey, result);
        // reset the "anti-loop" flag we set in the beginning
        if (context)  {
            delete context.calls.getLateEndDate[internalId];
        }
        
        return result;
    },
    processLateStartDateValue: function(value, context) {
        var me = this,
            result = value,
            options = context.options,
            store = options.taskStore || me.getTaskStore(true),
            minValue = context.minValue,
            maxValue = context.maxValue;
        // if we've got some resulting value
        if (result && !context.skipValueProcessing) {
            // make sure it does not violate allowed minimum
            if (minValue && store.limitEarlyLateDatesMutually && result < minValue) {
                result = minValue;
            }
            // skip non working time forward if requested (do this only if the value is less than its allowed maximum)
            if (options.skipNonWorkingTime && !me.isMilestone() && !me.hasChildNodes() && (!maxValue || result < maxValue)) {
                result = me.skipNonWorkingTime(result);
            }
            // make sure it does not violate allowed maximum
            if (maxValue && result > maxValue) {
                result = maxValue;
            }
        }
        return result;
    },
    /**
     * Returns the _late start date_ of the task.
     * The _late start date_ is the latest possible start date of this task.
     * This value is calculated based on the latest start dates of its successors.
     * If the task has no successors, this value is calculated as the _project end date_ minus the task duration
     * (_project end date_ is the latest end date of all the tasks in the taskStore).
     *
     * @return {Date} The late start date.
     */
    getLateStartDate: function(options) {
        options = options || {};
        delete options.translateTo;
        var me = this,
            store = options.taskStore || me.getTaskStore(true),
            skipNonWorkingTime = (typeof options.skipNonWorkingTime == 'boolean' ? options.skipNonWorkingTime : store.skipWeekendsDuringDragDrop),
            treatAsLeaf = options.treatAsLeaf,
            updateCache = options.updateCache,
            limitByConstraints = options.limitByConstraints !== false,
            cacheKey = me.getEarlyLateDateCacheKey('ls', options),
            skipValueProcessing = false,
            result;
        if (!updateCache && store.hasLateDateCachedValue(cacheKey))  {
            return store.getLateDateCachedValue(cacheKey);
        }
        
        // treatAsLeaf should work only for this exact task
        options.treatAsLeaf = false;
        // for nested calls we don't need excessive not working time skipping
        options.skipNonWorkingTime = false;
        var nonWorkingTimeSkipped = false,
            internalId = me.internalId,
            constraintLimits, min, max, context;
        // If we are in the "full dependencies scan" mode
        // let's protect from infinite loops (in case of bad data structure)
        // by storing the flag informing that we stepped into "getLateStartDate" method for the task
        // till this method is done
        if (!options.shallow) {
            context = options.context || {
                calls: {}
            };
            context.calls.getLateStartDate = context.calls.getLateStartDate || {};
            if (context.calls.getLateStartDate[internalId]) {
                return;
            }
            context.calls.getLateStartDate[internalId] = true;
            options.context = context;
        }
        if (!store) {
            result = me.getStartDate();
            skipValueProcessing = true;
        }
        // we can also use a value w/ not skipped non-working time (if cached)
        else if (!updateCache && me.hasLateDateCachedValue('ls', options)) {
            result = me.getLateDateCachedValue('ls', options);
        }
        // for a project or a manually scheduled task we simply return its start date
        else if (me.isProject || me.isManuallyScheduled() || me.isCompleted()) {
            result = me.getStartDate();
            skipValueProcessing = true;
        }
        // for parent task we take the minimal Late Start from its children
        else if (me.childNodes.length) {
            options.skipNonWorkingTime = true;
            Ext.each(me.childNodes, function(child) {
                var dt = child.getLateStartDate(options);
                if (dt && !result || dt < result) {
                    result = dt;
                }
            });
        } else // Late Start Date is Late Finish Date minus duration
        {
            var ignoreDependencies = false;
            if (store.scheduleByConstraints && !options.ignoreConstraint) {
                // Take the task constraint into account.
                if (constraintLimits = me.getInheritedConstraintRestrictions({
                    translateTo: 'startDate'
                })) {
                    // Must-Start-On (MSO) constraint
                    if (constraintLimits.startDate) {
                        result = constraintLimits.startDate;
                        // dependencies can be skipped since the constraint is not flexible
                        ignoreDependencies = true;
                        // ..and we should use the constraint date value
                        nonWorkingTimeSkipped = true;
                    }
                    // Must-Finish-On (MFO)
                    else if (constraintLimits.endDate) {
                        result = me.endDateToStartDate(constraintLimits.endDate);
                        // dependencies can be skipped since MFO is a non-flexible constraint
                        ignoreDependencies = true;
                    } else // if maximum allowed start/end dates are provided
                    // we use them as Late Start date (unless there are incoming dependencies found on next steps)
                    {
                        if (constraintLimits.max) {
                            max = result = constraintLimits.max.startDate;
                        }
                        if (limitByConstraints && constraintLimits.min) {
                            min = constraintLimits.min.startDate;
                        }
                    }
                }
            }
            // get maximum allowed start date based on outgoing dependencies
            if (!ignoreDependencies) {
                var dependenciesLimits = me.getOutgoingDependenciesConstraintContext(Ext.apply({
                        translateTo: 'startDate'
                    }, options));
                if (dependenciesLimits && (!result || dependenciesLimits.startDate < result)) {
                    max = result = dependenciesLimits.startDate;
                }
            }
        }
        // restore flags back
        options.treatAsLeaf = treatAsLeaf;
        options.skipNonWorkingTime = skipNonWorkingTime;
        if (!result) {
            var value = me.getLateEndDate(options);
            // ..subtract duration
            if (value)  {
                result = me.endDateToStartDate(value);
            }
            
        }
        result = me.processLateStartDateValue(result, {
            minValue: min,
            maxValue: max,
            skipValueProcessing: skipValueProcessing,
            options: options,
            cacheKey: cacheKey,
            constraintLimits: constraintLimits
        });
        // store found value into the cache
        store.setLateDateCachedValue(cacheKey, result);
        // reset the "anti-loop" flag we set in the beginning
        if (context)  {
            delete context.calls.getLateStartDate[internalId];
        }
        
        return result;
    },
    getTopParent: function(all) {
        var root = this.getTaskStore().getRoot(),
            p = this,
            path = [
                this
            ],
            result;
        while (p) {
            if (p === root)  {
                return all ? path : result;
            }
            
            path.push(p);
            result = p;
            p = p.parentNode;
        }
    },
    isContraryScheduled: function(taskStore, project, scheduleBackwards) {
        if (typeof scheduleBackwards !== 'boolean') {
            scheduleBackwards = this.getProjectScheduleBackwards(taskStore, project);
        }
        return this.getConstraintType() == (scheduleBackwards ? 'assoonaspossible' : 'aslateaspossible');
    },
    areEarlyDatesAvailable: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            project = me.getProject();
        return !(project ? project.isInvalidatingStartDate() : taskStore.isInvalidatingProjectStartDate());
    },
    areLateDatesAvailable: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            project = me.getProject();
        return !(project ? project.isInvalidatingEndDate() : taskStore.isInvalidatingProjectEndDate());
    },
    startInvalidatingProjectBorder: function() {
        var me = this,
            taskStore = me.getTaskStore(),
            project = me.getProject();
        if (project) {
            project.startInvalidatingRange();
        } else {
            taskStore.startInvalidatingProjectBorder();
        }
    },
    finishInvalidatingProjectBorder: function() {
        var me = this,
            taskStore = me.getTaskStore(),
            project = me.getProject();
        if (project) {
            project.finishInvalidatingRange();
        } else {
            taskStore.finishInvalidatingProjectBorder();
        }
    },
    initializePropagation: function() {
        var taskStore = this.getTaskStore(true),
            cascadeBatch;
        this.propagating = true;
        if (taskStore) {
            taskStore.suspendAutoSync();
            taskStore.suspendEarlyDatesResetNotification();
            taskStore.suspendLateDatesResetNotification();
            // reset Early/Late dates cache after the changer has finished its work
            // those values will be recalculated while rescheduling the affected tasks
            taskStore.resetEarlyDates(true);
            taskStore.resetLateDates(true);
            cascadeBatch = taskStore.startBatchCascade();
            taskStore.startProjection();
        }
        return {
            affectedTasks: {},
            cascadeBatch: cascadeBatch
        };
    },
    finalizePropagation: function(cancelChanges, affectedTasks, callback) {
        var taskStore = this.getTaskStore(true);
        if (taskStore) {
            if (cancelChanges) {
                while (taskStore.isProjecting()) taskStore.rejectProjection();
                affectedTasks = {};
            } else {
                var modifiedData;
                while (taskStore.isProjecting()) {
                    modifiedData = taskStore.commitProjection();
                }
                // Zero-level projection commit returns array of fields *actually* modified on the record
                // so we can filter out record that were temporary marked as affected by propagation
                // and leave only those which were really changed to reduce number of refreshes of UI
                var currentCascadeBatch = taskStore.currentCascadeBatch,
                    affected = currentCascadeBatch.affected,
                    nbrUpdated = false,
                    internalId;
                for (internalId in affected) {
                    // remove record from list of affected if it was not really changed
                    if (!modifiedData[internalId] || !modifiedData[internalId].length) {
                        nbrUpdated = true;
                        delete affected[internalId];
                        delete affectedTasks[taskStore.getModelByInternalId(internalId).getId()];
                    }
                }
                currentCascadeBatch.nbrAffected = 0;
                currentCascadeBatch.affectedParentsbyInternalId = {};
                currentCascadeBatch.affectedParentsArray = [];
                // Iterate through "affected" object to re-add affected tasks
                // in order to recalculate nbrAffected and collect affected nodes parents
                for (internalId in affected) {
                    var affectedTask = affected[internalId];
                    delete affected[internalId];
                    currentCascadeBatch.addAffected(affectedTask);
                }
            }
            taskStore.endBatchCascade();
            taskStore.resumeAutoSync(taskStore.autoSync && !cancelChanges && !Ext.Object.isEmpty(affectedTasks));
            taskStore.resumeEarlyDatesResetNotification();
            taskStore.resumeLateDatesResetNotification();
        }
        this.propagating = false;
        callback && callback(cancelChanges, affectedTasks);
    },
    // @private
    // If there are tasks that should be scheduled counter to others (ALAP in a FW-project or ASAP in a BW one)
    // we might need to propagate twice since to be able to calculate proper late dates (in FW projects, early dates in BW project).
    // This method decides if we need two-step propagation or not
    isTwoStepPropagationNeeded: function(taskStore, propagationSources, project, oppositeTasks) {
        var result = false;
        // If the 1st task is "counter" one
        // we check each other source trying to understand if project end might get changed or not.
        if (propagationSources[0].isContraryScheduled(taskStore, project)) {
            Ext.Array.each(propagationSources, function(source) {
                // Let's use 2-step propagation:
                // - if some other source is not "counter"
                if (!source.isContraryScheduled(null, project)) {
                    result = true;
                    return false;
                }
                // - if a source start/end or duration is changed (might affect project end date)
                else if (source.isProjected(source.startDateField) || source.isProjected(source.endDateField) || source.isProjected(source.durationField)) {
                    result = true;
                    return false;
                }
                // - if a source had a constraint other than ASAP/ALAP (or got such a constraint)
                else if (source.isProjected(source.constraintTypeField)) {
                    var prevConstraint = source.getUnprojected(source.constraintTypeField),
                        newConstraint = source.getConstraintType();
                    var prevConstraintClass = prevConstraint && Gnt.constraint.Base.getConstraintClass(prevConstraint),
                        newConstraintClass = newConstraint && Gnt.constraint.Base.getConstraintClass(newConstraint);
                    if ((prevConstraintClass && prevConstraintClass.isSemiflexibleConstraint || prevConstraintClass && prevConstraintClass.isInflexibleConstraint) || (newConstraintClass && newConstraintClass.isSemiflexibleConstraint || newConstraintClass && newConstraintClass.isInflexibleConstraint)) {
                        result = true;
                        return false;
                    }
                }
            });
        } else // if 1st propagation source is not scheduled counter to other tasks
        // we use 2-step propagation if there are counter scheduled tasks in the project
        {
            result = Boolean(oppositeTasks.length);
        }
        return result;
    },
    twoStepPropagateChangesThroughTasks: function(cfg) {
        var me = this,
            propagationSources1 = cfg.propagationSources1,
            propagationSources2 = cfg.propagationSources2,
            walkingSpec1 = cfg.walkingSpec1,
            walkingSpec2 = cfg.walkingSpec2,
            taskStore = cfg.taskStore,
            cascadeBatch = cfg.cascadeBatch,
            cascadeChanges = cfg.cascadeChanges,
            moveParentAsGroup = cfg.moveParentAsGroup,
            affectedTasks = cfg.affectedTasks,
            callback = cfg.callback,
            scheduleBackwards = cfg.scheduleBackwards;
        // Indicate that corresponding project border (start or end date) is being invalidated
        propagationSources1[0].startInvalidatingProjectBorder(scheduleBackwards);
        me.singleStepPropagateChangesThroughTasks({
            propagationSources: propagationSources1,
            walkingSpec: walkingSpec1,
            taskStore: taskStore,
            cascadeBatch: cascadeBatch,
            cascadeChanges: cascadeChanges,
            moveParentAsGroup: moveParentAsGroup,
            affectedTasks: affectedTasks,
            scheduleBackwards: scheduleBackwards,
            callback: function(cancelChanges, affectedTasks) {
                // Indicate that corresponding project border (start or end date) is stable and can be calculated safely
                propagationSources1[0].finishInvalidatingProjectBorder(scheduleBackwards);
                if (cancelChanges) {
                    callback.call(cancelChanges, affectedTasks);
                } else {
                    // reset early/late date caches
                    taskStore.resetEarlyDates(true);
                    taskStore.resetLateDates(true);
                    // project border has been changed
                    taskStore.resetTotalTimeSpanCache();
                    // Make a new empty cascadeBatch
                    var cascadeBatch2 = taskStore.getEmptyCascadeBatch();
                    cascadeBatch2.step1CascadeBatch = cascadeBatch;
                    cascadeBatch2.step1AffectedTasks = affectedTasks;
                    taskStore.startProjection();
                    me.singleStepPropagateChangesThroughTasks({
                        propagationSources: propagationSources2,
                        walkingSpec: walkingSpec2,
                        taskStore: taskStore,
                        cascadeBatch: cascadeBatch2,
                        cascadeChanges: cascadeChanges,
                        moveParentAsGroup: moveParentAsGroup,
                        affectedTasks: {},
                        scheduleBackwards: scheduleBackwards,
                        callback: callback
                    });
                }
            }
        });
    },
    singleStepPropagateChangesThroughTasks: function(cfg) {
        var me = this,
            propagationSources = cfg.propagationSources,
            walkingSpec = cfg.walkingSpec,
            taskStore = cfg.taskStore,
            cascadeBatch = cfg.cascadeBatch,
            cascadeChanges = cfg.cascadeChanges,
            moveParentAsGroup = cfg.moveParentAsGroup,
            affectedTasks = cfg.affectedTasks,
            callback = cfg.callback,
            scheduleBackwards = cfg.scheduleBackwards;
        me.propagateChangesThroughDependentTasks(taskStore.getLinearWalkingSequenceForDependentTasks(propagationSources, Ext.apply({
            self: true,
            ancestors: taskStore.recalculateParents,
            descendants: moveParentAsGroup,
            successors: cascadeChanges && !scheduleBackwards,
            predecessors: cascadeChanges && scheduleBackwards,
            cycles: taskStore.cycleResolutionStrategy
        }, walkingSpec)), taskStore, cascadeBatch, propagationSources, cascadeChanges, affectedTasks, callback);
    },
    continutePropagateChanges: function(cascadeBatch, affectedTasks, propagationSources, callback, cascadeChanges, moveParentAsGroup) {
        var me = this,
            taskStore;
        taskStore = me.getTaskStore(true);
        if (taskStore) {
            if (propagationSources === true) {
                propagationSources = me.isProjected() && [
                    me
                ] || false;
            } else if (propagationSources) {
                propagationSources = [].concat(propagationSources);
            }
            cascadeBatch.propagationSources = propagationSources;
            // Propagating
            if (propagationSources && propagationSources.length > 0) {
                // TODO: need to review this later to support propagation through multiple projects
                var project = me.getProject(),
                    scheduleBackwards = propagationSources[0].getProjectScheduleBackwards(taskStore),
                    oppositeTasks = taskStore.getContraryScheduledTasks(project);
                var runPropagation = function(propagationSources, callback, walkingSpec) {
                        me.singleStepPropagateChangesThroughTasks({
                            propagationSources: propagationSources,
                            walkingSpec: walkingSpec,
                            taskStore: taskStore,
                            cascadeBatch: cascadeBatch,
                            cascadeChanges: cascadeChanges,
                            moveParentAsGroup: moveParentAsGroup,
                            affectedTasks: affectedTasks,
                            scheduleBackwards: scheduleBackwards,
                            callback: callback
                        });
                    };
                // if we need 2-step propagation
                if (me.isTwoStepPropagationNeeded(taskStore, propagationSources, project, oppositeTasks)) {
                    Ext.each(oppositeTasks, function(task) {
                        task.markForRescheduling();
                    });
                    runPropagation = function(propagationSources, callback) {
                        me.twoStepPropagateChangesThroughTasks({
                            propagationSources1: Ext.Array.union(propagationSources, oppositeTasks),
                            propagationSources2: oppositeTasks,
                            taskStore: taskStore,
                            cascadeBatch: cascadeBatch,
                            cascadeChanges: cascadeChanges,
                            moveParentAsGroup: moveParentAsGroup,
                            affectedTasks: affectedTasks,
                            scheduleBackwards: scheduleBackwards,
                            callback: callback
                        });
                    };
                }
                // Some constraints we check early before propagation starts
                // so we check them and launch the propagation cycle
                var prePropagationConstraints = taskStore.getPrePropagationConstraints(me);
                if (prePropagationConstraints.length) {
                    me.doVerifyConstraints(prePropagationConstraints, function onConstraintsVerifiedCallback(constraintSatisfied, cancelChanges) {
                        // react on the verification fail
                        if (cancelChanges) {
                            me.finalizePropagation(cancelChanges, affectedTasks, callback);
                        } else // launch the propagation cycle
                        {
                            runPropagation(propagationSources, function(cancelChanges, affectedTasks) {
                                me.finalizePropagation(cancelChanges, affectedTasks, callback);
                            });
                        }
                    });
                } else // launch the propagation cycle
                {
                    runPropagation(propagationSources, function(cancelChanges, affectedTasks) {
                        me.finalizePropagation(cancelChanges, affectedTasks, callback);
                    });
                }
            } else {
                me.finalizePropagation(true, {}, callback && function() {
                    callback(false, {});
                });
            }
        } else // No task store
        {
            me.verifyConstraints(function(constraintSatisfied, cancelChanges) {
                if (!cancelChanges) {
                    affectedTasks[me.getId()] = me;
                }
                me.finalizePropagation(!!cancelChanges, affectedTasks, callback);
            }, affectedTasks);
        }
    },
    /**
     * Propagates changes done in `changer` function to the task to all dependent tasks. The action is asynchronous
     * since changes propagation might violate some constraints applied, which in turn might require user
     * interaction.
     *
     * **Please note** that the propagation process cannot be nested which means `changer` function cannot have `propagateChanges` call inside of it.
     * To avoid such cases all the methods invoking the propagation are marked with a special <span class="signature"><span class="propagating">propagating</span></span>
     * (or <span class="signature"><span class="propagating">pg</span></span> in the methods menu) tag in the docs.
     *
     * @param {Function} [changer] Function which should apply changes to the task.
     *
     * ```javascript
     *  task.propagateChanges(
     *      function (task, continueFn) {
     *          // apply some changes
     *          task.set('StartDate', ...);
     *          task.set('EndDate', ...);
     *          // return true to treat the task as the propagation source
     *          return true;
     *      }
     *  );
     * ```
     *
     *  If changer is not given or it's equal to Ext.emptyFn then propagation will be forcefully executed and tasks
     *  will be aligned/constrained according to their dependencies and/or constraints.
     * @param {Gnt.model.Task} changer.task The task
     * @param {Boolean/Gnt.model.Task/Gnt.model.Task[]} [changer.return] A changer might return:
     *
     *  - `true` - in this case the task will be considered as propagation source and propagation will be done only
     *    if the task has outstanding changes;
     *  - `false` or nothing - to cancel changes and skip propagation entirely;
     *  - a task instance, or an array of task instances - to consider given instances as propagation source(s) and do
     *    the propagation
     *
     * @param {Function} [callback] A callback function which will be called after changes propagation.
     * @param {Boolean}  callback.cancel Flag showing whether entire changes transaction has been canceled
     *  and nothing is changed.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     * @param {Boolean}  [forceCascadeChanges=task store `cascadeChanges` option] Flag indicating whether to propagate changes to dependent tasks.
     * @param {Boolean}  [asyncChanger=false] Flag indicating that `changer` function is asynchronous.
     * @param {Boolean}  [forceMoveParentAsGroup=task store `forceMoveParentAsGroup` option] Flag indicating whether to propagate changes to child nodes.
     */
    propagateChanges: function(changer, callback, forceCascadeChanges, asyncChanger, forceMoveParentAsGroup) {
        var me = this,
            cascadeChanges, moveParentAsGroup, propagationSources, taskStore;
        taskStore = me.getTaskStore(true);
        cascadeChanges = typeof forceCascadeChanges === 'boolean' ? forceCascadeChanges : taskStore && taskStore.cascadeChanges;
        moveParentAsGroup = typeof forceMoveParentAsGroup === 'boolean' ? forceMoveParentAsGroup : taskStore && taskStore.moveParentAsGroup;
        // We are currently propagating
        if (me.propagating) {
            callback && callback(true, {});
        } else {
            var context = me.initializePropagation(),
                changerArguments = [
                    me
                ];
            // If "changer" function is asynchronous we provide it with a function that should be called to continue the propagation
            if (asyncChanger) {
                changerArguments.push(function(propagationSources) {
                    me.continutePropagateChanges(context.cascadeBatch, context.affectedTasks, propagationSources, callback, cascadeChanges, moveParentAsGroup);
                });
            }
            try {
                propagationSources = (changer && changer !== Ext.emptyFn) ? changer.apply(this, changerArguments) : [
                    me
                ];
            } catch (e) {
                me.finalizePropagation(true);
                throw e;
            }
            if (!asyncChanger) {
                me.continutePropagateChanges(context.cascadeBatch, context.affectedTasks, propagationSources, callback, cascadeChanges, moveParentAsGroup);
            }
        }
    },
    /**
     * @private
     *
     * @param {Array} linearWalkingSequence
     * @param {Gnt.model.Task} linearWalkingSequence.0 Step task
     * @param {String}         linearWalkingSequence.1 Color of the visiting step
     *  - 'green'  - Task is ready to be processed
     *  - 'yellow' - Branch task is ready to process it's children
     * @param {Object}         linearWalkingSequence.2 Set of all collected dependent tasks
     * @param {Object}         linearWalkingSequence.3 Dependency data
     * @param {Gnt.data.TaskStore} taskStore
     * @param {Object}             cascadeBatch
     * @param {Gnt.model.Task[]}   propagationSources
     * @param {Boolean}            forceCascadeChanges
     * @param {Object}             affectedTasks
     * @param {Function}           callback
     * @param {Integer}            startAt
     */
    propagateChangesThroughDependentTasks: function(linearWalkingSequence, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback, startAt) {
        var me = this,
            i, len, constraintSatisfied;
        startAt = startAt || 0;
        constraintSatisfied = true;
        for (i = startAt , len = linearWalkingSequence.length; constraintSatisfied && i < len; ++i) {
            constraintSatisfied = me.processTaskConstraints(linearWalkingSequence, i, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, function(linearWalkingIndex, constraintSatisfied, propagationCanceled, affectedTasks) {
                // This callback might be called either synchronously or asynchronously thus we can't rely on
                // `i` variable here. That's because if it is called synchronously then `i` will not yet be
                // incremented by the for loop counter incrementing part, and if it's called asynchronously
                // then `i` will be already incremented by the for loop directive. Thus we got the index
                // for which this callback is called for as a parameter
                // Stop condition
                if (propagationCanceled || (linearWalkingIndex == len - 1)) {
                    //  if two-step propagation was used let's glue affected tasks objects of 1st and 2nd step
                    if (cascadeBatch.step1AffectedTasks) {
                        Ext.apply(affectedTasks, cascadeBatch.step1AffectedTasks);
                    }
                    //  ..do the same for BW compat cascadeBatch structure
                    if (cascadeBatch.step1CascadeBatch) {
                        Ext.apply(cascadeBatch.step1CascadeBatch.affected, cascadeBatch.affected);
                        cascadeBatch.step1CascadeBatch.nbrAffected = Ext.Object.getSize(cascadeBatch.step1CascadeBatch.affected);
                    }
                    callback(propagationCanceled, affectedTasks);
                }
                // Continue by recursion condition
                else if (!constraintSatisfied) {
                    me.propagateChangesThroughDependentTasks(linearWalkingSequence, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback, linearWalkingIndex + 1);
                }
            });
        }
    },
    // Else constraint is satisfied and we will continue by the for loop
    areLinkedTasksAffectedOrPropagationSourcesLinked: function(task, dependencies, affectedTasks, propagationSources) {
        var result = false,
            i, len, dep, linkedTask;
        for (i = 0 , len = dependencies.length; !result && i < len; ++i) {
            dep = dependencies[i];
            linkedTask = dep.getTargetTask() === task ? dep.getSourceTask() : dep.getTargetTask();
            result = linkedTask && affectedTasks.hasOwnProperty(linkedTask.getId()) || Ext.Array.contains(propagationSources, linkedTask);
        }
        return result;
    },
    processParentMoveAsGroup: function(task, taskStore, cascadeBatch, propagationSources, affectedTasks) {
        var scheduleBackwards = task.getProjectScheduleBackwards(taskStore),
            scheduleByConstraints = taskStore.scheduleByConstraints,
            recalculateParents = taskStore.recalculateParents,
            parentNode = task.parentNode,
            parentNodeStartDate = parentNode && (parentNode.getStartDate()),
            parentNodeUnprojectedStartDate = parentNode && (parentNode.getUnprojected(parentNode.startDateField)),
            parentNodeEndDate = parentNode && (parentNode.getEndDate()),
            offsetFromParent;
        // We ignore case when parent StartDate (EndDate in bw mode) is not specified since we cannot calculate proper dates to shift child tasks at
        if (!scheduleBackwards && parentNodeStartDate || scheduleBackwards && parentNodeEndDate) {
            // BW compat mode
            if (!scheduleByConstraints) {
                var startDate = task.getStartDate();
                if (startDate >= parentNodeUnprojectedStartDate) {
                    offsetFromParent = task.calculateDuration(parentNodeUnprojectedStartDate, startDate, null, {
                        segments: false
                    });
                    task.setStartDateWithoutPropagation(task.calculateEndDate(parentNodeStartDate, offsetFromParent, null, {
                        segments: false
                    }));
                } else // if the summary task starts after this one
                {
                    // force to not take segments into account during new start date calculating
                    offsetFromParent = task.calculateDuration(startDate, parentNodeUnprojectedStartDate, null, {
                        segments: false
                    });
                    task.setStartDateWithoutPropagation(task.calculateStartDate(parentNodeStartDate, offsetFromParent, null, {
                        segments: false
                    }));
                }
                // Passing a parent node here limits the constraining to incoming dependencies incoming from
                // that parent node descendants only, outer nodes are not taken into account
                this.areLinkedTasksAffectedOrPropagationSourcesLinked(task, scheduleBackwards ? task.getOutgoingDependencies(true) : task.getIncomingDependencies(true), affectedTasks, propagationSources) && task.scheduleWithoutPropagation({
                    shallow: !task.isContraryScheduled(taskStore, null, scheduleBackwards),
                    taskStore: taskStore,
                    parentNode: parentNode,
                    currentCascadeBatch: cascadeBatch
                });
            } else // in scheduleByConstraints mode we simply trigger the task rescheduling
            {
                task.scheduleWithoutPropagation({
                    shallow: !task.isContraryScheduled(taskStore, null, scheduleBackwards),
                    taskStore: taskStore,
                    currentCascadeBatch: cascadeBatch,
                    treatAsLeaf: task.hasChildNodes()
                });
                // Since summary task early dates (and late ones) are calculated based on its children
                // and on this stage we haven't stepped through the children yet (the changes are not applied to them).
                // So let's simply mark children for further scheduling and they will be processed on the next steps.
                task.cascadeBy(function(child) {
                    // mark leaves (and parents if "recalculateParents" is disabled)
                    if (!Ext.Array.contains(propagationSources, child) && (task.isLeaf() || !recalculateParents)) {
                        task.markForRescheduling();
                    }
                });
            }
        }
    },
    /**
     * @private
     *
     * Will return `false` if a constraint conflict has been detected and awaiting for resolution, once resolved
     * the callback method will be called.
     */
    processTaskConstraints: function(linearWalkingSequence, linearWalkingIndex, taskStore, cascadeBatch, propagationSources, forceCascadeChanges, affectedTasks, callback) {
        var step = linearWalkingSequence[linearWalkingIndex],
            task = step[0],
            color = step[1],
            isParent = task.hasChildNodes(),
            isLeaf = !isParent,
            needsRescheduling = task.isMarkedForRescheduling(),
            autoScheduled = !(task.isManuallyScheduled() || task.isCompleted() || task.isReadOnly() || Ext.Array.contains(propagationSources, task)),
            cascadeChanges = forceCascadeChanges || taskStore.cascadeChanges,
            scheduleBackwards = task.getProjectScheduleBackwards(taskStore),
            scheduleByConstraints = taskStore.scheduleByConstraints,
            recalculateParents = taskStore.recalculateParents,
            moveParentAsGroup = taskStore.moveParentAsGroup,
            parentNode = task.parentNode,
            parentNodeStartDate = parentNode && (parentNode.getStartDate()),
            parentNodeUnprojectedStartDate = parentNode && (parentNode.getUnprojected(parentNode.startDateField)),
            parentNodeEndDate = parentNode && (parentNode.getEndDate()),
            parentNodeUnprojectedEndDate = parentNode && (parentNode.getUnprojected(parentNode.endDateField)),
            parentNodeDateOffset = parentNode && affectedTasks[parentNode.getId()] && (scheduleBackwards ? parentNodeEndDate - parentNodeUnprojectedEndDate : parentNodeStartDate - parentNodeUnprojectedStartDate),
            skipConstraintsVerification = false,
            result;
        switch (true) {
            case autoScheduled && isLeaf && color == 'green' && parentNodeDateOffset && moveParentAsGroup:
            case autoScheduled && isParent && color == 'yellow' && parentNodeDateOffset && moveParentAsGroup:
                task.processParentMoveAsGroup(task, taskStore, cascadeBatch, propagationSources, affectedTasks);
                break;
            case isLeaf && color == 'green' && needsRescheduling:
            case isParent && color == 'yellow' && needsRescheduling:
                task.scheduleWithoutPropagation({
                    shallow: !task.isContraryScheduled(taskStore, null, scheduleBackwards),
                    taskStore: taskStore,
                    currentCascadeBatch: cascadeBatch
                });
                break;
            case autoScheduled && isLeaf && color == 'green' && cascadeChanges:
            case autoScheduled && isParent && color == 'yellow' && cascadeChanges:
                if (this.areLinkedTasksAffectedOrPropagationSourcesLinked(task, scheduleBackwards ? task.getOutgoingDependencies(true) : task.getIncomingDependencies(true), affectedTasks, propagationSources)) {
                    // If we need to schedule a summary task
                    if (isParent) {
                        if (moveParentAsGroup) {
                            // BW compat: pass special flag "treatAsLeaf" forcing to calculate ES/EE dates as for non-summary tasks (trying to comply the old behavior)
                            task.scheduleWithoutPropagation({
                                shallow: !task.isContraryScheduled(taskStore, null, scheduleBackwards),
                                taskStore: taskStore,
                                currentCascadeBatch: cascadeBatch,
                                treatAsLeaf: true
                            });
                        }
                        // If we are in the "scheduleByConstraints" mode
                        if (scheduleByConstraints) {
                            // Since summary task early dates (and late ones) are calculated based on its children
                            // and on this stage we haven't stepped through the children yet (the changes are not applied to them).
                            // So let's simply mark children for further scheduling and they will be processed on the next steps.
                            task.cascadeBy(function(child) {
                                // mark leaves (and parents if "recalculateParents" is disabled)
                                if (!Ext.Array.contains(propagationSources, child) && (task.isLeaf() || !recalculateParents)) {
                                    task.markForRescheduling();
                                }
                            });
                            // no need to verify the task constraints yet
                            skipConstraintsVerification = true;
                        }
                    } else // if it's a leaf task we simply reschedule it
                    {
                        task.scheduleWithoutPropagation({
                            shallow: !task.isContraryScheduled(taskStore, null, scheduleBackwards),
                            taskStore: taskStore,
                            currentCascadeBatch: cascadeBatch
                        });
                    }
                };
                // If it's a parent task and "recalculateParents" is enabled then we haven't finished w/ the task positioning yet.
                // So let's skip the task constraints check at this step. We can do it later.
                skipConstraintsVerification = skipConstraintsVerification || isParent && recalculateParents;
                break;
            case isParent && color == 'green' && recalculateParents:
                task.refreshCalculatedParentNodeData();
                break;
        }
        // If the propagation has finished done with the task
        // but it's still marked as requiring rescheduling let's reset the mark (to not affect further propagations)
        if (color == 'green' && task.isMarkedForRescheduling()) {
            task.unmarkForRescheduling();
        }
        if (task.isProjected(true)) {
            cascadeBatch.addAffected(task);
            affectedTasks[task.getId()] = task;
        }
        var proceedOnVerificationIsDoneCallback = function(constraintSatisfied, propagationCanceled) {
                var yellowStep, yellowStepIdx;
                // In case a parent node is adjusted according to its children and such an adjustment violates
                // the parent node constraint then we rewind back to the same parent node yellow step to readjust
                // it and its children once again allowing a user to reconsider (by showing him constraint violation
                // dialog, for example). We rewind by calling a callback with adjusted step index.
                if (!constraintSatisfied && isParent && autoScheduled && taskStore.recalculateParents && color == 'green') {
                    yellowStep = Ext.Array.findBy(linearWalkingSequence, function(step, index) {
                        var stepTask = step[0],
                            stepColor = step[1];
                        yellowStepIdx = index;
                        return task === stepTask && stepColor == 'yellow';
                    });
                    // yellowStep must always be present in the linear walking sequence.
                    callback(yellowStepIdx, constraintSatisfied, !!propagationCanceled, affectedTasks);
                } else {
                    callback(linearWalkingIndex, constraintSatisfied, !!propagationCanceled, affectedTasks);
                }
            };
        // if verification should be skipped we proceed to the next step by calling "proceedOnVerificationIsDoneCallback" manually
        if (skipConstraintsVerification) {
            proceedOnVerificationIsDoneCallback(true, false);
            result = true;
        } else {
            // otherwise we do verification by calling "task.verifyConstraints()" and "proceedOnVerificationIsDoneCallback" will be called there
            result = task.verifyConstraints(proceedOnVerificationIsDoneCallback, affectedTasks);
            // flexible constraints (ASAP/ALAP) could change the task data during the verification, so let's update affectedTasks one more time
            if (task.isProjected(true)) {
                cascadeBatch.addAffected(task);
                affectedTasks[task.getId()] = task;
            }
        }
        return result;
    },
    removeLinkToTask: function(task) {
        var depStore = this.getDependencyStore();
        var task1Id = this.getId();
        var task2Id = task.getId();
        Ext.Array.each(this.getAllDependencies(), function(dep) {
            if ((dep.getSourceId() === task1Id && dep.getTargetId() === task2Id) || (dep.getSourceId() === task2Id && dep.getTargetId() === task1Id)) {
                depStore.remove(dep);
                return false;
            }
        });
    },
    getGroupValue: function(fieldName) {
        var field = this.getField(fieldName);
        if (field.getGroupValue) {
            return field.getGroupValue(this);
        }
        return this.get(fieldName);
    },
    convertEmptyParentToLeafTask: function() {
        this.beginEdit();
        this.set('leaf', true);
        this.setDurationWithoutPropagation(1, this.getDurationUnit());
        this.endEdit();
    },
    hasEndPredecessorsButNoStartPredecessors: function() {
        var incoming = this.getIncomingDependencies();
        var result = incoming.length > 0;
        var Type = Gnt.model.Dependency.Type;
        Ext.Array.each(incoming, function(dep) {
            if (dep.getType() === Type.StartToStart || dep.getType() === Type.EndToStart) {
                return result = false;
            }
        });
        return result;
    },
    /**
     * Indicates if the task is completed (its percent completion is 100%).
     * Completed tasks are not affected by incoming dependencies.
     * @return {Boolean} `true` if the task is completed.
     */
    isCompleted: function() {
        return this.getPercentDone() >= 100;
    },
    /**
     * Indicates if the task is started (its percent completion is greater than zero).
     * @return {Boolean} `true` if the task is started.
     */
    isStarted: function() {
        return this.getPercentDone() > 0;
    },
    /**
     * Indicates if the task is in progress (its percent completion is greater than zero and less than 100%).
     * @return {Boolean} `true` if the task is in progress.
     */
    isInProgress: function() {
        return this.isStarted() && !this.isCompleted();
    },
    autoCalculateLag: function() {
        var dependencyStore = this.getDependencyStore();
        if (!dependencyStore || !dependencyStore.autoCalculateLag || !this.hasIncomingDependencies())  {
            return;
        }
        
        var deps = this.getIncomingDependencies();
        for (var i = 0; i < deps.length; i++) {
            dependencyStore.updateAutoCalculatedLag(deps[i]);
        }
    },
    assignAndUnassignAssignments: function(toUnassign, newAssignments, callback) {
        var me = this,
            cancelFns = [];
        if (toUnassign.length === 0 && newAssignments.length === 0) {
            return;
        }
        // array of functions to cancel assignments/unassignments made
        var assignmentStore = me.getAssignmentStore();
        assignmentStore.suspendAutoSync();
        me.propagateChanges(function() {
            return me.assignAndUnassignAssignmentsWithoutPropagation(toUnassign, newAssignments, function(fns) {
                cancelFns = fns;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            // if we need to cancel changes we run all cancel callbacks provided in reverse order
            cancelChanges && cancelFns.length && Ext.each(cancelFns, function(cancelFn) {
                cancelFn();
            }, this, true);
            assignmentStore.resumeAutoSync();
            if (!cancelChanges) {
                // Fire this event so UI can just react and update the row for the task
                assignmentStore.fireEvent('taskassignmentschanged', assignmentStore, me.id, newAssignments);
                if (assignmentStore.autoSync) {
                    assignmentStore.sync();
                }
            }
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    assignAndUnassignAssignmentsWithoutPropagation: function(toUnassign, newAssignments, cancelAndResultFeedback) {
        var me = this;
        var cancelFns = [];
        toUnassign.forEach(function(resource) {
            me.unassignWithoutPropagation(resource, function cancelFeedback(fn) {
                cancelFns.push(fn);
            });
        });
        newAssignments.forEach(function(assignment) {
            var resource = assignment.getResource(me.getResourceStore());
            resource && me.assignWithoutPropagation(resource, assignment.getUnits(), function cancelFeedback(fn) {
                cancelFns.push(fn);
            }, assignment.data);
        });
        me.adjustToCalendarWithoutPropagation();
        cancelAndResultFeedback && cancelAndResultFeedback(cancelFns);
        return [
            me
        ];
    }
});

/**

@class Gnt.model.task.Constraints
@mixin
@protected

Internal mixin class providing additional logic and functionality related to task constraints.

*/
Ext.define('Gnt.model.task.Constraints', {
    requires: [
        'Gnt.constraint.Base',
        'Gnt.constraint.AsLateAsPossible',
        'Gnt.constraint.AsSoonAsPossible',
        'Gnt.constraint.StartNoEarlierThan',
        'Gnt.constraint.StartNoLaterThan',
        'Gnt.constraint.FinishNoEarlierThan',
        'Gnt.constraint.FinishNoLaterThan',
        'Gnt.constraint.MustStartOn',
        'Gnt.constraint.MustFinishOn',
        'Gnt.constraint.implicit.Dependency',
        'Gnt.constraint.implicit.PotentialConflict'
    ],
    // Checks if the task constraint is not applicable for the task
    // (some constraints are meant to be used for leaf nodes only for example)
    resetConstraintIfNotApplicable: function() {
        var constraint = this.getConstraintClass();
        if (constraint && !constraint.isApplicable(this)) {
            this.beginEdit();
            this.set(this.constraintTypeField, '');
            this.set(this.constraintDateField);
            this.endEdit();
        }
    },
    /**
     * @propagating
     * Sets the constraint type and constraining date (if applicable) to the task.
     *
     * @param {String} type
     *  Constraint type, see {@link #setConstraintType} for further description.
     * @param {Date}   date
     *  Constraint date
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for cancelling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraint: function(type, date, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setConstraintWithoutPropagation(type, date);
        }, callback);
    },
    setConstraintWithoutPropagation: function(type, date, skipRescheduling) {
        var me = this,
            taskStore = me.getTaskStore(true),
            scheduleByConstraints = taskStore && taskStore.scheduleByConstraints,
            constraint;
        if (type) {
            constraint = Gnt.constraint.Base.getConstraintClass(type);
        }
        if (!date && constraint) {
            date = constraint.getInitialConstraintDate(me, date);
        }
        me.beginEdit();
        me.set(me.constraintTypeField, type || '');
        me.set(me.constraintDateField, date);
        // If we have to schedule based on constraints data we need to reset early/late dates cache
        if (scheduleByConstraints) {
            // reset early/late dates cache
            taskStore.resetEarlyDates();
            taskStore.resetLateDates();
            if (!skipRescheduling)  {
                me.scheduleWithoutPropagation();
            }
            
        }
        me.endEdit();
        return true;
    },
    /**
     * @propagating
     * Sets the constraint type of the task. The type string can be one of the following values:
     *
     *  - "startnoearlierthan"
     *  - "startnolaterthan"
     *  - "muststarton"
     *  - "finishnoearlierthan"
     *  - "finishnolaterthan"
     *  - "mustfinishon"
     *  - "assoonaspossible"
     *  - "aslateaspossible"
     *
     * @param {String} type
     *  Constraint type
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraintType: function(type, callback) {
        this.setConstraint(type, this.getConstraintDate(), callback);
    },
    setConstraintTypeWithoutPropagation: function(type) {
        this.setConstraintWithoutPropagation(type, this.getConstraintDate());
    },
    /**
     * @propagating
     * Sets the constraint date of the task.
     *
     * @param {Date}   date
     *  Constraint date
     * @param {Function} [callback] Callback to call after constraint application and constraint conflict resolution
     *  if any.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setConstraintDate: function(date, callback) {
        this.setConstraint(this.getConstraintType(), date, callback);
    },
    setConstraintDateWithoutPropagation: function(date) {
        this.setConstraintWithoutPropagation(this.getConstraintType(), date);
    },
    /**
     * Checks whether a constraint is set for the task.
     *
     * @return {Boolean}
     */
    hasConstraint: function() {
        return !!this.getConstraintType();
    },
    /**
     * Returns a constraint singleton class corresponding to the constraint type currently set for the task.
     *
     * @return {Gnt.constraint.Base} subclass of
     */
    getConstraintClass: function() {
        return Gnt.constraint.Base.getConstraintClass(this.getConstraintType());
    },
    /**
     * Returns true if task has no constraint set or if a constraint set is satisfied by the task.
     *
     * @return {Boolean}
     */
    isConstraintSatisfied: function() {
        var me = this;
        return !me.hasConstraint() || me.getConstraintClass().isSatisfied(me, me.getConstraintDate());
    },
    getDependencyConstraintClass: function() {
        return Gnt.constraint.implicit.Dependency;
    },
    getPotentialConflictConstraintClass: function() {
        return Gnt.constraint.implicit.PotentialConflict;
    },
    isDependencyConstraintSatisfied: function() {
        var taskStore = this.getTaskStore(true),
            checkDependencies = taskStore && taskStore.checkDependencyConstraint;
        return !checkDependencies || this.getDependencyConstraintClass().isSatisfied(this);
    },
    // Extension point to provide a custom set of constraints
    getConstraintClasses: function() {
        var constraintClass = this.getConstraintClass();
        return constraintClass ? [
            constraintClass
        ] : [];
    },
    /**
     * Verifies the constraints of the task.
     *
     * @param {Function} [onceResolvedContinueHere] Callback function to be called after constraint conflict resolution.
     * @param {Boolean}  onceResolvedContinueHere.constraintSatisfied Flag showing whether constraint has been satisfied or violated.
     * @param {Boolean}  onceResolvedContinueHere.cancelChanges Flag showing whether a user has opted for changes to be canceled.
     * @param {Object} By id map of affected tasks
     * @return {Boolean} True if no constraint conflict has been found, false otherwise
     *
     * @private
     */
    verifyConstraints: function(onceResolvedContinueHere, affectedTasks) {
        return this.doVerifyConstraints(this.getConstraintClasses(), onceResolvedContinueHere, false, affectedTasks);
    },
    doVerifyConstraints: function(constraintClasses, onceResolvedContinueHere, useCallbackAsIs, affectedTasks) {
        var me = this,
            taskStore = me.getTaskStore(true),
            hasConflictListener = taskStore && taskStore.hasListener('constraintconflict'),
            constraintDate = me.getConstraintDate(),
            constraintSatisfied = true,
            constraintResolutionContext, constraintClass, restartCallback, callback;
        if (!constraintClasses.length && onceResolvedContinueHere) {
            callback = useCallbackAsIs ? onceResolvedContinueHere : Ext.Function.pass(onceResolvedContinueHere, [
                true
            ]);
        }
        for (var i = 0; i < constraintClasses.length; i++) {
            constraintClass = constraintClasses[i];
            constraintSatisfied = false;
            if (constraintClass && constraintClass.hasThisConstraintApplied(me)) {
                constraintSatisfied = constraintClass.isSatisfied(me, constraintDate);
                // If the constraint claims it can resolve the violation w/o alerting anyone
                if (!constraintSatisfied && constraintClass.canResolve(me, constraintDate)) {
                    constraintClass.resolve(me, constraintDate);
                    constraintSatisfied = true;
                }
            } else {
                constraintSatisfied = true;
            }
            // We bind the callback to [constraintSatisfied] array as its arguments list
            // unless useCallbackAsIs flag is passed. The flag is used when we repeat verification call
            // which means the callback is already wrapped and we don't want to do it twice.
            if (onceResolvedContinueHere) {
                callback = useCallbackAsIs ? onceResolvedContinueHere : Ext.Function.pass(onceResolvedContinueHere, [
                    constraintSatisfied
                ]);
            }
            if (!constraintSatisfied && constraintClass) {
                // Let's make a callback that will repeat the constraints check cycle
                // after user will pick a resolution option
                restartCallback = callback && function(cancelChanges, restartVerification) {
                    // if user picked to cancel changes we don't need extra verification
                    if (cancelChanges || !restartVerification) {
                        me._doVerifyConstraintsWatcher = null;
                        callback.apply(this, arguments);
                    }
                    // if user has used some other option, let's repeat the verification cycle
                    else if (restartVerification) {
                        me.doVerifyConstraints(me.getConstraintClasses(), callback, true, affectedTasks);
                    }
                };
                constraintResolutionContext = constraintClass.getResolution(restartCallback, me, null);
                constraintResolutionContext.affectedTasks = affectedTasks;
                // check for infinite loop
                me._doVerifyConstraintsWatcher = me._doVerifyConstraintsWatcher || {};
                // if the constraint was violated earlier - it's an infinite cycle
                // (and if there is no conflict resolution UI attached)
                if (me._doVerifyConstraintsWatcher[constraintClass.getId()] && !hasConflictListener) {
                    // let's cancel the changes
                    constraintResolutionContext.cancelAction();
                    break;
                }
                // raise a flag marking that this constraint was violated
                me._doVerifyConstraintsWatcher[constraintClass.getId()] = true;
                if (hasConflictListener) {
                    /**
                     * @event constraintconflict
                     *
                     * Fires when task constraint conflict has been found and requires a resolution.
                     *
                     * @param {Gnt.model.Task} task The task whose constraint is violated
                     * @param {Object} context Constraint resolution context
                     * @param {String} context.title The description of the
                     *
                     * @member Gnt.data.TaskStore
                     */
                    taskStore.fireEvent('constraintconflict', me, constraintResolutionContext);
                } else {
                    constraintResolutionContext.defaultAction();
                }
                break;
            }
        }
        if (constraintSatisfied) {
            me._doVerifyConstraintsWatcher = null;
            callback && callback(false);
        }
        return constraintSatisfied;
    }
});

/**

@class Gnt.model.task.Splittable
@mixin
@protected

Internal mixin class providing task splitting logic and functionality belonging to the Task model class.

*/
Ext.define('Gnt.model.task.Splittable', {
    uses: [
        'Gnt.model.TaskSegment'
    ],
    segmentsTrackingSuspended: 0,
    changingTaskBySegments: false,
    segmentsSnapshot: null,
    segmentsProjection: null,
    getFirstSegment: function() {
        var segments = this.getSegments();
        return segments && segments[0];
    },
    getLastSegment: function() {
        var segments = this.getSegments();
        return segments && segments[segments.length - 1];
    },
    normalizeSegments: function() {
        var segments = this.getSegments();
        // we don't wanna hear any response from segments during their normalization
        this.suspendSegmentsTracking();
        // first let sort intervals by its start dates ascending
        segments.sort(function(a, b) {
            if (!a.normalized)  {
                a.normalize();
            }
            
            if (!b.normalized)  {
                b.normalize();
            }
            
            return a.getStartDate() > b.getStartDate() ? 1 : -1;
        });
        // merge overlapped segments if any
        this.mergeOverlappedSegments();
        // if we still have segmentation after merging
        if (this.getSegments()) {
            this.data[this.durationField] = this.getSegmentsDuration();
        }
        this.resumeSegmentsTracking();
    },
    // Refreshes the task segments dates. We have to call this after the task time span change.
    updateSegmentsDates: function(options) {
        options = options || {};
        if (!this.isSegmented())  {
            return;
        }
        
        // we don't want to catch response from segments
        this.suspendSegmentsTracking();
        options = Ext.apply({
            useAbsoluteOffset: false
        }, options);
        options.isForward = options.isForward !== false;
        var segmentsModified = false;
        this.forEachSegment(function(segment) {
            segment.updateDatesByOffsets(options);
            // remember any segment was actually modified
            segmentsModified = segmentsModified || Boolean(segment.modified);
        }, options.isForward);
        // need to set Segments field dirty
        if (segmentsModified) {
            this.set(this.segmentsField, this.getSegments().slice());
        }
        this.resumeSegmentsTracking();
    },
    getSegmentIntervalsForRange: function(from, till, segments) {
        segments = segments || this.getSegments();
        if (!segments)  {
            return;
        }
        
        var DATE = Sch.util.Date,
            result = [];
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var part = segments[i],
                segmentStart = part.getStartDate(),
                segmentEnd = part.getEndDate();
            if (DATE.intersectSpans(from, till, segmentStart, segmentEnd)) {
                result.push([
                    DATE.constrain(segmentStart, from, till) - 0,
                    DATE.constrain(segmentEnd, from, till) - 0
                ]);
            }
        }
        return result.length && result || null;
    },
    /**
     * Returns a segment that is ongoing on the provided date.
     * @param  {Date} date Date to find an ongoing segment on
     * @param  {Gnt.model.TaskSegment[]} [segments] List of segments to check. When not provided the task segments is used
     * @return {Gnt.model.TaskSegment} Ongoing segment
     */
    getSegmentByDate: function(date, segments) {
        segments = segments || this.getSegments();
        if (!segments)  {
            return;
        }
        
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var part = segments[i];
            if (date >= part.getStartDate() && date < part.getEndDate())  {
                return part;
            }
            
        }
    },
    // Truncates segments that don't fit into task time span (this can be detected either based on the task start/end dates or by comparing with the task duration).
    // @private
    constrainSegments: function(options) {
        // should be called only for the task driven changes, and `this.changingTaskBySegments` means that change initiated by a segment
        if (this.changingTaskBySegments)  {
            return;
        }
        
        options = options || {};
        var segments = this.getSegments();
        if (!segments)  {
            return;
        }
        
        var taskDuration = this.getDuration('MILLI'),
            durationUnit = options.unit || this.getDurationUnit(),
            durationLimit = options.duration,
            startDate = this.getStartDate(),
            endDate = this.getEndDate(),
            converter = this.getUnitConverter();
        if (!startDate || (!endDate && !taskDuration && !durationLimit)) {
            this.set(this.segmentsField, null);
            return;
        }
        if (durationLimit) {
            durationLimit = converter.convertDurationToMs(durationLimit, durationUnit);
        } else if (!endDate) {
            durationLimit = taskDuration;
        }
        // we don't want to catch response from segments
        this.suspendSegmentsTracking();
        segments[0].setStartDateWithoutPropagation(this.getStartDate(), false);
        // now let's loop over array and merge overlapping intervals
        var toRemove = [],
            durationLeft = durationLimit,
            current, previous;
        var toRemoveChecker;
        // we check if segment fits into task timespan using either task end date or task duration depending on options provided
        if (durationLimit) {
            toRemoveChecker = function() {
                return durationLeft <= 0;
            };
        } else {
            toRemoveChecker = function(segment) {
                return segment.getStartDate() >= endDate;
            };
        }
        for (var i = 0,
            l = segments.length; i < l; i++) {
            current = segments[i];
            // we get rid of segments that do not fit into task timespan
            if (toRemoveChecker(current)) {
                toRemove.push.apply(toRemove, segments.slice(i));
                break;
            }
            durationLeft -= current.getDuration('MILLI');
            previous = current;
        }
        // remove segments swallowed during merge
        this.removeSegments(toRemove);
        if (segments.length < 2) {
            this.set(this.segmentsField, null);
        } else {
            var last = this.getLastSegment();
            var lastAdjusted = false;
            // if we constrain using duration
            if (durationLimit) {
                if (durationLeft) {
                    last.setDurationWithoutPropagation(converter.convertMSDurationToUnit(last.getEndOffset() - last.getStartOffset() + durationLeft, last.getDurationUnit()));
                    lastAdjusted = true;
                }
            } else {
                if (last.getEndDate() - endDate) {
                    last.setEndDateWithoutPropagation(endDate, false);
                    lastAdjusted = true;
                }
            }
            // if we modified segments and field is not marked as modified yet
            var taskStore = this.getTaskStore(true),
                isProjecting = taskStore && taskStore.isProjecting();
            if ((toRemove.length || lastAdjusted) && (isProjecting || !this.modified || !this.modified[this.segmentsField])) {
                this.set(this.segmentsField, this.getSegments().slice());
            }
        }
        this.resumeSegmentsTracking();
    },
    forEachSegment: function(fn, isForward, startSegment, scope) {
        if (!fn)  {
            return;
        }
        
        scope = scope || this;
        var method, segment;
        if (isForward !== false) {
            // method to walk down the segments available
            method = 'getNextSegment';
            // initial segment
            segment = startSegment || this.getFirstSegment();
        } else {
            method = 'getPrevSegment';
            segment = startSegment || this.getLastSegment();
        }
        while (segment) {
            if (fn.call(scope, segment) === false)  {
                return;
            }
            
            segment = segment[method].call(segment);
        }
    },
    /**
     * @propagating
     * Splits a task.
     * @param {Date} from The date to split this task at.
     * @param {Number} [duration=1] Split duration.
     * @param {String} [unit=d] Split duration unit.
     * @param {Boolean} [skipNonWorkingTime] Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     * Default is `false`
     * @param {Function} [callback] Callback function to call after task has been split and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    split: function(from, duration, unit, skipNonWorkingTime, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.splitWithoutPropagation(from, duration, unit, skipNonWorkingTime, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    splitWithoutPropagation: function(from, duration, unit, skipNonWorkingTime, cancelFeedback) {
        var me = this;
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            var taskStore = me.getTaskStore(true);
            skipNonWorkingTime = taskStore ? taskStore.skipWeekendsDuringDragDrop : false;
        }
        // cannot split:
        // - if no split date specified
        // - a summary task
        // - a milestone
        if (!from || !me.isLeaf() || me.isMilestone())  {
            return;
        }
        
        var startDate = me.getStartDate(),
            endDate = me.getEndDate();
        // - not scheduled task
        // - provided date violates task interval
        if (!startDate || !endDate || (startDate >= from) || (from >= endDate))  {
            return;
        }
        
        var segments = me.getSegments(),
            segmentToSplit;
        // let's make a snapshot to rollback in case of some constraint violation
        var snapshot = me.buildSegmentsSnapshot(segments);
        if (segments) {
            segmentToSplit = me.getSegmentByDate(from);
            if (!segmentToSplit)  {
                return;
            }
            
        } else {
            segments = [];
        }
        duration = duration || 1;
        unit = unit || this.getDurationUnit();
        var date = new Date(from),
            splitStart = date,
            splitEnd = date,
            durationMS = me.getUnitConverter().convertDurationToMs(duration, unit);
        if (skipNonWorkingTime) {
            splitEnd = me.skipNonWorkingTime(splitEnd, true, true);
            splitStart = me.skipNonWorkingTime(splitStart, false, true);
        }
        // exit if split date is in a large gap between working periods of time
        // if (splitEnd - splitStart  > durationMS) return;
        var taskDurationUnit = me.getDurationUnit(),
            segmentPrototype = Ext.ClassManager.get(me.segmentClassName).prototype,
            firstPieceDuration, secondPieceDuration, segmentData;
        // suspend to not call onSegmentsChanged on every segment modification
        // we call it one time on the last step
        me.suspendSegmentsTracking();
        var addSegment = true;
        // split not segmented task
        if (!segmentToSplit) {
            firstPieceDuration = me.calculateDuration(startDate, splitStart);
            secondPieceDuration = me.getDuration() - firstPieceDuration;
            segmentData = {
                task: me
            };
            segmentData[segmentPrototype.startDateField] = startDate;
            segmentData[segmentPrototype.durationField] = firstPieceDuration;
            segmentData[segmentPrototype.durationUnitField] = taskDurationUnit;
            var segmentToAdd = Ext.create(me.segmentClassName, segmentData);
            if (!segmentToAdd.normalized)  {
                segmentToAdd.normalize();
            }
            
            segments.push(segmentToAdd);
        } else // split existing segment
        {
            firstPieceDuration = me.calculateDuration(segmentToSplit.getStartDate(), splitStart, taskDurationUnit);
            secondPieceDuration = segmentToSplit.getDuration(taskDurationUnit) - firstPieceDuration;
            // we don't create a new segment if split date falls on a segment start
            // in this case we just push the segment further by split duration length
            addSegment = !!firstPieceDuration;
            var pushFrom;
            if (addSegment) {
                segmentToSplit.setEndDateWithoutPropagation(splitStart, false, skipNonWorkingTime);
                // push segments starting from the next after the clicked one
                pushFrom = segmentToSplit.getNextSegment();
            } else // if we don't split the clicked segment
            // we push segments starting from it
            {
                pushFrom = segmentToSplit;
            }
            // shift all further segments by provided duration
            if (pushFrom) {
                me.forEachSegment(function(s) {
                    s.setStartEndOffset(s.getStartOffset() + durationMS, s.getEndOffset() + durationMS);
                    s.updateDatesByOffsets();
                }, true, pushFrom);
            }
        }
        // if we need to create a new segment
        if (addSegment) {
            // take split duration into account
            splitEnd = me.skipWorkingTime(splitEnd, durationMS);
            if (skipNonWorkingTime) {
                // adjust to calendar if required
                splitEnd = me.skipNonWorkingTime(splitEnd);
            }
            segmentData = {
                prevSegment: segmentToSplit || segments[0],
                task: me
            };
            segmentData[segmentPrototype.startDateField] = splitEnd;
            segmentData[segmentPrototype.durationField] = secondPieceDuration;
            segmentData[segmentPrototype.durationUnitField] = taskDurationUnit;
            var newSegment = Ext.create(me.segmentClassName, segmentData);
            if (!newSegment.normalized)  {
                newSegment.normalize();
            }
            
            if (segmentToSplit) {
                Ext.Array.insert(segments, Ext.Array.indexOf(segments, segmentToSplit) + 1, [
                    newSegment
                ]);
            } else {
                segments.push(newSegment);
            }
        }
        me.resumeSegmentsTracking();
        cancelFeedback && cancelFeedback(function() {
            me.rollbackSegmentsToSnapshot(snapshot);
            me.onSegmentsChanged(null, null);
        });
        if (!segmentToSplit) {
            me.setSegmentsWithoutPropagation(segments);
        } else {
            me.onSegmentsChanged(null, null);
        }
        return true;
    },
    /**
     * @propagating
     * Merges two segments of a task.
     * @param {Gnt.model.TaskSegment} segment1 First segment to merge.
     * @param {Gnt.model.TaskSegment} segment2 Second segment to merge.
     * @param {Function} [callback] Callback function to call after task has been merged and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    merge: function(segment1, segment2, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.mergeWithoutPropagation(segment1, segment2);
        }, callback);
    },
    mergeWithoutPropagation: function(segment1, segment2) {
        if (!this.isSegmented() || !segment1 || !segment2)  {
            return;
        }
        
        var first, second;
        if (segment1.getStartOffset() > segment2.getStartOffset()) {
            first = segment2;
            second = segment1;
        } else {
            first = segment1;
            second = segment2;
        }
        // merging itself will be done automatically inside of `onSegmentsChanged`
        first.setEndDateWithoutPropagation(second.getEndDate(), false);
        return true;
    },
    suspendSegmentsTracking: function() {
        this.segmentsTrackingSuspended++;
    },
    resumeSegmentsTracking: function() {
        this.segmentsTrackingSuspended--;
    },
    // Returns the sum of segments durations.
    getSegmentsDuration: function(unit) {
        unit = unit || this.getDurationUnit();
        var segments = this.getSegments();
        var duration = 0;
        for (var i = 0,
            l = segments.length; i < l; i++) {
            var s = segments[i];
            duration += s.getEndOffset() - s.getStartOffset();
        }
        return this.getUnitConverter().convertMSDurationToUnit(duration, unit);
    },
    mergeOverlappedSegments: function(doNotTruncate) {
        var segments = this.getSegments();
        if (segments) {
            var toRemove = [],
                previous = segments[0],
                current;
            // Check if we should merge segments
            for (var i = 1,
                l = segments.length; i < l; i++) {
                current = segments[i];
                // if `current` segment intersects `previous` segment
                if (current.getStartOffset() <= previous.getEndOffset()) {
                    // we skip the current
                    toRemove.push(current);
                    // if `current` end date is greater than `previous` one we elapse previous segment
                    if (current.getEndOffset() > previous.getEndOffset()) {
                        previous.setEndDateWithoutPropagation(current.getEndDate(), false);
                    }
                } else {
                    // `previous` keeps the last not skipped segment
                    previous = current;
                }
            }
            this.removeSegments(toRemove);
            if (segments.length < 2 && !doNotTruncate) {
                this.setSegmentsWithoutPropagation(null);
            }
        }
    },
    onSegmentEditBegin: function(segment) {
        this.getTreeStore().onSegmentEditBegin(this, segment);
        this.snapshotSegments();
    },
    onSegmentEditEnd: function(segment) {
        this.getTreeStore().onSegmentEditEnd(this, segment);
    },
    onSegmentsChanged: function(segment, modified) {
        if (this.segmentsTrackingSuspended)  {
            return;
        }
        
        this.changingTaskBySegments = true;
        // we don't want to escalate chain of calls
        this.suspendSegmentsTracking();
        // Check if we should merge segments
        // we pass `true` to not truncate segments array if we have 1 element in it (we need this to get duration from it)
        // The array will be completely reset inside of this.set() call
        this.mergeOverlappedSegments(true);
        // segments has been changed so we need re-adjust task to take them into account
        // if segment duration has been changed - task duration has to be updated
        if (segment && modified && segment.durationField in modified) {
            // even after merge here we have at least 1 segment to be able to get duration from it
            this.setDurationWithoutPropagation(this.getSegmentsDuration());
        }
        // for effort driven tasks we use setStartEndDateWithoutPropagation
        // since we might need to recalculate both EndDate and Duration
        else if (this.getSchedulingMode() == 'EffortDriven') {
            this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate());
        } else {
            this.setStartDateWithoutPropagation(this.getStartDate());
        }
        // re-get segments list since it could've been rolled back because of failed propagation
        // inside of setDuration/setStartDate call
        var segments = this.getSegments();
        // set field state to dirty
        this.set(this.segmentsField, segments && segments.slice() || null);
        this.resumeSegmentsTracking();
        this.changingTaskBySegments = false;
    },
    //this.getTreeStore().onSegmentsChanged(segment, modified);
    removeSegments: function(toRemove) {
        var segments = this.getSegments();
        if (segments && toRemove) {
            if (!Ext.isArray(toRemove))  {
                toRemove = [
                    toRemove
                ];
            }
            
            if (toRemove.length) {
                for (var i = 0,
                    l = toRemove.length; i < l; i++) {
                    Ext.Array.remove(segments, toRemove[i]);
                }
                this.onSegmentsChanged();
            }
        }
    },
    /**
     * @propagating
     * Sets list of segments of the split task.
     * @param {Gnt.model.TaskSegment[]/Object[]} value List of segments.
     * @param {Function} [callback] Callback function to call after task end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setSegments: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setSegmentsWithoutPropagation(value);
        }, callback);
    },
    /**
     * Sets list of segments of the split task.
     * @param {Gnt.model.TaskSegment[]/Object[]} value List of segments.
     */
    setSegmentsWithoutPropagation: function(value) {
        this.onSegmentEditBegin();
        this.suspendSegmentsTracking();
        // We call processSegmentsValue(value) here explicitly regardless "Segment" field also does this in its "convert" method.
        // The reason is we might be in the middle of projection and then "model.set()" method is overridden
        // and "converter" is not really called (until projection gets committed).
        this.set(this.segmentsField, this.processSegmentsValue(value));
        this.resumeSegmentsTracking();
        this.onSegmentsChanged();
        this.onSegmentEditEnd();
        return true;
    },
    processSegmentsValue: function(value) {
        var segments, currentSegment, prevSegment;
        // if segments are specified for the task
        if (value) {
            value = [].concat(value);
            segments = [];
            for (var i = 0,
                l = value.length; i < l; i++) {
                currentSegment = value[i];
                if (!(currentSegment instanceof Gnt.model.TaskSegment)) {
                    currentSegment = Ext.create(this.segmentClassName, Ext.apply(currentSegment, {
                        task: this
                    }));
                }
                segments.push(currentSegment);
                prevSegment = currentSegment;
            }
            value = segments && segments.length > 1 && segments || null;
        }
        return value;
    },
    /**
     * Returns `true` if task is segmented and `false` otherwise.
     * @return {Boolean} `true` if task is segmented and `false` otherwise.
     */
    isSegmented: function() {
        return Boolean(this.getSegments());
    },
    /**
     * Gets segment by its index.
     * @param {Number} index Segment index to retrieve (zero based value).
     * @return {Gnt.model.TaskSegment}
     */
    getSegment: function(index) {
        return this.getSegments()[index];
    },
    getLastSegmentsSnapshot: function() {
        var result;
        if (this.segmentsProjection && this.getTaskStore().isProjecting()) {
            var levels = Ext.Object.getKeys(this.segmentsProjection);
            if (levels.length) {
                result = this.segmentsProjection[Ext.Array.max(levels)];
            } else {
                result = this.getSegmentsSnapshot();
            }
        } else {
            result = this.getSegmentsSnapshot();
        }
        return result;
    },
    rejectSegmentsProjection: function() {
        var projectionLevel = this.getTaskStore(true).getProjectionLevel();
        var snapshot, i;
        if (this.segmentsProjection) {
            var snapshotLevel;
            for (i = projectionLevel; i >= 0; i--) {
                if (snapshot = this.segmentsProjection[i]) {
                    snapshotLevel = i;
                    break;
                }
            }
            if (snapshotLevel === projectionLevel) {
                delete this.segmentsProjection[snapshotLevel];
            }
        }
        if (snapshot) {
            this.rollbackSegmentsToSnapshot(snapshot);
        }
    },
    commitSegmentsProjection: function() {
        var taskStore = this.getTaskStore(true),
            projectionLevel = taskStore && taskStore.getProjectionLevel();
        if (this.segmentsProjection) {
            delete this.segmentsProjection[projectionLevel];
        }
    },
    rollbackSegmentsToSnapshot: function(snapshot) {
        this.data[this.segmentsField] = snapshot && Ext.Array.map(snapshot, function(segment) {
            return segment && segment[0].readSnapshot(segment);
        });
    },
    buildSegmentsSnapshot: function(segments) {
        segments = segments || this.getSegments();
        return segments && Ext.Array.map(segments, function(segment) {
            return segment && segment.buildSnapshot();
        });
    },
    getSegmentsSnapshot: function() {
        return this.segmentsSnapshot;
    },
    setSegmentsSnapshot: function(snapshot) {
        this.segmentsSnapshot = snapshot;
        this.hasSegmentsSnapshot = true;
    },
    resetSegmentsSnapshot: function() {
        this.segmentsSnapshot = null;
        this.hasSegmentsSnapshot = false;
    },
    snapshotSegments: function() {
        var taskStore = this.getTaskStore(true),
            segments = this.getSegments(),
            projectionLevel = taskStore && taskStore.getProjectionLevel(),
            snapshot;
        // if taskStore is in the middle of projection let's try to follow it
        // and bind snapshot to previous projection level, to be able to rollback segments
        // after projection rollback
        if (projectionLevel) {
            this.segmentsProjection = this.segmentsProjection || {};
            snapshot = this.segmentsProjection[projectionLevel - 1];
            if (!snapshot) {
                snapshot = this.buildSegmentsSnapshot(segments);
                this.segmentsProjection[projectionLevel - 1] = snapshot;
            }
        }
        // this is a zero level snapshot that is used for task.reject() support
        if (!this.hasSegmentsSnapshot) {
            this.setSegmentsSnapshot(snapshot || this.buildSegmentsSnapshot(segments));
        }
    },
    commitSegments: function() {
        // EtxJS5 calls `commit` during `reject` call. o_O
        if (this.rejecting)  {
            return;
        }
        
        // let's reset snapshot, we will fill it during first attempt to edit this task segments
        this.resetSegmentsSnapshot();
        var segments = this.getSegments();
        if (segments) {
            for (var i = 0,
                l = segments.length; i < l; i++) {
                segments[i].commit();
            }
        }
    },
    rejectSegments: function() {
        // get kept previous segments data
        this.hasSegmentsSnapshot && this.rollbackSegmentsToSnapshot(this.getSegmentsSnapshot());
        this.resetSegmentsSnapshot();
        var segments = this.getSegments();
        if (segments) {
            for (var i = 0,
                l = segments.length; i < l; i++) {
                segments[i].reject();
            }
        }
    }
});

/**
 @class Gnt.model.task.Effort
 @mixin

 Internal mixin class providing task specific effort and work related logic and functionality belonging to the Task model class.
 */
Ext.define('Gnt.model.task.Effort', {
    calculateActualEffort: function() {
        var effort = this.get(this.effortField);
        return effort != null ? effort * this.getPercentDone() / 100 : null;
    },
    /**
     * @method getEffortVariance
     * Returns the effort variance of this task.
     * This is the calculated value of the `Effort` minus the `BaselineEffort` value.
     * @return {Number} The effort variance of this task
     */
    calculateEffortVariance: function() {
        var effort = this.get(this.effortField);
        return effort != null ? effort - this.getBaselineEffort() : null;
    },
    /**
     * @method getBaselineEffort
     * Returns the task effort baseline (the number of {@link #getEffortUnit units}).
     * @return {Number} The task effort baseline value
     */
    /**
     * Sets the task effort baseline.
     * @param {Number}   effort   Effort baseline value
     * @param {String}   unit     Unit name the effort baseline value is provided in
     */
    setBaselineEffort: function(effort, unit) {
        var me = this,
            effortUnit = me.getEffortUnit();
        me.beginEdit();
        me.set(me.baselineEffortField, me.getUnitConverter().convertDuration(effort, unit || effortUnit, effortUnit));
        me.setEffortVariance(me.calculateEffortVariance());
        me.endEdit();
        return true;
    },
    /**
     * @method getActualEffort
     * Returns the actual current effort (the number of {@link #getEffortUnit units}) that has been completed. This number is calculated based on `PercentDone`.
     * @return {Number} The actual current effort value
     */
    /**
     * @propagating
     * Sets the actual current effort that has been completed. Only allowed for leaf tasks.
     * Calling this method will update `PercentDone` field value accordingly.
     * @param {Number}   effort   Effort value
     * @param {String}   unit     Unit name the effort value is provided in
     * @param {Function} [callback] Callback function to call after the actual effort value has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setActualEffort: function(effort, unit, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setActualEffortWithoutPropagation(effort, unit);
        }, callback);
    },
    processActualEffortValue: function(actualEffort) {
        var me = this,
            effort = me.getEffort();
        // TODO: below logic is experimental till we find more correct one (probably after we add all the required "Work*" fields)
        // The "ActualEffort" value cannot be greater than "Effort" value
        if (actualEffort > effort) {
            // if "Effort" is not initialized and we have "PercentDone" > 0
            // let's calculate "Effort" based on the "PercentDone"
            if (!effort && me.getPercentDone()) {
                me.set(me.effortField, actualEffort * 100 / me.getPercentDone());
            } else // otherwise let's update "Effort" w/ "ActualEffort" value
            {
                me.set(me.effortField, actualEffort);
            }
            // since we've modified Effort we need to update EffortVariance accordingly
            me.setEffortVariance(me.calculateEffortVariance());
        }
        return actualEffort;
    },
    setActualEffortWithoutPropagation: function(actualEffort, unit) {
        var me = this,
            effortUnit = me.getEffortUnit(),
            converter = me.getUnitConverter();
        // convert value to effortUnit units
        actualEffort = converter.convertDuration(actualEffort, unit || effortUnit, effortUnit);
        me.beginEdit();
        actualEffort = me.processActualEffortValue(actualEffort);
        me.set(me.actualEffortField, actualEffort);
        var effort = me.getEffort(),
            percentDone = effort ? Math.min(100, 100 * actualEffort / effort) : 0;
        me.set(me.percentDoneField, percentDone);
        me.recalculateCost();
        me.endEdit();
        return true;
    }
});

/**
 @class Gnt.model.task.Cost
 @mixin

 Internal mixin class providing task specific cost related logic and functionality belonging to the Task model class.
 */
Ext.define('Gnt.model.task.Cost', {
    recalculateCost: function() {
        var me = this;
        if (!me.autoCalculateCost)  {
            return false;
        }
        
        me.beginEdit();
        me.setActualCost(me.calculateActualCost());
        me.setCost(me.calculateCost());
        me.endEdit();
        return true;
    },
    calculateActualCost: function() {
        var effort = this.getEffort(),
            actualEffort = this.getActualEffort(),
            result = 0;
        // no effort -> no cost
        if (effort) {
            // Actual Cost = (Actual Work * Standard Rate) + Resource Per Use Costs
            // Since we don't have "ActualEffort" on the resource level we use here task ActualEffort/Effort (which is "PercentDone/100" strictly speaking)
            result = this.calculateResourcesCost(true) * actualEffort / effort + this.calculateResourcesPerUseCost();
        }
        return result;
    },
    /**
     * @method getCostVariance
     * Returns the cost variance of this task.
     * This is the calculated value of the `Cost` minus the `BaselineCost` value.
     * @return {Number} The cost variance of this task
     */
    calculateCostVariance: function() {
        return this.getCost() - this.getBaselineCost();
    },
    // NOTE: "Cost" depends on "ActualCost", "Effort" and "ActualEffort" fields
    calculateCost: function() {
        var me = this,
            effort = me.getEffort(),
            result = 0;
        if (effort) {
            var actualEffort = this.getActualEffort(),
                actualCost = this.getActualCost();
            // Cost = Actual Cost + Remaining Cost
            var remainingEffort = effort - actualEffort,
                // we don't add "Resources Per Use Costs" to the remaining cost
                // if the task has "actualCost" ..assuming that Per Use Costs are already included
                remainingCost = me.calculateResourcesCost(!!actualCost) * remainingEffort / effort;
            result = actualCost + remainingCost;
        }
        return result;
    },
    /**
     * Set the cost baseline for the task.
     * @param number The cost baseline value
     * @returns {boolean}
     */
    setBaselineCost: function(number) {
        var me = this;
        me.beginEdit();
        me.set(me.baselineCostField, number);
        me.setCostVariance(me.calculateCostVariance());
        me.endEdit();
        return true;
    },
    /**
     * @method getActualCost
     * Returns the current cost of the task based on its assignments and % completion.
     * This field is calculated based on assigned resources costs and the actual current effort of the task (`ActualEffort` field).
     * @return {Number} The actual cost for this task
     */
    /**
     * @method getCost
     * Returns the cost of this task.
     * This value is either calculated (if {@link #autoCalculateCost} is enabled) as {@link #getActualCost actual cost} plus remaining cost or {@link #setCost provided manually}.
     * @return {Number} The cost of this task
     */
    /**
     * Set the cost of the task.
     * Don't use this when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is `true` otherwise the provided value will get overriden.
     * @param number The cost value
     * @returns {boolean}
     */
    setCost: function(number) {
        var me = this;
        me.beginEdit();
        me.set(me.costField, number);
        me.setCostVariance(me.calculateCostVariance());
        me.endEdit();
        return true;
    },
    calculateResourcesCost: function(excludePerUseCost) {
        var result = 0,
            effort = this.getEffort();
        // if no effort to do -> cost is zero
        if (effort) {
            var assignments = this.getAssignments(),
                cost = 0,
                perUseCost = 0;
            for (var i = 0; i < assignments.length; i++) {
                var assignment = assignments[i],
                    resource = assignment.getResource();
                if (resource && assignment.getTask()) {
                    cost += assignment.getCost();
                    perUseCost += resource.getPerUseCost();
                }
            }
            result = cost;
            if (!excludePerUseCost)  {
                result += perUseCost;
            }
            
        }
        return result;
    },
    calculateResourcesPerUseCost: function() {
        var assignments = this.getAssignments(),
            result = 0;
        for (var i = 0; i < assignments.length; i++) {
            var resource = assignments[i].getResource();
            if (resource)  {
                result += resource.getPerUseCost();
            }
            
        }
        return result;
    }
});

/**
 * Contains legacy methods implementing backward compatible
 * date adjustments when end date is displayed a day earlier than it's stored in the data model (see {@link #getDisplayEndDate}, {@link #getDisplayStartDate} methods for details).
 *
 * See also {@link Gnt.panel.Gantt#disableDateAdjustments disableDateAdjustments} config for enabling the adjustments.
 */
Ext.define('Gnt.model.task.DateAdjustment', {
    requires: [
        'Ext.util.Format',
        'Ext.Date',
        'Sch.util.Date'
    ],
    /**
     * Returns the formatted start date value to be used in the UI.
     * May adjust milestones to show them one day earlier than the actual raw date.
     * Start date of regular tasks stays untouchable.
     *
     * **Note:** Will not be invoked by fields, editors, columns and tooltips if {@link Gnt.panel.Gantt#disableDateAdjustments} is `true`.
     *
     * @param {String} format Date format.
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getStartDate()] Start date value. If not specified, the Task start date will be used.
     * @return {String} Formatted start date value.
     */
    getDisplayStartDate: function(format, adjustMilestones, value, returnDate, isBaseline) {
        format = format || Ext.Date.defaultFormat;
        // if no value specified then we'll take task start date
        if (arguments.length < 3) {
            value = this.getStartDate();
            // by default we consider adjustMilestones enabled
            if (arguments.length < 2)  {
                adjustMilestones = true;
            }
            
        }
        if (value && adjustMilestones && this.isMilestone(isBaseline) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }
        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    },
    /**
     * Returns the formatted end date value to be used in the UI.
     * May adjust milestones to show them one day earlier than the actual raw date,
     * or adjust regular tasks end date to show them finish one day earlier than the actual raw date.
     *
     * **Note** that end date of all tasks in the Gantt chart is not inclusive, however this method may compensate the value.
     * For example, if you have a 1 day task which starts at **2018-07-20 00:00:00** and ends at **2018-07-21 00:00:00**
     * (remember the end date is not inclusive), this method will return **2018-07-20** if called with 'Y-m-d'.
     *
     * ```javascript
     *     var task = new Gnt.model.Task({
     *         StartDate : new Date(2018, 6, 20),
     *         EndDate   : new Date(2018, 6, 21)
     *     });
     *
     *     // the code below displays "2018/07/20"
     *     alert(task.getDisplayEndDate('Y/m/d'));
     * ```
     *
     * @param {String} format=Ext.Date.defaultFormat Date format.
     * @param {Boolean} [adjustMilestones=true] If true, milestones will display one day earlier than the actual raw date.
     * @param {Date} [value=this.getEndDate()] End date value. If not specified, the Task end date will be used.
     * @return {String} The formatted end date value.
     */
    getDisplayEndDate: function(format, adjustMilestones, value, returnDate, isBaseline) {
        format = format || Ext.Date.defaultFormat;
        if (arguments.length < 3) {
            value = this.getEndDate();
            if (arguments.length < 2)  {
                adjustMilestones = true;
            }
            
        }
        // If "value" has not time part (a midnight) and format specified to not show time info
        // we show the date 1 day earlier
        // (if it's a milestone we do it only when "adjustMilestones" is `true`)
        if (value && (!this.isMilestone(isBaseline) || adjustMilestones) && value - Ext.Date.clearTime(value, true) === 0 && !Ext.Date.formatContainsHourInfo(format)) {
            value = Sch.util.Date.add(value, Sch.util.Date.MILLI, -1);
        }
        return returnDate ? value : (value ? Ext.util.Format.date(value, format) : '');
    }
});

/**
 * This class represents a single task in your Gantt chart.
 * The inheritance hierarchy of this class includes the {@link Sch.model.Customizable} and {@link Ext.data.Model} classes. Fields that begin
 * with a capital letter come from this class directly, and lowercase field names are inherited from {@link Ext.data.NodeInterface}.
 * This class will not only inherit fields but also a set of methods that stem from the {@link Ext.data.NodeInterface}.
 * Please refer to the documentation of those classes to become familiar with the base interface of this class.
 *
 * By default, a Task has the following fields as seen below.
 *
 * ## Modifying task Fields
 *
 * If you want to add new fields or change the name/options for the existing ones,
 * you can do that by subclassing this class (see example below).
 *
 * ## Subclassing the Task class
 *
 * The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.
 *
 * ```javascript
 * Ext.define('MyProject.model.Task', {
 *     extend           : 'Gnt.model.Task',
 *     nameField        : 'myName',
 *     percentDoneField : 'percentComplete',
 *     isAlmostDone     : function () {
 *         return this.get('percentComplete') > 80;
 *     },
 *     ...
 * });
 * ```
 *
 * ## Creating a new Task instance programmatically
 *
 * To create a new task programmatically, simply call the Gnt.model.Task constructor and pass in any default field values.
 *
 * ```javascript
 * var newTask = new Gnt.model.Task({
 *     Name        : 'An awesome task',
 *     PercentDone : 80, // So awesome it's almost done
 *     ...
 * });
 *
 * // To take weekends and non-working time into account, the new task needs a reference to the task store (which has access to the global calendar)
 * newTask.taskStore = taskStore;
 *
 * // Initialize new task to today
 * newTask.setStartDate(new Date());
 *
 * // This is a leaf task
 * newTask.set('leaf', true);
 *
 * // Now it will appear in the UI if the Gantt panel is rendered
 * taskStore.getRootNode().appendChild(newTask);
 * ```
 *
 * ## Start and End dates
 *
 * For all tasks, the range between start date and end date is supposed to be not-inclusive on the right side: {@link #StartDate} <= date < {@link #EndDate}.
 * So, for example, the task which starts at 2018/07/18 and has 2 days duration, should have the end date: 2018/07/20, **not** 2018/07/19 23:59:59.
 * Both start and end dates of tasks in our components are *points* on time axis and if user specifies that some task starts
 * 01/01/2018 and has 1 day duration, that means the start point is 01/01/2018 00:00 and end point is 02/01/2018 00:00.
 *
 * ## Conversion to "days" duration unit
 *
 * Some duration units cannot be converted to "days" consistently. For example a month may have 28, 29, 30 or 31 days. The year may have 365 or 366 days and so on.
 * So in such conversion operations, we will always assume that a task with a duration of 1 month will have a duration of 30 days.
 * This is {@link Gnt.data.Calendar#daysPerMonth a configuration option} of the calendar class.
 *
 * ## Task API
 *
 * One important thing to consider is that, if you are using the availability/scheduling modes feature, then you need to use the task API call to update the fields like `StartDate / EndDate / Duration`.
 * Those calls will calculate the correct value of each the field, taking into account the information from calendar/assigned resources.
 *
 * ## Server-side integration
 *
 * Also, at least for now you should not use the "save" method of the model available in Ext 4:
 *
 * ```javascript
 * task.save() // WON'T WORK
 * ```
 *
 * This is because there are some quirks in using CRUD for Ext tree stores. These quirks are fixed in the TaskStore. To save the changes in task to server
 * use the "sync" method of the task store:
 *
 * ```javascript
 * taskStore.sync() // OK
 * ```
 */
Ext.define('Gnt.model.Task', {
    extend: 'Sch.model.Range',
    alias: 'gntmodel.event',
    requires: [
        'Sch.util.Date',
        'Ext.data.NodeInterface',
        'Ext.util.Format'
    ],
    uses: [
        'Gnt.model.TaskSegment'
    ],
    mixins: [
        'Gnt.model.mixin.ProjectableModel',
        'Gnt.model.task.More',
        'Gnt.model.task.Constraints',
        'Gnt.model.task.Splittable',
        'Gnt.model.task.Effort',
        'Gnt.model.task.Cost',
        'Gnt.model.task.DateAdjustment'
    ],
    isTaskModel: true,
    /**
     * @cfg {String} Class name of the model to represent task segment
     */
    segmentClassName: 'Gnt.model.TaskSegment',
    /**
     * @cfg {String} idProperty The name of the field treated as this Model's unique id.
     */
    idProperty: "Id",
    customizableFields: [
        /**
         * @field Id
         * A unique identifier of the task
         */
        /**
         * @field StartDate
         * @type Date
         * The start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
         */
        /**
         * @field EndDate
         * @type Date
         * The end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
         */
        /**
         * @field Name
         * The name of the task (task title)
         */
        /**
         * @field
         * The numeric part of the task duration (the number of units).
         *
         * **Note:** When duration value is calculated, the project calendar {@link Sch.data.Calendar#cfg-hoursPerDay HoursPerDay} value is taken into account.
         * Please checkout [Using calendars](#!/guide/gantt_calendars) guide for details.
         */
        {
            name: 'Duration',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The numeric part of the task effort (the number of units). The effort of the "parent" tasks will be automatically set to the sum
         * of efforts of their "child" tasks
         */
        {
            name: 'Effort',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The unit part of the task effort (corresponds to units defined in {@link Sch.util.Date}), defaults to "h" (hours). Valid values are:
         *
         * - "ms" (milliseconds)
         * - "s" (seconds)
         * - "mi" (minutes)
         * - "h" (hours)
         * - "d" (days)
         * - "w" (weeks)
         * - "mo" (months)
         * - "q" (quarters)
         * - "y" (years)
         */
        {
            name: 'EffortUnit',
            type: 'string',
            defaultValue: 'h'
        },
        /**
         * @field
         * The actual current effort (the number of {@link #EffortUnit effort units}) that has been completed. This number is calculated based on {@link #PercentDone % completion}.
         */
        {
            name: 'ActualEffort',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The difference between the effort and its set baseline.
        */
        {
            name: 'EffortVariance',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The id of the calendar, assigned to the task. Allows you to set the time when task can be performed.
         *
         * Should be only provided for specific tasks - all tasks by default are assigned to the project calendar, provided as the
         * {@link Gnt.data.TaskStore#calendar} option.
         */
        {
            name: 'CalendarId',
            type: 'string'
        },
        /**
         * @field
         * A freetext note about the task.
         */
        {
            name: 'Note',
            type: 'string'
        },
        /**
         * @field
         * The unit part of the task duration (corresponds to units defined in {@link Sch.util.Date}), defaults to "d" (days). Valid values are:
         *
         * - "ms" (milliseconds)
         * - "s" (seconds)
         * - "mi" (minutes)
         * - "h" (hours)
         * - "d" (days)
         * - "w" (weeks)
         * - "mo" (months)
         * - "q" (quarters)
         * - "y" (years)
         *
         */
        {
            name: 'DurationUnit',
            type: 'string',
            defaultValue: "d",
            // make sure the default value is applied when user provides empty value for the field, like "" or null
            convert: function(value) {
                return value || Sch.util.Date.DAY;
            }
        },
        /**
         * @field
         * The progress of the task expressed as the percentage of completion. (Number 0..100).
         *
         * If `PercentDone >= 100%` it means the task {@link Gnt.model.task.More#isCompleted is completed} and it won't be affected by incoming dependencies.
         *
         * For "leaf" tasks, `PercentDone` value is provided by the user while the parent tasks `PercentDone` value is calculated based on its children.
         * This behavior is configurable and depends on the {@link #autoCalculatePercentDoneForParentTask} value.
         * If set to `false`, the parent `PercentDone` value can also be entered manually.
         *
         * A summary task `PercentDone` is calculated as `sum (completed portion of the duration of its children) / sum (children duration) * 100%`,
         * where `completed portion of the duration of its children = sum (child duration * child percent done)`.
         */
        {
            name: 'PercentDone',
            type: 'number',
            defaultValue: 0
        },
        /**
         * @field
         * Cost of the task. Can also act as a calculated field containing the total cost of the task. Cost = Actual Cost + Remaining Cost
         */
        {
            name: 'Cost',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * A calculated field containing the current cost of the task based on assignments and completion of the task.
         */
        {
            name: 'ActualCost',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * A field showing the difference between the cost and its set baseline.
         */
        {
            name: 'CostVariance',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The task constraint. A string containing the alias for a constraint class (w/o the `gntconstraint` prefix). Valid values are:
         *
         * - "startnoearlierthan"
         * - "startnolaterthan"
         * - "muststarton"
         * - "finishnoearlierthan"
         * - "finishnolaterthan"
         * - "mustfinishon"
         * - "assoonaspossible"
         * - "aslateaspossible"
         *
         * If you want to define your own custom constraint class, you need to alias it:
         *
         * ```javascript
         *         Ext.define('MyConstraint', {
         *             extend      : 'Gnt.constraint.Base',
         *
         *             alias       : 'gntconstraint.myconstraint',
         *             ...
         *         });
         * ```
         */
        {
            name: 'ConstraintType',
            type: 'string',
            defaultValue: ''
        },
        /**
         * @field
         * The task constraint boundary date, if applicable.
         */
        {
            name: 'ConstraintDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @field
         * When set to `true`, the {@link #StartDate start date} of the task will not be changed by any of its incoming dependencies
         * or constraints. Also, a manually scheduled parent task is not affected by its child tasks and behaves like any other normal task.
        */
        {
            name: 'ManuallyScheduled',
            type: 'boolean',
            defaultValue: false
        },
        /**
         * @field
         * The scheduling mode for the task. Based on this field some fields of the task
         * will be "fixed" (should be provided) and some - computed.
         *
         * Possible values are:
         *
         * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based on information
         * about its start/end dates, task own calendar (project calendar if there's no one) and calendars of the assigned resources.
         *
         * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed dynamically,
         * based on the assigned resources information. Typical example of such task is - meeting. Meetings typically have
         * pre-defined start and end dates and the more people are participating in the meeting, the more effort is spent on the task.
         * When duration of such task increases, its effort is increased too (and vice-versa).
         * **NOTE:** Fixed start and end dates here doesn't mean that a user can't update them via GUI,
         * the only field which won't be editable in GUI is the effort field,
         * it will be calculated according to duration and resources assigned to the task.
         *
         * - `EffortDriven` mode means, that task has fixed effort and computed duration. The more resources will be assigned
         * to this task, the less the duration will be. The typical example will be a "paint the walls" task -
         * several painters will complete it faster.
         * **NOTE:** Task is not EffortDriven if it has no assignments and {@link Gnt.data.TaskStore#enableSetDurationOnEffortDrivenTask} flag is enabled.
         *
         * - `DynamicAssignment` mode can be used when both duration and effort of the task are fixed. The computed value in this
         * case will be - the assignment units of the resources assigned. In this mode, the assignment level of all assigned resources
         * will be updated to evenly distribute the task's workload among them.
         *
         * **NOTE:** Parent tasks are always Normal and accumulate results from their children, except those which are {@link #ManuallyScheduled}.
         *
         */
        {
            name: 'SchedulingMode',
            type: 'string',
            defaultValue: 'Normal'
        },
        /**
         * @field
         * The baseline start date of the task in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
         */
        {
            name: 'BaselineStartDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @field
         * The baseline end date of the task in the ISO 8601 format, **see "Start and End dates" section for important notes**
         */
        {
            name: 'BaselineEndDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @field
         * The baseline status of a task, expressed as the percentage completed (integer from 0 to 100)
         */
        {
            name: 'BaselinePercentDone',
            type: 'int',
            defaultValue: 0
        },
        /**
         * @field
         * The task effort baseline (the number of {@link #EffortUnit effort units}).
        */
        {
            name: 'BaselineEffort',
            type: 'number',
            allowNull: true
        },
        /**
         * @field
         * The cost baseline for the task.
         */
        {
            name: 'BaselineCost',
            type: 'number',
            allowNull: true
        },
        {
            name: 'Draggable',
            type: 'boolean',
            persist: false,
            defaultValue: true
        },
        // true or false
        {
            name: 'Resizable',
            persist: false,
            defaultValue: ''
        },
        // true, false, 'start' or 'end'
        /**
         * @field
         * 'true' to indicate that a task cannot be modified.
         */
        {
            name: 'ReadOnly',
            type: 'bool',
            defaultValue: false
        },
        /**
         * @field
         * Set this to 'true' if the task should rollup to its parent task.
         */
        {
            name: 'Rollup',
            type: 'boolean',
            defaultValue: false
        },
        /**
         * @field
         * @type {Gnt.model.TaskSegment[]}
         * Segments of the task that appear when the task gets {@link #split}.
         */
        {
            name: 'Segments',
            persist: true,
            convert: function(value, record) {
                return record.processSegmentsValue(value, record);
            },
            serialize: function(value) {
                if (!value)  {
                    return null;
                }
                
                return Ext.Array.map([].concat(value), function(segment) {
                    return segment.serialize();
                });
            }
        },
        // Two fields which specify the relations between "phantom" tasks when they are
        // being sent to the server to be created (e.g. when you create a new task containing a new child task).
        {
            name: 'PhantomId',
            type: 'string'
        },
        {
            name: 'PhantomParentId',
            type: 'string'
        },
        /**
         * @field
         * Set this to true if this task should be shown in the Timeline widget
         */
        {
            name: 'ShowInTimeline',
            type: 'bool'
        },
        /**
         * @field
         * A deadline date for this task
         */
        {
            name: 'DeadlineDate',
            type: 'date',
            dateFormat: 'c'
        }
    ],
    fields: [
        // Override NodeInterface defaults
        {
            name: 'index',
            type: 'int',
            persist: true
        },
        // Internal flag saying that the task needs to be rescheduled. We don't want this to be persisted or mess the modified fields list.
        {
            name: 'needsRescheduling',
            type: 'bool',
            persist: false
        }
    ],
    /**
     * @cfg {String} constraintTypeField The name of the field specifying the constraint type of this task.
     */
    constraintTypeField: 'ConstraintType',
    /**
     * @cfg {String} constraintDateField The name of the field specifying the constraint date for this task.
     */
    constraintDateField: 'ConstraintDate',
    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField: 'Draggable',
    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField: 'Resizable',
    /**
     * @cfg {String} nameField The name of the field that holds the task name. Defaults to "Name".
     */
    nameField: 'Name',
    /**
     * @cfg {String} durationField The name of the field holding the task duration.
     */
    durationField: 'Duration',
    /**
     * @cfg {String} durationUnitField The name of the field holding the task duration unit.
     */
    durationUnitField: 'DurationUnit',
    /**
     * @cfg {String} effortField The name of the field holding the value of task effort.
     */
    effortField: 'Effort',
    /**
     * @cfg {String} effortUnitField The name of the field holding the task effort unit.
     */
    effortUnitField: 'EffortUnit',
    /**
     * @cfg {String} actualEffortField The name of the field holding the task actual effort.
     */
    actualEffortField: 'ActualEffort',
    /**
     * @cfg {String} effortVarianceField The name of the field holding the task effort variance.
     */
    effortVarianceField: 'EffortVariance',
    /**
     * @cfg {String} costField The name of the field holding the task cost.
     */
    costField: 'Cost',
    /**
     * @cfg {String} actualCostField The name of the field holding the task actualcost.
     */
    actualCostField: 'ActualCost',
    /**
     * @cfg {String} costVarianceField The name of the field holding the task cost variance.
     */
    costVarianceField: 'CostVariance',
    /**
     * @cfg {String} percentDoneField The name of the field specifying the level of completion.
     */
    percentDoneField: 'PercentDone',
    /**
     * @cfg {String} manuallyScheduledField The name of the field defining if a task is manually scheduled or not.
     */
    manuallyScheduledField: 'ManuallyScheduled',
    /**
     * @cfg {String} schedulingModeField The name of the field defining the scheduling mode of the task.
     */
    schedulingModeField: 'SchedulingMode',
    /**
     * @cfg {String} rollupField The name of the field specifying if the task should rollup to its parent task.
     */
    rollupField: 'Rollup',
    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific task. Task calendar has the highest priority.
     */
    calendarIdField: 'CalendarId',
    /**
     * @cfg {String} baselineStartDateField The name of the field that holds the task baseline start date.
     */
    baselineStartDateField: 'BaselineStartDate',
    /**
     * @cfg {String} baselineEndDateField The name of the field that holds the task baseline end date.
     */
    baselineEndDateField: 'BaselineEndDate',
    /**
     * @cfg {String} baselinePercentDoneField The name of the field specifying the baseline level of completion.
     */
    baselinePercentDoneField: 'BaselinePercentDone',
    /**
     * @cfg {String} baselineEffortField The name of the field specifying the baseline level of the effort.
     */
    baselineEffortField: 'BaselineEffort',
    /**
     * @cfg {String} baselineCostField The name of the field specifying the cost baseline level.
     */
    baselineCostField: 'BaselineCost',
    /**
     * @cfg {String} noteField The name of the field specifying the task note.
     */
    noteField: 'Note',
    /**
     * @cfg {String} segmentsField The name of the field specifying the task segments.
     */
    segmentsField: 'Segments',
    /*
     * @cfg {Boolean} readOnlyField The name of the field specifying if the task is read only. When set to true, a task
     * is not draggable, resizable and for all its fields {@link #isEditable} returns `false`
     */
    readOnlyField: 'ReadOnly',
    /**
     * @cfg {Gnt.data.Calendar} calendar
     * Optional. An explicitly provided {@link Gnt.data.Calendar calendar} instance. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore
     * Optional. An explicitly provided {@link Gnt.data.DependencyStore} with dependencies information. Usually will be retrieved by the task from the {@link Gnt.data.TaskStore task store}.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore
     * Optional. An explicitly provided Gnt.data.TaskStore with tasks information. Usually will be set by the {@link Gnt.data.TaskStore task store}.
     */
    taskStore: null,
    /**
     * @cfg {String} phantomIdField The name of the field specifying the phantom id when this task is being 'realized' by the server.
     */
    phantomIdField: 'PhantomId',
    /**
     * @cfg {String} phantomParentIdField The name of the field specifying the parent task phantom id when this task is being 'realized' by the server.
     */
    phantomParentIdField: 'PhantomParentId',
    /**
     * @cfg {String} showInTimelineField The name of the field saying if the task has to be displayed in a project timeline view.
     */
    showInTimelineField: 'ShowInTimeline',
    /**
     * @cfg {String} deadlineDateField The name of the field that holds the task deadline date.
     */
    deadlineDateField: 'DeadlineDate',
    normalized: false,
    recognizedSchedulingModes: [
        'Normal',
        'FixedDuration',
        'EffortDriven',
        'DynamicAssignment'
    ],
    ignoreResourceCalendarsForSchedulingMode: null,
    /**
     * Returns the constraint type of the task.
     * @method getConstraintType
     * @return {String} Constraint type. The type string might be one of the following values:
     *
     *  - `finishnoearlierthan`
     *  - `finishnolaterthan`
     *  - `mustfinishon`
     *  - `muststarton`
     *  - `startnoearlierthan`
     *  - `startnolaterthan`
     */
    /**
     * Returns the constraint date of the task.
     * @method getConstraintDate
     * @return {Date} Constraint date
     */
    /**
     * @cfg {Boolean} convertEmptyParentToLeaf
     *
     * This configuration option allows you to control whether an empty parent task should be converted into a leaf. Note, that
     * it's not a new field, but a regular configuration property of this class.
     *
     * Usually you will want to enable/disable it for the whole class:
     *
     * ```javascript
     *  Ext.define('MyApp.model.Task', {
     *      extend                   : 'Gnt.model.Task',
     *      convertEmptyParentToLeaf : false
     *  })
     * ```
     */
    convertEmptyParentToLeaf: true,
    /**
     * @cfg {Boolean} autoCalculateEffortForParentTask
     *
     * This configuration option enables auto-calculation of the effort value for the parent task. When this option is enabled,
     * effort value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *
     * ```javascript
     *  Ext.define('MyApp.model.Task', {
     *      extend                           : 'Gnt.model.Task',
     *      autoCalculateEffortForParentTask : false
     *  })
     * ```
     */
    autoCalculateEffortForParentTask: true,
    /**
     * @cfg {Boolean} autoCalculatePercentDoneForParentTask
     *
     * This configuration option enables auto-calculation of the percent done value for the parent task. When this option is enabled,
     * percent done value of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *
     * ```javascript
     *  Ext.define('MyApp.model.Task', {
     *      extend                                : 'Gnt.model.Task',
     *      autoCalculatePercentDoneForParentTask : false
     *  })
     * ```
     */
    autoCalculatePercentDoneForParentTask: true,
    /**
     * @cfg {Boolean} autoCalculateCostForParentTask
     *
     * This configuration option enables auto-calculation of the cost and actualcost value for the parent task. When this option is enabled,
     * cost and actualcost of the parent tasks becomes not editable.
     *
     * Usually you will want to enable/disable it for the whole class:
     *
     * ```javascript
     *   Ext.define('MyApp.model.Task', {
     *      extend                         : 'Gnt.model.Task',
     *      autoCalculateCostForParentTask : false
     *   })
     * ```
     */
    autoCalculateCostForParentTask: true,
    /**
     * @cfg {Boolean} autoCalculateCost
     *
     * When set to `true` the values of `cost`, and `actual cost` fields are calculated automatically based on assigned resources cost.
     * When set to `false` the manually set values will be used for the fields.
     */
    autoCalculateCost: true,
    isHighlighted: false,
    calendarWaitingListener: null,
    childTasksDuration: null,
    completedChildTasksDuration: null,
    totalCount: null,
    // TODO: How to remove predecessors/successors?
    // NOTE: The property is managed by Gnt.data.util.TaskDependencyCache class
    /**
     * @property {Gnt.model.Dependency[]} predecessors The task predecessors list.
     */
    predecessors: null,
    // NOTE: The property is managed by Gnt.data.util.TaskDependencyCache class
    /**
     * @property {Gnt.model.Dependency[]} successors The task successors list.
     */
    successors: null,
    // special flag, that prevents parent from being converted into leafs when using "replaceChild" method
    // see `data_components/077_task_replace_child.t.js`
    removeChildIsCalledFromReplaceChild: false,
    // see comments in `endEdit` override
    savedDirty: null,
    // This flag is experimental. The main reason to DO NOT USE this flag is that if you have different calendars for your tasks under the same project,
    // you can't compare their length visually. 2 tasks can be equal by their lengths, but different by their values, and vice versa.
    useOwnCalendarAsConverter: false,
    constructor: function() {
        this._singleProp = {};
        this.callParent(arguments);
        if (this.phantom) {
            this.data[this.phantomIdField] = this.getId();
        }
        if (this.id === 'root') {
            this.convertEmptyParentToLeaf = false;
        }
        // NOTE: The properties are managed by Gnt.data.util.TaskDependencyCache class
        // TODO: Remove this code when those properties are remove from Task interface
        this.predecessors = [];
        this.successors = [];
    },
    // should be called once after initial loading - will convert the "EndDate" field to "Duration"
    // the model should have the link to calendar
    normalize: function() {
        var durationUnit = this.getDurationUnit(),
            startDate = this.getStartDate(),
            endDate = this.getEndDate(),
            data = this.data,
            taskStore = this.getTaskStore(true),
            schedulingMode = this.getSchedulingMode();
        if (schedulingMode == 'Manual') {
            schedulingMode = data[this.schedulingModeField] = 'Normal';
            data[this.manuallyScheduledField] = true;
        }
        var endDateField = this.endDateField;
        // normalize segments if required
        if (taskStore && this.isSegmented()) {
            this.normalizeSegments();
            var last;
            // if task is still segmented after segments normalization
            // let's set the task end to the last segment finish
            if (last = this.getLastSegment()) {
                endDate = data[endDateField] = last.getEndDate();
            }
        }
        var duration = this.getDuration();
        var effortField = this.effortField;
        if (endDate && this.inclusiveEndDate) {
            // End date supplied, if end dates are inclusive we need to adjust them -
            // but only IF:
            //      * The end-date dateFormat does not contain any hour info, OR
            //      * The end-date dateFormat does contain any hour info AND it has no hours/minutes/seconds/ms
            var format = this.getField(endDateField).dateFormat;
            var doAdjust = (format && !Ext.Date.formatContainsHourInfo(format)) || (endDate.getHours() === 0 && endDate.getMinutes() === 0 && endDate.getSeconds() === 0 && endDate.getMilliseconds() === 0);
            if (doAdjust) {
                if (Ext.isNumber(duration)) {
                    // Recalculate end date based on duration
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                } else {
                    // Simply add 1 day to end date
                    endDate = data[endDateField] = Ext.Date.add(endDate, Ext.Date.DAY, 1);
                }
            }
        }
        // for all scheduling modes
        if (duration == null && startDate && endDate) {
            duration = data[this.durationField] = this.calculateDuration(startDate, endDate, durationUnit);
        }
        if ((schedulingMode == 'Normal' || this.isManuallyScheduled() || (schedulingMode === 'EffortDriven' && !this.isEffortDriven())) && endDate == null && startDate && Ext.isNumber(duration)) {
            endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
        }
        // accessing the field value directly here, since we are interested in "raw" value
        // `getEffort` now returns 0 for empty effort values
        var effort = this.get(effortField),
            effortUnit = this.getEffortUnit();
        switch (schedulingMode) {
            case 'FixedDuration':
                if (endDate == null && startDate && Ext.isNumber(duration)) {
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                };
                if (effort == null && startDate && endDate) {
                    data[effortField] = this.calculateEffort(startDate, endDate, effortUnit);
                };
                break;
            case 'EffortDriven':
                if (effort == null && startDate && endDate) {
                    data[effortField] = this.calculateEffort(startDate, endDate, effortUnit);
                };
                if (endDate == null && startDate && effort) {
                    data[endDateField] = this.calculateEffortDrivenEndDate(startDate, effort, effortUnit);
                    // for "effortDriven" task, user can only provide StartDate and Effort - that's all we need
                    if (duration == null) {
                        data[this.durationField] = this.calculateDuration(startDate, data[endDateField], durationUnit);
                    }
                };
                break;
            default:
                if (endDate == null && startDate && Ext.isNumber(duration)) {
                    endDate = data[endDateField] = this.calculateEndDate(startDate, duration, durationUnit);
                };
                break;
        }
        if (this.getActualEffort() == null) {
            data[this.actualEffortField] = this.calculateActualEffort();
        }
        // calculates costs if "autoCalculateCost" is enabled
        if (this.autoCalculateCost) {
            if (this.getActualCost() == null) {
                data[this.actualCostField] = this.calculateActualCost();
            }
            if (this.getCost() == null) {
                data[this.costField] = this.calculateCost();
            }
        }
        if (this.getCostVariance() == null) {
            this.data[this.costVarianceField] = this.calculateCostVariance();
        }
        if (this.getEffortVariance() == null) {
            this.data[this.effortVarianceField] = this.calculateEffortVariance();
        }
        var calendarId = this.getCalendarId();
        if (calendarId)  {
            this.setCalendarId(calendarId, true);
        }
        
        this.normalized = true;
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance to be used as a converter
     * @return {Gnt.data.Calendar} calendar
     */
    getUnitConverter: function() {
        var taskStore = this.getTaskStore(true),
            project = this.getProject(),
            ownCalendar = this.getCalendar();
        // - use ownCalendar (if it's told to use it)
        // - otherwise use project calendar (if the task is in a task store or in a project node)
        // - otherwise fallback to own calendar
        return this.useOwnCalendarAsConverter && ownCalendar || (taskStore || project) && this.getProjectCalendar() || ownCalendar;
    },
    // recursive task
    normalizeParent: function() {
        var childNodes = this.childNodes;
        var totalEffortInMS = 0;
        var totalDurationInMS = 0;
        var completedDurationInMS = 0;
        var cost = 0;
        var actualCost = 0;
        var autoCalculatePercentDoneForParentTask = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask = this.autoCalculateEffortForParentTask;
        var autoCalculateCostForParentTask = this.autoCalculateCostForParentTask;
        var allTasksAreMilestonesAndFinished = childNodes.length > 0;
        var hasUnfinishedMilestone = false;
        for (var i = 0; i < childNodes.length; i++) {
            var child = childNodes[i];
            var isLeaf = child.isLeaf();
            if (!isLeaf)  {
                child.normalizeParent();
            }
            
            if (autoCalculateEffortForParentTask) {
                totalEffortInMS += child.getEffort('MILLI');
            }
            if (autoCalculateCostForParentTask) {
                cost += child.getCost();
                actualCost += child.getActualCost();
            }
            if (autoCalculatePercentDoneForParentTask) {
                var durationInMS = isLeaf ? child.getDuration('MILLI') || 0 : child.childTasksDuration,
                    childPercentDone = child.getPercentDone() || 0;
                totalDurationInMS += durationInMS;
                completedDurationInMS += isLeaf ? durationInMS * childPercentDone : child.completedChildTasksDuration;
                hasUnfinishedMilestone = hasUnfinishedMilestone || this.hasUnfinishedMilestone || (durationInMS === 0 && childPercentDone < 100);
                allTasksAreMilestonesAndFinished = allTasksAreMilestonesAndFinished && durationInMS === 0 && childPercentDone >= 100;
            }
        }
        if (autoCalculatePercentDoneForParentTask) {
            var newPercentDone = 0;
            this.childTasksDuration = totalDurationInMS;
            this.completedChildTasksDuration = completedDurationInMS;
            this.hasUnfinishedMilestone = hasUnfinishedMilestone;
            if (totalDurationInMS > 0) {
                newPercentDone = completedDurationInMS / totalDurationInMS;
                // Indicate there are unfinished tasks
                if (newPercentDone === 100 && hasUnfinishedMilestone) {
                    newPercentDone = 99;
                }
            } else if (allTasksAreMilestonesAndFinished) {
                // For parent tasks containing only milestones, if there is at least one task with < 100% done, the parent task should report itself as 0% done
                // If all children are 100%, parent reports 100% done too
                newPercentDone = 100;
            }
            if (this.getPercentDone() != newPercentDone)  {
                this.data[this.percentDoneField] = newPercentDone;
            }
            
        }
        if (autoCalculateEffortForParentTask) {
            if (this.getEffort('MILLI') != totalEffortInMS)  {
                this.data[this.effortField] = this.getUnitConverter().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit());
            }
            
        }
        if (autoCalculatePercentDoneForParentTask && autoCalculateEffortForParentTask) {
            this.data[this.actualEffortField] = this.calculateActualEffort();
        }
        if (autoCalculateCostForParentTask) {
            this.data[this.actualCostField] = actualCost;
            this.data[this.costField] = cost;
        }
        this.data[this.costVarianceField] = this.calculateCostVariance();
        this.data[this.effortVarianceField] = this.calculateEffortVariance();
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task. If task has no own calendar, it will be recursively looked up
     * starting from task's parent. If no one from parents have own calendar then project calendar will be returned.
     * See also `ownCalendarOnly` parameter and {@link #getOwnCalendar}, {@link #getProjectCalendar} methods.
     *
     * @param {Boolean} ownCalendarOnly (optional) When set to true, return only own calendar of this task and `null` if task has no calendar
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getCalendar: function(ownCalendarOnly, ignoreAbsense) {
        return ownCalendarOnly ? this.getOwnCalendar() : this.getOwnCalendar() || this.parentNode && this.parentNode.getCalendar() || this.getProjectCalendar(ignoreAbsense);
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this task (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar: function() {
        var calendarId = this.get(this.calendarIdField);
        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : this.calendar;
    },
    // TODO: cache project
    /**
     * Returns the {@link Gnt.model.Project project} instance, associated with this task if this task belongs to a project
     *
     * @return {Gnt.model.Project} project
     */
    getProject: function() {
        var me = this,
            project = null;
        if (this.isProject) {
            return this;
        }
        this.bubble(function(task) {
            if (me !== task && task.isProject) {
                project = task;
                return false;
            }
        }, this);
        return project;
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this task (with the TaskStore instance
     * this task belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar: function(ignoreAbsense) {
        var store = this.getTaskStore(true);
        var calendar = store && store.getCalendar() || this.parentNode && this.parentNode.getProjectCalendar() || this.isRoot() && this.calendar;
        if (!calendar && !ignoreAbsense) {
            Ext.Error.raise("Can't find a project calendar in `getProjectCalendar`");
        }
        return calendar;
    },
    getProjectStartDate: function() {
        var taskStore = this.getTaskStore(true),
            project = this.getProject();
        return project && project.getStartDate() || taskStore && taskStore.getProjectStartDate();
    },
    getProjectEndDate: function() {
        var taskStore = this.getTaskStore(true),
            project = this.getProject();
        return project && project.getEndDate() || taskStore && taskStore.getProjectEndDate();
    },
    getProjectScheduleBackwards: function(taskStore, project) {
        taskStore = taskStore || this.getTaskStore(true);
        project = project || this.getProject();
        return Boolean(project ? project.getScheduleBackwards() : taskStore && taskStore.scheduleBackwards);
    },
    /**
     * @propagating
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this task. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     * @param {Function} [callback] Callback function to call after task calendar has been changed and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setCalendar: function(calendar, callback) {
        var me = this,
            isCalendarInstance = calendar instanceof Gnt.data.Calendar;
        if (isCalendarInstance && !calendar.calendarId) {
            throw new Error("Can't set calendar w/o `calendarId` property");
        }
        return me.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar, false, callback);
    },
    /**
     * @propagating
     * @private
     */
    setCalendarId: function(calendarId, isInitial, callback) {
        var me = this;
        if (!isInitial) {
            me.propagateChanges(function() {
                return me.setCalendarIdWithoutPropagation(calendarId, isInitial);
            }, callback);
        } else {
            me.setCalendarIdWithoutPropagation(calendarId, isInitial);
        }
    },
    onCalendarChange: function(calendar) {
        if (!this.isReadOnly() && this.isTaskStored()) {
            this.adjustToCalendarWithoutPropagation();
        }
    },
    setCalendarIdWithoutPropagation: function(calendarId, isInitial) {
        var propagate = false;
        if (calendarId instanceof Gnt.data.Calendar)  {
            calendarId = calendarId.calendarId;
        }
        
        var prevCalendarId = this.getCalendarId();
        if (prevCalendarId != calendarId || isInitial) {
            propagate = true;
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }
            var listeners = {
                    calendarchange: this.onCalendarChange,
                    scope: this
                };
            var prevInstance = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);
            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar = null;
            prevInstance && prevInstance.un(listeners);
            this.set(this.calendarIdField, calendarId);
            if (!calendarId && !isInitial) {
                this.onCalendarChange();
            } else if (calendarId) {
                var calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
                if (calendarInstance) {
                    calendarInstance.on(listeners);
                    if (!isInitial) {
                        this.onCalendarChange();
                    }
                } else {
                    this.calendarWaitingListener = Ext.data.StoreManager.on('add', function onCalendarWaitingStoreManagerAdd() {
                        calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
                        // Checking if we're still in an active store
                        if (this.isTaskStored()) {
                            // We are.
                            // Checking for calendar instance
                            if (calendarInstance) {
                                this.calendarWaitingListener.destroy();
                                this.calendarWaitingListener = null;
                                calendarInstance.on(listeners);
                                this.onCalendarChange();
                            } else // No calendar instance yet, wait again
                            {
                                this.calendarWaitingListener = Ext.data.StoreManager.on('add', onCalendarWaitingStoreManagerAdd, this, {
                                    destroyable: true,
                                    single: true
                                });
                            }
                        }
                    }, this, {
                        destroyable: true,
                        single: true
                    });
                }
            }
        }
        return propagate;
    },
    /**
     * Returns the dependency store, associated with this task.
     *
     * @return {Gnt.data.DependencyStore} The dependency store instance
     */
    getDependencyStore: function() {
        var taskStore = this.getTaskStore(true),
            dependencyStore = taskStore && taskStore.getDependencyStore();
        return dependencyStore;
    },
    /**
     * Returns the resource store, associated with this task.
     *
     * @return {Gnt.data.Resource} The resource store instance
     */
    getResourceStore: function() {
        var taskStore = this.getTaskStore(true);
        return taskStore && taskStore.getResourceStore();
    },
    /**
     * Returns the assignment store, associated with this task.
     *
     * @return {Gnt.data.AssignmentStore} The assignment store instance
     */
    getAssignmentStore: function() {
        var taskStore = this.getTaskStore(true);
        return taskStore && taskStore.getAssignmentStore();
    },
    /**
     * Returns the {@link Gnt.data.TaskStore task store} instance, associated with this task
     *
     * @return {Gnt.data.TaskStore} task store
     */
    getTaskStore: function(ignoreAbsense) {
        var me = this;
        if (!me.taskStore) {
            me.taskStore = me.getTreeStore() || me.parentNode && me.parentNode.getTaskStore(ignoreAbsense);
        }
        if (!me.taskStore && !ignoreAbsense) {
            Ext.Error.raise("Can't find a taskStore in `getTaskStore`");
        }
        return me.taskStore;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * Provides a reference to a {@link Gnt.data.TaskStore task store} instance, which the task will use to access the global
     * {@link Gnt.data.Calendar calendar}. Calling this does *not* add the model to the task store. Call this method if you want to use
     * methods like {@link #setStartDate} or {@link #setEndDate} that should take the store calendar into account.
     *
     * @param {Gnt.data.TaskStore} taskStore The task store
     */
    setTaskStore: function(taskStore) {
        this.taskStore = taskStore;
    },
    /**
     * Returns true if the task is manually scheduled. Manually scheduled task is not affected by incoming dependencies or constraints.
     * Also, the manually scheduled parent task is not affected by its child tasks positions and behaves like any other normal task.
     *
     * @return {Boolean} The value of the ManuallyScheduled field
     */
    isManuallyScheduled: function() {
        return this.get(this.manuallyScheduledField);
    },
    /**
     * Returns true if {@link Gnt.model.Task#field-SchedulingMode} is 'EffortDriven' and either it has assignments
     * or it has no assignments but {@link Gnt.data.TaskStore#enableSetDurationOnEffortDrivenTask} flag is disabled.
     * @return {boolean}
     * @private
     */
    isEffortDriven: function() {
        return this.getSchedulingMode() === 'EffortDriven' && !(this.getAssignments().length === 0 && this.getTaskStore().enableSetDurationOnEffortDrivenTask);
    },
    isShowInTimeline: function() {
        return Boolean(this.getShowInTimeline());
    },
    /**
     * @propagating
     * Sets the task manually scheduled status.
     *
     * @param {Boolean} value The new value of the `SchedulingMode` field
     * @param {Function} [callback] Callback function to call after effort has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setManuallyScheduled: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setManuallyScheduledWithoutPropagation(value);
        }, callback);
    },
    /**
     * Sets the task manually scheduled status.
     */
    setManuallyScheduledWithoutPropagation: function(value) {
        var me = this;
        var wasManuallyScheduled = me.isManuallyScheduled();
        if (me.getManuallyScheduled() != value) {
            this.set(me.manuallyScheduledField, value);
        }
        // if the task is no longer manually scheduled we need to reschedule it
        if (wasManuallyScheduled && !me.isManuallyScheduled()) {
            me.markForRescheduling();
        }
        return true;
    },
    /**
     * @method getSchedulingMode
     *
     * Returns the scheduling mode of this task.
     *
     * May be one of the following strings:
     *
     * - `Normal` is the default (and backward compatible) mode. It means the task will be scheduled based on information
     * about its start/end dates, task own calendar (project calendar if there's no one) and calendars of the assigned resources.
     *
     * - `FixedDuration` mode means, that task has fixed start and end dates, but its effort will be computed dynamically,
     * based on the assigned resources information. Typical example of such task is - meeting. Meetings typically have
     * pre-defined start and end dates and the more people are participating in the meeting, the more effort is spent on the task.
     * When duration of such task increases, its effort is increased too (and vice-versa). **NOTE:** fixed start and end dates
     * here doesn't mean that a user can't update them via GUI, the only field which won't be editable in GUI is the effort field,
     * it will be calculated according to duration and resources assigned to the task.
     *
     * - `EffortDriven` mode means, that task has fixed effort and computed duration. The more resources will be assigned
     * to this task, the less the duration will be. The typical example will be a "paint the walls" task -
     * several painters will complete it faster.
     * **NOTE:** Task is not EffortDriven if it has no assignments and {@link Gnt.data.TaskStore#enableSetDurationOnEffortDrivenTask} flag is enabled.
     *
     * - `DynamicAssignment` mode can be used when both duration and effort of the task are fixed. The computed value in this
     * case will be - the assignment units of the resources assigned. In this mode, the assignment level of all assigned resources
     * will be updated to evenly distribute the task's workload among them.
     *
     * **NOTE:** Parent tasks are always Normal and accumulate results from their children, except those which are {@link #ManuallyScheduled}.
     *
     * @return {String} scheduling mode string
     */
    /**
     * @propagating
     * @inheritdoc #setSchedulingModeWithoutPropagation
     * @param {String} value Name of the scheduling mode.
     * The list of possible values is provided in the {@link #SchedulingMode} field description.
     * @param {Function} [callback] Callback function to call after task's scheduling mode has been changed and possible
     *  changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setSchedulingMode: function(value, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setSchedulingModeWithoutPropagation(value);
        }, callback);
    },
    /**
     * Sets the scheduling mode for this task.
     *
     * @param {String} value Name of the scheduling mode.
     * The list of possible values is provided in the {@link #SchedulingMode} field description.
     */
    setSchedulingModeWithoutPropagation: function(value) {
        var me = this,
            propagationSource;
        if (me.getSchedulingMode() != value) {
            me.set(this.schedulingModeField, value);
            if (me.isEffortDriven()) {
                me.updateSpanBasedOnEffort();
            } else if (me.getSchedulingMode() == 'FixedDuration') {
                me.updateEffortBasedOnDuration();
            }
            var predecessors = me.getPredecessors();
            if (predecessors.length) {
                propagationSource = predecessors[0];
            } else {
                propagationSource = me;
            }
        }
        return propagationSource;
    },
    /**
     * @method getSegments
     * Gets segments of the task
     * @returns {Gnt.model.TaskSegment[]} Task segments
     */
    skipWorkingTime: function(date, duration, isForward, segments) {
        if (!date)  {
            return date;
        }
        
        var result;
        var durationLeft;
        isForward = isForward !== false;
        var me = this,
            schedulingMode = me.getSchedulingMode(),
            useResources = me.shouldUseResourceCalendarsForSchedulingMode(schedulingMode);
        var cfg = {
                isForward: isForward,
                segments: segments || false,
                // take resources into account if any
                resources: useResources && me.hasResources(),
                fn: function(from, to) {
                    var diff = to - from,
                        dstDiff = new Date(from).getTimezoneOffset() - new Date(to).getTimezoneOffset();
                    if (diff >= durationLeft) {
                        result = new Date((isForward ? from : to) - 0 + (isForward ? 1 : -1) * durationLeft);
                        return false;
                    } else {
                        durationLeft -= diff + dstDiff * 60 * 1000;
                    }
                }
            };
        if (Ext.isObject(date)) {
            Ext.apply(cfg, date);
        } else {
            if (isForward) {
                cfg.startDate = date;
            } else {
                cfg.endDate = date;
            }
        }
        durationLeft = duration || cfg.duration;
        if (!durationLeft)  {
            return date;
        }
        
        me.forEachAvailabilityInterval(cfg);
        return result;
    },
    /**
     * @ignore
     */
    skipNonWorkingTime: function(date, isForward, segments) {
        if (!date)  {
            return date;
        }
        
        var skipped = false;
        isForward = isForward !== false;
        var me = this,
            schedulingMode = me.getSchedulingMode(),
            useResources = me.shouldUseResourceCalendarsForSchedulingMode(schedulingMode);
        var cfg = {
                isForward: isForward,
                segments: segments || false,
                // take resources into account if any
                resources: useResources && me.hasResources(),
                fn: function(from, to) {
                    // if found interval has zero time length then nothing to skip so we just ignore it.
                    // TODO: need to review a possibility to move this condition right into forEachAvailabilityInterval() body
                    if (from !== to) {
                        date = isForward ? from : to;
                        skipped = true;
                        return false;
                    }
                }
            };
        if (Ext.isObject(date)) {
            Ext.apply(cfg, date);
        } else {
            if (isForward) {
                cfg.startDate = date;
            } else {
                cfg.endDate = date;
            }
        }
        // resetting the date to the earliest availability interval
        me.forEachAvailabilityInterval(cfg);
        return skipped ? new Date(date) : me.getCalendar().skipNonWorkingTime(date, isForward);
    },
    /**
     * @method getStartDate
     *
     * Returns the start date of this task
     *
     * @return {Date} start date
     */
    /**
     * @propagating
     * @inheritdoc #setStartDateWithoutPropagation
     * @param {Date} date Start date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     * @param {Function} [callback] Callback function to call after start date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setStartDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function(task, continueFn) {
            me.setStartDateAndPinWithoutPropagation(date, keepDuration, skipNonWorkingTime, continueFn);
        }, callback, null, true);
    },
    setStartDateAndPinWithoutPropagation: function(startDate, keepDuration, skipNonWorkingTime, continueFn) {
        var me = this,
            result = me.setStartDateWithoutPropagation(startDate, keepDuration, skipNonWorkingTime);
        me.maybePinWithoutPropagation(function(constraintSatisfied, cancelChanges) {
            // If user clicked to cancel changes in constraint resolution UI
            // we pass false to the callback (otherwise we pass the propagation source(s))
            if (continueFn) {
                continueFn(cancelChanges ? false : result);
            }
        });
    },
    // TODO: refactor this
    /**
     * Depending from the arguments, set either `StartDate + EndDate` fields of this task, or `StartDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date Start date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start date to the earliest available working time (if it falls on non-working time).
     */
    setStartDateWithoutPropagation: function(date, keepDuration, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true),
            duration, endDate;
        // {{{ Parameters normalization
        // Effort driven tasks should always recalculate their duration
        // changing of their positions can cause duration changes because of assigned resources calendars
        keepDuration = typeof keepDuration == 'boolean' ? keepDuration : !me.isEffortDriven();
        skipNonWorkingTime = typeof skipNonWorkingTime == 'boolean' ? skipNonWorkingTime : taskStore && taskStore.skipWeekendsDuringDragDrop;
        // }}}
        me.autoCalculateLag();
        me.beginEdit();
        if (!date) {
            me.set(me.durationField, null);
            me.set(me.startDateField, null);
            me.setSegmentsWithoutPropagation(null);
        } else {
            if (skipNonWorkingTime && !(me.isMilestone() && taskStore && taskStore.scheduleByConstraints)) {
                // for milestones we skip non-working backwards, for normal tasks - forward
                date = me.skipNonWorkingTime(date, !me.isMilestone());
            }
            me.set(me.startDateField, date);
            // recalculate split dates
            if (taskStore && me.isSegmented()) {
                me.updateSegmentsDates();
            }
            if (keepDuration !== false) {
                me.set(me.endDateField, me.recalculateEndDate(date));
            } else {
                endDate = this.getEndDate();
                if (endDate) {
                    // truncate segments that don't fit into master task range and shrink/expand last segment
                    this.constrainSegments();
                    me.set(me.durationField, me.calculateDuration(date, endDate, me.getDurationUnit()));
                }
            }
        }
        // eof "has `date`" branch
        duration = me.getDuration();
        endDate = me.getEndDate();
        if (date && endDate && (duration === undefined || duration === null)) {
            me.set(me.durationField, me.calculateDuration(date, endDate, me.getDurationUnit()));
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    // TODO: for milestones another constraint type has to be chosen (FNET instead of SNET)
    getPinConstraintType: function(taskStore) {
        return this.getProjectScheduleBackwards(taskStore) ? 'finishnolaterthan' : 'startnoearlierthan';
    },
    pinWithoutPropagation: function(date, force) {
        var me = this,
            taskStore = me.getTaskStore(true);
        if (me.isPinnable(taskStore)) {
            var pinConstraintType = me.getPinConstraintType(taskStore),
                scheduleBackwards = me.getProjectScheduleBackwards(),
                taskDate = date || (scheduleBackwards ? me.getEndDate() : me.getStartDate());
            me.unpinWithoutPropagation(true);
            if (force || (taskDate - (scheduleBackwards ? me.getLateEndDate() : me.getEarlyStartDate()))) {
                me.setConstraintWithoutPropagation(pinConstraintType, taskDate);
            }
        }
    },
    unpinWithoutPropagation: function(skipRescheduling) {
        this.setConstraintWithoutPropagation(null, null, skipRescheduling);
    },
    isPinnable: function(taskStore) {
        taskStore = taskStore || this.getTaskStore(true);
        var result = false;
        // we should not pin manually scheduled tasks
        if (!this.isManuallyScheduled()) {
            var constraintType = this.getConstraintType();
            // in the backward scheduling mode we pin tasks silently
            if (this.getProjectScheduleBackwards(taskStore)) {
                result = true;
            }
            // in forward scheduling we ask of some constraints violation
            else if (constraintType) {
                switch (constraintType) {
                    case 'assoonaspossible':
                    case 'aslateaspossible':
                    case 'startnoearlierthan':
                    case 'finishnoearlierthan':
                        result = true;
                }
            } else // no constraints -> we can pin
            {
                result = true;
            }
        }
        return result;
    },
    maybePinWithoutPropagation: function(callback) {
        var me = this,
            taskStore = me.getTaskStore(true),
            scheduleBackwards = me.getProjectScheduleBackwards(),
            taskDate = (scheduleBackwards ? me.getEndDate() : me.getStartDate());
        // if the project is scheduled from its start to end
        if (taskStore && taskStore.scheduleByConstraints && !taskStore.isBackwardScheduled() && taskDate && me.isProjected(scheduleBackwards ? me.endDateField : me.startDateField)) {
            var dependencyConstraint = me.getDependencyConstraintClass();
            // If the dependency constraint is set and it's not satisfied let's run constraints verification loop
            // to ask user what to do ..and continue upon user's decision is provided
            if (taskStore.checkDependencyConstraint && dependencyConstraint && dependencyConstraint.hasThisConstraintApplied(me) && !dependencyConstraint.isSatisfied(me)) {
                me.doVerifyConstraints([
                    dependencyConstraint
                ], callback);
            } else {
                // pin the task w/ a constraint
                me.pinWithoutPropagation(taskDate);
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    isPinned: function() {
        return this.getConstraintType() == this.getPinConstraintType();
    },
    /**
     * @method getEndDate
     * Returns the end date of this task
     * @return {Date} end date
     */
    /**
     * @propagating
     * @inheritdoc #setEndDateWithoutPropagation
     * @param {Date} date End date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the end date to the previous working day (if it falls on weekend/holiday).
     * @param {Function} [callback] Callback function to call after end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setEndDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function(task, continueFn) {
            me.setEndDateAndPinWithoutPropagation(date, keepDuration, skipNonWorkingTime, continueFn);
        }, callback, null, true);
    },
    setEndDateAndPinWithoutPropagation: function(endDate, keepDuration, skipNonWorkingTime, continueFn) {
        var me = this,
            result = me.setEndDateWithoutPropagation(endDate, keepDuration, skipNonWorkingTime);
        me.maybePinWithoutPropagation(function(constraintSatisfied, cancelChanges) {
            // If user clicked to cancel changes in constraint resolution UI
            // we pass false to the callback (otherwise we pass the propagation source(s))
            if (continueFn) {
                continueFn(cancelChanges ? false : result);
            }
        });
    },
    // TODO: refactor this
    /**
     * Depending on the arguments, sets either `StartDate + EndDate` fields of this task, or `EndDate + Duration`
     * considering the weekends/holidays rules. The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} date End date to set
     * @param {Boolean} [keepDuration=true] Pass `true` to keep the duration of the task ("move" the task), `false` to change the duration ("resize" the task).
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the end date to the previous working day (if it falls on weekend/holiday).
     */
    setEndDateWithoutPropagation: function(date, keepDuration, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true),
            duration, startDate;
        // {{{ Parameters normalization
        keepDuration = keepDuration !== false;
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false && taskStore) {
            skipNonWorkingTime = taskStore.skipWeekendsDuringDragDrop;
        } else if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = false;
        }
        // }}}
        me.autoCalculateLag();
        me.beginEdit();
        var currentEndDate = me.getEndDate();
        if (!date) {
            me.set(me.durationField, null);
            me.set(me.endDateField, null);
            me.setSegments(null);
        } else {
            startDate = me.getStartDate();
            // task end date cannot be less than its start date
            if (!keepDuration && date < startDate) {
                date = startDate;
            }
            if (skipNonWorkingTime && (!taskStore.scheduleByConstraints || (date - startDate !== 0))) {
                date = me.skipNonWorkingTime(date, false);
            }
            if (keepDuration) {
                duration = me.getDuration();
                if (Ext.isNumber(duration)) {
                    // recalculate segments dates (we need this to calculate the task start date properly)
                    if (taskStore && me.isSegmented() && (date - currentEndDate)) {
                        me.updateSegmentsDates({
                            isForward: false,
                            endDate: date
                        });
                    }
                    me.set(me.startDateField, me.calculateStartDate(date, duration, me.getDurationUnit()));
                    me.set(me.endDateField, date);
                } else {
                    me.set(me.endDateField, date);
                }
            } else {
                var wasMilestone = me.isMilestone();
                // if end date after adjusting to calendar is less than start date
                // then it's going to be a milestone and we set start date equal to adjusted end date
                if (date < startDate) {
                    me.set(me.startDateField, date);
                }
                me.set(me.endDateField, date);
                me.constrainSegments();
                if (startDate) {
                    me.set(me.durationField, me.calculateDuration(startDate, date, me.getDurationUnit()));
                    // if we converted to regular task from milestone
                    // let's make sure that task start is adjusted to the calendar
                    if (wasMilestone && !me.isMilestone()) {
                        var properStartDate = me.skipNonWorkingTime(startDate, true);
                        if (properStartDate - startDate !== 0) {
                            // set start date adjusted to the calendar
                            me.set(me.startDateField, properStartDate);
                        }
                    }
                }
            }
        }
        duration = me.getDuration();
        startDate = me.getStartDate();
        if (date && startDate && (duration === undefined || duration === null)) {
            me.set(me.durationField, me.calculateDuration(startDate, date, me.getDurationUnit()));
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * @propagating
     * @inheritdoc #setStartEndDateWithoutPropagation
     * @param {Date} startDate Start date to set
     * @param {Date} endDate End date to set
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start/end dates to the next/previous working day (if they falls on weekend/holiday).
     * @param {Function} [callback] Callback function to call after start/end date has been set and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setStartEndDate: function(startDate, endDate, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function(task, continueFn) {
            me.setStartEndDateAndPinWithoutPropagation(startDate, endDate, skipNonWorkingTime, continueFn);
        }, callback, null, true);
    },
    setStartEndDateAndPinWithoutPropagation: function(startDate, endDate, skipNonWorkingTime, continueFn) {
        var me = this,
            result = me.setStartEndDateWithoutPropagation(startDate, endDate, skipNonWorkingTime);
        me.maybePinWithoutPropagation(function(constraintSatisfied, cancelChanges) {
            // If user clicked to cancel changes in constraint resolution UI
            // we pass false to the callback (otherwise we pass the propagation source(s))
            if (continueFn) {
                continueFn(cancelChanges ? false : result);
            }
        });
    },
    /**
     * Sets the `StartDate / EndDate / Duration` fields of this task, considering the availability/holidays information.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Date} startDate Start date to set
     * @param {Date} endDate End date to set
     * @param {Boolean} [skipNonWorkingTime=taskStore.skipWeekendsDuringDragDrop] Pass `true` to automatically move the start/end dates to the next/previous working day (if they falls on weekend/holiday).
     */
    setStartEndDateWithoutPropagation: function(startDate, endDate, skipNonWorkingTime) {
        var me = this,
            taskStore = me.getTaskStore(true),
            zeroDuration = startDate && endDate && startDate - endDate === 0;
        // {{{ Parameters normalization
        if (skipNonWorkingTime !== true && skipNonWorkingTime !== false && taskStore) {
            skipNonWorkingTime = taskStore.skipWeekendsDuringDragDrop && (!zeroDuration || !taskStore.scheduleByConstraints);
        } else if (skipNonWorkingTime !== true && skipNonWorkingTime !== false) {
            skipNonWorkingTime = false;
        }
        // }}}
        if (skipNonWorkingTime) {
            startDate = startDate && me.skipNonWorkingTime(startDate, true);
            endDate = endDate && me.skipNonWorkingTime(endDate, false);
            if (endDate != null && endDate < startDate) {
                startDate = endDate;
            }
        }
        var currentStartDate = me.getStartDate(),
            currentEndDate = me.getEndDate();
        me.beginEdit();
        me.set(me.startDateField, startDate);
        me.set(me.endDateField, endDate);
        // recalculate split dates
        if (me.getTaskStore(true) && me.isSegmented() && ((startDate - currentStartDate) || (endDate != null && endDate - currentEndDate))) {
            me.updateSegmentsDates();
        }
        if (endDate != null && endDate - currentEndDate) {
            me.constrainSegments();
        }
        if (endDate == null) {
            me.set(me.durationField, null);
        } else {
            me.set(me.durationField, me.calculateDuration(startDate, endDate, me.getDurationUnit()));
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * @propagating
     * Shifts the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
     * @param {Number} amount The amount to shift
     * @param {Function} [callback] Callback function to call after task has been shifted and changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    shift: function(unit, amount, callback) {
        var me = this,
            startDate = me.getStartDate(),
            endDate = me.getEndDate();
        me.setStartEndDate(startDate && Sch.util.Date.add(startDate, unit, amount), endDate && Sch.util.Date.add(endDate, unit, amount), false, callback);
    },
    /**
     * Returns the duration of the task expressed in the unit passed as the only parameter (or as specified by the DurationUnit for the task).
     *
     * @param {String} [unit] Unit to return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getDuration: function(unit) {
        var result = this.get(this.durationField);
        if (result && unit) {
            result = this.getUnitConverter().convertDuration(result, this.getDurationUnit(), unit);
        }
        return result;
    },
    /**
     * Returns the effort of the task expressed in the unit passed as the only parameter (or as specified by the EffortUnit for the task).
     *
     * @param {String} [unit] Unit to return the effort in. Defaults to the `EffortUnit` field of this task
     *
     * @return {Number} effort
     */
    getEffort: function(unit) {
        var result = this.get(this.effortField) || 0;
        if (result && unit) {
            result = this.getUnitConverter().convertDuration(result, this.getEffortUnit(), unit);
        }
        return result;
    },
    /**
     * @propagating
     * @inheritdoc #setEffortWithoutPropagation
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getEffortUnit()] The unit of the effort.
     * @param {Function} [callback] Callback function to call after effort has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setEffort: function(number, unit, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setEffortWithoutPropagation(number, unit);
        }, callback);
    },
    /**
     * Sets the `Effort + EffortUnit` fields of this task. In case the task has the `EffortDriven`
     * scheduling mode will also update the duration of the task accordingly.
     * In case of `DynamicAssignment` mode - will update the assignments.
     *
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getEffortUnit()] The unit of the effort.
     */
    setEffortWithoutPropagation: function(number, unit) {
        var me = this;
        //region Parameters normalization
        unit = unit || me.getEffortUnit();
        //endregion
        me.beginEdit();
        me.set(me.effortField, number);
        me.set(me.effortUnitField, unit);
        if (me.isEffortDriven()) {
            me.updateSpanBasedOnEffort();
        } else if (me.getSchedulingMode() == 'DynamicAssignment') {
            me.updateAssignments();
        }
        me.set(me.actualEffortField, me.calculateActualEffort());
        me.setEffortVariance(me.calculateEffortVariance());
        me.recalculateCost();
        me.endEdit();
        return true;
    },
    /**
     * Returns the "raw" calendar duration (difference between end and start date) of this task in the given units.
     *
     * Please refer to the "Task durations" section for additional important details about duration units.
     *
     * @param {String} unit Unit to return return the duration in. Defaults to the `DurationUnit` field of this task
     *
     * @return {Number} duration
     */
    getCalendarDuration: function(unit) {
        return this.getUnitConverter().convertMSDurationToUnit(this.getEndDate() - this.getStartDate(), unit || this.get(this.durationUnitField));
    },
    /**
     * @propagating
     * @inheritdoc #setDurationWithoutPropagation
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getDurationUnit()] The unit of the duration.
     * @param {Function} [callback] Callback function to call after duration has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setDuration: function(number, unit, callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.setDurationWithoutPropagation(number, unit);
        }, callback);
    },
    /**
     * Sets the `Duration + DurationUnit + EndDate` fields of this task, considering the weekends/holidays rules.
     * The modifications are wrapped with `beginEdit/endEdit` calls.
     *
     * May also update additional fields, depending on the scheduling mode.
     *
     * @param {Number} number The number of duration units
     * @param {String} [unit=task.getDurationUnit()] The unit of the duration.
     */
    setDurationWithoutPropagation: function(number, unit) {
        var me = this;
        // {{{ Parameters normalization
        unit = unit || me.getDurationUnit();
        // }}}
        var wasMilestone = me.isMilestone(),
            taskStore = me.getTaskStore(true),
            isManuallyScheduled = me.isManuallyScheduled(),
            // If a task has end predecessors, and no start predecessors we update the start date instead of the end date
            updateStartDate = !isManuallyScheduled && me.hasEndPredecessorsButNoStartPredecessors() || me.getProjectScheduleBackwards(taskStore),
            startDate = me.getStartDate(),
            endDate = me.getEndDate(),
            newEndDate = null,
            newStartDate = null;
        me.beginEdit();
        // When scheduleByConstraints is enabled we just change the duration (and unit if provided)
        // and reschedule the task
        if (taskStore && taskStore.scheduleByConstraints) {
            me.set(me.durationField, number);
            me.set(me.durationUnitField, unit);
            // let's recalculate end/start dates
            if (startDate) {
                me.set(me.endDateField, me.recalculateEndDate(startDate));
            } else if (endDate) {
                me.set(me.startDateField, me.recalculateStartDate(endDate));
            }
            // for auto-scheduled task we need rescheduling since above end/start could be not enough
            // so we mark the task for rescheduling during the next (or ongoing) propagation
            if (!isManuallyScheduled) {
                me.markForRescheduling();
            }
            // TODO: We've just changed the duration which could affect Early/Late dates (including this task ones in case project start/end got changed)
            taskStore.resetEarlyDates();
            taskStore.resetLateDates();
            me.constrainSegments({
                duration: number,
                unit: unit
            });
        } else // BW compatibility mode
        {
            // Provide project start date (if any) or now as start date if it isn't already set
            if (Ext.isNumber(number) && !startDate) {
                if (endDate) {
                    // If task has end date but no start date and we're setting the duration, modify start date (handled below)
                    updateStartDate = true;
                } else {
                    // TODO: this is wrong since does not take into account incoming dependencies (not speaking of constraints)
                    newStartDate = (taskStore && taskStore.getProjectStartDate()) || Ext.Date.clearTime(new Date());
                    me.set(me.startDateField, newStartDate);
                }
            }
            me.constrainSegments({
                duration: number,
                unit: unit
            });
            if (Ext.isNumber(number)) {
                if (updateStartDate && me.getEndDate()) {
                    newStartDate = me.calculateStartDate(me.getEndDate(), number, unit);
                } else if (me.getStartDate()) {
                    newEndDate = me.calculateEndDate(me.getStartDate(), number, unit);
                }
            }
            // Don't clear the end date if task isn't properly scheduled
            if (!updateStartDate && (newEndDate || me.getStartDate())) {
                me.set(me.endDateField, newEndDate);
            }
            if (updateStartDate && (newStartDate || me.getEndDate())) {
                me.set(me.startDateField, newStartDate);
            }
            me.set(me.durationField, number);
            me.set(me.durationUnitField, unit);
            // if task is switched to/from milestone then we also need
            // to check if start/end dates are adjusted to the calendar
            if (me.isMilestone() != wasMilestone) {
                // if it's not a milestone now
                if (wasMilestone) {
                    // check if start date is adjusted to calendar
                    startDate = me.getStartDate();
                    if (startDate) {
                        var properStartDate = me.skipNonWorkingTime(startDate, true);
                        if (properStartDate - startDate !== 0) {
                            // set start date adjusted to the calendar
                            me.set(me.startDateField, properStartDate);
                        }
                    }
                }
                // if it's a milestone
                else if (newEndDate) {
                    // skip non-working time backward
                    var properEndDate = me.skipNonWorkingTime(newEndDate, false);
                    if (properEndDate - newEndDate !== 0) {
                        // set start/end dates adjusted to the calendar
                        me.set(me.startDateField, properEndDate);
                        me.set(me.endDateField, properEndDate);
                    }
                }
            }
        }
        me.onPotentialEffortChange();
        me.endEdit();
        return true;
    },
    /**
     * @private
     * Defines whether resource calendars should be taken into account for the provided scheduling mode or not.
     * @param  {String} schedulingMode A supported scheduling mode (one of allowed {@link #SchedulingMode} field values)
     * @return {Boolean} Return `false` to prevent using resource calendars when dealing with the provided scheduling mode.
     */
    shouldUseResourceCalendarsForSchedulingMode: function(schedulingMode) {
        return !this.ignoreResourceCalendarsForSchedulingMode || !this.ignoreResourceCalendarsForSchedulingMode[schedulingMode];
    },
    calculateStartDate: function(endDate, duration, unit, options) {
        unit = unit || this.getDurationUnit();
        if (!duration || !endDate)  {
            return endDate;
        }
        
        var me = this,
            schedulingMode = me.getSchedulingMode(),
            useResources = me.shouldUseResourceCalendarsForSchedulingMode(schedulingMode) && me.hasResources(),
            durationInMS = me.getUnitConverter().convertDurationToMs(duration, unit),
            isSegmented = me.isSegmented(),
            result;
        // We use forEachAvailabilityInterval iterator when we need to take into account extra factors, namely:
        // - Task segments
        // - Resources calendars
        if (me.getTaskStore(true) && (me.isSegmented() || useResources)) {
            var leftDuration = durationInMS;
            options = Ext.apply({
                endDate: endDate,
                isForward: false,
                offsetSegments: isSegmented,
                resources: useResources
            }, options);
            me.forEachAvailabilityInterval(options, function(from, till) {
                var intervalDuration = till - from;
                if (intervalDuration >= leftDuration) {
                    result = new Date(till - leftDuration);
                    return false;
                } else {
                    var dstDiff = new Date(till).getTimezoneOffset() - new Date(from).getTimezoneOffset();
                    leftDuration -= intervalDuration + dstDiff * 60 * 1000;
                }
            });
        } else {
            // otherwise just consult the task calendar
            result = me.getCalendar().calculateStartDate(endDate, durationInMS, 'MILLI');
        }
        return result;
    },
    // Recalculates a task end date based on a new start date (use task start date if omitted)
    recalculateEndDate: function(startDate) {
        var me = this,
            result, duration;
        startDate = startDate || me.getStartDate();
        if (startDate && me.isEffortDriven()) {
            result = me.calculateEffortDrivenEndDate(startDate, me.getEffort());
        } else {
            duration = me.getDuration();
            if (startDate && Ext.isNumber(duration)) {
                result = me.calculateEndDate(startDate, duration, me.getDurationUnit());
            } else {
                result = me.getEndDate();
            }
        }
        return result;
    },
    recalculateStartDate: function(endDate) {
        var me = this,
            result, duration;
        endDate = endDate || me.getStartDate();
        if (endDate && me.isEffortDriven()) {
            result = me.calculateEffortDrivenStartDate(endDate, me.getEffort());
        } else {
            duration = me.getDuration();
            if (endDate && Ext.isNumber(duration)) {
                result = me.calculateStartDate(endDate, duration, me.getDurationUnit());
            } else {
                result = me.getStartDate();
            }
        }
        return result;
    },
    calculateEndDate: function(startDate, duration, unit, options) {
        unit = unit || this.getDurationUnit();
        if (!duration || !startDate)  {
            return startDate;
        }
        
        var me = this,
            schedulingMode = me.getSchedulingMode(),
            useResources = me.shouldUseResourceCalendarsForSchedulingMode(schedulingMode) && me.hasResources(),
            durationInMS = me.getUnitConverter().convertDurationToMs(duration, unit),
            isSegmented = me.isSegmented(),
            result;
        // We use forEachAvailabilityInterval iterator when we need to take into account extra factors, namely:
        // - Task segments
        // - Resource calendars
        if (me.getTaskStore(true) && (isSegmented || useResources)) {
            var leftDuration = durationInMS;
            options = Ext.apply({
                startDate: startDate,
                offsetSegments: isSegmented,
                resources: useResources
            }, options);
            me.forEachAvailabilityInterval(options, function(from, till) {
                var intervalDuration = till - from;
                if (intervalDuration >= leftDuration) {
                    result = new Date(from + leftDuration);
                    return false;
                } else {
                    var dstDiff = new Date(from).getTimezoneOffset() - new Date(till).getTimezoneOffset();
                    leftDuration -= intervalDuration + dstDiff * 60 * 1000;
                }
            });
        } else {
            // otherwise just consult the task calendar
            result = me.getCalendar().calculateEndDate(startDate, durationInMS, 'MILLI');
        }
        return result;
    },
    calculateDuration: function(startDate, endDate, unit, options) {
        unit = unit || this.getDurationUnit();
        if (!startDate || !endDate) {
            return 0;
        }
        var me = this,
            schedulingMode = me.getSchedulingMode(),
            useResources = me.shouldUseResourceCalendarsForSchedulingMode(schedulingMode) && me.hasResources(),
            durationInMS = 0;
        // We use forEachAvailabilityInterval iterator when we need to take into account extra factors, namely:
        // - Task segments
        // - Resource calendars
        if (me.getTaskStore(true) && (me.isSegmented() || useResources)) {
            me.forEachAvailabilityInterval(Ext.apply({
                startDate: startDate,
                endDate: endDate,
                resources: useResources
            }, options), function(from, till) {
                var dstDiff = new Date(from).getTimezoneOffset() - new Date(till).getTimezoneOffset();
                durationInMS += till - from + dstDiff * 60 * 1000;
            });
        } else {
            // otherwise just consult the task calendar
            durationInMS = me.getCalendar().calculateDuration(startDate, endDate, 'MILLI');
        }
        return me.getUnitConverter().convertMSDurationToUnit(durationInMS, unit);
    },
    isCalendarApplicable: function(calendarId) {
        var startDate = this.getStartDate();
        if (!startDate)  {
            return true;
        }
        
        var taskStore = this.getTaskStore(true);
        if (!taskStore)  {
            return true;
        }
        
        var endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, (taskStore && taskStore.availabilitySearchLimit) || 5 * 365);
        var assignments = this.getAssignments();
        var resourcesCalendars = [];
        Ext.Array.each(assignments, function(assignment) {
            var resource = assignment.getResource();
            if (resource) {
                resourcesCalendars.push(resource.getCalendar());
            }
        });
        if (!resourcesCalendars.length)  {
            return true;
        }
        
        var calendar = Gnt.data.Calendar.getCalendar(calendarId);
        for (var i = 0,
            l = resourcesCalendars.length; i < l; i++) {
            if (calendar.isAvailabilityIntersected(resourcesCalendars[i], startDate, endDate))  {
                return true;
            }
            
        }
        return false;
    },
    forEachAvailabilityInterval: function(options, func, scope) {
        func = func || options.fn;
        scope = scope || options.scope || this;
        var me = this,
            startDate = options.startDate,
            endDate = options.endDate,
            includeEmptyIntervals = options.includeEmptyIntervals,
            needResources = options.resources,
            useSegments = (options.segments !== false) && me.isSegmented(),
            offsetSegments = options.offsetSegments,
            // isForward enabled by default
            isForward = options.isForward !== false,
            DATE = Sch.util.Date,
            cursorDate, pointTimesSortFn, pointsSortFn;
        // need taskStore to get default `availabilitySearchLimit` value
        var store = me.getTaskStore(true);
        var i, k, l, interval, intervalStart, intervalEnd;
        if (isForward) {
            if (!startDate)  {
                throw new Error("forEachAvailabilityInterval: `startDate` is required when `isForward` is true");
            }
            
            // if no boundary we still have to specify some limit
            if (!endDate)  {
                endDate = DATE.add(Ext.isNumber(startDate) ? new Date(startDate) : startDate, Sch.util.Date.DAY, options.availabilitySearchLimit || (store && store.availabilitySearchLimit) || 5 * 365);
            }
            
            cursorDate = new Date(startDate);
            pointTimesSortFn = function(a, b) {
                return a - b;
            };
            pointsSortFn = function(a, b) {
                return a.type < b.type ? 1 : -1;
            };
        } else {
            if (!endDate)  {
                throw new Error("forEachAvailabilityInterval: `endDate` is required when `isForward` is false");
            }
            
            // if no boundary we still have to specify some limit
            if (!startDate)  {
                startDate = DATE.add(Ext.isNumber(endDate) ? new Date(endDate) : endDate, Sch.util.Date.DAY, -(options.availabilitySearchLimit || (store && store.availabilitySearchLimit) || 5 * 365));
            }
            
            cursorDate = new Date(endDate);
            pointTimesSortFn = function(a, b) {
                return b - a;
            };
            pointsSortFn = function(a, b) {
                return a.type > b.type ? 1 : -1;
            };
        }
        var taskCalendar = me.getOwnCalendar(),
            projectCalendar = me.getProjectCalendar(true) || taskCalendar,
            resourceByCalendar = {},
            calendars = [];
        // if we take resources into account
        if (needResources) {
            var resourceFound = false;
            // we can provide list of assignments as well
            var assignments = options.assignments;
            // helper function to prepare resources data
            var handleResource = function(resource) {
                    var resourceId = resource.getId(),
                        assignment = assignments && Ext.Array.findBy(assignments, function(a) {
                            return a.getResourceId() == resourceId;
                        }) || me.getAssignmentFor(resource),
                        calendar = resource.getCalendar(),
                        id = calendar.getCalendarId();
                    if (!resourceByCalendar[id]) {
                        resourceByCalendar[id] = [];
                        calendars.push(calendar);
                    }
                    resourceByCalendar[id].push({
                        assignment: assignment,
                        resourceId: resourceId,
                        units: assignment && assignment.getUnits()
                    });
                    resourceFound = true;
                };
            // user has provided the resources to use for iteration
            if (needResources !== true) {
                Ext.each(needResources, handleResource);
            } else // otherwise retrieve all assigned resources
            {
                Ext.Array.each(me.getAssignments(), function(assignment) {
                    var resource = assignment.getResource();
                    if (resource)  {
                        handleResource(resource);
                    }
                    
                });
            }
            // if there are no resources - then iterator should not be called by contract, just return
            if (!resourceFound)  {
                return;
            }
            
        } else // if we don't use resource calendars for calculation then we use the task/project calendar
        {
            taskCalendar = taskCalendar || projectCalendar;
        }
        var workingTimeDuration = 0,
            inSegment = true,
            splitStartDates, splitEndDates, splitStartDate, splitEndDate, splitStart, splitEnd;
        // We need to take segments into account
        // Let's walk over the segments and "invert" them.
        // We need to operate non working intervals (splits) instead of StartDate-EndDate pairs.
        if (useSegments) {
            var fillSplitDates;
            splitStartDates = [];
            splitEndDates = [];
            // If this mode enabled we shift segments to match the first (last - depending isForward flag) availability interval found.
            // This is used when calculating the task start/end date.
            // We cannot operate segments dates since they are not updated yet ..we have to convert offsets to dates
            if (offsetSegments) {
                if (isForward) {
                    splitEnd = cursorDate;
                    fillSplitDates = function(segment) {
                        var neigbourSegment = segment.getNextSegment();
                        if (neigbourSegment) {
                            splitStart = segment.skipWorkingTime(splitEnd, segment.getEndOffset() - segment.getStartOffset(), isForward) - 0;
                            splitEnd = segment.skipWorkingTime(splitStart, neigbourSegment.getStartOffset() - segment.getEndOffset(), isForward) - 0;
                        }
                        return neigbourSegment;
                    };
                } else {
                    splitStart = cursorDate;
                    fillSplitDates = function(segment) {
                        var neigbourSegment = segment.getPrevSegment();
                        if (neigbourSegment) {
                            splitEnd = segment.skipWorkingTime(splitStart, segment.getEndOffset() - segment.getStartOffset(), isForward) - 0;
                            splitStart = segment.skipWorkingTime(splitEnd, segment.getStartOffset() - neigbourSegment.getEndOffset(), isForward) - 0;
                        }
                        return neigbourSegment;
                    };
                }
            } else // use segment dates as-is
            {
                if (isForward) {
                    fillSplitDates = function(segment) {
                        var neigbourSegment = segment.getNextSegment();
                        if (neigbourSegment) {
                            splitStart = segment.getEndDate() - 0;
                            splitEnd = neigbourSegment.getStartDate() - 0;
                        }
                        return neigbourSegment;
                    };
                } else {
                    fillSplitDates = function(segment) {
                        var neigbourSegment = segment.getPrevSegment();
                        if (neigbourSegment) {
                            splitStart = segment.getEndDate() - 0;
                            splitEnd = neigbourSegment.getStartDate() - 0;
                        }
                        return neigbourSegment;
                    };
                }
            }
            me.forEachSegment(function collectSplits(segment) {
                if (fillSplitDates(segment)) {
                    // set initial "inSegment" value (depending on "isForward" mode)
                    if (splitStart < startDate) {
                        inSegment = !isForward;
                    }
                    // we use the split only if it intersects w/ the requested timespan
                    else if (splitStart <= endDate) {
                        splitStartDates.push(splitStart);
                    }
                    // set initial "inSegment" value (depending on "isForward" mode)
                    if (splitEnd < startDate) {
                        inSegment = isForward;
                    }
                    // we use the split only if it intersects w/ the requested timespan
                    else if (splitEnd <= endDate) {
                        splitEndDates.push(splitEnd);
                    }
                }
            }, isForward);
            splitStartDate = splitStartDates.shift();
            splitEndDate = splitEndDates.shift();
        }
        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            var pointsByTime = {};
            var pointTimes = [];
            var cursorDT = cursorDate - (isForward ? 0 : 1);
            // if a task has a custom calendar
            if (taskCalendar) {
                var taskIntervals = taskCalendar.getAvailabilityIntervalsFor(cursorDT);
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0 , l = taskIntervals.length; k < l; k++) {
                    interval = taskIntervals[k];
                    intervalStart = interval.startDate - 0;
                    intervalEnd = interval.endDate - 0;
                    if (!pointsByTime[intervalStart]) {
                        pointsByTime[intervalStart] = [];
                        pointTimes.push(intervalStart);
                    }
                    pointsByTime[intervalStart].push({
                        type: '00-taskAvailailabilityStart'
                    });
                    pointTimes.push(intervalEnd);
                    pointsByTime[intervalEnd] = pointsByTime[intervalEnd] || [];
                    pointsByTime[intervalEnd].push({
                        type: '01-taskAvailailabilityEnd'
                    });
                }
            }
            // If we take the task segmentation into account
            if (useSegments && (splitStartDate || splitEndDate)) {
                var nextCursorDT = isForward ? DATE.getStartOfNextDay(cursorDate) - 0 : DATE.getEndOfPreviousDay(cursorDate) - 1;
                // if split start is inside of this interval
                while (splitStartDate && (isForward ? splitStartDate < nextCursorDT : splitStartDate > nextCursorDT)) {
                    if (!pointsByTime[splitStartDate]) {
                        pointsByTime[splitStartDate] = [];
                        pointTimes.push(splitStartDate);
                    }
                    pointsByTime[splitStartDate].push({
                        type: '05-taskSegmentEnd'
                    });
                    splitStartDate = splitStartDates.shift();
                }
                // if split end is inside of this interval
                while (splitEndDate && (isForward ? splitEndDate < nextCursorDT : splitEndDate > nextCursorDT)) {
                    if (!pointsByTime[splitEndDate]) {
                        pointsByTime[splitEndDate] = [];
                        pointTimes.push(splitEndDate);
                    }
                    pointsByTime[splitEndDate].push({
                        type: '04-taskSegmentStart'
                    });
                    splitEndDate = splitEndDates.shift();
                }
            }
            var resourceList;
            // loop over resources having custom calendars
            for (i = 0 , l = calendars.length; i < l; i++) {
                var cal = calendars[i],
                    resourceIntervals = cal.getAvailabilityIntervalsFor(cursorDT);
                resourceList = resourceByCalendar[cal.getCalendarId()];
                // using "for" instead of "each" should be blazing fast! :)
                // the order of intervals processing doesn't matter here, since we are just collecting the "points of interest"
                for (k = 0; k < resourceIntervals.length; k++) {
                    interval = resourceIntervals[k];
                    intervalStart = interval.startDate - 0;
                    intervalEnd = interval.endDate - 0;
                    if (!pointsByTime[intervalStart]) {
                        pointsByTime[intervalStart] = [];
                        pointTimes.push(intervalStart);
                    }
                    pointsByTime[intervalStart].push({
                        type: '02-resourceAvailailabilityStart',
                        resources: resourceList
                    });
                    if (!pointsByTime[intervalEnd]) {
                        pointsByTime[intervalEnd] = [];
                        pointTimes.push(intervalEnd);
                    }
                    pointsByTime[intervalEnd].push({
                        type: '03-resourceAvailailabilityEnd',
                        resources: resourceList
                    });
                }
            }
            pointTimes.sort(pointTimesSortFn);
            var inTaskCalendar = false,
                currentResources = {},
                resourceCounter = 0,
                isWorkingTime = false,
                newPointTimes = null,
                points, point, m, n;
            var inc = 1;
            if (isForward) {
                for (i = 0; i < pointTimes.length; i += inc) {
                    inc = 1;
                    intervalStart = pointTimes[i];
                    intervalEnd = pointTimes[i + 1];
                    points = pointsByTime[intervalStart];
                    points.sort(pointsSortFn);
                    for (k = 0; k < points.length; k++) {
                        point = points[k];
                        switch (point.type) {
                            case '00-taskAvailailabilityStart':
                                inTaskCalendar = true;
                                break;
                            case '01-taskAvailailabilityEnd':
                                inTaskCalendar = false;
                                break;
                            case '02-resourceAvailailabilityStart':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    currentResources[resourceList[m].resourceId] = resourceList[m];
                                    resourceCounter++;
                                };
                                break;
                            case '03-resourceAvailailabilityEnd':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    delete currentResources[resourceList[m].resourceId];
                                    resourceCounter--;
                                };
                                break;
                            case '04-taskSegmentStart':
                                inSegment = true;
                                break;
                            case '05-taskSegmentEnd':
                                inSegment = false;
                                break;
                        }
                    }
                    // availability interval is out of [ startDate, endDate )
                    if (intervalStart >= endDate || intervalEnd <= startDate)  {
                        
                        continue;
                    }
                    
                    isWorkingTime = (inTaskCalendar || !taskCalendar) && (!needResources || resourceCounter);
                    if (inc && intervalStart && intervalEnd && ((isWorkingTime && inSegment) || includeEmptyIntervals)) {
                        if (intervalStart < startDate)  {
                            intervalStart = startDate - 0;
                        }
                        
                        if (intervalEnd > endDate)  {
                            intervalEnd = endDate - 0;
                        }
                        
                        if (func.call(scope, intervalStart, intervalEnd, currentResources) === false)  {
                            return false;
                        }
                        
                    }
                }
            } else {
                for (i = 0; i < pointTimes.length; i += inc) {
                    inc = 1;
                    intervalStart = pointTimes[i + 1];
                    intervalEnd = pointTimes[i];
                    points = pointsByTime[intervalEnd];
                    points.sort(pointsSortFn);
                    for (k = 0; k < points.length; k++) {
                        point = points[k];
                        switch (point.type) {
                            case '01-taskAvailailabilityEnd':
                                inTaskCalendar = true;
                                break;
                            case '00-taskAvailailabilityStart':
                                inTaskCalendar = false;
                                break;
                            case '03-resourceAvailailabilityEnd':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    currentResources[resourceList[m].resourceId] = resourceList[m];
                                    resourceCounter++;
                                };
                                break;
                            case '02-resourceAvailailabilityStart':
                                resourceList = point.resources;
                                for (m = 0 , n = resourceList.length; m < n; m++) {
                                    delete currentResources[resourceList[m].resourceId];
                                    resourceCounter--;
                                };
                                break;
                            case '05-taskSegmentEnd':
                                inSegment = true;
                                break;
                            case '04-taskSegmentStart':
                                inSegment = false;
                                break;
                        }
                    }
                    // availability interval is out of [ startDate, endDate )
                    if (intervalStart > endDate || intervalEnd <= startDate)  {
                        
                        continue;
                    }
                    
                    isWorkingTime = (inTaskCalendar || !taskCalendar) && (!needResources || resourceCounter);
                    if (inc && intervalStart && intervalEnd && ((isWorkingTime && inSegment) || includeEmptyIntervals)) {
                        if (intervalStart < startDate)  {
                            intervalStart = startDate - 0;
                        }
                        
                        if (intervalEnd > endDate)  {
                            intervalEnd = endDate - 0;
                        }
                        
                        if (func.call(scope, intervalStart, intervalEnd, currentResources) === false)  {
                            return false;
                        }
                        
                    }
                }
            }
            // eof backward branch
            // does not perform cloning internally!
            cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate) : DATE.getEndOfPreviousDay(cursorDate);
        }
    },
    // eof while
    // iterates over the common availability intervals for tasks and resources in between `startDate/endDate`
    // note, that function will receive start/end dates as number, not dates (for optimization purposes)
    // this method is not "normalized" intentionally because of performance considerations
    forEachAvailabilityIntervalWithResources: function(options, func, scope) {
        if (!options.resources)  {
            options.resources = true;
        }
        
        this.forEachAvailabilityInterval.apply(this, arguments);
    },
    calculateEffortDrivenEndDate: function(startDate, effort, unit) {
        if (!effort)  {
            return startDate;
        }
        
        var effortInMS = this.getUnitConverter().convertDurationToMs(effort, unit || this.getEffortUnit());
        var endDate = new Date(startDate);
        this.forEachAvailabilityIntervalWithResources({
            startDate: startDate
        }, function(intervalStartDate, intervalEndDate, currentResources) {
            var totalUnits = 0;
            for (var i in currentResources) totalUnits += currentResources[i].units;
            var intervalDuration = intervalEndDate - intervalStartDate;
            var availableEffort = totalUnits * intervalDuration / 100;
            if (availableEffort >= effortInMS) {
                endDate = new Date(intervalStartDate + effortInMS / availableEffort * intervalDuration);
                return false;
            } else {
                effortInMS -= availableEffort;
            }
        });
        return endDate;
    },
    calculateEffortDrivenStartDate: function(endDate, effort, unit) {
        if (!effort)  {
            return endDate;
        }
        
        var effortInMS = this.getUnitConverter().convertDurationToMs(effort, unit || this.getEffortUnit());
        var result = new Date(endDate);
        this.forEachAvailabilityIntervalWithResources({
            endDate: endDate,
            isForward: false
        }, function(intervalStartDate, intervalEndDate, currentResources) {
            var totalUnits = 0;
            for (var i in currentResources) totalUnits += currentResources[i].units;
            var intervalDuration = intervalEndDate - intervalStartDate;
            var availableEffort = totalUnits * intervalDuration / 100;
            if (availableEffort >= effortInMS) {
                result = new Date(intervalEndDate - effortInMS / availableEffort * intervalDuration);
                return false;
            } else {
                effortInMS -= availableEffort;
            }
        });
        return result;
    },
    // this method has a contract that all child parents should already have refreshed data, so it should be called
    // in the "bubbling" order - starting from deeper nodes to closer to root
    refreshCalculatedParentNodeData: function() {
        // Wrap with beginEdit/endEdit since otherwise this will cause an infinite loop
        // since endEdit calls taskStore.onEndUpdate() which in turn starts parents recalculation
        this.beginEdit();
        var childNodes = this.childNodes;
        var autoCalculatePercentDoneForParentTask = this.autoCalculatePercentDoneForParentTask;
        var autoCalculateEffortForParentTask = this.autoCalculateEffortForParentTask;
        var autoCalculateCostForParentTask = this.autoCalculateCostForParentTask;
        var length = childNodes.length;
        var changedFields = {};
        if (length > 0 && (autoCalculateEffortForParentTask || autoCalculatePercentDoneForParentTask || autoCalculateCostForParentTask)) {
            var totalEffortInMS = 0;
            var totalDurationInMS = 0;
            var completedDurationInMS = 0;
            var cost = 0;
            var actualCost = 0;
            var allTasksAreMilestonesAndFinished = true;
            var hasUnfinishedMilestone = false;
            for (var k = 0; k < length; k++) {
                var childNode = childNodes[k];
                // We could end up here as a result of taskStore#removeAll which means some of the child nodes could already
                // be removed
                if (childNode.parentNode) {
                    var isLeaf = childNode.isLeaf();
                    if (autoCalculateEffortForParentTask)  {
                        totalEffortInMS += childNode.getEffort('MILLI');
                    }
                    
                    if (autoCalculateCostForParentTask) {
                        cost += childNode.getCost();
                        actualCost += childNode.getActualCost();
                    }
                    if (autoCalculatePercentDoneForParentTask) {
                        var durationInMS = isLeaf ? childNode.getDuration('MILLI') || 0 : childNode.childTasksDuration,
                            childPercentDone = childNode.getPercentDone() || 0;
                        totalDurationInMS += durationInMS;
                        completedDurationInMS += isLeaf ? durationInMS * childPercentDone : childNode.completedChildTasksDuration;
                        hasUnfinishedMilestone = hasUnfinishedMilestone || childNode.hasUnfinishedMilestone || (durationInMS === 0 && childPercentDone < 100);
                        allTasksAreMilestonesAndFinished = allTasksAreMilestonesAndFinished && durationInMS === 0 && childPercentDone >= 100;
                    }
                }
            }
            if (autoCalculateEffortForParentTask && this.getEffort('MILLI') != totalEffortInMS) {
                changedFields.Effort = true;
                this.setEffortWithoutPropagation(this.getUnitConverter().convertMSDurationToUnit(totalEffortInMS, this.getEffortUnit()));
            }
            if (autoCalculatePercentDoneForParentTask) {
                var newPercentDone = 0;
                this.childTasksDuration = totalDurationInMS;
                this.completedChildTasksDuration = completedDurationInMS;
                this.hasUnfinishedMilestone = hasUnfinishedMilestone;
                if (totalDurationInMS > 0) {
                    newPercentDone = completedDurationInMS / totalDurationInMS;
                    // Indicate there are unfinished tasks
                    if (newPercentDone === 100 && hasUnfinishedMilestone) {
                        newPercentDone = 99;
                    }
                } else if (allTasksAreMilestonesAndFinished) {
                    // For parent tasks containing only milestones, if there is at least one task with < 100% done, the parent task should report itself as 0% done
                    // If all children are 100%, parent reports 100% done too
                    newPercentDone = 100;
                }
                if (this.getPercentDone() != newPercentDone) {
                    changedFields.PercentDone = true;
                    this.setPercentDoneWithoutPropagation(newPercentDone);
                }
            }
            if (autoCalculateCostForParentTask) {
                this.setActualCost(actualCost);
                this.setCost(cost);
            }
        }
        var startChanged, endChanged;
        if (!this.isRoot() && length > 0 && !this.isManuallyScheduled() && !this.isReadOnly()) {
            var minDate = new Date(-8.64E15),
                maxDate = new Date(+8.64E15),
                earliest = new Date(+8.64E15),
                //new Date(maxDate)
                latest = new Date(-8.64E15),
                //new Date(minDate) - this works incorrect in FF
                isProject = this.isProject,
                scheduleBackwards = isProject && this.getScheduleBackwards();
            // If it's a project
            if (isProject) {
                if (scheduleBackwards) {
                    latest = this.getEndDate();
                } else {
                    earliest = this.getStartDate();
                }
            }
            for (var i = 0; i < length; i++) {
                var r = childNodes[i];
                // If it's a project node
                if (isProject) {
                    // we calculate either its finish or start
                    if (scheduleBackwards) {
                        earliest = Sch.util.Date.min(earliest, r.getStartDate() || earliest);
                    } else {
                        latest = Sch.util.Date.max(latest, r.getEndDate() || latest);
                    }
                } else {
                    earliest = Sch.util.Date.min(earliest, r.getStartDate() || earliest);
                    latest = Sch.util.Date.max(latest, r.getEndDate() || latest);
                }
            }
            // This could happen if a parent task has two children, one having just start date and another having just an end date
            if (latest < earliest && earliest < maxDate && latest > minDate) {
                var tmp;
                tmp = latest;
                latest = earliest;
                earliest = tmp;
            }
            startChanged = changedFields.StartDate = earliest - maxDate !== 0 && this.getStartDate() - earliest !== 0;
            endChanged = changedFields.EndDate = latest - minDate !== 0 && this.getEndDate() - latest !== 0;
            // special case to only trigger 1 update event and avoid extra "recalculateParents" calls
            // wrapping with `beginEdit / endEdit` is not an option, because they do not nest (one "endEdit" will "finalize" all previous "beginEdit")
            if (startChanged && endChanged) {
                this.setStartEndDateWithoutPropagation(earliest, latest, false);
            } else if (startChanged) {
                this.setStartDateWithoutPropagation(earliest, false, false);
            } else if (endChanged) {
                this.setEndDateWithoutPropagation(latest, false, false);
            }
        }
        this.endEdit();
        return changedFields;
    },
    // This function is mostly used for backward compatibility as it does not trigger the changes propagation
    recalculateParents: function() {
        var parent = this.parentNode;
        parent && (parent.refreshCalculatedParentNodeData() , !this.getTaskStore().cascading && parent.recalculateParents());
    },
    /**
     * Returns true if this task is a milestone (has the same start and end dates).
     *
     * @param {Boolean} [isBaseline] Whether to check for baseline dates instead of "normal" dates. If this argument is provided with
     * "true" value, this method returns the result from the {@link #isBaselineMilestone} method.
     *
     * @return {Boolean}
     */
    isMilestone: function(isBaseline) {
        if (isBaseline)  {
            return this.isBaselineMilestone();
        }
        
        // a summary task may have zero duration when "recalculateParents" is on
        // and a child task has working time on the summary task non-working time
        // so we operate start and end date pair here
        if (!this.get('leaf')) {
            var startDate = this.getStartDate(),
                endDate = this.getEndDate();
            if (startDate && endDate) {
                return endDate - startDate === 0;
            }
        }
        return this.getDuration() === 0;
    },
    /**
     * @propagating
     * @inheritdoc #convertToMilestoneWithoutPropagation
     * @param {Function} [callback] Callback function to call after task has been converted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    convertToMilestone: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.convertToMilestoneWithoutPropagation();
        }, callback);
    },
    /**
     * Converts this task to a milestone (start date will match the end date).
     */
    convertToMilestoneWithoutPropagation: function() {
        var me = this,
            propagate = false;
        if (!me.isMilestone()) {
            propagate = me.setStartDateWithoutPropagation(me.getEndDate(), false);
            var taskStore = me.getTaskStore(true),
                scheduleByConstraints = taskStore && taskStore.scheduleByConstraints;
            if (scheduleByConstraints) {
                me.markForRescheduling();
            }
        }
        return propagate;
    },
    /**
     * @propagating
     * @inheritdoc #convertToRegularWithoutPropagation
     * @param {Function} [callback] Callback function to call after task has been converted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    convertToRegular: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.convertToRegularWithoutPropagation();
        }, callback);
    },
    /**
     * Converts a milestone task to a regular task with a duration of 1 [durationUnit].
     */
    convertToRegularWithoutPropagation: function() {
        var me = this,
            propagate = false,
            unit, newStart;
        if (me.isMilestone()) {
            unit = me.get(me.durationUnitField);
            var taskStore = me.getTaskStore(true),
                scheduleByConstraints = taskStore && taskStore.scheduleByConstraints;
            if (!scheduleByConstraints) {
                newStart = me.calculateStartDate(me.getStartDate(), 1, unit);
            }
            propagate = me.setDurationWithoutPropagation(1, unit);
            if (!scheduleByConstraints) {
                // we set the `moveParentAsGroup` flag to false, because in this case we don't want/need to
                // change any of child tasks
                propagate = propagate && me.setStartDateWithoutPropagation(newStart, true, false, false);
            }
        }
        return propagate;
    },
    /**
     * Returns true if this task is a "baseline" milestone (has the same start and end baseline dates) or false if it's not or the dates are wrong.
     *
     * @return {Boolean}
     */
    isBaselineMilestone: function() {
        var baseStart = this.getBaselineStartDate(),
            baseEnd = this.getBaselineEndDate();
        if (baseStart && baseEnd) {
            return baseEnd - baseStart === 0;
        }
        return false;
    },
    // Sets the task "leaf" attribute to `false` and resets `Segments` field
    // since a parent task cannot be split
    markAsParent: function() {
        var me = this;
        me.isSegmented() && me.setSegmentsWithoutPropagation(null);
        // Parent task should never be split
        me.set('leaf', false);
    },
    /**
     * Returns the duration unit of the task.
     * @return {String} the duration unit
     */
    getDurationUnit: function() {
        return this.get(this.durationUnitField) || Sch.util.Date.DAY;
    },
    /**
     * @method setDurationUnit
     *
     * Updates the duration unit of the task.
     *
     * @param {String} unit New duration unit
     * @return {String} the duration unit
     */
    /**
     * Returns the effort unit of the task.
     * @return {String} the effort unit
     */
    getEffortUnit: function() {
        return this.get(this.effortUnitField) || Sch.util.Date.HOUR;
    },
    /**
     * @method setEffortUnit
     *
     * Updates the effort unit of the task.
     *
     * @param {String} unit New effort unit
     * @return {String} the effort unit
     */
    /**
     * @method setDeadlineDate
     *
     * Sets the deadline date for this task
     *
     * @param {Date} date
     */
    /**
     * @method getDeadlineDate
     *
     * Returns the task deadline date
     *
     * @return {Date} date
     */
    /**
     * @method setRollup
     *
     * Controls if this task should roll up to its parent
     *
     * @param {Boolean} rollup
     */
    /**
     * @method getRollup
     *
     * Gets the rollup value for this task
     *
     * @return {Boolean} value
     */
    /**
     * Sets the percent complete value of the task
     *
     * @propagating This method might launch the changes propagation process over the dependent tasks in case
     * the task has percent complete set to 100% and the new value is less.
     * In this case the task stops being manually scheduled and thus requires rescheduling.
     *
     * @param {Number} value The new value
     * @param {Function} [callback] Callback function to call after the percent value has been set and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    setPercentDone: function(percentDone, callback) {
        var me = this;
        if (me.rescheduleOnPercentDoneChange(percentDone)) {
            me.propagateChanges(function() {
                return me.setPercentDoneWithoutPropagation(percentDone);
            }, callback);
        } else {
            me.setPercentDoneWithoutPropagation(percentDone);
            var affectedTasks = {};
            affectedTasks[me.getId()] = me;
            callback && callback(true, affectedTasks);
        }
    },
    /**
     * Sets the percent complete value of the task
     * @param {Number} value The new value
     */
    setPercentDoneWithoutPropagation: function(percentDone) {
        var me = this;
        if (percentDone != me.getPercentDone()) {
            me.beginEdit();
            if (me.rescheduleOnPercentDoneChange(percentDone)) {
                me.markForRescheduling();
            }
            me.set(me.percentDoneField, percentDone);
            me.set(me.actualEffortField, me.calculateActualEffort());
            me.recalculateCost();
            me.endEdit();
        }
        return true;
    },
    rescheduleOnPercentDoneChange: function(percentDone) {
        // We used to have this comment & code here:
        // We need to reschedule the task (and all the related tasks too)
        // if the task will stop being manually scheduled because of the percent change
        // return !this.getManuallyScheduled() && this.isCompleted() && percentDone < 100;
        // But now changing of PercentDone field always triggers propagation
        // since calculation of aggregated PercentDone on parents is done as part of the propagation process
        return true;
    },
    /**
     * @method getPercentDone
     *
     * Gets the percent complete value of the task
     * @return {Number} The percent complete value of the task
     */
    /**
     * @method getCls
     *
     * Returns the CSS class for the task element
     *
     * @return {String} CSS class for the task element
     */
    /**
     * @method getBaselineStartDate
     *
     * Returns the baseline start date of this task
     *
     * @return {Date} The baseline start date
     */
    /**
     * @method setBaselineStartDate
     *
     * Sets the baseline start date of this task
     *
     * @param {Date} date
     */
    /**
     * @method getBaselineEndDate
     *
     * Returns the baseline end date of this task
     *
     * @return {Date} The baseline end date
     */
    /**
     * @method setBaselineEndDate
     *
     * Sets the baseline end date of this task
     *
     * @param {Date} date
     */
    /**
     * @method setBaselinePercentDone
     *
     * Sets the baseline percent complete value
     *
     * @param {Number} value The new value
     */
    /**
     * Gets the baseline percent complete value
     * @return {Number} The percent done level of the task
     */
    getBaselinePercentDone: function() {
        return this.get(this.baselinePercentDoneField) || 0;
    },
    /**
     * Returns true if the Task can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var parent = this.parentNode;
        return !parent || !parent.phantom || parent.isRoot();
    },
    /**
     * Returns an array of Gnt.model.Resource instances assigned to this Task.
     *
     * @return {Gnt.model.Resource[]} resources
     */
    getResources: function() {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getResourcesForEvent(me) || [];
    },
    /**
     * Returns an array of Gnt.model.Assignment instances associated with this Task.
     *
     * @return {Gnt.model.Assignment[]} resources
     */
    getAssignments: function() {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForTask(me) || [];
    },
    /**
     * Returns true if this task has any assignments. **Note**, that this function returns `true` even if all assignment records are invalid
     * (ie pointing to non-existing resource in the resource store).
     *
     * @return {Boolean}
     */
    hasAssignments: function() {
        return this.getAssignments().length > 0;
    },
    /**
     * Returns true if this task has any assignments with valid resources. Returns `true` only if at least one assignment record is valid -
     * pointing to existed resource record in the resource store.
     *
     * @return {Boolean}
     */
    hasResources: function() {
        var assignments = this.getAssignments(),
            result = false,
            i, len;
        for (i = 0 , len = assignments.length; !result && i < len; i++) {
            result = !!assignments[i].getResource();
        }
        return result;
    },
    /**
     * If given resource is assigned to this task, returns a Gnt.model.Assignment record.
     * Otherwise returns `null`
     *
     * @param {Gnt.model.Resource/Mixid} resourceOrId The instance of {@link Gnt.model.Resource} or resource id
     *
     * @return {Gnt.model.Assignment|null}
     */
    getAssignmentFor: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentForEventAndResource(me, resource) || null;
    },
    /**
     * @method isAssignedTo
     * Returns true if the task is assigned to a certain resource.
     *
     * @param {Sch.model.Resource} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.isTaskAssignedToResource(me, resource) || false;
    },
    /**
     * @propagating
     * Assigns this task to the passed Resource or Resource Id.
     *
     * @param {Gnt.model.Resource/Mixed} resource The instance of a {@link Gnt.model.Resource resource} or its id.
     * @param {Number} units The integer value for the {@link Gnt.model.Assignment#unitsField Units field} of the assignment record.
     * @param {Function} [callback] Callback function to call after resource has been assigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    assign: function(resource, units, callback) {
        var me = this,
            compatResult, cancelFn;
        me.propagateChanges(function() {
            return me.assignWithoutPropagation(resource, units, function cancelAndResultFeedback(fn, result) {
                cancelFn = fn;
                compatResult = result;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
        return compatResult;
    },
    assignWithoutPropagation: function(resource, units, cancelAndResultFeedback, assignmentData) {
        var me = this,
            cancelActions = [],
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore.getAssignmentStore(),
            resourceStore = taskStore.getResourceStore(),
            assignment, resourceId;
        // {{{ Parameter normalization
        units = units || 100;
        assignmentData = assignmentData || {};
        // }}}
        // Preconditions:
        // If we have a resource model instance but it's not in the resource store then adding it,
        // the resource is probably a phantom record
        if (resource.isResourceModel && resourceStore.indexOf(resource) == -1) {
            resourceId = resource.getId();
            resourceStore.add(resource);
            cancelActions.push(function() {
                resourceStore.remove(resource);
            });
        }
        // If we have a resource model already in the store then just getting it's id
        else if (resource.isResourceModel) {
            resourceId = resource.getId();
        }
        // If we don't have a resource model then we must have a resource id, and if a resource with the given id
        // is present in the store then we can proceed
        else if (resourceStore.indexOfId(resource) >= 0) {
            resourceId = resource;
        } else // Otherwise we have nothing to assign to the task, raising an error
        {
            // @TODO: #2773 - Rhyno parse error - Syntax error while building the app
            var foo = false;
        }
        assignmentData[assignmentStore.model.prototype.unitsField] = units;
        assignment = assignmentStore.assignTaskToResource(me, resourceId, assignmentData);
        cancelActions.push(function() {
            assignmentStore.unassignTaskFromResource(me, resourceId);
        });
        cancelAndResultFeedback && cancelAndResultFeedback(function() {
            Ext.Array.each(cancelActions, function(action) {
                action();
            });
        }, assignment[0]);
        return [
            me
        ];
    },
    /**
     * @propagating
     * Un-assign a resource from this task
     *
     * @param {Gnt.model.Resource/Number} resource An instance of the {@link Gnt.model.Resource} class or a resource id
     * @param {Function} [callback] Callback function to call after resource has been unassigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unassign: function() {
        return this.unAssign.apply(this, arguments);
    },
    unAssign: function(resource, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.unassignWithoutPropagation(resource, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    unassignWithoutPropagation: function(resource, cancelFeedback) {
        var me = this,
            resourceId = resource.isResourceModel ? resource.getId() : resource,
            assignmentStore = me.getAssignmentStore(),
            assignment = me.getAssignmentFor(resourceId),
            indexOfAssignment;
        indexOfAssignment = assignmentStore.indexOf(assignment);
        assignmentStore.unassignTaskFromResource(me, resource);
        cancelFeedback && cancelFeedback(function() {
            assignmentStore.insert(indexOfAssignment, assignment);
        });
        return [
            me
        ];
    },
    /**
     * @propagating
     * Reassigns a task from old resource to a new one.
     *
     * @param {Gnt.model.Resource/Mixed} oldResource A resource to unassign from
     * @param {Gnt.model.Resource/Mixed} newResource A resource to assign to
     * @param {Function} [callback] Callback function to call after resource has been reassigned and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    reassign: function(oldResource, newResource, callback) {
        var me = this,
            unassignCancelFn, assignCancelFn;
        me.propagateChanges(function() {
            var units = me.getAssignmentFor(oldResource).getUnits();
            var propagate = false;
            var oldAssignment = me.getAssignmentFor(oldResource);
            propagate = me.unassignWithoutPropagation(oldResource, function unassignCancelFeedback(fn) {
                unassignCancelFn = fn;
            });
            propagate = propagate && me.assignWithoutPropagation(newResource, units, function assignCancelFeedback(fn) {
                assignCancelFn = fn;
            }, oldAssignment.data);
            return propagate;
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            if (cancelChanges) {
                assignCancelFn && assignCancelFn();
                unassignCancelFn && unassignCancelFn();
            }
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    // TODO: interceptor is needed only for Gnt.view.Dependency, ask Nick if it can be removed
    /**
     * @propagating
     * Links a task to another one given in `toId` with typed dependency given in `type`.
     *
     * @param {Gnt.model.Task|Number} toId
     * @param {Integer/Object} [type=Gnt.model.Dependency.Type.EndToStart] dependency type see {@link Gnt.model.Dependency#Type}.
     *
     * Or accepts a config object for the newly created dependency {@link Gnt.model.Dependency}:
     *
     * ```javascript
     * task.linkTo(sucessorTask, {
     *     Type    : Gnt.model.Dependency.Type.EndToStart,
     *     Lag     : 2,
     *     LagUnit : 'd'
     * })
     * ```
     *
     * @param {Function} [callback] Callback function to call after tasks has been linked and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    linkTo: function(toId, type, callback, /* private */
    interceptor) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.linkToWithoutPropagation(toId, type, function cancelFeedback(fn) {
                cancelFn = fn;
            }, interceptor);
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    linkToWithoutPropagation: function(toId, type, cancelFeedback) {
        var me = this,
            fromId = me.getId(),
            taskStore = me.getTaskStore(),
            dependencyStore = me.getDependencyStore(),
            model = dependencyStore.model,
            scheduleBackwards = me.getProjectScheduleBackwards(),
            result = false,
            newDependency, config;
        toId = toId instanceof Gnt.model.Task ? toId.getId() : toId;
        // {{{ Parameters normalization
        toId = toId instanceof Gnt.model.Task ? toId.getId() : toId;
        type = ((type === null || type === undefined) && Gnt.model.Dependency.Type.EndToStart) || type;
        // }}}
        if (typeof type === 'object') {
            config = type;
        } else {
            config = {};
            config[model.prototype.typeField] = type;
        }
        config[model.prototype.toField] = toId;
        config[model.prototype.fromField] = fromId;
        newDependency = new model(config);
        if (dependencyStore.isValidDependency(newDependency)) {
            dependencyStore.add(newDependency);
            // mark the tasks as requiring rescheduling so the next propagation will adjust them
            var target = newDependency.getTargetTask();
            if (scheduleBackwards) {
                target.isUnscheduled() && target.markForRescheduling();
                me.markForRescheduling();
                result = target;
            } else {
                me.isUnscheduled() && me.markForRescheduling();
                target.markForRescheduling();
                result = me;
            }
        }
        cancelFeedback && cancelFeedback(function() {
            dependencyStore.remove(newDependency);
        });
        return result;
    },
    /**
     * @propagating
     * Unlinks a task from another one given in `fromId`.
     *
     * @param {Gnt.model.Task|Number} fromId
     * @param {Function} [callback] Callback function to call after tasks has been unlinked and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unlinkFrom: function(fromId, callback) {
        var me = this,
            cancelFn;
        me.propagateChanges(function() {
            return me.unlinkFromWithoutPropagation(fromId, function cancelFeedback(fn) {
                cancelFn = fn;
            });
        }, function onPropagationComplete(cancelChanges, affectedTasks) {
            cancelChanges && cancelFn && cancelFn();
            callback && callback(cancelChanges, affectedTasks);
        });
    },
    unlinkFromWithoutPropagation: function(fromId, cancelFeedback) {
        var me = this,
            toId = me.getId(),
            dependencyStore = me.getDependencyStore(),
            dependency, indexOfDependency;
        // {{{ Parameters normalization
        fromId = fromId instanceof Gnt.model.Task ? fromId.getId() : fromId;
        // }}}
        dependency = dependencyStore.getTasksLinkingDependency(fromId, toId);
        indexOfDependency = dependencyStore.indexOf(dependency);
        dependencyStore.remove(dependency);
        cancelFeedback && cancelFeedback(function() {
            dependencyStore.insert(indexOfDependency, dependency);
        });
        return me;
    },
    // side-effects free method - suitable for use in "normalization" stage
    // calculates the effort based on the assignments information
    calculateEffort: function(startDate, endDate, unit) {
        // effort calculation requires both dates
        if (!startDate || !endDate)  {
            return 0;
        }
        
        var totalEffort = 0;
        this.forEachAvailabilityIntervalWithResources({
            startDate: startDate,
            endDate: endDate
        }, function(intervalStartDate, intervalEndDate, currentAssignments) {
            var totalUnits = 0;
            for (var i in currentAssignments) totalUnits += currentAssignments[i].units;
            totalEffort += (intervalEndDate - intervalStartDate) * totalUnits / 100;
        });
        return this.getUnitConverter().convertMSDurationToUnit(totalEffort, unit || this.getEffortUnit());
    },
    updateAssignments: function() {
        // prevent nested call of this method (we have assignment.setUnits() below)
        if (!this._inUpdateAssignments) {
            this._inUpdateAssignments = true;
            var startDate = this.getStartDate(),
                endDate = this.getEndDate(),
                totalTime = 0;
            // do nothing if task is not scheduled
            if (startDate && endDate) {
                this.forEachAvailabilityIntervalWithResources({
                    startDate: startDate,
                    endDate: endDate
                }, function(intervalStartDate, intervalEndDate, currentAssignments) {
                    for (var resourceId in currentAssignments) {
                        totalTime += intervalEndDate - intervalStartDate;
                    }
                });
                // found some assigned resource intervals
                if (totalTime) {
                    var effortInMS = this.getEffort(Sch.util.Date.MILLI);
                    Ext.Array.each(this.getAssignments(), function(assignment) {
                        assignment.setUnits(effortInMS / totalTime * 100);
                    });
                }
            }
            this._inUpdateAssignments = false;
        }
    },
    updateEffortBasedOnDuration: function() {
        this.setEffortWithoutPropagation(this.calculateEffort(this.getStartDate(), this.getEndDate()));
    },
    // Alias for updateEffortBasedOnDuration(). Added to have symmetry with updateSpanBasedOnEffort.
    updateEffortBasedOnSpan: function() {
        this.updateEffortBasedOnDuration();
    },
    updateSpanBasedOnEffort: function() {
        // we have to update startDate because duration change can turn the task into a milestone
        // and for milestones we should set startDate to the end of last working period
        this.setStartEndDateWithoutPropagation(this.getStartDate(), this.recalculateEndDate());
    },
    onPotentialEffortChange: function() {
        var me = this,
            taskStore = me.getTaskStore(true);
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (me.getSchedulingMode()) {
                case 'FixedDuration':
                    me.updateEffortBasedOnDuration();
                    break;
                case 'DynamicAssignment':
                    me.updateAssignments();
                    break;
            }
        }
    },
    //TODO something here
    onAssignmentMutation: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            calculateCost = me.autoCalculateCost;
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (me.getSchedulingMode()) {
                case 'FixedDuration':
                    me.updateEffortBasedOnDuration();
                    calculateCost = false;
                    break;
                case 'EffortDriven':
                    me.updateSpanBasedOnEffort();
                    break;
                case 'DynamicAssignment':
                    me.updateAssignments();
                    break;
            }
            if (calculateCost)  {
                me.recalculateCost();
            }
            
        }
    },
    //TODO something here
    onAssignmentStructureMutation: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            calculateCost = me.autoCalculateCost;
        if (me.isTaskStored() && (!taskStore || !taskStore.isUndoingOrRedoing())) {
            switch (me.getSchedulingMode()) {
                case 'FixedDuration':
                    me.updateEffortBasedOnDuration();
                    calculateCost = false;
                    break;
                case 'EffortDriven':
                    me.updateSpanBasedOnEffort();
                    break;
                case 'DynamicAssignment':
                    me.updateAssignments();
                    break;
            }
            if (calculateCost)  {
                me.recalculateCost();
            }
            
        }
    },
    /**
     * @propagating
     * Adjusts the task start/end properly according to the calendar dates and taking the task dependencies and constraints into account.
     * @param {Function} [callback] Callback function to call after the task has been adjusted and possible changes among dependent tasks were propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    adjustToCalendar: function(callback) {
        var me = this;
        me.propagateChanges(function() {
            return me.adjustToCalendarWithoutPropagation();
        }, callback);
    },
    /**
     * Adjusts the task start/end properly according to the calendar dates and taking the task dependencies and constraints into account.
     *
     * See also {@link #adjustToCalendar} to propagate changes to dependent tasks.
     */
    adjustToCalendarWithoutPropagation: function() {
        var me = this,
            taskStore = me.getTaskStore(true),
            propagate = false;
        if (taskStore) {
            if (me.get('leaf')) {
                me.setStartDateWithoutPropagation(me.getStartDate());
                me.scheduleWithoutPropagation({
                    taskStore: taskStore
                });
                // Should it be recalculated here too?
                // me.recalculateCost();
                propagate = me;
            } else if (me.getStartDate() && me.getEndDate()) {
                me.set(me.durationField, me.calculateDuration(me.getStartDate(), me.getEndDate(), me.getDurationUnit()));
                propagate = me;
            }
        }
        return propagate;
    },
    /**
     Returns if the task is readonly. When readonly is `true` the task {@link #isEditable} returns `false` for all its fields.
     @return {Boolean} Boolean value, indicating whether the model is readonly
     */
    isReadOnly: function() {
        var result = false;
        this.bubble(function(task) {
            if (task.getReadOnly()) {
                result = true;
                return false;
            }
        }, this);
        return result;
    },
    /*
     * @method setReadOnly
     * Sets if the given task is readonly. You can subclass this class and override this method to provide your own logic.
     *
     * When the task is readonly {@link #isEditable} returns `false` for all fields except the readonly field.
     * A task in readonly state will not allow dependency creation.
     *
     * @param {String} value indicating if the task is readonly
     */
    /**
     * Checks if the given task field is editable. You can subclass this class and override this method to provide your own logic.
     *
     * It takes the task scheduling mode into account. For example for "FixedDuration" mode, the {@link #Effort}
     * field is calculated and thus should not be editable by user directly.
     *
     * @param {String} fieldName Name of the field
     * @return {Boolean} Boolean value, indicating whether the given field is editable
     */
    isEditable: function(fieldName) {
        // if some parent is readonly
        if (!this.getReadOnly() && this.isReadOnly()) {
            return false;
        }
        if (fieldName === this.readOnlyField)  {
            return true;
        }
        
        // check if the task is readonly
        if (this.getReadOnly())  {
            return false;
        }
        
        if (!this.isLeaf()) {
            if (this.autoCalculateEffortForParentTask) {
                if (fieldName === this.effortField)  {
                    return false;
                }
                
                if (fieldName === this.actualEffortField)  {
                    return false;
                }
                
            }
            if (this.autoCalculateCostForParentTask) {
                if (fieldName === this.costField)  {
                    return false;
                }
                
                if (fieldName === this.actualCostField)  {
                    return false;
                }
                
            }
            if (fieldName === this.percentDoneField && this.autoCalculatePercentDoneForParentTask)  {
                return false;
            }
            
        }
        // "autoCalculateCost" mode means we calculate "Cost" and "ActualCost" based on assigned resources costs
        if (this.autoCalculateCost) {
            if (fieldName === this.costField)  {
                return false;
            }
            
            if (fieldName === this.actualCostField)  {
                return false;
            }
            
        }
        if ((fieldName === this.durationField || fieldName === this.endDateField) && this.isEffortDriven()) {
            return false;
        }
        if (fieldName === this.effortField && this.getSchedulingMode() === 'FixedDuration') {
            return false;
        }
        return true;
    },
    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable: function() {
        return this.getDraggable();
    },
    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */
    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable: function() {
        return this.getResizable();
    },
    /**
     * @method getWBSCode
     *
     * Returns the WBS code of task.
     * @return {String} The WBS code string
     */
    getWBSCode: function() {
        var indexes = [],
            index,
            task = this;
        while (task.parentNode) {
            index = task.parentNode.childNodes.indexOf(task);
            indexes.push(index + 1);
            task = task.parentNode;
        }
        return indexes.reverse().join('.');
    },
    resetTotalCount: function(preventCaching) {
        var task = this;
        while (task) {
            task.totalCount = preventCaching ? -1 : null;
            task = task.parentNode;
        }
    },
    /**
     * Returns total count of child nodes and their children.
     *
     * @return {Number} Total count of child nodes
     */
    getTotalCount: function() {
        var totalCount = this.totalCount;
        var cachingPrevented = totalCount == -1;
        // `cachingPrevented` (totalCount == -1) will cause the value to be always recalculated
        if (totalCount == null || cachingPrevented) {
            var childNodes = this.childNodes;
            totalCount = childNodes.length;
            for (var i = 0,
                l = childNodes.length; i < l; i++) {
                totalCount += childNodes[i].getTotalCount();
            }
            if (cachingPrevented)  {
                return totalCount;
            }
            else  {
                this.totalCount = totalCount;
            }
            
        }
        return totalCount;
    },
    /**
     * @method getPreviousSiblingsTotalCount
     * Returns count of all sibling nodes (including their children).
     *
     * @return {Number}
     */
    getPreviousSiblingsTotalCount: function() {
        var task = this.previousSibling,
            count = this.parentNode.childNodes.indexOf(this);
        while (task) {
            count += task.getTotalCount();
            task = task.previousSibling;
        }
        return count;
    },
    /**
     * @method getSequenceNumber
     *
     * Returns the sequential number of the task. A sequential number means the ordinal position of the task in the total dataset, regardless
     * of its nesting level and collapse/expand state of any parent tasks. The root node has a sequential number equal to 0.
     *
     * For example, in the following tree data sample sequential numbers are specified in the comments:
     *
     *        root : {
     *            children : [
     *                {   // 1
     *                    leaf : true
     *                },
     *                {       // 2
     *                    children : [
     *                        {   // 3
     *                            children : [
     *                                {   // 4
     *                                    leaf : true
     *                                },
     *                                {   // 5
     *                                    leaf : true
     *                                }
     *                            ]
     *                        }]
     *                },
     *                {   // 6
     *                    leaf : true
     *                }
     *            ]
     *        }
     *
     * If we will collapse some of the parent tasks, sequential number of collapsed tasks won't change.
     *
     * See also {@link Gnt.data.TaskStore#getBySequenceNumber}.
     *
     * @return {Number} The code
     */
    getSequenceNumber: function() {
        var code = 0,
            task = this;
        while (task.parentNode) {
            code += task.getPreviousSiblingsTotalCount() + 1;
            task = task.parentNode;
        }
        return code;
    },
    // generally should be called on root node only
    getBySequenceNumber: function(number) {
        var resultNode = null,
            childNode, totalCount;
        if (number === 0) {
            resultNode = this;
        } else if (number > 0 && number <= this.getTotalCount()) {
            number--;
            for (var i = 0,
                l = this.childNodes.length; i < l; i++) {
                childNode = this.childNodes[i];
                totalCount = childNode.getTotalCount();
                if (number > totalCount)  {
                    number -= totalCount + 1;
                }
                else {
                    childNode = this.childNodes[i];
                    resultNode = childNode.getBySequenceNumber(number);
                    break;
                }
            }
        }
        return resultNode;
    },
    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */
    // Does a regular copy but also copies references to the model taskStore etc
    // Intended to be used when copying a task that will be added to the same taskStore
    fullCopy: function(model) {
        var cp = this.callParent(arguments);
        cp.taskStore = this.getTaskStore();
        return cp;
    },
    commit: function() {
        this.callParent(arguments);
        this.commitSegments();
    },
    reject: function() {
        this.callParent(arguments);
        this.rejectSegments();
    },
    isUnscheduled: function() {
        return !this.getStartDate() || !this.getEndDate();
    },
    isMarkedForRescheduling: function() {
        return this.get('needsRescheduling');
    },
    markForRescheduling: function() {
        this.set('needsRescheduling', true);
    },
    unmarkForRescheduling: function() {
        this.set('needsRescheduling', false);
    },
    isTaskStored: function() {
        // We can't rely on this.taskStore here only, it's value is managed in setRoot/onTaskRemoved method of the task store
        // and there's a time when task is removed already but onTaskRemoved() handle hasn't completed yet
        return !!(this.getTreeStore() && this.getTreeStore().getRoot() && !this.getTreeStore().destroyed);
    },
    /*
        var root = this;
        while (!root.isRoot()) {
            root = root.parentNode;
        }
        return this.taskStore && this.taskStore.getRoot() === root;
        */
    onRegisterTreeNode: function(store) {
        if (store && store.autoNormalizeNodes && !this.normalized) {
            this.normalize();
        }
    }
}, function() {
    // Do this first to be able to override NodeInterface methods
    Ext.data.NodeInterface.decorate(this);
    this.override({
        copy: function() {
            var result = this.callParent(arguments),
                segments = result.getSegments();
            // for a segmented task we also make a copy of each segment
            if (segments) {
                for (var i = 0; i < segments.length; i++) {
                    var segment = segments[i];
                    // clone segments but provide "task" property targeting the task copy
                    segments[i] = segment.copy(segment.getId(), false, {
                        task: result
                    });
                }
            }
            return result;
        },
        // @OVERRIDE
        insertBefore: function(node, refNode) {
            node = this.createNode(node);
            if (!node)  {
                return;
            }
            
            var store = this.getTaskStore(true),
                root = store && store.getRoot(),
                phantomParentIdField = this.phantomParentIdField,
                phantom = this !== root && this.phantom,
                isMove = !!node.parentNode,
                internalId = this.getId();
            if (phantom) {
                this.data[this.phantomIdField] = internalId;
            }
            if (internalId !== node.data[phantomParentIdField]) {
                var newPhantomParentIdValue = phantom ? internalId : null;
                if (!node.phantom && node.data[phantomParentIdField] !== newPhantomParentIdValue) {
                    node.modified = node.modified || {};
                    node.modified[phantomParentIdField] = node.data[phantomParentIdField];
                }
                node.data[phantomParentIdField] = newPhantomParentIdValue;
            }
            var refNodeIndex = refNode && refNode.get('index');
            this.resetTotalCount(isMove);
            // Scan for and remove invalid dependencies since a parent task may not have dependencies to its children etc.
            // Has to be done before callParent where the node move happens
            if (isMove && node.hasDependencies() && !store.isUndoingOrRedoing()) {
                node.removeDependenciesToParents(this);
            }
            var res = this.callParent(arguments);
            // Scan for and remove invalid dependencies since a parent task may not have dependencies to its children etc.
            if (isMove) {
                // if the task has dependencies
                if (this.hasDependencies()) {
                    // we just potentially changed dependencies setup so need to reset the dependency store cache
                    store.getDependencyStore().resetMethodsCache();
                    // Scan for and remove invalid dependencies.
                    if (!store.isUndoingOrRedoing()) {
                        this.removeInvalidDependencies();
                    }
                }
                this.resetTotalCount();
            }
            if (store && !store.isUndoingOrRedoing()) {
                // Check if the task constraint is no more sensible (some constraints are meant to be used for leaf nodes only)
                this.resetConstraintIfNotApplicable();
            }
            return res;
        },
        // @OVERRIDE
        appendChild: function(nodes, suppressEvents, commit) {
            nodes = nodes instanceof Array ? nodes : [
                nodes
            ];
            var store = this.getTaskStore(true),
                root = store && store.getRoot(),
                isMove = false,
                phantomParentIdField = this.phantomParentIdField,
                phantom = this !== root && this.phantom,
                internalId = this.getId(),
                nodesCreated = 0;
            if (store && nodes.length > 1) {
                store.suspendAutoRecalculateParents++;
            }
            for (var i = 0; i < nodes.length; i++) {
                var node = this.createNode(nodes[i]);
                if (!node)  {
                    
                    continue;
                }
                
                nodesCreated++;
                nodes[i] = node;
                // appending child that is already in the same tree, will first remove it from previous parent.
                // Removing is hidden inside of the `appendChild` implementation and causes various side effects
                // which re-fills the `totalCount` cache with wrong value. Need to suspend caching during parent
                // "appendChild" implementation
                if (node.parentNode) {
                    isMove = true;
                    // Has to be done before callParent where the node move happens
                    if (node.hasDependencies() && store && !store.isUndoingOrRedoing()) {
                        node.removeDependenciesToParents(this);
                    }
                }
                if (internalId !== node.data[phantomParentIdField]) {
                    var newPhantomParentIdValue = phantom ? internalId : null;
                    if (!node.phantom && node.data[phantomParentIdField] !== newPhantomParentIdValue) {
                        node.modified = node.modified || {};
                        node.modified[phantomParentIdField] = node.data[phantomParentIdField];
                    }
                    node.data[phantomParentIdField] = newPhantomParentIdValue;
                }
            }
            if (!nodesCreated)  {
                return;
            }
            
            if (phantom) {
                this.data[this.phantomIdField] = internalId;
            }
            this.resetTotalCount(isMove);
            // convert a single element array back to just element, to avoid extra function call
            var res = this.callParent([
                    nodes.length > 1 ? nodes : nodes[0],
                    suppressEvents,
                    commit
                ]);
            if (isMove) {
                // if the task has dependencies
                if (this.hasDependencies()) {
                    // we just potentially changed dependencies setup so need to reset the dependency store cache
                    store.getDependencyStore().resetMethodsCache();
                    // Scan for and remove invalid dependencies.
                    if (store && !store.isUndoingOrRedoing()) {
                        this.removeInvalidDependencies();
                    }
                }
                this.resetTotalCount();
            }
            if (store && !store.isUndoingOrRedoing()) {
                this.beginEdit();
                // Bugfix ticket #1401
                this.markAsParent();
                // since the task became a parent we switch its scheduling mode to 'Normal' (ticket #1441)
                this.set(this.schedulingModeField, 'Normal');
                // Check if the task constraint is no more sensible (some constraints are meant to be used for leaf nodes only)
                this.resetConstraintIfNotApplicable();
                if (store && nodes.length > 1) {
                    store.suspendAutoRecalculateParents--;
                }
                this.endEdit();
            }
            if (store && store.recalculateParents && !store.suspendAutoRecalculateParents && !this.isRoot() && !store.cascading && !store.isUndoingOrRedoing()) {
                nodes[0].recalculateParents();
            }
            return res;
        },
        // @OVERRIDE
        removeChild: function(node, destroy, suppressEvents, isMove) {
            var me = this,
                needToConvertToLeaf = !me.removeChildIsCalledFromReplaceChild && me.convertEmptyParentToLeaf && me.childNodes.length == 1,
                taskStore = me.getTaskStore(true),
                result;
            me.resetTotalCount();
            // need to reset the flag early, because the removal operation may cause some side effects (event listeners)
            // flag should be already reset in those listeners
            me.removeChildIsCalledFromReplaceChild = false;
            // Calling parent
            result = me.callParent(arguments);
            // In case of node move we need to reset the total count cache one more time here.
            // This is for the case, when we append/insert some existing node to a different position
            // in its parent node. In this case, the total count cache will be originally reset in our
            // overrides for `insertBefore` or `appendChild`. This is supposed to be enough, but its not,
            // because before doing actuall append, not first will be removed from the parent ("removeChild" call
            // is part of the `appendChild/insertBefore` methods. The listeners of `remove` event may call
            // `getTotalCount` and fill the cache. Then, we continue to actual node insertion, but cache is already filled
            // with wrong data.
            if (isMove) {
                me.resetTotalCount();
            }
            // If this parent has children left, recalculate it's start/end dates if required
            if (me.childNodes.length > 0 && taskStore && taskStore.recalculateParents && !taskStore.suspendAutoRecalculateParents && !taskStore.isUndoingOrRedoing()) {
                // If the parent has some children left then recalculate it's start/end dates if required
                //me.refreshCalculatedParentNodeData();
                me.childNodes[0].recalculateParents();
            }
            // If the parent has no other children, change it to a leaf task
            if (needToConvertToLeaf && !me.isRoot() && taskStore && !taskStore.isUndoingOrRedoing()) {
                me.convertEmptyParentToLeafTask();
            }
            return result;
        },
        replaceChild: function() {
            // flag will be reset in the `removeChild` override
            this.removeChildIsCalledFromReplaceChild = true;
            this.callParent(arguments);
        },
        removeAll: function() {
            var isLeaf = this.isLeaf(),
                taskStore = this.getTaskStore(true);
            this.resetTotalCount();
            this.callParent(arguments);
            // if we don't know the task taskStore we cannot set its duration to 1 day (which happens in convertEmptyParentToLeafTask())
            if (!isLeaf && this.convertEmptyParentToLeaf && taskStore) {
                this.convertEmptyParentToLeafTask();
            }
        },
        // @OVERRIDE
        createNode: function(node) {
            var me = this,
                store = me.getTaskStore(true),
                root = store && store.getRoot(),
                reader;
            if (store) {
                reader = store.getProxy().getReader();
                var originalGetChildType = reader.getChildType;
                // TODO: check this in ext5.1.2+
                // parent "createNode" doesnot fallback to the reader model
                // and raises exception because of that (in ext5.1.0/ext5.1.1)
                reader.getChildType = function() {
                    return originalGetChildType.apply(this, arguments) || this.getModel();
                };
            }
            node = this.callParent(arguments);
            // restore original reader.getChildType
            if (store && reader)  {
                delete reader.getChildType;
            }
            
            return node;
        }
    });
});

/**
 * This class represents a single Project in your Gantt chart.
 *
 * The inheritance hierarchy of this class includes {@link Gnt.model.Task}, {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
 * This class will also receive a set of methods and additional fields that stem from the {@link Ext.data.NodeInterface}.
 * Please refer to the documentation of those classes to become familiar with the base interface of this class.
 */
Ext.define('Gnt.model.Project', {
    extend: 'Gnt.model.Task',
    alias: 'gntmodel.project',
    /**
     * @property {Boolean} isProject Indicates that this is a project model.
     * Can be used in heterogeneous stores to distinguish project records from task ones.
     */
    isProject: true,
    /**
     * @cfg {String} descriptionField The name of the {@link #Description} field.
     */
    descriptionField: 'Note',
    /**
     * @cfg {String} allowDependenciesField The name of the {@link #AllowDependencies} field.
     */
    allowDependenciesField: 'AllowDependencies',
    /**
     * @cfg {String} scheduleBackwardsField The name of the {@link #ScheduleBackwards} field.
     */
    scheduleBackwardsField: 'ScheduleBackwards',
    customizableFields: [
        /**
         * @field
         * The description of the project, this field maps to the task {@link #Note} field.
         */
        {
            name: 'Description',
            type: 'string'
        },
        /**
         * @field
         * This field indicates if the project tasks are allowed to have dependencies with tasks of another project.
         */
        {
            name: 'AllowDependencies',
            persist: false,
            type: 'bool',
            defaultValue: false
        },
        /**
         * @field
         * This field indicates if the project is scheduled from its end to start.
         */
        {
            name: 'ScheduleBackwards',
            type: 'bool',
            defaultValue: false
        }
    ],
    recognizedSchedulingModes: [
        'Normal'
    ],
    convertEmptyParentToLeaf: false,
    startDateIsInvalid: false,
    endDateIsInvalid: false,
    /**
     * Checks if the given project field is editable. You can subclass this class and override this method to provide your own logic.
     * **Please pay attention** that in contrast to the task model {@link Gnt.modelTask#isEditable isEditable} this method on the project level
     * returns `false` by default. Which means that after subclassing the class and adding new fields the one needs to explicitly handle them in this method to make the fields editable.
     */
    isEditable: function(fieldName) {
        // some fields doesn't make sense to edit for a project
        switch (fieldName) {
            case this.nameField:
            case this.readOnlyField:
            case this.durationField:
            case this.durationUnitField:
            case this.descriptionField:
            case this.allowDependenciesField:
            case this.scheduleBackwardsField:
            case this.calendarIdField:
            case this.clsField:
            case this.manuallyScheduledField:
            case this.showInTimelineField:
                return this.callParent(arguments);
            // start date of the project is editable if:
            // - project is scheduled from start to end (otherwise start date is auto-calculated)
            // - or it's manually scheduled
            case this.startDateField:
                return (!this.getScheduleBackwards() || this.isManuallyScheduled()) && this.callParent(arguments);
            // end date of the project is editable if:
            // - project is scheduled from end to start (otherwise end date is auto-calculated)
            // - or it's manually scheduled
            case this.endDateField:
                return (this.getScheduleBackwards() || this.isManuallyScheduled()) && this.callParent(arguments);
            default:
                return false;
        }
    },
    /**
     * @method getScheduleBackwards
     * Indicates if the project is scheduled from its end to start.
     * @return {Boolean} `True` if the project is scheduled from its end to start.
     */
    /**
     * @propagating
     * @method setScheduleBackwards
     * Sets if the project should be scheduled from its end to start.
     * @param {Boolean} value `True` to schedule the project its end to start.
     */
    setScheduleBackwards: function(value) {
        var me = this;
        me.propagateChanges(function() {
            me.set(me.scheduleBackwardsField, value);
            // mark all nested tasks as required re-scheduling
            me.cascadeChildren(function(task) {
                task.markForRescheduling();
            });
            return me;
        }, null, null, null, /*forceMoveParentAsGroup*/
        true);
    },
    getScheduleBackwards: function() {
        // This method is explicitly added here since we have method w/ the same name in Task model
        // (so we're avoiding infinite recursion)
        return this.get(this.scheduleBackwardsField);
    },
    /*
     * @method setReadOnly
     * Sets if the given project is read only. All underlying tasks will be considered as read only as well.
     *
     * @param {String} value `True` to mark the project as read only.
     */
    setStartDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function() {
            var result = me.setStartDateWithoutPropagation(date, keepDuration, skipNonWorkingTime);
            // Make sure that ongoing propagation will reschedule all the nested tasks if needed
            me.maybeMarkChildrenForRescheduling();
            return result;
        }, callback);
    },
    setStartEndDate: function(startDate, endDate, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function() {
            var result = me.setStartEndDateWithoutPropagation(startDate, endDate, skipNonWorkingTime);
            // Make sure that ongoing propagation will reschedule all the nested tasks if needed
            me.maybeMarkChildrenForRescheduling();
            return result;
        }, callback);
    },
    setEndDate: function(date, keepDuration, skipNonWorkingTime, callback) {
        var me = this;
        me.propagateChanges(function() {
            var result = me.setEndDateWithoutPropagation(date, keepDuration, skipNonWorkingTime);
            // Make sure that ongoing propagation will reschedule all the nested tasks if needed
            me.maybeMarkChildrenForRescheduling();
            return result;
        }, callback);
    },
    isChildrenReschedulingNeeded: function() {
        var me = this,
            newData = me.getProjection();
        return newData && ((me.getScheduleBackwards() ? newData[me.endDateField] : newData[me.startDateField]) || newData.hasOwnProperty(me.scheduleBackwardsField));
    },
    /**
     * @private
     * Marks nested tasks as requiring rescheduling if the project start date (finish date for backward scheduling) has been changed
     * in the ongoing propagation.
     */
    maybeMarkChildrenForRescheduling: function() {
        var me = this;
        if (me.isChildrenReschedulingNeeded()) {
            // Make sure that ongoing propagation will reschedule all the nested tasks
            me.cascadeChildren(function(task) {
                task.markForRescheduling();
            });
        }
    },
    isInvalidatingStartDate: function() {
        return this.startDateIsInvalid;
    },
    isInvalidatingEndDate: function() {
        return this.endDateIsInvalid;
    },
    /**
     * @private
     * The method is called to invalidate the calculated project border (end date for forward scheduled projects and start date - for backward scheduled ones).
     * It's used during the propagation.
     */
    startInvalidatingRange: function() {
        var me = this;
        if (!me.isManuallyScheduled()) {
            if (me.getScheduleBackwards()) {
                me.startDateIsInvalid = true;
            } else {
                me.endDateIsInvalid = true;
            }
        }
    },
    /**
     * @private
     * The method is called to indicated that the calculated project border (end date for forward scheduled projects and start date - for backward scheduled ones)
     * is stable and can be used.
     * It's used during the propagation.
     */
    finishInvalidatingRange: function() {
        var me = this;
        if (!me.isManuallyScheduled()) {
            if (me.getScheduleBackwards()) {
                me.startDateIsInvalid = false;
            } else {
                me.endDateIsInvalid = false;
            }
        }
    },
    /**
     * Do not allow to indent/outdent project nodes
     * @hide
     */
    indent: Ext.emptyFn,
    /**
     * @hide
     */
    outdent: Ext.emptyFn,
    // Projects cannot be restricted w/ constraints
    maybePinWithoutPropagation: Ext.emptyFn
});
/**
     * @hide
     * @field ActualCost
     */
/**
     * @hide
     * @field ActualEffort
     */
/**
     * @hide
     * @field BaselineCost
     */
/**
     * @hide
     * @field BaselineEffort
     */
/**
     * @hide
     * @field BaselineEndDate
     */
/**
     * @hide
     * @field BaselinePercentDone
     */
/**
     * @hide
     * @field BaselineStartDate
     */
/**
     * @hide
     * @field ConstraintDate
     */
/**
     * @hide
     * @field ConstraintType
     */
/**
     * @hide
     * @field Cost
     */
/**
     * @hide
     * @field CostVariance
     */
/**
     * @hide
     * @field DeadlineDate
     */
/**
     * @hide
     * @field Duration
     */
/**
     * @hide
     * @field DurationUnit
     */
/**
     * @hide
     * @field Effort
     */
/**
     * @hide
     * @field EffortUnit
     */
/**
     * @hide
     * @field EffortVariance
     */
/**
     * @hide
     * @field SchedulingMode
     */
/**
     * @hide
     * @cfg actualCostField
     */
/**
     * @hide
     * @cfg actualEffortField
     */
/**
     * @hide
     * @cfg autoCalculateCost
     */
/**
     * @hide
     * @cfg autoCalculateCostForParentTask
     */
/**
     * @hide
     * @cfg autoCalculateEffortForParentTask
     */
/**
     * @hide
     * @cfg autoCalculatePercentDoneForParentTask
     */
/**
     * @hide
     * @cfg baselineCostField
     */
/**
     * @hide
     * @cfg baselineEffortField
     */
/**
     * @hide
     * @cfg baselineEndDateField
     */
/**
     * @hide
     * @cfg baselinePercentDoneField
     */
/**
     * @hide
     * @cfg baselineStartDateField
     */
/**
     * @hide
     * @cfg constraintDateField
     */
/**
     * @hide
     * @cfg constraintTypeField
     */
/**
     * @hide
     * @cfg convertEmptyParentToLeaf
     */
/**
     * @hide
     * @cfg costField
     */
/**
     * @hide
     * @cfg costVarianceField
     */
/**
     * @hide
     * @cfg deadlineDateField
     */
/**
     * @hide
     * @cfg durationField
     */
/**
     * @hide
     * @cfg durationUnitField
     */
/**
     * @hide
     * @cfg effortField
     */
/**
     * @hide
     * @cfg effortUnitField
     */
/**
     * @hide
     * @cfg effortVarianceField
     */
/**
     * @hide
     * @cfg schedulingModeField
     */
/**
     * @hide
     * @cfg segmentsField
     */
/**
     * @hide
     * @method addPredecessor
     */
/**
     * @hide
     * @method addSuccessor
     */
/**
     * @hide
     * @method addTaskAbove
     */
/**
     * @hide
     * @method addTaskBelow
     */
/**
     * @hide
     * @method assign
     */
/**
     * @hide
     * @method getActualCost
     */
/**
     * @hide
     * @method getActualEffort
     */
/**
     * @hide
     * @method getAssignmentFor
     */
/**
     * @hide
     * @method getAssignments
     */
/**
     * @hide
     * @method getBaselineEffort
     */
/**
     * @hide
     * @method getBaselineEndDate
     */
/**
     * @hide
     * @method getBaselinePercentDone
     */
/**
     * @hide
     * @method getBaselineStartDate
     */
/**
     * @hide
     * @method getConstraintClass
     */
/**
     * @hide
     * @method getConstraintDate
     */
/**
     * @hide
     * @method getConstraintType
     */
/**
     * @hide
     * @method getCost
     */
/**
     * @hide
     * @method getCostVariance
     */
/**
     * @hide
     * @method getDeadlineDate
     */
/**
     * @hide
     * @method getDuration
     */
/**
     * @hide
     * @method getDurationUnit
     */
/**
     * @hide
     * @method getEarlyEndDate
     */
/**
     * @hide
     * @method getEarlyStartDate
     */
/**
     * @hide
     * @method getEffort
     */
/**
     * @hide
     * @method getEffortUnit
     */
/**
     * @hide
     * @method getEffortVariance
     */
/**
     * @hide
     * @method getEndSlack
     */
/**
     * @hide
     * @method getFreeSlack
     */
/**
     * @hide
     * @method getLateEndDate
     */
/**
     * @hide
     * @method getLateStartDate
     */
/**
     * @hide
     * @method getProject
     */
/**
     * @hide
     * @method getResources
     */
/**
     * @hide
     * @method getSchedulingMode
     */
/**
     * @hide
     * @method getSegment
     */
/**
     * @hide
     * @method getSegmentByDate
     */
/**
     * @hide
     * @method getSegments
     */
/**
     * @hide
     * @method getStartSlack
     */
/**
     * @hide
     * @method getTotalSlack
     */
/**
     * @hide
     * @method hasAssignments
     */
/**
     * @hide
     * @method hasConstraint
     */
/**
     * @hide
     * @method hasResources
     */
/**
     * @hide
     * @method isAssignedTo
     */
/**
     * @hide
     * @method isBaselineMilestone
     */
/**
     * @hide
     * @method isConstraintSatisfied
     */
/**
     * @hide
     * @method isCritical
     */
/**
     * @hide
     * @method isMilestone
     */
/**
     * @hide
     * @method isSegmented
     */
/**
     * @hide
     * @method merge
     */
/**
     * @hide
     * @method reassign
     */
/**
     * @hide
     * @method setActualEffort
     */
/**
     * @hide
     * @method setBaselineCost
     */
/**
     * @hide
     * @method setBaselineEffort
     */
/**
     * @hide
     * @method setBaselineEndDate
     */
/**
     * @hide
     * @method setBaselinePercentDone
     */
/**
     * @hide
     * @method setBaselineStartDate
     */
/**
     * @hide
     * @method setConstraint
     */
/**
     * @hide
     * @method setConstraintDate
     */
/**
     * @hide
     * @method setConstraintType
     */
/**
     * @hide
     * @method setCost
     */
/**
     * @hide
     * @method setDeadlineDate
     */
/**
     * @hide
     * @method setDuration
     */
/**
     * @hide
     * @method setDurationUnit
     */
/**
     * @hide
     * @method setDurationWithoutPropagation
     */
/**
     * @hide
     * @method setEffort
     */
/**
     * @hide
     * @method setEffortUnit
     */
/**
     * @hide
     * @method setEffortWithoutPropagation
     */
/**
     * @hide
     * @method setSchedulingMode
     */
/**
     * @hide
     * @method setSchedulingModeWithoutPropagation
     */
/**
     * @hide
     * @method setSegments
     */
/**
     * @hide
     * @method setSegmentsWithoutPropagation
     */
/**
     * @hide
     * @method split
     */
/**
     * @hide
     * @method unassign
     */
/**
     * @hide
     * @method getAllDependencies
     */
/**
     * @hide
     * @method getIncomingDependencies
     */
/**
     * @hide
     * @method getOutgoingDependencies
     */
/**
     * @hide
     * @method hasDependencies
     */
/**
     * @hide
     * @method hasIncomingDependencies
     */
/**
     * @hide
     * @method hasOutgoingDependencies
     */
/**
     * @hide
     * @method getPredecessors
     */
/**
     * @hide
     * @method getSuccessors
     */
/**
     * @hide
     * @method linkTo
     */
/**
     * @hide
     * @method unlinkFrom
     */

/**
 * This extension of EventDependencyCache is needed for backwards compatibility only. The keys of this cache are Task ids
 * (or complex keys encoding a Task id), the values are dependencies. The Task interface declares two deprecated properties
 * `successors` and `predecessors` this class fills those properties in supporting backwards compatibility.
 *
 * TODO: remove this class and modify Gnt.data.DependencyStore constructor, where instance of this class is created
 *       and assigned to `eventDependencyCache` property, when Task::successors/Task::predecessors are finaly removed
 *       and not supported anymore.
 */
Ext.define('Gnt.data.util.TaskDependencyCache', function(thisCls) {
    function keyToTask(me, k) {
        var ts;
        if (!(k instanceof Ext.data.Model)) {
            ts = me.dependencyStore.getTaskStore();
            k = ts && ts.getModelById(k);
        }
        return k;
    }
    function fillSuccessors(me, k) {
        var t = keyToTask(me, k);
        t && (t.successors = me.getSuccessors(k));
    }
    function fillPredecessors(me, k) {
        var t = keyToTask(me, k);
        t && (t.predecessors = me.getPredecessors(k));
    }
    function clearSuccessorsPredecessors(me) {
        var ts = me.dependencyStore.getTaskStore(),
            root = ts && ts.getRoot();
        root && root.cascadeBy(function(node) {
            node.successors = [];
            node.predecessors = [];
        });
    }
    function fillTasksWithDepInfo(me) {
        var ts = me.dependencyStore.getTaskStore(),
            root = ts && ts.getRoot();
        root && root.cascadeBy(function(node) {
            node.successors = me.getSuccessors(node);
            node.predecessors = me.getPredecessors(node);
        });
    }
    return {
        extend: 'Sch.data.util.EventDependencyCache',
        taskStoreDetacher: null,
        taskStoreDependencyStoreDetacher: null,
        constructor: function(dependencyStore) {
            var me = this,
                taskStore;
            me.callParent([
                dependencyStore
            ]);
            function onTaskStoreRootChange(store) {
                fillTasksWithDepInfo(me);
            }
            function onTaskStoreNodeAppend(parent, node) {
                fillSuccessors(me, node);
                fillPredecessors(me, node);
            }
            function onTaskStoreNodeInsert(parent, node) {
                fillSuccessors(me, node);
                fillPredecessors(me, node);
            }
            function onTaskStoreRefresh(store) {
                fillTasksWithDepInfo(me);
            }
            function onDependencyStoreTaskStoreChange(store, taskStore) {
                attachToTaskStore(taskStore);
            }
            function onDependencyStoreRefresh(store) {
                fillTasksWithDepInfo(me);
            }
            function attachToTaskStore(store) {
                Ext.destroy(me.taskStoreDetacher);
                me.taskStoreDetacher = store && store.on({
                    'rootchange': onTaskStoreRootChange,
                    'nodeappend': onTaskStoreNodeAppend,
                    'nodeinsert': onTaskStoreNodeInsert,
                    'refresh': onTaskStoreRefresh,
                    priority: 99,
                    destroyable: true
                });
                // This cache can't work lazyly, so if a task store changes then it should fill itself
                // otherwise task's `successors`, `predecessors` properties won't be up-to-date
                fillTasksWithDepInfo(me);
            }
            me.taskStoreDependencyStoreDetacher = dependencyStore.on({
                'eventstorechange': onDependencyStoreTaskStoreChange,
                'refresh': onDependencyStoreRefresh,
                priority: 100,
                destroyable: true
            });
            attachToTaskStore(dependencyStore.getTaskStore());
        },
        destroy: function() {
            var me = this;
            me.callParent();
            Ext.destroyMembers(me, 'taskStoreDetacher', 'taskStoreDependencyStoreDetacher');
        },
        addSuccessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillSuccessors(me, k);
        },
        addPredecessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillPredecessors(me, k);
        },
        setSuccessors: function(k, vals) {
            var me = this;
            me.callParent([
                k,
                vals
            ]);
            fillSuccessors(me, k);
        },
        setPredecessors: function(k, vals) {
            var me = this;
            me.callParent([
                k,
                vals
            ]);
            fillPredecessors(me, k);
        },
        removeSuccessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillSuccessors(me, k);
        },
        removePredecessor: function(k, v) {
            var me = this;
            me.callParent([
                k,
                v
            ]);
            fillPredecessors(me, k);
        },
        moveSuccessors: function(oldKey, newKey, v) {
            var me = this;
            me.callParent(arguments);
            fillSuccessors(me, oldKey);
            fillSuccessors(me, newKey);
        },
        movePredecessors: function(oldKey, newKey, v) {
            var me = this;
            me.callParent(arguments);
            fillPredecessors(me, oldKey);
            fillPredecessors(me, newKey);
        },
        clearSuccessors: function(k) {
            var me = this;
            me.callParent([
                k
            ]);
            fillSuccessors(me, k);
        },
        clearPredecessors: function(k) {
            var me = this;
            me.callParent([
                k
            ]);
            fillPredecessors(me, k);
        },
        clear: function(k) {
            var me = this;
            me.callParent(arguments);
            if (k) {
                fillSuccessors(me, k);
                fillPredecessors(me, k);
            } else {
                clearSuccessorsPredecessors(me);
            }
        }
    };
});

/**

@class Gnt.data.DependencyStore
@extends Ext.data.Store

 A class representing a collection of dependencies between the tasks in the {@link Gnt.data.TaskStore}.
 Contains a collection of {@link Gnt.model.Dependency} records.

## Custom validation

You can subclass the class like any other Ext JS one and add your own custom validation for Dependencies:

    Ext.define('MyDependencyStore', {
        extend              : 'Gnt.data.DependencyStore',

        // Override this method to provide custom logic defining what constitutes a valid dependency
        getDependencyError  : function (from, to) {
            // Support default validation rules
            var error = this.callParent(arguments);
            if (error) return error;


            // Example: Don`t allow links between tasks of type A, to tasks with type B

            var taskStore = this.getTaskStore(),
                sourceTask,
                targetTask;

            // a dependency can be provided as a model instance
            if (from instanceof Gnt.model.Dependency) {
                sourceTask = from.getSourceTask();
                targetTask = from.getTargetTask();
            // ..or "from" & "to" contain predecessor & successor identifiers
            } else {
                sourceTask = taskStore.getModelById(from);
                targetTask = taskStore.getModelById(to);
            }

            // Let`s return a custom error code -100 for such case (it must be a negative value)
            if (sourceTask.getType() !== 'A' || targetTask.getType() !== 'B') return -100;

            // No errors
            return 0;
        },

        ...
    })

*/
Ext.define('Gnt.data.DependencyStore', {
    extend: 'Sch.data.DependencyStore',
    requires: [
        'Sch.util.Date',
        'Gnt.data.util.TaskDependencyCache'
    ],
    model: 'Gnt.model.Dependency',
    alias: 'store.gantt_dependencystore',
    //private
    taskStore: null,
    methodsCache: null,
    /**
     * @cfg {Boolean} strictDependencyValidation A boolean flag indicating whether a strict validation of dependencies should be applied.
     * This mode will detect indirect cycles between parent-child relationships.
     * For example, the following cases will be considered as invalid (here `P1`, `P2`, `P3` are parent tasks and `T1`, `T2`, `T3` - their children respectively):

                P1 =========
                T1 ++++++          P2 =========
                                   T2    +++++        P3 ===============
                                                      T3 +++++++++++++++

     * These cases will be considered as cycles:
     *
     * - if we have dependency `P1---->P2` then dependency `T2---->P1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T2---->T1` will be invalid
     * - if we have dependency `P1---->P2` then dependency `T2---->T1` will be invalid
     * - if we have dependencies `P1---->P2---->P3` then dependency `T3---->T1` will be invalid
     * - if we have dependency `P1---->T2` then dependency `P2---->T1` will be invalid
     * - if we have dependencies `P1---->T2` `P2---->T3` then dependency `P3---->T1` will be invalid
     * - if we have dependencies `T1---->P2` `T2---->P3` then dependency `T3---->P1` will be invalid
     *
     * and these cases will be treated as transitivity (or duplicating) dependency when {@link #transitiveDependencyValidation} is set to `True`:
     *
     * - if we have dependency `P1---->P2` then dependency `T1---->P2` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T1---->T2` will be invalid
     * - if we have dependency `P1---->P2` then dependency `T1---->T2` will be invalid
     * - if we have dependencies `P1---->P2---->P3` then dependency `T1---->T3` will be invalid
     * - if we have dependency `P1---->T2` then dependency `T1---->P2` will be invalid
     * - if we have dependencies `P1---->T2` `P2---->T3` then dependency `T1---->P3` will be invalid
     * - if we have dependencies `T1---->P2` `T2---->P3` then dependency `P1---->T3` will be invalid
     */
    strictDependencyValidation: false,
    /**
     * @cfg {Boolean} transitiveDependencyValidation When set to true, alternative routes between tasks are considered invalid.
     * For example if we have dependencies `A---->B---->C` and `D---->C` then dependency `A---->D` will be treated as invalid
     * because it builds an alternative route from task `A` to task `C`.
     *
     * When {@link #strictDependencyValidation} is `True` this setting also enables detecting transitivity between groups of tasks.
     * Please see {@link #strictDependencyValidation} description for examples.
     */
    transitiveDependencyValidation: false,
    /**
     * @cfg {String[]} allowedDependencyTypes
     *
     * Represents a list of the dependency types that are allowed in this store. Any {@link Gnt.panel.Gantt} panel associated with this store
     * will query this store for this information. If set to `null` (the default value) all types of dependencies are allowed.
     * To restrict the allowed dependencies set, provide it as an array of strings, corresponding to the names in the {@link Gnt.model.Dependency#Type} enumerable.
     *
     * For example:
     *
     *          allowedDependencyTypes : [ 'StartToEnd', 'EndToEnd' ]
     *
     */
    allowedDependencyTypes: null,
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `false` to disallow dependencies involving parent tasks.
     */
    allowParentTaskDependencies: true,
    /**
     * @cfg {Boolean} autoCalculateLag Set to `true` to calculate lag automatically for newly added and updated dependencies. Only applies when no {@link #Lag} is set in the model.
     * On update of start- or endDate of a task this will effect the ingoing dependencies of the task.
     */
    autoCalculateLag: false,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.init();
    },
    createEventDependencyCache: function() {
        return new Gnt.data.util.TaskDependencyCache(this);
    },
    init: function() {
        var me = this;
        me.methodsCache = {};
        me.on({
            add: me.onDependencyAdd,
            update: me.onDependencyUpdate,
            // seems we can't use "bulkremove" event, because one can listen to `remove` event on the task store
            // and expect correct state in it
            remove: me.onDependencyRemove,
            priority: 100,
            scope: me
        });
    },
    updateAutoCalculatedLag: function(dependency) {
        if (dependency.getLag() === 0) {
            var DependencyType = this.model.Type,
                lagUnit = dependency.getLagUnit(),
                from = dependency.getSourceTask(),
                to = dependency.getTargetTask(),
                DATE = Sch.util.Date,
                sign = 1,
                start, end;
            switch (dependency.getType()) {
                case DependencyType.StartToStart:
                    if (to.getStartDate() < from.getStartDate())  {
                        sign = -1;
                    }
                    ;
                    start = DATE.min(from.getStartDate(), to.getStartDate());
                    end = DATE.max(from.getStartDate(), to.getStartDate());
                    break;
                case DependencyType.StartToEnd:
                    if (to.getEndDate() < from.getStartDate())  {
                        sign = -1;
                    }
                    ;
                    start = DATE.min(from.getStartDate(), to.getEndDate());
                    end = DATE.max(from.getStartDate(), to.getEndDate());
                    break;
                case DependencyType.EndToStart:
                    if (to.getStartDate() < from.getEndDate())  {
                        sign = -1;
                    }
                    ;
                    start = DATE.min(to.getStartDate(), from.getEndDate());
                    end = DATE.max(to.getStartDate(), from.getEndDate());
                    break;
                case DependencyType.EndToEnd:
                    if (to.getEndDate() < from.getEndDate())  {
                        sign = -1;
                    }
                    ;
                    start = DATE.min(to.getEndDate(), from.getEndDate());
                    end = DATE.max(to.getEndDate(), from.getEndDate());
                    break;
            }
            var lag = to.calculateDuration(start, end, lagUnit);
            dependency.setLag(sign * lag);
        }
    },
    onDependencyAdd: function(me, dependencies) {
        // Looping over added dependencies but
        //     need to ignore the initial "add" events for data provided in the config
        Ext.Array.each(dependencies, function(dependency) {
            // ensure that tasks being linked are fully scheduled only if we are not currently undoing or redoing
            var from = dependency.getSourceTask(),
                to = dependency.getTargetTask();
            if (from && to && !me.isUndoingOrRedoing()) {
                // TODO: this code needs to be moved to TaskStore ..it should support projections
                me.autoCalculateLag && me.updateAutoCalculatedLag(dependency);
            }
        });
        me.resetMethodsCache();
    },
    onDependencyRemove: function(me, dependencies) {
        me.resetMethodsCache();
    },
    onDependencyUpdate: function(me, dependency, operation) {
        if (operation != Ext.data.Model.COMMIT) {
            me.resetMethodsCache();
        }
    },
    // TODO: document
    reduceTaskDependencies: function(task, reduceFn, result, flat, depsGetterFn) {
        return this.reduceEventDependencies(task, reduceFn, result, flat, depsGetterFn);
    },
    // TODO: document
    reduceTaskIncomingDependencies: function(task, reduceFn, result, flat) {
        return this.reduceEventIncomingDependencies(task, reduceFn, result, flat);
    },
    // TODO: document
    reduceTaskOutgoingDependencies: function(task, reduceFn, result, flat) {
        return this.reduceEventOutgoingDependencies(task, reduceFn, result, flat);
    },
    // TODO: document
    mapTaskDependencies: function(task, fn, filterFn, flat, depsGetterFn) {
        return this.mapEventDependencies(task, fn, filterFn, flat, depsGetterFn);
    },
    // TODO: document
    mapTaskIncomingDependencies: function(task, fn, filterFn, flat) {
        return this.mapEventIncomingDependencies(task, fn, filterFn, flat);
    },
    // TODO: document
    mapTaskOutgoingDependencies: function(task, fn, filterFn, flat) {
        return this.mapEventOutgoingDependencies(task, fn, filterFn, flat);
    },
    /**
     * Returns all dependencies for a certain task (both incoming and outgoing)
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     * @return {Gnt.model.Dependency[]}
     */
    getTaskDependencies: function(task, flat) {
        return this.getEventDependencies(task, flat);
    },
    /**
     * Returns all incoming dependencies of the given task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     *
     * @return {Gnt.model.Dependency[]}
     */
    getTaskIncomingDependencies: function(task, flat) {
        return this.getEventIncomingDependencies(task, flat);
    },
    /**
     * Returns all outcoming dependencies of a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     *
     * @return {Gnt.model.Dependency[]}
     */
    getTaskOutgoingDependencies: function(task, flat) {
        return this.getEventOutgoingDependencies(task, flat);
    },
    /**
     * Returns all predecessors of a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     *
     * @return {Gnt.model.Task[]}
     */
    getTaskPredecessors: function(task, flat) {
        return this.getEventPredecessors(task, flat);
    },
    /**
     * Returns all successors of a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     *
     * @return {Gnt.model.Task[]}
     */
    getTaskSuccessors: function(task, flat) {
        return this.getEventSuccessors(task, flat);
    },
    /**
     * Removed all dependencies for a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     */
    removeTaskDependencies: function(task, flat) {
        this.removeEventDependencies(task, flat);
    },
    /**
     * Removes all incoming dependencies for a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     */
    removeTaskIncomingDependencies: function(task, flat) {
        this.removeEventIncomingDependencies(task, flat);
    },
    /**
     * Removes all outgoing dependencies for a task
     *
     * @param {Gnt.model.Task} task
     * @param {Boolean} flat
     */
    removeTaskOutgoingDependencies: function(task, flat) {
        this.removeEventOutgoingDependencies(task, flat);
    },
    // @private
    // Serializes array of dependencies. Used during cache key calculation.
    getKeyByDeps: function(dependencies, fromField, toField) {
        if (!dependencies || !dependencies.length)  {
            return '';
        }
        
        var key = '';
        for (var i = 0,
            l = dependencies.length; i < l; i++) {
            var dep = dependencies[i];
            key += (dep.getSourceId && dep.getSourceId() || dep[fromField]) + ':' + (dep.getTargetId && dep.getTargetId() || dep[toField]) + ',';
        }
        return key;
    },
    buildCacheKey: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        var fromField = context.fromField || (context.fromField = this.model.prototype.fromField),
            toField = context.toField || (context.toField = this.model.prototype.toField),
            ignoreDepKey = context.ignoreDepKey,
            addDepKey = context.addDepKey;
        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!context.hasOwnProperty('ignoreDepKey')) {
            context.ignoreDepKey = ignoreDepKey = ignoreDepRecords && this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            context.addDepKey = addDepKey = addDepRecords && this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }
        // calculate cache key for provided arguments
        return sourceId + '-' + targetId + '-' + ignoreDepKey + '-' + addDepKey;
    },
    /**
     * @method hasTransitiveDependency
     * Returns `true` if there is a dependency (either direct or "transitive") between tasks
     * with `sourceId` and `targetId`
     *
     * @param {String} sourceId
     * @param {String} targetId
     * @param {Gnt.model.Dependency[]} [ignoreDepRecords] If provided, dependencies in this array will be ignored during transitivity search.
     * @param {Gnt.model.Dependency[]/Object[]} [addDepRecords] If provided, search will be done supposing that specified records exist in the dependency store.
     *
     * @return {Boolean}
     */
    /** @ignore */
    hasTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {
            visitedTasks: {}
        };
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var visitedTasks = context.visitedTasks,
            extraSuccessors = context.extraSuccessors;
        if (this.isCachedResultAvailable('hasTransitiveDependency', cacheKey)) {
            return this.methodsCache.hasTransitiveDependency[cacheKey];
        }
        var me = this,
            fromField = context.fromField,
            toField = context.toField,
            sourceTask = this.getTaskById(sourceId),
            i, l;
        // protection from cycles
        if (visitedTasks[sourceId])  {
            return false;
        }
        
        visitedTasks[sourceId] = true;
        if (sourceTask) {
            // if list of dependencies to be created is provided let's
            // organize it as a hash containing successors list by task ids
            if (addDepRecords && !extraSuccessors) {
                extraSuccessors = context.extraSuccessors = {};
                for (i = 0 , l = addDepRecords.length; i < l; i++) {
                    var dep = addDepRecords[i];
                    var from = dep.getSourceId && dep.getSourceId() || dep[fromField];
                    extraSuccessors[from] = extraSuccessors[from] || [];
                    extraSuccessors[from].push(dep);
                }
            }
            var dependency,
                successors = sourceTask.successors;
            // add successors to be added to existing successors
            if (extraSuccessors && extraSuccessors[sourceId])  {
                successors = successors.concat(extraSuccessors[sourceId]);
            }
            
            for (i = 0 , l = successors.length; i < l; i++) {
                dependency = successors[i];
                var target = dependency.getTargetId && dependency.getTargetId() || dependency[toField];
                if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) && (target === targetId || me.hasTransitiveDependency(target, targetId, ignoreDepRecords, addDepRecords, context))) {
                    return this.setCachedResult('hasTransitiveDependency', cacheKey, true);
                }
            }
        }
        return this.setCachedResult('hasTransitiveDependency', cacheKey, false);
    },
    successorsHaveTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {};
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var task = targetId instanceof Gnt.model.Task ? targetId : this.getTaskById(targetId);
        if (this.isCachedResultAvailable('successorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.successorsHaveTransitiveDependency[cacheKey];
        }
        for (var i = 0,
            l = task.successors.length; i < l; i++) {
            var toId = task.successors[i].getTargetId();
            if (this.hasTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) || this.predecessorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords) || this.successorsHaveTransitiveDependency(sourceId, toId, ignoreDepRecords, addDepRecords, context))  {
                return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, true);
            }
            
        }
        return this.setCachedResult('successorsHaveTransitiveDependency', cacheKey, false);
    },
    predecessorsHaveTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        context = context || {};
        // calculate cache key for provided arguments
        var cacheKey = this.buildCacheKey(sourceId, targetId, ignoreDepRecords, addDepRecords, context);
        var task = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);
        if (this.isCachedResultAvailable('predecessorsHaveTransitiveDependency', cacheKey)) {
            return this.methodsCache.predecessorsHaveTransitiveDependency[cacheKey];
        }
        for (var i = 0,
            l = task.predecessors.length; i < l; i++) {
            var fromId = task.predecessors[i].getSourceId();
            if (this.hasTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) || this.successorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords) || this.predecessorsHaveTransitiveDependency(fromId, targetId, ignoreDepRecords, addDepRecords, context))  {
                return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, true);
            }
            
        }
        return this.setCachedResult('predecessorsHaveTransitiveDependency', cacheKey, false);
    },
    isPartOfTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords) {
        var task = sourceId instanceof Gnt.model.Task ? sourceId : this.getTaskById(sourceId);
        if (!task.predecessors.length && !task.successors.length)  {
            return false;
        }
        
        if (task.predecessors.length) {
            return this.predecessorsHaveTransitiveDependency.apply(this, arguments);
        } else {
            return this.successorsHaveTransitiveDependency.apply(this, arguments);
        }
    },
    getCycle: function(context) {
        context = context || {};
        Ext.applyIf(context, {
            ignoreTasks: {},
            visitedTasks: {},
            path: [],
            task: this.getAt(0).getSourceTask()
        });
        var visitedTasks = context.visitedTasks,
            ignoreTasks = context.ignoreTasks,
            path = context.path,
            task = context.task,
            taskId = task.getId();
        if (ignoreTasks[taskId])  {
            return;
        }
        
        path.push(task);
        if (visitedTasks[taskId])  {
            return path;
        }
        
        visitedTasks[taskId] = true;
        var successors = task.successors;
        for (var i = 0,
            l = successors.length; i < l; i++) {
            context.task = successors[i].getTargetTask();
            var cycle = this.getCycle(context);
            if (cycle)  {
                return cycle;
            }
            
        }
        path.pop();
        delete visitedTasks[taskId];
    },
    getCycles: function() {
        var me = this,
            result = [],
            ignoreTasks = {};
        this.each(function(dep) {
            var path = me.getCycle({
                    task: dep.getSourceTask(),
                    ignoreTasks: ignoreTasks
                });
            if (path) {
                for (var i = 0,
                    l = path.length; i < l; i++) {
                    ignoreTasks[path[i]] = true;
                }
                result.push(path);
            }
        });
        return result;
    },
    resetMethodsCache: function() {
        this.methodsCache = {};
    },
    isCachedResultAvailable: function(method, key) {
        return this.methodsCache[method] && this.methodsCache[method].hasOwnProperty(key);
    },
    getCachedResult: function(method, key) {
        return this.methodsCache[method][key];
    },
    setCachedResult: function(method, key, value) {
        this.methodsCache[method] = this.methodsCache[method] || {};
        this.methodsCache[method][key] = value;
        return value;
    },
    // @private
    getGroupTopTasks: function(sourceGroup, targetGroup) {
        var sourceGroupLength = sourceGroup.length,
            targetGroupLength = targetGroup.length,
            i = sourceGroupLength,
            j = targetGroupLength,
            sourceTopParent, targetTopParent;
        do {
            sourceTopParent = sourceGroup[i];
            targetTopParent = targetGroup[j];
            i--;
            j--;
        } while (sourceTopParent == targetTopParent && i >= 0 && j >= 0);
        return [
            sourceTopParent,
            targetTopParent
        ];
    },
    groupsHasTransitiveDependency: function(sourceId, targetId, ignoreDepRecords, addDepRecords, context) {
        var ctx = context || {
                targets: null,
                visitedTasks: {}
            };
        var root = this.getTaskStore().getRootNode(),
            result = false,
            me = this,
            source = this.getTaskById(sourceId),
            target = this.getTaskById(targetId),
            visitedTasks = ctx.visitedTasks,
            targets = ctx.targets;
        if (!ctx.targetGroup) {
            ctx.targetGroup = target.getTopParent(true);
        }
        var fromField = ctx.fromField || (ctx.fromField = this.model.prototype.fromField),
            toField = ctx.toField || (ctx.toField = this.model.prototype.toField),
            ignoreDepKey = ctx.ignoreDepKey,
            addDepKey = ctx.addDepKey;
        // get groups top elements based on their intersection
        var groups = this.getGroupTopTasks(source.getTopParent(true), ctx.targetGroup),
            sourceTopParent = groups[0],
            targetTopParent = groups[1];
        if (sourceTopParent === source && targetTopParent === target && source.isLeaf() && target.isLeaf()) {
            return this.hasTransitiveDependency(sourceId, targetId, ignoreDepRecords);
        }
        // let's preserve key part calculated by ignoreDepRecords and addDepRecords since they will not change
        if (!ctx.hasOwnProperty('ignoreDepKey')) {
            ctx.ignoreDepKey = ignoreDepKey = ignoreDepRecords && this.getKeyByDeps(ignoreDepRecords, fromField, toField) || '';
            ctx.addDepKey = addDepKey = addDepRecords && this.getKeyByDeps(addDepRecords, fromField, toField) || '';
        }
        // calculate cache key for provided arguments
        var cacheKey = sourceTopParent.getId() + '-' + targetTopParent.getId() + '-' + ignoreDepKey + '-' + addDepKey;
        if (this.isCachedResultAvailable('groupsHasTransitiveDependency', cacheKey)) {
            return this.methodsCache.groupsHasTransitiveDependency[cacheKey];
        }
        // if top target element has changed for this source group
        // then we need to regather "targets" hash
        if (targetTopParent !== ctx.targetTopParent) {
            ctx.targetTopParent = targetTopParent;
            targets = ctx.targets = {};
            // collect children Ids into targets hash
            targetTopParent.cascadeBy(function(task) {
                targets[task.getId()] = true;
            });
        }
        var extraSuccessors = ctx.extraSuccessors;
        // if list of dependencies to be created is provided let's
        // organize it as a hash containing successors list by task ids
        if (addDepRecords && !extraSuccessors) {
            extraSuccessors = ctx.extraSuccessors = {};
            for (var i = 0,
                l = addDepRecords.length; i < l; i++) {
                var dep = addDepRecords[i];
                var from = dep.getSourceId && dep.getSourceId() || dep[fromField];
                extraSuccessors[from] = extraSuccessors[from] || [];
                extraSuccessors[from].push(dep);
            }
        }
        // for each source group task we check if any of its succeeding task is in "targets" hash
        sourceTopParent.cascadeBy(function(task) {
            if (task !== root) {
                var taskId = task.getId();
                // data cycles protection
                if (visitedTasks[taskId])  {
                    return false;
                }
                
                visitedTasks[taskId] = true;
                var successors = task.successors;
                // add successors to be added to existing successors
                if (extraSuccessors && extraSuccessors[taskId])  {
                    successors = successors.concat(extraSuccessors[taskId]);
                }
                
                for (var i = 0,
                    l = successors.length; i < l; i++) {
                    var dependency = successors[i],
                        toId = dependency.getTargetId && dependency.getTargetId() || dependency[toField];
                    // if succeeding task is not in ignore list
                    // and it's in "targets" then we found transitivity
                    // otherwise we go deeper
                    if ((!ignoreDepRecords || Ext.Array.indexOf(ignoreDepRecords, dependency) == -1) && (targets[toId] || me.groupsHasTransitiveDependency(toId, targetId, ignoreDepRecords, addDepRecords, ctx))) {
                        result = true;
                        return false;
                    }
                }
            }
        });
        // update cache
        return this.setCachedResult('groupsHasTransitiveDependency', cacheKey, result);
    },
    /**
     * @method getDependencyError
     * Validates a provided dependency and returns a corresponding error code or zero if no error was detected.
     * This method can validate either an existing {@link Gnt.model.Dependency} instance or a proposed (about to be created) link
     * that can be specified as source and target task identifiers plus the dependency type.
     *
     * If you subclass this class, you can provide your own version of this method.
     * Please note that this method is supposed to return a negative integer error code so
     * ensure that you choose some unused values for any new kind of validation.
     * Don't forget to call the parent implementation if you also want to check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies (this check is done only when {@link #transitiveDependencyValidation} is set to `True`), e.g. if A -> B, B -> C, then A -> C is not valid, or if A -> B, A -> C, then B -> C is not valid
     * - cyclic dependencies, e.g. if A -> B, B -> C, then C -> A is not valid
     *
     * **Note:** This method behavior depends on {@link #transitiveDependencyValidation} and {@link #strictDependencyValidation} option.
     * The first config enables so called _transitivity_ validation. And when {@link #strictDependencyValidation} is turned on,
     * the system tries to detect cycles (and transitivity if {@link #transitiveDependencyValidation} enabled) cases between groups of tasks.
     *
     * The method can be used either by providing a dependency as the first argument (then `toId` and `type` should be omitted):
     *
     *      // checking dependency record
     *      switch (dependencyStore.getDependencyError(dependency)) {
     *          case -3: case -8: case -5:
     *              alert('This dependency builds duplicating transitivity');
     *              break;
     *          case -4: case -7:
     *              alert('This is a cyclic dependency');
     *              break;
     *          ...
     *      }
     *
     * or by providing identifiers of the source and target tasks as well as the type of the dependency (if `type` is not provided it defaults to End-To-Start):
     *
     *      // check if 11 --> 15 dependency is between parent & child
     *      if (dependencyStore.getDependencyError(11, 15) == -9) {
     *          alert('This is a dependency between parent and its child');
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done assuming that the specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done assuming that the specified records DO NOT exist in the dependency store.
     * @return {Number} Returns zero if dependency is valid.
     * Full list of possible values is:
     *
     *  - `0`  dependency is valid
     *  - `-1`  other error (wrong input data provided: empty source/target Id(s) or source Id equals target Id)
     *  - `-2`  source (or target) task is not found
     *  - `-3`  transitive dependency (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-4`  cyclic dependency
     *  - `-5`  transitive dependency (dependency being validated is part of larger transitive route) (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-7`  cyclic dependency between groups
     *  - `-8`  transitive dependency between groups (returned only when {@link #transitiveDependencyValidation} is `True`)
     *  - `-9`  dependency between parent and child
     *  - `-10` wrong dependency type
     *  - `-11` dependencies to/from parent tasks not allowed
     *  - `-12` dependencies to projects not allowed
     *  - `-13` dependencies to other project tasks not allowed
     */
    /** @ignore */
    getDependencyError: function(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        // `calledFromThisModel` is used when called from `isValid` method of depedency model
        var fromId, fromTask, toTask;
        var modelInput = dependencyOrFromId instanceof Gnt.model.Dependency;
        // Normalize input
        if (modelInput) {
            fromId = dependencyOrFromId.getSourceId();
            fromTask = this.getTaskById(fromId);
            // if dependency provided then `toId` and `type` arguments can be skipped
            dependenciesToAdd = toId;
            dependenciesToRemove = type;
            // if dependency being validated presented in dependenciesToAdd list
            if (dependenciesToAdd && Ext.Array.contains(dependenciesToAdd, dependencyOrFromId)) {
                // make list copy
                dependenciesToAdd = dependenciesToAdd.slice();
                // and remove dependency from it
                Ext.Array.remove(dependenciesToAdd, dependencyOrFromId);
            }
            type = dependencyOrFromId.getType();
            toId = dependencyOrFromId.getTargetId();
            toTask = this.getTaskById(toId);
            // if we've been called with dependencies model as 1st arg (modelInput) and that dependency
            // is already in the dep store, this case is identical to called "isValid" method on the dependency record
            if (dependencyOrFromId.store)  {
                calledFromThisDepModel = dependencyOrFromId;
            }
            
        } else {
            fromId = dependencyOrFromId;
            fromTask = this.getTaskById(fromId);
            toTask = this.getTaskById(toId);
            if (type === undefined) {
                // get default dependency type from the dependency class
                var defaultType = this.model.getField(this.model.prototype.typeField).defaultValue;
                type = defaultType !== undefined ? defaultType : this.model.Type.EndToStart;
            }
        }
        if (!calledFromThisDepModel && modelInput && !dependencyOrFromId.isValid()) {
            return -1;
        } else if (!fromId || !toId || fromId == toId) {
            return -1;
        }
        // Both tasks need to exist for the link to make sense
        if (!fromTask || !toTask)  {
            return -2;
        }
        
        // check dependency type
        if (!this.isValidDependencyType(type))  {
            return -10;
        }
        
        // Also, not allowed to setup a link between a parent and its child
        if (fromTask.contains(toTask) || toTask.contains(fromTask))  {
            return -9;
        }
        
        var depsToIgnore;
        if (dependenciesToRemove || calledFromThisDepModel) {
            depsToIgnore = [];
            // ignore dependency itself during transitivities/cycles search
            if (calledFromThisDepModel)  {
                depsToIgnore.push(calledFromThisDepModel);
            }
            
            if (dependenciesToRemove)  {
                depsToIgnore = depsToIgnore.concat(dependenciesToRemove);
            }
            
        }
        // checking the presence of transitivity in forward direction (fromId -> toId) - prevents actual transitivity
        if (this.transitiveDependencyValidation) {
            if (this.hasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -3;
            }
            
        } else {
            // check if tasks are already linked directly
            if (this.areTasksLinkedForward(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -3;
            }
            
        }
        // checking the presence of transitivity in backward direction (toId -> fromId) - prevents cycles
        if (this.hasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd))  {
            return -4;
        }
        
        // checking the presence of transitivity between fromId-task and some of toId-task successors
        // or between some of fromId-task predecessors and toId-task
        // it detects cases when we have 1->2, 1->3 dependencies and validating 2->3 dependency
        // and when we have 2->3, 1->3 dependencies and validating 1->2 dependency
        if (this.transitiveDependencyValidation && this.isPartOfTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
            return -5;
        }
        
        // if strict dependencies validation mode enabled
        if (this.strictDependencyValidation) {
            // let's check if there is an opposite relation between the tasks parent-child stacks (to prevent cycle)
            if (this.groupsHasTransitiveDependency(toId, fromId, depsToIgnore, dependenciesToAdd))  {
                return -7;
            }
            
            // also check if there is some other relation of the same direction (to prevent transitivity)
            if (this.transitiveDependencyValidation && this.groupsHasTransitiveDependency(fromId, toId, depsToIgnore, dependenciesToAdd))  {
                return -8;
            }
            
        }
        if (!this.allowParentTaskDependencies && (!fromTask.isLeaf() || !toTask.isLeaf()))  {
            return -11;
        }
        
        // project record itself cannot be linked w/ a dependency
        if (toTask.isProject || fromTask.isProject) {
            return -12;
        }
        // children of a project are connectible depending on "AllowDependencies" flag
        var toProject = toTask.getProject(),
            fromProject = fromTask.getProject();
        if (toProject != fromProject) {
            if (toProject && !toProject.getAllowDependencies() || fromProject && !fromProject.getAllowDependencies()) {
                return -13;
            }
        }
        return 0;
    },
    isValidDependencyType: function(type) {
        if (this.allowedDependencyTypes) {
            var result = false,
                model = this.model;
            Ext.each(this.allowedDependencyTypes, function(name) {
                if (model.Type[name] == type) {
                    result = true;
                    return false;
                }
            });
            return result;
        }
        return true;
    },
    /**
     * @method isValidDependency
     * Returns `true` if a dependency (or about to be created dependency) between two tasks is valid.
     *
     * **Please note,** If you subclass this class, that this method is just a wrapper over {@link #getDependencyError}
     * method so if you want to implement a custom validation please override {@link #getDependencyError}.
     * And don't forget to call the parent implementation if you also want the check for cyclic dependencies etc.
     *
     * These scenarios are considered invalid:
     *
     * - a task linking to itself
     * - a dependency between a child and one of its parents
     * - transitive dependencies, e.g. if A -> B, B -> C, then A -> C is not valid, or if A -> B, A -> C, then B -> C is not valid
     * - cyclic dependencies, e.g. if A -> B, B -> C, then C -> A is not valid
     *
     * **Note:** This method behavior depends on {@link #strictDependencyValidation} option.
     * When {@link #strictDependencyValidation} is turned on the system tries to detect cycles and transitivity cases between _groups of tasks_.
     *
     * Method can be used either by providing dependency in first argument (and then `toId` and `type` **should** be omitted):
     *
     *      // validating dependency record
     *      if (!dependencyStore.isValidDependency(dependency)) ...
     *
     * or by providing identifiers of source and target tasks and type of dependency (here `type` can be omitted as well if no further arguments are required):
     *
     *      // if 11 --> 15 dependency is valid
     *      if (dependencyStore.isValidDependency(11, 15)) {
     *          // let`s create it
     *          dependencyStore.add({ From: 11, To: 15 })
     *      }
     *
     * @param {Gnt.model.Dependency/Mixed} dependencyOrFromId Either a dependency or the source task id
     * @param {Mixed} [toId] The target task id. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Number} [type] The type of the dependency. Should be omitted if `dependencyOrFromId` is {@link Gnt.model.Dependency} instance.
     * @param {Gnt.model.Dependency[]/Object[]} [dependenciesToAdd] If provided, validation will be done supposing that specified records exist in the dependency store.
     * @param {Gnt.model.Dependency[]} [dependenciesToRemove]  If provided, validation will be done supposing that specified records DO NOT exist in the dependency store.
     * @return {Boolean}
     */
    /** @ignore */
    isValidDependency: function(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel) {
        return !this.getDependencyError(dependencyOrFromId, toId, type, dependenciesToAdd, dependenciesToRemove, calledFromThisDepModel);
    },
    /**
     * @method areTasksLinkedForward
     * Returns true if there is a direct forward dependency between the two tasks.
     * Please see also {@link #areTasksLinked} method to check both forward and backward directions.
     *
     * @param {Gnt.model.Task/Mixed} fromTask Source task or its id
     * @param {Gnt.model.Task/Mixed} toTask Target task or its id
     *
     * @return {Boolean}
     */
    /** @ignore */
    areTasksLinkedForward: function(fromTask, toTask, dependenciesToRemove, dependenciesToAdd) {
        var from = fromTask instanceof Gnt.model.Task ? fromTask : this.getTaskById(fromTask);
        var to = toTask instanceof Gnt.model.Task ? toTask : this.getTaskById(toTask);
        if (!from || !to)  {
            return false;
        }
        
        var model = this.model.prototype,
            fromField = model.fromField,
            toField = model.toField;
        var cacheKey = from.getId() + '-' + to.getId() + '-' + (this.getKeyByDeps(dependenciesToRemove, fromField, toField) || '') + '-' + (this.getKeyByDeps(dependenciesToAdd, fromField, toField) || '');
        if (this.isCachedResultAvailable('areTasksLinkedForward', cacheKey)) {
            return this.methodsCache.areTasksLinkedForward[cacheKey];
        }
        var successors = from.successors,
            predecessors = to.predecessors,
            dep, i, l;
        // loop over source task successors and check if some of them is presented in target tasks predecessors
        for (i = 0 , l = successors.length; i < l; i++) {
            dep = successors[i];
            // ignore dependencies provided in dependenciesToRemove array
            if ((!dependenciesToRemove || !Ext.Array.contains(dependenciesToRemove, dep)) && Ext.Array.contains(predecessors, dep))  {
                return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
            }
            
        }
        // if provided list of dependencies that we must consider as existing in the store
        if (dependenciesToAdd) {
            var sourceId, targetId;
            // let's loop over it and check if link between task is presented there
            for (i = 0 , l = dependenciesToAdd.length; i < l; i++) {
                dep = dependenciesToAdd[i];
                sourceId = dep.getSourceId && dep.getSourceId() || dep[fromField];
                targetId = dep.getTargetId && dep.getTargetId() || dep[toField];
                if (sourceId == from.getId() && targetId == to.getId())  {
                    return this.setCachedResult('areTasksLinkedForward', cacheKey, true);
                }
                
            }
        }
        return this.setCachedResult('areTasksLinkedForward', cacheKey, false);
    },
    /**
     * Returns true if there is a direct dependency between the two tasks. The dependency can be forward (from 1st task to 2nd)
     * or backward (from 2nd to 1st).
     *
     * @param {Gnt.model.Task/Mixed} task1 First task or its id
     * @param {Gnt.model.Task/Mixed} task2 Second task or its id
     *
     * @return {Boolean}
     */
    areTasksLinked: function(task1, task2) {
        var from = task1 instanceof Gnt.model.Task ? task1 : this.getTaskById(task1);
        var to = task2 instanceof Gnt.model.Task ? task2 : this.getTaskById(task2);
        if (!from || !to)  {
            return false;
        }
        
        var cacheKey = from.getId() + '-' + to.getId();
        if (this.isCachedResultAvailable('areTasksLinked', cacheKey)) {
            return this.methodsCache.areTasksLinked[cacheKey];
        }
        return this.setCachedResult('areTasksLinked', cacheKey, this.areTasksLinkedForward(from, to) || this.areTasksLinkedForward(to, from));
    },
    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Gnt.model.Task/String} sourceTask 1st task
     * @param {Gnt.model.Task/String} targetTask 2nd task
     * @return {Gnt.model.Dependency}
     */
    getDependencyForSourceAndTargetTasks: function(sourceTask, targetTask) {
        return this.getDependencyForSourceAndTargetEvents(sourceTask, targetTask);
    },
    /**
     * Returns a dependency model instance linking given tasks if such dependency exists in the store.
     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Gnt.model.Task} sourceEvent
     * @param {Gnt.model.Task} targetEvent
     * @return {Sch.model.Dependency}
     */
    getTasksLinkingDependency: function(sourceEvent, targetEvent) {
        return this.getEventsLinkingDependency(sourceEvent, targetEvent);
    },
    getTaskById: function(id) {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getModelById(id) || null;
    },
    /**
     * Returns the source task of the dependency
     *
     * @param {Gnt.model.Dependency/Mixed} dependency The dependency or its id
     * @return {Gnt.model.Task} The source task of this dependency
     */
    getSourceTask: function(dependency) {
        var id = dependency instanceof Gnt.model.Dependency ? dependency.getSourceId() : dependency;
        return this.getTaskById(id);
    },
    /**
     * Returns the target task of the dependency
     * @param {Gnt.model.Dependency/Mixed} dependency The dependency or its id
     * @return {Gnt.model.Task} The target task of this dependency
     */
    getTargetTask: function(dependency) {
        var id = dependency instanceof Gnt.model.Dependency ? dependency.getTargetId() : dependency;
        return this.getTaskById(id);
    },
    /**
     * Returns the {@link Gnt.data.TaskStore} instance, to which this dependency store is attached.
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.getEventStore();
    },
    /**
     * Sets the associated task store instance.
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        var me = this;
        me.taskStore = store;
        me.setEventStore(store);
    },
    logInvalidDependencies: function() {
        var me = this,
            strictDependencyValidation = me.strictDependencyValidation;
        // enable strictDependencyValidation to catch implicit cyles
        me.strictDependencyValidation = true;
        // iterate all the dependencies and show dependency errors
        me.each(function(d) {
            var error;
            if ((error = me.getDependencyError(d))) {
                var c = console,
                    sourceTask = d.getSourceTask(),
                    targetTask = d.getTargetTask();
                if (sourceTask && targetTask) {
                    c.log(d, error, sourceTask.getName(), targetTask.getName());
                }
            }
        });
        // restore config
        me.strictDependencyValidation = strictDependencyValidation;
    }
});

/**
 * @class Gnt.model.Resource
 *
 * This class represents a single Resource in your gantt chart.
 * The inheritance hierarchy of this class includes {@link Sch.model.Customizable} and {@link Ext.data.Model} classes.
 * Please refer to the documentation of those classes to become familiar with the base interface of this class.
 *
 * If you want to add or change some fields, describing resources - subclass this class:
 *
 *     Ext.define('MyProject.model.Resource', {
 *         extend      : 'Gnt.model.Resource',
 *
 *         fields      : [
 *             // `Id` and `Name` fields are already provided by the superclass
 *             { name: 'Company', type : 'string' }
 *         ],
 *
 *         getCompany : function () {
 *             return this.get('Company')
 *         },
 *         ...
 *     })
 *
 * Any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.
 *
 * See also: {@link Gnt.model.Assignment}, {@link Gnt.column.ResourceAssignment}
 */
Ext.define('Gnt.model.Resource', {
    extend: 'Sch.model.Resource',
    customizableFields: [
        /**
         * @field
         * The resource calendar identifier
         */
        'CalendarId',
        /**
         * @field
         * The resource rate
         */
        {
            name: 'Rate',
            type: 'number',
            defaultValue: 0
        },
        /**
         * @field
         * The resource rate unit (corresponds to units defined in {@link Sch.util.Date}). Valid values are:
         *
         * - "mi" (minutes)
         * - "h" (hours)
         * - "d" (days)
         * - "w" (weeks)
         * - "mo" (months)
         * - "q" (quarters)
         * - "y" (years)
         */
        {
            name: 'RateUnit',
            type: 'string',
            defaultValue: 'h'
        },
        /**
         * @field
         * The value of per-use-cost when this resource is assigned
         */
        {
            name: 'PerUseCost',
            type: 'number',
            defaultValue: 0
        }
    ],
    /**
     * @cfg {String} calendarIdField The name of the field defining the id of the calendar for this specific resource.
     */
    calendarIdField: 'CalendarId',
    /**
     * @cfg {String} rateField The name of the field defining the Rate of this resource.
     */
    rateField: 'Rate',
    /**
     * @cfg {String} rateUnitField The name of the field defining the used RateUnit of this resource.
     */
    rateUnitField: 'RateUnit',
    /**
     * @cfg {String} perUseCostField The name of the field defining the PerUseCost of this resource.
     */
    perUseCostField: 'PerUseCost',
    normalized: false,
    calendarWaitingListener: null,
    isResource: true,
    /**
     * Returns a task store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Gnt.data.TaskStore|null}
     */
    getTaskStore: function() {
        var store = this.store || (this.getTreeStore && this.getTreeStore());
        return store ? store.getTaskStore() : null;
    },
    getEventStore: function() {
        return this.getTaskStore();
    },
    /**
     * @method getRate Returns the set rate for this resource.
     *
     * @return {Number} The rate per unit for this resource
     */
    /**
     * Set the Rate and RateUnit for this resource. Setting a new unit or rate will have influence on the assigned tasks costs when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is set to true.
     *
     * @param {Number} rate
     * @param {String} unit
     */
    setRate: function(rate, unit) {
        if (unit)  {
            this.set(this.rateUnitField, unit);
        }
        
        this.set(this.rateField, rate);
        this.recalculateCost();
    },
    /**
     * @method getRateUnit Returns the RateUnit for this resource.
     *
     * @return {String} The RateUnit for this resource
     */
    /**
     *
     * @param {String} unit Set the RateUnit for this resource. Setting a new unit will have influence on the assigned tasks costs when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is set to true.
     */
    setRateUnit: function(unit) {
        this.set(this.rateUnitField, unit);
        this.recalculateCost();
    },
    /**
     * @method getPerUseCost Returns the PerUseCost for this resource.
     *
     * @return {Number} The PerUseCost for this resource
     */
    /**
     * Set PerUseCost when this resource is assigned to a new task.
     * Setting a new PerUseCost will have influence on the assigned task costs when {@link Gnt.model.Task#autoCalculateCost autoCalculateCost} is set to true.
     *
     * @param {Number} cost
     */
    setPerUseCost: function(cost) {
        this.set(this.perUseCostField, cost);
        this.recalculateCost();
    },
    recalculateCost: function() {
        this.forEachTask(function(task) {
            task.recalculateCost();
        }, this);
    },
    /**
     * Returns an array of tasks associated with this resource
     *
     * @return {Sch.model.Task[]} Associated tasks
     */
    getTasks: function() {
        return this.getEvents();
    },
    /**
     * Returns the calendar, based on which is performed the schedule calculations for associated tasks.
     * It will be either the own calendar of this resource (if any) or the calendar of the whole project.
     *
     * @param {Boolean} ownCalendarOnly Pass `true` to return only own calendar.
     *
     * @return {Gnt.data.Calendar} The instance of calendar
     */
    getCalendar: function(ownCalendarOnly) {
        var me = this;
        return ownCalendarOnly ? me.getOwnCalendar() : me.getOwnCalendar() || me.getProjectCalendar();
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with this resource (if any). See also {@link #calendarIdField}.
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getOwnCalendar: function() {
        var calendarId = this.getCalendarId();
        return calendarId ? Gnt.data.Calendar.getCalendar(calendarId) : null;
    },
    /**
     * Returns the {@link Gnt.data.Calendar calendar} instance, associated with the project of this resource (with the TaskStore instance
     * this resource belongs to).
     *
     * @return {Gnt.data.Calendar} calendar
     */
    getProjectCalendar: function() {
        return this.getTaskStore().getCalendar();
    },
    /**
     * Sets the {@link Gnt.data.Calendar calendar}, associated with this resource. Calendar must have a {@link Gnt.data.Calendar#calendarId calendarId} property
     * defined, which will be saved in the `CalendarId` field of this task.
     *
     * @param {Gnt.data.Calendar/String} calendar A calendar instance or string with calendar id
     */
    setCalendar: function(calendar) {
        var isCalendarInstance = calendar instanceof Gnt.data.Calendar;
        if (isCalendarInstance && !calendar.calendarId)  {
            throw new Error("Can't set calendar w/o `calendarId` property");
        }
        
        this.setCalendarId(isCalendarInstance ? calendar.calendarId : calendar);
    },
    setCalendarId: function(calendarId, isInitial) {
        if (calendarId instanceof Gnt.data.Calendar)  {
            calendarId = calendarId.calendarId;
        }
        
        var prevCalendarId = this.getCalendarId();
        if (prevCalendarId != calendarId || isInitial) {
            if (this.calendarWaitingListener) {
                this.calendarWaitingListener.destroy();
                this.calendarWaitingListener = null;
            }
            var listeners = {
                    calendarchange: this.onCalendarChange,
                    scope: this
                };
            var prevInstance = this.calendar || Gnt.data.Calendar.getCalendar(prevCalendarId);
            // null-ifying the "explicit" property - it should not be used at all generally, only "calendarId"
            this.calendar = null;
            prevInstance && prevInstance.un(listeners);
            this.set(this.calendarIdField, calendarId);
            var calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
            if (calendarInstance) {
                calendarInstance.on(listeners);
                if (!isInitial)  {
                    this.onCalendarChange();
                }
                
            } else {
                this.calendarWaitingListener = Ext.data.StoreManager.on('add', function(index, item, key) {
                    calendarInstance = Gnt.data.Calendar.getCalendar(calendarId);
                    if (calendarInstance) {
                        this.calendarWaitingListener.destroy();
                        this.calendarWaitingListener = null;
                        calendarInstance.on(listeners);
                        this.onCalendarChange();
                    }
                }, this, {
                    destroyable: true
                });
            }
        }
    },
    onCalendarChange: function() {
        // raise flag that the resource is processing its calendar change
        this.inOnCalendarChange = true;
        this.adjustToCalendar();
        this.inOnCalendarChange = false;
    },
    adjustToCalendar: function() {
        this.getTaskStore() && this.forEachTask(function(task) {
            task.adjustToCalendar();
        });
    },
    // TODO: move it to Scheduler codebase
    /**
     * Assigns this resource to a given task. A new {@link Gnt.model.Assignment assignment} will be created
     * and added to the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     * @param {Number} units The value for the "Units" field
     * @param {Function} [callback] Callback function to call after resource has been assigned and possible changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    assignTo: function(taskOrId, units, callback) {
        var task = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getModelById(taskOrId);
        return task.assign(this, units, callback);
    },
    // TODO: move it to Scheduler code base
    /**
     * Un assigns this resource from the given task. The corresponding {@link Gnt.model.Assignment assignment} record
     * will be removed from the {@link Gnt.data.AssignmentStore} of the project.
     *
     * @param {Gnt.model.Task/Number} taskOrId Either instance of {@link Gnt.model.Task} or id of the task
     * @param {Function} [callback] Callback function to call after resource has been unassigned and possible changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    unAssignFrom: function(taskOrId, callback) {
        var task = taskOrId instanceof Gnt.model.Task ? taskOrId : this.getTaskStore().getModelById(taskOrId);
        return task.unAssign(this, callback);
    },
    // TODO: move it to Scheduler codebase
    /**
     * Alias to {@link #unAssignFrom}.
     */
    unassignFrom: function() {
        return this.unAssignFrom.apply(this, arguments);
    },
    // TODO: maybe refactor this method using assignment store map* functions
    // TODO: move it to Scheduler's code base
    /**
     * Iterator for each assignment, associated with this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Assignment assignment} instance
     * as the only argument
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachAssignment: function(func, scope) {
        var me = this,
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore && taskStore.getAssignmentStore(),
            assignments = assignmentStore && assignmentStore.getAssignmentsForResource(me) || [],
            i, len, done;
        scope = scope || this;
        for (done = false , i = 0 , len = assignments.length; !done && i < len; ++i) {
            done = (false === func.call(scope, assignments[i]));
        }
    },
    // TODO: maybe refactor this method using assignment store map* methods
    // TODO: move it to Scheduler's codebase with forEachEvent name
    /**
     * Iterator for tasks, assigned to this resource.
     *
     * @param {Function} func The function to call. This function will receive an {@link Gnt.model.Task task} instance
     * as the only argument.
     *
     * @param {Object} scope The scope to run the function in.
     */
    forEachTask: function(func, scope) {
        var me = this,
            taskStore = me.getTaskStore(),
            assignmentStore = taskStore && taskStore.getAssignmentStore(),
            assignments = assignmentStore && assignmentStore.getAssignmentsForResource(me) || [],
            i, len, done, task;
        scope = scope || this;
        for (done = false , i = 0 , len = assignments.length; !done && i < len; ++i) {
            task = assignments[i].getTask();
            task && (done = (false === func.call(scope, task)));
        }
    },
    collectAvailabilityIntervalPoints: function(intervals, startPoint, endPoint, pointsByTime, pointTimes) {
        for (var k = 0,
            l = intervals.length; k < l; k++) {
            var interval = intervals[k];
            var intervalStartDate = interval.startDate - 0;
            var intervalEndDate = interval.endDate - 0;
            if (!pointsByTime[intervalStartDate]) {
                pointsByTime[intervalStartDate] = [];
                pointTimes.push(intervalStartDate);
            }
            pointsByTime[intervalStartDate].push(startPoint);
            if (!pointsByTime[intervalEndDate]) {
                pointsByTime[intervalEndDate] = [];
                pointTimes.push(intervalEndDate);
            }
            pointsByTime[intervalEndDate].push(endPoint);
        }
    },
    forEachAvailabilityIntervalWithTasks: function(options, func, scope) {
        scope = scope || this;
        var startDate = options.startDate;
        var endDate = options.endDate;
        var targetTask = options.task;
        if (!startDate || !endDate)  {
            throw "Both `startDate` and `endDate` are required for `forEachAvailabilityIntervalWithTasks`";
        }
        
        var cursorDate = new Date(startDate);
        var includeAllIntervals = options.includeAllIntervals;
        var includeResCalIntervals = options.includeResCalIntervals;
        var resourceCalendar = this.getCalendar();
        var assignments = [];
        var tasks = [];
        var tasksCalendars = [];
        var pointTimes = [
                startDate - 0,
                endDate - 0
            ];
        var pointsByTime = {};
        pointsByTime[startDate - 0] = [
            {
                type: '00-intervalStart'
            }
        ];
        pointsByTime[endDate - 0] = [
            {
                type: '00-intervalEnd'
            }
        ];
        this.forEachAssignment(function(assignment) {
            var task = assignment.getTask();
            // filter out non-existing and irrelevant tasks
            if (!task || (targetTask && task !== targetTask))  {
                return;
            }
            
            var taskStart = task.getStartDate();
            var taskEnd = task.getEndDate();
            var taskId = task.getId();
            // filter out tasks out of provided [ startDate, endDate ) interval
            if (taskStart > endDate || taskEnd < startDate)  {
                return;
            }
            
            tasks.push(task);
            // We use the resource calendar if task has no an assigned calendar
            // Since we have to use resource calendar only in this case (project calendar should not be taken into account)
            tasksCalendars.push(task.getOwnCalendar() || this.getCalendar());
            // if task is segmented then segments start/end dates are points of interest
            if (task.isSegmented()) {
                for (var taskSegments = task.getSegments(),
                    i = 0,
                    l = taskSegments.length; i < l; i++) {
                    var segment = taskSegments[i];
                    this.collectAvailabilityIntervalPoints([
                        {
                            startDate: segment.getStartDate(),
                            endDate: segment.getEndDate()
                        }
                    ], {
                        type: '05-taskStart',
                        assignment: assignment,
                        taskId: taskId,
                        units: assignment.getUnits()
                    }, {
                        type: '04-taskEnd',
                        taskId: taskId
                    }, pointsByTime, pointTimes);
                }
            } else // task start/end dates are points of interest
            {
                this.collectAvailabilityIntervalPoints([
                    {
                        startDate: taskStart,
                        endDate: taskEnd
                    }
                ], {
                    type: '05-taskStart',
                    assignment: assignment,
                    taskId: taskId,
                    units: assignment.getUnits()
                }, {
                    type: '04-taskEnd',
                    taskId: taskId
                }, pointsByTime, pointTimes);
            }
            assignments.push(assignment);
        });
        // if there are no tasks - then there are no common intervals naturally
        if (!tasks.length && !includeAllIntervals && !includeResCalIntervals)  {
            return;
        }
        
        var DATE = Sch.util.Date;
        var i, l, taskId;
        while (cursorDate < endDate) {
            this.collectAvailabilityIntervalPoints(resourceCalendar.getAvailabilityIntervalsFor(cursorDate), {
                type: '00-resourceAvailabilityStart'
            }, {
                type: '01-resourceAvailabilityEnd'
            }, pointsByTime, pointTimes);
            // using "for" instead of "each" should be blazing fast! :)
            for (i = 0 , l = tasksCalendars.length; i < l; i++) {
                taskId = tasks[i].getId();
                // resource specific calendar point
                this.collectAvailabilityIntervalPoints(tasksCalendars[i].getAvailabilityIntervalsFor(cursorDate), {
                    type: '02-taskAvailabilityStart',
                    taskId: taskId
                }, {
                    type: '03-taskAvailabilityEnd',
                    taskId: taskId
                }, pointsByTime, pointTimes);
            }
            // does not perform cloning internally!
            cursorDate = DATE.getStartOfNextDay(cursorDate);
        }
        // Numerical sort, can't use default JS sort
        // we have to define a sorting function here since there is a bug in Chrome
        // which affects large arrays sorting if you don't provide a sorting function (#1365)
        pointTimes.sort(function(a, b) {
            return a - b;
        });
        var inInterval = false,
            inResource = false,
            currentAssignments = {},
            inTaskCalendar = 0,
            inTask = 0;
        var inTaskCalendarHash = {};
        for (i = 0 , l = pointTimes.length - 1; i < l; i++) {
            var points = pointsByTime[pointTimes[i]];
            points.sort(function(a, b) {
                return a.type < b.type ? 1 : -1;
            });
            for (var k = 0,
                j = points.length; k < j; k++) {
                var point = points[k];
                switch (point.type) {
                    case '00-resourceAvailabilityStart':
                        inResource = true;
                        break;
                    case '01-resourceAvailabilityEnd':
                        inResource = false;
                        break;
                    case '02-taskAvailabilityStart':
                        inTaskCalendar++;
                        inTaskCalendarHash[point.taskId] = true;
                        break;
                    case '03-taskAvailabilityEnd':
                        inTaskCalendar--;
                        delete inTaskCalendarHash[point.taskId];
                        break;
                    case '05-taskStart':
                        currentAssignments[point.taskId] = point;
                        inTask++;
                        break;
                    case '04-taskEnd':
                        delete currentAssignments[point.taskId];
                        inTask--;
                        break;
                    case '00-intervalStart':
                        inInterval = true;
                        break;
                    case '00-intervalEnd':
                        return;
                }
            }
            if (inInterval && (includeAllIntervals || includeResCalIntervals && inResource || inResource && inTaskCalendar && inTask)) {
                var meta = {
                        inResourceCalendar: inResource,
                        inTasksCalendar: !!inTaskCalendar,
                        inTask: inTask,
                        inTaskCalendarHash: Ext.apply({}, inTaskCalendarHash)
                    };
                var intervalStartDate = pointTimes[i];
                var intervalEndDate = pointTimes[i + 1];
                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate > endDate || intervalEndDate < startDate)  {
                    
                    continue;
                }
                
                if (intervalStartDate < startDate)  {
                    intervalStartDate = startDate - 0;
                }
                
                if (intervalEndDate > endDate)  {
                    intervalEndDate = endDate - 0;
                }
                
                if (func.call(scope, intervalStartDate, intervalEndDate, currentAssignments, meta) === false)  {
                    return false;
                }
                
            }
        }
    },
    /**
     * This method will generate a report about the resource allocation in the given timeframe.
     * The start and end dates of the timeframe are provided as the "startDate/endDate" properties of the `options` parameter.
     * Options may also contain additional property: `includeAllIntervals` which includes the intervals w/o any
     * assignments in the ouput (see the example below).
     *
     * For example, this resource `R1` has the availability from 10:00 till 17:00 on 2012/06/01 and from 12:00 till 15:00 on 2012/06/02.
     * It is also assigned on 50% to two tasks:
     *
     * - `T1` has availability from 11:00 till 16:00 on 2012/06/01 and from 13:00 till 17:00 on 2012/06/02.
     *   It starts at 11:00 2012/06/01 and ends at 17:00 2012/06/02
     * - `T2` has availability from 15:00 till 19:00 on 2012/06/01 and from 09:00 till 14:00 on 2012/06/02.
     *   It starts at 15:00 2012/06/01 and ends at 14:00 2012/06/02
     *
     * So the allocation information for the period 2012/06/01 - 2012/06/03 (note the 03 in day - it means 2012/06/02 inclusive)
     * will looks like the following (to better understand this example you might want to draw all the information on paper):
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        {
            startDate           : new Date(2012, 5, 1, 15),
            endDate             : new Date(2012, 5, 1, 16),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 1, 16),
            endDate             : new Date(2012, 5, 1, 17),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 12),
            endDate             : new Date(2012, 5, 2, 13),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask2 ],
            assignmentsHash     : { 'T2' : assignmentForTask2 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 13),
            endDate             : new Date(2012, 5, 2, 14),
            totalAllocation     : 100,
            assignments         : [ assignmentForTask1, assignmentForTask2 ],
            assignmentsHash     : {
                'T1' : assignmentForTask1,
                'T2' : assignmentForTask2
            },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 2
        },
        {
            startDate           : new Date(2012, 5, 2, 14),
            endDate             : new Date(2012, 5, 2, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 },
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
    ]

     *
     * As you can see its quite detailed information - every distinct timeframe is included in the report.
     * You can aggregate this information as you need.
     *
     * Setting the `includeAllIntervals` option to true, will include intervals w/o assignments in the report, so the in the
     * example above, the report will start with:
     *

    [
        {
            startDate           : new Date(2012, 5, 1, 00),
            endDate             : new Date(2012, 5, 1, 10),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : false,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 10),
            endDate             : new Date(2012, 5, 1, 11),
            totalAllocation     : 0,
            assignments         : [],
            assignmentsHash     : {},
            inResourceCalendar  : true,
            inTasksCalendar     : false,
            inTask              : 0
        },
        {
            startDate           : new Date(2012, 5, 1, 11),
            endDate             : new Date(2012, 5, 1, 15),
            totalAllocation     : 50,
            assignments         : [ assignmentForTask1 ],
            assignmentsHash     : { 'T1' : assignmentForTask1 }
            inResourceCalendar  : true,
            inTasksCalendar     : true,
            inTask              : 1
        },
        ...
    ]


     *
     * @param {Object} options Object with the following properties:
     *
     * - "startDate" - start date for the report timeframe
     * - "endDate" - end date for the report timeframe
     * - "includeAllIntervals" - whether to include the intervals w/o assignments in the report
     * - "includeResCalIntervals" - whether to include the intervals of resource calendar in the report
     * - "task" - (optional) Only return allocation data relating to a certain task
     */
    getAllocationInfo: function(options) {
        var info = [];
        this.forEachAvailabilityIntervalWithTasks(options, function(intervalStartDate, intervalEndDate, intervalAssignments, meta) {
            var effectiveTotalAllocation = 0,
                effectiveAssignments = [],
                effectiveAssignmentsHash = {},
                totalAllocation = 0,
                assignments = [],
                assignmentsHash = {},
                durationMS = intervalEndDate - intervalStartDate,
                allocationMS = 0;
            if (meta.inResourceCalendar && meta.inTasksCalendar && meta.inTask) {
                // loop over all the unfinished (on this period of time) resource assignments
                for (var i in intervalAssignments) {
                    // if this task is running in the interval
                    if (meta.inTaskCalendarHash[i]) {
                        // calculate allocation (in milliseconds)
                        allocationMS += durationMS * intervalAssignments[i].units * 0.01;
                        // calculate "effective" total allocation % (by running tasks only)
                        effectiveTotalAllocation += intervalAssignments[i].units;
                        // put it into array / hash of running tasks
                        effectiveAssignmentsHash[i] = intervalAssignments[i].assignment;
                        effectiveAssignments.push(intervalAssignments[i].assignment);
                    }
                    // keep sum of allocation % for all the not finished tasks
                    // (regardless of which task is been handled in this interval)
                    totalAllocation += intervalAssignments[i].units;
                    // array / hash of ongoing tasks
                    assignmentsHash[i] = intervalAssignments[i].assignment;
                    assignments.push(intervalAssignments[i].assignment);
                }
            }
            info.push(Ext.apply({
                startDate: new Date(intervalStartDate),
                endDate: new Date(intervalEndDate),
                effectiveTotalAllocation: effectiveTotalAllocation,
                effectiveAssignmentsHash: effectiveAssignmentsHash,
                effectiveAssignments: effectiveAssignments,
                totalAllocationMS: allocationMS,
                totalAllocation: totalAllocation,
                assignments: assignments,
                assignmentsHash: assignmentsHash
            }, meta));
        });
        return info;
    },
    /**
     * Returns resource utilization info for the given time span.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Number} underUtilizationThreshold
     * @param {Number} overUtilizationThreshold
     *
     * @return {Object}  info
     * @return {Number}  info.allocationMs
     * @return {Number}  info.allocationDeltaMs,
     * @return {Boolean} info.isOverallocated
     * @return {Boolean} info.isUnderallocated
     * @return {Number}  info.resourceAvailabilityMs,
     * @return {Object}  info.assignmentInfo   Assignment utilization information keyed by assignment id
     * @return {Object}  info.taskInfo         Assignment utilization information keyed by task id
     */
    getUtilizationInfo: function(startDate, endDate, underUtilizationThreshold, overUtilizationThreshold) {
        var me = this,
            amountMs = 0,
            isOverallocated = false,
            isUnderallocated = false,
            assignmentInfo = {},
            taskInfo = {};
        if (arguments.length < 3) {
            underUtilizationThreshold = overUtilizationThreshold = 100;
        }
        // get resource allocation report (array of intervals)
        var allocationIntervals = me.getAllocationInfo({
                // include not only allocated intervals but also availability intervals defined by the resource calendar
                // to be able to detect resource under-allocation properly
                includeResCalIntervals: true,
                startDate: startDate,
                endDate: endDate
            });
        Ext.Array.each(allocationIntervals, function(intervalInfo) {
            amountMs += intervalInfo.totalAllocationMS;
            if (intervalInfo.effectiveTotalAllocation > overUtilizationThreshold) {
                isOverallocated = true;
                isUnderallocated = false;
            } else if (!isOverallocated && intervalInfo.effectiveTotalAllocation < underUtilizationThreshold) {
                isUnderallocated = true;
            }
            // loop over individual assignments to have allocationMs/isOverallocated/isUnderallocated per each assignment
            Ext.Array.each(intervalInfo.effectiveAssignments, function(assignment) {
                var assignmentId = assignment.getId(),
                    taskId = assignment.getTaskId(),
                    assignmentUnits = assignment.getUnits(),
                    allocationMs = Math.floor((intervalInfo.endDate - intervalInfo.startDate) * assignmentUnits / 100),
                    allocationDeltaMs = 0,
                    isOverallocated = assignmentUnits > overUtilizationThreshold,
                    isUnderallocated = assignmentUnits < underUtilizationThreshold,
                    assignmentUtilization;
                // if the assignment counters already started increment them
                if (assignmentInfo[assignmentId]) {
                    assignmentUtilization = assignmentInfo[assignmentId];
                    assignmentUtilization.allocationMs += allocationMs;
                    assignmentUtilization.allocationDeltaMs += allocationDeltaMs;
                    assignmentUtilization.isOverallocated = assignmentUtilization.isOverallocated || isOverallocated;
                    assignmentUtilization.isUnderallocated = assignmentUtilization.isUnderallocated || isUnderallocated;
                } else // init the assignment counters
                {
                    assignmentUtilization = {
                        isUtilized: true,
                        allocationMs: allocationMs,
                        allocationDeltaMs: allocationDeltaMs,
                        isOverallocated: isOverallocated,
                        isUnderallocated: isUnderallocated
                    };
                    assignmentInfo[assignmentId] = assignmentUtilization;
                    taskInfo[taskId] = assignmentUtilization;
                }
            });
        });
        return {
            isUtilized: amountMs > 0,
            allocationMs: amountMs,
            allocationDeltaMs: 0,
            isOverallocated: isOverallocated,
            isUnderallocated: isUnderallocated,
            // individual assignments utilization info
            assignmentInfo: assignmentInfo,
            taskInfo: taskInfo
        };
    }
});

Ext.define('Gnt.data.mixin.ResourceStore', {
    extend: 'Ext.Mixin',
    taskStore: null,
    mixinConfig: {
        after: {
            constructor: 'constructor'
        }
    },
    constructor: function() {
        this.on(this.getStoreListeners());
    },
    getStoreListeners: function() {
        return {
            load: this.normalizeResources,
            remove: this.onResourceRemoved,
            clear: this.onResourceStoreClear,
            // Our internal listeners should be ran before any client listeners
            priority: 100
        };
    },
    normalizeResources: function() {
        // scan through all resources and re-assign the "calendarId" property to get the listeners in place
        this.each(function(resource) {
            if (!resource.normalized) {
                var calendarId = resource.getCalendarId();
                if (calendarId)  {
                    resource.setCalendarId(calendarId, true);
                }
                
                resource.normalized = true;
            }
        });
    },
    // Performance optimization possibility: Assignment store datachange will cause a full refresh
    // so removing a resource will currently cause 2 refreshes. Not critical since this is not a very common use case
    onResourceRemoved: function(store, resources) {
        var assignmentStore = this.getAssignmentStore();
        Ext.Array.each(resources, function(resource) {
            assignmentStore.removeAssignmentsForResource(resource);
        });
    },
    onResourceStoreClear: function() {
        this.getAssignmentStore().removeAll();
    },
    /**
     * Returns the associated task store instance.
     *
     * @return {Gnt.data.TaskStore|null}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    /**
     * Sets associated task store instance
     *
     * @param {Gnt.data.TaskStore} store
     */
    setTaskStore: function(store) {
        this.taskStore = store;
    },
    /**
     * Returns the associated assignment store instance.
     *
     * @return {Gnt.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getAssignmentStore() || null;
    },
    /**
     * Returns the associated dependency store
     *
     * @return {Gnt.data.DependencyStore|null}
     */
    getDependencyStore: function() {
        var taskStore = this.getTaskStore();
        return taskStore && taskStore.getDependencyStore() || null;
    }
});

/**
@class Gnt.data.ResourceStore
@extends Sch.data.ResourceStore

A class representing the collection of the resources - {@link Gnt.model.Resource} records.

*/
Ext.define('Gnt.data.ResourceStore', {
    requires: [
        'Gnt.model.Resource'
    ],
    mixins: [
        'Gnt.data.mixin.ResourceStore'
    ],
    extend: 'Sch.data.ResourceStore',
    storeId: 'resources',
    model: 'Gnt.model.Resource',
    alias: 'store.gantt_resourcestore'
});
/**
     * @property {Gnt.data.TaskStore} taskStore The task store to which this resource store is associated.
     * Usually is configured automatically, by the task store itself.
     */

// https://app.assembla.com/spaces/bryntum/tickets/9503-task-not-marked-as-modified-after-node-reordering/details#
Ext.define('Gnt.patches.NodeInterface', {
    extend: 'Sch.util.Patch',
    target: 'Gnt.model.Task',
    overrides: {
        /**
         * Updates general data of this node like isFirst, isLast, depth. This
         * method is internally called after a node is moved. This shouldn't
         * have to be called by the developer unless they are creating custom
         * Tree plugins.
         * @protected
         * @param {Boolean} commit
         * @param {Object} info The info to update. May contain any of the following
         *  @param {Object} info.isFirst
         *  @param {Object} info.isLast
         *  @param {Object} info.index
         *  @param {Object} info.depth
         *  @param {Object} info.parentId
         *  @return {String[]} The names of any persistent fields that were modified.
         */
        updateInfo: function(commit, info) {
            if (commit && typeof commit !== 'boolean') {
                commit = commit.commit;
            }
            return this.callParent([
                commit,
                info
            ]);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?301768-Tree-view-is-rendered-before-load-event-is-thrown
// In Ext 5.1.1 tree view is refreshed before its store throw 'load' event.
// Only reliable way to process loaded data before that refresh is to listen 'refresh' event after store.load method in called
// This patch requires to be a mixin, to be required correctly in the task store
Ext.define('Gnt.patches.TaskStore', {
    extend: 'Ext.Mixin',
    onClassMixedIn: function(targetClass) {
        Ext.override(targetClass, {
            // This is new handler for 'load' event that will check if caching procedures were performed before
            // and also it will remove extra listener
            onTasksLoad: function() {
                if (!this._refreshCalled) {
                    this.onTasksLoaded();
                }
                this.un('refresh', this.onTaskStoreRefresh, this);
            },
            onTasksBeforeLoad: function() {
                // if this is a reload operation, view will be refreshed before 'load' event is fired
                // we need to recalculate cache on 'refresh' event then
                this._refreshCalled = false;
                // There's a sencha listener to refresh view, with priority of 1000, we need to prepare data before that
                // so we make priority a little bit more. Covered by 200_view
                this.on('refresh', this.onTaskStoreRefresh, this, {
                    priority: 1001
                });
            },
            // Fill cache, rise a flag about this
            onTaskStoreRefresh: function() {
                // Refresh can be called twice (6.0.2), we need to restore listeners only once
                // https://www.sencha.com/forum/showthread.php?310964-TreeStore-fires-refresh-twice-during-load
                if (!this._refreshCalled) {
                    this._refreshCalled = true;
                    this.onTasksLoaded();
                }
            },
            setupListeners: function() {
                this.callParent(arguments);
                this.on('beforeload', this.onTasksBeforeLoad, this, {
                    priority: 100
                });
                // these events need advanced listener that will check if cache has to be recalculated
                this.un({
                    load: this.onTasksLoaded,
                    rootchanged: this.onTasksLoaded,
                    scope: this
                });
                this.on({
                    load: this.onTasksLoad,
                    rootchanged: this.onTasksLoad,
                    scope: this
                });
            }
        });
    }
});

/*

 Overrides to detect and save task segments state before any editing takes place
 The flow is as follows:

 1. taskStore.onSegmentEditBegin() is called
 2. We serialize and save current segments on the Task
 3. Any following change to segments from here on
 4. At some point later 'processSavingOldValue' is called as a result of the 'update' event fired
 5. The Undo action now has a reliable before-edit copy of all segment data for the Task
 6a. If no undo manager active: State cache cleared in onSegmentEditEnd
 6b. If undo manager active : State cache cleared in onUndoRedoTransactionEnd
 */
Ext.define('Gnt.data.undoredo.mixin.TaskStoreHint', {
    extend: 'Robo.data.Store',
    segmentsStateByTaskId: null,
    onSegmentEditBegin: function(task, segment) {},
    // var me = this;
    // this.segmentsStateByTaskId = this.segmentsStateByTaskId || {};
    // // Before any editing takes place of a segment, store the original
    // if (!this.segmentsStateByTaskId.hasOwnProperty(task.internalId)) {
    //     this.segmentsStateByTaskId[task.internalId] = task.buildSegmentsSnapshot();
    // }
    onSegmentEditEnd: function(task, segment) {},
    // var me = this;
    // if (!me.isInUndoRedoTransaction()) {
    //     delete this.segmentsStateByTaskId[task.internalId];
    // }
    onUndoRedoTransactionEnd: function(manager, transaction) {
        var me = this;
        // // After a transaction is completed, clear the cached data
        // this.segmentsStateByTaskId = null;
        me.callParent([
            manager,
            transaction
        ]);
    },
    getOriginalSegmentsState: function(task) {
        var segmentsSnapshot = task.getLastSegmentsSnapshot();
        //this.segmentsStateByTaskId && this.segmentsStateByTaskId[ task.internalId ];
        // ..or from standard "previous"/"previousValues" hashes (this might happen when generic model.set("Segments", ...) was used
        // instead of higher level methods like "split", "setSegments" etc
        if (!segmentsSnapshot) {
            var previousSegments = (task.previous || task.previousValues)[task.segmentsField];
            if (previousSegments) {
                segmentsSnapshot = task.buildSegmentsSnapshot(previousSegments);
            }
        }
        return segmentsSnapshot;
    }
});

/**
 * The mixin adds transaction alike functionality into a store, works in pair with {@link Gnt.model.mixin.ProjectableModel}
 * if you mix-in this one into a store make sure you mixin in {@link Gnt.model.mixin.ProjectableModel} into store's
 * model class as well.
 *
 * NOTE: only model updates are included into a transaction, record adding/removing are not taken into account,
 * that's why it's called "projection".
 */
Ext.define('Gnt.data.mixin.ProjectableStore', function() {
    function getByInternalId(store, id) {
        return store.byInternalIdMap && store.byInternalIdMap[id] || store.getByInternalId(id);
    }
    /**
     * @private
     * @method getProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjection() {
        var me = this,
            projectionStack = me.projectionStack;
        return projectionStack && projectionStack[projectionStack.length - 1];
    }
    /**
     * @private
     * @method getProjectionLevel
     * @member Gnt.data.mixin.ProjectableStore
     */
    function getProjectionLevel() {
        var me = this,
            projectionStack = me.projectionStack;
        return projectionStack && projectionStack.length || 0;
    }
    /**
     * Checks if a store is currently projecting
     *
     * @return {Boolean}
     * @method isProjecting
     * @member Gnt.data.mixin.ProjectableStore
     */
    function isProjecting() {
        return this.getProjectionLevel() > 0;
    }
    /**
     * Checks whether any of given records are projected currently, i.e. any of given records has changes in current
     * projection.
     *
     * @param {Ext.data.Model/[Ext.data.Model]} records
     * @return boolean
     */
    function areProjected(records) {
        var i, len, are;
        records = [].concat(records);
        for (are = false , i = 0 , len = records.length; !are && i < len; i++) {
            are = records[i].isProjected();
        }
        return are;
    }
    /**
      * Starts store's projection, any updates to any records during projection period will be put into a projection
      * storage and might be committed into record's data by calling {@link Gnt.data.mixin.ProjectableStore#commitProjection} or
      * canceled by calling {@link Gnt.data.mixin.ProjectableStore#rejectProjection}. The primary condition for this
      * to work is that store's records must use {#link Gnt.model.mixin.ProjectableModel} mixin. Projections
      * might be nested.
      *
      * @method startProjection
      * @member Gnt.data.mixin.ProjectableStore
      */
    function startProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            newProjection, prevProjection;
        if (!projectionStack) {
            me.projectionStack = [
                {}
            ];
        } else {
            prevProjection = projectionStack[projectionStack.length - 1];
            newProjection = {};
            Ext.Object.each(prevProjection, function(id, data) {
                var dataConstructor = function() {};
                dataConstructor.prototype = data;
                newProjection[id] = new dataConstructor();
            });
            projectionStack.push(newProjection);
        }
        me.fireEvent('projectionstart', me, me.getProjectionLevel());
    }
    /**
     * Commits all the changes recorded since last call to {@link #startProjection}..
     *
     * @method commitProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function commitProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            projectionData, committingData,
            modifiedData = {},
            prop, data, hasUpdates, internalId, record;
        // If projection level is 0 then committing recorded updates into corresponding store's records.
        if (projectionStack.length === 1) {
            committingData = projectionStack[0];
            me.projectionStack = null;
            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {
                    record = getByInternalId(me, internalId);
                    // Record might have been deleted from the store during projection time
                    if (record) {
                        data = committingData[internalId];
                        hasUpdates = false;
                        for (prop in data) {
                            if (data.hasOwnProperty(prop)) {
                                hasUpdates = true;
                                break;
                            }
                        }
                        if (hasUpdates) {
                            modifiedData[internalId] = record.set(data);
                        }
                    }
                }
            }
        } else // If projection level is higher then copying current projection into lower level (previous) projection
        {
            committingData = projectionStack.pop();
            projectionData = projectionStack[projectionStack.length - 1];
            for (internalId in committingData) {
                if (committingData.hasOwnProperty(internalId)) {
                    if (!projectionData.hasOwnProperty(internalId)) {
                        projectionData[internalId] = committingData[internalId];
                    } else {
                        projectionData[internalId] = Ext.apply(projectionData[internalId], committingData[internalId]);
                    }
                }
            }
        }
        me.fireEvent('projectioncommit', me, projectionStack && projectionStack[projectionStack.length - 1], committingData, me.getProjectionLevel());
        return modifiedData;
    }
    /**
     * Rejects all the changes to store's records recorded since projection last call to {@link #startProjection}.
     *
     * @method rejectProjection
     * @member Gnt.data.mixin.ProjectableStore
     */
    function rejectProjection() {
        var me = this,
            projectionStack = me.projectionStack,
            projectionData = projectionStack.pop();
        // If projection level was 1 (and now 0) then simply getting rid of projection stack
        if (projectionStack.length === 0) {
            me.projectionStack = null;
        }
        // If projection level is higher then we've got rid of changes recorded since last startProjection() call
        // by simply popping the last projection state from the projection stack.
        me.fireEvent('projectionreject', me, projectionStack && projectionStack[projectionStack.length - 1], projectionData, me.getProjectionLevel());
    }
    return {
        projectionStack: null,
        getProjection: getProjection,
        isProjecting: isProjecting,
        areProjected: areProjected,
        getProjectionLevel: getProjectionLevel,
        startProjection: startProjection,
        commitProjection: commitProjection,
        rejectProjection: rejectProjection
    };
});

/**
 * @private
 * @experimental
 * The mixin adds support for grouping the task store by either a TaskModel field name or a custom function.
 *
 * **NOTE:** Grouping while filtering is not supported, so using the grouping feature resets filters.
 */
Ext.define('Gnt.data.mixin.Groupable', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        after: {
            constructor: 'afterConstructor'
        }
    },
    currentGroupField: null,
    originalTree: null,
    fieldsToIgnore: null,
    realCommitFn: null,
    // Old state of certain tree structure data fields that we modify in grouping mode
    oldFieldPersistStates: null,
    // Flat array of all parent nodes in the original taskstore before grouping
    savedParentNodes: null,
    /**
     * @return {Boolean} True if tree is grouped, and false otherwise
     */
    isTreeGrouped: function() {
        return !!this.getTreeGroupField();
    },
    /**
     * @return {String} A field name by which the store is grouped by, or `null` if it's not grouped
     */
    getTreeGroupField: function() {
        return this.currentGroupField;
    },
    afterConstructor: function() {
        var model = this.getModel();
        this.oldFieldPersistStates = {};
        this.realCommitFn = model.prototype.commit;
        this.fieldsToIgnore = [
            'index',
            this.parentIdProperty || 'parentId',
            model.prototype.phantomParentIdField
        ];
        // Save initial persist settings to certain tree structure fields
        Ext.Array.forEach(this.fieldsToIgnore, function(field) {
            this.oldFieldPersistStates[field] = model.getField(field).persist;
        }, this);
    },
    /**
     * Groups tasks by the provided field name or a function or resets grouping if empty value is provided.
     * @param {String/Function} [fieldName] A field name or a function to group tasks by.
     *
     * ```javascript
     *     // let's group task store records by duration field values
     *     taskStore.groupBy('Duration');
     * ```
     *
     * If a function is provided it accepts a task as the only argument and grouping is done by its returning
     * value:
     *
     * ```javascript
     *     // let's get tasks grouped by their complete/incomplete status
     *     taskStore.groupBy(function (task) {
     *         return task.isComplete();
     *     });
     * ```
     *
     * Pass falsy value to clear grouping:
     *
     * ```javascript
     *     // let's reset grouping
     *     taskStore.groupBy();
     * ```
     *
     * @return {Boolean} `false` if no grouping can be performed for the field.
     */
    groupBy: function(fieldName) {
        // The node to group
        var node = this.getRoot();
        if (this.currentGroupField !== fieldName) {
            if (fieldName) {
                // Grouping while filtering is not supported
                this.clearTreeFilter();
                // Store/model modifications, undone when store is ungrouped
                this.applyStoreAndModelOverrides();
                var groups = this.groupNodeByFieldName(node, fieldName);
                // If no leaf tasks exists, just return - nothing to group
                if (groups.length === 0) {
                    this.revertStoreAndModelOverrides();
                    return false;
                }
                this.currentGroupField = fieldName;
                this.beforeTreeRestructuring();
                this.disableCommitFn();
                node.removeAll();
                node.appendChild(groups, true, false);
                this.enableCommitFn();
                this.protectGroupNodes(node);
                this.afterTreeRestructuring();
            } else if (this.isTreeGrouped()) {
                this.restoreTreeStructure();
            }
        }
    },
    protectGroupNodes: function(node) {
        // Make sure any group nodes are not considered dirty in case a store sync is performed
        Ext.Array.forEach(node.childNodes, function(group) {
            // If user deletes all children of a group node, it should stay a group
            group.convertEmptyParentToLeaf = false;
            // Group nodes should aggregate child node values
            group.refreshCalculatedParentNodeData();
            // Group nodes should never trigger a store sync, nor be marked as dirty in the UI
            group.commit(true);
        });
    },
    /**
     * Clears grouping
     */
    clearGroup: function() {
        this.groupBy();
    },
    sortGroups: function(groups, fieldName) {
        var model = this.getModel();
        var sorter;
        if (typeof fieldName === 'string') {
            var field = model.getField(fieldName);
            sorter = function(group1, group2) {
                // Put No value group at the top
                if (group1._GroupValue_ === '_novalue_')  {
                    return -1;
                }
                
                if (group2._GroupValue_ === '_novalue_')  {
                    return 1;
                }
                
                // Let the field decide how to sort values
                return field.collate(group1._GroupValue_, group2._GroupValue_);
            };
        } else {
            // Sort based on the raw _GroupValue_
            sorter = function(group1, group2) {
                // Put No value group at the top
                if (group1._GroupValue_ === '_novalue_')  {
                    return -1;
                }
                
                if (group2._GroupValue_ === '_novalue_')  {
                    return 1;
                }
                
                return group1._GroupValue_ < group2._GroupValue_ ? -1 : 1;
            };
        }
        return groups.sort(sorter);
    },
    disableCommitFn: function() {
        // HACK: Ext will commit nodes as they are appended into another treenode, we need to prevent this
        var model = this.getModel();
        model.prototype.commit = Ext.emptyFn;
    },
    enableCommitFn: function() {
        this.getModel().prototype.commit = this.realCommitFn;
    },
    applyStoreAndModelOverrides: function() {
        var model = this.getModel();
        // HACK: We need to also look in the original tree for any parent nodes which are not part of the grouped tree structure
        // This is required when rendering for example predecessor column, if a leaf task predecessor has a link to a parent task (not part
        // of the grouped store)
        this.getModelById = function(id) {
            return this.self.prototype.getModelById.call(this, id) || this.savedParentNodes[id];
        };
        Ext.Array.forEach(this.fieldsToIgnore, function(field) {
            model.getField(field).persist = false;
        });
    },
    revertStoreAndModelOverrides: function() {
        var model = this.getModel();
        delete this.getModelById;
        // Restore old persist settings to certain tree structure fields
        Ext.Object.each(this.oldFieldPersistStates, function(field, value) {
            model.getField(field).persist = value;
        });
    },
    beforeTreeRestructuring: function() {
        // While rebuilding the tree we should not recalculate any parents, due to nodes being removed
        this.suspendAutoRecalculateParents++;
        // Need to keep our own saved copy of the removed records as it may be modified by tree operations
        this.__removedNodes = this.getRemovedRecords().slice();
        // Prevent any events to fire, triggering sync on any stores etc
        this.suspendEvents();
        // Prevent dependencies from being removed during restructuring
        this.setDependencyStore(new Gnt.data.DependencyStore({
            oldStore: this.getDependencyStore()
        }));
    },
    afterTreeRestructuring: function() {
        this.suspendAutoRecalculateParents--;
        this.resumeEvents();
        this.setDependencyStore(this.getDependencyStore().oldStore);
        // HACK need to reset removed records
        this.removedNodes = this.__removedNodes;
        this.__removedNodes = null;
        // Let the world know, so the view can be updated
        this.fireEvent('refresh');
    },
    getGroupTaskConfig: function(groupValue, rawValue, child) {
        var modelPrototype = this.getModel().prototype;
        var result = {
                _GroupValue_: groupValue,
                _RawValue_: rawValue,
                expanded: true
            };
        result[modelPrototype.idProperty] = '-group-' + groupValue;
        result[modelPrototype.nameField] = rawValue;
        result[modelPrototype.draggableField] = false;
        result[modelPrototype.resizableField] = false;
        if (child) {
            result.children = [
                child
            ];
        }
        return result;
    },
    // Creates an array of new group nodes containing the children matching the passed fieldName.
    // Also, this method save the full tree structure of all parent nodes to be able to recreate the original tree
    groupNodeByFieldName: function(rootNode, fieldName) {
        this.savedParentNodes = this.savedParentNodes || {};
        var me = this,
            groupTasks = {},
            isString = typeof fieldName === 'string',
            savedParentNodes = me.savedParentNodes,
            isStoreGrouped = me.isTreeGrouped();
        rootNode.cascadeBy(function(task) {
            // we group only leaf tasks
            if (task.isLeaf()) {
                var groupValue = isString ? task.getGroupValue(fieldName) : fieldName.call(me, task);
                var value = isString ? task.get(fieldName) : groupValue;
                if (value == null || value === '')  {
                    groupValue = '_novalue_';
                }
                
                var groupNode = groupTasks[groupValue];
                // if no such group made yet
                if (!groupNode) {
                    groupTasks[groupValue] = me.getGroupTaskConfig(groupValue, value, task);
                } else // add the task to existing group
                {
                    groupNode.children.push(task);
                }
            }
            // summary tasks we just backup to restore when grouping is reset
            else if (!isStoreGrouped) {
                if (!task.isRoot()) {
                    savedParentNodes[task.id] = task;
                }
                // Save old value so we can restore it
                task.__convertEmptyParentToLeaf = task.convertEmptyParentToLeaf;
                // Prevent store from reacting to 'leaf' flag changing state
                task.convertEmptyParentToLeaf = false;
                // Save a reference to the original childNodes array
                task.__children = task.childNodes.slice();
            }
        });
        if (!isStoreGrouped && Ext.Object.getKeys(groupTasks).length > 0) {
            me.beforeTreeRestructuring();
            //This creates a new full tree, all nodes are removed from "this" store after this line.
            //The leaf tasks will be automatically removed from when creating the grouped tree structure
            me.originalTree = new Ext.data.TreeModel({
                children: rootNode.childNodes.slice()
            });
            me.afterTreeRestructuring();
            // Save a shallow copy of the root children too
            me.originalTree.__children = rootNode.childNodes.slice();
        }
        // Convert to an array of groups, then sort
        groupTasks = me.sortGroups(Ext.Object.getValues(groupTasks), fieldName);
        return groupTasks;
    },
    restoreTreeStructure: function() {
        var clonedRoot = this.originalTree;
        var removedNodes = this.getRemovedRecords().slice();
        var newNodes = this.getNewRecords();
        this.beforeTreeRestructuring();
        function reducer(result, record) {
            if (record.phantom) {
                // if record is phantom check if it is still present in new nodes array
                if (Ext.Array.indexOf(newNodes, record) !== -1) {
                    result.push(record);
                }
            } else if (record.get('_GroupValue_') == null && Ext.Array.indexOf(removedNodes, record) === -1) {
                result.push(record);
            }
            return result;
        }
        // Put all the child nodes back in the empty parents of the cloned tree
        Ext.Array.forEach(Ext.Object.getValues(this.savedParentNodes), function(parentTask) {
            // Also need to respect any nodes that were removed while the task store was grouped
            parentTask.appendChild(Ext.Array.reduce(parentTask.__children, reducer, []));
            parentTask.convertEmptyParentToLeaf = parentTask.__convertEmptyParentToLeaf;
            delete parentTask.convertEmptyParentToLeaf;
            delete parentTask.__children;
        });
        var root = this.getRoot();
        root.removeAll();
        root.appendChild(Ext.Array.reduce(clonedRoot.__children, reducer, []).concat(newNodes));
        this.revertStoreAndModelOverrides();
        this.currentGroupField = this.savedParentNodes = this.originalTree = null;
        this.afterTreeRestructuring();
    }
});

/**

 @class Gnt.data.TaskStore
 @extends Ext.data.TreeStore
 @aside guide gantt_data_integration

 A class representing the tree of tasks in the gantt chart. An individual task is represented as an instance of the {@link Gnt.model.Task} class. The store
 expects the data loaded to be hierarchical. Each parent node should contain its children in a property called 'children' (please note that this is different from the old 1.x
 version where the task store expected a flat data structure)

 Parent tasks
 ------------

 By default, when the start or end date of a task gets changed, its parent task(s) will optionally also be updated. Parent tasks always start at it earliest child and ends
 at the end date of its latest child. So be prepared to see several updates and possibly several requests to server. You can batch them with the {@link Ext.data.proxy.Proxy#batchActions} configuration
 option.

 Overall, this behavior can be controlled with the {@link #recalculateParents} configuration option (defaults to true).

 Cascading
 ---------

 In the similar way, when the start/end date of the task gets changed, gantt *can* update any dependent tasks, so they will start on the earliest date possible.
 This behavior is called "cascading" and is enabled or disabled using the {@link #cascadeChanges} configuration option.

 Backward scheduling
 -------------------

 By default tasks are scheduled as early as possible but this behavior can be changed with {@link #scheduleBackwards} config.
 That flag enables _backward scheduling_. In this mode tasks are scheduled from the project end date and begin as late as possible.

 _Backward scheduling_ is a method allowing to plan the project backwards when you have the deadline date when the project should finish.
 And you schedule your tasks based on that fixed date. All the tasks in this mode by default are placed as late as possible.
 The project start date in this mode is flexible and calculated based on the tasks.
 The method allows to estimate the latest possible date the project could start to not break the deadline.

 Scheduling by constraints
 -------------------------

 When calculating the earliest possible start dates the gantt can take into account task constraints.
 This mode can be enables using {@link #scheduleByConstraints} option.
 In the mode the {@link Gnt.model.Task#getEarlyStartDate earliest start date} of a task is calculated based on the task incoming dependencies and constraints
 (including parents dependencies and constraints).
 And when a task start date gets changed by {@link Gnt.model.setStartDate} or {@link Gnt.model.setStartEndDate} methods
 the task automatically gets fixed by the "Start-No-Earlier-Than" constraint.

 A task that is not restricted by dependencies or constraints starts at the {@link #projectStartDate project start date}.

 Integration notes
 -----------------

 For details on data integration - please see [this guide](#!/guide/gantt_data_integration).

 */
Ext.define('Gnt.data.TaskStore', {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Sch.util.Date',
        'Sch.patches.TreeStore',
        'Sch.patches.TreeStoreInternalIdMap',
        'Gnt.data.Linearizator',
        'Gnt.model.Task',
        'Gnt.model.Project',
        'Gnt.data.Calendar',
        'Gnt.data.DependencyStore',
        'Gnt.data.ResourceStore',
        'Gnt.data.AssignmentStore'
    ],
    mixins: [
        'Gnt.patches.NodeInterface',
        'Gnt.patches.TaskStore',
        'Sch.data.mixin.FilterableTreeStore',
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.EventStore',
        'Gnt.data.undoredo.mixin.TaskStoreHint',
        'Gnt.data.mixin.ProjectableStore',
        'Gnt.data.mixin.Groupable'
    ],
    /**
     * @cfg {String/Gnt.model.Task} model The task model to associate with this task store
     *
     */
    model: 'Gnt.model.Task',
    alias: 'store.gantt_taskstore',
    storeId: 'tasks',
    disableDateAdjustments: true,
    /**
     * @cfg {String} typeProperty
     * The name of the property in a raw task data block which indicates the type of the task to be created from that raw data.
     * This is used for heterogeneous trees containing both task and project models (the value is set on the `typeProperty` of the DataReader).
     * For example, the data may look like this:
     *
     *      [{
     *          // TaskType provided so Gnt.model.Project instance will be created for the node
     *          TaskType    : 'Gnt.model.Project',
     *          Name        : 'Main Project',
     *          StartDate   : '2015-06-01',
     *          Duration    : 100,
     *          children    : [{
     *              // since TaskType is omitted the store model will be used for the node
     *              Name        : 'Task 1',
     *              StartDate   : '2015-06-01',
     *              Duration    : 10
     *              children    : [{
     *                  // since TaskType is omitted the store model will be used for the node
     *                  Name        : 'Sub-task 1'
     *                  StartDate   : '2015-06-01',
     *                  Duration    : 10,
     *                  leaf        : true
     *              }]
     *          }]
     *      }]
     *
     * The values should correspond to a valid {@link Gnt.model.Task Task} model class.
     */
    typeProperty: 'TaskType',
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager A calendar manager instance.
     * If specified then the task store will use its {@link Gnt.data.Calendar project calendar}.
     */
    calendarManager: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance to use for this task store. **Should be loaded prior the task store**.
     * This option can be also specified as the configuration option for the gantt panel. If not provided, a default calendar, containing the weekends
     * only (no holidays) will be created.
     *
     */
    calendar: null,
    calendarListeners: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A `Gnt.data.DependencyStore` instance with dependencies information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A `Gnt.data.ResourceStore` instance with resources information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A `Gnt.data.AssignmentStore` instance with assignments information.
     * This option can be also specified as a configuration option for the gantt panel.
     */
    assignmentStore: null,
    /**
     * @cfg {Boolean} weekendsAreWorkdays This option will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar.
     *
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Boolean} cascadeChanges A boolean flag indicating whether a change in a task should be propagated to its successors.
     * This option can be also specified as a {@link Gnt.panel.Gantt#cascadeChanges configuration option} of the Gantt panel.
     */
    cascadeChanges: true,
    /**
     * @cfg {Boolean} batchSync true to batch sync request for 500ms allowing cascade operations, or any other task change with side effects to be batched into one sync call.
     */
    batchSync: true,
    /**
     * @cfg {Boolean} recalculateParents A boolean flag indicating whether a change in some task should update its parent task.
     * This option can be also specified as the configuration option for the gantt panel.
     */
    recalculateParents: true,
    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop A boolean flag indicating whether a task should be moved to the next earliest available time if it falls on non-working time,
     * during move/resize/create operations.
     * This option can be also specified as a configuration option for the Gantt panel.
     */
    skipWeekendsDuringDragDrop: true,
    /**
     * @cfg {Number} cascadeDelay If you usually have deeply nested dependencies, it might be a good idea to add a small delay
     * to allow the modified record to be refreshed in the UI right away and then handle the cascading
     */
    cascadeDelay: 0,
    /**
     * @cfg {Boolean} moveParentAsGroup Set to `true` to move parent task together with its children, as a group. Set to `false`
     * to move only parent task itself. Note, that to enable drag and drop for parent tasks, one need to use the
     * {@link Gnt.panel.Gantt#allowParentTaskMove} option.
     */
    moveParentAsGroup: true,
    /**
     * @cfg {Boolean} enableDependenciesForParentTasks Set to `true` to process the dependencies from/to parent tasks as any other dependency.
     * Set to `false` to ignore such dependencies and not cascade changes by them.
     *
     * Currently, support for dependencies from/to parent task is limited. Only the "start-to-end" and "start-to-start" dependencies
     * are supported. Also, if some task has incoming dependency from usual task and parent task, sometimes the dependency from
     * parent task can be ignored.
     *
     * Note, that when enabling this option requires the {@link Gnt.data.DependencyStore#strictDependencyValidation} to be set to `true` as well.
     * Otherwise it will be possible to create indirect cyclic dependencies, which will cause an infinite recursion exception.
     */
    enableDependenciesForParentTasks: true,
    /**
     * @cfg {Number} availabilitySearchLimit Maximum number of days to search for calendars common availability.
     * Used in various task calculations requiring to respect working time.
     * In these cases the system tries to account working time as intersection of the assigned resource calendars and the task calendar.
     * This config determines the range intersection will be searched in.
     * For example in case of task end date calculation system will try to find calendars intersection between task start date
     * and task start date plus `availabilitySearchLimit` days.
     */
    availabilitySearchLimit: 1825,
    //5*365
    /**
     * @cfg {String} [cycleResolutionStrategy='cut'] Strategy to use to resolve cycles in dependent node sets.
     * Possible values are:
     *
     *  - "none"
     *  - "exception"
     *  - "cut"
     *
     * Each value corresponds to a public function from {@link Gnt.data.linearizator.CycleResolvers}.
     */
    cycleResolutionStrategy: 'cut',
    /**
     * @cfg {Boolean} [autoNormalizeNodes=true]
     * If this flag is `true` when tasks are loaded to the store, missing data like {@link Gnt.model.Task#StartDate StartDate},
     * {@link Gnt.model.Task#EndDate EndDate}, {@link Gnt.model.Task#Duration Duration}, {@link Gnt.model.Task#Effort Effort},
     * will be automatically calculated in scope of this record. For example, if a task has {@link Gnt.model.Task#StartDate StartDate}
     * and {@link Gnt.model.Task#EndDate EndDate} specified, but {@link Gnt.model.Task#Duration Duration} is missing,
     * normalization will calculate the duration value. The calculation doesn't involve other tasks,
     * like parent/children or incoming/outgoing dependencies.
     */
    autoNormalizeNodes: true,
    /**
     * @cfg {Boolean} enableSetDurationOnEffortDrivenTask When true, allows to change duration on effort driven tasks
     * which do not have any assignments.
     */
    enableSetDurationOnEffortDrivenTask: true,
    /**
     * @event filter
     * Will be fired on the call to `filter` method
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `filter` method
     */
    /**
     * @event clearfilter
     * Will be fired on the call to `clearFilter` method
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `clearFilter` method
     */
    /**
    * @event beforecascade
    * Fires before a cascade operation is initiated
    * @param {Gnt.data.TaskStore} store The task store
    */
    /**
    * @event cascade
    * Fires when after a cascade operation has completed
    * @param {Gnt.data.TaskStore} store The task store
    * @param {Object} context A context object revealing details of the cascade operation, such as 'nbrAffected' - how many tasks were affected.
    */
    /**
     * @cfg {Date} projectStartDate
     * The _project start date_. When {@link #scheduleByConstraints} is enabled all tasks start on this date unless they are constrained with a dependency or a constraint.
     * Please note that children of a {@link Gnt.model.Project project task} get the _project start date_ from the project {@link Gnt.model.Project#StartDate field}.
     *
     * FYI, The value can be provided as part of the server side response when using a {@link Gnt.data.CrudManager}.
     * For details see [this guide](#!/guide/gantt_crud_manager-section-providing-the-project-start-date).
     */
    projectStartDate: null,
    /**
     * @cfg {Date} projectEndDate
     * The _project finish date_.
     * The value is used in backward scheduled projects (when {@link #scheduleBackwards} is `true`).
     * When {@link #scheduleByConstraints} is enabled all tasks finish on this date unless they are constrained with a dependency or a constraint.
     * Please note that children of a {@link Gnt.model.Project project task} get the _project end date_ from the project {@link Gnt.model.Project#EndDate field}.
     *
     * FYI, The value can be provided as part of the server side response when using a {@link Gnt.data.CrudManager}.
     * For details see [this guide](#!/guide/gantt_crud_manager-section-providing-the-project-start-date).
     */
    projectEndDate: null,
    /**
     * @cfg {Boolean} limitEarlyLateDatesMutually
     * The config affects task early/late dates calculation when a scheduling conflict takes place.
     * If the config is `true` task early and late dates mutually limit each other values:
     * 
     * - task {@link Gnt.model.Task#getEarlyStartDate early start date} cannot be greater than its {@link Gnt.model.Task#getLateStartDate late start date}
     * - task {@link Gnt.model.Task#getEarlyEndDate early end date} cannot be greater than its {@link Gnt.model.Task#getLateEndDate late end date}
     *
     * Which also implies vise-versa restrictions:
     *
     * - task {@link Gnt.model.Task#getLateStartDate late start date} cannot be less than its {@link Gnt.model.Task#getEarlyStartDate early start date}
     * - task {@link Gnt.model.Task#getLateEndDate late end date} cannot be less than its {@link Gnt.model.Task#getEarlyEndDate early end date}
     *
     * The option is disabled by default to not mask scheduling conflicts.
     */
    limitEarlyLateDatesMutually: false,
    cascading: false,
    isFillingRoot: false,
    isSettingRoot: false,
    // These cache objects store early/late dates indexed by task internalId-s.
    earlyDatesCache: null,
    lateDatesCache: null,
    earlyDatesResetNotificationSuspended: 0,
    earlyDatesResetNotificationRequested: 0,
    lateDatesResetNotificationSuspended: 0,
    lateDatesResetNotificationRequested: 0,
    lastTotalTimeSpan: null,
    suspendAutoRecalculateParents: 0,
    suspendAutoCascade: 0,
    currentCascadeBatch: null,
    batchCascadeLevel: 0,
    // HACK to work around strange Sencha behavior
    // https://app.assembla.com/spaces/bryntum/tickets/5059
    defaultRootText: '',
    /**
     * @cfg {String} dependenciesCalendar A string, defining the calendar, that will be used when calculating the working time, skipped
     * by the dependencies {@link Gnt.model.Dependency#Lag lag}. Possible values are:
     *
     *  - `project` - the project calendar is used
     *  - `source` - the calendar of dependency's source task is used
     *  - `target` - the calendar of target task
     */
    dependenciesCalendar: 'target',
    pendingDataUpdates: null,
    // Counter for the number of store.load() calls. It's used to track nested calls.
    tasksLoadStarted: 0,
    /**
     * Will be fired on the call to `filter` method
     * @event filter
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `filter` method
     */
    /**
     * Will be fired on the call to `clearFilter` method
     * @event clearfilter
     * @param {Gnt.data.TaskStore} self This task store
     * @param {Object} args The arguments passed to `clearFilter` method
     */
    /**
     * @event beforecascade
     * Fires before a cascade operation is initiated
     * @param {Gnt.data.TaskStore} store The task store
     */
    /**
     * @event cascade
     * Fires when after a cascade operation has completed
     * @param {Gnt.data.TaskStore} store The task store
     * @param {Object} context A context object revealing details of the cascade operation, such as 'nbrAffected' - how many tasks were affected.
     */
    /**
     * @cfg {Boolean} checkDependencyConstraint
     * Enables warning a user when he makes a change that breaks an incoming dependency.
     * This check works only when {@link #scheduleByConstraints} mode is enabled.
     * This warning only shows up when the change breaks a _single_ dependency.
     *
     * In case multiple dependencies are broken the gantt will try to resolve automatically:
     *
     *  - if the task was shifted away from its predecessors - the gantt will pin the task with "Start-No-Earlier-Than" constraint
     *  - if the task was shifted back from its predecessors - the task will be shifted forward to satisfy its incoming dependencies
     */
    checkDependencyConstraint: false,
    /**
     * @cfg {Boolean} checkPotentialConflictConstraint
     * Enables a warning of a user about a potential conflict that might be caused
     * by setting one of the following constraints ("Start No Later Than", "Finish No Later Than", "Must Start On", "Must Finish On") on a task that has incoming dependencies.
     *
     * This check works only when {@link #scheduleByConstraints} mode is enabled.
     */
    checkPotentialConflictConstraint: false,
    /**
     * @cfg {Boolean} scheduleByConstraints
     * Enables scheduling of the tasks based on their constraints (including ones inherited from corresponding parent tasks).
     * If a task has no affecting constraints and dependencies it would start at the _project start date_.
     * The _project start date_ value is taken either:
     *
     * - from the task's project node ({@link Gnt.model.Project} instance) if the task has it
     * - or from the {@link #projectStartDate} option
     */
    scheduleByConstraints: false,
    /**
     * @cfg {String} projectDateFormat
     * Sets the format the _project start date_ is returned in from the server when using a {@link Gnt.data.CrudManager CrudManager}.
     * The format is any string supported by Ext.Date.parse method.
     */
    projectDateFormat: "c",
    /**
     * @cfg {Boolean} scheduleBackwards
     *
     * Enables _backward scheduling_. In this mode tasks are scheduled from the project end date and begin as late as possible.
     *
     * _Backward scheduling_ is a method allowing to plan the project backwards when you have the deadline date when the project should finish.
     * And you schedule your tasks based on that fixed date. All the tasks in this mode by default are placed as late as possible.
     * The project start date in this mode is flexible and calculated based on the tasks.
     * The method allows to estimate the latest possible date the project could start to not break the deadline.
     *
     * By default the mode is disabled and all tasks begin as soon as possible.
     *
     * **Please note,** that if a task belongs to a {@link Gnt.model.Project project node} then this setting is taken from
     * the project node (see {@link Gnt.model.Project#getScheduleBackwards} method).
     */
    scheduleBackwards: false,
    constructor: function(config) {
        config = config || {};
        // calendar manager on the config has the highest prio
        var calendarManager = 'calendarManager' in config ? config.calendarManager : this.getCalendarManager();
        delete config.calendarManager;
        this.setCalendarManager(calendarManager);
        var calendar = config.calendar || this.calendar;
        if (!calendar) {
            var calendarConfig = {};
            if (config.hasOwnProperty('weekendsAreWorkdays')) {
                calendarConfig.weekendsAreWorkdays = config.weekendsAreWorkdays;
            } else {
                if (this.self.prototype.hasOwnProperty('weekendsAreWorkdays') && this.self != Gnt.data.TaskStore) {
                    calendarConfig.weekendsAreWorkdays = this.weekendsAreWorkdays;
                }
            }
            // if we have calendarManager
            if (this.getCalendarManager()) {
                calendar = this.getCalendarManager().getProjectCalendar();
            }
            calendar = calendar && Ext.data.StoreManager.lookup(calendar) || new Gnt.data.Calendar(calendarConfig);
        }
        // If not provided, create default stores (which will be overridden by GanttPanel during instantiation
        var dependencyStore = config.dependencyStore || this.dependencyStore;
        dependencyStore = dependencyStore && Ext.data.StoreManager.lookup(dependencyStore) || Ext.create("Gnt.data.DependencyStore");
        delete config.dependencyStore;
        var resourceStore = config.resourceStore || this.resourceStore;
        resourceStore = resourceStore && Ext.data.StoreManager.lookup(resourceStore) || Ext.create("Gnt.data.ResourceStore");
        delete config.resourceStore;
        var assignmentStore = config.assignmentStore || this.assignmentStore;
        assignmentStore = assignmentStore && Ext.data.StoreManager.lookup(assignmentStore) || Ext.create("Gnt.data.AssignmentStore", {
            resourceStore: resourceStore
        });
        delete config.assignmentStore;
        if (calendar) {
            // remove config to not overwrite this.calendar after setCalendar() call
            delete config.calendar;
            this.setCalendar(calendar, true, true);
        }
        // init cache for early/late dates
        this.resetEarlyDates(true);
        this.resetLateDates(true);
        this.pendingDataUpdates = {
            recalculateParents: {}
        };
        // Nodes should not be loaded before related stores are set, thus we postpone root loading
        // to the time when class is constructed and related stores are set
        // {{{ Initial root loading and superclass construction
        var configuredRoot = config.root || this.root;
        this.root = null;
        delete config.root;
        this.callParent([
            config
        ]);
        this.setResourceStore(resourceStore);
        this.setAssignmentStore(assignmentStore);
        this.setDependencyStore(dependencyStore);
        configuredRoot && this.setRoot(configuredRoot);
        // }}}
        this.setupListeners();
        var root = this.getRoot();
        if (root && this.autoNormalizeNodes) {
            root.normalizeParent();
        }
        if (this.autoSync && this.batchSync) {
            // Prevent operations with side effects to create lots of individual server requests
            this.sync = Ext.Function.createBuffered(this.sync, 500);
        }
        this.initTreeFiltering();
    },
    getCrudManager: function() {
        return this.crudManager;
    },
    // This hook used by the CrudManager when we register a store in it
    setCrudManager: function(crudManager) {
        this.crudManager = crudManager;
    },
    getCalendarManager: function() {
        return this.calendarManager;
    },
    setCalendarManager: function(calendarManager) {
        calendarManager = calendarManager && Ext.data.StoreManager.lookup(calendarManager);
        // If calendar manager is not changed - do nothing
        if (calendarManager === this.calendarManager)  {
            return;
        }
        
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy();
        }
        this.calendarManager = calendarManager;
        if (calendarManager) {
            this.projectCalendarSet = Boolean(calendarManager.getProjectCalendar());
            // wait till calendar manager set a project calendar and then use it
            this.calendarManagerListeners = calendarManager.on({
                projectcalendarset: function(manager, calendar) {
                    // we don't recalculate tasks after the first project calendar set
                    // further calendarManager.setProjectCalendar() calls will cause tasks adjustment
                    if (!this.settingCalendar) {
                        this.setCalendar(calendar, !this.projectCalendarSet);
                        this.projectCalendarSet = true;
                    }
                },
                scope: this,
                destroyable: true
            });
        }
        return calendarManager;
    },
    onProjectionCommit: function(me, lastChanges, committedChanges) {
        // loop over committed tasks and commit segments changes as well
        for (var internalId in committedChanges) {
            if (committedChanges.hasOwnProperty(internalId)) {
                var task = this.getModelByInternalId(internalId);
                task && task.commitSegmentsProjection();
            }
        }
    },
    onProjectionReject: function(me, lastChanges, rejectedChanges) {
        // loop over committed tasks and revert segments changes as well
        for (var internalId in rejectedChanges) {
            if (rejectedChanges.hasOwnProperty(internalId)) {
                var task = this.getModelByInternalId(internalId);
                task && task.rejectSegmentsProjection();
            }
        }
    },
    setupListeners: function() {
        this.listenersAreInitialized = true;
        this.on({
            nodeappend: this.onMyNodeAdded,
            nodeinsert: this.onMyNodeAdded,
            update: this.onTaskUpdated,
            // track projection commit/reject
            projectioncommit: this.onProjectionCommit,
            projectionreject: this.onProjectionReject,
            // Prevent a sort from triggering 'index' field to be persisted. It should only be persisted when reordering manually
            beforesort: function() {
                var indexField = this.getModel().getField('index');
                indexField.oldPersist = indexField.persist;
                indexField.persist = false;
            },
            sort: function() {
                var indexFld = this.getModel().getField('index');
                indexFld.persist = indexFld.oldPersist;
            },
            scope: this
        });
        this.on({
            noderemove: this.onTaskRemoved,
            nodemove: this.onTaskMoved,
            sort: this.onTasksSorted,
            load: this.onTasksLoaded,
            scope: this,
            // This should guarantee that our listeners are run first since view should
            // only refresh after we've updated cached dependencies for each task (on store load, root change etc)
            priority: 100
        });
    },
    // Overridden from EventStore mixin to turn off EventStore mixin's logic related to resource->events caching
    // which comes into play in absence of assignment store
    createResourceEventsCache: Ext.emptyFn,
    // Overridden from EventStore mixin to provide id consistency manager with task store instead of event store
    createIdConsistencyManager: function() {
        var me = this;
        return new Sch.data.util.IdConsistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    // Overridden from EventStore mixin to provide id consistency manager with task store instead of event store
    createModelPersistencyManager: function() {
        var me = this;
        return new Sch.data.util.ModelPersistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    fillNode: function(node, newNodes) {
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        if (node.isRoot()) {
            this.isSettingRoot = true;
        }
        this.callParent(arguments);
        if (node.isRoot()) {
            this.isSettingRoot = false;
        }
    },
    onTasksLoaded: function() {
        var root = this.getRoot();
        if (root && this.autoNormalizeNodes) {
            root.normalizeParent();
        }
        // restore back CRUD listeners to support cascading and parent recalculations
        this.onTasksLoadEnd();
    },
    onTasksLoadStart: function() {
        // store.load() might be called recursively in a tree store
        // so we keep number of invokes to restore listeners back only when the last call is done
        this.tasksLoadStarted++;
        // we don't want to recalculate parent nodes an load stage
        this.suspendAutoRecalculateParents++;
        // Overridden to avoid reacting to the removing of all the records in the store
        this.un("noderemove", this.onTaskRemoved, this);
        // 5.0.1 Seems Ext is using regular "appendChild" method during store load, which triggers all the corresponding events
        // we don't want to react on those events during loading (recalculate parents, etc)
        this.un("nodeappend", this.onMyNodeAdded, this);
        this.un("update", this.onTaskUpdated, this);
    },
    onTasksLoadEnd: function() {
        // reset total timespan cache to force its recalculating
        this.resetTotalTimeSpanCache();
        this.tasksLoadStarted--;
        // if no more nested load() calls
        // let's restore CRUD listeners
        if (!this.tasksLoadStarted) {
            this.on("noderemove", this.onTaskRemoved, this);
            this.on("nodeappend", this.onMyNodeAdded, this);
            this.on("update", this.onTaskUpdated, this);
        }
        // enable parent nodes recalculating back
        this.suspendAutoRecalculateParents--;
    },
    load: function(options) {
        // suspend CRUD listeners to skip cascading and parent recalculations (we restore it back by calling onTasksLoadEnd() in a "load" event listener)
        this.on('beforeload', this.onTasksLoadStart, this, {
            // we want it to run as late as possible to make sure some other listener hadn't returned false before it
            priority: -999,
            single: true
        });
        // Note, that gantt uses additional important override for `load` method for ExtJS 4.2.1 and below, inherited from
        // Sch.data.mixin.FilterableTreeStore
        this.callParent(arguments);
    },
    // After the task store proxy is set we map provided "typeProperty"
    // to the reader being used
    setProxy: function() {
        this.callParent(arguments);
        if (this.typeProperty) {
            var me = this,
                reader = me.getProxy() && me.getProxy().getReader();
            // if user has not provided "typeProperty" directly to the reader
            if (reader && !reader.getTypeProperty()) {
                reader.setTypeProperty(me.typeProperty);
            }
        }
    },
    setRoot: function(rootNode) {
        var me = this;
        // Ext5 NOTE: we check this.count() since it might break loading of data from "root" config if we call getRoot() too early
        var oldRoot = this.count() && this.getRoot();
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        this.isSettingRoot = true;
        Ext.apply(rootNode, {
            calendar: me.calendar,
            taskStore: me,
            // TODO: this is probably not needed anymore
            dependencyStore: me.dependencyStore,
            // TODO: this is probably not needed anymore
            // HACK Prevent tree store from trying to 'create' the root node
            phantom: false,
            dirty: false
        });
        // if "setupListeners" was already called ..means we react on the store add/remove/update
        // let's call "onTasksLoadStart" detaching the listeners
        if (me.listenersAreInitialized) {
            me.onTasksLoadStart();
        }
        var res = this.callParent(arguments);
        this.isSettingRoot = false;
        if (me.listenersAreInitialized) {
            me.onTasksLoaded();
        }
        // we reset taskStore property on the tasks of the old root when we set the new root
        oldRoot && oldRoot.cascadeBy(function(node) {
            node.setTaskStore(null);
        });
        return res;
    },
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    /**
     * Sets the dependency store for this task store
     *
     * @param {Gnt.data.DependencyStore} dependencyStore
     */
    setDependencyStore: function(dependencyStore) {
        var me = this,
            oldStore = me.dependencyStore,
            listeners = {
                clear: me.onDependenciesClear,
                load: me.onDependenciesLoad,
                add: me.onDependencyAdd,
                update: me.onDependencyUpdate,
                remove: me.onDependencyDelete,
                scope: me
            };
        if (oldStore && oldStore.isStore) {
            oldStore.un(listeners);
            oldStore.setTaskStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(null);
        }
        me.dependencyStore = dependencyStore && Ext.StoreMgr.lookup(dependencyStore) || null;
        if (me.dependencyStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(me.dependencyStore);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(me.dependencyStore);
            me.dependencyStore.setTaskStore(me);
            me.dependencyStore.on(listeners);
        }
        if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
            /**
             * @event dependencystorechange
             * Fires when new dependency store is set via {@link #setDependencyStore} method.
             * @param {Gnt.data.TaskStore}           this
             * @param {Gnt.data.DependencyStore|null} newAssignmentStore
             * @param {Gnt.data.DependencyStore|null} oldAssignmentStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('dependencystorechange', me, dependencyStore, oldStore);
        }
    },
    /**
     * Returns a resource store instance this task store is associated with. See also {@link #setResourceStore}.
     *
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function() {
        return this.resourceStore || null;
    },
    /**
     * Sets the resource store for this task store
     *
     * @param {Gnt.data.ResourceStore} resourceStore
     */
    setResourceStore: function(resourceStore) {
        var me = this,
            oldStore = me.resourceStore;
        if (oldStore && oldStore.isStore) {
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
        }
        me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;
        if (me.resourceStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
            me.resourceStore.setTaskStore(me);
            me.resourceStore.normalizeResources();
        }
        if ((oldStore || resourceStore) && (oldStore !== resourceStore)) {
            /**
             * @event resourcestorechange
             * Fires when new resource store is set via {@link #setResourceStore} method.
             * @param {Gnt.data.TaskStore}          this
             * @param {Gnt.data.ResourceStore|null} newResourceStore
             * @param {Gnt.data.ResourceStore|null} oldResourceStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
        }
    },
    /**
     * Returns an assignment store this task store is associated with. See also {@link #setAssignmentStore}.
     *
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.assignmentStore || null;
    },
    /**
     * Sets the assignment store for this task store
     *
     * @param {Gnt.data.AssignmentStore} assignmentStore
     */
    setAssignmentStore: function(assignmentStore) {
        var me = this,
            oldStore = me.assignmentStore,
            listeners = {
                add: me.onAssignmentStructureMutation,
                update: me.onAssignmentUpdate,
                remove: me.onAssignmentStructureMutation,
                scope: me
            };
        if (oldStore && oldStore.isStore) {
            oldStore.un(listeners);
            oldStore.setTaskStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
        }
        me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;
        if (me.assignmentStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
            assignmentStore.setTaskStore(me);
            assignmentStore.on(listeners);
        }
        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * @event assignmentstorechange
             * Fires when new assignment store is set via {@link #setAssignmentStore} method.
             * @param {Gnt.data.TaskStore}            this
             * @param {Gnt.data.AssignmentStore|null} newAssignmentStore
             * @param {Gnt.data.AssignmentStore|null} oldAssignmentStore
             */
            // Method might be called before class is fully constructed thus we check for observable mixin to be ready
            me.events && me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
        }
    },
    /**
     * @propagating
     * Call this method if you want to adjust tasks according to the calendar dates.
     * @param  {Gnt.model.Task/Gnt.model.Task[]} [tasks] Task or list of tasks to be adjusted. If omitted all tasks will be adjusted.
     * @param  {Function} callback Function to call on propagation changes completion or failure.
     */
    adjustToCalendar: function(tasks, callback) {
        var me = this;
        // reset early/late dates cache
        me.resetEarlyDates();
        me.resetLateDates();
        if (tasks instanceof Gnt.model.Task) {
            tasks.adjustToCalendar(callback);
        } else {
            if (Ext.isFunction(tasks)) {
                callback = tasks;
                tasks = [];
            }
            var root = me.getRoot(),
                doneNodes = {},
                globalPropagation = false;
            // if no tasks provided
            if (!Ext.isArray(tasks) || !tasks.length) {
                // get 1st level tasks
                tasks = root && root.childNodes || [];
                globalPropagation = true;
            }
            // we will initiate propagation starting from the root
            // yet real propagation sources are returned in the "propagationSources" array
            root && root.propagateChanges(function() {
                var propagationSources = [];
                for (var i = 0,
                    l = tasks.length; i < l; i++) {
                    var node = tasks[i];
                    // each node's child we adjust to calendar
                    node.cascadeBy(function(n) {
                        if (n !== root)  {
                            n.adjustToCalendarWithoutPropagation();
                        }
                        
                    });
                    // if we renormalize globally we say that we started propagation from tasks w/o incoming
                    // dependencies (since if we include them into "propagationSources" they will be treated as already processed
                    // and won't be aligned by incoming dependencies
                    if (!globalPropagation || !node.hasIncomingDependencies()) {
                        propagationSources.push(node);
                    }
                }
                return propagationSources.length && propagationSources || false;
            }, function(cancel, affected) {
                // remember tasks already processed as result of changes propagation
                if (!cancel)  {
                    Ext.apply(doneNodes, affected);
                }
                
                callback && callback.apply(this, arguments);
            });
        }
    },
    /**
     * Returns a project calendar instance.
     *
     * @return {Gnt.data.Calendar}
     */
    getCalendar: function() {
        return this.calendar || null;
    },
    /**
     * Sets the calendar for this task store
     *
     * @param {Gnt.data.Calendar} calendar
     */
    setCalendar: function(calendar, doNotChangeTasks, suppressEvent) {
        if (this.settingCalendar)  {
            return;
        }
        
        this.settingCalendar = true;
        var listeners = {
                calendarchange: function() {
                    this.adjustToCalendar();
                },
                destroyable: true,
                scope: this
            };
        if (this.calendarListeners) {
            this.calendarListeners.destroy();
            this.calendarListeners = null;
        }
        this.calendar = calendar;
        if (calendar) {
            this.calendarListeners = calendar.on(listeners);
            var root = this.getRoot();
            if (root) {
                root.calendar = calendar;
            }
            if (!doNotChangeTasks) {
                this.adjustToCalendar();
            }
            if (!suppressEvent) {
                this.fireEvent('calendarset', this, calendar);
            }
            // let calendarManager know of project calendar change
            if (this.getCalendarManager()) {
                this.getCalendarManager().setProjectCalendar(calendar);
            }
        }
        this.settingCalendar = false;
    },
    /**
     * Returns the critical path(s) containing tasks with no slack that, if shifted, will push the end date of the project forward.
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths: function() {
        var me = this,
            finalTasks = [],
            projects = me.getProjects(),
            roots = projects.length === 0 ? [
                me.getRoot()
            ] : projects;
        Ext.Array.each(roots, function(projectRoot) {
            // project end date
            var end = projectRoot.isProject && projectRoot.getEndDate() || me.getProjectEndDate();
            // find the tasks that ends on that date
            projectRoot.cascadeBy(function(task) {
                if (task.getEndDate() - end === 0 && !task.isRoot()) {
                    finalTasks.push(task);
                }
            });
        });
        return Ext.Array.map(finalTasks, function(task) {
            return task.getCriticalPaths();
        });
    },
    onMyNodeAdded: function(parent, node) {
        var me = this;
        if (!node.isRoot()) {
            if (me.lastTotalTimeSpan) {
                var span = me.getTotalTimeSpan();
                // if new task dates violates cached total range then let's reset getTotalTimeSpan() cache
                if (node.getEndDate() > span.end || node.getStartDate() < span.start) {
                    me.resetTotalTimeSpanCache();
                }
            }
            // if it's a latest task
            if (node.getEndDate() - me.getProjectEndDate() === 0) {
                me.resetLateDates();
            }
            if (!me.isUndoingOrRedoing()) {
                var dependencyStore = this.getDependencyStore(),
                    nodeNeedsRescheduling = true;
                if (me.cascadeChanges && !me.suspendAutoCascade && (me.scheduleByConstraints || node.getParentsIncomingDependencies().length)) {
                    // Scheduling the new added task ..and its linked tasks if any
                    dependencyStore && dependencyStore.reduceTaskDependencies(node, function(result, dependency) {
                        var from = dependency.getSourceTask(),
                            to = dependency.getTargetTask();
                        if (from && to) {
                            // re-scheduler both tasks
                            from.scheduleWithoutPropagation();
                            to.scheduleWithoutPropagation();
                            // set flag to not re-schedule the node twice
                            nodeNeedsRescheduling = false;
                        }
                    }, null, false);
                    // re-schedule the node if it's needed
                    nodeNeedsRescheduling && node.scheduleWithoutPropagation();
                }
                if (!me.cascading && me.recalculateParents && !me.suspendAutoRecalculateParents) {
                    if (me.updating) {
                        me.pendingDataUpdates.recalculateParents[node.getId()] = node;
                    } else {
                        node.recalculateParents();
                    }
                }
            }
        }
    },
    onTaskUpdated: function(store, task, operation) {
        var prev = task.previous;
        var parentIdProperty = this.parentIdProperty || 'parentId';
        if (this.lastTotalTimeSpan) {
            var span = this.getTotalTimeSpan();
            // if new task dates violates cached total range then let's reset the cache
            if (prev && (prev[task.endDateField] - span.end === 0 || prev[task.startDateField] - span.start === 0) || (task.getEndDate() > span.end || task.getStartDate() < span.start)) {
                this.resetTotalTimeSpanCache();
            }
        }
        if (!this.cascading && operation !== Ext.data.Model.COMMIT && prev && !this.isUndoingOrRedoing()) {
            var parentPrev = task.parentNode && task.parentNode.previous;
            var parentPrevId = parentPrev && parentPrev[task.idProperty];
            var doRecalcParents = task.percentDoneField in prev;
            // Check if we should cascade this update to successors
            // We're only interested in cascading operations that affect the start/end dates
            if (task.startDateField in prev || task.endDateField in prev || (// parentId got changed (and not because of a phantom parent got persisted)
            (parentIdProperty in prev) && (!parentPrevId || parentPrevId != prev[parentIdProperty])) || task.effortField in prev || // if task has changed _from_ manually scheduled mode
            prev[task.schedulingModeField] === 'Manual' || prev[task.manuallyScheduledField]) {
                var cascadeSourceTask = task;
                if (this.cascadeChanges && !this.suspendAutoCascade) {
                    // if we switched scheduling mode from manual then we'll call propagateChanges() on task for some of
                    // task predecessors (if any) to update task itself
                    if (prev[cascadeSourceTask.schedulingModeField] == 'Manual') {
                        var deps = cascadeSourceTask.getIncomingDependencies(true);
                        if (deps.length) {
                            cascadeSourceTask = deps[0].getSourceTask();
                        }
                    }
                    this.cascadeTimer = Ext.Function.defer(cascadeSourceTask.propagateChanges, this.cascadeDelay, cascadeSourceTask, [
                        Ext.emptyFn,
                        null,
                        true
                    ]);
                } else {
                    // reset early/late dates cache
                    this.resetEarlyDates();
                    this.resetLateDates();
                }
                doRecalcParents = true;
            }
            // if task scheduling turned to manual
            else if ((task.manuallyScheduledField in prev) && task.isManuallyScheduled()) {
                // reset early/late dates cache
                this.resetEarlyDates();
                this.resetLateDates();
            }
            if (doRecalcParents && this.recalculateParents && !this.suspendAutoRecalculateParents) {
                if (this.updating) {
                    this.pendingDataUpdates.recalculateParents[task.getId()] = task;
                } else {
                    task.recalculateParents();
                }
            }
        }
    },
    onEndUpdate: function() {
        var me = this,
            toRecalculateParents = {},
            task;
        if (!this.isUndoingOrRedoing()) {
            Ext.Object.each(me.pendingDataUpdates.recalculateParents, function(id, task) {
                task.parentNode && (toRecalculateParents[task.parentNode.getId()] = task.parentNode);
            });
            // Sorting lower depth first, but then pop()'ing to process deepest depth first
            toRecalculateParents = Ext.Array.sort(Ext.Object.getValues(toRecalculateParents), function(a, b) {
                return (a.data.depth > b.data.depth) ? 1 : ((a.data.depth < b.data.depth) ? -1 : 0);
            });
            while (toRecalculateParents.length > 0) {
                task = toRecalculateParents.pop();
                task.refreshCalculatedParentNodeData();
                task.recalculateParents();
            }
        }
        me.pendingDataUpdates.recalculateParents = {};
        return me.callParent(arguments);
    },
    getEmptyCascadeBatch: function() {
        var me = this;
        return {
            nbrAffected: 0,
            affected: {},
            addAffected: function(task, doNotAddParents) {
                var internalId = task.internalId;
                if (this.affected[internalId]) {
                    // already added
                    return;
                } else {
                    this.affected[internalId] = task;
                    this.nbrAffected++;
                }
                if (!me.cascading && this.nbrAffected > 1) {
                    me.fireEvent('beforecascade', me);
                    me.cascading = true;
                }
                if (!doNotAddParents) {
                    var byId = this.affectedParentsbyInternalId;
                    var array = this.affectedParentsArray;
                    var parent = task.isLeaf() ? task.parentNode : task;
                    while (parent && !parent.data.root) {
                        if (byId[parent.internalId])  {
                            break;
                        }
                        
                        byId[parent.internalId] = parent;
                        array.push(parent);
                        this.addAffected(parent, true);
                        parent = parent.parentNode;
                    }
                }
            },
            affectedParentsArray: [],
            affectedParentsbyInternalId: {}
        };
    },
    // starts a `batched` cascade (can contain several cascades, combined in one `currentCascadeBatch` context
    // cascade batch may actually contain 0 cascades (if for example deps are invalid)
    startBatchCascade: function() {
        if (!this.batchCascadeLevel) {
            this.currentCascadeBatch = this.getEmptyCascadeBatch();
            this.suspendAutoRecalculateParents++;
            this.suspendAutoCascade++;
        }
        this.batchCascadeLevel++;
        return this.currentCascadeBatch;
    },
    endBatchCascade: function() {
        this.batchCascadeLevel--;
        if (!this.batchCascadeLevel) {
            this.suspendAutoRecalculateParents--;
            this.suspendAutoCascade--;
            var currentCascadeBatch = this.currentCascadeBatch;
            this.currentCascadeBatch = null;
            this.resetEarlyDates();
            this.resetLateDates();
            if (this.cascading) {
                this.cascading = false;
                this.fireEvent('cascade', this, currentCascadeBatch);
            }
        }
    },
    removeTaskDependencies: function(task) {
        var dependencyStore = this.dependencyStore,
            deps = task.getAllDependencies(dependencyStore);
        if (deps.length)  {
            dependencyStore.remove(deps);
        }
        
    },
    removeTaskAssignments: function(task) {
        var assignmentStore = this.getAssignmentStore(),
            assignments = task.getAssignments();
        if (assignments.length)  {
            assignmentStore.remove(assignments);
        }
        
    },
    // TODO: constraints
    onTaskRemoved: function(store, removedNode, isMove) {
        var dependencyStore = this.getDependencyStore();
        var assignmentStore = this.getAssignmentStore();
        var taskDropped = !removedNode.isReplace && !isMove;
        // remove dependencies associated with the task
        if (dependencyStore && taskDropped) {
            removedNode.cascadeBy(this.removeTaskDependencies, this);
        }
        // remove task assignments
        if (assignmentStore && taskDropped) {
            // Fire this event so UI can ignore the datachanged events possibly fired below
            assignmentStore.fireEvent('beforetaskassignmentschange', assignmentStore, removedNode.getId(), []);
            removedNode.cascadeBy(this.removeTaskAssignments, this);
            // Fire this event so UI can just react and update the row for the task
            assignmentStore.fireEvent('taskassignmentschanged', assignmentStore, removedNode.getId(), []);
        }
        var span = this.getTotalTimeSpan();
        var startDate = removedNode.getStartDate();
        var endDate = removedNode.getEndDate();
        // if removed task dates were equal to total range then removing can affect total time span
        // so let's reset getTotalTimeSpan() cache
        if (endDate - span.end === 0 || startDate - span.start === 0) {
            this.resetTotalTimeSpanCache();
        }
        // mark task that it's no longer belong to the task store
        if (taskDropped)  {
            removedNode.setTaskStore(null);
        }
        
        //if early/late dates are supported
        this.resetEarlyDates();
        this.resetLateDates();
    },
    onTaskMoved: function(task, oldParent, newParent, index) {
        var span = this.getTotalTimeSpan();
        var startDate = task.getStartDate();
        var endDate = task.getEndDate();
        // if removed task dates were equal to total range then removing can affect total time span
        // so let's reset getTotalTimeSpan() cache
        if (endDate - span.end === 0 || startDate - span.start === 0) {
            this.resetTotalTimeSpanCache();
        }
        //if early/late dates are supported
        this.resetEarlyDates();
        this.resetLateDates();
    },
    // TODO: constraints
    onAssignmentUpdate: function(assignmentStore, assignment, operation) {
        var me = this,
            prev = assignment.previous,
            skipRecalc = true,
            resourceIdField = assignment.resourceIdField,
            taskIdField = assignment.taskIdField,
            unitsField = assignment.unitsField,
            resource, resourcePrev, task, taskPrev;
        // we need to recalculate (effort etc.) on ResourceId/TaskId/Units fields change
        // (for ResourceId/TaskId we skip the case when they are change because of the
        // corresponding referenced records id change)
        for (var field in prev) {
            switch (field) {
                case resourceIdField:
                    resource = assignment.getResource();
                    resourcePrev = resource && resource.previous;
                    skipRecalc = resourcePrev && resourcePrev[resource.idProperty] == prev[field];
                    break;
                case taskIdField:
                    task = assignment.getTask();
                    taskPrev = task && task.previous;
                    skipRecalc = taskPrev && taskPrev[task.idProperty] == prev[field];
                    break;
                case unitsField:
                    skipRecalc = false;
                    break;
            }
            if (skipRecalc)  {
                break;
            }
            
        }
        if (!skipRecalc && !me.isUndoingOrRedoing() && operation !== Ext.data.Model.COMMIT) {
            // TaskStore could be filtered etc.
            task = assignment.getTask(me);
            if (task) {
                task.onAssignmentMutation(assignment);
            }
        }
    },
    // TODO: constraints
    onAssignmentStructureMutation: function(assignmentStore, assignments) {
        var me = this;
        if (!this.isUndoingOrRedoing()) {
            Ext.Array.each([].concat(assignments), function(assignment) {
                var task = assignment.getTask(me);
                if (task) {
                    task.onAssignmentStructureMutation(assignment);
                }
            });
        }
    },
    /**
     * @protected
     * Returns true to suppress propagation on a particular dependency (or a dependency field) update.
     * By default returns `true` in the following cases:
     *
     * - {@link Gnt.model.Dependency#Id Id} field change;
     * - {@link Gnt.model.Dependency#Highlighted Highlighted} field change;
     * - {@link Gnt.model.Dependency#From From} field change caused by the corresponding task {@link Gnt.model.Task#Id Id} field change;
     * - {@link Gnt.model.Dependency#To To} field change caused by the corresponding task {@link Gnt.model.Task#Id Id} field change;
     * @param {Gnt.model.Dependency} dependency The updated dependency
     * @param {String[]} modifiedFields List of modified fields
     * @return {Boolean}
     */
    skipPropagationOnDependencyUpdate: function(dependency, modifiedFields) {
        var prev = dependency.previous,
            result = true,
            fromField = dependency.fromField,
            toField = dependency.toField,
            typeField = dependency.typeField,
            lagField = dependency.lagField,
            lagUnitField = dependency.lagUnitField;
        for (var field in prev) {
            switch (field) {
                // "From"/"To" fields change cause propagation except the case
                // when they got changed just because corresponding tasks have changed their Id-s
                // (happens when persisting tasks)
                case fromField:
                    var source = dependency.getSourceTask();
                    var sourcePrev = source && source.previous;
                    result = source && sourcePrev && sourcePrev[source.idProperty] == prev[field];
                    break;
                case toField:
                    var target = dependency.getTargetTask();
                    var targetPrev = target && target.previous;
                    result = target && targetPrev && targetPrev[target.idProperty] == prev[field];
                    break;
                // ... "Type"/"Lag" fields change causes propagation
                case typeField:
                case lagField:
                case lagUnitField:
                    result = false;
                    break;
            }
            if (!result)  {
                break;
            }
            
        }
        return result;
    },
    // TODO: in this "update" listener we launch propagation which is wrong
    // need to get rid of this code (propagation starting logic should
    // be triggered only in the gantt specific methods).
    // covered by 221_highlight_dependency
    onDependencyUpdate: function(store, dependency, operation, modifiedFields) {
        if (operation !== Ext.data.Model.COMMIT && !this.skipPropagationOnDependencyUpdate(dependency, modifiedFields)) {
            var me = this;
            // changing a dependency might cause total time span change
            me.resetTotalTimeSpanCache();
            // reset early late dates cache
            me.resetEarlyDates();
            me.resetLateDates();
            // If cascade changes is activated, adjust the connected task start/end date
            // but not if we are in the middle of propagation or undo/redo
            if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
                var extraTasksToReschedule = [];
                if (modifiedFields) {
                    var modified = dependency.modified,
                        task = dependency.getSourceTask() || dependency.getTargetTask(),
                        scheduleBackwards = task && task.getProjectScheduleBackwards() || me.scheduleBackwards,
                        relatedTaskId, relatedTask;
                    if (scheduleBackwards) {
                        // if the dependency source was changed
                        if (Ext.Array.contains(modifiedFields, dependency.fromField)) {
                            relatedTaskId = modified && modified[dependency.fromField];
                        }
                    } else {
                        // if the dependency target was changed
                        if (Ext.Array.contains(modifiedFields, dependency.toField)) {
                            relatedTaskId = modified && modified[dependency.toField];
                        }
                    }
                    // ..we get the old linked task and force its re-scheduling
                    relatedTask = relatedTaskId && me.getNodeById(relatedTaskId);
                    relatedTask && extraTasksToReschedule.push(relatedTask);
                }
                me.scheduleLinkedTasks([
                    dependency
                ], {
                    extraTasksToReschedule: extraTasksToReschedule.length && extraTasksToReschedule
                });
            }
        }
    },
    onDependenciesClear: function() {
        this.adjustToCalendar();
    },
    onDependenciesLoad: function() {
        // reset cached early/late dates
        this.resetEarlyDates();
        this.resetLateDates();
    },
    onDependencyAdd: function(store, dependencies) {
        var me = this;
        // changing a dependency might cause total time span change
        me.resetTotalTimeSpanCache();
        // reset early late dates cache
        me.resetEarlyDates();
        me.resetLateDates();
        // If cascade changes is activated, adjust the connected task start/end date
        // but not if we are in the middle of propagation or undo/redo
        if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
            me.scheduleLinkedTasks(dependencies);
        }
    },
    onDependencyDelete: function(store, dependencies) {
        var me = this;
        // changing a dependency might cause total time span change
        me.resetTotalTimeSpanCache();
        // reset early late dates cache
        me.resetEarlyDates();
        me.resetLateDates();
        // If cascade changes is activated, adjust the connected task start/end date
        // but not if we are in the middle of propagation or undo/redo
        if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
            var target,
                extraTasksToReschedule = [];
            // collect targets of the removed dependencies
            for (var i = 0; i < dependencies.length; i++) {
                target = dependencies[i].getTargetTask(me);
                target && extraTasksToReschedule.push(target);
            }
            me.scheduleLinkedTasks(dependencies, {
                extraTasksToReschedule: extraTasksToReschedule.length && extraTasksToReschedule
            });
        }
    },
    scheduleLinkedTasks: function(dependencies, options) {
        options = options || {};
        var me = this,
            extraTasks = options.extraTasksToReschedule || [];
        // TODO: the following is very fragile code in case any constraint is violated (and we switch to async
        // execution) we should not propagate changes here, all changes should be propagated using corresponding
        // task/dependency model interface (linkTo/unlinkFrom etc).
        // -- Maxim
        // If cascade changes is activated, adjust the connected task start/end date
        // but not if we are in the middle of propagation or undo/redo
        if (me.cascadeChanges && !me.suspendAutoCascade && !me.isUndoingOrRedoing()) {
            var sources = [],
                toReSchedule = [].concat(extraTasks);
            Ext.Array.each(dependencies, function(dependency) {
                var source = dependency.getSourceTask(me),
                    target = dependency.getTargetTask(me);
                if (source && target) {
                    if (source.getProjectScheduleBackwards()) {
                        sources.push(target);
                        target.isUnscheduled() && toReSchedule.push(target);
                        toReSchedule.push(source);
                    } else {
                        sources.push(source);
                        source.isUnscheduled() && toReSchedule.push(source);
                        toReSchedule.push(target);
                    }
                }
            });
            sources = sources.concat(extraTasks);
            sources.length && me.getRoot().propagateChanges(function() {
                Ext.Array.each(toReSchedule, function(task) {
                    task.markForRescheduling();
                });
                return sources;
            });
        }
    },
    forEachTaskUnordered: function(fn, scope) {
        var root = this.getRoot();
        if (root) {
            root.cascadeBy(function(rec) {
                if (rec !== root) {
                    return fn.call(scope || this, rec);
                }
            });
        }
    },
    forEachLeafTask: function(fn, scope, root) {
        root = root || this.getRoot();
        if (root) {
            root.cascadeBy(function(rec) {
                if (rec.isLeaf()) {
                    return fn.call(scope || this, rec);
                }
            });
        }
    },
    getTimeSpanForTasks: function(tasks) {
        var earliest = Sch.util.Date.MAX_VALUE,
            latest = Sch.util.Date.MIN_VALUE;
        var compareFn = function(r) {
                var startDate = r.getStartDate();
                var endDate = r.getEndDate();
                if (startDate && startDate < earliest) {
                    earliest = startDate;
                }
                // Ignore tasks without start date as they aren't rendered anyway
                if (startDate && endDate && endDate > latest) {
                    latest = endDate;
                }
            };
        if (tasks) {
            if (!Ext.isArray(tasks))  {
                tasks = [
                    tasks
                ];
            }
            
            Ext.Array.each(tasks, compareFn);
        } else {
            this.forEachTaskUnordered(compareFn);
        }
        earliest = earliest < Sch.util.Date.MAX_VALUE ? earliest : null;
        latest = latest > Sch.util.Date.MIN_VALUE ? latest : null;
        return {
            start: earliest,
            end: latest || (earliest && Ext.Date.add(earliest, Ext.Date.DAY, 1)) || null
        };
    },
    resetTotalTimeSpanCache: function() {
        this.lastTotalTimeSpan = null;
    },
    /**
     * Returns an object defining the earliest start date and the latest end date of all the tasks in the store.
     * Tasks without start date are ignored, tasks without end date use their start date (if any) + 1 day
     * @return {Object} An object with 'start' and 'end' Date properties.
     */
    getTotalTimeSpan: function() {
        if (this.lastTotalTimeSpan)  {
            return this.lastTotalTimeSpan;
        }
        
        this.lastTotalTimeSpan = this.getTimeSpanForTasks();
        return this.lastTotalTimeSpan;
    },
    // A hook used by the CrudManager to apply some extra info to the loaded store
    applyMetaData: function(metaData) {
        var projectStartDate = metaData.projectStartDate,
            projectEndDate = metaData.projectEndDate;
        if ('scheduleBackwards' in metaData) {
            this.setScheduleBackwards(metaData.scheduleBackwards, true);
        }
        // set project start date to the value provided from the server
        if (projectStartDate) {
            if ('string' == typeof projectStartDate) {
                metaData.projectStartDate = this.parseProjectDate(projectStartDate);
            }
            // we pass 2nd argument `true` since don't want automatic full rescheduling after the data loading
            this.setProjectStartDate(metaData.projectStartDate, true);
        }
        // set project end date to the value provided from the server
        if (projectEndDate) {
            if ('string' == typeof projectEndDate) {
                metaData.projectEndDate = this.parseProjectDate(projectEndDate);
            }
            // we pass 2nd argument `true` since don't want automatic full rescheduling after the data loading
            this.setProjectEndDate(metaData.projectEndDate, true);
        }
        if ('cascadeChanges' in metaData) {
            this.cascadeChanges = metaData.cascadeChanges;
        }
        this.metaData = metaData;
    },
    parseProjectDate: function(value) {
        return Ext.Date.parse(value, this.projectDateFormat);
    },
    /**
     * Sets the _project start date_.
     *
     * See also: {@link #projectStartDate} config.
     *
     * @param {Date} startDate The _project start date_.
     * @param {Boolean} [doNotReSchedule=false] Pass `true` to not reschedule tasks automatically (which happens by default when {@link #scheduleBackwards} is `false`).
     */
    setProjectStartDate: function(startDate, doNotReSchedule) {
        var me = this,
            oldStartDate = me.projectStartDate;
        // if dates differ
        if (!oldStartDate || oldStartDate - startDate) {
            me.projectStartDate = startDate;
            me.fireEvent('projectstartdateset', me, null, startDate, oldStartDate);
            if (!doNotReSchedule && !me.scheduleBackwards) {
                me.schedule(true);
            }
        }
    },
    /**
     * Sets the _project end date_.
     *
     * See also: {@link #projectEndDate} config.
     *
     * @param {Date} endDate The _project end date_.
     * @param {Boolean} [doNotReSchedule=false] Pass `true` to not reschedule tasks automatically (which happens by default when {@link #scheduleBackwards} is enabled).
     */
    setProjectEndDate: function(endDate, doNotReSchedule) {
        var me = this,
            oldEndDate = this.projectEndDate;
        // if dates differ
        if (!oldEndDate || oldEndDate - endDate) {
            this.projectEndDate = endDate;
            this.fireEvent('projectenddateset', this, null, endDate, oldEndDate);
            if (!doNotReSchedule && me.scheduleBackwards) {
                me.schedule(true);
            }
        }
    },
    /**
     * Returns the project start date. If the {@link projectStartDate project start date} is not set
     * the method returns the earliest start of all the tasks in the store.
     *
     * See also: {@link #projectStartDate} config.
     *
     * @return {Date} The project start date.
     */
    getProjectStartDate: function() {
        return this.projectStartDate || this.getTotalTimeSpan().start;
    },
    /**
     * Returns the project end date. This value is calculated as the latest end of all the tasks in the store.
     *
     * See also: {@link #projectEndDate} config.
     *
     * @return {Date} The project end date.
     */
    getProjectEndDate: function() {
        return this.projectEndDate || this.getTotalTimeSpan().end;
    },
    /**
     * Toggles scheduling from the project end date. In this mode all tasks begin as late as possible.
     * By default the mode is disabled and all tasks begin as soon as possible.
     * @param {Boolean} value Pass `true` to enable scheduling from the project end date.
     * @param {Boolean} [doNotReSchedule=false] Pass `true` to not reschedule tasks automatically.
     */
    setScheduleBackwards: function(value, doNotReSchedule) {
        if (this.scheduleBackwards != value) {
            this.scheduleBackwards = value;
            if (this.scheduleBackwards) {
                this.setProjectStartDate(null, true);
            } else {
                this.setProjectEndDate(null, true);
            }
            if (!doNotReSchedule)  {
                this.schedule();
            }
            
        }
    },
    schedule: function(resetCache, callback) {
        var me = this,
            root = me.getRoot(),
            // use root children as propagation sources
            sources = [].concat(root.childNodes);
        if (sources.length) {
            if (resetCache) {
                // reset early/late dates cache
                me.resetEarlyDates();
                me.resetLateDates();
            }
            // mark all the tasks as requiring rescheduling
            me.forEachTaskUnordered(function(task) {
                task.markForRescheduling();
            });
            // propagation will perform rescheduling
            root && root.propagateChanges(function() {
                return sources;
            }, callback);
        }
    },
    /**
     * Returns all projects kept in the store.
     * @return {Gnt.model.Project[]}
     */
    getProjects: function() {
        var root = this.getRoot(),
            projects = [],
            childNodes = root.childNodes;
        for (var i = 0,
            l = childNodes.length; i < l; i++) {
            if (childNodes[i].isProject) {
                projects.push(childNodes[i]);
            }
        }
        return projects;
    },
    // Internal helper method
    getTotalTaskCount: function(ignoreRoot) {
        var count = ignoreRoot === false ? 1 : 0;
        this.forEachTaskUnordered(function() {
            count++;
        });
        return count;
    },
    /**
     * Returns an array of all the tasks in this store.
     *
     * @return {Gnt.model.Task[]} The tasks currently loaded in the store
     */
    toArray: function() {
        var tasks = [];
        this.getRoot().cascadeBy(function(t) {
            tasks.push(t);
        });
        return tasks;
    },
    beginIndent: function(nodes, context) {
        this.fireEvent('beforeindentationchange', this, nodes, context);
    },
    endIndent: function(nodes, context) {
        this.fireEvent('indentationchange', this, nodes, context);
    },
    cancelIndent: function(context) {
        this.fireEvent('indentationcancel', this, context);
    },
    /**
     * Increase the indendation level of one or more tasks in the tree
     *
     * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to indent
     * @param {Function} [callback] Callback function to call after nodes have been indented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    indent: function(nodes, callback) {
        var me = this,
            canceled = false,
            affected = {},
            context, nodesToProcess;
        nodes = Ext.isArray(nodes) ? nodes.slice() : [
            nodes
        ];
        // 1. Filtering out all nodes which parents are also to be indented as well as the ones having no previous sibling
        //    since such nodes can't be indented
        nodes = Ext.Array.filter(nodes, function(node) {
            var result;
            result = !!node.previousSibling;
            while (result && !node.isRoot()) {
                result = !Ext.Array.contains(nodes, node.parentNode);
                node = node.parentNode;
            }
            return result;
        });
        // 2. Sorting nodes by index ascending, that's related on how task.indent() method actually indents
        nodes = Ext.Array.sort(nodes, function(a, b) {
            return a.get('index') - b.get('index');
        });
        // 3. Filter out project nodes
        nodes = Ext.Array.filter(nodes, function(record) {
            return !(record instanceof Gnt.model.Project);
        });
        // 4. Accumulating context
        context = Ext.Array.reduce(nodes, function(prev, curr) {
            prev[curr.getId()] = {
                parentNode: curr.parentNode,
                index: curr.get('index')
            };
            return prev;
        }, {});
        // 5. Indenting taking constraints related behaviour in mind
        me.beginIndent(nodes, context);
        me.suspendEvent('beforeindentationchange', 'indentationchange');
        nodesToProcess = nodes.slice();
        (function processStep() {
            if (nodesToProcess.length) {
                nodesToProcess.shift().indent(function(cancel, affectedNodes) {
                    if (!cancel) {
                        affected = Ext.apply(affected, affectedNodes);
                        processStep();
                    } else {
                        canceled = true;
                        affected = {};
                        me.resumeEvent('beforeindentationchange', 'indentationchange');
                        me.cancelIndent(context);
                    }
                });
            } else {
                me.resumeEvent('beforeindentationchange', 'indentationchange');
                me.endIndent(nodes, context);
                callback && callback(canceled, affected);
            }
        })();
    },
    /**
     * Decrease the indendation level of one or more tasks in the tree
     *
     * @param {Gnt.model.Task/Gnt.model.Task[]} tasks The task(s) to outdent
     * @param {Function} [callback] Callback function to call after task has been outdented and changes among dependent tasks was propagated.
     * @param {Boolean} callback.cancelChanges Flag showing that the setting has caused a constraint violation
     *  and a user opted for canceling the change and thus nothing has been updated.
     * @param {Object}   callback.affectedTasks Object containing a map (by id) of tasks affected by changes propagation.
     */
    outdent: function(nodes, callback) {
        var me = this,
            canceled = false,
            affected = {},
            context, nodesToProcess;
        nodes = Ext.isArray(nodes) ? nodes.slice() : [
            nodes
        ];
        // 1. Filtering out all nodes which parents are also to be outdented as well as the ones having root parent
        //    since such nodes can't be indented
        nodes = Ext.Array.filter(nodes, function(node) {
            var result;
            result = node.parentNode && !node.parentNode.isRoot();
            while (result && !node.isRoot()) {
                result = !Ext.Array.contains(nodes, node.parentNode);
                node = node.parentNode;
            }
            return result;
        });
        // 2. Sorting nodes by index descending, that's related on how task.outdent() method actually outdents
        nodes = Ext.Array.sort(nodes, function(a, b) {
            return b.get('index') - a.get('index');
        });
        // 3. Accumulating context
        context = Ext.Array.reduce(nodes, function(prev, curr) {
            prev[curr.getId()] = {
                parentNode: curr.parentNode,
                index: curr.get('index')
            };
            return prev;
        }, {});
        // 4. Outdenting taking constraints related behaviour in mind
        me.beginIndent(nodes, context);
        me.suspendEvent('beforeindentationchange', 'indentationchange');
        nodesToProcess = nodes.slice();
        (function processStep() {
            if (nodesToProcess.length) {
                nodesToProcess.shift().outdent(function(cancel, affectedNodes) {
                    if (!cancel) {
                        affected = Ext.apply(affected, affectedNodes);
                        processStep();
                    } else {
                        canceled = true;
                        affected = {};
                        me.resumeEvent('beforeindentationchange', 'indentationchange');
                        me.cancelIndent(context);
                    }
                });
            } else {
                me.resumeEvent('beforeindentationchange', 'indentationchange');
                me.endIndent(nodes, context);
                callback && callback(canceled, affected);
            }
        })();
    },
    /**
     * Returns the tasks associated with a resource
     * @param {Gnt.model.Resource} resource
     * @return {Gnt.model.Task[]} the tasks assigned to this resource
     */
    getTasksForResource: function(resource) {
        return this.getEventsForResource(resource);
    },
    /**
     * Returns the resources associated with a task
     * @param {Gnt.model.Task} task
     * @return {Gnt.model.Resource[]}
     */
    getResourcesForTask: function(task) {
        return this.getResourcesForEvent(task);
    },
    // Event store adaptions (flat store vs tree store)
    forEachScheduledEvent: function(fn, scope) {
        scope = scope || this;
        this.forEachTaskUnordered(function(event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();
            if (eventStart && eventEnd) {
                return fn.call(scope, event, eventStart, eventEnd);
            }
        });
    },
    onTasksSorted: function() {
        // After sorting we need to reapply filters if store was previously filtered
        if (this.lastTreeFilter) {
            this.filterTreeBy(this.lastTreeFilter);
        }
    },
    /**
     * Appends a new task to the store
     * @param {Gnt.model.Task/Object} record The record to append to the store
     * @return {Gnt.model.Task} The appended record
     */
    append: function(record) {
        return this.getRoot().appendChild(record);
    },
    notifyEarlyDatesReset: function() {
        this.fireEvent('earlydatesreset');
    },
    suspendEarlyDatesResetNotification: function() {
        this.earlyDatesResetNotificationSuspended++;
    },
    resumeEarlyDatesResetNotification: function(silent) {
        this.earlyDatesResetNotificationSuspended && this.earlyDatesResetNotificationSuspended--;
        if (!this.earlyDatesResetNotificationSuspended && this.earlyDatesResetNotificationRequested) {
            if (!silent)  {
                this.notifyEarlyDatesReset();
            }
            
            this.earlyDatesResetNotificationRequested = 0;
        }
    },
    resetEarlyDates: function(silent) {
        this.earlyDatesCache = {};
        if (!silent) {
            if (!this.earlyDatesResetNotificationSuspended) {
                this.notifyEarlyDatesReset();
            } else {
                this.earlyDatesResetNotificationRequested++;
            }
        }
    },
    notifyLateDatesReset: function() {
        this.fireEvent('latedatesreset');
    },
    suspendLateDatesResetNotification: function() {
        this.lateDatesResetNotificationSuspended++;
    },
    resumeLateDatesResetNotification: function(silent) {
        this.lateDatesResetNotificationSuspended && this.lateDatesResetNotificationSuspended--;
        if (!this.lateDatesResetNotificationSuspended && this.lateDatesResetNotificationRequested) {
            if (!silent)  {
                this.notifyLateDatesReset();
            }
            
            this.lateDatesResetNotificationRequested = 0;
        }
    },
    resetLateDates: function(silent) {
        this.lateDatesCache = {};
        if (!silent) {
            if (!this.lateDatesResetNotificationSuspended) {
                this.notifyLateDatesReset();
            } else {
                this.lateDatesResetNotificationRequested++;
            }
        }
    },
    setEarlyDateCachedValue: function(key, value) {
        this.earlyDatesCache[key] = value;
    },
    hasEarlyDateCachedValue: function(key) {
        return this.earlyDatesCache.hasOwnProperty(key);
    },
    getEarlyDateCachedValue: function(key) {
        return this.earlyDatesCache[key];
    },
    setLateDateCachedValue: function(key, value) {
        this.lateDatesCache[key] = value;
    },
    hasLateDateCachedValue: function(key) {
        return this.lateDatesCache.hasOwnProperty(key);
    },
    getLateDateCachedValue: function(key) {
        return this.lateDatesCache[key];
    },
    afterUndoRedo: function() {
        this.resetEarlyDates();
        this.resetLateDates();
        // call the default Robo.data.Store mixin implementation
        this.mixins['Gnt.data.undoredo.mixin.TaskStoreHint'].afterUndoRedo.call(this);
    },
    /**
     * Returns Task by sequential number. See {@link Gnt.model.Task#getSequenceNumber} for details.
     *
     * @param {Number} number
     *
     * @return {Gnt.model.Task}
     */
    getBySequenceNumber: function(number) {
        return this.getRoot().getBySequenceNumber(number);
    },
    destroy: function() {
        this.setCalendar(null);
        this.setCalendarManager(null);
        this.setAssignmentStore(null);
        this.setDependencyStore(null);
        this.setResourceStore(null);
        if (this.calendarManagerListeners) {
            this.calendarManagerListeners.destroy();
        }
        clearTimeout(this.cascadeTimer);
        clearTimeout(this.syncTimer);
        this.callParent(arguments);
    },
    linearWalkDependentTasks: function(sourceTaskList, processor, walkingSpecification) {
        var me = this,
            // TODO: in the future we need to handle the case when tasks belong to different projects
            scheduleBackwards = (Ext.isArray(sourceTaskList) ? sourceTaskList[0] : sourceTaskList).getProjectScheduleBackwards();
        walkingSpecification = walkingSpecification || {
            self: true,
            ancestors: me.recalculateParents,
            descendants: me.moveParentAsGroup,
            successors: me.cascadeChanges && !scheduleBackwards,
            predecessors: me.cascadeChanges && scheduleBackwards,
            cycles: me.cycleResolutionStrategy
        };
        return Gnt.data.Linearizator.linearWalkBySpecification(sourceTaskList, processor, walkingSpecification);
    },
    getLinearWalkingSequenceForDependentTasks: function(sourceTaskList, walkingSpecification) {
        var result = [];
        this.linearWalkDependentTasks(sourceTaskList, function(task, color, sourceSet, depsData) {
            result.push(Array.prototype.slice.call(arguments));
        }, walkingSpecification);
        return result;
    },
    // @override
    // ExtJS doesn't use getters in this method but we need to use them to take model projections into account.
    // We literally copied Ext.data.TreeStore.isVisible and replaced every node.data.* with node.get(*)
    isVisible: function(node) {
        var parentNode = node.parentNode,
            visible = node.get('visible'),
            root = this.getRoot();
        while (visible && parentNode) {
            visible = parentNode.get('expanded') && parentNode.get('visible');
            parentNode = parentNode.parentNode;
        }
        return visible && !(node === root && !this.getRootVisible());
    },
    /**
     * Removes tasks from the store, ignoring all readOnly tasks.
     * @param {[Gnt.model.Task]/Gnt.model.Task} tasks The task(s) to remove
     * @return {[Gnt.model.Task]} The removed records
     */
    removeTasks: function(tasks) {
        tasks = [].concat(tasks);
        // Don't allow removing readOnly tasks
        tasks = Ext.Array.filter(tasks, function(task) {
            return !task.parentNode || !task.parentNode.isReadOnly();
        });
        // Sorting tasks by depth, such that children were removed before parents, otherwise
        // undo manager might have difficulties restoring the hierarchy. If children are removed
        // after parents then undo manager will catch no notification about the removal, after parents
        // have been removed the undo manager has no control over tree detached hierarchy anymore.
        tasks = Ext.Array.sort(tasks, function(a, b) {
            return b.getDepth() - a.getDepth();
        });
        /*tasks.length > 1 && */
        this.fireEvent('beforebatchremove', this, tasks);
        Ext.Array.forEach(tasks, function(task) {
            //task.parentNode.removeSubtaskWithoutPropagation(task);
            task.remove();
        });
        /*tasks.length > 1 && */
        this.fireEvent('batchremove', this, tasks);
        return tasks;
    },
    isBackwardScheduled: function() {
        return this.backwardScheduling;
    },
    /**
     * @protected
     * Returns a list of constraint classes to validate before propagating the changes to the related tasks.
     * By default the list includes:
     *
     * - Gnt.constraint.implicit.PotentialConflict - (when {@link #checkPotentialConflictConstraint} is `true`) showing a warning when user sets a constraint on a task having a predecessor (which might cause a conflict in the future).
     *
     * @param  {Gnt.model.Task} task Task to validate constraints for.
     * @return {Gnt.constraint.Base[]} Array of constraints to validate.
     */
    getPrePropagationConstraints: function(task) {
        var result = [];
        if (this.prePropagationConstraints) {
            result = this.prePropagationConstraints;
        } else {
            result = [];
            this.checkPotentialConflictConstraint && task.getPotentialConflictConstraintClass() && result.push(task.getPotentialConflictConstraintClass());
            this.prePropagationConstraints = result;
        }
        return result;
    },
    /**
     * @private
     * Returns tasks that are meant to be scheduled contrary to the project scheduling direction.
     * If the store is scheduled forwards the method returns tasks having ALAP constraint set,
     * and if the store is scheduled backwards the method returns tasks constrained ASAP.
     * @param  {Gnt.model.Project} [project] Return only tasks belonging to the provided project.
     *  If not provided proceeds all the store tasks and uses {@link #scheduleBackwards} to define the project direction.
     * @return {Gnt.model.Task[]}         Array of tasks.
     */
    getContraryScheduledTasks: function(project) {
        var result = [],
            root = project || this.getRoot();
        root && root.cascadeBy(function(task) {
            if (task.isContraryScheduled(null, project))  {
                result.push(task);
            }
            
        });
        return result;
    },
    startInvalidatingProjectBorder: function(scheduleBackwards) {
        if (!arguments.length)  {
            scheduleBackwards = this.scheduleBackwards;
        }
        
        if (scheduleBackwards) {
            this.startDateIsInvalid = true;
        } else {
            this.endDateIsInvalid = true;
        }
    },
    finishInvalidatingProjectBorder: function(scheduleBackwards) {
        if (!arguments.length)  {
            scheduleBackwards = this.scheduleBackwards;
        }
        
        if (scheduleBackwards) {
            this.startDateIsInvalid = false;
        } else {
            this.endDateIsInvalid = false;
        }
    },
    isInvalidatingProjectStartDate: function() {
        return this.startDateIsInvalid;
    },
    isInvalidatingProjectEndDate: function() {
        return this.endDateIsInvalid;
    }
});

/**
 * @class Gnt.data.CrudManager
 * @aside guide gantt_crud_manager
 * @aside guide crud_manager
 *
 * A class implementing a central collection of all data stores related to the Gantt chart.
 * It allows you to load all stores in a single server request and persist all of their changes in one request as well. This
 *  helps you use a transactional 'all-or-nothing' approach to saving your data.
 * This class uses AJAX as a transport mechanism and JSON as the encoding format.
 *
 * # Gantt stores
 *
 * The class supports all the Gantt specific stores: resources, assignments, dependencies, calendars and tasks.
 * For these stores, the class has separate configs ({@link #resourceStore}, {@link #assignmentStore}, {@link #dependencyStore}, {@link #taskStore})
 * to register them. The class can also grab them from the task store (this behavior can be changed using {@link #addRelatedStores} config).
 *
 * ```javascript
 *     var taskStore = Ext.create('Gnt.data.TaskStore', {
 *         calendarManager : calendarManager,
 *         resourceStore   : resourceStore,
 *         dependencyStore : dependencyStore,
 *         assignmentStore : assignmentStore
 *     });
 *
 *     var crudManager = Ext.create('Gnt.data.CrudManager', {
 *         autoLoad        : true,
 *         // We specify TaskStore only. The rest stores will be taken from it.
 *         taskStore       : taskStore,
 *         transport       : {
 *             load    : {
 *                 url     : 'php/read.php'
 *             },
 *             sync    : {
 *                 url     : 'php/save.php'
 *             }
 *         }
 *     });
 * ```
 *
 * # Calendars
 *
 * The CrudManager class supports bulk loading of project calendars.
 * To do this, the {@link #calendarManager} config has to be specified or it can be specified on a {@link Gnt.data.TaskStore#calendarManager task store}
 * (while having {@link #addRelatedStores} is enabled).
 *
 * ```javascript
 *     var calendarManager   = Ext.create('Gnt.data.CalendarManager', {
 *         calendarClass   : 'Gnt.data.calendar.BusinessTime'
 *     });
 *
 *     ...
 *
 *     var taskStore     = Ext.create('MyTaskStore', {
 *         // taskStore calendar will automatically be set when calendarManager gets loaded
 *         calendarManager : calendarManager,
 *         resourceStore   : resourceStore,
 *         dependencyStore : dependencyStore,
 *         assignmentStore : assignmentStore
 *     });
 *
 *     var crudManager   = Ext.create('Gnt.data.CrudManager', {
 *         autoLoad        : true,
 *         taskStore       : taskStore,
 *         transport       : {
 *             load    : {
 *                 url     : 'php/read.php'
 *             },
 *             sync    : {
 *                 url     : 'php/save.php'
 *             }
 *         }
 *     });
 * ```
 *
 * # AJAX request configuration
 *
 * To configure AJAX request parameters please take a look at the {@link #transport} config.
 *
 * ```javascript
 *     var crudManager = Ext.create('Sch.data.CrudManager', {
 *         autoLoad        : true,
 *         taskStore       : taskStore,
 *         transport       : {
 *             load    : {
 *                 url         : 'php/read.php',
 *                 // use GET request
 *                 method      : 'GET',
 *                 // pass request JSON in "rq" parameter
 *                 paramName   : 'rq',
 *                 // extra HTTP request parameters
 *                 params      : {
 *                     foo     : 'bar'
 *                 }
 *             },
 *             sync    : {
 *                 url     : 'php/save.php'
 *             }
 *         }
 *     });
 * ```
 *
 *
 * # Extra stores
 *
 * Along with the Gantt specific stores any number of additional stores can be specified
 * using {@link #stores} config on a construction step or {@link #addStore} method in the runtime:
 *
 * ```javascript
 *     var crudManager = Ext.create('Gnt.data.CrudManager', {
 *         // extra stores
 *         stores          : [ 'departments', 'messages' ],
 *         taskStore       : taskStore,
 *         transport       : {
 *             load    : {
 *                 url     : 'php/read.php'
 *             },
 *             sync    : {
 *                 url     : 'php/save.php'
 *             }
 *         }
 *     });
 *
 *     // append 'documents' store
 *     crudManager.addStore('documents');
 *
 *     // now when we registered all the stores let's load them
 *     crudManager.load();
 * ```
 *
 * * **Note:** Any extra stores provided in {@link #stores} config will be loaded **before** the gantt specific stores.
 * If for some reason you need to change that loading order you should use {@link #addStore} method:
 *
 * ```javascript
 *     // append store3 to the end so it will be loaded last
 *     crudManager.addStore(store3);
 * ```
 *
 */
Ext.define('Gnt.data.CrudManager', {
    extend: 'Sch.crud.AbstractManager',
    mixins: [
        'Sch.crud.encoder.Json',
        'Sch.crud.transport.Ajax'
    ],
    requires: [
        'Gnt.data.CalendarManager',
        'Gnt.data.TaskStore'
    ],
    /**
     * @cfg {Gnt.data.CalendarManager/Object} calendarManager A calendar manager instance or its descriptor.
     */
    calendarManager: null,
    /**
     * @cfg {Gnt.data.TaskStore/String/Object} taskStore Tasks store or its descriptor or its identifier.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.DependencyStore/Object} dependencyStore A store with dependencies or its descriptor.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore/Object} resourceStore A store with resources or its descriptor.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore/Object} assignmentStore A store with assignments or its descriptor.
     */
    assignmentStore: null,
    /**
     * @cfg {Boolean} addRelatedStores
     * When set to `true` this class will try to get the {@link #calendarManager}, {@link #dependencyStore}, {@link #resourceStore} and {@link #assignmentStore} stores from
     * the specified {@link #taskStore} instance.
     */
    addRelatedStores: true,
    constructor: function(config) {
        config = config || {};
        var calendarManager = config.calendarManager || this.calendarManager,
            taskStore = config.taskStore || this.taskStore || new Gnt.data.TaskStore({
                proxy: 'memory'
            }),
            assignmentStore = config.assignmentStore || this.assignmentStore,
            resourceStore = config.resourceStore || this.resourceStore,
            dependencyStore = config.dependencyStore || this.dependencyStore,
            // list of stores to add
            stores = [];
        // retrieve stores registered on the provided taskStore
        if (config.addRelatedStores !== false) {
            var extracted = this.getTaskStoreInfo(taskStore, config);
            calendarManager = calendarManager || extracted.calendarManager;
            assignmentStore = assignmentStore || extracted.assignmentStore;
            resourceStore = resourceStore || extracted.resourceStore;
            dependencyStore = dependencyStore || extracted.dependencyStore;
        }
        // If calendar manager was not provided to crud manager or task store - it is still null at this point
        if (!calendarManager) {
            calendarManager = new Gnt.data.CalendarManager();
        }
        // Call this early manually to be able to add listeners before calling the superclass constructor
        this.mixins.observable.constructor.call(this, config);
        // calendars go first in the stores loading order
        this.addCalendarManager(calendarManager, stores);
        // ..then resources, assignments, dependencies and finally tasks
        if (resourceStore)  {
            stores.push(resourceStore);
        }
        
        if (assignmentStore)  {
            stores.push(assignmentStore);
        }
        
        if (dependencyStore)  {
            stores.push(dependencyStore);
        }
        
        if (taskStore)  {
            stores.push(taskStore);
        }
        
        if (stores.length) {
            var syncSequence = [];
            // For applying sync results we have a different order:
            // calendars -> resources -> tasks -> assignments -> dependencies
            if (calendarManager)  {
                syncSequence.push(calendarManager);
            }
            
            if (resourceStore)  {
                syncSequence.push(resourceStore);
            }
            
            if (taskStore)  {
                syncSequence.push(taskStore);
            }
            
            if (assignmentStore)  {
                syncSequence.push(assignmentStore);
            }
            
            if (dependencyStore)  {
                syncSequence.push(dependencyStore);
            }
            
            if (syncSequence.length) {
                config.syncApplySequence = (config.syncApplySequence || config.stores || []).concat(syncSequence);
            }
            var _stores = config.stores || this.stores;
            if (_stores && !Ext.isArray(_stores))  {
                _stores = [
                    _stores
                ];
            }
            
            // all the Gantt related stores will go after the user defined stores (specified in config.stores)
            config.stores = (_stores || []).concat(stores);
        }
        this.callParent([
            config
        ]);
        // make sure we have properties set to proper stores descriptors
        this.calendarManager = this.getStoreDescriptor(calendarManager);
        this.resourceStore = this.getStoreDescriptor(resourceStore);
        this.assignmentStore = this.getStoreDescriptor(assignmentStore);
        this.dependencyStore = this.getStoreDescriptor(dependencyStore);
        this.taskStore = this.getStoreDescriptor(taskStore);
        this.taskStore.store.setCalendarManager(calendarManager);
    },
    onBeforeIndentationChange: function() {
        this.suspendChangesTracking();
    },
    onIndentationChange: function() {
        this.resumeChangesTracking(true);
    },
    onBeforeBatchRemove: function() {
        this.suspendChangesTracking();
    },
    onBatchRemove: function() {
        this.resumeChangesTracking(true);
    },
    bindStoreListeners: function(store, un) {
        // task store has some extra events to listen
        if (store instanceof Gnt.data.TaskStore) {
            var listeners = {
                    beforeindentationchange: this.onBeforeIndentationChange,
                    indentationchange: this.onIndentationChange,
                    beforebatchremove: this.onBeforeBatchRemove,
                    batchremove: this.onBatchRemove,
                    scope: this
                };
            if (un) {
                this.mun(store, listeners);
            } else {
                this.mon(store, listeners);
            }
        }
        return this.callParent(arguments);
    },
    getTaskStoreInfo: function(taskStore, config) {
        if (!taskStore.isStore) {
            if (typeof taskStore == 'string') {
                taskStore = Ext.data.StoreManager.get(taskStore);
            } else {
                taskStore = taskStore.store;
            }
        }
        var result = {},
            calendarManager = config.calendarManager,
            assignmentStore = config.assignmentStore,
            resourceStore = config.resourceStore,
            dependencyStore = config.dependencyStore;
        if (!calendarManager)  {
            result.calendarManager = taskStore.calendarManager;
        }
        
        if (!assignmentStore)  {
            result.assignmentStore = taskStore.getAssignmentStore();
        }
        
        if (!resourceStore)  {
            result.resourceStore = taskStore.getResourceStore();
        }
        
        if (!dependencyStore)  {
            result.dependencyStore = taskStore.getDependencyStore();
        }
        
        return result;
    },
    addCalendarManager: function(calendarManager, stores) {
        var store, descriptor;
        if (calendarManager.isStore) {
            store = calendarManager;
            descriptor = {
                store: calendarManager
            };
        } else if (typeof calendarManager == 'object') {
            store = calendarManager.store;
            descriptor = calendarManager;
        } else {
            calendarManager = Ext.data.StoreManager.get(calendarManager);
            store = calendarManager;
            descriptor = {
                store: calendarManager
            };
        }
        var model = (store.getModel && store.getModel() || store.model).prototype;
        // register calendar manager sub-stores being kept in "Days" field
        if (!descriptor.stores) {
            descriptor.stores = [
                {
                    storeId: model.daysField,
                    idProperty: model.idProperty
                }
            ];
        }
        this.calendarManager = descriptor;
        // on calendar manager data loaded, we set the project calendar
        store.on('load', this.onCalendarManagerLoad, this);
        this.mon(store, {
            dayadd: this.onStoreChange,
            dayupdate: this.onStoreChange,
            dayremove: this.onStoreChange,
            daybulkremove: this.onStoreChange,
            scope: this
        });
        stores.push(descriptor);
    },
    onCalendarManagerLoad: function(store) {
        // if meteData is provided and it contains project calendar definition
        if (store.metaData && store.metaData.hasOwnProperty('projectCalendar')) {
            var projectCalendar = store.getProjectCalendar(),
                oldCalendarId = projectCalendar && projectCalendar.getCalendarId(),
                newCalendarId = store.metaData.projectCalendar;
            // if project calendar has changed
            if (oldCalendarId != newCalendarId) {
                store.setProjectCalendar(newCalendarId);
            }
        }
    },
    applyLoadResponse: function() {
        // let's ignore calendars events during data loading since we don't want tasks to get moved after stores loading
        var cm = this.getCalendarManager();
        cm && cm.suspendCalendarsEvents();
        this.callParent(arguments);
        if (cm) {
            cm.resumeCalendarsEvents();
            // Since we suspended calendar events the calendar caches stayed intact
            // so we need to reset them now .."resetCache" private method does it silently
            // since we don't want to trigger "adjustToCalendar" calls automatically (expensive operation on large datasets)
            Ext.Array.each(cm.getRoot().childNodes, function(node) {
                var c = node.getCalendar();
                if (c)  {
                    c.resetCache();
                }
                
            });
        }
    },
    /**
     * Returns the calendar manager bound to the crud manager.
     * @return {Gnt.data.CalendarManager} The calendar manager bound to the crud manager.
     */
    getCalendarManager: function() {
        return this.calendarManager && this.calendarManager.store;
    },
    /**
     * Returns the resource store bound to the crud manager.
     * @return {Gnt.data.ResourceStore} The resource store bound to the crud manager.
     */
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store;
    },
    /**
     * Returns the dependency store bound to the crud manager.
     * @return {Gnt.data.DependencyStore} The dependency store bound to the crud manager.
     */
    getDependencyStore: function() {
        return this.dependencyStore && this.dependencyStore.store;
    },
    /**
     * Returns the assignment store bound to the crud manager.
     * @return {Gnt.data.AssignmentStore} The assignment store bound to the crud manager.
     */
    getAssignmentStore: function() {
        return this.assignmentStore && this.assignmentStore.store;
    },
    /**
     * Returns the task store bound to the crud manager.
     * @return {Gnt.data.TaskStore} The task store bound to the crud manager.
     */
    getTaskStore: function() {
        return this.taskStore && this.taskStore.store;
    },
    // To make this compatible with Ext Scheduler
    getEventStore: function() {
        return this.taskStore && this.taskStore.store;
    },
    prepareUpdated: function(list, stores, storeInfo) {
        if (list[0] instanceof Gnt.model.Task) {
            // Root should not be updated since the gantt doesn't modify this (though Ext JS might)
            list = Ext.Array.filter(list, function(node) {
                return !node.isRoot();
            });
            var result = this.callParent([
                    list,
                    stores,
                    storeInfo
                ]);
            // if resetIdsBeforeSync mode is enabled and we deal with tasks
            // we need to reset ids for tasks segments as well
            if (this.resetIdsBeforeSync) {
                var segmentsField = list[0].segmentsField,
                    proto = Ext.ClassManager.get(list[0].segmentClassName).prototype,
                    idProperty = proto.idProperty,
                    phantomIdField = proto.phantomIdField;
                for (var i = 0; i < result.length; i++) {
                    var segmentsData = result[i][segmentsField];
                    if (segmentsData) {
                        for (var j = 0; j < segmentsData.length; j++) {
                            var segment = segmentsData[j];
                            if (segment[phantomIdField])  {
                                delete segment[idProperty];
                            }
                            
                        }
                    }
                }
            }
            return result;
        }
        return this.callParent(arguments);
    },
    prepareAdded: function(list) {
        var result = this.callParent(arguments);
        // if resetIdsBeforeSync mode is enabled and we deal with tasks
        // we need to reset ids for tasks segments as well
        if (this.resetIdsBeforeSync && list[0] instanceof Gnt.model.Task) {
            var segmentsField = list[0].segmentsField,
                idProperty = Ext.ClassManager.get(list[0].segmentClassName).prototype.idProperty;
            for (var i = 0; i < result.length; i++) {
                var segmentsData = result[i][segmentsField];
                if (segmentsData) {
                    for (var j = 0; j < segmentsData.length; j++) {
                        delete segmentsData[j][idProperty];
                    }
                }
            }
        }
        return result;
    },
    // Override AbstractManager method to get Segment field changes properly
    getRecordChangesStates: function(record, changes, stores, store) {
        if (record.isTaskSegment) {
            return this.getSegmentChangesStates(record);
        }
        return this.callParent(arguments);
    },
    // Extracts Segments field changes
    getSegmentChangesStates: function(record) {
        var task = record.getTask(),
            taskStore = task.getTaskStore(),
            storeInfo = this.getStoreDescriptor(taskStore),
            idProperty = record.idProperty,
            phantomIdField = storeInfo && storeInfo.phantomIdField || record.phantomIdField || this.phantomIdField,
            taskId = task.getId(),
            id = record.getId(),
            activeSync = this.activeRequests.sync;
        function findById(array, prop, value) {
            return array && Ext.Array.findBy(array, function(entry) {
                return entry[prop] == value;
            });
        }
        var sentChanges, currentChanges;
        // If we have info on the active sync operation
        if (activeSync) {
            var sentData = activeSync.pack[storeInfo.storeId],
                syncUpdated = sentData && sentData.updated,
                syncAdded = sentData && sentData.added,
                currentTaskChanges, sentTaskChanges;
            // Get current changes snapshot made before CM started applying the response
            var currentData = this._currentChangeSetPackage[storeInfo.storeId],
                currentUpdated = currentData && currentData.updated,
                currentAdded = currentData && currentData.added;
            // Get snapshot of the Task data sent to the server (if it was updated)
            sentTaskChanges = findById(syncUpdated, idProperty, taskId);
            // the task was updated and sent to the server
            if (sentTaskChanges) {
                // find sent Segments data
                sentChanges = findById(sentTaskChanges[task.segmentsField], idProperty, id);
                if (sentChanges) {
                    // get its current state
                    currentTaskChanges = findById(currentUpdated, idProperty, taskId);
                    currentChanges = findById(currentTaskChanges && currentTaskChanges[task.segmentsField], idProperty, id);
                }
            } else // ..no snapshot means the record could be sent to the server as added
            {
                // searching the Task data in sent added data
                sentTaskChanges = findById(syncAdded, phantomIdField, taskId);
                // the task was added and sent to the server
                if (sentTaskChanges) {
                    // find sent Segments data
                    sentChanges = findById(sentTaskChanges[task.segmentsField], phantomIdField, id);
                    if (sentChanges) {
                        // get its current state
                        currentTaskChanges = findById(currentAdded, phantomIdField, taskId);
                        currentChanges = findById(currentTaskChanges && currentTaskChanges[task.segmentsField], phantomIdField, id);
                    }
                }
            }
        }
        return {
            sent: sentChanges,
            current: currentChanges
        };
    },
    isSegmentsValueEqual: function(segments1, segments2) {
        if (!segments1 && !segments2)  {
            return true;
        }
        
        if ((!segments1 && segments2) || (segments1 && !segments2) || segments1.length != segments2.length) {
            return false;
        }
        for (var i = 0,
            l = segments1.length; i < l; i++) {
            var segment1 = segments1[i],
                segment2 = segments2[i];
            if (segment1.isInstance)  {
                segment1 = segment1.serialize();
            }
            
            if (segment2.isInstance)  {
                segment2 = segment2.serialize();
            }
            
            if (Ext.JSON.encode(segment1) != Ext.JSON.encode(segment2))  {
                return false;
            }
            
        }
        return true;
    },
    // Override AbstractManager method to treat Segments field properly
    isFieldValueEqual: function(record, field, value1, value2) {
        if (record.isTaskModel && (field == record.segmentsField || field.name == record.segmentsField)) {
            return this.isSegmentsValueEqual(value1, value2);
        }
        return this.callParent(arguments);
    },
    // Override AbstractManager method to tweak Segments field
    applyChangeToField: function(record, name, value, store) {
        // If that's a new value for a task "Segments" field
        if (record.isTaskModel && name == record.segmentsField) {
            var segments = record.getSegments(),
                phantomIdField = segments && segments[0].phantomIdField,
                idProperty = segments && segments[0].idProperty;
            // If the task is segmented we try to modify existing segments one by one
            if (segments && value) {
                // loop over transferred segments if any
                for (var i = value.length - 1; i >= 0; i--) {
                    // get transferred segment change
                    var segmentChange = value[i],
                        phantomId = segmentChange[phantomIdField],
                        id = segmentChange[idProperty],
                        segment = null;
                    // let's find corresponding segment to update
                    for (var j = 0; j < segments.length; j++) {
                        segment = segments[j];
                        // we detect it using either phantom or real id
                        if ((segment.get(phantomIdField) == phantomId) || (segment.getId() == id)) {
                            // let's apply transferred changes to found segment
                            this.applyChangesToRecord(segment, segmentChange);
                            break;
                        }
                    }
                }
                // TODO if match not found add a new segment passed from the server here
                return;
            }
        }
        // fallback to default behaviour
        return this.callParent(arguments);
    },
    // TODO keep applyChangesToTask hook since we mentioned it on the forum
    applyChangesToTask: function(record, changes) {},
    applyChangesToRecord: function(record, changes, stores) {
        // TODO keep applyChangesToTask hook since we mentioned it on the forum
        if (record.isTaskModel) {
            this.ignoreUpdates++;
            this.applyChangesToTask.apply(this, arguments);
            this.ignoreUpdates--;
        }
        this.callParent(arguments);
        if (!record.isPhantom() && record.data[record.phantomIdField])  {
            delete record.data[record.phantomIdField];
        }
        
    }
});

/**

@class Gnt.data.calendar.BusinessTime
@extends Gnt.data.Calendar

A class representing a customizable calendar with weekends, holidays and availability information for any day. 

This class is basically a subclass of {@link Gnt.data.Calendar}, configured for normal business hours availability, 
you can fine-tune its setting if needed. Default availability hours for every day are 08:00-12:00 and 13:00-17:00 
(can be configured with {@link #defaultAvailability} property.

See also {@link Gnt.data.Calendar} for additional information.

*/
Ext.define('Gnt.data.calendar.BusinessTime', {
    extend: 'Gnt.data.Calendar',
    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     * 
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth: 20,
    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     * 
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek: 5,
    /**
     * Number of hours per day. Will be used when converting the duration in days to hours.
     * 
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     * 
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay: 8,
    /**
     * @cfg {String[]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Gnt.model.CalendarDay}) for each working weekday (Monday-Friday). 
     */
    defaultAvailability: [
        '08:00-12:00',
        '13:00-17:00'
    ]
});

/**
 * This class keeps ids consistent inside undo/redo queues
 * @private
 */
Ext.define('Gnt.data.undoredo.IdConsistencyManager', {
    extend: 'Sch.data.util.IdConsistencyManager',
    getUpdateAssignmentEventIdFieldFn: function(assignmentStore, oldId, newId) {
        return function() {
            assignmentStore.each(function(assignment) {
                assignment.getEventId() == oldId && assignment.setEventId(newId);
            });
        };
    },
    getUpdateAssignmentResourceIdFieldFn: function(assignmentStore, oldId, newId) {
        return function() {
            assignmentStore.each(function(assignment) {
                assignment.getResourceId() == oldId && assignment.setResourceId(newId);
            });
        };
    },
    getUpdateDependencySourceTargedIdFieldFn: function(dependencyStore, oldId, newId) {
        return function() {
            dependencyStore.each(function(dependency) {
                dependency.getSourceId() == oldId && dependency.setSourceId(newId);
                dependency.getTargetId() == oldId && dependency.setTargetId(newId);
            });
        };
    }
});

/**
 * @class Gnt.data.undoredo.Manager
 * @extends Robo.Manager
 *
 * This class provides Gantt-aware undo-redo capabilities for the provided array of {@link Ext.data.Store} instances. To enable undo support for your Gantt chart stores, simply
 * create an UndoManager and configure it with your stores:
 *
 * ```
 *     var undoManager = new Gnt.data.undoredo.Manager({
 *         transactionBoundary : 'timeout',
 *         stores              : [
 *             taskStore,
 *             dependencyStore,
 *             ...
 *         ]
 *     });
 *
 *     undoManager.start();
 *
 *     yourStore.getAt(0).set('name', 'a new name');
 *
 *     undoManager.undo(); // Call 'undo' to revert last action
 * ```
 */
Ext.define('Gnt.data.undoredo.Manager', {
    extend: 'Robo.Manager',
    uses: [
        'Gnt.data.TaskStore',
        'Gnt.data.undoredo.IdConsistencyManager',
        'Gnt.data.undoredo.action.flat.Add',
        'Gnt.data.undoredo.action.flat.Remove',
        'Gnt.data.undoredo.action.taskstore.Update'
    ],
    idConsistencyManager: null,
    /**
     * @cfg {Gnt.data.CrudManager} crudManager
     * When provided, undo manager will start monitoring crud manager stores
     * and will correctly redo adding assignments/dependencies.
     */
    crudManager: null,
    constructor: function(config) {
        var crud = config.crudManager;
        if (crud) {
            config.stores = (config.stores || []).concat([
                crud.getCalendarManager(),
                crud.getTaskStore(),
                crud.getResourceStore(),
                crud.getAssignmentStore(),
                crud.getDependencyStore()
            ]);
            // Sync autoSync config, because it requires some additional logic on undomanager side
            config.autoSync = crud.autoSync;
            // Add idfield to ignored, we do not need to undo that
            config.ignoredFieldNames = Ext.apply(config.ignoredFieldNames || {}, {
                expanded: 1,
                Id: 1
            });
        }
        this.callParent([
            config
        ]);
        if (crud) {
            this.bindCrudManager(config.crudManager);
        }
    },
    bindCrudManager: function(crud) {
        var me = this;
        crud.on({
            beforesync: function() {
                me.pause();
            },
            sync: function() {
                me.resume();
            }
        });
    },
    bindStore: function(store) {
        // When task store is added to undoredo manager we need to initialize id consistency manager on that task store
        // to keep task ids in correct state inside redo queue
        // NOTE: This manager only support one task store!
        if (store instanceof Gnt.data.TaskStore) {
            this.idConsistencyManager && this.idConsistencyManager.destroy();
            this.idConsistencyManager = new Gnt.data.undoredo.IdConsistencyManager({
                eventStore: store,
                resourceStore: store.getResourceStore(),
                // these two stores will hold records removed from stores and existing in redo queue
                assignmentStore: new Ext.util.Collection(),
                dependencyStore: new Ext.util.Collection()
            });
        }
        this.callParent(arguments);
    },
    onFlatStoreAdd: function(store, records, index) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        if (this.idConsistencyManager) {
            // Dependency/assignment store contain records that are linked to tasks/resources.
            // When undoing/redoing task/resource id may change and that require us to
            // update corresponding records in the queues. To achieve that we provide
            // collection to the action, that is supposed to store all records affected
            // by action
            if (this.idConsistencyManager.getEventStore().getDependencyStore() === store) {
                this.currentTransaction.addAction(new Gnt.data.undoredo.action.flat.Add({
                    autoSync: this.autoSync,
                    store: store,
                    records: records,
                    index: index,
                    collection: this.idConsistencyManager.getDependencyStore()
                }));
            } else if (this.idConsistencyManager.getEventStore().getAssignmentStore() === store) {
                this.currentTransaction.addAction(new Gnt.data.undoredo.action.flat.Add({
                    autoSync: this.autoSync,
                    store: store,
                    records: records,
                    index: index,
                    collection: this.idConsistencyManager.getAssignmentStore()
                }));
            } else {
                this.callParent(arguments);
            }
        } else {
            this.callParent(arguments);
        }
    },
    onFlatStoreRemove: function(store, records, index, isMove) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        if (this.idConsistencyManager) {
            // Dependency/assignment store contain records that are linked to tasks/resources.
            // When undoing/redoing task/resource id may change and that require us to
            // update corresponding records in the queues. To achieve that we provide
            // collection to the action, that is supposed to store all records affected
            // by action
            if (this.idConsistencyManager.getEventStore().getDependencyStore() === store) {
                this.currentTransaction.addAction(new Gnt.data.undoredo.action.flat.Remove({
                    autoSync: this.autoSync,
                    store: store,
                    records: records,
                    index: index,
                    isMove: isMove,
                    collection: this.idConsistencyManager.getDependencyStore()
                }));
                this.idConsistencyManager.getDependencyStore().add(records);
            } else if (this.idConsistencyManager.getEventStore().getAssignmentStore() === store) {
                this.currentTransaction.addAction(new Gnt.data.undoredo.action.flat.Remove({
                    autoSync: this.autoSync,
                    store: store,
                    records: records,
                    index: index,
                    isMove: isMove,
                    collection: this.idConsistencyManager.getAssignmentStore()
                }));
                this.idConsistencyManager.getAssignmentStore().add(records);
            } else {
                this.callParent(arguments);
            }
        } else {
            this.callParent(arguments);
        }
    },
    getStoreTypeListeners: function(store) {
        var me = this,
            listeners = me.callParent([
                store
            ]);
        if (store instanceof Gnt.data.TaskStore) {
            listeners.update = me.onTaskStoreUpdate;
            listeners.projectionstart = me.onTaskStoreProjectionStart;
            listeners.projectioncommit = me.onTaskStoreProjectionEnd;
            listeners.projectionreject = me.onTaskStoreProjectionEnd;
        }
        return listeners;
    },
    onTaskStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        var me = this;
        if (!me.onAnyChangeInAnyStore(store) || operation !== 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !me.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        me.currentTransaction.addAction(new Gnt.data.undoredo.action.taskstore.Update({
            autoSync: me.autoSync,
            record: record,
            fieldNames: modifiedFieldNames.filter(function(field) {
                return !(field in me.ignoredFieldNames);
            })
        }));
    },
    onTaskStoreProjectionStart: function(store, projectionLevel) {
        var me = this;
        if (projectionLevel === 1 && me.transactionBoundary === 'timeout') {
            if (!me.currentTransaction) {
                // This will start an undo/redo transaction if one isn't started yet
                me.onAnyChangeInAnyStore(store);
            }
            if (me.currentTransaction) {
                me.hold();
            }
        }
    },
    onTaskStoreProjectionEnd: function(store, projection, data, projectionLevel) {
        var me = this;
        if (projectionLevel === 0 && me.transactionBoundary === 'timeout' && me.currentTransaction) {
            me.release();
        }
    }
});

Ext.define('Gnt.data.undoredo.action.flat.Add', {
    extend: 'Robo.action.flat.Add',
    // This collection holds records, removed from flat store. It provides convenient way to
    // update records (e.g. when we need to update links between entities in the undo/redo queue)
    collection: null,
    undo: function() {
        this.callParent();
        this.collection.add(this.records);
    },
    redo: function() {
        this.callParent();
        this.collection.remove(this.records);
    }
});

Ext.define('Gnt.data.undoredo.action.flat.Remove', {
    extend: 'Robo.action.flat.Remove',
    // This collection holds records, removed from flat store. It provides convenient way to
    // update records (e.g. when we need to update links between entities in the undo/redo queue)
    collection: null,
    undo: function() {
        this.callParent();
        this.collection.remove(this.records);
    },
    redo: function() {
        this.callParent();
        this.collection.add(this.records);
    }
});

/**
 * Special update action which knows how to properly store segments snapshot, works in conjuction with
 * {@link Gnt.data.undoredo.mixin.TaskStoreHint} which does actual segments snapshot in response upon undo/redo
 * transaction start
 */
Ext.define('Gnt.data.undoredo.action.taskstore.Update', {
    extend: 'Robo.action.tree.Update',
    uses: [
        'Ext.Array'
    ],
    processSavingOldValue: function(fieldName, record) {
        var me = this,
            value;
        if (fieldName == record.segmentsField) {
            value = record.getTaskStore().getOriginalSegmentsState(record);
        } else {
            value = me.callParent([
                fieldName,
                record
            ]);
        }
        return value;
    },
    processSavingNewValue: function(fieldName, record) {
        var me = this,
            value;
        if (fieldName === record.segmentsField) {
            value = record.buildSegmentsSnapshot();
        } else {
            value = me.callParent(arguments);
        }
        return value;
    },
    processRestoringValue: function(value, fieldName, record) {
        var me = this;
        if (fieldName == record.segmentsField) {
            record.rollbackSegmentsToSnapshot(value);
            value = me.self.CUSTOMLY_PROCESSED;
        } else {
            value = me.callParent(arguments);
        }
        return value;
    }
});

/**
 * @class Gnt.feature.DragCreator
 * @private
 *
 * An internal class which shows a drag proxy while clicking and dragging.
 * Create a new instance of this plugin
 */
Ext.define("Gnt.feature.DragCreator", {
    requires: [
        'Ext.Template',
        'Sch.util.DragTracker',
        'Gnt.Tooltip'
    ],
    /**
     * @cfg {Boolean} disabled true to start disabled
     */
    disabled: false,
    /**
     * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
     */
    showDragTip: true,
    /**
     * @cfg {Object} tooltipConfig A custom config object to apply to the {@link Gnt.Tooltip} instance.
     */
    tooltipConfig: null,
    /**
     * @cfg {Number} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started.
     */
    dragTolerance: 2,
    /**
     * @cfg {Ext.Template/String} template The HTML template shown when dragging to create new items
     */
    template: '<div class="sch-gantt-dragcreator-proxy"></div>',
    /**
     * @cfg {Function} validatorFn An empty function by default.
     * Provide to perform custom validation on the item being created.
     * @param {Ext.data.Model} record the resource for which the task is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the creation event is valid, else false to cancel
     */
    validatorFn: Ext.emptyFn,
    /**
    * @cfg {Object} validatorFnScope
    * The scope for the {@link #validatorFn}
    */
    validatorFnScope: null,
    start: null,
    end: null,
    constructor: function(config) {
        Ext.apply(this, config || {});
        this.init();
    },
    // private
    init: function() {
        var view = this.ganttView,
            gridViewBodyEl = view.el,
            bind = Ext.Function.bind;
        view.on({
            destroy: this.onGanttDestroy,
            scope: this
        });
        this.tracker = new Sch.util.DragTracker({
            el: gridViewBodyEl,
            tolerance: this.dragTolerance,
            onBeforeStart: bind(this.onBeforeDragStart, this),
            onStart: bind(this.onDragStart, this),
            onDrag: bind(this.onDrag, this),
            onEnd: bind(this.onDragEnd, this)
        });
        if (this.showDragTip) {
            this.dragTip = new Gnt.Tooltip(Ext.apply({
                mode: 'duration',
                cls: 'gnt-dragcreate-tip',
                gantt: view
            }, this.tooltipConfig));
        }
    },
    /**
    * Enables/disables the plugin
    * @param {Boolean} disabled True to disable this plugin
    */
    setDisabled: function(disabled) {
        this.disabled = disabled;
        if (this.dragTip) {
            this.dragTip.setDisabled(disabled);
        }
    },
    getProxy: function() {
        if (!this.proxy) {
            var containerEl = this.ganttView.up('tablepanel').el;
            if (!(this.template instanceof Ext.Template)) {
                this.template = new Ext.Template(this.template);
            }
            // Attach this element to the nested gantt panel element (view el is cleared by refreshes)
            this.proxy = this.template.append(containerEl, {}, true);
        }
        return this.proxy;
    },
    // private
    onBeforeDragStart: function(e) {
        var s = this.ganttView,
            t = e.getTarget('.' + s.timeCellCls, 2);
        if (t && !this.disabled) {
            var task = s.resolveTaskRecord(t);
            var dateTime = s.getDateFromDomEvent(e);
            if (!task.isReadOnly() && task.isLeaf() && !task.getStartDate() && !task.getEndDate() && s.fireEvent('beforedragcreate', s, task, dateTime, e) !== false) {
                e.stopEvent();
                // Save record if the user ends the drag outside the current row
                this.record = task;
                // Start time of the task to be created
                this.originalStart = dateTime;
                // Constrain the dragging within the current row schedule area
                this.rowRegion = s.getScheduleRegion(this.record, this.originalStart);
                // Save date constraints
                this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);
                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },
    // private
    onDragStart: function() {
        var me = this,
            view = me.ganttView,
            proxy = me.getProxy();
        me.start = me.originalStart;
        me.end = me.start;
        me.rowBoundaries = {
            top: me.rowRegion.top,
            bottom: me.rowRegion.bottom
        };
        proxy.setBox({
            x: me.tracker.startXY[0],
            y: me.rowBoundaries.top,
            height: me.rowBoundaries.bottom - me.rowBoundaries.top
        });
        proxy.show();
        view.fireEvent('dragcreatestart', view);
        if (me.showDragTip) {
            me.dragTip.enable();
            me.dragTip.updateContent(me.start, me.end, true, me.record);
            me.dragTip.showBy(proxy);
        }
    },
    // private
    onDrag: function(e) {
        var me = this,
            view = me.ganttView,
            dragRegion = me.tracker.getRegion().constrainTo(me.rowRegion),
            dates = view.getStartEndDatesFromRegion(dragRegion, 'round');
        if (!dates) {
            return;
        }
        me.start = dates.start || me.start;
        me.end = dates.end || me.end;
        var dc = me.dateConstraints;
        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }
        me.valid = me.validatorFn.call(me.validatorFnScope || me, me.record, me.start, me.end, e) !== false;
        if (me.showDragTip) {
            me.dragTip.updateContent(me.start, me.end, me.valid, me.record);
            me.dragTip.showBy(me.getProxy());
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        me.getProxy().setBox(dragRegion);
    },
    // private
    onDragEnd: function(e) {
        var me = this,
            view = me.ganttView,
            doFinalize = true;
        me.createContext = {
            start: me.start,
            end: me.end,
            e: e,
            record: me.record,
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        if (me.showDragTip) {
            me.dragTip.disable();
        }
        if (!me.start || !me.end || (me.end < me.start)) {
            me.valid = false;
        }
        if (me.valid) {
            doFinalize = view.fireEvent('beforedragcreatefinalize', me, me.createContext, e) !== false;
        }
        if (doFinalize) {
            me.finalize(me.valid);
        }
    },
    finalize: function(doCreate) {
        var me = this,
            context = me.createContext,
            view = me.ganttView;
        if (doCreate) {
            context.record.setStartEndDate(context.start, context.end, context.record.getTaskStore().skipWeekendsDuringDragDrop);
            view.fireEvent('dragcreateend', view, context.record, context.e);
        }
        me.proxy.hide();
        view.fireEvent('afterdragcreate', view);
    },
    onGanttDestroy: function() {
        // In case panel is destroyed while drag create is ongoing, the below date reset indicates to the onDragEnd that the drag was invalid
        // and there should be no side effect
        this.start = this.end = null;
        if (this.tracker) {
            this.tracker.destroy();
        }
        if (this.dragTip) {
            this.dragTip.destroy();
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
    }
});

/**
 * @class Gnt.feature.LabelEditor
 * @protected
 * @extends Ext.Editor
 *
 * Internal class used by the Gantt chart internals allowing inline editing of the task labels.
 */
Ext.define("Gnt.feature.LabelEditor", {
    extend: "Ext.Editor",
    /**
     * @cfg {String} labelPosition Identifies which side of task this editor is used for. Possible values: 'left', 'right', 'top' or 'bottom'.
     * @property
     */
    labelPosition: '',
    triggerEvent: 'dblclick',
    // private, must be supplied
    delegate: null,
    // The field name to edit - private, must be supplied
    dataIndex: null,
    shadow: false,
    completeOnEnter: true,
    cancelOnEsc: true,
    ignoreNoChange: true,
    ganttView: null,
    constructor: function(ganttView, config) {
        this.ganttView = ganttView;
        this.ganttView.on({
            afterrender: this.onGanttRender,
            destroy: this.onGanttDestroy,
            scope: this
        });
        // In 6.2.0 we make normal column unfocusable thus we need
        // to manually close editor on click in view
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            this.ganttView.on({
                itemclick: this.onGanttItemClick,
                scope: this
            });
        }
        Ext.apply(this, config);
        if (this.labelPosition === 'left') {
            this.alignment = 'r-r';
        } else if (this.labelPosition === 'right') {
            this.alignment = 'l-l';
        } else {
            // default for editor is c-c? (constrained)
            // which dosen't work in our case
            this.alignment = 'c-c';
        }
        this.delegate = '.sch-gantt-label-' + this.labelPosition;
        this.callParent([
            config
        ]);
    },
    onGanttItemClick: function() {
        this.completeEdit();
    },
    // Programmatically enter edit mode
    // Will use first instance of event
    edit: function(record) {
        if (!record.isEditable(this.dataIndex)) {
            return;
        }
        var elements = this.ganttView.getElementsFromEventRecord(record),
            eventEl = elements && elements[0];
        if (eventEl) {
            var wrap = eventEl.up(this.ganttView.eventWrapSelector);
            this.record = record;
            if (!this.rendered) {
                this.render(this.ganttView.getEl());
            }
            this.startEdit(wrap.down(this.delegate), this.dataIndex ? record.get(this.dataIndex) : '');
        }
    },
    onGanttRender: function(ganttView) {
        if (!this.field.width) {
            this.autoSize = 'width';
        }
        this.on({
            beforestartedit: function(editor, el, value) {
                return ganttView.fireEvent('labeledit_beforestartedit', ganttView, this.record, value, editor);
            },
            beforecomplete: function(editor, value, original) {
                return ganttView.fireEvent('labeledit_beforecomplete', ganttView, value, original, this.record, editor);
            },
            complete: function(editor, value, original) {
                this.record.set(this.dataIndex, value);
                ganttView.fireEvent('labeledit_complete', ganttView, value, original, this.record, editor);
            },
            scope: this
        });
        ganttView.el.on(this.triggerEvent, function(e, t) {
            this.edit(ganttView.resolveTaskRecord(t));
        }, this, {
            delegate: this.delegate
        });
    },
    onGanttDestroy: function() {
        this.destroy();
    }
});

/**
* @class Gnt.feature.ProgressBarResize
*
* Internal plugin enabling resizing of a task progress bar, configure this feature using the {@link Gnt.panel.Gantt#progressBarResizeConfig} config setting.
*/
Ext.define("Gnt.feature.ProgressBarResize", {
    requires: [
        'Ext.ToolTip',
        'Ext.resizer.Resizer'
    ],
    /**
    * @cfg {Boolean} useTooltip false to not show a tooltip while resizing. Defaults to true.
    */
    useTooltip: true,
    /**
    * @cfg {Number} increment
    * The increment in percent to use during a progress element resize
    */
    increment: 10,
    tip: null,
    resizable: null,
    ganttView: null,
    constructor: function(config) {
        Ext.apply(this, config || {});
        var g = this.ganttView;
        g.on({
            destroy: this.cleanUp,
            scope: this
        });
        g.el.on('mousedown', this.onMouseDown, this, {
            delegate: '.sch-gantt-progressbar-handle'
        });
        this.callParent(arguments);
    },
    onMouseDown: function(e, t) {
        var g = this.ganttView,
            rec = g.resolveTaskRecord(t);
        if (g.fireEvent('beforeprogressbarresize', g, rec) !== false) {
            var progBar = Ext.fly(t).prev('.sch-gantt-progress-bar');
            e.stopEvent();
            progBar.addCls('sch-progress-bar-resizing');
            this.resizable = this.createResizable(progBar, rec, e);
            g.fireEvent('progressbarresizestart', g, rec);
            // If the mouse isn't moved after mousedown, no resize event will be fired by the Ext.Resizable. Handle this case manually
            Ext.getBody().on('mouseup', this.onBodyMouseUp, this, {
                single: true,
                delay: 1
            });
        }
    },
    // private
    createResizable: function(el, taskRecord, e) {
        var rtl = this.ganttView.rtl,
            taskEl = el.up(this.ganttView.eventSelector),
            taskWidth = taskEl.getWidth() - 2 * this.ganttView.eventBorderWidth,
            widthIncrement = taskWidth * this.increment / 100;
        var rz = Ext.create('Ext.resizer.Resizer', {
                target: el,
                taskRecord: taskRecord,
                handles: rtl ? 'w' : 'e',
                minWidth: 0,
                maxWidth: taskWidth,
                minHeight: 1,
                widthIncrement: widthIncrement,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            });
        rz.resizeTracker.onMouseDown(e, rz[rtl ? 'west' : 'east'].dom);
        taskEl.addCls('sch-gantt-resizing');
        if (this.useTooltip) {
            this.tip = Ext.create("Ext.ToolTip", {
                autoHide: false,
                anchor: 'b',
                html: '%'
            });
            this.tip.setTarget(el);
            this.tip.update(taskRecord.getPercentDone() + '%');
            this.tip.show();
        }
        return rz;
    },
    // private
    partialResize: function(rz, newWidth) {
        var percent = Math.round(newWidth * 100 / (rz.maxWidth * this.increment)) * this.increment;
        if (this.tip) {
            this.tip.body.update(percent + '%');
        }
    },
    // private
    afterResize: function(rz, w, h, e) {
        var rec = rz.taskRecord;
        if (this.tip) {
            this.tip.destroy();
            this.tip = null;
        }
        var old = rz.taskRecord.getPercentDone();
        if (Ext.isNumber(w)) {
            var percent = Math.round(w * 100 / (rz.maxWidth * this.increment)) * this.increment;
            // Constrain between 0-100
            percent = Math.min(100, Math.max(0, percent));
            rz.taskRecord.setPercentDone(percent);
        }
        if (old === rz.taskRecord.getPercentDone()) {
            // Value didn't change, manually refresh the row
            this.ganttView.refreshNode(this.ganttView.indexOf(rz.taskRecord));
        }
        // Destroy resizable
        rz.destroy();
        this.resizable = null;
        this.ganttView.fireEvent('afterprogressbarresize', this.ganttView, rec);
    },
    // If the new percent done is the same as the old, no resize event will be fired by the Ext.Resizable. Handle this case manually
    onBodyMouseUp: function() {
        if (this.resizable) {
            this.afterResize(this.resizable);
        }
    },
    cleanUp: function() {
        if (this.tip) {
            this.tip.destroy();
        }
    }
});

//https://www.sencha.com/forum/showthread.php?321953-Ext-JS-resizer-sets-height-when-resizing-east-west&p=1314032#post1314032
Ext.define('Gnt.patches.ResizeTracker', {
    extend: 'Sch.util.Patch',
    target: 'Ext.resizer.ResizeTracker',
    minVersion: '6.5.0',
    overrides: {
        resize: function(box, atEnd) {
            var me = this,
                region = me.activeResizeHandle.region,
                target,
                setPosition = me.setPosition;
            // We are live resizing the target, or at the end: Size the target
            if (me.dynamic || (!me.dynamic && atEnd)) {
                // Resize the target
                if (setPosition) {
                    me.target.setBox(box);
                } else {
                    if (region === 'east') {
                        me.target.setWidth(box.width);
                    } else if (region === 'south') {
                        me.target.setHeight(box.height);
                    } else {
                        me.target.setSize(box.width, box.height);
                    }
                }
            }
            // In the middle of a resize - just resize the proxy
            if (!atEnd) {
                target = me.getProxy();
                if (target && target !== me.target) {
                    if (setPosition || me.hideProxy) {
                        target.setBox(box);
                    } else {
                        target.setSize(box.width, box.height);
                    }
                }
            }
        }
    }
});

/**
 @class Gnt.feature.TaskResize
 @extends Ext.util.Observable

 A plugin enabling the task resizing feature. Generally there's no need to manually create it,
 it can be activated with the {@link Gnt.panel.Gantt#taskResizeHandles} option of the gantt panel and configured with the {@link Gnt.panel.Gantt#resizeConfig}.


 */
Ext.define("Gnt.feature.TaskResize", {
    requires: [
        'Ext.resizer.Resizer',
        'Gnt.patches.ResizeTracker',
        'Gnt.Tooltip'
    ],
    constructor: function(config) {
        Ext.apply(this, config);
        var g = this.ganttView;
        g.on({
            destroy: this.onDestroy,
            scope: this
        });
        g.mon(g.el, 'mousedown', this.onMouseDown, this, {
            delegate: '.sch-resizable-handle'
        });
        this.callParent(arguments);
    },
    /**
     * @cfg {Boolean} showDuration true to show the duration instead of the end date when resizing a task
     */
    showDuration: true,
    /**
     * @type {Boolean} showExactResizePosition true to see exact task length during resizing
     */
    showExactResizePosition: false,
    /**
     * @cfg {Boolean} useTooltip `False` to not show a tooltip while resizing
     */
    useTooltip: true,
    /**
     * @cfg {Object} tooltipConfig A custom config object to apply to the {@link Gnt.Tooltip} instance.
     */
    tooltipConfig: null,
    /**
     * @cfg {Function} validatorFn An empty function by default.
     * Provide to perform custom validation on the item being resized.
     * @param {Ext.data.Model} record The task being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} isValid True if the creation event is valid, else false to cancel
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    taskRec: null,
    taskEl: null,
    isStart: null,
    ganttView: null,
    resizable: null,
    mouseDownEvent: null,
    handlePos: null,
    onMouseDown: function(e, t) {
        var ganttView = this.ganttView;
        var segmentNode = e.getTarget('.sch-gantt-task-segment');
        var taskNode = e.getTarget(ganttView.eventSelector);
        var taskRecord = ganttView.resolveTaskRecord(taskNode);
        // Check if we're resizing a split-task segment
        if (segmentNode) {
            taskNode = segmentNode;
            taskRecord = taskRecord.getSegment(parseInt(segmentNode.getAttribute('data-segmentIndex'), 10));
        }
        var isResizable = taskRecord.isResizable();
        // Don't trigger on right clicks
        if (e.button !== 0 || isResizable === false || typeof isResizable === 'string' && !taskNode.className.match(isResizable)) {
            return;
        }
        // Allow observers to abort the resize operation
        if (ganttView.fireEvent('beforetaskresize', ganttView, taskRecord, e) === false) {
            return;
        }
        e.stopEvent();
        this.mouseDownEvent = e;
        this.handlePos = this.getHandlePosition(t);
        this.taskEl = Ext.get(taskNode);
        this.taskRec = taskRecord;
        this.isStart = !!t.className.match('sch-resizable-handle-start');
        ganttView.el.on({
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            scope: this,
            single: true
        });
    },
    // private
    onMouseMove: function(e, t) {
        var g = this.ganttView,
            record = this.taskRec,
            taskEl = this.taskEl,
            rtl = g.rtl,
            isStart = this.isStart,
            isWest = (rtl && !isStart) || (!rtl && isStart),
            widthIncrement = g.getSnapPixelAmount(),
            currentWidth = taskEl.getWidth(),
            maxWidth, sibling;
        // Not all zoom levels support perfect snapping (e.g. in Month view we cannot snap to days)
        widthIncrement = Math.max(1, widthIncrement);
        var resizerConfig = {
                target: taskEl,
                record: record,
                isStart: isStart,
                isWest: isWest,
                handles: isWest ? 'w' : 'e',
                minHeight: 1,
                minWidth: widthIncrement,
                widthIncrement: widthIncrement,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            };
        if (record instanceof Gnt.model.TaskSegment && (sibling = this.taskEl.next('.sch-gantt-task-segment'))) {
            // Segment tasks in a split-task are constrained horizontally to the following segment border
            resizerConfig.maxWidth = rtl ? sibling.getRight() - taskEl.getRight() : sibling.getLeft() - taskEl.getLeft();
        }
        // Normal tasks, and last segment in a split-task are constrained to the row element
        resizerConfig.constrainRegion = taskEl.up(g.getItemSelector()).getRegion();
        taskEl.addCls('sch-gantt-resizing');
        this.ganttView.fireEvent('taskresizestart', this.ganttView, this.taskRec);
        // Since percent complete indicator uses fixed amount of pixels, we need to switch
        // it to use % during the resize operation (visual indication only)
        var progressBarEl = taskEl.down('.sch-gantt-progress-bar', true);
        if (progressBarEl) {
            Ext.fly(progressBarEl).setWidth(100 * Ext.fly(progressBarEl).getWidth() / taskEl.getWidth() + '%');
        }
        this.resizable = Ext.create('Ext.resizer.Resizer', resizerConfig);
        // HACK calling private method
        this.resizable.resizeTracker.onMouseDown(this.mouseDownEvent, this.resizable[isWest ? 'west' : 'east'].dom);
        this.resizable.resizeTracker.onMouseMove(e, this.resizable[this.handlePos].dom);
        if (this.useTooltip) {
            if (!this.tip) {
                this.tip = Ext.create(Ext.apply({
                    xclass: 'Gnt.Tooltip',
                    mode: this.showDuration ? 'duration' : 'startend',
                    gantt: this.ganttView,
                    constrainTo: this.ganttView.up('grid').el,
                    cls: 'gnt-resize-tip'
                }, this.tooltipConfig));
            } else {
                this.tip.enable();
            }
            this.tip.updateContent(record.getStartDate(), record.getEndDate(), true, record);
            this.tip.showBy(taskEl, e.getX());
            // Catch case of user not moving the mouse at all
            Ext.getBody().on('mouseup', function() {
                this.tip.disable();
            }, this, {
                single: true
            });
        }
    },
    onMouseUp: function(e, t) {
        var g = this.ganttView;
        g.el.un({
            mousemove: this.onMouseMove,
            mouseup: this.onMouseUp,
            scope: this,
            single: true
        });
        this.mouseDownEvent = null;
        // manually clean up any cached elements, https://app.assembla.com/spaces/bryntum/tickets/realtime_list?tickets_report_id=filter:u2231773&ticket=4997
        if (this.resizable) {
            this.resizable.east && this.resizable.east.destroy();
            this.resizable.west && this.resizable.west.destroy();
        }
    },
    // private
    partialResize: function(resizer, newWidth, oldWidth, e) {
        var ganttView = this.ganttView,
            isWest = resizer.isWest,
            task = resizer.record,
            el = resizer.el,
            cursorDate;
        cursorDate = ganttView.getDateFromCoordinate(resizer.isStart ? el.getLeft() : el.getRight(), this.showExactResizePosition ? null : 'round');
        var start, end, newDate;
        if (this.showExactResizePosition) {
            var adjustedDate = ganttView.timeAxis.roundDate(cursorDate, ganttView.snapRelativeToEventStartDate ? task.getStartDate() : false);
            adjustedDate = task.skipNonWorkingTime(adjustedDate, !task.isMilestone());
            var target = resizer.target.el,
                exactWidth;
            if (isWest) {
                start = task.skipNonWorkingTime(adjustedDate, !task.isMilestone());
                newDate = start;
                exactWidth = ganttView.timeAxisViewModel.getDistanceBetweenDates(start, task.getEndDate());
                target.setWidth(exactWidth);
                var offsetX = ganttView.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                target.setX(target.getX() + offsetX);
            } else {
                // to calculate endDate properly we have to clone task and set endDate
                var clone = Gnt.util.Data.cloneModelSet([
                        task
                    ])[0];
                var taskStore = task.getTaskStore();
                clone.setTaskStore(taskStore);
                clone.setCalendar(task.getCalendar());
                clone.setEndDateWithoutPropagation(adjustedDate, false, taskStore.skipWeekendsDuringDragDrop);
                end = clone.getEndDate();
                newDate = end;
                exactWidth = ganttView.timeAxisViewModel.getDistanceBetweenDates(task.getStartDate(), end);
                target.setWidth(exactWidth);
            }
        } else {
            start = resizer.isStart ? cursorDate : resizer.record.getStartDate();
            end = resizer.isStart ? resizer.record.getEndDate() : cursorDate;
            newDate = cursorDate;
        }
        resizer.date = newDate;
        ganttView.fireEvent('partialtaskresize', ganttView, task, start, end, resizer.el, e);
        // sometimes when you resize fast this.tip here is undefined
        // so checking just this.useTooltip is not enough
        if (this.useTooltip && this.tip) {
            var valid = this.validatorFn.call(this.validatorFnScope || this, task, start, end) !== false;
            this.tip.updateContent(start, end, valid, task);
        }
    },
    // private
    afterResize: function(resizer, w, h, e) {
        if (this.useTooltip) {
            this.tip.disable();
        }
        var me = this,
            record = resizer.record,
            oldStart = record.getStartDate(),
            oldEnd = record.getEndDate(),
            start = resizer.isStart ? resizer.date : oldStart,
            end = resizer.isStart ? oldEnd : resizer.date,
            ganttView = me.ganttView,
            modified = false,
            doFinalize = true;
        me.resizeContext = {
            record: record,
            start: start,
            end: end,
            oldStart: record.getStartDate(),
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        };
        if (start && end && (// Input sanity check
        start - oldStart || end - oldEnd) && // Make sure start OR end changed
        me.validatorFn.call(me.validatorFnScope || me, record, start, end, e) !== false) {
            doFinalize = ganttView.fireEvent('beforetaskresizefinalize', me, me.resizeContext, e) !== false;
            modified = true;
        } else {
            ganttView.refreshKeepingScroll();
        }
        if (doFinalize) {
            me.finalize(modified);
        }
    },
    finalize: function(updateRecord) {
        var me = this,
            view = me.ganttView,
            context = me.resizeContext,
            record = context.record,
            rowTask = record.task || record,
            // Make sure we tell the view to resize a record in its store, and not a segment
            skipWeekends = view.taskStore.skipWeekendsDuringDragDrop,
            previousDate, newDate;
        if (updateRecord) {
            // start <= end is "normal" case
            // start > end is case when task should be resized to 0
            if (context.start - context.oldStart !== 0) {
                previousDate = record.getStartDate();
                newDate = context.start <= context.end ? context.start : context.end;
                record.setStartDate(newDate, false, skipWeekends, function(cancelChanges, affectedTasks) {
                    newDate = record.getStartDate();
                    if (!(newDate < previousDate || newDate > previousDate)) {
                        view.refreshNode(view.store.indexOf(rowTask));
                    }
                    view.fireEvent('aftertaskresize', view, rowTask);
                });
            } else {
                previousDate = record.getEndDate();
                newDate = context.start <= context.end ? context.end : context.start;
                record.setEndDate(newDate, false, skipWeekends, function(cancelChanges, affectedTasks) {
                    newDate = record.getEndDate();
                    if (!(newDate < previousDate || newDate > previousDate)) {
                        view.refreshNode(view.store.indexOf(rowTask));
                    }
                    view.fireEvent('aftertaskresize', view, rowTask);
                });
            }
        } else {
            view.refreshNode(view.store.indexOf(rowTask));
            view.fireEvent('aftertaskresize', view, rowTask);
        }
        // Destroy resizable
        me.resizable.destroy();
        me.resizable = null;
        me.resizeContext = null;
    },
    getHandlePosition: function(node) {
        var isStart = node.className.match('start');
        if (this.ganttView.rtl) {
            return isStart ? 'east' : 'west';
        }
        return isStart ? 'west' : 'east';
    },
    onDestroy: function() {
        if (this.tip) {
            this.tip.destroy();
        }
        this.mouseDownEvent = null;
    }
});

/**
 * Helper class for asynchronous drop processing.
 *
 * @class Gnt.feature.taskdd.AsyncDropHandler
 */
Ext.define("Gnt.feature.taskdd.AsyncDropHandler", {
    $resolveFn: null,
    $rejectFn: null,
    $processFn: null,
    $canceled: false,
    $waiting: false,
    $done: false,
    /**
     * @param {Function} resolve Function to call when {@link #done} method is called
     * @param {Function} reject  Function to call when {@link #cancel} method is called
     * @param {Function} process Function to call when {@link #process} method is called
     *
     * @private
     */
    constructor: function(resolve, reject, process) {
        var me = this;
        me.$resolveFn = resolve;
        me.$rejectFn = reject;
        me.$processFn = process;
    },
    /**
     * Checks whether drop processing is in progress
     *
     * @return {Boolean}
     */
    isWaiting: function() {
        return this.$waiting;
    },
    /**
     * Call to postpone custom or default drop processing.
     *
     * If method is called then call to {@link #done} or {@link #cancel} is mandatory afterwards
     */
    wait: function() {
        this.$waiting = true;
    },
    /**
     * Checks whether drop processing has been done
     *
     * @return {Boolean}
     */
    isDone: function() {
        return this.$done;
    },
    /**
     * Call to finilize drop processing
     *
     * @param {Mixed} result Done result
     */
    done: function(result) {
        var me = this;
        if (!me.$done && !me.$canceled) {
            me.$waiting = false;
            me.$done = true;
            me.$resolveFn(result);
        }
    },
    /**
     * Checks whether drop processing has been canceled
     *
     * @return {Boolean}
     */
    isCanceled: function() {
        return this.$canceled;
    },
    /**
     * Call to cancel drop processing.
     *
     * @param {Mixed} result Cancel result
     */
    cancel: function(result) {
        var me = this;
        if (!me.$canceled && !me.$done) {
            me.$waiting = false;
            me.$canceled = true;
            me.$rejectFn(result);
        }
    },
    /**
     * Call to initiate default drop processing.
     */
    process: function() {
        return this.$processFn();
    }
});

/**
 * Special status proxy class capable of being attached to any element on the page. The parent class allows attaching
 * to body only.
 */
Ext.define('Gnt.feature.taskdd.Proxy', {
    extend: 'Ext.dd.StatusProxy',
    alias: 'widget.gnt-task-ddproxy',
    config: {
        /**
         * @cfg {Ext.dom.Element|HTMLElement|String} Element or node or node id to force attach to
         */
        forceAttachTo: null
    },
    shadow: false,
    forceStatusProc: null,
    lastRecievedStatus: null,
    destroy: function() {
        var me = this;
        me.callParent();
        if (me.forceStatusProc) {
            clearTimeout(me.forceStatusProc);
            me.forceStatusProc = null;
        }
    },
    applyForceAttachTo: function(el) {
        if (el) {
            el = Ext.get(el);
            if (el.dom == Ext.getBody().dom) {
                el = null;
            }
        }
        return el;
    },
    updateForceAttachTo: function(el, oldEl) {
        this.forceAttach(el);
    },
    forceAttach: function(containerEl) {
        var me = this,
            el, pageXY, localXY;
        if (me.rendered) {
            el = me.getEl();
            containerEl = containerEl || Ext.getBody();
            pageXY = me.getXY();
            localXY = containerEl.translatePoints(pageXY);
            el.hide();
            containerEl.appendChild(el);
            el.setLocalXY(localXY.left, localXY.top);
            !me.hidden && el.show();
        }
    },
    /**
     * @inheritdoc
     */
    ensureAttachedToBody: function(runLayout) {},
    // do nothing for now
    /**
     * @inheritdoc
     */
    afterRender: function() {
        var me = this;
        me.callParent();
        me.forceAttach(me.getForceAttachTo());
    },
    /**
     * Returns task element inside proxy ghost.
     *
     * @return {HTMLElement|null}
     */
    getTaskGhostEl: function() {
        return Ext.fly(this.getGhost()).first(null, true);
    },
    /**
     * @inheritdoc
     *
     * Overriden to support status forcing
     */
    setStatus: function(status) {
        var me = this;
        if (me.forceStatusProc) {
            me.lastRecievedStatus = status;
        } else {
            me.callParent([
                status
            ]);
        }
    },
    /**
     * @inheritdoc
     *
     * Overriden to support status forcing cleanup
     */
    reset: function(clearGhost) {
        var me = this;
        if (me.forceStatusProc) {
            clearTimeout(me.forceStatusProc);
            me.lastRecievedStatus = null;
            me.forceStatusProc = null;
        }
        me.callParent([
            clearGhost
        ]);
    },
    /**
     * Sets proxy status and forces it to stay for given time span.
     *
     * After time span ends proxy switches to last recieved via {@link #setStatus}() status
     */
    forceStatus: function(status, timeSpanMs) {
        var me = this;
        if (!me.forceStatusProc) {
            me.lastRecievedStatus = me.dropStatus;
            me.setStatus(status);
            me.forceStatusProc = Ext.Function.defer(function() {
                me.forceStatusProc = null;
                me.setStatus(me.lastRecievedStatus);
            }, timeSpanMs || 100);
        }
    }
});

/**
 * @class Gnt.feature.taskdd.DropZone
 * @extends Ext.dd.DropZone
 *
 * Special drop zone class handling drops on task scheduling view. The class delegates actual drop handling to other
 * parties capable of listening to {@link Gnt.view.Gantt gantt view} or it's relays.
 */
Ext.define('Gnt.feature.taskdd.DropZone', function(thisClass) {
    function withCanHandleDropQuery(me, gantt, eventName, args, onCanHandle, onCantHandle) {
        var handlersCount = 0,
            handlersCls = [],
            canHandleDrop = function(proxyCls) {
                ++handlersCount;
                proxyCls && handlersCls.push(proxyCls);
            };
        gantt.hasListeners[eventName] && gantt.fireEvent.apply(gantt, [].concat(eventName, args, canHandleDrop));
        handlersCls = handlersCls.length && handlersCls.join(' ') || me.dropAllowed;
        return handlersCount > 0 ? (onCanHandle ? onCanHandle(handlersCls) : handlersCls) : (onCantHandle ? onCantHandle() : me.dropNotAllowed);
    }
    return {
        extend: 'Ext.dd.DropZone',
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt
             */
            gantt: null,
            /**
             * @cfg {Gnt.feature.taskdd.DragZone} ownerDragZone
             */
            ownerDragZone: null
        },
        scrollDetacher: null,
        lastOverEvent: null,
        /**
         * @inheritdoc
         */
        constructor: function(el, config) {
            var me = this;
            me.callParent([
                el,
                config
            ]);
            me.initConfig(config);
        },
        /**
         * @inheritdoc
         */
        destroy: function() {
            var me = this;
            me.setOwnerDragZone(null);
            me.callParent();
        },
        updateOwnerDragZone: function(newDragZone, oldDragZone) {
            var me = this;
            if (me.scrollDetacher) {
                Ext.destroy(me.scrollDetacher);
                me.scrollDetacher = null;
            }
            if (newDragZone) {
                me.scrollDetacher = Ext.fly(me.getEl()).on('scroll', me.onDropZoneElementScroll, me, {
                    destroyable: true
                });
            }
        },
        onDropZoneElementScroll: function(e) {
            var me = this,
                dragZone = me.getOwnerDragZone();
            if (dragZone.dragging && me.lastOverNode) {
                dragZone.getProxy().setStatus(me.notifyOver(dragZone, me.lastOverEvent, dragZone.dragData));
            }
        },
        /**
         * @inheritdoc
         */
        getTargetFromEvent: function(e) {
            return e.getTarget(this.getGantt().getItemSelector());
        },
        /**
         * @inheritdoc
         */
        onNodeEnter: function(target, dragSource, e, data) {
            var me = this,
                gantt = me.getGantt();
            /**
             * @event 'task-row-drag-enter'
             * @member Gnt.view.Gantt
             *
             * Fires when dragging operation enter a task row.
             *
             * @param {Gnt.view.Gantt} ganttView   Gantt component view instance
             * @param {HTMLElement} target         HTML element the operation is detected over
             * @param {Ext.dd.DragZone} dragSource Dragging initiated drag source instance
             * @param {Object} data                Data returned by drag source getDragData() method
             * @param {Object} e                   Event object
             */
            gantt.hasListeners['task-row-drag-enter'] && gantt.fireEvent('task-row-drag-enter', gantt, target, dragSource, data, e);
        },
        /**
         * @inheritdoc
         */
        onNodeOut: function(target, dragSource, e, data) {
            var me = this,
                gantt = me.getGantt();
            /**
             * @event 'task-row-drag-out'
             * @member Gnt.view.Gantt
             *
             * Fires when dragging operation exits a task row.
             *
             * @param {Gnt.view.Gantt} ganttView   Gantt component view instance
             * @param {HTMLElement} target         HTML element the operation is detected over
             * @param {Ext.dd.DragZone} dragSource Dragging initiated drag source instance
             * @param {Object} data                Data returned by drag source getDragData() method
             * @param {Object} e                   Event object
             */
            gantt.hasListeners['task-row-drag-out'] && gantt.fireEvent('task-row-drag-out', gantt, target, dragSource, data, e);
            if (!me.getEl().contains(e.getTarget())) {
                /**
                 * @event 'schedule-drag-out'
                 * @member Gnt.view.Gantt
                 *
                 * Fires when dragging operation exits the gantt view
                 *
                 * @param {Gnt.view.Gantt} ganttView   Gantt component view instance
                 * @param {Ext.dd.DragZone} dragSource Dragging initiated drag source instance
                 * @param {Object} data                Data returned by drag source getDragData() method
                 * @param {Object} e                   Event object
                 */
                gantt.hasListeners['schedule-drag-out'] && gantt.fireEvent('schedule-drag-out', gantt, dragSource, data, e);
            }
        },
        /**
         * @inheritdoc
         */
        onNodeOver: function(target, dragSource, e, data) {
            var me = this,
                gantt = me.getGantt();
            me.lastOverEvent = e;
            /**
             * @event 'task-row-drag-over'
             * @member Gnt.view.Gantt
             *
             * Contantly fires while dragging operation is over a task row.
             *
             * @param {Gnt.view.Gantt} ganttView        Gantt component view instance
             * @param {HTMLElement} target              HTML element the operation is detected over
             * @param {Ext.dd.DragZone} dragSource      Dragging initiated drag source instance
             * @param {Object} data                     Data returned by drag source getDragData() method
             * @param {Object} e                        Event object
             * @param {Function} canHandleDrop          Function to call if drop zone can handle the drop
             * @param {String} [canHandleDrop.proxyCls] Status proxy CSS class to add to drag proxy
             */
            return withCanHandleDropQuery(me, gantt, 'task-row-drag-over', [
                gantt,
                target,
                dragSource,
                data,
                e
            ]);
        },
        /**
         * @inheritdoc
         */
        onNodeDrop: function(target, dragSource, e, data) {
            var me = this,
                gantt = me.getGantt(),
                result = false;
            withCanHandleDropQuery(me, gantt, 'task-row-drag-over', [
                gantt,
                target,
                dragSource,
                data,
                e
            ], function onCanHandleDrop() {
                /**
                     * @event 'task-row-drag-drop'
                     * @member Gnt.view.Gantt
                     *
                     * Fires when drag drop happens over a task row.
                     *
                     * @param {Gnt.view.Gantt} ganttView   Gantt component view instance
                     * @param {HTMLElement} target         HTML element the operation is detected over
                     * @param {Ext.dd.DragZone} dragSource Dragging initiated drag source instance
                     * @param {Object} data                Data returned by drag source getDragData() method
                     * @param {Object} e                   Event object
                     */
                gantt.hasListeners['task-row-drag-drop'] && gantt.fireEvent('task-row-drag-drop', gantt, target, dragSource, data, e);
                result = true;
            });
            return result;
        },
        /**
         * @inheritdoc
         */
        onContainerOver: function(dragSource, e, data) {
            var me = this,
                gantt = me.getGantt();
            /**
             * @event 'schedule-drag-over'
             * @member Gnt.view.Gantt
             *
             * Contantly fires while dragging operation is not over a task row but is inside the gantt view.
             *
             * @param {Gnt.view.Gantt} ganttView        Gantt component view instance
             * @param {Ext.dd.DragZone} dragSource      Dragging initiated drag source instance
             * @param {Object} data                     Data returned by drag source getDragData() method
             * @param {Object} e                        Event object
             * @param {Function} canHandleDrop          Function to call if drop zone can handle the drop
             * @param {String} [canHandleDrop.proxyCls] Status proxy CSS class to add to drag proxy
             */
            return withCanHandleDropQuery(me, gantt, 'schedule-drag-over', [
                gantt,
                dragSource,
                data,
                e
            ]);
        },
        /**
         * @inheritdoc
         */
        onContainerDrop: function(dragSource, e, data) {
            var me = this,
                gantt = me.getGantt(),
                result = false;
            withCanHandleDropQuery(me, gantt, 'schedule-drag-over', [
                gantt,
                dragSource,
                data,
                e
            ], function onCanHandleDrop() {
                /**
                     * @event 'schedule-drag-drop'
                     * @member Gnt.view.Gantt
                     *
                     * Fires when drag drop happens over a gantt view but not within any view's task rows.
                     *
                     * @param {Gnt.view.Gantt} ganttView   Gantt component view instance
                     * @param {Ext.dd.DragZone} dragSource Dragging initiated drag source instance
                     * @param {Object} data                Data returned by drag source getDragData() method
                     * @param {Object} e                   Event object
                     */
                gantt.hasListeners['schedule-drag-drop'] && gantt.fireEvent('schedule-drag-drop', gantt, dragSource, data, e);
                result = true;
            });
            return result;
        }
    };
});

/**
 * @class Gnt.feature.taskdd.plugin.InRowTaskDragDrop
 *
 * In row task drag & drop plugin.
 */
Ext.define('Gnt.feature.taskdd.plugin.InRowTaskDragDrop', function(thisClass) {
    function positionTaskElement(gantt, taskEl, startDate, endDate) {
        var startX = Ext.isDate(startDate) ? gantt.getCoordinateFromDate(startDate, false) : startDate,
            endX = Ext.isDate(endDate) ? gantt.getCoordinateFromDate(endDate, false) : endDate;
        Ext.fly(taskEl).setX(startX);
        Ext.fly(taskEl).setWidth(endX - startX);
    }
    function withSnappedTaskCoordinates(currentPointX, startPointDate, task, gantt, showExactDropPosition, snapRelativeToEventStartDate, skipWeekendsDuringDragDrop, skipWeekendsFn, doFn) {
        var result = false,
            ltr = !gantt.rtl,
            //!gantt.shouldAdjustForRtl(), // NOTE: shouldAdjustForRtl() is either not reliable or handles different case
            //       it returns true in tests, but false in demos, regardless of Gantt's rtl : true setting
            currentPointDate, timeDiffMs, timeAxisStartDate, timeAxisEndDate, newStartDate, newEndDate, newStartDateX, newEndDateX, viewWidth;
        // Calculating current pointer date from its X coordinate to be able to calculate time shift
        // the pointer movement represents
        currentPointDate = gantt.getDateFromCoordinate(currentPointX);
        timeDiffMs = currentPointDate - startPointDate;
        // Now calculating new start date
        newStartDate = Sch.util.Date.add(task.getStartDate(), Sch.util.Date.MILLI, timeDiffMs);
        // If showing exact drop position is requested
        if (showExactDropPosition) {
            // Skip non working time
            if (skipWeekendsDuringDragDrop) {
                newStartDate = skipWeekendsFn.call(this, task, newStartDate);
            }
            // Rounding new start date value using timeaxis which will also snap the date rounded to gantt's
            // snap pixel amount
            newStartDate = gantt.timeAxis.roundDate(newStartDate, snapRelativeToEventStartDate ? task.getStartDate() : false);
            // Skip non working time again after date is rounded
            if (skipWeekendsDuringDragDrop) {
                newStartDate = skipWeekendsFn.call(this, task, newStartDate);
            }
            // WARNING: calling private method, but the same has been done in original/non-refactored
            //          Gnt.features.TaskDragDrop code, so don't blame me.
            newEndDate = task.recalculateEndDate(newStartDate);
        } else {
            // in this branch we don't need to adjust drag proxy position and dimensions
            // position will be updated by drop source, and dimensions can't change here
            // NOTE: this simplistic "newEnddate" calculation is not accurate since it doesn't take into account non-working days. Though it's not critical until someone complains
            // We calculate end date here just for the tooltip
            if (task.isSegmented()) {
                newEndDate = Sch.util.Date.add(newStartDate, Sch.util.Date.MILLI, task.getLastSegment().getEndOffset());
            } else {
                newEndDate = Sch.util.Date.add(newStartDate, task.getDurationUnit(), task.getDuration());
            }
        }
        timeAxisStartDate = gantt.timeAxis.getStart();
        timeAxisEndDate = gantt.timeAxis.getEnd();
        // Calculating new start / end horizontal coordinates, which always should be within visible time span
        // NOTE: We need page coordinates here, they are usually passed to DragZone#alignElWithMouse()
        //       via DragZone::setDragElPos() later on
        if (Sch.util.Date.betweenLesser(newStartDate, timeAxisStartDate, timeAxisEndDate)) {
            // Milestone tasks has additional offset that we should respect
            newStartDateX = gantt.getCoordinateFromDate(newStartDate, false) - gantt.getXOffset(task);
        } else {
            // If we show exact position and new start date is out of view's right bound - use time axis end date
            // as new start X.
            if (showExactDropPosition && timeAxisEndDate <= newStartDate) {
                newStartDateX = gantt.getCoordinateFromDate(timeAxisEndDate, false);
            } else {
                newStartDateX = gantt.getCoordinateFromDate(timeAxisStartDate, false);
            }
        }
        if (Sch.util.Date.betweenLesser(newEndDate, timeAxisStartDate, timeAxisEndDate)) {
            newEndDateX = gantt.getCoordinateFromDate(newEndDate, false);
        } else {
            newEndDateX = gantt.getCoordinateFromDate(timeAxisEndDate, false);
        }
        if (gantt.rtl && gantt.shouldAdjustForRtl()) {
            viewWidth = gantt.getWidth();
            newStartDateX = viewWidth - newStartDateX;
            newEndDateX = viewWidth - newEndDateX;
        }
        result = (doFn || Ext.returnTrue)(newStartDate, newEndDate, newStartDateX, newEndDateX);
        return result;
    }
    function doProcessDrop(me, gantt, target, task, startDate, endDate, dropSource, data, initialTaskElStartX, initialTaskElWidth, e, dropActionFn) {
        (new Ext.Promise(function(resolve, reject) {
            var dropHandler = new Gnt.feature.taskdd.AsyncDropHandler(resolve, reject, dropActionFn),
                eventCanceled, dragContext;
            if (gantt.hasListeners.beforetaskdropfinalize) {
                // TODO: other properties might be needed
                // Backward compatibility
                dragContext = Ext.apply({}, data, {
                    start: startDate,
                    end: endDate,
                    finalize: function(validDrop) {
                        if (validDrop) {
                            dropHandler.process();
                            dropHandler.done();
                        } else {
                            // Since we have moved task element to the drop coordinates to visually
                            // indicate possible task position during asynchronous drop processing
                            // so we have to restore the element position back to original task
                            // time coordinates
                            positionTaskElement(gantt, data.ddel, initialTaskElStartX, initialTaskElStartX + initialTaskElWidth);
                            dropHandler.cancel();
                        }
                    }
                });
                /**
                 * @event beforetaskdropfinalize
                 * @preventable
                 *
                 * Fires before a SUCCESSFUL drop operation is finalized.
                 * This event is supposed to be used as a SYNCHRONOUS hook before the drop finalizing, or as an ASYNCHRONOUS drop validator.
                 * Return `true` to finalize the drop operation immediately, or return `false` to finalize it later.
                 * To finalize the operation later, call the 'finalize' method available on the context object.
                 * Pass `true` to the `finalize` function to accept the drop or `false` if you want to cancel it.
                 *
                 * Here is an example of a **sync** hook:
                 *
                 * ```javascript
                 * beforetaskdropfinalize : function (view, dragContext, e) {
                 *     dragContext.record.setCls('dropped');
                 *     return true;
                 * }
                 *
                 * ```
                 *
                 * Here is an example of an **async** hook:
                 *
                 * ```javascript
                 * beforetaskdropfinalize : function (view, dragContext, e) {
                 *     Ext.Ajax.request({
                 *         url     : '/check-the-drop-operation',
                 *         success : function (response) {
                 *             // confirm the drop operation
                 *             dragContext.finalize(true);
                 *         },
                 *         failure : function (response) {
                 *             // decline the drop operation
                 *             dragContext.finalize(false);
                 *         }
                 *     });
                 *     return false;
                 * }
                 * ```
                 *
                 * **NOTE:** In case you return `false` from the listener, you should ALWAYS call the `finalize` function,
                 * no matter with `true` argument to confirm the drop operation, or with `false` argument to decline it.
                 *
                 * **NOTE2:** If you need to perform SYNCHRONOUS drop validation please take a look at {@link Gnt.feature.taskdd.plugin.InRowTaskDragDrop#validatorFn validatorFn}.
                 *
                 * @param {Mixed} view The gantt view instance
                 * @param {Object} dragContext An object containing 'record', 'start', 'finalize' properties.
                 * @param {Ext.EventObject} e The event object
                 *
                 * @member Gnt.view.Gantt
                 */
                // Sane event signature
                //eventCanceled = (false === gantt.fireEvent('beforetaskdropfinalize', gantt, data, dropHandler, e));
                // Backward compatible event signature
                eventCanceled = (false === gantt.fireEvent('beforetaskdropfinalize', gantt, dragContext, e));
                // Proxy element will be hidden at that moment but drop is being processed asynchronously
                // thus we still need a visual indication where a task element might be in case drop will
                // be considered valid after asynchronous processing. Lets move task element at the drop
                // coordinates.
                if (eventCanceled && !dropHandler.isCanceled()) {
                    positionTaskElement(gantt, data.ddel, startDate, task.isMilestone() ? null : endDate);
                }
            }
            // Sane behaviour
            //if (eventCanceled && !dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
            //    dropHandler.cancel();
            //}
            //else if (!dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
            //    dropHandler.process();
            //    dropHandler.done();
            //}
            // Backward compatible behaviour
            if (!eventCanceled && !dropHandler.isWaiting() && !(dropHandler.isDone() || dropHandler.isCanceled())) {
                dropHandler.process();
                dropHandler.done();
            }
        }).then(function(result) {
            /**
             * @event taskdrop
             *
             * Fires after a succesful drag and drop operation
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The dropped record
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners.taskdrop && gantt.fireEvent('taskdrop', gantt, task);
        }).then(undefined, function(result) {
            /**
             * @event taskdropcancel
             *
             * Fires if task drop operation is canceled
             *
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The dropped record
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners.taskdropcancel && gantt.fireEvent('taskdropcancel', gantt, task);
        }));
    }
    function doDefaultDropProcessing(me, task, newStartDate, newEndDate) {
        task.setStartEndDate(newStartDate, newEndDate);
    }
    return {
        extend: 'Ext.plugin.Abstract',
        alias: 'plugin.gantt_inrowtaskdragdrop',
        id: 'inrowtaskdragdrop',
        requires: [
            'Ext.Promise',
            'Sch.util.Date',
            'Gnt.Tooltip',
            'Gnt.feature.taskdd.AsyncDropHandler'
        ],
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt Gantt view the drop controller works with
             */
            gantt: null,
            /**
             * @cfg {Boolean|Object} tooltip True or a custom config object to enable and apply to the {@link Gnt.Tooltip} instance.
             *
             * Pass false to disable tooltip during in row dragging.
             */
            tooltip: null,
            /**
             * @cfg {Function} validatorFn
             * A custom validation function to be called during the drag and drop process
             * and also after the drop operation is made but before it's finalized.
             * If you need to perform an async validation,
             * please take a look at {@link Gnt.view.Gantt#beforetaskdropfinalize beforetaskdropfinalize} event instead.
             *
             * @param {Gnt.model.Task} record The record being dragged
             * @param {Date} date The new start date
             * @param {Number} duration The duration of the item being dragged, in minutes
             * @param {Ext.EventObject} e The event object
             * @return {Boolean} true if the drop position is valid, else false to prevent a drop
             */
            validatorFn: Ext.returnTrue,
            /**
             * @cfg {Boolean} [showExactDropPosition=false] When enabled, the task being dragged always "snaps" to the exact start date / duration that it will have after being dropped.
             */
            showExactDropPosition: false,
            /**
             * @cfg {Boolean} [snaprelativetoeventstartdate=false] Whether to snap relative to task start position or to time axis start date.
             *
             * The option is in effect only if {@link #showExactDropPosition} is set to *true*.
             */
            snapRelativeToEventStartDate: false,
            /**
             * @cfg {Boolean} [skipWeekendsDuringDragDrop=false] When enabled, that task being dragged will skip weekend dates.
             */
            skipWeekendsDuringDragDrop: false,
            /**
             * @cfg {Boolean} [constrainDragToTaskRow=true] When enabled dragged task element will constrained by task row
             */
            constrainDragToTaskRow: true,
            /**
             * @cfg {String} [dropAllowedCls='sch-gantt-dragproxy'] A CSS class to apply to drag proxy if drop is valid at the point
             */
            dropAllowedCls: 'sch-gantt-dragproxy'
        },
        ganttDetacher: null,
        initialTaskElStartX: null,
        initialTaskElWidth: null,
        /**
         * @private
         */
        skipWeekends: function(task, startDate) {
            var taskStore = task.getTaskStore(true),
                scheduleByConstraints = taskStore && taskStore.scheduleByConstraints;
            // If "scheduleByConstraints" is false we use old behavior - all tasks skip non-working time forwards, except milestones which skip backwards.
            // And when "scheduleByConstraints" is true we skip it forwards.
            return task.skipNonWorkingTime(startDate, scheduleByConstraints ? true : !task.isMilestone());
        },
        /**
         * @inheritdoc
         */
        destroy: function() {
            var me = this;
            me.setTooltip(null);
            // this will destroy the tooltip
            me.setGantt(null);
            // this will detach from gantt events if any are being listened for
            me.callParent();
        },
        /**
         * Enables task in row drag & drop
         */
        enable: function() {
            var me = this;
            if (me.disabled) {
                me.callParent();
                me.attachToGantt();
            }
        },
        /**
         * Disables task in row drag & drop
         */
        disable: function() {
            var me = this;
            if (!me.disabled) {
                me.callParent();
                me.detachFromGantt();
            }
        },
        updateGantt: function(gantt, oldGantt) {
            var me = this;
            oldGantt && me.detachFromGantt();
            gantt && !me.disabled && me.attachToGantt();
        },
        attachToGantt: function() {
            var me = this;
            me.ganttDetacher = me.getGantt().on({
                scope: me,
                destroyable: true,
                'taskdragstart': me.onTaskDragStart,
                'task-row-drag-enter': me.onTaskRowDragEnter,
                'task-row-drag-out': me.onTaskRowDragOut,
                'task-row-drag-over': me.onTaskRowDragOver,
                'task-row-drag-drop': me.onTaskRowDragDrop,
                'schedule-drag-over': me.onTaskContainerOver,
                'aftertaskdrop': me.onAfterTaskDrop
            });
        },
        detachFromGantt: function() {
            var me = this;
            me.ganttDetacher && (Ext.destroy(me.ganttDetacher) , me.ganttDetacher = null);
        },
        applyTooltip: function(tooltip) {
            var me = this;
            if (tooltip && !(tooltip instanceof Gnt.Tooltip)) {
                tooltip = Ext.create(Ext.apply({}, tooltip === true ? {} : tooltip, {
                    xclass: 'Gnt.Tooltip',
                    gantt: me.getGantt(),
                    constrainTo: me.getGantt().getEl(),
                    cls: "gnt-dragdrop-tip",
                    hidden: true,
                    avoidPointer: true,
                    $ownedBy: me
                }));
            }
            return tooltip;
        },
        updateTooltip: function(tooltip, oldTooltip) {
            var me = this;
            if (oldTooltip && oldTooltip.$ownedBy === me) {
                Ext.destroy(oldTooltip);
            }
        },
        updateTipContent: function(tip, task, start, end, valid) {
            start = start || task.getStartDate();
            end = end || task.getEndDate();
            var store = task.getTaskStore(true),
                format = tip.gantt.getDisplayDateFormat();
            if (!store || !store.disableDateAdjustments) {
                start = task.getDisplayStartDate(format, tip.adjustMilestones, start, true);
                end = task.getDisplayEndDate(format, tip.adjustMilestones, end, true);
            }
            tip.updateContent(start, end, valid, task);
        },
        constrainProxyToInitialTaskRow: function(gantt, taskEl, initialTaskElementClickOffsets, dropSource) {
            var proxy = dropSource.getProxy(),
                taskXY, viewXY, offsets;
            // If proxy will be within initial task row then we should attach it to Gantt's secondary canvas
            // such that Gantt's view bounded proxy element
            proxy.setForceAttachTo(gantt.getSecondaryCanvasEl());
            // Since proxy will now be a visual replacement of the task than we are to hide
            // the original task element
            Ext.fly(taskEl).hide();
            // Now constraining proxy movemeent within initial task row.
            // To be precise we will constrain proxy vertical movement, we will setup it such that
            // proxy vertical offset relative to original task element top be 0 always
            taskXY = Ext.fly(taskEl).getXY();
            taskXY = new Ext.util.Point(taskXY[0], taskXY[1]);
            viewXY = Ext.fly(dropSource.getEl()).getXY();
            viewXY = new Ext.util.Point(viewXY[0], viewXY[1]);
            offsets = taskXY.getOffsetsTo(viewXY);
            // This is DD magic, believe me it should be like this
            // Internally setInitPosition() takes page coordinates of the dropSource.getEl() (which is gantt view
            // in our case, and then substracts from it deltaX, deltaY, passed as arguments, and stores the result
            // as dragging initial page coordinates.
            dropSource.setInitPosition(-offsets.x, -offsets.y);
            dropSource.setDelta(initialTaskElementClickOffsets.x, initialTaskElementClickOffsets.y);
            dropSource.setYConstraint(0, 0);
        },
        onTaskDragStart: function(gantt, task, xy, data, dropSource) {
            var me = this;
            this.initialTaskElStartX = Ext.fly(data.ddel).getX();
            this.initialTaskElWidth = Ext.fly(data.ddel).getWidth();
            // If it's task drag and drag should be constrained to task row only then constraining proxy
            if (data.isTaskDrag && me.getConstrainDragToTaskRow()) {
                me.constrainProxyToInitialTaskRow(gantt, data.ddel, data.startOffsets, dropSource);
            }
        },
        onTaskRowDragEnter: function(gantt, target, dropSource, data, e) {
            var me = this,
                tip;
            if (data.isTaskDrag && Ext.fly(data.item).contains(target)) {
                // Snapping proxy to task row
                me.constrainProxyToInitialTaskRow(gantt, data.ddel, data.startOffsets, dropSource);
                // Aligning tooltip
                tip = me.getTooltip();
                tip && me.updateTipContent(tip, data.record);
                tip && tip.showBy(dropSource.getProxy().getGhost());
            }
        },
        onTaskRowDragOut: function(gantt, target, dropSource, data, e) {
            var me = this,
                tip;
            if (data.isTaskDrag && !me.getConstrainDragToTaskRow() && Ext.fly(data.item).contains(target)) {
                // Returning proxy back to body
                dropSource.getProxy().setForceAttachTo(null);
                // Force removing cls to ensure proper proxy style
                dropSource.getProxy().removeCls(me.getDropAllowedCls());
                // Hiding tooltip
                tip = me.getTooltip();
                tip && tip.hide();
                // Resetting proxy delta and movement constraints
                dropSource.setDelta(0, 0);
                dropSource.clearConstraints();
                // Showing original task element back
                Ext.fly(data.ddel).show();
            }
        },
        onTaskRowDragOver: function(gantt, target, dropSource, data, e, canHandleDrop) {
            var me = this,
                eXY, tip, task;
            if (data.isTaskDrag && (me.getConstrainDragToTaskRow() || Ext.fly(data.item).contains(target))) {
                // To keep visual compatibility with previous task drag & drop implementation we should always
                // report as if we can handle task drop here
                canHandleDrop(me.getDropAllowedCls());
                task = data.record;
                eXY = e.getXY();
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedTaskCoordinates(eXY[0], data.startPointDate, task, gantt, me.getShowExactDropPosition(), me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), me.skipWeekends, function(newStartDate, newEndDate, newStartDateX, newEndDateX) {
                    var valid = true,
                        validDragElX, validDragElY;
                    // We add offsets here because the same offsets has been passed to DragZone::setDelta() at
                    // the drag enter event handler. The offsets set via setDelta() will be automatically subtracted
                    // from the coordinates we pass here, thus we add them back. In other words
                    // DragZone::setDragElPos() expects here the coordinates of the mouse pointer, not the coordinates
                    // of the dragged element
                    validDragElY = eXY[1] + data.startOffsets.y;
                    if (gantt.rtl && gantt.shouldAdjustForRtl()) {
                        validDragElX = newEndDateX + data.startOffsets.x;
                    } else {
                        validDragElX = newStartDateX + data.startOffsets.x;
                    }
                    // We do not rely on default proxy movement here and update drag element position manually
                    // due to the fact that node over notification might come via emulation layer in
                    // Gnt.feature.taskdd.DropZone activated upon drop zone element scrolling.
                    // Meant to fix position when snapToIncrement is enabled
                    dropSource.setDragElPos(validDragElX, validDragElY);
                    // If we don't require showing exact drop position then default proxy movement handling is
                    // enough and we should do nothing, we calculate start/end dates just for the tooltip then
                    // NOTE: remove that condition if you want proxy size adjusted for the case when partially
                    //       visible event is being moved
                    // NOTE: Math.abs() is for RTL mode, when (newEndDateX < newStartDateX)
                    if ((gantt.rtl || me.getShowExactDropPosition()) && !task.isMilestone()) {
                        Ext.fly(dropSource.getProxy().getTaskGhostEl()).setWidth(Math.abs(newEndDateX - newStartDateX));
                    }
                    // Validating drop with user supplied validatorFn, here just to update the tip
                    if (me.getValidatorFn()) {
                        valid = (false !== (me.getValidatorFn())(task, newStartDate, newEndDate - newStartDate, e));
                    }
                    // Aligning tooltip
                    tip = me.getTooltip();
                    tip && me.updateTipContent(tip, task, newStartDate, newEndDate, valid);
                    tip && tip.showBy(dropSource.getProxy().getGhost());
                    return true;
                });
            }
        },
        onTaskRowDragDrop: function(gantt, target, dropSource, data, e) {
            var me = this,
                eXY, task;
            if (data.isTaskDrag && (me.getConstrainDragToTaskRow() || Ext.fly(data.item).contains(target))) {
                task = data.record;
                eXY = e.getXY();
                // Returning proxy back to body, it's important to do here, after this moment secondary canvas
                // the proxy is attached to might be destroyed and then re-created back, but this will also
                // destroy proxy's ghost element. So by detaching it from secondary canvas back to body element
                // we save the ghost.
                dropSource.getProxy().setForceAttachTo(null);
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedTaskCoordinates(eXY[0], data.startPointDate, task, gantt, // Here at the drop time we need to calculate new start / end dates exactly how it will be adjusted
                // after taking into account snapping and weekend skipping settings, thus we pass true here
                // instead of me.getShowExactDropPosition()
                true, me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), me.skipWeekends, function(newStartDate, newEndDate, newStartDateX, newEndDateX) {
                    var valid = true;
                    // Processing drop only if task's start date is to be changed
                    if (task.getStartDate() - newStartDate) {
                        // Validating drop with user supplied validatorFn
                        if (me.getValidatorFn()) {
                            valid = (false !== (me.getValidatorFn())(task, newStartDate, newEndDate - newStartDate, e));
                        }
                        valid && me.processDrop(gantt, target, task, newStartDate, newEndDate, dropSource, data, me.initialTaskElStartX, me.initialTaskElWidth, e, function() {
                            doDefaultDropProcessing(me, task, newStartDate, newEndDate);
                        });
                    }
                });
            }
        },
        onTaskContainerOver: function(gantt, dropSource, data, e, canHandleDrop) {
            var me = this;
            if (data.isTaskDrag && me.getConstrainDragToTaskRow()) {
                // If proxy is constrained to be within initial task row then we always should report
                // as if we can handle drop to keep visual compatibility with the previous task drag & drop implementation
                canHandleDrop(me.getDropAllowedCls());
            }
        },
        onAfterTaskDrop: function(gantt, record, e, data, dropSource) {
            var me = this,
                tip;
            // We don't always get drag out event, thus this is the last chance to do cleanup
            if (data.isTaskDrag) {
                // Returning proxy back to body
                dropSource.getProxy().setForceAttachTo(null);
                // Hiding tooltip
                tip = me.getTooltip();
                tip && tip.hide();
                // Just in case
                dropSource.clearConstraints();
                // Showing original task element back (just in case), we have hidden in in onTaskRowDragEnter() and
                // we might not get onTaskRowDragOut() call if drop is within different gantt component
                Ext.fly(data.ddel).show();
                this.initialTaskElStartX = null;
                this.initialTaskElWidth = null;
            }
        },
        processDrop: function(gantt, target, task, newStartDate, newEndDate, dropSource, data, initialTaskElStartX, initialTaskElWidth, e, dropActionFn) {
            return doProcessDrop(this, gantt, target, task, newStartDate, newEndDate, dropSource, data, initialTaskElStartX, initialTaskElWidth, e, dropActionFn);
        }
    };
});

/**
 * @class Gnt.feature.taskdd.plugin.SegmentDragDrop
 *
 * Task segment drag & drop plugin
 */
Ext.define('Gnt.feature.taskdd.plugin.SegmentDragDrop', function(thisClass) {
    function getSegmentAvailableTimespan(gantt, taskSegment, taskSegmentIdx) {
        var task = taskSegment.getTask(),
            segments = task.getSegments(),
            timeAxisStartDate, timeAxisEndDate, prevSegment, nextSegment;
        prevSegment = (taskSegmentIdx > 0) && segments[taskSegmentIdx - 1];
        nextSegment = (taskSegmentIdx < segments.length - 1) && segments[taskSegmentIdx + 1];
        timeAxisStartDate = gantt.timeAxis.getStart();
        timeAxisEndDate = gantt.timeAxis.getEnd();
        return {
            prevSegment: prevSegment || null,
            nextSegment: nextSegment || null,
            startDate: prevSegment ? prevSegment.getEndDate() : null,
            endDate: nextSegment ? nextSegment.getStartDate() : null,
            timeAxisStartDate: timeAxisStartDate,
            timeAxisEndDate: timeAxisEndDate,
            startDateWithinAxis: prevSegment && Sch.util.Date.betweenLesser(prevSegment.getEndDate(), timeAxisStartDate, timeAxisEndDate) || false,
            endDateWithinAxis: nextSegment && Sch.util.Date.betweenLesser(nextSegment.getStartDate(), timeAxisStartDate, timeAxisEndDate) || false
        };
    }
    function withSnappedTaskSegmentCoordinates(currentPointX, startPointDate, taskSegment, taskSegmentIdx, gantt, showExactDropPosition, snapRelativeToEventStartDate, skipWeekendsDuringDragDrop, doFn) {
        var result = false,
            currentPointDate, timeDiffMs, newStartDate, newEndDate, newStartDateX, newEndDateX, segmentAvailableTimespan,
            startShrinked = false,
            endShrinked = false;
        // Calculating current pointer date from its X coordinate to be able to calculate time shift
        // the pointer movement presents
        currentPointDate = gantt.getDateFromCoordinate(currentPointX);
        timeDiffMs = currentPointDate - startPointDate;
        // Segments are restricted in movement by their sibling segments. Here we calculate valid segment
        // movement timespan
        segmentAvailableTimespan = getSegmentAvailableTimespan(gantt, taskSegment, taskSegmentIdx);
        //
        // Now calculating new start date
        //
        newStartDate = Sch.util.Date.add(taskSegment.getStartDate(), Sch.util.Date.MILLI, timeDiffMs);
        // If showing exact drop position is requested
        if (showExactDropPosition) {
            // Rounding new start date value using timeaxis which will also snap the date rounded to gantt's
            // snap pixel amount
            newStartDate = gantt.timeAxis.roundDate(newStartDate, snapRelativeToEventStartDate ? taskSegment.getStartDate() : false);
            // If weekends skipping is requested then skipping
            if (skipWeekendsDuringDragDrop) {
                newStartDate = taskSegment.skipNonWorkingTime(newStartDate, !taskSegment.isMilestone());
            }
        }
        // We can't go earlier than segment available time span start date if one is given
        startShrinked = segmentAvailableTimespan.startDate && newStartDate < segmentAvailableTimespan.startDate || false;
        newStartDate = startShrinked ? segmentAvailableTimespan.startDate : newStartDate;
        //
        // Now calculating new end date
        //
        if (showExactDropPosition) {
            // WARNING: calling private method, but the same has been done in original/non-refactored
            //          Gnt.features.TaskDragDrop code, so don't blame me.
            newEndDate = taskSegment.recalculateEndDate(newStartDate);
        } else {
            newEndDate = Sch.util.Date.add(newStartDate, taskSegment.getDurationUnit(), taskSegment.getDuration());
        }
        // We can't go later than segment available time span end date if one is given
        endShrinked = segmentAvailableTimespan.endDate && newEndDate > segmentAvailableTimespan.endDate || false;
        newEndDate = endShrinked ? segmentAvailableTimespan.endDate : newEndDate;
        // NOTE: This code was added to keep new segment D&D implementation compatible
        //       with features/1204_dragdrop.t.js
        // --------------------------------------
        if (endShrinked) {
            newStartDate = Sch.util.Date.add(newEndDate, taskSegment.getDurationUnit(), -taskSegment.getDuration());
            startShrinked = segmentAvailableTimespan.startDate && newStartDate < segmentAvailableTimespan.startDate || false;
            newStartDate = startShrinked ? segmentAvailableTimespan.startDate : newStartDate;
        }
        // --------------------------------------
        //
        // Calculating new start / end horizontal coordinates, which always should be within visible time span
        //
        // NOTE: We need page coordniates here, they are usually passed to DragZone#alignElWithMouse()
        //       via DragZone::setDragElPos() later on
        if (Sch.util.Date.betweenLesser(newStartDate, segmentAvailableTimespan.timeAxisStartDate, segmentAvailableTimespan.timeAxisEndDate)) {
            newStartDateX = gantt.getCoordinateFromDate(newStartDate, false);
        } else {
            newStartDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.timeAxisStartDate, false);
        }
        if (Sch.util.Date.betweenLesser(newEndDate, segmentAvailableTimespan.timeAxisStartDate, segmentAvailableTimespan.timeAxisEndDate)) {
            newEndDateX = gantt.getCoordinateFromDate(newEndDate, false);
        } else {
            newEndDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.timeAxisEndDate, false);
        }
        result = (doFn || Ext.returnTrue)(newStartDate, newEndDate, newStartDateX, newEndDateX);
        return result;
    }
    function processDrop(me, gantt, target, taskSegment, startDate, endDate, dropSource, data, e) {
        (new Ext.Promise(function(resolve, reject) {
            var dropHandler = new Gnt.feature.taskdd.AsyncDropHandler(resolve, reject, function() {
                    doDefaultDropProcessing(me, taskSegment, startDate, endDate);
                }),
                eventCanceled, dragContext;
            if (gantt.hasListeners.beforetaskdropfinalize) {
                // TODO: other properties might be needed
                // Backward compatibility
                dragContext = Ext.apply({}, data, {
                    start: startDate,
                    end: endDate,
                    finalize: function(validDrop) {
                        if (validDrop) {
                            dropHandler.process();
                            dropHandler.done();
                        } else {
                            dropHandler.cancel();
                        }
                    }
                });
                // NOTE: Event is document in InRowTaskDragDrop plugin
                // Sane event signature
                //eventCanceled = (false === gantt.fireEvent('beforetaskdropfinalize', gantt, data, dropHandler, e));
                // Backward compatible event signature
                eventCanceled = (false === gantt.fireEvent('beforetaskdropfinalize', gantt, dragContext, e));
            }
            // Sane behaviour
            //if (eventCanceled && !dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
            //    dropHandler.cancel();
            //}
            //else if (!dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
            //    dropHandler.process();
            //    dropHandler.done();
            //}
            // Backward compatible behaviour
            if (!eventCanceled && !dropHandler.isWaiting() && !(dropHandler.isDone() || dropHandler.isCanceled())) {
                dropHandler.process();
                dropHandler.done();
            }
        }).then(function(result) {
            // NOTE: Event is document in InRowTaskDragDrop plugin
            gantt.hasListeners.taskdrop && gantt.fireEvent('taskdrop', gantt, taskSegment);
        }).then(undefined, function(result) {
            // NOTE: Event is document in InRowTaskDragDrop plugin
            gantt.hasListeners.taskdropcancel && gantt.fireEvent('taskdropcancel', gantt, taskSegment);
        }));
    }
    function doDefaultDropProcessing(me, taskSegment, newStartDate, newEndDate) {
        // NOTE: This code was added and the later one commented out to keep new segment
        //       D&D implementation compatible with features/1204_dragdrop.t.js
        taskSegment.setStartDate(newStartDate, true, me.getSkipWeekendsDuringDragDrop());
    }
    // taskSegment.setStartEndDate(newStartDate, newEndDate);
    function setDraggingHorizontalMovementConstrains(dropSource, gantt, taskSegment, taskSegmentIdx, taskSegmentXY, taskSegmentWidth) {
        var segmentAvailableTimespan, timespanStartDateX, timespanEndDateX;
        segmentAvailableTimespan = getSegmentAvailableTimespan(gantt, taskSegment, taskSegmentIdx);
        if (segmentAvailableTimespan.startDateWithinAxis && segmentAvailableTimespan.endDateWithinAxis) {
            timespanStartDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.startDate, false);
            timespanEndDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.endDate, false);
            dropSource.setXConstraint(taskSegmentXY.x - timespanStartDateX, timespanEndDateX - taskSegmentXY.x - taskSegmentWidth);
        } else if (segmentAvailableTimespan.startDateWithinAxis) {
            timespanStartDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.startDate, false);
            dropSource.setXConstraint(taskSegmentXY.x - timespanStartDateX, Ext.Number.MAX_SAFE_INTEGER);
        } else if (segmentAvailableTimespan.endDateWithinAxis) {
            timespanEndDateX = gantt.getCoordinateFromDate(segmentAvailableTimespan.endDate, false);
            dropSource.setXConstraint(Ext.Number.MAX_SAFE_INTEGER, timespanEndDateX - taskSegmentXY.x - taskSegmentWidth);
        }
    }
    return {
        extend: 'Ext.plugin.Abstract',
        alias: 'plugin.gantt_segmentdragdrop',
        id: 'segmentdragdrop',
        requires: [
            'Ext.Number',
            'Ext.Promise',
            'Sch.util.Date',
            'Gnt.Tooltip',
            'Gnt.feature.taskdd.AsyncDropHandler'
        ],
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt Gantt view the drop controller works with
             */
            gantt: null,
            /**
             * @cfg {Boolean|Object} tooltip True or a custom config object to enable and apply to the {@link Gnt.Tooltip} instance.
             *
             * Pass false to disable tooltip during in row dragging.
             */
            tooltip: null,
            /**
             * @cfg {Function} validatorFn An empty function by default.
             *
             * Provide to perform custom validation on the item being dragged.
             * This function is called during the drag and drop process and also after the drop is made.
             *
             * @param {Gnt.model.Task} record The record being dragged
             * @param {Date} date The new start date
             * @param {Number} duration The duration of the item being dragged, in minutes
             * @param {Ext.EventObject} e The event object
             * @return {Boolean} true if the drop position is valid, else false to prevent a drop
             */
            validatorFn: Ext.returnTrue,
            /**
             * @cfg {Boolean} [showExactDropPosition=false] When enabled, the task being dragged always "snaps" to the exact start date / duration that it will have after being dropped.
             */
            showExactDropPosition: false,
            /**
             * @cfg {Boolean} [snapRelativeToEventStartDate=false] Whether to snap relative to task start position or to time axis start date.
             *
             * The option is in effect only if {@link #showExactDropPosition} is set to *true*.
             */
            snapRelativeToEventStartDate: false,
            /**
             * @cfg {Boolean} [skipWeekendsDuringDragDrop=false] When enabled, that task being dragged will skip weekend dates.
             */
            skipWeekendsDuringDragDrop: false,
            /**
             * @cfg {String} [dropAllowedCls='sch-gantt-dragproxy'] A CSS class to apply to drag proxy if drop is valid at the point
             */
            dropAllowedCls: 'sch-gantt-dragproxy'
        },
        ganttDetacher: null,
        lastValidDragElX: null,
        lastValidDragElY: null,
        /**
         * @inheritdoc
         */
        destroy: function() {
            var me = this;
            me.setTooltip(null);
            // this will destroy the tooltip
            me.setGantt(null);
            // this will detach from gantt events if any are being listened for
            me.callParent();
        },
        /**
         * Enables segment drag & drop
         */
        enable: function() {
            var me = this;
            if (me.disabled) {
                me.callParent();
                me.attachToGantt();
            }
        },
        /**
         * Disables segment drag & drop
         */
        disable: function() {
            var me = this;
            if (!me.disabled) {
                me.callParent();
                me.detachFromGantt();
            }
        },
        updateGantt: function(gantt, oldGantt) {
            var me = this;
            oldGantt && me.detachFromGantt();
            gantt && !me.disabled && me.attachToGantt();
        },
        attachToGantt: function() {
            var me = this;
            me.ganttDetacher = me.getGantt().on({
                scope: me,
                destroyable: true,
                'task-row-drag-enter': me.onTaskRowDragEnter,
                'task-row-drag-over': me.onTaskRowDragOver,
                'task-row-drag-drop': me.onTaskRowDragDrop,
                'schedule-drag-over': me.onTaskContainerOver,
                'schedule-drag-out': me.onTaskContainerOut,
                'aftertaskdrop': me.onAfterTaskDrop
            });
        },
        detachFromGantt: function() {
            var me = this;
            me.ganttDetacher && (Ext.destroy(me.ganttDetacher) , me.ganttDetacher = null);
        },
        applyTooltip: function(tooltip) {
            var me = this;
            //Change 6.5 constrainTo  : me.getGantt().getEl() contraints the tip on the task when there is only one row.
            if (tooltip && !(tooltip instanceof Gnt.Tooltip)) {
                tooltip = Ext.create(Ext.apply({}, tooltip === true ? {} : tooltip, {
                    xclass: 'Gnt.Tooltip',
                    gantt: me.getGantt(),
                    constrainTo: me.getGantt().ownerGrid.getEl(),
                    cls: "gnt-dragdrop-tip",
                    hidden: true,
                    avoidPointer: true,
                    $ownedBy: me
                }));
            }
            return tooltip;
        },
        updateTooltip: function(tooltip, oldTooltip) {
            var me = this;
            if (oldTooltip && oldTooltip.$ownedBy === me) {
                Ext.destroy(oldTooltip);
            }
        },
        updateTipContent: function(tip, taskSegmentRecord, start, end) {
            start = start || taskSegmentRecord.getStartDate();
            end = end || taskSegmentRecord.getEndDate();
            tip.updateContent(start, end, true, taskSegmentRecord);
        },
        onTaskRowDragEnter: function(gantt, target, dropSource, data, e) {
            var me = this,
                taskSegmentXY, elXY, offsets, taskSegment, taskSegmentIdx, segmentAvailableTimespan, timespanStartDateX, timespanEndDateX, segmentElWidth, tip;
            if (data.isTaskSegmentDrag) {
                // Segments dragging is always withing task view, attaching proxy to gantt view element
                dropSource.getProxy().setForceAttachTo(gantt.getSecondaryCanvasEl());
                // Hiding initial task segment element (it's now presented by the proxy);
                Ext.fly(data.ddel).hide();
                // Constraining proxy movement within initial task row and within segment's sibling segments
                taskSegmentXY = Ext.fly(data.ddel).getXY();
                taskSegmentXY = new Ext.util.Point(taskSegmentXY[0], taskSegmentXY[1]);
                elXY = Ext.fly(dropSource.getEl()).getXY();
                elXY = new Ext.util.Point(elXY[0], elXY[1]);
                offsets = taskSegmentXY.getOffsetsTo(elXY);
                // This is DD magic, believe me it should be like this
                // Internally setInitPosition() takes page coordinates of the dropSource.getEl() (which is gantt view
                // in our case, and then substracts from it deltaX, deltaY, passed as arguments, and stores the result
                // as dragging initial page coordinates.
                // Setting Y axis constraint
                dropSource.setInitPosition(-offsets.x, -offsets.y);
                dropSource.setDelta(data.startOffsets.x, data.startOffsets.y);
                dropSource.setYConstraint(0, 0);
                // Setting X axis constraint
                segmentElWidth = Ext.fly(dropSource.getProxy().getTaskGhostEl()).getWidth();
                setDraggingHorizontalMovementConstrains(dropSource, gantt, data.record, data.segmentIndex, taskSegmentXY, segmentElWidth);
                // Saving initial valid proxy X, Y coordinates
                // We add offsets here because the same offsets has been passing to DragZone::setDelta()
                // The offsets set via setDelta will be automatically substracted
                // from the coordinates we pass to DragZone::setDragElPos() later, thus we adding them back.
                // In other words DragZone::setDragElPos() expects the coordinates of the mouse pointer,
                // not the coordinates the of dragged element
                me.lastValidDragElX = me.lastValidDragElX !== null ? me.lastValidDragElX : (taskSegmentXY.x + data.startOffsets.x);
                me.lastValidDragElY = me.lastValidDragElY !== null ? me.lastValidDragElY : (taskSegmentXY.y + data.startOffsets.y);
                dropSource.unlockDragProxyPosition();
                dropSource.setDragElPos(me.lastValidDragElX, me.lastValidDrarElY);
                // Aligning tooltip
                tip = me.getTooltip();
                tip && me.updateTipContent(tip, data.record);
                tip && tip.showBy(dropSource.getProxy().getGhost());
            }
        },
        onTaskRowDragOver: function(gantt, target, dropSource, data, e, canHandleDrop) {
            var me = this,
                eXY, tip, taskSegment, taskSegmentIdx, taskSegmentXY, availableTimespan, timespanStartDateX, timespanEndDateX, segmentElWidth;
            if (data.isTaskSegmentDrag) {
                // To keep visual compatibility with previous task drag & drop implementation we should always
                // report as if we can handle task drop here
                canHandleDrop(me.getDropAllowedCls());
                taskSegment = data.record;
                taskSegmentIdx = data.segmentIndex;
                eXY = e.getXY();
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedTaskSegmentCoordinates(eXY[0], data.startPointDate, taskSegment, taskSegmentIdx, gantt, me.getShowExactDropPosition(), me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), function(newStartDate, newEndDate, newStartDateX, newEndDateX) {
                    var validDragElX, validDragElY, valid;
                    // We add offsets here because the same offsets has been passing to DragZone::setDelta() at
                    // the drag enter event handler. The offsets set via setDelta will be automatically substracted
                    // from the coordinates we pass here, thus we adding them back. In other words
                    // DragZone::setDragElPos() expects here the coordinates of the mouse pointer, not the coordinates
                    // of dragged element
                    me.lastValidDragElX = validDragElX = newStartDateX + data.startOffsets.x;
                    me.lastValidDragElY = validDragElY = eXY[1] + data.startOffsets.y;
                    // We do not rely on default proxy movement here and update drag element position manually
                    // due to the fact that node over notification might come via emulation layer in
                    // Gnt.feature.taskdd.DropZone activated upon drop zone element scrolling.
                    dropSource.setDragElPos(validDragElX, validDragElY);
                    // If we don't require showing exact drop position then default proxy movement handling is
                    // enough and we should do nothing, we calculate start/end dates just for the tooltip then
                    if (me.getShowExactDropPosition()) {
                        // Updating ghost task element width, due to snapping it might have been changed
                        // and we should reflect it visually
                        segmentElWidth = newEndDateX - newStartDateX;
                        Ext.fly(dropSource.getProxy().getTaskGhostEl()).setWidth(segmentElWidth);
                        // Reconstraining drag proxy X axis since proxy width might have changed
                        taskSegmentXY = Ext.fly(data.ddel).getXY();
                        taskSegmentXY = new Ext.util.Point(taskSegmentXY[0], taskSegmentXY[1]);
                        setDraggingHorizontalMovementConstrains(dropSource, gantt, taskSegment, taskSegmentIdx, taskSegmentXY, segmentElWidth);
                    }
                    // Validating drop with user supplied validatorFn, here just to update the tip
                    if (me.getValidatorFn()) {
                        valid = (false !== (me.getValidatorFn())(taskSegment, newStartDate, newEndDate - newStartDate, e));
                    }
                    // Aligning tooltip
                    tip = me.getTooltip();
                    tip && me.updateTipContent(tip, taskSegment, newStartDate, newEndDate, valid);
                    tip && tip.showBy(dropSource.getProxy().getGhost());
                });
            }
        },
        onTaskRowDragDrop: function(gantt, target, dropSource, data, e) {
            var me = this,
                taskSegment, taskSegmentIdx, eXY;
            if (data.isTaskSegmentDrag) {
                taskSegment = data.record;
                taskSegmentIdx = data.segmentIndex;
                eXY = e.getXY();
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedTaskSegmentCoordinates(eXY[0], data.startPointDate, taskSegment, taskSegmentIdx, gantt, // Here at the drop time we need to calculate new start / end dates exactly how it will be adjusted
                // after taking into account snapping and weekend skipping settings, thus we pass true here
                // instead of me.getShowExactDropPosition()
                true, me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), function(newStartDate, newEndDate, newStartDateX, newEndDateX) {
                    var valid = true;
                    // Processing drop only if segment's start date is to be changed
                    if (taskSegment.getStartDate() - newStartDate) {
                        // Validating drop with user supplied validatorFn
                        if (me.getValidatorFn()) {
                            valid = (false !== (me.getValidatorFn())(taskSegment, newStartDate, newEndDate - newStartDate, e));
                        }
                        valid && processDrop(me, gantt, target, taskSegment, newStartDate, newEndDate, dropSource, data, e);
                    }
                });
            }
        },
        onTaskContainerOver: function(gantt, dropSource, data, e, canHandleDrop) {
            var me = this;
            if (data.isTaskSegmentDrag) {
                // Upon segment dragging the proxy is constrained to be within initial task row and thus we always
                // should report as if we can handle drop to keep visual compatibility with the previous task
                // drag & drop implementation
                canHandleDrop(me.getDropAllowedCls());
                // This is important here otherwise drag proxy element might be aligned incorrectly
                // by the default proxy movement code
                dropSource.setDragElPos(me.lastValidDragElX, me.lastValidDragElY);
                dropSource.lockDragProxyPosition();
            }
        },
        onTaskContainerOut: function(gantt, dropSource, data, e) {
            var me = this;
            if (data.isTaskSegmentDrag) {
                // This is important here otherwise drag proxy element might be aligned incorrectly
                // by the default proxy movement code
                dropSource.setDragElPos(me.lastValidDragElX, me.lastValidDragElY);
                dropSource.lockDragProxyPosition();
            }
        },
        onAfterTaskDrop: function(gantt, record, e, data, dropSource) {
            var me = this,
                tip;
            // We don't always get drag out event, thus this is the last chance to do cleanup
            if (data.isTaskSegmentDrag) {
                // Returning proxy back to body
                dropSource.getProxy().setForceAttachTo(null);
                // Hiding tooltip
                tip = me.getTooltip();
                tip && tip.hide();
                // Just in case
                dropSource.clearConstraints();
                // Showing original task segment element back, we have hidden in in onTaskRowDragEnter
                Ext.fly(data.ddel).show();
                // Resetting last valid drag coordinates
                me.lastValidDragElX = me.lastValidDragElY = null;
                // Unlocking drag proxy position, it might have been locked at onTaskContainerOut
                dropSource.unlockDragProxyPosition();
            }
        }
    };
});

/**
 * @class Gnt.feature.taskdd.plugin.DeadlineDragDrop
 *
 * In row deadline marker drag & drop plugin.
 */
Ext.define('Gnt.feature.taskdd.plugin.DeadlineDragDrop', function(thisClass) {
    function withSnappedDeadlineCoordinate(proposedX, task, gantt, showExactDropPosition, snapRelativeToEventStartDate, skipWeekendsDuringDragDrop, doFn) {
        var result = false,
            newDate, newDateX;
        // Calculating new start date using event - initial event element click offset coordinates, i.e.
        // using dragged element left coordinate.
        newDate = gantt.getDateFromCoordinate(proposedX);
        // If gantt is capable to calculate new deadline date (i.e. coordinate is within time axis)
        if (newDate) {
            // If showing exact drop position is requested
            if (showExactDropPosition) {
                // Rounding new deadline date value using timeaxis which will also snap the date rounded to gantt's
                // snap pixel amount
                newDate = gantt.timeAxis.roundDate(newDate, snapRelativeToEventStartDate ? task.getDeadlineDate() : false);
                // If weekends skipping is requested then skipping
                if (skipWeekendsDuringDragDrop) {
                    // WARNING: calling private method, but the same has been done in original/non-refactored
                    //          Gnt.features.TaskDragDrop code, so don't blame me.
                    newDate = task.skipNonWorkingTime(newDate, false);
                }
                // gantt.getCoordinateFromDate() call assumes date is within timeaxis time span
                // so we are to normalize new start, new end dates to be within it
                newDate = Sch.util.Date.max(newDate, gantt.timeAxis.getStart());
                newDate = Sch.util.Date.min(newDate, gantt.timeAxis.getEnd());
            }
            // We need page coordniates here, they are usually passed to DragZone#alignElWithMouse()
            // via DragZone::setDragElPos() later on
            newDateX = gantt.getCoordinateFromDate(newDate, false);
            result = (doFn || Ext.returnTrue)(newDate, newDateX);
        }
        return result;
    }
    function processDrop(me, gantt, target, task, newDate, dropSource, data, e) {
        (new Ext.Promise(function(resolve, reject) {
            var dropHandler = new Gnt.feature.taskdd.AsyncDropHandler(resolve, reject, function() {
                    doDefaultDropProcessing(me, task, newDate);
                }),
                eventCanceled;
            /**
             * @event before-deadline-drop-finalize
             *
             * Cancelable
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {Date} newDate
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Gnt.feature.taskdd.AsyncDropHandler} dropHandler
             *
             * @member Gnt.view.Gantt
             */
            if (gantt.hasListeners['before-deadline-drop-finalize']) {
                eventCanceled = (false === gantt.fireEvent('before-deadline-drop-finalize', gantt, target, newDate, dropSource, data, e, dropHandler));
            }
            if (eventCanceled && !dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
                dropHandler.cancel();
            } else if (!dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
                dropHandler.process();
                dropHandler.done();
            }
        }).then(function(result) {
            /**
             * @event deadline-drop-done
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {Date} newDate
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Mixed} result Processing done result
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners['deadline-drop-done'] && gantt.fireEvent('deadline-drop-done', gantt, target, newDate, dropSource, data, e, result);
        }).then(undefined, function(result) {
            /**
             * @event deadline-drop-cancel
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {Date} newDate
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Mixed} result Processing cancel result
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners['deadline-drop-cancel'] && gantt.fireEvent('deadline-drop-cancel', gantt, target, newDate, dropSource, data, e, result);
        }));
    }
    function doDefaultDropProcessing(me, task, newDate) {
        task.setDeadlineDate(newDate);
    }
    return {
        extend: 'Ext.plugin.Abstract',
        alias: 'plugin.gantt_deadlinedragdrop',
        id: 'deadlinedragdrop',
        requires: [
            'Ext.Promise',
            'Sch.util.Date',
            'Gnt.Tooltip',
            'Gnt.feature.taskdd.AsyncDropHandler'
        ],
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt Gantt view the drop controller works with
             */
            gantt: null,
            /**
             * @cfg {Boolean|Object} tooltip True or a custom config object to enable and apply to the {@link Gnt.Tooltip} instance.
             *
             * Pass false to disable tooltip during in row dragging.
             */
            tooltip: null,
            /**
             * @cfg {Function} validatorFn An empty function by default.
             *
             * Provide to perform custom validation on the item being dragged.
             * This function is called during the drag and drop process and also after the drop is made.
             *
             * @param {Gnt.model.Task} record The record the deadline of which is being dragged
             * @param {Date} date The new deadline date
             * @param {Ext.EventObject} e The event object
             * @return {Boolean} true if the drop position is valid, else false to prevent a drop
             */
            validatorFn: Ext.returnTrue,
            /**
             * @cfg {Boolean} [showExactDropPosition=false] When enabled, the deadline being dragged always "snaps" to the exact date that it will have after being dropped.
             */
            showExactDropPosition: false,
            /**
             * @cfg {Boolean} [snapRelativeToEventStartDate=false] Whether to snap relative to deadline start position or to time axis start date.
             *
             * The option is in effect only if {@link #showExactDropPosition} is set to *true*.
             */
            snapRelativeToEventStartDate: false,
            /**
             * @cfg {Boolean} [skipWeekendsDuringDragDrop=false] When enabled, that deadline being dragged will skip weekend dates.
             */
            skipWeekendsDuringDragDrop: false,
            /**
             * @cfg {String} [dropAllowedCls='sch-gantt-dragproxy'] A CSS class to apply to drag proxy if drop is valid at the point
             */
            dropAllowedCls: 'sch-gantt-dragproxy'
        },
        ganttDetacher: null,
        /**
         * @inheritdoc
         */
        destroy: function() {
            var me = this;
            me.setTooltip(null);
            // this will destroy the tooltip
            me.setGantt(null);
            // this will detach from gantt events if any are being listened for
            me.callParent();
        },
        /**
         * Enables deadline drag & drop
         */
        enable: function() {
            var me = this;
            if (me.disabled) {
                me.callParent();
                me.attachToGantt();
            }
        },
        /**
         * Disables deadline drag & drop
         */
        disable: function() {
            var me = this;
            if (!me.disabled) {
                me.callParent();
                me.detachFromGantt();
            }
        },
        updateGantt: function(gantt, oldGantt) {
            var me = this;
            oldGantt && me.detachFromGantt();
            gantt && !me.disabled && me.attachToGantt();
        },
        attachToGantt: function() {
            var me = this;
            me.ganttDetacher = me.getGantt().on({
                scope: me,
                destroyable: true,
                'task-row-drag-enter': me.onTaskRowDragEnter,
                'task-row-drag-over': me.onTaskRowDragOver,
                'task-row-drag-drop': me.onTaskRowDragDrop,
                'schedule-drag-over': me.onTaskContainerOver,
                'aftertaskdrop': me.onAfterTaskDrop
            });
        },
        detachFromGantt: function() {
            var me = this;
            me.ganttDetacher && (Ext.destroy(me.ganttDetacher) , me.ganttDetacher = null);
        },
        applyTooltip: function(tooltip) {
            var me = this;
            if (tooltip && !(tooltip instanceof Gnt.Tooltip)) {
                tooltip = Ext.create(Ext.apply({}, tooltip === true ? {} : tooltip, {
                    xclass: 'Gnt.Tooltip',
                    gantt: me.getGantt(),
                    constrainTo: me.getGantt().getEl(),
                    cls: "gnt-dragdrop-tip",
                    hidden: true,
                    avoidPointer: true,
                    $ownedBy: me
                }));
            }
            return tooltip;
        },
        updateTooltip: function(tooltip, oldTooltip) {
            var me = this;
            if (oldTooltip && oldTooltip.$ownedBy === me) {
                Ext.destroy(oldTooltip);
            }
        },
        updateTipContent: function(tip, taskRecord, date, valid) {
            tip.updateContent(null, date || taskRecord.getDeadlineDate(), valid === undefined ? true : valid, taskRecord);
        },
        onTaskRowDragEnter: function(gantt, target, dropSource, data, e) {
            var me = this,
                taskXY, elXY, offsets, tip;
            if (data.isDeadlineDrag) {
                // Deadline dragging is always happens within task row, so attaching proxy to gantt view element
                dropSource.getProxy().setForceAttachTo(gantt.getSecondaryCanvasEl());
                // Hiding initial deadline element (it's now represented by the proxy)
                Ext.fly(data.ddel).hide();
                // Constraining proxy movement within initial task row
                taskXY = Ext.fly(data.ddel).getXY();
                taskXY = new Ext.util.Point(taskXY[0], taskXY[1]);
                elXY = Ext.fly(dropSource.getEl()).getXY();
                elXY = new Ext.util.Point(elXY[0], elXY[1]);
                offsets = taskXY.getOffsetsTo(elXY);
                // This is DD magic, believe me it should be like this
                // Internally setInitPosition() takes page coordinates of the dropSource.getEl() (which is gantt view
                // in our case, and then substracts from it deltaX, deltaY, passed as arguments, and stores the result
                // as dragging initial page coordinates.
                dropSource.setInitPosition(-offsets.x, -offsets.y);
                dropSource.setDelta(data.startOffsets.x, data.startOffsets.y);
                dropSource.setYConstraint(0, 0);
                // Aligning tooltip
                tip = me.getTooltip();
                tip && me.updateTipContent(tip, data.record);
                tip && tip.showBy(dropSource.getProxy().getGhost());
            }
        },
        onTaskRowDragOver: function(gantt, target, dropSource, data, e, canHandleDrop) {
            var me = this,
                eXY, tip, task;
            if (data.isDeadlineDrag) {
                // To keep visual compatibility with previous task drag & drop implementation we should always
                // report as if we can handle task drop here
                canHandleDrop(me.getDropAllowedCls());
                task = data.record;
                eXY = e.getXY();
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedDeadlineCoordinate(// Providing function with dragged element top/left coordniate for it to be able to calculate
                // proposed new deadline date
                eXY[0] - data.startOffsets.x, // Other params required for calculation
                task, gantt, me.getShowExactDropPosition(), me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), function(newDate, newDateX) {
                    var valid = true,
                        validDragElX, validDragElY;
                    // We add offsets here because the same offsets has been passing to DragZone::setDelta() at
                    // the drag enter event handler. The offsets set via setDelta will be automatically substracted
                    // from the coordinates we pass here, thus we adding them back. In other words
                    // DragZone::setDragElPos() expects here the coordinates of the mouse pointer, not the coordinates
                    // of dragged element
                    validDragElX = newDateX + data.startOffsets.x;
                    validDragElY = eXY[1] + data.startOffsets.y;
                    // We do not rely on default proxy movement here and update drag element position manually
                    // due to the fact that node over notification might come via emulation layer in
                    // Gnt.feature.taskdd.DropZone activated upon drop zone element scrolling.
                    dropSource.setDragElPos(validDragElX, validDragElY);
                    // Validating drop with user supplied validatorFn, here just to update the tip
                    if (me.getValidatorFn()) {
                        valid = (false !== (me.getValidatorFn())(task, newDate, e));
                    }
                    // Aligning tooltip
                    tip = me.getTooltip();
                    tip && me.updateTipContent(tip, task, newDate, valid);
                    tip && tip.showBy(dropSource.getProxy().getGhost());
                    return true;
                });
            }
        },
        onTaskRowDragDrop: function(gantt, target, dropSource, data, e) {
            var me = this,
                eXY, task;
            if (data.isDeadlineDrag) {
                task = data.record;
                eXY = e.getXY();
                // The method contains the logic to snap task to exact drop start/end dates
                withSnappedDeadlineCoordinate(// Providing function with dragged element left coordniate for it to be able to calculate
                // proposed new deadline date
                eXY[0] - data.startOffsets.x, // Other params required for calculation
                task, gantt, me.getShowExactDropPosition(), me.getSnapRelativeToEventStartDate(), me.getSkipWeekendsDuringDragDrop(), function(newDate, newDateX) {
                    var valid = true;
                    // Processing drop only if task's deadline date is to be changed
                    if (task.getDeadlineDate() - newDate) {
                        // Validating drop with user supplied validatorFn
                        if (me.getValidatorFn()) {
                            valid = (false !== (me.getValidatorFn())(task, newDate, e));
                        }
                        valid && processDrop(me, gantt, target, task, newDate, dropSource, data, e);
                    }
                });
            }
        },
        onTaskContainerOver: function(gantt, dropSource, data, e, canHandleDrop) {
            var me = this;
            if (data.isDeadlineDrag) {
                // Deadline dragging is always constrained to be within initial task row, so we should report
                // as if we can handle drop to keep compatibility with the previous task drag & drop implementation
                canHandleDrop(me.getDropAllowedCls());
            }
        },
        onAfterTaskDrop: function(gantt, record, e, data, dropSource) {
            var me = this,
                tip;
            // We don't always get drag out event, thus this is the last chance to do cleanup
            if (data.isDeadlineDrag) {
                // Returning proxy back to body
                dropSource.getProxy().setForceAttachTo(null);
                tip = me.getTooltip();
                tip && tip.hide();
                Ext.fly(data.ddel).show();
            }
        }
    };
});

/**
 * @class Gnt.feature.taskdd.plugin.OutOfRowTaskDragDrop
 *
 * Task reording and moving / copying from other Gantt components drop controller
 */
Ext.define('Gnt.feature.taskdd.plugin.OutOfRowTaskDragDrop', function(thisClass) {
    var INS_INTO = 'into',
        INS_BEFORE = 'before',
        INS_AFTER = 'after';
    function calcSnappedDropMarkerCoordinate(targetRow, proposedY) {
        var result = false,
            rowRegion, rowInnerRegion, rowHeight, proposedRegion;
        targetRow = Ext.fly(targetRow);
        rowRegion = targetRow.getRegion();
        rowHeight = rowRegion.getHeight();
        rowInnerRegion = Ext.util.Region.from(rowRegion).adjust(rowHeight * 0.25, 0, -rowHeight * 0.25, 0).round();
        proposedRegion = new Ext.util.Region(proposedY, rowRegion.right, proposedY, rowRegion.left);
        if (proposedRegion.bottom < rowInnerRegion.top) {
            result = {
                coord: rowRegion.top,
                pos: INS_BEFORE
            };
        } else if (proposedRegion.top > rowInnerRegion.bottom) {
            result = {
                coord: rowRegion.bottom,
                pos: INS_AFTER
            };
        } else {
            result = {
                coord: proposedY,
                pos: INS_INTO
            };
        }
        return result;
    }
    function withSnappedDropMarkerCoordinate(targetRow, proposedY, doFn) {
        var advice;
        doFn = doFn || Ext.returnTrue;
        advice = calcSnappedDropMarkerCoordinate(targetRow, proposedY);
        return doFn(advice.coord, advice.pos);
    }
    function isValidTarget(gantt, targetRow, dropSource, data, proposedY) {
        var result = false,
            draggedTask, overTask;
        // Can't drop on itself
        if (!Ext.fly(data.item).contains(targetRow)) {
            draggedTask = data.record;
            overTask = gantt.getRecord(targetRow);
            // Ancestor node can't be dropped into/before/after it's descendant
            result = overTask ? !overTask.isAncestor(draggedTask) : false;
        }
        return result;
    }
    function doProcessDrop(gantt, target, insPos, dropSource, data, e, dropActionFn) {
        (new Ext.Promise(function(resolve, reject) {
            var dropHandler = new Gnt.feature.taskdd.AsyncDropHandler(resolve, reject, dropActionFn),
                eventCanceled;
            /**
             * @event before-task-outrow-drop-finalize
             *
             * Cancelable
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {String} insPos ("into" / "before" / "after")
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Gnt.feature.taskdd.AsyncDropHandler} dropHandler
             *
             * @member Gnt.view.Gantt
             */
            if (gantt.hasListeners['before-task-outrow-drop-finalize']) {
                eventCanceled = (false === gantt.fireEvent('before-task-outrow-drop-finalize', gantt, target, insPos, dropSource, data, e, dropHandler));
            }
            if (eventCanceled && !dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
                dropHandler.cancel();
            } else if (!dropHandler.isWaiting() && (!dropHandler.isDone() || !dropHandler.isCanceled())) {
                dropHandler.process();
                dropHandler.done();
            }
        }).then(function(result) {
            /**
             * @event task-outrow-drop-done
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {String} insPos ("into" / "before" / "after")
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Mixed} result Processing done result
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners['task-outrow-drop-done'] && gantt.fireEvent('task-outrow-drop-done', gantt, target, insPos, dropSource, data, e, result);
        }).then(undefined, function(result) {
            // This is a `catch` call (https://www.sencha.com/forum/showthread.php?333035-Ext-Promise-otherwise-vs-catch)
            /**
             * @event task-outrow-drop-cancel
             *
             * @param {Gnt.view.Gantt} gantt
             * @param {HTMLElement} target
             * @param {String} insPos ("into" / "before" / "after")
             * @param {Gnt.feature.taskdd.DragZone} dropSource
             * @param {Object} data
             * @param {Ext.event.Event} e
             * @param {Mixed} result Processing cancel result
             *
             * @member Gnt.view.Gantt
             */
            gantt.hasListeners['task-outrow-drop-canceled'] && gantt.fireEvent('task-outrow-drop-canceled', gantt, target, insPos, dropSource, data, e, result);
        }));
    }
    function doDefaultDropProcessing(gantt, target, insPos, draggedTask) {
        var overTask, wasLeaf;
        overTask = target && gantt.getRecord(target) || gantt.getTaskStore().getRoot();
        // Just in case
        if (overTask) {
            wasLeaf = overTask.isLeaf();
            // If tasks are from a different stores
            if (overTask.getTaskStore() !== draggedTask.getTaskStore()) {
                draggedTask = draggedTask.copy(null);
            }
            if (insPos == INS_INTO) {
                overTask.appendChild(draggedTask);
            } else if (insPos == INS_BEFORE) {
                overTask.parentNode.insertBefore(draggedTask, overTask);
            } else if (insPos == INS_AFTER) {
                overTask.parentNode.insertChild(overTask.parentNode.indexOf(overTask) + 1, draggedTask);
            }
            // Expanding over node if it's become parent
            if (wasLeaf && !overTask.isLeaf()) {
                overTask.expand();
            }
        }
    }
    return {
        extend: 'Ext.plugin.Abstract',
        alias: 'plugin.gantt_outofrowtaskdragdrop',
        id: 'outofrowtaskdragdrop',
        requires: [
            'Ext.util.Region',
            'Ext.util.Point',
            'Ext.Promise',
            'Gnt.feature.taskdd.AsyncDropHandler'
        ],
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt Gantt view the drop controller works with
             */
            gantt: null,
            /**
             * @cfg {String} dropMarkerCls
             */
            dropMarkerCls: 'gnt-taskdd-dropmarker',
            /**
             * @cfg {Number} expandTimeout Timeout in milliseconds after which collapsed parent task will be expanded
             *                             if mouse stays in such task's row. Set to false to disable auto expansion
             */
            expandTimeout: 2000,
            /**
             * @cfg {Function} validatorFn An empty function by default
             *
             * Provide it to perform custom drop validation
             *
             * @param {Gnt.view.Gantt}    validatorFn.gantt              Gantt view dragged item is from
             * @param {HTMLElement}       validatorFn.target             Drop target element
             * @param {Ext.dd.DropSource} validatorFn.dropSource         Drag & Drop source object
             * @param {Object}            validatorFn.data               Drag & Drop data
             * @param {Number}            validatorFn.proposedY          Drop Y coordinate
             * @param {Function}          validatorFn.defaultValidatorFn Default validator function
             * @return {Boolean}          validatorFn.return
             *
             */
            validatorFn: null
        },
        ganttDetacher: null,
        dropMarkerEl: null,
        lastOverTarget: null,
        animating: false,
        expandProcId: null,
        destroy: function() {
            var me = this;
            me.destroyDropMarkerEl();
            me.stopScheduledExpanding();
            me.setGantt(null);
            // this will detach from gantt events if any are being listened for
            me.callParent();
        },
        /**
         * Enables task out of row drag & drop
         */
        enable: function() {
            var me = this;
            if (me.disabled) {
                me.callParent();
                me.attachToGantt();
            }
        },
        /**
         * Disables task out of row drag & drop
         */
        disable: function() {
            var me = this;
            if (!me.disabled) {
                me.callParent();
                me.detachFromGantt();
            }
        },
        updateGantt: function(gantt, oldGantt) {
            var me = this;
            oldGantt && me.detachFromGantt();
            gantt && !me.disabled && me.attachToGantt();
        },
        attachToGantt: function() {
            var me = this;
            me.ganttDetacher = me.getGantt().on({
                scope: me,
                destroyable: true,
                'task-row-drag-enter': me.onTaskRowDragEnter,
                'task-row-drag-out': me.onTaskRowDragOut,
                'task-row-drag-over': me.onTaskRowDragOver,
                'task-row-drag-drop': me.onTaskRowDragDrop,
                'schedule-drag-over': me.onTaskContainerOver,
                'schedule-drag-out': me.onTaskContainerOut,
                'schedule-drag-drop': me.onTaskContainerDrop,
                'aftertaskdrop': me.onAfterTaskDrop
            });
        },
        detachFromGantt: function() {
            var me = this;
            me.ganttDetacher && (Ext.destroy(me.ganttDetacher) , me.ganttDetacher = null);
        },
        hasDropMarkerEl: function() {
            return !!this.dropMarkerEl;
        },
        getDropMarkerEl: function() {
            var me = this,
                el = me.dropMarkerEl;
            if (!el) {
                el = me.dropMarkerEl = me.getGantt().getItemCanvasEl().createChild({
                    tag: 'div',
                    cls: me.getDropMarkerCls(),
                    style: {
                        display: 'none',
                        width: me.getGantt().getEl().getWidth() + 'px'
                    }
                });
            }
            return el;
        },
        reAttachDropMarkerEl: function() {
            var me = this,
                el = me.dropMarkerEl;
            if (el) {
                el = me.getGantt().getItemCanvasEl().appendChild(el);
            }
        },
        destroyDropMarkerEl: function() {
            var me = this;
            me.dropMarkerEl && (Ext.destroy(me.dropMarkerEl) , me.dropMarkerEl = null , me.animating = false);
        },
        stopScheduledExpanding: function() {
            var me = this;
            if (me.expandProcId) {
                clearTimeout(me.expandProcId);
                me.expandProcId = null;
            }
        },
        onTaskRowDragEnter: function(gantt, target, dropSource, data, e) {
            var me = this,
                overTask;
            // This is for the browsers which do not support pointer-events: none
            // See onContainerOver() for further details
            me.lastOverTarget = target;
            overTask = gantt.getRecord(target);
            if (!overTask.isLeaf() && !overTask.isExpanded() && me.getExpandTimeout()) {
                me.expandProcId = Ext.Function.defer(function() {
                    me.stopScheduledExpanding();
                    overTask.expand(false, function() {
                        me.reAttachDropMarkerEl();
                    });
                }, me.getExpandTimeout());
            }
        },
        onTaskRowDragOut: function(gantt, target, dropSource, data, e) {
            var me = this;
            // This is for the browsers which do not support pointer-events: none
            // See onContainerOver() for further details
            me.lastOverTarget = null;
            me.stopScheduledExpanding();
        },
        onTaskRowDragOver: function(gantt, target, dropSource, data, e, canHandleDrop) {
            var me = this,
                eXY, el,
                validatorFn = me.getValidatorFn() || isValidTarget;
            if (data.isTaskDrag && !Ext.fly(data.item).contains(target)) {
                eXY = e.getXY();
                el = me.getDropMarkerEl();
                withSnappedDropMarkerCoordinate(target, eXY[1], function(snappedY, insPos) {
                    if (!me.animating) {
                        me.animating = true;
                        if (insPos != INS_INTO && !el.isVisible(true)) {
                            el.show();
                        }
                        el.animate({
                            to: {
                                y: snappedY,
                                opacity: insPos == INS_INTO ? 0 : 1
                            },
                            listeners: {
                                afteranimate: function() {
                                    insPos == INS_INTO && el.hide();
                                    me.animating = false;
                                }
                            }
                        });
                    }
                    if (validatorFn(gantt, target, dropSource, data, eXY[1], isValidTarget)) {
                        canHandleDrop();
                    }
                });
            } else if (data.isTaskDrag && me.hasDropMarkerEl()) {
                me.getDropMarkerEl().hide();
            }
        },
        onTaskRowDragDrop: function(gantt, target, dropSource, data, e) {
            var me = this,
                eXY, dragMarkerEl;
            if (data.isTaskDrag && !Ext.fly(data.item).contains(target)) {
                eXY = e.getXY();
                withSnappedDropMarkerCoordinate(target, eXY[1], function(snappedY, insPos) {
                    me.processDrop(gantt, target, insPos, dropSource, data, e, function() {
                        doDefaultDropProcessing(gantt, target, insPos, data.record);
                    });
                });
            }
        },
        onTaskContainerOver: function(gantt, dropSource, data, e, canHandleDrop) {
            var me = this;
            // We can always handle drop on the container
            if (data.isTaskDrag) {
                canHandleDrop();
            }
        },
        onTaskContainerOut: function(gantt, dropSource, data, e) {
            var me = this;
            me.destroyDropMarkerEl();
        },
        onTaskContainerDrop: function(gantt, dropSource, data, e) {
            var me = this;
            // This is for the browsers which do not support pointer-events: none
            if (data.isTaskDrag && me.lastOverTarget) {
                me.onTaskRowDragDrop(gantt, me.lastOverTarget, dropSource, data, e);
            } else if (data.isTaskDrag) {
                me.processDrop(gantt, null, INS_INTO, dropSource, data, e, function() {
                    doDefaultDropProcessing(gantt, null, INS_INTO, data.record);
                });
            }
        },
        onAfterTaskDrop: function(gantt, record, e, data, dropSource) {
            var me = this;
            if (me.hasDropMarkerEl()) {
                // Any drop is a signal to remove marker from the view
                me.destroyDropMarkerEl();
            }
        },
        processDrop: function(gantt, target, insPos, dropSource, data, e, dropActionFn) {
            return doProcessDrop(gantt, target, insPos, dropSource, data, e, dropActionFn);
        }
    };
});

/**
 * This plugin contains logic responsible for resource drops processing
 */
Ext.define("Gnt.feature.taskdd.plugin.ResourceDrop", function(thisClass) {
    function toArray(records) {
        return records ? (!Ext.isArray(records) ? [
            records
        ] : records) : [];
    }
    function isResourceAlike(record) {
        return record.isResource || (record.isUtilizationResource && record.isSurrogateResource());
    }
    function extractResource(record) {
        return record.isUtilizationResource ? record.getOriginalResource() : record;
    }
    function canExtractResourcesFrom(records) {
        return Ext.Array.some(toArray(records), function(r) {
            return isResourceAlike(r);
        });
    }
    function extractResourcesFrom(records) {
        return Ext.Array.reduce(toArray(records), function(result, r) {
            if (isResourceAlike(r)) {
                result.push(extractResource(r));
            }
            return result;
        }, []);
    }
    function filterOutAssignedResources(task, resources) {
        return Ext.Array.filter(toArray(resources), function(r) {
            return !task.getAssignmentFor(r);
        });
    }
    function canAssignResourcesTo(task, resources) {
        return filterOutAssignedResources(task, resources).length > 0;
    }
    function assignResourcesTo(task, resources) {
        Ext.Array.each(toArray(resources), function(r) {
            task.assign(r);
        });
    }
    function getTargetTask(gantt, targetNode) {
        return gantt.ownerGrid.resolveTaskRecord(targetNode);
    }
    return {
        extend: 'Ext.plugin.Abstract',
        alias: 'plugin.gantt_resourcedrop',
        id: 'resourcedrop',
        config: {
            /**
             * @cfg {Gnt.view.Gantt} gantt Gantt view the drop controller works with
             */
            gantt: null
        },
        ganttDetacher: null,
        /**
         * @inheritdoc
         */
        destroy: function() {
            var me = this;
            me.setGantt(null);
            // this will detach from gantt events if any are being listened for
            me.callParent();
        },
        /**
         * Enables resource nodes drop
         */
        enable: function() {
            var me = this;
            if (me.disabled) {
                me.callParent();
                me.attachToGantt();
            }
        },
        /**
         * Disables resource nodes drop
         */
        disable: function() {
            var me = this;
            if (!me.disabled) {
                me.callParent();
                me.detachFromGantt();
            }
        },
        updateGantt: function(gantt, oldGantt) {
            var me = this;
            oldGantt && me.detachFromGantt();
            gantt && !me.disabled && me.attachToGantt();
        },
        attachToGantt: function() {
            var me = this;
            me.ganttDetacher = me.getGantt().on({
                scope: me,
                destroyable: true,
                'task-row-drag-over': me.onTaskRowDragOver,
                'task-row-drag-drop': me.onTaskRowDragDrop
            });
        },
        detachFromGantt: function() {
            var me = this;
            me.ganttDetacher && (Ext.destroy(me.ganttDetacher) , me.ganttDetacher = null);
        },
        onTaskRowDragOver: function(gantt, target, dropSource, data, e, canHandleDrop) {
            var task;
            if (data.records && canExtractResourcesFrom(data.records)) {
                task = getTargetTask(gantt, target);
                if (task && canAssignResourcesTo(task, extractResourcesFrom(data.records))) {
                    canHandleDrop();
                }
            }
        },
        onTaskRowDragDrop: function(gantt, target, dropSource, data, e) {
            var resources, task;
            if (data.records && canExtractResourcesFrom(data.records)) {
                task = getTargetTask(gantt, target);
                if (task) {
                    resources = filterOutAssignedResources(task, extractResourcesFrom(data.records));
                    assignResourcesTo(task, resources);
                }
            }
        }
    };
});

/**
 * Internal plugin enabling drag and drop for tasks
 */
Ext.define("Gnt.feature.taskdd.DragZone", {
    extend: "Ext.dd.DragZone",
    requires: [
        'Ext.mixin.Pluggable',
        'Ext.util.Point',
        'Ext.dd.StatusProxy',
        'Ext.dd.DropZone',
        'Sch.patches.DragZoneDupIds',
        'Gnt.feature.taskdd.Proxy',
        'Gnt.feature.taskdd.DropZone',
        'Gnt.feature.taskdd.plugin.InRowTaskDragDrop',
        'Gnt.feature.taskdd.plugin.SegmentDragDrop',
        'Gnt.feature.taskdd.plugin.DeadlineDragDrop',
        'Gnt.feature.taskdd.plugin.OutOfRowTaskDragDrop',
        'Gnt.feature.taskdd.plugin.ResourceDrop'
    ],
    mixins: {
        pluggable: 'Ext.mixin.Pluggable'
    },
    config: {
        /**
        * @cfg {Gnt.view.Gantt} gantt Reference to the gantt view
        */
        gantt: null,
        /**
        * @cfg {String} taskSelector Task element CSS selector
        */
        taskSelector: null,
        /**
        * @cfg {String} deadlineSelector Deadline element CSS selector
        */
        deadlineSelector: null,
        /**
        * @cfg {Boolean} [useTooltip=true] `false` to not show a tooltip while dragging
        */
        useTooltip: true,
        /**
        * @cfg {Object} [tooltipConfig=null] A custom config object to apply to the {@link Gnt.Tooltip} instance.
        */
        tooltipConfig: null,
        /**
        * @cfg {Function} [validatorFn] An empty function by default.
        *
        * Provide to perform custom validation on the item being dragged.
        * This function is called during the drag and drop process and also after the drop is made.
        *
        * @param {Gnt.model.Task} record The record being dragged
        * @param {Date} date The new start date
        * @param {Number} duration The duration of the item being dragged, in minutes
        * @param {Ext.EventObject} e The event object
        * @return {Boolean} true if the drop position is valid, else false to prevent a drop
        */
        validatorFn: Ext.returnTrue,
        /**
        * @cfg {Object} [validatorFnScope=null]
        * The scope for the validatorFn, defaults to the gantt view instance
        */
        validatorFnScope: null,
        /**
        * @cfg {Boolean} [showExactDropPosition=false] When enabled, the task being dragged always "snaps" to the exact start date / duration that it will have after being drop.
        */
        showExactDropPosition: false,
        /**
        * @cfg {Boolean} [skipWeekendsDuringDragDrop=false] When enabled, that task being dragged will skip weekend dates.
        */
        skipWeekendsDuringDragDrop: false,
        /**
        * @cfg {Boolean} [constrainDragToTaskRow=true] When enabled dragged task element will constrained by task row
        */
        constrainDragToTaskRow: true,
        /**
        * @cfg {String} [rtlProxyCls] CSS class to add to drag proxy if Gantt is in RTL mode
        */
        rtlProxyCls: "sch-rtl",
        /**
        * @cfg {String} [invalidTargetSelector] Invalid targets CSS selector
        */
        invalidTargetSelector: [
            // Stop task drag and drop when a resize handle, a terminal or a parent task is clicked
            '.' + Ext.baseCSSPrefix + 'resizable-handle',
            '.sch-resizable-handle',
            '.sch-terminal',
            '.sch-gantt-progressbar-handle',
            '.sch-rollup-task',
            '.sch-gantt-baseline-item .sch-gantt-item'
        ].join(','),
        /**
        * @cfg {String} [initialProxyCls] Initial drag proxy status CSS class
        */
        initialProxyCls: 'sch-gantt-dragproxy',
        /**
        * @cfg {Boolean|Object} [inRowTaskDragDrop=true] In row task drag & drop controlling parameter.
        *
        * Either true to enable, false to disable or a configuration object to enable with custom configuration
        * for {@link Gnt.feature.taskdd.plugin.InRowTaskDragDrop} plugin.
        */
        inRowTaskDragDrop: true,
        /**
        * @cfg {Boolean|Object} [segmentDragDrop=true] Task segments drag & drop controlling parameter.
        *
        * Either true to enable, false to disable or a configuration object to enable with custom configuration
        * for {@link Gnt.feature.taskdd.plugin.SegmentDragDrop} plugin.
        */
        segmentDragDrop: true,
        /**
        * @cfg {Boolean|Object} [deadlineDragDrop=true] Task deadline drag & drop controlling parameter.
        *
        * Either true to enable, false to disable or a configuration object to enable with custom configuration
        * for {@link Gnt.feature.taskdd.plugin.DeadlineDragDrop} plugin.
        */
        deadlineDragDrop: true,
        /**
        * @cfg {Boolean|Object} [outOfRowDragDrop=false] Out of row task drag & drop controlling parameter.
        *
        * true to enable, false to disable or a configuration object to enable with custom configuration
        * for {@link Gnt.feature.taskdd.plugin.OutOfRowTaskDragDrop} plugin. This feature allows to drag tasks outside the Gantt view (to other Gantt/grid/tree views)
        */
        outOfRowTaskDragDrop: false,
        /**
        * @cfg {Boolean|Object} [resourceDrop=false] Resource drop controlling parameter.
        *
        * Either true to enable, false to disable or a configuration object to enable with custom configuration
        * for {@link Gnt.feature.taskdd.plugin.ResourceDrop} plugin.
        */
        resourceDrop: false,
        /**
        * Task drop zone instance paired with this drag zone
        *
        * @cfg {Gnt.feature.taskdd.DropZone) taskDropZone
        *
        * @private
        */
        taskDropZone: null
    },
    // ----------------------------------
    // has to be set to `false` - we'll register the gantt view in the ScrollManager manually
    containerScroll: false,
    dragProxyPositionLocked: false,
    /**
    * @inheritdoc
    */
    constructor: function(el, config) {
        var me = this,
            proxy;
        config = config || {};
        proxy = me.proxy || config.proxy || {};
        if (!(proxy instanceof Ext.dd.StatusProxy)) {
            me.proxy = Ext.create(Ext.apply({}, proxy, {
                xclass: 'Gnt.feature.taskdd.Proxy',
                $ownedBy: me
            }));
            delete config.proxy;
        } else {
            me.proxy = proxy;
        }
        config = Ext.applyIf(config, {
            ddGroup: config.gantt.id + '-task-dd'
        });
        me.callParent([
            el,
            config
        ]);
        me.initConfig(config);
        me.view = me.getGantt();
        // Compatibility with tree/grid view drag drop zones
        if (me.getGantt().rtl) {
            me.proxy.addCls(me.getRtlProxyCls());
        }
        // Creating pair drop zone if none is given
        if (!me.getTaskDropZone()) {
            me.setTaskDropZone({
                'xclass': 'Gnt.feature.taskdd.DropZone',
                gantt: me.getGantt(),
                ddGroup: me.ddGroup
            });
        }
        // Tasks drag & drop support
        if (me.getInRowTaskDragDrop()) {
            me.addPlugin(Ext.apply({
                type: 'gantt_inrowtaskdragdrop',
                gantt: me.getGantt(),
                tooltip: me.getUseTooltip() && (me.getTooltipConfig() || true),
                validatorFn: me.getValidatorFn() && Ext.Function.bind(me.getValidatorFn(), me.getValidatorFnScope() || me.getGantt()),
                showExactDropPosition: me.getShowExactDropPosition(),
                skipWeekendsDuringDragDrop: me.getSkipWeekendsDuringDragDrop(),
                snapRelativeToEventStartDate: me.getGantt().snapRelativeToEventStartDate,
                constrainDragToTaskRow: me.getConstrainDragToTaskRow(),
                dropAllowedCls: me.getInitialProxyCls()
            }, me.getInRowTaskDragDrop()));
        }
        // Segments drag & drop support
        if (me.getSegmentDragDrop()) {
            me.addPlugin(Ext.apply({
                type: 'gantt_segmentdragdrop',
                gantt: me.getGantt(),
                tooltip: me.getUseTooltip() && (me.getTooltipConfig() || true),
                validatorFn: me.getValidatorFn() && Ext.Function.bind(me.getValidatorFn(), me.getValidatorFnScope() || me.getGantt()),
                showExactDropPosition: me.getShowExactDropPosition(),
                skipWeekendsDuringDragDrop: me.getSkipWeekendsDuringDragDrop(),
                snapRelativeToEventStartDate: me.getGantt().snapRelativeToEventStartDate,
                dropAllowedCls: me.getInitialProxyCls()
            }, me.getSegmentDragDrop()));
        }
        // Task's deadline drag & drop support
        if (me.getDeadlineDragDrop()) {
            me.addPlugin(Ext.apply({
                type: 'gantt_deadlinedragdrop',
                gantt: me.getGantt(),
                tooltip: me.getUseTooltip() && (me.getTooltipConfig() || true),
                showExactDropPosition: me.getShowExactDropPosition(),
                skipWeekendsDuringDragDrop: me.getSkipWeekendsDuringDragDrop(),
                snapRelativeToEventStartDate: me.getGantt().snapRelativeToEventStartDate,
                dropAllowedCls: me.getInitialProxyCls()
            }, me.getDeadlineDragDrop()));
        }
        // Task reordering and external drop support
        if (me.getOutOfRowTaskDragDrop()) {
            me.setConstrainDragToTaskRow(true);
            me.addPlugin(Ext.apply({
                type: 'gantt_outofrowtaskdragdrop',
                gantt: me.getGantt()
            }, me.getOutOfRowTaskDragDrop()));
        }
        // Resources drop sopport
        if (me.getResourceDrop()) {
            me.addPlugin(Ext.apply({
                type: 'gantt_resourcedrop',
                gantt: me.getGantt()
            }, me.getResourceDrop()));
        }
    },
    /**
    * @inheritdoc
    */
    destroy: function() {
        var me = this;
        me.setPlugins(null);
        me.proxy && me.proxy.$ownedBy == me && Ext.destroy(me.proxy);
        me.taskDropZone && me.taskDropZone.getOwnerDragZone() == me && Ext.destroy(me.taskDropZone);
        me.callParent();
    },
    applyTaskDropZone: function(dropZone) {
        var me = this;
        if (!(dropZone instanceof Ext.dd.DropZone)) {
            dropZone = Ext.apply({}, dropZone || {}, {
                'xclass': 'Gnt.feature.taskdd.DropZone',
                gantt: me.getGantt(),
                ddGroup: me.ddGroup,
                ownerDragZone: me
            });
            dropZone = Ext.create(dropZone.xclass, me.getEl(), dropZone);
        }
        return dropZone;
    },
    /**
    * @inheritdoc
    */
    isValidHandleChild: function(node) {
        var me = this;
        return me.callParent([
            node
        ]) && !Ext.fly(node).is(me.getInvalidTargetSelector());
    },
    /**
    * @inheritdoc
    */
    getDragData: function(e) {
        var me = this,
            gantt = me.getGantt(),
            result = null,
            taskEl, taskSegmentEl, taskSegmentIdx, deadlineEl, draggedEl, rowEl, draggedTask, startPoint, startPointDate, startOffsets, isTaskDrag, isTaskSegmentDrag, isDeadlineDrag, xy;
        taskEl = e.getTarget(me.taskSelector);
        taskSegmentEl = taskEl && e.getTarget('.sch-gantt-task-segment');
        taskSegmentIdx = Number(taskSegmentEl && taskSegmentEl.getAttribute('data-segmentIndex'));
        deadlineEl = !taskEl && e.getTarget(me.deadlineSelector);
        rowEl = e.getTarget(gantt.getItemSelector());
        // Dragging the first segment means move the entire task, otherwise drag the segment node
        draggedEl = taskSegmentEl && taskSegmentIdx > 0 && taskSegmentEl || taskEl || deadlineEl;
        draggedTask = draggedEl && gantt.resolveTaskRecord(draggedEl);
        if (draggedTask && taskSegmentEl && taskSegmentIdx > 0) {
            draggedTask = draggedTask.getSegment(taskSegmentIdx);
        }
        isTaskDrag = !!taskEl && (!taskSegmentEl || taskSegmentIdx === 0);
        isTaskSegmentDrag = !!taskSegmentEl && taskSegmentIdx > 0;
        isDeadlineDrag = !!deadlineEl;
        if (draggedTask && ((isTaskDrag && (me.getInRowTaskDragDrop() || me.getOutOfRowTaskDragDrop())) || (isTaskSegmentDrag && me.getSegmentDragDrop()) || (isDeadlineDrag && me.getDeadlineDragDrop()))) {
            if (gantt.rtl && gantt.shouldAdjustForRtl()) {
                startPoint = Ext.util.Point.fromEvent(e);
            } else {
                xy = e.getXY();
                startPoint = new Ext.util.Point(xy[0], xy[1]);
            }
            startPointDate = gantt.getDateFromDomEvent(e);
            startOffsets = startPoint.getOffsetsTo(Ext.fly(draggedEl).getRegion());
            startOffsets = new Ext.util.Point(startOffsets.x, startOffsets.y);
            result = {
                ddel: draggedEl,
                record: draggedTask,
                records: [
                    draggedTask
                ],
                // compatibility with TreeView/GridView drop zone
                item: rowEl,
                // compatibility with TreeView/GridView drop zone,
                segmentIndex: taskSegmentIdx,
                startPoint: startPoint,
                startPointDate: startPointDate,
                startOffsets: startOffsets,
                isTaskDrag: isTaskDrag,
                isTaskSegmentDrag: isTaskSegmentDrag,
                isDeadlineDrag: isDeadlineDrag
            };
        } else {
            // Iterate over each plugin and allow it to provide drag data
            result = Ext.Array.reduce(me.getPlugins(), function(result, p) {
                if (!result && Ext.isFunction(p.getDragData)) {
                    result = p.getDragData(e);
                }
                return result;
            }, null);
        }
        if (result) {
            // Iterate over each plugin and allow it to extend drag data
            result = Ext.Array.reduce(me.getPlugins(), function(result, p) {
                if (Ext.isFunction(p.extendDragData)) {
                    result = p.extendDragData(e, result);
                }
                return result;
            }, result);
        }
        return result;
    },
    onBeforeDrag: function(data, e) {
        var me = this,
            result = true;
        /**
         * @event beforetaskdrag
         * @preventable
         *
         * Fires before a task drag drop is initiated, return false to cancel it
         *
         * @param {Gnt.view.Gantt} gantt The gantt view instance
         * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
         * @param {Ext.EventObject} e The event object
         * @param {Object} data Drag data
         * @param {Gnt.feature.taskdd.DragZone} dragZone
         *
         * @member Gnt.view.Gantt
         */
        if (me.gantt.hasListeners.beforetaskdrag) {
            result = (false !== me.gantt.fireEvent('beforetaskdrag', me.gantt, data.record, e, data, me));
        }
        if (result) {
            // This might be handy during drag process and shouldn't change until dragging stops
            me.cachedViewportSize = {
                width: Ext.Element.getViewportWidth(),
                height: Ext.Element.getViewportHeight()
            };
        }
        return result;
    },
    onStartDrag: function(x, y) {
        var me = this,
            data = me.dragData,
            proxy = me.getProxy();
        proxy.forceStatus(me.getInitialProxyCls());
        me.prepareProxyForDragging(proxy, data, x, y);
        me.setDelta(data.startOffsets.x, data.startOffsets.y);
        me.alignElWithMouse(proxy.getEl(), x, y);
        /**
         * @event taskdragstart
         *
         * Fires when a dnd operation starts
         *
         * @param {Gnt.view.Gantt} gantt The gantt view instance
         * @param {Gnt.model.Task} taskRecord The record being dragged
         * @param {Object} xy Pointer page coordinates
         * @param {Object} data Drag data
         * @param {Gnt.feature.taskdd.DragZone} dragZone
         *
         * @member Gnt.view.Gantt
         */
        return me.gantt.hasListeners.taskdragstart && me.gantt.fireEvent('taskdragstart', me.gantt, data.record, {
            x: x,
            y: y
        }, me.dragData, me);
    },
    onEndDrag: function(data, e) {
        var me = this;
        // TODO: The name of the event should be 'aftertaskdrag'
        // https://app.assembla.com/spaces/bryntum/tickets/6480-gnt-feature-taskdd-dragzone--change-event-aftertaskdrop-into-aftertaskdrag/details
        /**
         * @event aftertaskdrop
         *
         * Fires after a drag and drop operation, regardless if the drop valid or invalid
         *
         * @param {Gnt.view.Gantt} gantt The gantt view instance
         * @param {Gnt.model.Task} task The task instance
         * @param {Ext.EventObject} e The event object
         * @param {Object} data Drag data
         * @param {Gnt.feature.taskdd.DragZone} dragZone
         *
         * @member Gnt.view.Gantt
         */
        return me.gantt.hasListeners.aftertaskdrop && me.gantt.fireEvent('aftertaskdrop', me.gantt, data.record, e, data, me);
    },
    // beforeDragEnter : function(target, e, id) {},
    // afterDragEnter : function(target, e, id) {},
    // beforeDragOut : function(taget, e, id) {},
    // afterDragOut : function(target, e, id) {},
    // beforeDragOver : function(target, e, id) {},
    // afterDragOver : function(target, e, id) {},
    // beforeDragDrop : function(target, e, id) {},
    // afterDragDrop : function(target, e, id) {},
    // beforeInvalidDrop : function(target, e, id) {},
    // afterInvalidDrop : function(target, e, id) {},
    /**
    * @inheritdoc
    *
    * Overriden, to get rid of weird highlight fx in default implementation
    */
    afterRepair: function() {
        this.dragging = false;
    },
    /**
     * Prepares proxy for taking part in a drag operation.
     *
     * @param {Gnt.feature.taskdd.Proxy} proxy
     * @param {Mixed} data
     * @param {Number} x
     * @param {Number} y
     */
    prepareProxyForDragging: function(proxy, data, x, y) {
        var height = Ext.fly(data.ddel).getHeight();
        // Adjusting proxy size for exact matching look
        Ext.fly(proxy.getTaskGhostEl()).setHeight(height);
        if (data.isTaskDrag && data.record.isMilestone()) {
            // Firefox requires this to measure correctly in tests
            // 1204_dragdrop.t.js
            Ext.fly(proxy.getTaskGhostEl()).setWidth(Ext.fly(data.ddel).getWidth());
        }
    },
    /**
    * Locks drag proxy position such that {@link #alignElWithMouse} method has no effect any more.
    */
    lockDragProxyPosition: function() {
        this.dragProxyPositionLocked = true;
    },
    /**
    * Unlocks drag proxy position such that {@link #alignElWithMouse} method has effect again.
    */
    unlockDragProxyPosition: function() {
        this.dragProxyPositionLocked = false;
    },
    /**
     * Properly translates coordinates in case of RTL viewport
     * @param {Gnt.feature.taskdd.Proxy} proxy
     * @param {Number} x
     * @param {Number} y
     * @returns {{top: number, left: number}}
     * @private
     */
    translateXY: function(proxy, x, y) {
        var me = this,
            gantt = me.getGantt(),
            result;
        if (!gantt.rtl || gantt.shouldAdjustForRtl()) {
            result = proxy.translatePoints(x, y);
        } else {
            var el = proxy.el,
                styles = el.getStyle([
                    'position',
                    'top',
                    'right'
                ]),
                relative = styles.position === 'relative',
                left = parseFloat(styles.right),
                top = parseFloat(styles.top),
                xy = proxy.getXY();
            if (Ext.isArray(x)) {
                y = x[1];
                x = x[0];
            }
            if (isNaN(left)) {
                left = relative ? 0 : el.dom.offsetLeft;
            }
            if (isNaN(top)) {
                top = relative ? 0 : el.dom.offsetTop;
            }
            left = (typeof x === 'number') ? x - xy[0] + left : undefined;
            top = (typeof y === 'number') ? y - xy[1] + top : undefined;
            result = {
                left: left,
                top: top
            };
        }
        return result;
    },
    /**
    * @inheritdoc
    *
    * original method limits task position by viewport dimensions
    * our drag proxy might be attached to other elements but body
    * so we have to set position relative to element it's attached to
    */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var me = this,
            oCoord = me.getTargetCoord(iPageX, iPageY),
            proxy = me.getProxy(),
            proxySize = proxy.getSize(),
            proxyParent = proxy.getForceAttachTo(),
            vpSize = me.cachedViewportSize,
            localXY;
        if (!me.dragProxyPositionLocked) {
            // el here is actually proxy.getEl()
            localXY = me.translateXY(proxy, oCoord.x, oCoord.y);
            // If proxy is attached to body element then we are to constrain it's position within viewport
            if (!proxyParent) {
                // NOTE: me.lastPageX, me.lastPageY are set in me.cachePosition() to the proxy element
                //       last page x,y coordinates
                if (localXY.left < 0) {
                    oCoord.x = localXY.left = me.lastPageX || 0;
                } else if (localXY.left >= vpSize.width - proxySize.width) {
                    oCoord.x = localXY.left = me.lastPageX || (vpSize.width - proxySize.width);
                }
                if (localXY.top < 0) {
                    oCoord.y = localXY.top = me.lastPageY || 0;
                } else if (localXY.top >= vpSize.height - proxySize.height) {
                    oCoord.y = localXY.top = me.lastPageY || (vpSize.height - proxySize.height);
                }
            }
            proxy.setLocalXY(localXY.left, localXY.top);
            me.cachePosition(oCoord.x, oCoord.y);
            // If we are attached to body then giving chance for body scroll
            if (!proxy.getForceAttachTo()) {
                me.autoScroll(oCoord.x, oCoord.y, proxySize.width, proxySize.height);
            }
        }
        return oCoord;
    },
    // HACK: if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // https://app.assembla.com/spaces/bryntum/tickets/7282-ext-supports-touch-true-causes-crash-on-task-drag/details
    onInvalidDrop: function(target, e, id) {
        if (!e) {
            e = target;
            target = e.getTarget() || document.body;
        }
        return this.callParent([
            target,
            e,
            id
        ]);
    }
});

/**
 * A specialized field allowing a user to switch a task to readonly mode.
 */
Ext.define('Gnt.field.ReadOnly', {
    extend: 'Ext.form.field.Checkbox',
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.readonlyfield',
    alternateClassName: [
        'Gnt.widget.ReadOnlyField'
    ],
    fieldProperty: 'readOnlyField',
    setTaskValueMethod: 'setReadOnly',
    getTaskValueMethod: 'getReadOnly',
    instantUpdate: true,
    initEvents: function() {
        var me = this;
        me.on('change', me.onFieldValueChange, me);
        return me.callParent();
    },
    valueToVisible: function(value) {
        return value ? this.L('yes') : this.L('no');
    },
    onFieldValueChange: function(me, newValue, oldValue) {
        if (me.instantUpdate && !me.getSuppressTaskUpdate() && me.task) {
            // apply changes to task
            me.applyChanges();
        }
    }
});

/**
 * A specialized field for editing the project scheduling direction (either from the project start or from the project end date).
 * This class inherits from the Ext.form.field.ComboBox field and any of its configuration options can be used.
 */
Ext.define('Gnt.field.ScheduleBackwards', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.JsonStore',
        'Sch.patches.BoundList'
    ],
    mixins: [
        'Gnt.field.mixin.TaskField',
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.schedulebackwardsfield',
    allowBlank: false,
    forceSelection: true,
    displayField: 'text',
    valueField: 'value',
    queryMode: 'local',
    listConfig: {
        htmlEncode: true
    },
    instantUpdate: true,
    fieldProperty: 'scheduleBackwardsField',
    setTaskValueMethod: 'setScheduleBackwards',
    getTaskValueMethod: 'getScheduleBackwards',
    constructor: function(config) {
        Ext.apply(this, config);
        this.store = new Ext.data.JsonStore({
            fields: [
                'value',
                'text'
            ],
            autoDestroy: true,
            data: [
                {
                    value: 0,
                    text: this.L('Project start date')
                },
                {
                    value: 1,
                    text: this.L('Project finish date')
                }
            ]
        });
        this.callParent(arguments);
        this.on('change', this.onFieldChange, this);
    },
    onSetTask: function() {
        this.setValue(this.task.getScheduleBackwards() ? 1 : 0);
    },
    valueToVisible: function(value) {
        return value ? this.L('Project finish date') : this.L('Project start date');
    },
    onFieldChange: function(field, value) {
        if (this.instantUpdate && !this.getSuppressTaskUpdate() && this.task) {
            if (this.task.getScheduleBackwards() != Boolean(this.value)) {
                // apply changes to task
                this.applyChanges();
            }
        }
    },
    getValue: function() {
        return this.value;
    }
});

/**
@class Gnt.model.TaskSegment
@extends Gnt.model.Task

This class represents a segment of a split task in your Gantt chart.

*/
Ext.define('Gnt.model.TaskSegment', {
    extend: 'Gnt.model.Task',
    isTaskSegment: true,
    /**
     * @cfg {Gnt.model.Task} task The task part of which this segment is.
     * @required
     */
    task: null,
    customizableFields: [
        {
            name: 'StartOffset',
            type: 'int',
            defaultValue: null
        },
        {
            name: 'EndOffset',
            type: 'int',
            defaultValue: null
        }
    ],
    startOffsetField: 'StartOffset',
    endOffsetField: 'EndOffset',
    taskNotifyingSuspended: 0,
    constructor: function(cfg) {
        cfg = cfg || {};
        cfg.leaf = true;
        if (!cfg.task)  {
            throw "'task' has to be specified";
        }
        
        this.task = cfg.task;
        this.callParent(arguments);
        Ext.override(this, this.overridables);
        if (this.getTask().normalized && this.getTaskStore(true) && !this.normalized) {
            this.normalize();
        }
    },
    overridables: {
        // we have to treat set() method override this way since we use explicit Ext.override() call
        // to override it in Gnt.model.mixin.ProjectableModel, and thus we can override it using the same approach only
        set: function() {
            var task = this.getTask();
            if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
                // let master task know of editing being started
                task.onSegmentEditBegin(this);
            }
            this.callParent(arguments);
            if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
                // let master task know of editing being ended
                task.onSegmentEditEnd(this);
            }
        }
    },
    getFieldsToSerialize: function() {
        var me = this;
        return [
            me.idProperty,
            me.phantomIdField,
            me.startDateField,
            me.endDateField,
            me.durationField,
            me.durationUnitField,
            me.clsField
        ];
    },
    serialize: function() {
        var me = this,
            fieldsToKeep = me.getFieldsToSerialize(),
            data = me.getData({
                serialize: true
            }),
            fieldName;
        // Need to get rid of unnecessary fields
        for (fieldName in data) {
            if (!Ext.Array.contains(fieldsToKeep, fieldName)) {
                delete data[fieldName];
            }
        }
        // To make sure idProperty is there
        if (me.getId()) {
            data[me.idProperty] = me.getId();
        }
        return data;
    },
    setStartOffset: function(startOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(this.getEndOffset() - startOffset, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, startOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    setEndOffset: function(endOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(endOffset - this.getStartOffset(), this.getDurationUnit());
        this.beginEdit();
        this.set(this.endOffsetField, endOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    setStartEndOffset: function(startOffset, endOffset) {
        var cal = this.getTask().getProjectCalendar();
        var durationInTaskUnit = cal.convertMSDurationToUnit(endOffset - startOffset, this.getDurationUnit());
        this.beginEdit();
        this.set(this.startOffsetField, startOffset);
        this.set(this.endOffsetField, endOffset);
        this.set(this.durationField, durationInTaskUnit);
        this.endEdit();
    },
    normalize: function() {
        // fill missing standard task fields: end date based on duration or duration based on end date etc.
        this.callParent(arguments);
        var startDate = this.getStartDate();
        // fill offsets if needed
        if (!Ext.isNumber(this.getStartOffset()) && startDate) {
            var task = this.getTask();
            var startOffset = this.calculateDuration(task.getStartDate(), startDate, 'MILLI');
            var endOffset = startOffset + this.getDuration('MILLI');
            var cal = task.getProjectCalendar();
            var durationInTaskUnits = cal.convertMSDurationToUnit(endOffset - startOffset, this.getDurationUnit());
            this.data[this.startOffsetField] = startOffset;
            this.data[this.endOffsetField] = endOffset;
            this.data[this.durationField] = durationInTaskUnits;
        }
    },
    updateOffsetsByDates: function() {
        // we need task store to use its project calendar
        if (!this.getTaskStore(true))  {
            return;
        }
        
        // prevents nested updating of offsets
        // and updating of offsets during start/end recalculation (based on offsets)
        if (this.updatingOffsets || this.updatingDates)  {
            return;
        }
        
        // set flag saying that we are in the middle of updating offsets by dates
        this.updatingOffsets = true;
        var offset = this.calculateDuration(this.getTask().getStartDate(), this.getStartDate(), 'MILLI');
        this.setStartEndOffset(offset, offset + this.getDuration('MILLI'));
        this.updatingOffsets = false;
    },
    updateDatesByOffsets: function(options) {
        options = options || {};
        // prevents nested updating of dates
        // and updating of dates during offsets updating
        if (this.updatingDates || this.updatingOffsets)  {
            return;
        }
        
        var isForward = options.isForward !== false,
            useAbsoluteOffset = options.useAbsoluteOffset !== false,
            startDate = options.startDate,
            endDate = options.endDate,
            taskStore = this.getTaskStore(true);
        if (!taskStore)  {
            return;
        }
        
        // set flag saying that we are in the middle of updating dates by offsets
        this.updatingDates = true;
        var date, neighbour;
        if (isForward) {
            neighbour = this.getPrevSegment();
            if (neighbour && !useAbsoluteOffset) {
                date = this.skipWorkingTime(neighbour.getEndDate(), this.getStartOffset() - neighbour.getEndOffset());
            } else {
                date = this.skipWorkingTime(startDate || this.getTask().getStartDate(), this.getStartOffset());
            }
        } else {
            neighbour = this.getNextSegment();
            if (neighbour && !useAbsoluteOffset) {
                date = this.skipWorkingTime(neighbour.getStartDate(), neighbour.getStartOffset() - this.getEndOffset() + this.getDuration('MILLI'), false);
            } else {
                date = this.skipWorkingTime(endDate || this.getTask().getEndDate(), this.getDuration('MILLI'), false);
            }
        }
        this.setStartDateWithoutPropagation(date, true, taskStore.skipWeekendsDuringDragDrop);
        this.updatingDates = false;
    },
    getPrevSegment: function() {
        var segments = this.task.getSegments();
        return segments[Ext.Array.indexOf(segments, this) - 1];
    },
    getNextSegment: function() {
        var segments = this.task.getSegments();
        return segments[Ext.Array.indexOf(segments, this) + 1];
    },
    buildSnapshot: function() {
        return [
            this,
            Ext.apply({}, this.data)
        ];
    },
    readSnapshot: function(snapshot) {
        var result = snapshot;
        if (snapshot) {
            Ext.apply(this.data, snapshot[1]);
            result = this;
        }
        return result;
    },
    suspendTaskNotifying: function() {
        this.taskNotifyingSuspended++;
    },
    resumeTaskNotifying: function() {
        this.taskNotifyingSuspended--;
    },
    skipWorkingTime: function(date, duration, isForward, segments) {
        return this.callParent([
            date,
            duration,
            isForward,
            false
        ]);
    },
    skipNonWorkingTime: function(date, isForward, segments) {
        return this.callParent([
            date,
            isForward,
            false
        ]);
    },
    setStartDateWithoutPropagation: function(date, keepDuration, skipNonWorkingTime) {
        this.beginEdit();
        this.callParent(arguments);
        keepDuration = keepDuration !== false;
        this.updateOffsetsByDates();
        // if we have next segment(s) and we have to respect and not overlap them
        if (keepDuration) {
            if (!this.inShifting && this.getNextSegment()) {
                // this.shiftNeighboursWithoutPropagation();
                var neighbour = this.getNextSegment();
                var shift = this.getEndOffset() - neighbour.getStartOffset();
                if (neighbour && shift > 0) {
                    neighbour.suspendTaskNotifying();
                    neighbour.shiftWithoutPropagation(shift, true);
                    neighbour.resumeTaskNotifying();
                }
            }
        }
        // if the segment has zero duration let's remove it
        else if (!this.getDuration()) {
            var task = this.getTask();
            task.suspendSegmentsTracking();
            task.removeSegments(this);
            task.resumeSegmentsTracking();
        }
        this.endEdit();
        return true;
    },
    /**
     * @private
     * Shifts the segment by provided number of milliseconds.
     * @param {Number} amountMS Number of milliseconds the segment shoud be mover by.
     * @param {Boolean} [respectNeighbours=false] Pass `true` to shift further segments as well.
     */
    shiftWithoutPropagation: function(amountMS, respectNeighbours) {
        var me = this,
            neighbour;
        if (amountMS) {
            me.beginEdit();
            me.inShifting = true;
            me.setStartEndOffset(me.getStartOffset() + amountMS, me.getEndOffset() + amountMS);
            me.updateDatesByOffsets();
            if (respectNeighbours) {
                neighbour = amountMS > 0 ? me.getNextSegment() : me.getPrevSegment();
                if (neighbour) {
                    neighbour.suspendTaskNotifying();
                    neighbour.shiftWithoutPropagation(amountMS, true);
                    neighbour.resumeTaskNotifying();
                }
            }
            me.inShifting = false;
            me.endEdit();
        }
        return true;
    },
    setEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        // if the segment has zero duration let's remove it
        if (!this.getDuration()) {
            var task = this.getTask();
            task.suspendSegmentsTracking();
            task.removeSegments(this);
            task.resumeSegmentsTracking();
        }
        this.updateOffsetsByDates();
        this.endEdit();
        return true;
    },
    setStartEndDateWithoutPropagation: function() {
        this.beginEdit();
        this.callParent(arguments);
        // if the segment has zero duration let's remove it
        if (!this.getDuration()) {
            var task = this.getTask();
            task.suspendSegmentsTracking();
            task.removeSegments(this);
            task.resumeSegmentsTracking();
        }
        this.updateOffsetsByDates();
        this.endEdit();
        return true;
    },
    setDurationWithoutPropagation: function(number, unit) {
        var me = this,
            newStartDate, newEndDate;
        // {{{ Parameters normalization
        unit = unit || me.getDurationUnit();
        // }}}
        me.beginEdit();
        var taskStore = me.getTaskStore(true),
            scheduleBackwards = me.getProjectScheduleBackwards(taskStore);
        if (Ext.isNumber(number)) {
            if (scheduleBackwards) {
                newStartDate = me.getEndDate() && me.calculateStartDate(me.getEndDate(), number, unit);
            } else {
                newEndDate = me.getStartDate() && me.calculateEndDate(me.getStartDate(), number, unit);
            }
        }
        me.set(me.durationField, number);
        me.set(me.durationUnitField, unit);
        if (newEndDate) {
            me.set(me.endDateField, newEndDate);
        }
        if (newStartDate) {
            me.set(me.startDateField, newStartDate);
        }
        // if the segment has zero duration let's remove it
        if (!me.getDuration()) {
            var task = me.getTask();
            task.suspendSegmentsTracking();
            task.removeSegments(me);
            task.resumeSegmentsTracking();
        }
        me.updateOffsetsByDates();
        me.endEdit();
        return true;
    },
    /**
     * Gets the task to which the segment belongs.
     * @return {Gnt.model.Task} The task.
     */
    getTask: function() {
        return this.task;
    },
    beginEdit: function() {
        var task = this.getTask();
        if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
            // let master task know of editing being started
            task.onSegmentEditBegin(this);
        }
        this.callParent(arguments);
    },
    endEdit: function() {
        var modified = this.previous,
            task = this.getTask();
        this.callParent(arguments);
        if (task && !this.__editCounter && !this.taskNotifyingSuspended) {
            // if the timespan was affected by the change we let the master task know of it
            if (this.startDateField in modified || this.endDateField in modified || this.startOffsetField in modified || this.endOffsetField in modified || this.durationField in modified) {
                task.onSegmentsChanged(this, modified);
            }
            task.onSegmentEditEnd(this);
        }
    },
    // sub-segments are not supported
    // @ignore
    setSegments: Ext.emptyFn,
    // @ignore
    setSegmentsWithoutPropagation: Ext.emptyFn,
    // @ignore
    getSegments: Ext.emptyFn,
    callTask: function(args) {
        var task = this.task;
        var method = this.callTask.caller;
        var taskMethod = method && task[method.$name];
        if (taskMethod)  {
            return taskMethod.apply(task, args);
        }
        
    },
    // @ignore
    getSchedulingMode: function() {
        // #1902 here we redirected this call to the task previously (using: this.callTask(arguments);)
        // yet it brings few questions when it comes to "EfforDriven" mode
        // where end date is calculated based on effort value ..and segment just doesn't have it normally
        return 'Normal';
    },
    // methods mapped from the task
    getCalendar: function() {
        return this.callTask(arguments);
    },
    getOwnCalendar: function() {
        return this.callTask(arguments);
    },
    getProjectCalendar: function() {
        return this.callTask(arguments);
    },
    getDependencyStore: function() {
        return this.callTask(arguments);
    },
    getResourceStore: function() {
        return this.callTask(arguments);
    },
    getAssignmentStore: function() {
        return this.callTask(arguments);
    },
    getTaskStore: function() {
        return this.callTask(arguments);
    },
    forEachAvailabilityInterval: function(options) {
        // we query the task for available intervals
        // but force it to NOT take segmentation into account
        options.segments = options.segments || false;
        return this.callTask(arguments);
    },
    propagateChanges: function() /*...*/
    {
        return this.callTask(arguments);
    },
    rejectSegmentsProjection: function() {
        return this.callTask(arguments);
    },
    commitSegmentsProjection: function() {
        return this.callTask(arguments);
    },
    getAssignments: function() {
        return this.callTask(arguments);
    },
    getAssignmentFor: function() {
        return this.callTask(arguments);
    },
    isAssignedTo: function() {
        return this.callTask(arguments);
    },
    isDraggable: function() {
        return this.callTask(arguments);
    },
    getResources: function() {
        return this.callTask(arguments);
    },
    isReadOnly: function() {
        return this.task.isReadOnly();
    },
    // @ignore
    autoCalculateCost: false,
    // @ignore
    recalculateCost: Ext.emptyFn,
    copy: function(newId, session, /*private*/
    newData) {
        var me = this,
            // we need to provide custom properties to the copy
            data = Ext.apply({}, newData, me.data),
            idProperty = me.idProperty,
            T = me.self;
        if (newId || newId === 0) {
            data[idProperty] = newId;
        } else if (newId === null) {
            delete data[idProperty];
        }
        return new T(data, session);
    }
});
/**
     * @hide
     * @field Name
     */
/**
     * @hide
     * @field Note
     */
/**
     * @hide
     * @field ActualEffort
     */
/**
     * @hide
     * @field ActualCost
     */
/**
     * @hide
     * @field BaselineEffort
     */
/**
     * @hide
     * @field BaselineCost
     */
/**
     * @hide
     * @field BaselineEndDate
     */
/**
     * @hide
     * @field BaselinePercentDone
     */
/**
     * @hide
     * @field BaselineStartDate
     */
/**
     * @hide
     * @field CalendarId
     */
/**
     * @hide
     * @field ConstraintDate
     */
/**
     * @hide
     * @field ConstraintType
     */
/**
     * @hide
     * @field Cost
     */
/**
     * @hide
     * @field CostVariance
     */
/**
     * @hide
     * @field DeadlineDate
     */
/**
     * @hide
     * @field Effort
     */
/**
     * @hide
     * @field EffortUnit
     */
/**
     * @hide
     * @field EffortVariance
     */
/**
     * @hide
     * @field ManuallyScheduled
     */
/**
     * @hide
     * @field PercentDone
     */
/**
     * @hide
     * @field ReadOnly
     */
/**
     * @hide
     * @field Rollup
     */
/**
     * @hide
     * @field SchedulingMode
     */
/**
     * @hide
     * @field ShowInTimeline
     */
/**
     * @hide
     * @method setName
     */
/**
     * @hide
     * @method getCost
     */
/**
     * @hide
     * @method getDeadlineDate
     */
/**
     * @hide
     * @method getName
     */
/**
     * @hide
     * @cfg autoCalculateEffortForParentTask
     */
/**
     * @hide
     * @cfg autoCalculatePercentDoneForParentTask
     */
/**
     * @hide
     * @cfg baselineEndDateField
     */
/**
     * @hide
     * @cfg baselinePercentDoneField
     */
/**
     * @hide
     * @cfg baselineStartDateField
     */
/**
     * @hide
     * @cfg calendar
     */
/**
     * @hide
     * @cfg calendarIdField
     */
/**
     * @hide
     * @cfg constraintDateField
     */
/**
     * @hide
     * @cfg constraintTypeField
     */
/**
     * @hide
     * @cfg convertEmptyParentToLeaf
     */
/**
     * @hide
     * @cfg draggableField
     */
/**
     * @hide
     * @cfg effortField
     */
/**
     * @hide
     * @cfg effortUnitField
     */
/**
     * @hide
     * @cfg manuallyScheduledField
     */
/**
     * @hide
     * @cfg percentDoneField
     */
/**
     * @hide
     * @cfg phantomParentIdField
     */
/**
     * @hide
     * @cfg resizableField
     */
/**
     * @hide
     * @cfg rollupField
     */
/**
     * @hide
     * @cfg schedulingModeField
     */
/**
     * @hide
     * @cfg taskStore
     */
/**
     * @hide
     * @cfg dependencyStore
     */
/**
     * @hide
     * @property assignments
     */
/**
     * @hide
     * @property predecessors
     */
/**
     * @hide
     * @property successors
     */
/**
     * @hide
     * @method addMilestone
     */
/**
     * @hide
     * @method addPredecessor
     */
/**
     * @hide
     * @method addSubtask
     */
/**
     * @hide
     * @method addSuccessor
     */
/**
     * @hide
     * @method addTaskAbove
     */
/**
     * @hide
     * @method addTaskBelow
     */
/**
     * @hide
     * @method assign
     */
/**
     * @hide
     * @method cascadeChanges
     */
/**
     * @hide
     * @method cascadeChildren
     */
/**
     * @hide
     * @method convertToMilestone
     */
/**
     * @hide
     * @method convertToRegular
     */
/**
     * @hide
     * @method forEachDate
     */
/**
     * @hide
     * @method getAllDependencies
     */
/**
     * @hide
     * @method getAssignmentFor
     */
/**
     * @hide
     * @method getAssignmentStore
     */
/**
     * @hide
     * @method getAssignments
     */
/**
     * @hide
     * @method getBaselineEndDate
     */
/**
     * @hide
     * @method getBaselinePercentDone
     */
/**
     * @hide
     * @method getBaselineStartDate
     */
/**
     * @hide
     * @method setBaselineEndDate
     */
/**
     * @hide
     * @method setBaselinePercentDone
     */
/**
     * @hide
     * @method setBaselineStartDate
     */
/**
     * @hide
     * @method getCalendar
     */
/**
     * @hide
     * @method getCalendarDuration
     */
/**
     * @hide
     * @method getConstraintClass
     */
/**
     * @hide
     * @method getDates
     */
/**
     * @hide
     * @method getDependencyStore
     */
/**
     * @hide
     * @method getDisplayEndDate
     */
/**
     * @hide
     * @method getDisplayStartDate
     */
/**
     * @hide
     * @method getEarlyEndDate
     */
/**
     * @hide
     * @method getEarlyStartDate
     */
/**
     * @hide
     * @method getEffort
     */
/**
     * @hide
     * @method getEffortUnit
     */
/**
     * @hide
     * @method getIncomingDependencies
     */
/**
     * @hide
     * @method getLateEndDate
     */
/**
     * @hide
     * @method getLateStartDate
     */
/**
     * @hide
     * @method getOutgoingDependencies
     */
/**
     * @hide
     * @method getOwnCalendar
     */
/**
     * @hide
     * @method getPercentDone
     */
/**
     * @hide
     * @method getPredecessors
     */
/**
     * @hide
     * @method getResourceStore
     */
/**
     * @hide
     * @method getResources
     */
/**
     * @hide
     * @method getSchedulingMode
     */
/**
     * @hide
     * @method getSegment
     */
/**
     * @hide
     * @method getSequenceNumber
     */
/**
     * @hide
     * @method getSuccessors
     */
/**
     * @hide
     * @method getTaskStore
     */
/**
     * @hide
     * @method getTotalCount
     */
/**
     * @hide
     * @method getWBSCode
     */
/**
     * @hide
     * @method hasAssignments
     */
/**
     * @hide
     * @method hasConstraint
     */
/**
     * @hide
     * @method hasIncomingDependencies
     */
/**
     * @hide
     * @method hasOutgoingDependencies
     */
/**
     * @hide
     * @method hasResources
     */
/**
     * @hide
     * @method indent
     */
/**
     * @hide
     * @method insertSubtask
     */
/**
     * @hide
     * @method isAssignedTo
     */
/**
     * @hide
     * @method isBaselineMilestone
     */
/**
     * @hide
     * @method isConstraintSatisfied
     */
/**
     * @hide
     * @method isManuallyScheduled
     */
/**
     * @hide
     * @method isMilestone
     */
/**
     * @hide
     * @method isPersistable
     */
/**
     * @hide
     * @method isProjected
     */
/**
     * @hide
     * @method isSegmented
     */
/**
     * @hide
     * @method linkTo
     */
/**
     * @hide
     * @method merge
     */
/**
     * @hide
     * @method outdent
     */
/**
     * @hide
     * @method setBaselinePercentDone
     */
/**
     * @hide
     * @method setCalendar
     */
/**
     * @hide
     * @method setConstraint
     */
/**
     * @hide
     * @method setConstraintDate
     */
/**
     * @hide
     * @method setConstraintType
     */
/**
     * @hide
     * @method setEffort
     */
/**
     * @hide
     * @method setEffortUnit
     */
/**
     * @hide
     * @method setPercentDone
     */
/**
     * @hide
     * @method setSchedulingMode
     */
/**
     * @hide
     * @method setSegments
     */
/**
     * @hide
     * @method setTaskStore
     */
/**
     * @hide
     * @method shift
     */
/**
     * @hide
     * @method split
     */
/**
     * @hide
     * @method unAssign
     */
/**
     * @hide
     * @method unlinkFrom
     */
/**
     * @hide
     * @method isResizable
     */
/**
     * @hide
     * @method isScheduled
     */
/**
     * @hide
     * @method isStarted
     */
/**
     * @hide
     * @method propagateChanges
     */
/**
     * @hide
     * @method reassign
     */
/**
     * @hide
     * @method removeSubtask
     */
/**
     * @hide
     * @method setActualEffort
     */
/**
     * @hide
     * @method setBaselineCost
     */
/**
     * @hide
     * @method setBaselineEffort
     */
/**
     * @hide
     * @method setCost
     */
/**
     * @hide
     * @method setDeadlineDate
     */
/**
     * @hide
     * @method setDraggable
     */
/**
     * @hide
     * @method setEffortWithoutPropagation
     */
/**
     * @hide
     * @method setManuallyScheduled
     */
/**
     * @hide
     * @method setManuallyScheduledWithoutPropagation
     */
/**
     * @hide
     * @method setPercentDoneWithoutPropagation
     */
/**
     * @hide
     * @method setResizable
     */
/**
     * @hide
     * @method setRollup
     */
/**
     * @hide
     * @method getRollup
     */
/**
     * @hide
     * @method setSchedulingModeWithoutPropagation
     */
/**
     * @hide
     * @method setSegmentsWithoutPropagation
     */
/**
     * @hide
     * @method unassign
     */
/**
     * @hide
     * @method adjustToCalendar
     */
/**
     * @hide
     * @method convertToMilestoneWithoutPropagation
     */
/**
     * @hide
     * @method convertToRegularWithoutPropagation
     */
/**
     * @hide
     * @method getActualCost
     */
/**
     * @hide
     * @method getActualEffort
     */
/**
     * @hide
     * @method getBaselineEffort
     */
/**
     * @hide
     * @method getConstraintDate
     */
/**
     * @hide
     * @method getConstraintType
     */
/**
     * @hide
     * @method getEndSlack
     */
/**
     * @hide
     * @method getFreeSlack
     */
/**
     * @hide
     * @method getPreviousSiblingsTotalCount
     */
/**
     * @hide
     * @method getProject
     */
/**
     * @hide
     * @method getProjectCalendar
     */
/**
     * @hide
     * @method getSegmentByDate
     */
/**
     * @hide
     * @method getSegments
     */
/**
     * @hide
     * @method getStartSlack
     */
/**
     * @hide
     * @method getTotalSlack
     */
/**
     * @hide
     * @method hasDependencies
     */
/**
     * @hide
     * @method isCompleted
     */
/**
     * @hide
     * @method isCritical
     */
/**
     * @hide
     * @method isDraggable
     */
/**
     * @hide
     * @method isEditable
     */
/**
     * @hide
     * @method isInProgress
     */
/**
     * @hide
     * @method isReadOnly
     */
/**
     * @hide
     * @cfg actualCostField
     */
/**
     * @hide
     * @cfg actualEffortField
     */
/**
     * @hide
     * @cfg autoCalculateCost
     */
/**
     * @hide
     * @cfg autoCalculateCostForParentTask
     */
/**
     * @hide
     * @cfg baselineCostField
     */
/**
     * @hide
     * @cfg baselineEffortField
     */
/**
     * @hide
     * @cfg clsField
     */
/**
     * @hide
     * @cfg costField
     */
/**
     * @hide
     * @cfg costVarianceField
     */
/**
     * @hide
     * @cfg deadlineDateField
     */
/**
     * @hide
     * @cfg effortVarianceField
     */
/**
     * @hide
     * @cfg nameField
     */
/**
     * @hide
     * @cfg noteField
     */
/**
     * @hide
     * @cfg segmentsField
     */
/**
     * @hide
     * @cfg showInTimelineField
     */

Ext.define('Gnt.model.Week', {
    extend: 'Ext.data.Model',
    idProperty: 'Id',
    fields: [
        {
            name: 'Id'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'startDate',
            type: 'date'
        },
        {
            name: 'endDate',
            type: 'date'
        },
        {
            name: 'mainDay'
        },
        // type : Gnt.model.CalendarDay
        {
            name: 'weekAvailability'
        }
    ],
    set: function(field, value) {
        if (field === 'name') {
            // rename every CalendarDay instance embedded
            Ext.Array.each(this.get('weekAvailability').concat(this.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    weekDay.setName(value);
                }
            });
        }
        this.callParent(arguments);
    }
});

Ext.define('Gnt.view.dependency.Painter', {
    extend: 'Sch.view.dependency.Painter',
    alias: 'schdependencypainter.ganttdefault',
    /**
     * Get index to cache for specified task
     * @private
     */
    getIndexForCache: function(primaryView, task) {
        return primaryView.getTaskStore().indexOf(task);
    },
    createLineDef: function(primaryView, dependency, source, target, sourceBox, targetBox, otherBoxes) {
        var DEP_TYPE = dependency.self.Type,
            me = this,
            horizontalMargin = me.pathFinder.getHorizontalMargin(),
            ganttRowHeight = primaryView.getRowHeight(),
            result = me.callParent([
                primaryView,
                dependency,
                source,
                target,
                sourceBox,
                targetBox,
                otherBoxes
            ]);
        // Reversing start/end endpoints generate more Gantt-friendly arrows
        var endBox = result.endBox;
        var endSide = result.endSide;
        result.startArrowSize = result.endArrowSize;
        result.startArrowMargin = result.endArrowMargin;
        result.endArrowSize = 0;
        result.endArrowMargin = 0;
        result.endBox = result.startBox;
        result.endSide = result.startSide;
        result.startBox = endBox;
        result.startSide = endSide;
        result.boxesReversed = true;
        result.startVerticalMargin = Math.floor((ganttRowHeight - (result.startBox.bottom - result.startBox.top)) / 2) + 1;
        result.endVerticalMargin = Math.floor((ganttRowHeight - (result.endBox.bottom - result.endBox.top)) / 2) - 1;
        if (// This dependency type
        dependency.getType() == DEP_TYPE.EndToStart && // Target box is below source box
        result.endBox.bottom < result.startBox.top && (// Horizontal gap between source box end and target box start is less then 5px
        result.endBox.end - result.startBox.start < horizontalMargin)) {
            result.startShift = target.isMilestone() ? 0 : (horizontalMargin - (targetBox.end - targetBox.start) / 2);
            result.startVerticalMargin = result.startHorizontalMargin = result.startArrowMargin = result.endArrowMargin = 0;
            result.startSide = 'top';
        }
        return result;
    }
});

/**
 * The class implements the gantt specific dependency view.
 */
Ext.define('Gnt.view.dependency.View', {
    extend: 'Sch.view.dependency.View',
    alias: 'schdependencyview.basegantt',
    requires: [
        'Gnt.view.dependency.Painter'
    ],
    config: {
        painterConfig: {
            type: 'ganttdefault'
        }
    },
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (me.painter.getUseDependencyRowIntersectionCache()) {
            if (me.getPrimaryView().taskStore) {
                me.getPrimaryView().mon(me.getPrimaryView().taskStore, {
                    rootchange: me.resetPainterCache,
                    add: me.resetPainterCache,
                    remove: me.resetPainterCache,
                    // Since we have an override for collapseAll/expandAll which mutes Store events (see Gnt.panel.Gantt),
                    // we need to clear cache additionally on nodecollapse/nodeexpand
                    nodecollapse: me.resetPainterCache,
                    nodeexpand: me.resetPainterCache,
                    //load        : me.resetPainterCache, // TODO: check if refresh fired with load
                    clear: me.resetPainterCache,
                    refresh: me.resetPainterCache,
                    scope: me
                });
            }
        }
        if (me.getEnableDependencyDragDrop()) {
            me.configureAllowedSourceTerminals();
            if (me.getDependencyStore().allowedDependencyTypes) {
                // Define the allowed targets at drag start time
                me.dragZone.on('dragstart', me.configureAllowedTargetTerminals, me);
            } else {
                // Allow all types
                me.getPrimaryView().el.addCls([
                    'sch-terminal-allow-target-start',
                    'sch-terminal-allow-target-end'
                ]);
            }
            me.dragZone.on('drop', me.hideTargetTerminals, me);
        }
    },
    // Add classes to hide unallowed terminals
    // TODO: Replace with terminalSides as in scheduler? to not draw unallowed at all?
    configureAllowedSourceTerminals: function() {
        var allowed = this.getDependencyStore().allowedDependencyTypes,
            classes = [
                'sch-terminal-allow-source-start',
                'sch-terminal-allow-source-end'
            ];
        if (allowed) {
            classes = [];
            if (Ext.Array.contains(allowed, 'EndToEnd') || Ext.Array.contains(allowed, 'EndToStart')) {
                classes.push('sch-terminal-allow-source-end');
            }
            if (Ext.Array.contains(allowed, 'StartToStart') || Ext.Array.contains(allowed, 'StartToEnd')) {
                classes.push('sch-terminal-allow-source-start');
            }
        }
        this.dragZone.view.el.addCls(classes);
    },
    configureAllowedTargetTerminals: function() {
        var allowed = this.getDependencyStore().allowedDependencyTypes,
            classes = [],
            el = this.dragZone.view.el;
        el.removeCls([
            'sch-terminal-allow-target-start',
            'sch-terminal-allow-target-end'
        ]);
        if (Ext.Array.contains(allowed, 'EndToEnd') || Ext.Array.contains(allowed, 'StartToEnd')) {
            classes.push('sch-terminal-allow-target-end');
        }
        if (Ext.Array.contains(allowed, 'StartToStart') || Ext.Array.contains(allowed, 'EndToStart')) {
            classes.push('sch-terminal-allow-target-start');
        }
        el.addCls(classes);
    },
    hideTargetTerminals: function() {
        this.getDependencyStore().allowedDependencyTypes && this.getPrimaryView().el.removeCls([
            'sch-terminal-allow-target-start',
            'sch-terminal-allow-target-end'
        ]);
    },
    // Since there's only one task per row in Gantt panel we need to update dependencies only for the updated task
    // instead of full redraw as for Scheduler
    onPrimaryViewItemUpdate: function(taskRecord, index, eventNode) {
        this.updateDependencies(taskRecord.getAllDependencies()).then(null, Ext.emptyFn);
    }
});

/**
 * This mixin is a helper for Gantt panel. It adds Dependency view instance management methods.
 */
Ext.define('Gnt.view.dependency.Mixin', {
    extend: 'Sch.view.dependency.Mixin',
    requires: [
        'Gnt.view.dependency.View'
    ],
    /**
     * @cfg {Boolean} enableDependencyDragDrop
     * True to allow creation of dependencies by using drag and drop between task terminals (defaults to true)
     */
    enableDependencyDragDrop: true,
    createDependencyView: function(config, primaryView) {
        return Sch.view.dependency.View.create(Ext.apply({}, config, {
            primaryView: primaryView,
            type: 'basegantt'
        }));
    }
});

// For RTL, cell editor misaligns when editing in the tree column
Ext.define('Gnt.patches.CellEditor', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellEditor',
    overrides: {
        realign: function(autoSize) {
            var me = this,
                boundEl = me.boundEl,
                innerCell = boundEl.dom.querySelector(me.context.view.innerSelector),
                innerCellTextNode = innerCell.firstChild,
                width = boundEl.getWidth(),
                grid = me.grid,
                xOffset,
                v = '',
                // innerCell is empty if there are no children, or there is one text node, and it contains whitespace
                isEmpty = !innerCellTextNode || (innerCellTextNode.nodeType === 3 && !(Ext.String.trim(v = innerCellTextNode.data).length));
            if (me.isForTree) {
                // When editing a tree, adjust the width and offsets of the editor to line
                // up with the tree cell's text element
                xOffset = me.getTreeNodeOffset(innerCell);
                width -= Math.abs(xOffset);
            }
            if (grid.columnLines) {
                // Subtract the column border width so that the editor displays inside the
                // borders. The column border could be either on the left or the right depending
                // on whether the grid is RTL - using the sum of both borders works in both modes.
                width -= boundEl.getBorderWidth('rl');
            }
            if (autoSize === true) {
                me.field.setWidth(width);
            }
            // https://sencha.jira.com/browse/EXTJSIV-10871 Ensure the data bearing element has a height from text.
            if (isEmpty) {
                innerCell.innerHTML = 'X';
            }
            me.alignTo(boundEl, me.alignment);
            // alignTo does not handle offsets WRT RTL, so
            // we offset the editor's X position here.
            if (xOffset) {
                me.setX(me.getX() + xOffset);
            }
            if (isEmpty) {
                innerCell.firstChild.data = v;
            }
        }
    }
});

// Patch for https://www.sencha.com/forum/showthread.php?469558
Ext.define('Gnt.patches.Rows', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.Rows',
    minVersion: '6.5.2',
    maxVersion: '6.5.3.57',
    overrides: {
        getCount: function() {
            var me = this,
                selectedRecords = me.selectedRecords,
                result = selectedRecords ? selectedRecords.getCount() : 0,
                range = me.getRange(),
                i,
                store = me.view.dataSource;
            // If dragging, add all records in the drag that are *not* in the collection
            for (i = range[0]; i <= range[1]; i++) {
                // Range may be outside of the store count if last record was selected and removed
                if (!selectedRecords || (i < store.getCount() && !selectedRecords.byInternalId.get(store.getAt(i) && store.getAt(i).internalId))) {
                    result++;
                }
            }
            return result;
        }
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/9477-shift+click-by-locked-grid-fails-with-an-exception/details#
Ext.define('Gnt.patches.Cells', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.Cells',
    applyFn: function() {
        delete Ext.grid.selection.Cells.prototype.setRangeStart.$privacy;
        Ext.grid.selection.Cells.override({
            setRangeStart: function(startCell, endCell) {
                if (startCell.record == null && startCell.column == null) {
                    startCell = this.view.selModel.getCellContext(0, 0);
                }
                return this.callParent(arguments);
            }
        });
    }
});

// https://www.sencha.com/forum/showthread.php?305782-TreeViewDragDrop-cannot-be-disabled
Ext.define('Gnt.patches.SpreadsheetModel', {
    extend: 'Sch.util.Patch',
    requires: [
        'Gnt.patches.Cells'
    ],
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                privates: {
                    // prevent selecting cells in normal view
                    onMouseMove: function(e, target, opts) {
                        var me = this,
                            view = opts.view,
                            schedulingView;
                        if (view.getSchedulingView) {
                            schedulingView = view.getSchedulingView();
                        } else if (view.ownerGrid.getSchedulingView) {
                            schedulingView = view.ownerGrid.getSchedulingView();
                        }
                        // if mouse is moving over scheduling view - do nothing
                        if (schedulingView && schedulingView._cmpCls && Ext.fly(target).up('.' + schedulingView._cmpCls)) {
                            return;
                        }
                        me.callParent(arguments);
                    },
                    // do not start drag selection on click in dragdrop column
                    handleMouseDown: function(view, cellNode, cellIndex, record) {
                        // prevent selection start on click in normal view
                        if (!(view instanceof Gnt.view.Gantt)) {
                            var isRowReorderCell = cellNode.className.indexOf('sch-gantt-column-dragdrop') >= 0;
                            if (isRowReorderCell) {
                                // dragdrop plugin need a selection to work on, also
                                this.selectRows([
                                    record
                                ], this.isSelected(record));
                            } else {
                                this.callParent(arguments);
                            }
                        }
                    }
                }
            };
        Ext.override(Ext.grid.selection.SpreadsheetModel, overrides);
    }
});

// Reported here https://www.sencha.com/forum/showthread.php?334034
Ext.define('Gnt.patches.SpreadsheetModel_2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.2.1',
    overrides: {
        privates: {
            onMouseUp: function(e, target, opts) {
                var me = this,
                    view = opts.view,
                    cell, record;
                me.checkCellClicked = null;
                if (view && !view.destroyed) {
                    // If we catch the event before the View sees it and stamps a position in, we need to know where they mouseupped.
                    if (!e.position) {
                        cell = e.getTarget(view.cellSelector);
                        if (cell) {
                            record = view.getRecord(cell);
                            if (record) {
                                e.position = new Ext.grid.CellContext(view).setPosition(record, view.getHeaderByCell(cell));
                            }
                        }
                    }
                    // Disable until a valid new selection is announced in fireSelectionChange unless it's a click
                    if (me.extensible && e.position && !e.position.isEqual(me.mousedownPosition)) {
                        me.extensible.disable();
                    }
                    view.el.un('mousemove', me.onMouseMove, me);
                    // Copy the records encompassed by the drag range into the record collection
                    if (me.selected.isRows) {
                        me.selected.addRange();
                    }
                    // Fire selection change only if we have dragged - if the mouseup position is different from the mousedown position.
                    // If there has been no drag, the click handler will select the single row
                    if (!e.position || !e.position.isEqual(me.mousedownPosition)) {
                        me.fireSelectionChange();
                    }
                }
            }
        }
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/4062-scrollbar-appears-in-locked-grid-when-adding-new-record/details
Ext.define('Gnt.patches.SpreadsheetModel_3', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.0.2',
    overrides: {
        privates: {
            // This method can be provided with first and last visible columns in grid when we select whole row/range.
            // Given that we moved selection extender to locked grid in ticket #3915, this method get selection
            // extender positioned far outside of locked view making view scrollable when it shouldn't. We constrain
            // range to locked grid columns here.
            // covered by 221_spreadsheet_1
            onSelectionFinish: function(sel, firstCell, lastCell) {
                var view = this.view;
                if (lastCell && view instanceof Gnt.view.Gantt) {
                    var lockedView = view.ownerGrid.lockedGrid.view,
                        header = lockedView.getHeaderCt(),
                        columns = header.getVisibleGridColumns();
                    if (Ext.Array.indexOf(columns, lastCell.column) === -1 && lastCell.record !== null) {
                        lastCell = new Ext.grid.CellContext(view).setPosition(lastCell.record, columns[columns.length - 1]);
                    }
                }
                this.callParent(arguments);
            }
        }
    }
});

//https://www.sencha.com/forum/showthread.php?337241
// Spread sheet model doesn't react correctly to store.remove() called manually
Ext.define('Gnt.patches.SpreadsheetModel_4', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.0.2',
    overrides: {
        privates: {
            onStoreRemove: function() {
                var sel = this.getSelected();
                // Updating on store mutation is only valid if we are selecting records.
                if (sel && !sel.isCells) {
                    this.callParent(arguments);
                }
            }
        },
        deselect: function(records, suppressEvent) {
            // API docs are inherited
            var me = this,
                sel = me.selected,
                store = me.view.dataSource,
                len, i, record,
                changed = false;
            if (sel && sel.isRows) {
                if (!Ext.isArray(records)) {
                    records = [
                        records
                    ];
                }
                len = records.length;
                for (i = 0; i < len; i++) {
                    record = records[i];
                    if (typeof record === 'number') {
                        record = store.getAt(record);
                    }
                    if (sel.remove(record)) {
                        changed = true;
                    }
                }
            }
            if (changed) {
                me.updateHeaderState();
                if (!suppressEvent) {
                    me.fireSelectionChange();
                }
            }
        }
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/5393-exception-in-spreadsheet-model-when-column-is-selected-and-hidden-from-header
// https://www.sencha.com/forum/showthread.php?469276
Ext.define('Gnt.patches.SpreadsheetModel_5', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.2.1',
    applyFn: function() {
        var overrides = {
                privates: {}
            };
        // this is intentional
        if (Ext.getVersion().isGreaterThan('6.5.0')) {
            overrides.privates.onViewChanged = function(view, isColumnChange) {
                var me = this,
                    selData = me.selected,
                    store = view.store,
                    selectionChanged = false,
                    rowRange, colCount, colIdx, rowIdx, context;
                if (selData) {
                    view = selData.view;
                    if (isColumnChange) {
                        if (selData.isCells) {
                            context = new Ext.grid.CellContext(view);
                            rowRange = selData.getRowRange();
                            colCount = view.ownerGrid.getColumnManager().getColumns().length;
                            if (colCount) {
                                for (rowIdx = rowRange[0]; rowIdx <= rowRange[1]; rowIdx++) {
                                    context.setRow(rowIdx);
                                    for (colIdx = 0; colIdx < colCount; colIdx++) {
                                        context.setColumn(colIdx);
                                        if (context.column) {
                                            view.onCellDeselect(context);
                                        }
                                        if (me.maybeClearSelection(context)) {
                                            selectionChanged = true;
                                        }
                                    }
                                }
                            } else {
                                me.clearSelections();
                                selectionChanged = true;
                            }
                        } else {
                            if (selData.isColumns) {
                                selectionChanged = false;
                                selData.eachColumn(function(column, columnIdx) {
                                    if (!column.isVisible() || !view.ownerGrid.isAncestor(column)) {
                                        // OVERRIDE
                                        this.remove(column);
                                        // END OVERRIDE
                                        if (me.maybeClearSelection({
                                            column: column
                                        })) {
                                            selectionChanged = true;
                                        }
                                    }
                                });
                            }
                        }
                    } else {
                        if (selData.isRows && store.isFiltered()) {
                            selData.eachRow(function(rec) {
                                if (!store.contains(rec)) {
                                    this.remove(rec);
                                    if (me.maybeClearSelection({
                                        rowIdx: view.indexOf(rec)
                                    })) {
                                        selectionChanged = true;
                                    }
                                }
                            });
                        }
                    }
                }
                return selectionChanged;
            };
        } else // because in 6.2 branch corresponding method is
        {
            overrides.privates.onColumnsChanged = function() {
                var me = this,
                    selData = me.selected,
                    rowRange, colCount, colIdx, rowIdx, view, context, selectionChanged;
                // When columns have changed, we have to deselect *every* cell in the row range because we do not know where the
                // columns have gone to.
                if (selData) {
                    view = selData.view;
                    if (selData.isCells) {
                        context = new Ext.grid.CellContext(view);
                        rowRange = selData.getRowRange();
                        colCount = view.getVisibleColumnManager().getColumns().length;
                        if (colCount) {
                            for (rowIdx = rowRange[0]; rowIdx <= rowRange[1]; rowIdx++) {
                                context.setRow(rowIdx);
                                for (colIdx = 0; colIdx < colCount; colIdx++) {
                                    context.setColumn(colIdx);
                                    view.onCellDeselect(context);
                                }
                            }
                        } else {
                            me.clearSelections();
                        }
                    }
                    // We have to deselect columns which have been hidden/removed
                    else if (selData.isColumns) {
                        selectionChanged = false;
                        selData.eachColumn(function(column, columnIdx) {
                            if (!column.isVisible() || !view.ownerGrid.isAncestor(column)) {
                                // OVERRIDE
                                this.remove(column);
                                // END OVERRIDE
                                selectionChanged = true;
                            }
                        });
                    }
                }
                // This event is fired directly from the HeaderContainer before the view updates.
                // So we have to wait until idle to update the selection UI.
                // NB: fireSelectionChange calls updateSelectionExtender after firing its event.
                Ext.on('idle', selectionChanged ? me.fireSelectionChange : me.updateSelectionExtender, me, {
                    single: true
                });
            };
        }
        Ext.override(Ext.grid.selection.SpreadsheetModel, overrides);
    }
});

// https://www.bryntum.com/forum/viewtopic.php?f=9&t=9075
// Allow a lockable GridPanel to fire an event when its Scroller has been set up
Ext.define('Gnt.patches.TablePanel', {
    extend: 'Sch.util.Patch',
    requires: [
        'Ext.grid.locking.Lockable'
    ],
    target: 'Ext.panel.Table',
    minVersion: '6.2.1',
    overrides: {
        initScrollContainer: function() {
            // callParent doesn't work for mixed in methods
            Ext.grid.locking.Lockable.prototype.initScrollContainer.call(this);
            ////////////////////////////
            //
            // The fix. A new event that signals that a locking grid has set up its
            // special Y scrolling element and put the two views inside it.
            // Used by the TreViewDragDrop plugin to acquire the correct element
            // to scroll on drag.
            this.fireEvent('scrollersinitialized', this);
        }
    }
});

//https://www.sencha.com/forum/showthread.php?337241
// Spread sheet model doesn't react correctly to store.remove() called manually
Ext.define('Gnt.patches.TreeView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tree.View',
    minVersion: '6.0.2',
    overrides: {
        onFocusLeave: function(e) {
            var me = this,
                isLeavingGrid;
            // If the blur was caused by a refresh, we expect things to be refocused.
            if (!me.destroying && !me.refreshing) {
                // See if focus is really leaving the grid.
                // If we have a locking partner, and focus is going to that, we're NOT leaving the grid.
                isLeavingGrid = !e.isScroll && (!me.lockingPartner || !e.toComponent || (e.toComponent !== me.lockingPartner && !me.lockingPartner.isAncestor(e.toComponent)));
                // Ignore this event if we do not actually contain focus.
                // CellEditors are rendered into the view's encapculating element,
                // So focusleave will fire when they are programatically blurred.
                // We will not have focus at that point.
                if (me.cellFocused) {
                    // Blur the focused cell unless we are navigating into a locking partner,
                    // in which case, the focus of that will setPosition to the target
                    // without an intervening position to null.
                    if (isLeavingGrid) {
                        me.getNavigationModel().setPosition(null, null, e.event, null, true);
                    }
                    me.cellFocused = false;
                    me.focusEl = me.el;
                    me.focusEl.dom.setAttribute('tabIndex', 0);
                }
                // Exiting to outside, switch back to navigation mode before clearing the navigation position
                // so that the current position's row can have its tabbability saved.
                if (isLeavingGrid) {
                    if (me.ownerGrid.actionableMode) {
                        // If focus is thrown back in with no specific target, it should go back into
                        // navigable mode at this position.
                        // See http://www.w3.org/TR/wai-aria-practices-1.1/#h-grid
                        // "Once focus has been moved inside the grid, subsequent tab presses that re-enter the grid shall return focus to the cell that last held focus."
                        me.lastFocused = me.actionPosition;
                        me.ownerGrid.setActionableMode(false);
                    }
                } else {
                    me.actionPosition = null;
                }
                // Skip the AbstractView's implementation.
                Ext.Component.prototype.onFocusLeave.call(me, e);
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?305782-TreeViewDragDrop-cannot-be-disabled
Ext.define('Gnt.patches.TreeViewDragDrop', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tree.plugin.TreeViewDragDrop',
    minVersion: '6.0.0',
    overrides: {
        init: function(view) {
            Ext.applyIf(view, {
                copy: this.copy,
                allowCopy: this.allowCopy
            });
            // Wait for the LockingView to fix up its scrolling insanity, because we need access to its
            // Y scroller if we are to be able to scroll in the Y axis while dragging.
            if (this.containerScroll && view.ownerGrid.lockable) {
                view.ownerGrid.on('scrollersinitialized', this.onLockingScrollersInitialized, this, {
                    single: true
                });
            } else {
                view.on('render', this.onViewRender, this, {
                    single: true
                });
            }
        },
        onLockingScrollersInitialized: function(lockingView) {
            // The base will register its client View's element to scroll, but
            // because we know wer are locking, we have to register the Y scrolling element.
            // Save reference to element in order to unregister correctly
            this.cmp._registeredScrollableElement = lockingView.getScrollable().getElement();
            Ext.dd.ScrollManager.register(this.cmp._registeredScrollableElement);
            this.onViewRender(this.cmp);
        },
        destroy: function() {
            this.cmp._registeredScrollableElement && Ext.dd.ScrollManager.unregister(this.cmp._registeredScrollableElement);
            delete this.cmp._registeredScrollableElement;
            this.callParent();
        },
        disable: function() {
            this.callParent(arguments);
            this.dragZone && this.dragZone.lock();
            this.dropZone && this.dropZone.lock();
        },
        enable: function() {
            this.callParent(arguments);
            this.dragZone && this.dragZone.unlock();
            this.dropZone && this.dropZone.unlock();
        }
    }
});

// https://www.sencha.com/forum/showthread.php?334465-Crash-when-removing-all-rows-with-spreadsheet-model&p=1169814#post1169814
Ext.define('Gnt.patches.SelectionExtender2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SelectionExtender',
    minVersion: '6.0.0',
    overrides: {
        setHandle: function(firstPos, lastPos) {
            if ((this.view.lockedView && this.view.lockedView.getNodes().length === 0) || (firstPos && lastPos && (!firstPos.record || !lastPos.record))) {
                this.disable();
                return;
            }
            return this.callParent(arguments);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?334465-Crash-when-removing-all-rows-with-spreadsheet-model&p=1169814#post1169814
Ext.define('Gnt.patches.SelectionExtender3', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SelectionExtender',
    minVersion: '6.7.0',
    overrides: {
        alignHandle: function() {
            var me = this,
                firstCell = me.firstPos && me.firstPos.getCell(true),
                lastCell = me.lastPos && me.lastPos.getCell(true),
                handle = me.handle,
                shouldDisplay;
            // Cell corresponding to the position might not be rendered.
            // This will be called upon scroll
            if (firstCell && lastCell) {
                me.enable();
                handle.alignTo(lastCell, 'c-br');
                shouldDisplay = me.isHandleWithinView(Ext.fly(lastCell).up('.' + Ext.baseCSSPrefix + 'grid-view, .' + Ext.baseCSSPrefix + 'tree-view'));
                handle.setVisible(shouldDisplay);
            } else {
                me.disable();
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?308916-Crash-when-hiding-columns-spreadsheet-model&p=1128276#post1128276
Ext.define('Gnt.patches.LockingView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.locking.View',
    minVersion: '6.0.0',
    overrides: {
        getCellByPosition: function(pos, returnDom) {
            if (pos && !pos.column)  {
                return null;
            }
            
            return this.callParent(arguments);
        },
        onCellDeselect: function(cellContext) {
            if (cellContext && !cellContext.column)  {
                return;
            }
            
            return this.callParent(arguments);
        },
        //reported bug
        //https://www.sencha.com/forum/showthread.php?347157-ExtJs-6-5-0-Locked-grid-fires-multiple-view-refresh-events-on-sort
        onDataRefresh: function() {
            Ext.suspendLayouts();
            this.relayFn('onDataRefresh', arguments);
            Ext.resumeLayouts(true);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?332570-locked-view-and-header-are-out-of-sync-after-collapsing-node
// covered by 115_collapse_expand
Ext.define('Gnt.patches.NavigationModel_6_2_0', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '6.2.0',
    maxVersion: '7.1.9',
    overrides: {
        // "preventNavigation" is removed by Sencha in 7.2.0
        // See Gnt.patches.NavigationModel_7_2_0 which is designed to replace this patch
        focusPosition: function(position, preventNavigation) {
            // Only apply logic to gantt view
            if (!(this.view instanceof Gnt.view.Gantt) || !preventNavigation) {
                this.callParent(arguments);
            }
        }
    }
});

// This override is required to fix "Should not loose scroll position on node collapse" in 115_collapse_expand.t
// and "View should keep scroll position after deleting task" in 091_task_context_menu.t
// In fact this override replaces old override NavigationModel_6_2_0, because Sencha cleaned up the code
// and stopped passing "preventNavigation" parameter into "focusPosition" function
Ext.define('Gnt.patches.NavigationModel_7_2_0', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '7.2.0',
    // We don't need to call "focusPosition" if "preventNavigation" is true
    // The original function is super long, so search for OVERRIDE region to find the override
    overrides: {
        setPosition: function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
            var me = this,
                clearing = recordIndex == null && columnIndex == null,
                isClear = me.record == null && me.recordIndex == null && me.item == null,
                view, scroller, selModel, dataSource, columnManager, newRecordIndex, newColumnIndex, newRecord, newColumn, columns;
            // Work out the view we are operating on.
            // If they passed a CellContext, use the view from that.
            // Otherwise, use the view injected into the event by Ext.view.View#processEvent.
            // Otherwise, use the last focused view.
            // Failing that, use the view we were bound to.
            if (recordIndex && recordIndex.isCellContext) {
                view = recordIndex.view;
            } else if (keyEvent && keyEvent.view) {
                view = keyEvent.view;
            } else if (me.lastFocused) {
                view = me.lastFocused.view;
            } else {
                view = me.view;
            }
            // In case any async focus was requested before this call.
            view.cancelFocusTask();
            // Return if the view was destroyed between the deferSetPosition call and now,
            // or if the call is a no-op or if there are no items which could be focused.
            if (view.destroyed || !view.refreshCounter || !view.ownerCt || clearing && isClear || !view.all.getCount()) {
                return;
            }
            selModel = view.getSelectionModel();
            dataSource = view.dataSource;
            columnManager = view.getVisibleColumnManager();
            columns = columnManager.getColumns();
            // If a CellContext is passed, use it.
            // Passing null happens on blur to remove focus class.
            if (recordIndex && recordIndex.isCellContext) {
                newRecord = recordIndex.record;
                newRecordIndex = recordIndex.rowIdx;
                newColumnIndex = Math.min(recordIndex.colIdx, columns.length - 1);
                newColumn = columns[newColumnIndex];
                // If the record being focused is not available (eg, after a removal),
                // then go to the same position
                if (dataSource.indexOf(newRecord) === -1) {
                    scroller = view.getScrollable();
                    // Change recordIndex so that the "No movement" test is bypassed
                    // if the record is not found
                    me.recordIndex = -1;
                    // If the view will not jump upwards to bring the next row under the mouse
                    // as expected because it's at the end, focus the previous row
                    // eslint-disable-next-line max-len
                    if (scroller && (scroller.getPosition().y >= scroller.getMaxPosition().y - view.all.last(true).offsetHeight)) {
                        recordIndex.rowIdx--;
                    }
                    newRecordIndex = Math.min(recordIndex.rowIdx, dataSource.getCount() - 1);
                    newRecord = dataSource.getAt(newRecordIndex);
                }
            } else {
                // Both axes are null, we defocus
                if (clearing) {
                    newRecord = newRecordIndex = null;
                } else {
                    // AbstractView's default behaviour on focus is to call setPosition(0);
                    // A call like this should default to the last column focused, or column 0;
                    if (columnIndex == null) {
                        columnIndex = me.lastFocused ? me.lastFocused.column : 0;
                    }
                    if (typeof recordIndex === 'number') {
                        newRecordIndex = Math.max(Math.min(recordIndex, dataSource.getCount() - 1), 0);
                        newRecord = dataSource.getAt(recordIndex);
                    }
                    // row is a Record
                    else if (recordIndex.isEntity) {
                        newRecord = recordIndex;
                        newRecordIndex = dataSource.indexOf(newRecord);
                    }
                    // row is a grid row
                    else if (recordIndex.tagName) {
                        newRecord = view.getRecord(recordIndex);
                        newRecordIndex = dataSource.indexOf(newRecord);
                        if (newRecordIndex === -1) {
                            newRecord = null;
                        }
                    } else {
                        if (isClear) {
                            return;
                        }
                        clearing = true;
                        newRecord = newRecordIndex = null;
                    }
                }
                // Record position was successful
                if (newRecord) {
                    // If the record being focused is not available (eg, after a sort), then go to 0,0
                    if (newRecordIndex === -1) {
                        // Change recordIndex so that the "No movement" test is bypassed
                        // if the record is not found
                        me.recordIndex = -1;
                        newRecord = dataSource.getAt(0);
                        newRecordIndex = 0;
                        columnIndex = null;
                    }
                    // No columnIndex passed, and no previous column position - default to column 0
                    if (columnIndex == null) {
                        if (!(newColumn = me.column)) {
                            newColumnIndex = 0;
                            newColumn = columns[0];
                        }
                    } else if (typeof columnIndex === 'number') {
                        newColumn = columns[columnIndex];
                        newColumnIndex = columnIndex;
                    } else {
                        newColumn = columnIndex;
                        newColumnIndex = columnManager.indexOf(columnIndex);
                    }
                } else {
                    clearing = true;
                    newColumn = newColumnIndex = null;
                }
            }
            // The column requested may have been hidden or removed (eg reconfigure)
            // Fall back to column index.
            if (newColumn && columnManager.indexOf(newColumn) === -1) {
                if (newColumnIndex === -1) {
                    newColumnIndex = 0;
                } else {
                    newColumnIndex = Math.min(newColumnIndex, columns.length - 1);
                }
                newColumn = columns[newColumnIndex];
            }
            // If we are in actionable mode and focusing a cell, exit actionable mode
            // at the requested position
            if (view.actionableMode && !clearing) {
                return view.ownerGrid.setActionableMode(false, new Ext.grid.CellContext(view).setPosition(newRecord, newColumn));
            }
            // No movement; just ensure the correct item is focused and return early.
            // Do not push current position into previous position, do not fire events.
            if (newRecordIndex === me.recordIndex && newColumnIndex === me.columnIndex && view === me.position.view) {
                return me.focusPosition(me.position);
            }
            if (me.cell) {
                me.cell.removeCls(me.focusCls);
            }
            // Track the last position.
            // Used by SelectionModels as the navigation "from" position.
            me.previousRecordIndex = me.recordIndex;
            me.previousRecord = me.record;
            me.previousItem = me.item;
            me.previousCell = me.cell;
            me.previousColumn = me.column;
            me.previousColumnIndex = me.columnIndex;
            me.previousPosition = me.position.clone();
            // Track the last selectionStart position to correctly track ranges
            // (i.e., SHIFT + selection).
            me.selectionStart = selModel.selectionStart;
            // Set our CellContext to the new position
            me.position.setAll(view, me.recordIndex = newRecordIndex, me.columnIndex = newColumnIndex, me.record = newRecord, me.column = newColumn);
            if (clearing) {
                me.item = me.cell = null;
            } else {
                // region OVERRIDE
                // Call "focusPosition" if view is not a gantt view or if view is a gantt view and navigation is not prevented
                if (!(this.view instanceof Gnt.view.Gantt) || !preventNavigation) {
                    me.focusPosition(me.position);
                }
            }
            // endregion
            // Legacy API is that the SelectionModel fires focuschange events
            // and the TableView fires rowfocus and cellfocus events.
            if (!suppressEvent) {
                selModel.fireEvent('focuschange', selModel, me.previousRecord, me.record);
                view.fireEvent('rowfocus', me.record, me.item, me.recordIndex);
                view.fireEvent('cellfocus', me.record, me.cell, me.position);
            }
            // If we have moved, fire an event
            if (keyEvent && !preventNavigation && me.cell !== me.previousCell) {
                me.fireNavigateEvent(keyEvent);
            }
        }
    }
});

/**
@class Gnt.template.Template
@extends Ext.XTemplate

Base class of all UI task templates. Subclass this class to implement your own UI template.
*/
Ext.define("Gnt.template.Template", {
    extend: 'Ext.XTemplate',
    disableFormats: true,
    getInnerTpl: Ext.emptyFn,
    innerTpl: null,
    dependencyTerminalMarkup: '<div class="sch-terminal sch-terminal-start"></div><div class="sch-terminal sch-terminal-end"></div>',
    terminalSides: null,
    terminalTpl: '<div class="sch-terminal sch-terminal-SIDE"></div>',
    constructor: function(cfg) {
        Ext.apply(this, cfg);
        var side = cfg.rtl ? 'right' : 'left';
        var inner = this.getInnerTpl(cfg) || '';
        this.callParent([
            '<div class="sch-event-wrap {ctcls} ' + Ext.baseCSSPrefix + 'unselectable" style="' + side + ':{offset}px">',
            '<tpl if="isRollup">',
            inner,
            (cfg.rollupLabel ? '<label class="sch-gantt-rollup-label">{rollupLabel}</label>' : ''),
            '<tpl else>',
            (cfg.leftLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-left"><label class="sch-gantt-label sch-gantt-label-left">{leftLabel}</label></div>' : ''),
            (cfg.rightLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-right" style="left:{width}px"><label class="sch-gantt-label sch-gantt-label-right">{rightLabel}</label></div>' : ''),
            (cfg.topLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-top"><label class="sch-gantt-label sch-gantt-label-top">{topLabel}</label></div>' : ''),
            inner,
            (cfg.bottomLabel ? '<div class="sch-gantt-labelct sch-gantt-labelct-bottom"><label class="sch-gantt-label sch-gantt-label-bottom">{bottomLabel}</label></div>' : ''),
            '</tpl>',
            '</div>'
        ]);
    }
});

/**
@class Gnt.template.Task
@extends Ext.XTemplate

Template class used to render a regular leaf task.
*/
Ext.define("Gnt.template.Task", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}" unselectable="on">&#160;</div>',
    getInnerTpl: function(cfg) {
        var side = cfg.rtl ? 'right' : 'left';
        return '<div id="' + cfg.prefix + '{id}" {attr} class="sch-gantt-item sch-gantt-task-bar {cls}" unselectable="on" style="width:{width}px;{style}">' + '<tpl if="isRollup">' + '<tpl else>' + '<tpl if="segments">' + '<div class="sch-gantt-segment-connector"></div>' + '</tpl>' + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'left') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-start"></div>' : '') + '<tpl for="segments">' + '<div id="' + cfg.prefix + '{parent.Id}-segment-{[xindex-1]}" class="sch-gantt-task-segment {cls}" style="' + side + ':{left}px;width:{width}px;{style}"' + ' data-segmentIndex="{[xindex-1]}">' + this.innerTpl + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : '') + '</div>' + '</tpl>' + this.innerTpl + ((cfg.taskResizeHandles === 'both' || cfg.taskResizeHandles === 'right') ? '<div class="sch-resizable-handle sch-gantt-task-handle sch-resizable-handle-end"></div>' : '') + (cfg.enableProgressBarResize ? '<div style="' + side + ':{progressBarWidth}px" class="sch-gantt-progressbar-handle"></div>' : '') + (// Left / Right terminals
        cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') + '</tpl>' + '</div>';
    }
});

/**
@class Gnt.template.ParentTask
@extends Ext.XTemplate

Class used to render a parent task.
*/
Ext.define("Gnt.template.ParentTask", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the task.
     */
    innerTpl: '<div class="sch-gantt-progress-bar" style="width:{progressBarWidth}px;{progressBarStyle}">&#160;</div>',
    getInnerTpl: function(cfg) {
        return '<div id="' + cfg.prefix + '{id}" {attr} class="sch-gantt-item sch-gantt-parenttask-bar {cls}" style="width:{width}px; {style}">' + this.innerTpl + (// Left / Right terminals
        (cfg.enableDependencyDragDrop && cfg.allowParentTaskDependencies) ? this.dependencyTerminalMarkup : '') + '</div>';
    }
});

/**
@class Gnt.template.Milestone
@extends Ext.XTemplate

Class used to render a milestone task.
*/
Ext.define("Gnt.template.Milestone", {
    extend: 'Gnt.template.Template',
    /**
     * @cfg {String} innerTpl The template defining the inner visual markup for the milestone task.
     */
    innerTpl: '<img unselectable="on" ' + 'style="<tpl if="print">height: {side}px; border-left-width: {side}px; </tpl>{style}" ' + 'src="' + Ext.BLANK_IMAGE_URL + '" ' + 'class="sch-gantt-milestone-diamond {cls}" />',
    getInnerTpl: function(cfg) {
        return '<div id="' + cfg.prefix + '{id}" {attr} class="sch-gantt-item sch-gantt-milestone-diamond-ct">' + this.innerTpl + '<tpl if="isRollup">' + '<tpl else>' + (// Dependency terminals
        cfg.enableDependencyDragDrop ? this.dependencyTerminalMarkup : '') + '</tpl>' + '</div>';
    }
});

Ext.define("Gnt.template.RollupTask", {
    extend: 'Ext.XTemplate',
    text: '<div class="sch-rollup-wrap">' + '<tpl for=".">' + '{[values.tpl.apply(values)]}' + '</tpl>' + '</div>',
    constructor: function(cfg) {
        this.callParent([
            this.text
        ]);
    }
});

/**
 @class Gnt.template.Deadline
 @extends Ext.XTemplate

 Template class rendering deadline markers.
 */
Ext.define("Gnt.template.Deadline", {
    extend: 'Ext.XTemplate',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    disableFormats: true,
    markup: '<div data-qtip="__DEADLINE__:  {date}" data-qalign="b-tl" class="gnt-deadline-indicator {cls}" style="{dir}:{offset}px"></div>',
    constructor: function() {
        this.markup = this.markup.replace(/__DEADLINE__/, this.L('deadline'));
        this.callParent([
            this.markup
        ]);
    }
});

Ext.define('Gnt.tooltip.EventTip', {
    extend: 'Sch.tooltip.EventTip',
    onTipBeforeShow: function(me) {
        if (!me.triggerElement || !me.triggerElement.id) {
            return false;
        }
        var view = me.getView();
        // All visible modal windows on the page.
        var modalVisibleWindows = Ext.all('window[modal=true]{isVisible()}');
        // First modal window that is not a scheduler and doesn't contain scheduler inside.
        var foundWindow = Ext.Array.findBy(modalVisibleWindows, function(modalWindow) {
                return view !== modalWindow && !view.isDescendantOf(modalWindow);
            });
        // Tooltip should not be shown above task editor or other modal windows
        if (foundWindow)  {
            return false;
        }
        
        var record = view.resolveEventRecord(me.triggerElement);
        if (!record || view.fireEvent('beforetooltipshow', view, record) === false) {
            return false;
        }
        var dataForMe = view.getDataForTooltipTpl(record, me.triggerElement, me.pointerEvent),
            tooltipString;
        if (!dataForMe)  {
            return false;
        }
        
        tooltipString = view.tooltipTpl.apply(dataForMe);
        if (!tooltipString)  {
            return false;
        }
        
        me.update(tooltipString);
    }
});

/**

@class Gnt.view.Gantt
@extends Sch.view.TimelineGridView

A view of the gantt panel. Use the {@link Gnt.panel.Gantt#getSchedulingView} method to get its instance from gantt panel.

*/
Ext.define("Gnt.view.Gantt", {
    extend: "Sch.view.TimelineGridView",
    alias: [
        'widget.ganttview'
    ],
    requires: [
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Sch.util.Date',
        'Sch.util.ScrollManager',
        'Gnt.patches.NavigationModel_6_2_0',
        'Gnt.patches.NavigationModel_7_2_0',
        'Gnt.model.Task',
        'Gnt.template.Task',
        'Gnt.template.ParentTask',
        'Gnt.template.Milestone',
        'Gnt.template.RollupTask',
        'Gnt.template.Deadline',
        'Gnt.tooltip.EventTip',
        'Gnt.feature.taskdd.DragZone',
        'Gnt.feature.ProgressBarResize',
        'Gnt.feature.TaskResize',
        'Sch.view.Horizontal',
        'Gnt.feature.LabelEditor',
        'Gnt.feature.DragCreator'
    ],
    mixins: [
        'Sch.mixin.GridViewCanvas',
        'Sch.mixin.FilterableTreeView'
    ],
    _cmpCls: 'sch-ganttview',
    scheduledEventName: 'task',
    trackOver: false,
    toggleOnDblClick: false,
    // private
    eventSelector: '.sch-gantt-item',
    eventWrapSelector: '.sch-event-wrap',
    barMargin: 4,
    progressBarResizer: null,
    taskResizer: null,
    taskDragDrop: null,
    dragCreator: null,
    resizeConfig: null,
    createConfig: null,
    dragDropConfig: null,
    progressBarResizeConfig: null,
    externalGetRowClass: null,
    baselineVisible: false,
    /**
     * @cfg {Number} outsideLabelsGatherWidth Defines width of special zone outside (before and after) of visible area within which tasks will be still rendered into DOM.
     * This is used to render partially visible labels of invisible tasks bordering with visible area.
     *
     * Increase this value to see long labels, set to 0 if you want to hide labels of invisible tasks completely.
     */
    outsideLabelsGatherWidth: 200,
    // Task click-events --------------------------
    /**
     * @event taskclick
     * Fires when a task is clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskdblclick
     * Fires when a task is double clicked
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskcontextmenu
     * Fires when contextmenu is activated on a task
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     * @param {Ext.EventObject} e The event object
     */
    // Resizing events start --------------------------
    /**
     * @event beforetaskresize
     * @preventable
     * Fires before a resize starts, return false to stop the execution
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event taskresizestart
     * Fires when resize starts
     *
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task about to be resized
     */
    /**
     * @event partialtaskresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The start date of the task
     * @param {Date} endDate The end date of the task
     * @param {Ext.Element} element The element being resized
     */
    /**
     * @event aftertaskresize
     * Fires after a succesful resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task that has been resized
     */
    // Task progress bar resizing events start --------------------------
    /**
     * @event beforeprogressbarresize
     * @preventable
     * Fires before a progress bar resize starts, return false to stop the execution
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */
    /**
     * @event progressbarresizestart
     * Fires when a progress bar resize starts
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
     */
    /**
     * @event afterprogressbarresize
     * Fires after a succesful progress bar resize operation
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord record The updated record
     */
    // Dnd events start --------------------------
    /**
     * @event beforetaskresizefinalize
     * @preventable
     * Fires before a succesful resize operation is finalized. Return false to finalize the resize at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} resizeContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event beforedragcreatefinalize
     * @preventable
     * Fires before a succesful create operation is finalized. Return false to finalize creating at a later time.
     * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
     * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
     * @param {Mixed} view The gantt view instance
     * @param {Object} createContext An object containing 'record', 'start', 'end', 'finalize' properties.
     * @param {Ext.EventObject} e The event object
     */
    // Label editors events --------------------------
    /**
     * @event labeledit_beforestartedit
     * Fires before editing is started for a field
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Gnt.model.Task} taskRecord The task record
     */
    /**
     * @event labeledit_beforecomplete
     * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */
    /**
     * @event labeledit_complete
     * Fires after editing is complete and any changed value has been written to the underlying field.
     * @param {Gnt.view.Gantt} gantt The gantt view instance
     * @param {Mixed} value The current field value
     * @param {Mixed} startValue The original field value
     * @param {Gnt.model.Task} taskRecord The affected record
     */
    // Drag create events start --------------------------
    /**
     * @event beforedragcreate
     * @preventable
     * Fires before a drag create operation starts, return false to prevent the operation
     * @param {Gnt.view.Gantt} gantt The gantt view
     * @param {Gnt.model.Task} task The task record being updated
     * @param {Date} date The date of the drag start point
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event dragcreatestart
     * Fires before a drag starts, return false to stop the operation
     * @param {Gnt.view.Gantt} view The gantt view
     */
    /**
     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     * @param {Gnt.model.Task} task The updated task record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Gnt.view.Gantt} view The gantt view
     */
    // Drag create events end --------------------------
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Gnt.view.Gantt} ganttView The gantt view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Ext.EventObject} e The event object
     */
    constructor: function(config) {
        config = config || {};
        if (config) {
            this.externalGetRowClass = config.getRowClass;
            delete config.getRowClass;
        }
        this.callParent(arguments);
        this.on({
            itemupdate: this.onRowUpdate,
            scope: this
        });
        this.mon(this.taskStore, {
            update: this.onTaskStoreUpdate,
            scope: this
        });
        this.initTreeFiltering();
    },
    setupTooltip: function() {
        var me = this,
            target = me.getEl();
        me.callParent(arguments);
        me.tip.destroy();
        me.tip = new Gnt.tooltip.EventTip(Ext.apply({
            view: me,
            delegate: me.eventSelector,
            target: target,
            dismissDelay: 0,
            constrainTo: me.grid.getEl(),
            // Stay within target region
            rtl: me.rtl
        }, me.tipCfg));
    },
    onBeforeIndentationChange: function() {
        var position = this.getNavigationModel().getPosition();
        if (position && position.record) {
            this._lastNavigatedRecord = position.record;
        }
    },
    onIndentationChange: function() {
        this._lastNavigatedRecord && this.getNavigationModel().setPosition(this._lastNavigatedRecord);
        delete this._lastNavigatedRecord;
    },
    onRender: function() {
        // 213_indent
        // save navigation position during indenting
        this.mon(this.getTaskStore(), {
            beforeindentationchange: this.onBeforeIndentationChange,
            indentationchange: this.onIndentationChange,
            scope: this
        });
        this.configureLabels();
        this.setupGanttEvents();
        this.setupTemplates();
        this.callParent(arguments);
    },
    /**
     * Returns the associated dependency store
     * @return {Gnt.data.TaskStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    configureFeatures: function() {
        if (this.enableProgressBarResize !== false) {
            this.progressBarResizer = Ext.create("Gnt.feature.ProgressBarResize", Ext.apply({
                ganttView: this
            }, this.progressBarResizeConfig || {}));
            this.on({
                beforeprogressbarresize: this.onBeforeTaskProgressBarResize,
                progressbarresizestart: this.onTaskProgressBarResizeStart,
                afterprogressbarresize: this.onTaskProgressBarResizeEnd,
                scope: this
            });
        }
        if (this.taskResizeHandles !== 'none') {
            this.taskResizer = Ext.create("Gnt.feature.TaskResize", Ext.apply({
                ganttView: this,
                validatorFn: this.resizeValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.resizeConfig || {}));
            this.on({
                beforedragcreate: this.onBeforeDragCreate,
                beforetaskresize: this.onBeforeTaskResize,
                taskresizestart: this.onTaskResizeStart,
                aftertaskresize: this.onTaskResizeEnd,
                progressbarresizestart: this.onTaskResizeStart,
                afterprogressbarresize: this.onTaskResizeEnd,
                scope: this
            });
        }
        if (this.enableTaskDragDrop) {
            this.taskDragDrop = Ext.create(this.dragDropConfig && this.dragDropConfig.xclass || "Gnt.feature.taskdd.DragZone", this.getEl(), Ext.apply({
                gantt: this,
                taskSelector: this.eventSelector,
                deadlineSelector: '.gnt-deadline-indicator',
                validatorFn: this.dndValidatorFn || Ext.emptyFn,
                validatorFnScope: this,
                skipWeekendsDuringDragDrop: this.taskStore.skipWeekendsDuringDragDrop,
                snapRelativeToEventStartDate: this.snapRelativeToEventStartDate
            }, this.dragDropConfig));
            this.on({
                beforetaskdrag: this.onBeforeTaskDrag,
                taskdragstart: this.onDragDropStart,
                aftertaskdrop: this.onDragDropEnd,
                scope: this
            });
        }
        if (this.enableDragCreation) {
            this.dragCreator = Ext.create("Gnt.feature.DragCreator", Ext.apply({
                ganttView: this,
                validatorFn: this.createValidatorFn || Ext.emptyFn,
                validatorFnScope: this
            }, this.createConfig));
        }
    },
    /**
     * Returns the template for the task. Override this template method to supply your own custom UI template for a certain type of task.
     *
     * @template
     * @protected
     * @param {Gnt.model.Task} task The task to get template for.
     * @param {Boolean} isBaseline True to return the template for a baseline version of the task.
     * @return {Gnt.template.Template} Template for the task.
     */
    getTemplateForTask: function(task, isBaseline) {
        if (task.isMilestone(isBaseline)) {
            return this.milestoneTemplate;
        }
        if (task.isLeaf()) {
            return this.eventTemplate;
        }
        // return baseline templates
        return this.parentEventTemplate;
    },
    refreshNotReadOnlyChildNodes: function(record) {
        record.cascadeBy({
            // if a child is explicitly marked as readonly then parent readonly change
            // doesn't affect the child state so we don't cascade it or its children
            before: function(child) {
                return child == record || !child.getReadOnly();
            },
            after: function(child) {
                if (child !== record) {
                    this.refreshNode(child);
                }
            },
            scope: this
        });
    },
    setShowRollupTasks: function(show) {
        this.showRollupTasks = show;
        var parentNodes = {};
        this.taskStore.getRootNode().cascadeBy(function(node) {
            if (node.getRollup()) {
                var parentNode = node.parentNode;
                parentNodes[parentNode.internalId] = parentNode;
            }
        });
        for (var id in parentNodes) {
            var index = this.store.indexOf(parentNodes[id]);
            if (index >= 0) {
                this.refreshNode(index);
            }
        }
    },
    getRollupTasks: function(parentTask) {
        return Ext.Array.filter(parentTask.childNodes, function(task) {
            return task.getRollup();
        });
    },
    //Todo combine generic parts this function with columnRenderer
    getRollupRenderData: function(parentModel) {
        var rollupData = [];
        var ta = this.timeAxis,
            viewStart = ta.getStart(),
            viewEnd = ta.getEnd(),
            rollupTasks = this.getRollupTasks(parentModel);
        for (var i = 0; i < rollupTasks.length; i++) {
            var taskModel = rollupTasks[i];
            var taskStart = taskModel.getStartDate();
            var taskEnd = taskModel.getEndDate() || taskStart && Sch.util.Date.add(taskStart, taskModel.getDurationUnit(), 1);
            if (taskStart && taskEnd) {
                if (Sch.util.Date.intersectSpans(taskStart, taskEnd, viewStart, viewEnd)) {
                    var data = {},
                        isMileStone = taskModel.isMilestone(),
                        rollupLabel;
                    data.isRollup = true;
                    data.id = Ext.id();
                    data.attr = 'rolluptaskid="' + taskModel.getId() + '"';
                    var endsOutsideView = taskEnd > viewEnd,
                        startsInsideView = Sch.util.Date.betweenLesser(taskStart, viewStart, viewEnd),
                        taskStartX = this.getCoordinateFromDate(startsInsideView ? taskStart : viewStart),
                        taskEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskEnd),
                        itemWidth = isMileStone ? 0 : taskEndX - taskStartX;
                    data.offset = (isMileStone ? (taskEndX || taskStartX) : taskStartX);
                    data.tpl = isMileStone ? this.milestoneTemplate : this.eventTemplate;
                    data.cls = taskModel.getCls();
                    data.ctcls = '';
                    data.record = taskModel;
                    if (rollupLabel = this.rollupLabelField) {
                        var value = taskModel.data[rollupLabel.dataIndex || rollupLabel];
                        data.rollupLabel = rollupLabel.renderer ? rollupLabel.renderer.call(rollupLabel.scope || this, value, taskModel) : Ext.htmlEncode(value);
                    }
                    if (isMileStone) {
                        data.side = Math.round(0.5 * this.getRowHeight());
                        data.ctcls += ' sch-gantt-milestone';
                    } else {
                        data.width = Math.max(1, itemWidth);
                        if (endsOutsideView) {
                            data.ctcls += ' sch-event-endsoutside ';
                        }
                        if (!startsInsideView) {
                            data.ctcls += ' sch-event-startsoutside ';
                        }
                        data.ctcls += ' sch-gantt-task';
                    }
                    if (taskModel.isReadOnly()) {
                        data.ctcls += ' sch-gantt-task-readonly';
                    }
                    if (taskModel.isProject) {
                        data.ctcls += ' sch-gantt-project-task';
                    }
                    data.cls += ' sch-rollup-task';
                    rollupData.push(data);
                }
            }
        }
        return rollupData;
    },
    getLabelRenderData: function(taskModel) {
        var left = this.leftLabelField,
            right = this.rightLabelField,
            top = this.topLabelField,
            bottom = this.bottomLabelField,
            value,
            renderData = {
                labelRendered: true
            };
        if (left) {
            value = left.dataIndex ? taskModel.data[left.dataIndex] : undefined;
            renderData.leftLabel = left.renderer ? left.renderer.call(left.scope || this, value, taskModel) : Ext.htmlEncode(value);
        }
        if (right) {
            value = right.dataIndex ? taskModel.data[right.dataIndex] : undefined;
            renderData.rightLabel = right.renderer ? right.renderer.call(right.scope || this, value, taskModel) : Ext.htmlEncode(value);
        }
        if (top) {
            value = top.dataIndex ? taskModel.data[top.dataIndex] : undefined;
            renderData.topLabel = top.renderer ? top.renderer.call(top.scope || this, value, taskModel) : Ext.htmlEncode(value);
        }
        if (bottom) {
            value = bottom.dataIndex ? taskModel.data[bottom.dataIndex] : undefined;
            renderData.bottomLabel = bottom.renderer ? bottom.renderer.call(bottom.scope || this, value, taskModel) : Ext.htmlEncode(value);
        }
        return renderData;
    },
    getSegmentsRenderData: function(taskModel, percentDone, taskStartX) {
        var D = Sch.util.Date,
            parts = taskModel.getSegments(),
            viewStart = this.timeAxis.getStart(),
            viewEnd = this.timeAxis.getEnd(),
            segments = [],
            percentDoneDuration = 0,
            i, l, part, partStartX, partEndX, partStartDate, partEndDate, segmentCls, progressBarWidth, segmentWidth, percentDoneAtDate, percentDoneX;
        // since task is fragmented we cannot use just: (taskEnd - taskStart) * percentDone
        // we have to get sum of all parts instead
        for (i = 0 , l = parts.length; i < l; i++) {
            part = parts[i];
            percentDoneDuration += (part.getEndDate() - part.getStartDate()) * percentDone;
        }
        for (i = 0 , l = parts.length; i < l; i++) {
            part = parts[i];
            segmentCls = part.getCls() || '';
            partEndDate = part.getEndDate() || taskModel.getStartDate();
            partStartDate = part.getStartDate();
            // if this segment starts in the visible area
            if (D.betweenLesser(partStartDate, viewStart, viewEnd)) {
                partStartX = this.getCoordinateFromDate(partStartDate);
                // if it ends in visible area as well
                if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                    partEndX = this.getCoordinateFromDate(partEndDate);
                } else {
                    partEndX = this.getCoordinateFromDate(viewEnd);
                }
            } else // if its start is invisible
            {
                partStartX = this.getCoordinateFromDate(viewStart);
                // if end is visible
                if (D.betweenLesser(partEndDate, viewStart, viewEnd)) {
                    partEndX = this.getCoordinateFromDate(partEndDate);
                }
                // if both ends are invisible lets move them outside of visible area
                else if (partStartDate >= viewEnd && partEndDate > viewEnd) {
                    partStartX = partEndX = this.getCoordinateFromDate(viewEnd) + 100;
                } else if (partStartDate < viewStart && partEndDate < viewStart) {
                    partStartX = partEndX = this.getCoordinateFromDate(viewStart) - 100;
                } else // if segment start before view start and ends after view end
                {
                    partEndX = this.getCoordinateFromDate(viewEnd);
                }
            }
            segmentWidth = partEndX - partStartX;
            if (!percentDoneAtDate) {
                percentDoneDuration -= (partEndDate - partStartDate);
                if (percentDoneDuration <= 0) {
                    percentDoneAtDate = D.add(partEndDate, D.MILLI, percentDoneDuration);
                    // mark part that has progress bar slider
                    segmentCls += ' sch-segment-in-progress';
                    percentDoneX = this.getCoordinateFromDate(percentDoneAtDate);
                    // get progress bar size for this part
                    progressBarWidth = Math.min(Math.abs(percentDoneX - partStartX), segmentWidth);
                } else // all parts before the time span that has "percentDoneAtDate" have 100% percent done
                {
                    progressBarWidth = part.width;
                }
            } else // all parts after the time span that has "percentDoneAtDate" have zero percent done
            {
                progressBarWidth = 0;
            }
            segments.push(Ext.applyIf({
                left: partStartX - taskStartX,
                width: segmentWidth,
                cls: segmentCls,
                percentDone: percentDone * 100,
                SegmentIndex: i,
                progressBarWidth: progressBarWidth
            }, part.data));
        }
        segments[0].cls += ' sch-gantt-task-segment-first';
        segments[segments.length - 1].cls += ' sch-gantt-task-segment-last';
        return {
            percentDoneAtDate: percentDoneAtDate,
            segments: segments
        };
    },
    buildTaskCls: function(taskModel, tplData, startsInsideView, endsOutsideView) {
        var dataCls = '',
            ctcls = '';
        if (taskModel.isMilestone()) {
            tplData.side = Math.round((this.enableBaseline ? 0.4 : 0.5) * this.getRowHeight());
            ctcls += " sch-gantt-milestone";
        } else {
            var minWidthForShowingArrows = 8;
            if (tplData.width < minWidthForShowingArrows) {
                ctcls += 'sch-gantt-parent-noarrows';
            }
            if (endsOutsideView) {
                ctcls += ' sch-event-endsoutside ';
            }
            if (!startsInsideView) {
                ctcls += ' sch-event-startsoutside ';
            }
            if (taskModel.isLeaf()) {
                var resizableMode = taskModel.getResizable();
                ctcls += " sch-gantt-task";
                if (typeof resizableMode === 'boolean' || typeof resizableMode === 'string') {
                    dataCls += ' sch-event-resizable-' + resizableMode;
                }
            } else {
                ctcls += " sch-gantt-parent-task";
            }
        }
        if (taskModel.isReadOnly()) {
            ctcls += " sch-gantt-task-readonly";
        }
        if (taskModel.isProject) {
            ctcls += " sch-gantt-project-task";
        }
        if (taskModel.dirty)  {
            dataCls += ' sch-dirty ';
        }
        
        if (taskModel.isDraggable() === false)  {
            dataCls += ' sch-event-fixed ';
        }
        
        dataCls += taskModel.isSegmented() ? ' sch-event-segmented ' : ' sch-event-notsegmented ';
        tplData.cls += ' ' + dataCls;
        tplData.ctcls += ' ' + ctcls;
    },
    // private
    columnRenderer: function(value, meta, taskModel) {
        var taskStart = taskModel.getStartDate(),
            timeAxis = this.timeAxis,
            D = Sch.util.Date,
            tplData = {},
            cellResult = '',
            viewStart = timeAxis.getStart(),
            viewEnd = timeAxis.getEnd(),
            isMilestone = taskModel.isMilestone(),
            userData, startsInsideView, endsOutsideView;
        if (taskStart) {
            var taskEnd = taskModel.getEndDate() || D.add(taskStart, taskModel.getDurationUnit() || D.DAY, 1),
                tick = timeAxis.getAt(0),
                // milliseconds per pixel ratio
                msPerPx = (tick.getEndDate() - tick.getStartDate()) / this.timeAxisViewModel.getTickWidth(),
                timeDelta = msPerPx * this.outsideLabelsGatherWidth,
                // if task belongs to the visible time span
                doRender = D.intersectSpans(taskStart, taskEnd, viewStart, viewEnd),
                renderBuffer = this.outsideLabelsGatherWidth > 0,
                // if task belongs to the buffered zone before/after visible time span
                renderAfter = renderBuffer && D.intersectSpans(taskStart, taskEnd, viewEnd, new Date(viewEnd.getTime() + timeDelta)),
                renderBefore = renderBuffer && D.intersectSpans(taskStart, taskEnd, new Date(viewStart.getTime() - timeDelta), viewStart);
            // if task belongs to the visible time span
            // or belongs to the buffered zone before/after visible time span
            if (doRender || renderAfter || renderBefore) {
                endsOutsideView = taskEnd > viewEnd;
                startsInsideView = D.betweenLesser(taskStart, viewStart, viewEnd);
                var taskStartX, taskEndX, itemWidth;
                // regular case ..task intersects visible time span
                if (doRender) {
                    taskStartX = this.getCoordinateFromDate(startsInsideView ? taskStart : viewStart);
                    taskEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskEnd);
                    itemWidth = isMilestone ? 0 : taskEndX - taskStartX;
                } else // task belongs to the buffered zone before/after visible time span
                {
                    startsInsideView = true;
                    itemWidth = 0;
                    if (renderAfter) {
                        taskStartX = Math.floor(this.getCoordinateFromDate(viewEnd) + (taskStart - viewEnd) / msPerPx);
                    } else {
                        taskStartX = Math.floor(this.getCoordinateFromDate(viewStart) - (viewStart - taskEnd) / msPerPx);
                    }
                }
                // if task is partially hidden progress bar should be rendered accordingly
                // eg. task is halfway done and rendered only half of the task
                // progress bar in this case should be hidden (width is 0)
                var percentDone = Math.min(taskModel.getPercentDone() || 0, 100) / 100,
                    percentDoneAtDate, percentDoneX, progressBarWidth, segments;
                // if task is split
                if (taskModel.isSegmented()) {
                    var segmentsRenderData = this.getSegmentsRenderData(taskModel, percentDone, taskStartX);
                    percentDoneAtDate = segmentsRenderData.percentDoneAtDate;
                    segments = segmentsRenderData.segments;
                } else // if task is NOT split
                {
                    // picks date between task start and end according to percentDone value
                    percentDoneAtDate = new Date((taskEnd - taskStart) * percentDone + taskStart.getTime());
                    if (percentDoneAtDate < viewStart) {
                        percentDoneAtDate = viewStart;
                    } else if (percentDoneAtDate > viewEnd) {
                        percentDoneAtDate = viewEnd;
                    }
                }
                percentDoneX = this.getCoordinateFromDate(percentDoneAtDate);
                // what if rtl?
                // in case task is rendered outside of view and has width 0, we should also set progress bar
                // width to 0 or progress bar will be visible as a 1px width vertical lines
                progressBarWidth = Math.min(Math.abs(percentDoneX - taskStartX), itemWidth);
                // Data provided to the Task XTemplate is composed in these steps
                //
                // 1. Get the default data from the Task Model
                // 2. Apply internal rendering properties: id, sizing, position etc
                // 3. Allow user to add extra properties at runtime using the eventRenderer template method
                tplData = {
                    // Core properties
                    id: taskModel.internalId + '-x-x',
                    offset: isMilestone ? (taskEndX || taskStartX) - this.getXOffset(taskModel) : taskStartX,
                    width: Math.max(1, itemWidth),
                    ctcls: '',
                    cls: taskModel.getCls() || '',
                    print: this._print,
                    record: taskModel,
                    percentDone: percentDone * 100,
                    progressBarWidth: Math.max(0, progressBarWidth - 2 * this.eventBorderWidth),
                    segments: segments
                };
                // Labels
                Ext.apply(tplData, this.getLabelRenderData(taskModel));
                // Get data from user "renderer"
                userData = this.eventRenderer && this.eventRenderer.call(this.eventRendererScope || this, taskModel, tplData, taskModel.store, meta) || {};
                if (userData) {
                    Ext.apply(tplData, userData);
                }
                this.buildTaskCls(taskModel, tplData, startsInsideView, endsOutsideView);
                cellResult += this.getTemplateForTask(taskModel).apply(tplData);
            }
        }
        // Show the rollup tasks no matter if the summary task is in view or not.
        if (this.showRollupTasks && !taskModel.isLeaf()) {
            var rollupData = this.getRollupRenderData(taskModel);
            if (rollupData.length > 0) {
                cellResult += this.rollupTemplate.apply(rollupData);
            }
        }
        // if baselines enabled
        if (this.enableBaseline) {
            // userData might be not initialized if we do not render the task bar (unscheduled or out of visible span)
            if (!userData) {
                userData = this.eventRenderer && this.eventRenderer.call(this, taskModel, tplData, taskModel.store, meta) || {};
            }
            // render baseline bar
            cellResult += this.baselineRenderer(taskModel, userData, viewStart, viewEnd, tplData.labelRendered);
        }
        var deadline = taskModel.getDeadlineDate();
        if (deadline && timeAxis.dateInAxis(deadline)) {
            cellResult += this.deadlineRenderer(taskModel, deadline);
        }
        return cellResult;
    },
    deadlineRenderer: function(taskModel, deadline) {
        return this.deadlineTemplate.apply({
            dir: this.rtl ? 'right' : 'left',
            offset: this.getCoordinateFromDate(deadline),
            date: this.getFormattedEndDate(deadline),
            cls: (new Date() > deadline && !taskModel.isCompleted()) ? 'gnt-deadline-indicator-late' : ''
        });
    },
    baselineRenderer: function(taskModel, userData, viewStart, viewEnd, labelsRenderDataPrepared) {
        var D = Sch.util.Date,
            taskBaselineStart = taskModel.getBaselineStartDate(),
            taskBaselineEnd = taskModel.getBaselineEndDate();
        if (taskBaselineStart && taskBaselineEnd && D.intersectSpans(taskBaselineStart, taskBaselineEnd, viewStart, viewEnd)) {
            var endsOutsideView = taskBaselineEnd > viewEnd;
            var startsInsideView = D.betweenLesser(taskBaselineStart, viewStart, viewEnd);
            userData = userData || {};
            var isBaselineMilestone = taskModel.isBaselineMilestone(),
                baseStartX = this.getCoordinateFromDate(startsInsideView ? taskBaselineStart : viewStart),
                baseEndX = this.getCoordinateFromDate(endsOutsideView ? viewEnd : taskBaselineEnd),
                baseWidth = Math.max(1, isBaselineMilestone ? 0 : baseEndX - baseStartX),
                baseTpl = this.getTemplateForTask(taskModel, true),
                data = {
                    progressBarStyle: userData.baseProgressBarStyle || '',
                    // Putting 'base-' as suffix ('-base') conflicts with task element id creating rules where
                    // task element id is [commonprefix]-(task.internalId)-(resource.internalId)-(partnum)
                    id: 'base-' + taskModel.internalId,
                    // TODO: this should use same rendering as the regular task
                    progressBarWidth: Math.min(100, taskModel.getBaselinePercentDone()) * baseWidth / 100,
                    percentDone: taskModel.getBaselinePercentDone(),
                    offset: isBaselineMilestone ? (baseEndX || baseStartX) - this.getXOffset(taskModel, true) : baseStartX,
                    print: this._print,
                    width: Math.max(1, baseWidth),
                    style: userData.baseStyle || '',
                    baseline: true
                };
            var ctcls = '';
            if (isBaselineMilestone) {
                data.side = Math.round(0.4 * this.getRowHeight());
                ctcls = "sch-gantt-milestone-baseline sch-gantt-baseline-item";
            } else if (taskModel.isLeaf()) {
                ctcls = "sch-gantt-task-baseline sch-gantt-baseline-item";
            } else {
                ctcls = "sch-gantt-parenttask-baseline sch-gantt-baseline-item";
            }
            if (endsOutsideView) {
                ctcls += ' sch-event-endsoutside ';
            }
            if (!startsInsideView) {
                ctcls += ' sch-event-startsoutside ';
            }
            // HACK, a bit inconsistent. 'basecls' should probably end up on the task el instead of the wrapper.
            data.ctcls = ctcls + ' ' + (userData.basecls || '');
            if (!labelsRenderDataPrepared) {
                Ext.apply(data, this.getLabelRenderData(taskModel));
            }
            return baseTpl.apply(data);
        }
        return '';
    },
    getTemplateConfig: function() {
        return {
            leftLabel: this.leftLabelField,
            rightLabel: this.rightLabelField,
            topLabel: this.topLabelField,
            bottomLabel: this.bottomLabelField,
            rollupLabel: this.rollupLabelField,
            prefix: this.eventPrefix,
            taskResizeHandles: this.taskResizeHandles,
            enableDependencyDragDrop: this.enableDependencyDragDrop !== false,
            allowParentTaskDependencies: this.allowParentTaskDependencies !== false,
            enableProgressBarResize: this.enableProgressBarResize,
            rtl: this.rtl
        };
    },
    setupTemplate: function(template, defaultClass, defaultConfig) {
        // if no template provided or it's not a template class instance
        if (!template || !template.isTemplate) {
            template = Ext.create(Ext.apply({
                xclass: defaultClass
            }, template, defaultConfig));
        }
        return template;
    },
    setupTemplates: function() {
        var tplCfg = this.getTemplateConfig();
        var config = Ext.apply({}, this.taskBodyTemplate && {
                innerTpl: this.taskBodyTemplate
            }, tplCfg);
        this.eventTemplate = this.setupTemplate(this.eventTemplate, "Gnt.template.Task", config);
        config = Ext.apply({}, this.parentTaskBodyTemplate && {
            innerTpl: this.parentTaskBodyTemplate
        }, tplCfg);
        this.parentEventTemplate = this.setupTemplate(this.parentEventTemplate, "Gnt.template.ParentTask", config);
        config = Ext.apply({}, this.milestoneBodyTemplate && {
            innerTpl: this.milestoneBodyTemplate
        }, tplCfg);
        this.milestoneTemplate = this.setupTemplate(this.milestoneTemplate, "Gnt.template.Milestone", config);
        this.rollupTemplate = this.setupTemplate(this.rollupTemplate, "Gnt.template.RollupTask");
        this.deadlineTemplate = this.setupTemplate(this.deadlineTemplate, "Gnt.template.Deadline");
    },
    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    // To be compatible with Sch.view.dependency.View
    getEventStore: function() {
        return this.getTaskStore();
    },
    // private
    setupGanttEvents: function() {
        var me = this,
            taskStore = this.taskStore;
        if (this.toggleParentTasksOnClick) {
            this.on({
                taskclick: function(view, task, e) {
                    if (e.getTarget('.sch-rollup-wrap'))  {
                        return;
                    }
                    
                    var dependencyView = this.ownerGrid.dependencyView,
                        isCreatingDependency = dependencyView && dependencyView.dragZone && dependencyView.dragZone.dragging;
                    if (!isCreatingDependency && !task.isLeaf() && (!taskStore.isTreeFiltered() || taskStore.allowExpandCollapseWhileFiltered)) {
                        task.isExpanded() ? task.collapse() : task.expand();
                    }
                }
            });
        }
    },
    // private
    configureLabels: function() {
        Ext.Array.each([
            'left',
            'right',
            'top',
            'bottom'
        ], function(pos) {
            var field = this[pos + 'LabelField'];
            if (field) {
                field = Ext.isObject(field) ? Ext.apply({}, field) : field;
                if (Ext.isString(field)) {
                    field = this[pos + 'LabelField'] = {
                        dataIndex: field
                    };
                }
                // Initialize editor (if defined)
                if (field.editor) {
                    var editor = field.editor;
                    // if user provided an object we should clone it in case it sits on a class prototype
                    if (!editor.isComponent) {
                        editor = Ext.clone(editor);
                    }
                    field.editor = Ext.create("Gnt.feature.LabelEditor", this, {
                        labelPosition: pos,
                        field: editor,
                        dataIndex: field.dataIndex
                    });
                }
                this[pos + 'LabelField'] = field;
            }
        }, this);
        this.on('labeledit_beforestartedit', this.onBeforeLabelEdit, this);
    },
    // private
    onBeforeTaskDrag: function(p, record) {
        return !this.readOnly && record.isDraggable() !== false && !record.isReadOnly() && (this.allowParentTaskMove || record.isLeaf());
    },
    onDragDropStart: function() {
        var me = this,
            DD = me.taskDragDrop,
            horizontal = DD.getConstrainDragToTaskRow && DD.getConstrainDragToTaskRow();
        if (me.tip) {
            me.tip.disable();
            me.tip.hide();
        }
        Sch.util.ScrollManager.activate(me, horizontal ? 'horizontal' : 'both');
        // In order to fix treeviewdragdrop scroll body is registered in scroll manager.
        // It makes all drag operations close to edges to trigger scroll.
        // Issue in 6.5.1 can be resolved by registering locked body, instead of scroll body. But 6.2.1 doesn't
        // allow such approach. In order to prevent task dragdrop to scroll vertically we make threshold too low
        // to ever be reached with mouse.
        if (!DD.outOfRowTaskDragDrop && DD.dragging) {
            me._oldVThresh = Ext.dd.ScrollManager.vthresh;
            Ext.dd.ScrollManager.vthresh = -1;
        }
    },
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
        Sch.util.ScrollManager.deactivate(this);
        if (!this.taskDragDrop.outOfRowTaskDragDrop && this.taskDragDrop.dragging) {
            Ext.dd.ScrollManager.vthresh = this._oldVThresh;
            delete this._oldVThresh;
        }
    },
    onTaskProgressBarResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },
    onTaskProgressBarResizeEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
    },
    onTaskResizeStart: function() {
        var scrollable = this.getScrollable();
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        // While resizing a task, we don't want the scroller to interfere
        scrollable.setDisabled && scrollable.setDisabled(true);
    },
    onTaskResizeEnd: function() {
        var scrollable = this.getScrollable();
        if (this.tip) {
            this.tip.enable();
        }
        // While resizing a task, we don't want the scroller to interfere
        scrollable.setDisabled && scrollable.setDisabled(false);
    },
    // private
    onBeforeDragCreate: function() {
        return !this.readOnly;
    },
    // private
    onBeforeTaskResize: function(view, task) {
        return !this.readOnly && !task.isEffortDriven();
    },
    onBeforeTaskProgressBarResize: function() {
        return !this.readOnly;
    },
    onBeforeLabelEdit: function() {
        return !this.readOnly;
    },
    afterRender: function() {
        this.callParent(arguments);
        this.getEl().on('mousemove', this.configureFeatures, this, {
            single: true
        });
    },
    resolveTaskRecord: function(el) {
        var node = this.findItemByChild(el);
        if (node) {
            return this.getRecord(node);
        }
        return null;
    },
    resolveEventRecord: function(el) {
        return this.resolveTaskRecord(el);
    },
    resolveEventRecordFromResourceRow: function(el) {
        return this.resolveTaskRecord(el);
    },
    /**
     * @private
     * @param {Gnt.model.Task} task Task to highlight
     * @param {Boolean} highlight Pass true to highlight task and false to unhighlight it
     * @param {Boolean} [includeDependent] Pass false to ignore dependent tasks/dependencies
     */
    triggerHighlightTask: function(task, highlight, includeDependent) {
        if (!(task instanceof Ext.data.Model)) {
            task = this.taskStore.getModelById(task);
        }
        if (task) {
            task.isHighlighted = highlight;
            var el = this.getRow(task);
            if (el) {
                Ext.fly(el)[highlight ? 'addCls' : 'removeCls']('sch-gantt-task-highlighted');
            }
            if (includeDependent !== false) {
                for (var i = 0,
                    l = task.successors.length; i < l; i++) {
                    var dep = task.successors[i];
                    this[(highlight ? '' : 'un') + 'highlightDependency'](dep);
                    this[(highlight ? '' : 'un') + 'highlightTask'](dep.getTargetTask(), includeDependent);
                }
            }
        }
    },
    /**
     * Highlights a task and optionally any dependent tasks. Highlighting will add the `sch-gantt-task-highlighted`
     * class to the task row element.
     *
     * @param {Gnt.model.Task/Number} task Either a task record or the id of a task
     * @param {Boolean} highlightDependentTasks `true` to highlight the depended tasks. Defaults to `true`
     *
     */
    highlightTask: function(task, highlightDependentTasks) {
        this.triggerHighlightTask(task, true, highlightDependentTasks);
    },
    /**
     * Un-highlights a task and optionally any dependent tasks.
     *
     * @param {Gnt.model.Task/Number} task Either a task record or the id of a task
     * @param {Boolean} includeSuccessorTasks `true` to also highlight successor tasks. Defaults to `true`
     *
     */
    unhighlightTask: function(task, includeSuccessorTasks) {
        this.triggerHighlightTask(task, false, includeSuccessorTasks);
    },
    /**
     * Highlights tasks in the current view that match the passed filter function
     * @param {Function} fn Function to filter tasks to hightlight
     * @param {Object} [scope] Scope for filter function
     */
    highlightTasksBy: function(fn, scope) {
        var me = this;
        scope = scope || me;
        me.taskStore.getRoot().cascadeBy(function(task) {
            fn.call(scope, task) && me.highlightTask(task, false);
        });
    },
    /**
     * Clears highlighted tasks/dependencies
     */
    clearHighlightedTasks: function() {
        var me = this,
            dependencyView = me.ownerGrid.getDependencyView();
        me.taskStore.getRoot().cascadeBy(function(task) {
            me.unhighlightTask(task, false);
        });
        Ext.Array.each(dependencyView.getHighlightedDependencies(), function(dependency) {
            dependencyView.unhighlightDependency(dependency);
        });
    },
    getRowClass: function(task) {
        var cls = '';
        if (task.isHighlighted) {
            cls += ' sch-gantt-task-highlighted';
        }
        if ('_GroupValue_' in task.data) {
            cls += ' gnt-group-item';
        }
        if (this.externalGetRowClass) {
            cls += ' ' + (this.externalGetRowClass.apply(this, arguments) || '');
        }
        return cls;
    },
    /**
     * Returns the critical path(s) that can affect the end date of the project
     * @return {Array} paths An array of arrays (containing task chains)
     */
    getCriticalPaths: function() {
        return this.taskStore.getCriticalPaths();
    },
    /**
     * Highlights the critical path(s) that can affect the end date of the project.
     */
    highlightCriticalPaths: function() {
        var me = this;
        // First clear any selected tasks/dependencies
        me.clearHighlightedTasks();
        var paths = me.getCriticalPaths(),
            dependencyStore = me.getDependencyStore(),
            dependencyView = me.ownerGrid.getDependencyView();
        // we might have multiple projects
        Ext.Array.each(paths, function(path) {
            var prevLevelTasks;
            // walk through the path
            Ext.Array.each(path, function(levelTasks) {
                // every element is an array of critical predecessors
                for (var i = 0,
                    l = levelTasks.length; i < l; i++) {
                    var task = levelTasks[i];
                    // for leaves we highlight the task itself and its parents that are also critical
                    if (task.isLeaf()) {
                        task.bubble(function(parent) {
                            if (!parent.isRoot() && !parent.isProject && (parent === task || parent.isCritical())) {
                                me.highlightTask(parent, false);
                            }
                        });
                    } else // for summaries we highlight the task itself and its children that are also critical
                    {
                        task.cascadeBy(function(child) {
                            if (child === task || child.isCritical()) {
                                me.highlightTask(child, false);
                            }
                        });
                    }
                    // If we have the previous path chain
                    // let's loop over its tasks and highlight stressed dependencies
                    if (prevLevelTasks) {
                        Ext.each(prevLevelTasks, function(prevTask) {
                            var dependency = dependencyStore.getTasksLinkingDependency(task, prevTask);
                            dependency && dependencyView.highlightDependency(dependency);
                        });
                    }
                }
                prevLevelTasks = levelTasks;
            });
        });
        me.addCls('sch-gantt-critical-chain');
    },
    /**
     * Removes the highlighting of the critical path(s).
     */
    unhighlightCriticalPaths: function() {
        var me = this;
        me.removeCls('sch-gantt-critical-chain');
        me.clearHighlightedTasks();
    },
    //private
    getXOffset: function(task, isBaseline) {
        var offset = 0;
        if (task.isMilestone(isBaseline)) {
            // For milestones, the offset should be one forth of the row height
            // #4784
            offset = Math.floor(this.getRowHeight() / 4);
        }
        return offset;
    },
    //private
    onDestroy: function() {
        if (this.rendered) {
            Ext.dd.ScrollManager.unregister(this.el);
        }
        clearTimeout(this.scrollTimer);
        clearTimeout(this.unbindListenerTimer);
        this.taskDragDrop && Ext.destroy(this.taskDragDrop);
        this.callParent(arguments);
    },
    /**
     * Convenience method wrapping the dependency manager method which highlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    highlightDependency: function(record) {
        this.ownerGrid.getDependencyView().highlightDependency(record);
    },
    /**
     * Convenience method wrapping the dependency manager method which unhighlights the elements representing a particular dependency
     * @param {Mixed} record Either the id of a record or a record in the dependency store
     */
    unhighlightDependency: function(record) {
        this.ownerGrid.getDependencyView().unhighlightDependency(record);
    },
    /**
     * Returns the editor defined for the left task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getLeftEditor: function() {
        return this.leftLabelField && this.leftLabelField.editor;
    },
    /**
     * Returns the editor defined for the right task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getRightEditor: function() {
        return this.rightLabelField && this.rightLabelField.editor;
    },
    /**
     * Returns the editor defined for the top task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getTopEditor: function() {
        return this.topLabelField && this.topLabelField.editor;
    },
    /**
     * Returns the editor defined for the bottom task label
     * @return {Gnt.feature.LabelEditor} editor The editor
     */
    getBottomEditor: function() {
        return this.bottomLabelField && this.bottomLabelField.editor;
    },
    /**
     * Programmatically activates the editor for the left label
     * @param {Gnt.model.Task} record The task record
     */
    editLeftLabel: function(record) {
        var ed = this.getLeftEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the right label
     * @param {Gnt.model.Task} record The task record
     */
    editRightLabel: function(record) {
        var ed = this.getRightEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the top label
     * @param {Gnt.model.Task} record The task record
     */
    editTopLabel: function(record) {
        var ed = this.getTopEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    /**
     * Programmatically activates the editor for the bottom label
     * @param {Gnt.model.Task} record The task record
     */
    editBottomLabel: function(record) {
        var ed = this.getBottomEditor();
        if (ed) {
            ed.edit(record);
        }
    },
    // Repaint parents of rollup tasks and readonly child tasks
    onRowUpdate: function(store, index) {
        var record = this.store.getAt(index);
        if (record && record.previous) {
            var prev = record.previous;
            // The code below will handle the redraw when user does "setRollup" on some task
            // However generally the parent tasks are refreshed at the end of the cascading in the `onAfterCascade` method
            // of the Gnt.panel.Gantt
            if (record.parentNode && (record.rollupField in prev || record.getRollup())) {
                this.refreshNode(record.parentNode);
            }
            // refresh the task child nodes when the task readOnly status changes
            if (record.readOnlyField in prev) {
                this.refreshNotReadOnlyChildNodes(record);
            }
        }
    },
    // Repaint parents of rollup tasks if such tasks are hidden due to collapsed parent and update is done
    // via undo-redo (though there might be other cases when rollup task is changed and those changes might
    // not propagate to a parent task, if, for example, recalculate parents or cascade changes are off)
    onTaskStoreUpdate: function(taskStore, task, operation, modifiedFieldNames, details) {
        var prev = task.previous;
        if (prev && task.getRollup() && task.parentNode && !task.parentNode.expanded && taskStore.isUndoingOrRedoing()) {
            this.refreshNode(task.parentNode);
        }
    },
    handleScheduleEvent: function(e) {
        var t = e.getTarget('.' + this.timeCellCls, 3);
        if (t) {
            var rowNode = this.findRowByChild(t);
            if (e.type.indexOf('pinch') >= 0) {
                this.fireEvent('schedule' + e.type, this, e);
            } else {
                this.fireEvent('schedule' + e.type, this, this.getDateFromDomEvent(e, 'floor'), this.indexOf(rowNode), e);
            }
        }
    },
    /**
     *  Scrolls a task record into the viewport.
     *  This method will also expand all relevant parent nodes to locate the event.
     *
     *  @param {Gnt.model.Task} taskRec, the task record to scroll into view
     *  @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     *  @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     */
    scrollEventIntoView: function(taskRec, highlight, animate, callback, scope) {
        scope = scope || this;
        var me = this;
        var taskStore = this.taskStore;
        var basicScroll = function(el, scrollHorizontally) {
                // HACK
                // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
                // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                me.up('panel').scrollTask.cancel();
                // Add a little breathing room on the left of the task
                me.scrollElementIntoView(el, scrollHorizontally, animate, highlight, 100, callback, scope);
            };
        // Make sure the resource is expanded all the way up first.
        if (!taskRec.isVisible()) {
            taskRec.bubble(function(node) {
                node.expand();
            });
        }
        var targetEl;
        var startDate = taskRec.getStartDate(),
            endDate = taskRec.getEndDate(),
            isScheduled = Boolean(startDate && endDate),
            elements;
        if (isScheduled) {
            var timeAxis = this.timeAxis;
            // If task is not in the currently viewed time span, change time span
            if (!timeAxis.dateInAxis(startDate)) {
                timeAxis.shiftTo(Sch.util.Date.add(startDate, timeAxis.mainUnit, -timeAxis.increment * 1));
            }
            elements = this.getElementsFromEventRecord(taskRec);
            targetEl = elements && elements[0];
        } else {
            // No date information in the task, scroll to row element instead
            targetEl = this.getNode(taskRec);
            if (targetEl) {
                targetEl = Ext.fly(targetEl).down(this.getCellSelector());
            }
        }
        // If task store is grouped bufferedRenderer.scrollTo() raises
        // an exception if we try to scroll to a summary task
        if (taskStore.indexOf(taskRec) >= 0) {
            this.scrollTimer = Ext.Function.defer(function() {
                me.ownerGrid.ensureVisible(taskRec, {
                    callback: function() {
                        // el should be present now
                        var elements = me.getElementsFromEventRecord(taskRec);
                        targetEl = elements && elements[0];
                        if (targetEl) {
                            Ext.Function.defer(function() {
                                basicScroll(targetEl, true);
                            }, 10);
                        } else {
                            callback && callback.call(scope);
                        }
                    }
                });
            }, 10);
        }
    },
    // Checks if the element provided has been rendered and if it's currently displayed.
    // At the state when it's rendered and displayed we can query DOM for element dimensions and offsets
    isElementRenderedAndDisplayed: function(taskRecordOrRowEl) {
        if (taskRecordOrRowEl instanceof Gnt.model.Task) {
            taskRecordOrRowEl = this.view.getRowNode(taskRecordOrRowEl);
        }
        return !!(taskRecordOrRowEl && Ext.fly(taskRecordOrRowEl).getHeight());
    },
    /**
     * Gets the task box of the given task.
     *
     * @param {Sch.model.Event} taskRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximately calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     */
    getItemBox: function(taskRecord) {
        var DATE = Sch.util.Date,
            me = this,
            result = null,
            viewStartDate = me.getViewStartDate(),
            viewEndDate = me.getViewEndDate(),
            // For milestones we tend to use end date since there might be a milestone having non-zero duration and in such case
            // no full length task bar is rendered, we just render a "diamond" on the end date
            taskStartDate = taskRecord.isMilestone() && taskRecord.getEndDate() || taskRecord.getStartDate(),
            taskEndDate = taskRecord.getEndDate(),
            taskStore = me.getTaskStore(),
            taskStartX, taskEndX, rowEl, rowIndex, rowHeight, firstRowIndex, firstRowRecord, lastRowIndex, lastRowRecord, lastRowEl;
        // Checking if task record is:
        result = (// - scheduled;
        taskStartDate && taskEndDate && // - visible, i.e. it's not within a collapsed row
        // - actually rendered or might be filtered out by Sencha's filters
        me.store.indexOf(taskRecord) >= 0 && (// - not filtered out
        !taskStore.isTreeFiltered() || taskStore.lastTreeFilter.filter.call(taskStore.lastTreeFilter.scope || taskStore, taskRecord))) || null;
        if (result) {
            rowEl = me.getNode(taskRecord);
            // If task row is rendered and displayed
            if (rowEl && me.isElementRenderedAndDisplayed(rowEl)) {
                var taskNodeTop, taskNodeBottom;
                var nodeContainer = me.getNodeContainer();
                var OUTSIDE_VIEW_OFFSET = 40;
                // To make sure non-relevant dependency lines aren't seen
                if (taskRecord.isMilestone()) {
                    var verticalMargin = me.getRowHeight() * 0.16,
                        rowTop = Ext.fly(rowEl).getOffsetsTo(nodeContainer)[1],
                        milestoneEl, leftOffset;
                    taskNodeTop = rowTop + verticalMargin;
                    taskNodeBottom = rowTop + me.getRowHeight() - verticalMargin;
                    // If there is a diamond element - use it for calculations
                    milestoneEl = Ext.fly(rowEl).down('.sch-gantt-milestone-diamond') || Ext.fly(rowEl).down('.sch-gantt-milestone-diamond-ct');
                    if (milestoneEl) {
                        leftOffset = milestoneEl.getOffsetsTo(rowEl)[0];
                        taskStartX = leftOffset;
                        taskEndX = leftOffset + milestoneEl.getWidth();
                    }
                } else {
                    var taskNode = Ext.fly(rowEl).down('.' + Ext.baseCSSPrefix + 'grid-cell-inner > .sch-event-wrap .sch-gantt-item', true) || rowEl;
                    taskNodeTop = Ext.fly(taskNode).getOffsetsTo(nodeContainer)[1];
                    taskNodeBottom = taskNodeTop + Ext.fly(taskNode).getHeight();
                }
                if (!taskStartX) {
                    taskStartX = me.getCoordinateFromDate(DATE.min(DATE.max(taskStartDate, viewStartDate), viewEndDate));
                    taskEndX = me.getCoordinateFromDate(DATE.max(DATE.min(taskEndDate, viewEndDate), viewStartDate));
                }
                // Make sure start/end points are not in view
                // NOTE: getTime() is for Chrome optimization
                if (viewStartDate.getTime() > taskStartDate.getTime())  {
                    taskStartX -= OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewStartDate.getTime() > taskEndDate.getTime())  {
                    taskEndX -= OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewEndDate.getTime() < taskStartDate.getTime())  {
                    taskStartX += OUTSIDE_VIEW_OFFSET;
                }
                
                if (viewEndDate.getTime() < taskEndDate.getTime())  {
                    taskEndX += OUTSIDE_VIEW_OFFSET;
                }
                
                // Finally we have all the data needed to calculate the task record box
                result = {
                    rendered: true,
                    start: taskStartX,
                    end: taskEndX,
                    top: Math.round(taskNodeTop),
                    bottom: Math.round(taskNodeBottom)
                };
            } else // Resource row is not rendered and it's not collapsed. We calculate a task box approximately.
            {
                result = {
                    rendered: false,
                    start: me.getCoordinateFromDate(DATE.max(taskStartDate, viewStartDate)),
                    end: me.getCoordinateFromDate(DATE.min(taskEndDate, viewEndDate))
                };
                // top and bottom to go
                // WARNING: view.all is a private property
                firstRowIndex = me.all.startIndex;
                firstRowRecord = me.getRecord(firstRowIndex);
                // WARNING: view.all is a private property
                lastRowIndex = me.all.endIndex;
                lastRowRecord = me.getRecord(lastRowIndex);
                if (firstRowRecord && lastRowRecord) {
                    rowHeight = me.getRowHeight();
                    // Task row is not rendered and it's above first visible row.
                    // Here we provide box coordinates requested to be in the row above the first visible row, this should suffice. The real box coordinates are somewhere above,
                    // and it will take way to much effort to calculate them to exact values, so we provide some sufficient surrogate coordinates.
                    if (taskRecord.isAbove(firstRowRecord)) {
                        result.top = -rowHeight;
                        result.bottom = result.top + rowHeight;
                        result.relPos = 'before';
                    }
                    // Task row is not rendered or displayed and it's inside visible rows range, the case happens when a view or one of it's parents is hidden
                    // with 'display:none' rule.
                    else if (taskRecord == lastRowRecord || taskRecord.isAbove(lastRowRecord)) {
                        rowIndex = me.indexOf(taskRecord);
                        result.top = rowIndex * rowHeight;
                        result.bottom = result.top + rowHeight;
                    } else // Task row is not rendered and it's below last visible row.
                    // Here we provide box coordinates requested to be in the row bellow the last visible row, this should suffice. The real box coordniates are somewhere below,
                    // and it will take way to much effort to calculate them to exact values, so we provide some sufficient surrogate coordinates.
                    {
                        lastRowEl = me.getNode(lastRowIndex);
                        // Rows can be stretched, use last row's real coordinates if offsets are reliable
                        if (me.isElementRenderedAndDisplayed(lastRowEl)) {
                            result.top = Ext.fly(lastRowEl).getOffsetsTo(me.getNodeContainer())[1] + Ext.fly(lastRowEl).getHeight();
                        } else {
                            result.top = (lastRowIndex + 1) * rowHeight;
                        }
                        result.bottom = result.top + rowHeight;
                        result.relPos = 'after';
                    }
                } else {
                    result = null;
                }
            }
            // Milestone boxes need special adjustments
            if (result) {
                result = me.adjustItemBox(taskRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Gnt.model.Task} taskRecord
     * @param {Object} taskBox
     * @return {Number} taskBox.top
     * @return {Number} taskBox.bottom
     * @return {Number} taskBox.start
     * @return {Number} taskBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(taskRecord, taskBox) {
        var result = taskBox;
        if (taskRecord.isMilestone()) {
            result.bottom++;
        }
        return result;
    },
    getDataForTooltipTpl: function(record, triggerElement, e) {
        var id = triggerElement.getAttribute('rolluptaskid'),
            targetRecord = record,
            overlappingRecords = [],
            data;
        // If hovering a rollup miniature, we should show the rolled up task info
        if (id) {
            var rolledUpRecord = this.getTaskStore().getNodeById(id);
            if (rolledUpRecord) {
                targetRecord = rolledUpRecord;
                overlappingRecords = this.getAdjacentRollupRecords(record, targetRecord, triggerElement, e);
            }
        }
        data = Ext.Array.map([
            targetRecord
        ].concat(overlappingRecords), function(record) {
            return Ext.apply({
                _record: record
            }, record.data);
        });
        // To make this structure BW compatible, single object has to be returned with _record
        // property (accessed by few examples). At the same time we should pass array of records for overlappig
        // rollups, that should include all records (for convenience). Resulting structure is recursive.
        return Ext.apply(data[0], {
            _useBaselineData: Boolean(Ext.fly(triggerElement).up('.sch-gantt-baseline-item')),
            records: data
        });
    },
    getAdjacentRollupRecords: function(rootRecord, rollupRecord, triggerElement, e) {
        var taskStore = this.getTaskStore(),
            adjacentRecords = [],
            threshold = this.rollupIntersectThreshold,
            cursorPoint = e.getPoint();
        Ext.fly(triggerElement).up('.sch-rollup-wrap').select('.sch-gantt-item').each(function(rollupEl) {
            if (triggerElement != rollupEl.dom) {
                var targetRegion = rollupEl.getRegion();
                var include;
                // Add a threshold distance for milestones to identify overlapping tasks
                if (rollupRecord.isMilestone()) {
                    var hoveredRollupElementRegion = Ext.fly(triggerElement).getRegion(),
                        sourceRegion = Ext.util.Region.from({
                            top: hoveredRollupElementRegion.top - threshold,
                            right: hoveredRollupElementRegion.right + threshold,
                            bottom: hoveredRollupElementRegion.bottom + threshold,
                            left: hoveredRollupElementRegion.left - threshold
                        });
                    include = sourceRegion.intersect(targetRegion);
                } else {
                    include = targetRegion.contains(cursorPoint);
                }
                if (include) {
                    var id = rollupEl.getAttribute('rolluptaskid');
                    var rolledUpRecord = taskStore.getNodeById(id);
                    if (rolledUpRecord) {
                        adjacentRecords.push(rolledUpRecord);
                    }
                }
            }
        });
        return adjacentRecords;
    },
    /**
     * Shows the baseline tasks
     */
    showBaseline: function() {
        var me = this;
        if (!me.baselineVisible) {
            me.baselineVisible = true;
            me.addCls('sch-ganttview-showbaseline');
            /**
             * Fired when baseline elements visiblity is set to on.
             *
             * @event baseline-show
             *
             * @param {Gnt.view.Gantt} this
             */
            me.fireEvent('baseline-show', me);
        }
    },
    /**
     * Hides the baseline tasks
     */
    hideBaseline: function() {
        var me = this;
        if (me.baselineVisible) {
            me.baselineVisible = false;
            /**
             * Fired when baseline elements visiblity is set to off.
             *
             * @event baseline-hide
             *
             * @param {Gnt.view.Gantt} this
             */
            me.removeCls('sch-ganttview-showbaseline');
            me.fireEvent('baseline-hide', me);
        }
    },
    /**
     * Toggles the display of the baseline
     */
    toggleBaseline: function() {
        var me = this;
        me.baselineVisible ? me.hideBaseline() : me.showBaseline();
    }
});

/**
 * @class   Gnt.widget.ConstraintResolutionForm
 * @extend  Ext.form.Panel
 */
Ext.define("Gnt.widget.ConstraintResolutionForm", {
    extend: "Ext.form.Panel",
    requires: [
        'Ext.form.RadioGroup',
        'Ext.form.field.Display'
    ],
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    alias: 'widget.constraintresolutionform',
    /**
     * @cfg {Object} l10n Object containing localication strings
     * An object, purposed for the class localization. Contains the following keys/values:

            - "Constraint violation" : "Constraint violation"
            - dateFormat           : "m/d/Y",
            - "OK"                 : 'OK',
            - "Cancel"             : 'Cancel',
            - "Resolution options" : "Resolution options",
            - "Don't ask again"    : "Don't ask again",
            - "Task {0} violates constraint {1}"     : "Task {0} violates constraint {1}",
            - "Task {0} violates constraint {1} {2}" : "Task {0} violates constraint {1} {2}"
     */
    legacyMode: false,
    // That's for localizable mixin
    config: {
        /**
         * @cfg {Object} resolutionContext Object containing a set of possible resolutions provided by {@link Gnt.constraint.Base#getResolution()}.
         */
        resolutionContext: null,
        /**
         * @cfg {String} [dateFormat=null] Date format string to use in vialotion description string. If none is given then
         * the one from {@link #l10n} will be used otherwise {@link Ext.Date#defaultFormat}.
         */
        dateFormat: null
    },
    bodyPadding: 10,
    autoScroll: true,
    initComponent: function() {
        var me = this;
        if (!me.getDateFormat()) {
            me.setDateFormat(me.L("dateFormat"));
        }
        me.setupItemsFromResolutionContext(me.resolutionContext);
        me.setupFooterFromResolutionContext(me.resolutionContext);
        me.callParent(arguments);
    },
    setupItemsFromResolutionContext: function(resolutionContext) {
        var me = this,
            resolutions;
        resolutions = Ext.Array.map(resolutionContext.resolutions, function(r, index) {
            return {
                xtype: 'radio',
                boxLabel: me.getResolutionOptionDescription(r, resolutionContext),
                name: 'resolutionOption',
                checked: r === resolutionContext.getCancelActionOption(),
                inputValue: index,
                tabIndex: index
            };
        });
        me.items = [
            {
                xtype: 'displayfield',
                itemId: 'description',
                value: me.getConstraintViolationDescription(resolutionContext),
                anchor: "-0"
            },
            {
                xtype: 'radiogroup',
                itemId: 'options',
                columns: 1,
                title: me.L("Resolution options"),
                allowBlank: false,
                items: resolutions,
                anchor: "-0"
            }
        ];
    },
    setupFooterFromResolutionContext: function(resolutionContext) {
        var me = this;
        me.fbar = {
            itemId: 'footer-tb',
            items: [
                {
                    xtype: 'checkbox',
                    itemId: 'dont-ask-cb',
                    boxLabel: me.L("Don't ask again"),
                    tabIndex: resolutionContext.resolutions.length + 1
                },
                '->',
                {
                    text: me.L("OK"),
                    itemId: 'ok-btn',
                    formBind: true,
                    tabIndex: resolutionContext.resolutions.length + 2,
                    handler: me.onUserActionOk,
                    scope: me
                },
                {
                    text: me.L("Cancel"),
                    itemId: 'cancel-btn',
                    tabIndex: resolutionContext.resolutions.length + 3,
                    handler: me.onUserActionCancel,
                    scope: me
                }
            ]
        };
    },
    getDontAskValue: function() {
        var me = this;
        return me.down('#dont-ask-cb').getValue();
    },
    getConstraintViolationDescription: function(resolutionContext) {
        var me = this,
            constraintTitle, constraintDate, constraintClass, task, taskName, dateFormat, description;
        constraintTitle = resolutionContext.title;
        task = resolutionContext.task;
        taskName = Ext.htmlEncode(task.getName()) || '';
        constraintClass = task.getConstraintClass();
        dateFormat = me.getDateFormat();
        constraintDate = constraintClass && constraintClass.getDisplayableConstraintDateForFormat(resolutionContext.date, dateFormat, task) || resolutionContext.date;
        if (resolutionContext.description) {
            description = resolutionContext.description;
        } else if (resolutionContext.getConstraintViolationDescription) {
            description = resolutionContext.getConstraintViolationDescription(resolutionContext, me);
        } else {
            description = constraintDate ? Ext.String.format(me.L("Task {0} violates constraint {1} {2}"), taskName, constraintTitle, Ext.Date.format(constraintDate, dateFormat)) : Ext.String.format(me.L("Task {0} violates constraint {1}"), taskName, constraintTitle);
        }
        return description;
    },
    getResolutionOptionDescription: function(resolution, resolutionContext) {
        var me = this,
            S = Ext.String,
            task, constraintDate, constraintClass, dateFormat;
        task = resolutionContext.task;
        constraintClass = task.getConstraintClass();
        dateFormat = me.getDateFormat();
        constraintDate = constraintClass && constraintClass.getDisplayableConstraintDateForFormat(resolutionContext.date, dateFormat, task) || resolutionContext.date;
        var values = [
                resolution.title
            ];
        if (resolution.getTitleValues) {
            values = values.concat(resolution.getTitleValues(resolutionContext, me));
            for (var i = values.length - 1; i >= 0; i--) {
                if (values[i] instanceof Date)  {
                    values[i] = Ext.Date.format(values[i], dateFormat);
                }
                
            }
        } else {
            values = values.concat([
                constraintDate && Ext.Date.format(constraintDate, dateFormat) || ''
            ]);
        }
        S.format.apply(S, values);
        return S.format.apply(S, values);
    },
    onUserActionOk: function(btn) {
        var me = this,
            result;
        result = me.getValues();
        result.dontAsk = me.getDontAskValue();
        me.fireEvent('ok', me, result);
    },
    onUserActionCancel: function(btn) {
        var me = this;
        me.fireEvent('cancel', me);
    },
    getOptimalHeight: function(width) {
        var me = this,
            originalPos, originalWidth, radioGroup, radioGroupOffsets, optimalHeight, footerBar;
        if (width) {
            originalPos = me.getXY();
            originalWidth = me.getWidth();
            me.setXY([
                -10000,
                -10000
            ]);
            me.setWidth(width);
        }
        radioGroup = me.getComponent('options');
        radioGroupOffsets = radioGroup.getEl().getOffsetsTo(me.body);
        footerBar = me.getDockedComponent('footer-tb');
        optimalHeight = radioGroupOffsets[1] + Ext.getDom(radioGroup.getEl()).scrollHeight + 2 * me.bodyPadding + footerBar.getHeight() + 10;
        /* scroll safety */
        if (width) {
            me.setWidth(originalWidth);
            me.setXY(originalPos);
        }
        return optimalHeight;
    }
});

/**
 * @class   Gnt.widget.ConstraintResolutionWindow
 * @extends Ext.window.Window
 */
Ext.define("Gnt.widget.ConstraintResolutionWindow", {
    extend: "Ext.window.Window",
    alias: "widget.constraintresolutionwindow",
    requires: [
        "Gnt.widget.ConstraintResolutionForm"
    ],
    mixins: [
        "Gnt.mixin.Localizable"
    ],
    modal: true,
    closable: true,
    resizable: true,
    collapsible: false,
    border: false,
    bodyBorder: false,
    /**
     * @cfg {Object} l10n Object containing localication strings
     * An object, purposed for the class localization. Contains the following keys/values:

            - "Constraint violation" : "Constraint violation"
     */
    config: {
        /**
         * @cfg {Object} resolutionContext Object containing a set of possible resolutions provided by {@link Gnt.constraint.Base#getResolution()}.
         */
        resolutionContext: null,
        /**
         * @cfg {String} dateFormat
         *
         * Date format to pass to {@link Gnt.widget.ConstraintResolutionForm}
         */
        dateFormat: null
    },
    form: null,
    minWidth: 500,
    // this one is here to satisfy localization test: this.L("Constraint violation")
    title: 'L{Constraint violation}',
    initComponent: function() {
        var me = this;
        me.title = me.localizeText(me.title);
        me.setupItems();
        me.height = Math.round(Ext.dom.Element.getViewportHeight() / 3);
        me.width = Math.round(Ext.dom.Element.getViewportWidth() / 4);
        me.callParent(arguments);
        me.on('afterlayout', me.onAfterOptimalLayout, me, {
            single: true
        });
    },
    setupItems: function() {
        var me = this;
        me.layout = 'fit';
        me.form = new Gnt.widget.ConstraintResolutionForm({
            resolutionContext: me.getResolutionContext(),
            dateFormat: me.getDateFormat(),
            bubbleEvents: [
                'ok',
                'cancel'
            ]
        });
        me.items = me.form;
    },
    onAfterOptimalLayout: function() {
        var me = this,
            originalHeight, originalFormHeight, formOptimalHeight, optimalHeight;
        originalHeight = me.getHeight();
        originalFormHeight = me.form.getHeight();
        formOptimalHeight = me.form.getOptimalHeight();
        optimalHeight = formOptimalHeight + originalHeight - originalFormHeight;
        originalHeight != optimalHeight && me.setHeight(optimalHeight);
    }
});

/**
 * @class   Gnt.plugin.ConstraintResolutionGui
 * @extends Ext.AbstractPlugin
 */
Ext.define("Gnt.plugin.ConstraintResolutionGui", {
    extend: "Ext.AbstractPlugin",
    alias: "plugin.constraintresolutiongui",
    requires: [
        "Gnt.widget.ConstraintResolutionWindow"
    ],
    config: {
        /**
         * @cfg {String} dateFormat
         *
         * Date format to pass to {@link Gnt.widget.ConstraintResolutionWindow}
         */
        dateFormat: null
    },
    cmpDetacher: null,
    storeDetacher: null,
    storedResolutions: null,
    window: null,
    init: function(cmp) {
        var me = this;
        me.callParent(arguments);
        if (!me.disabled) {
            me.enable();
        }
    },
    destroy: function() {
        // Destroy any active window if Gantt/plugin is destroyed
        this.window && this.window.destroy();
        this.callParent(arguments);
    },
    enable: function() {
        var me = this,
            cmp = me.getCmp();
        me.callParent();
        // This is a GUI class, let's wait for the Gantt view to render first
        if (cmp.rendered) {
            me.attachToTaskStore();
        } else {
            me.cmpDetacher = cmp.on('afterrender', function() {
                me.attachToTaskStore();
            }, null, {
                destroyable: true,
                single: true
            });
        }
    },
    disable: function() {
        var me = this,
            cmp = me.getCmp();
        me.callParent();
        if (cmp.rendered) {
            me.detachFromTaskStore();
        } else {
            me.cmpDetacher && Ext.destroy(me.cmpDetacher);
            me.cmpDetacher = null;
        }
    },
    attachToTaskStore: function() {
        var me = this,
            cmp, store;
        if (!me.storeDetacher) {
            cmp = me.getCmp();
            store = cmp.getTaskStore();
            me.storeDetacher = cmp.mon(store, 'constraintconflict', me.onConstraintConflict, me, {
                destroyable: true
            });
        }
    },
    detachFromTaskStore: function() {
        var me = this;
        me.storeDetacher && Ext.destroy(me.storeDetacher);
        me.storeDetacher = null;
    },
    onConstraintConflict: function(task, resolutionContext) {
        var me = this,
            ganttPanel = me.getCmp(),
            lockedView = ganttPanel.lockedGrid.getView(),
            normalView = ganttPanel.normalGrid.getView(),
            depView = ganttPanel.getDependencyView(),
            detacher,
            detacherWrapper = {
                destroy: function() {
                    Ext.destroy(detacher);
                }
            };
        // Redrawing the conflicting task row and dependencies
        function redrawTask() {
            lockedView.refreshNode(task);
            normalView.refreshNode(task);
            depView.updateDependencies(task.getAllDependencies()).then(null, Ext.emptyFn);
        }
        redrawTask();
        if (!me.hasStoredResolutionForContext(resolutionContext)) {
            var windowCfg = {
                    dateFormat: me.getDateFormat(),
                    resolutionContext: resolutionContext
                };
            // resolution context can override the window title
            if (resolutionContext.windowTitle) {
                windowCfg.title = resolutionContext.windowTitle;
            }
            me.window = new Gnt.widget.ConstraintResolutionWindow(windowCfg);
            detacher = me.window.on({
                'ok': Ext.Function.bind(me.onUserActionOk, me, [
                    resolutionContext,
                    redrawTask,
                    me.window,
                    detacherWrapper
                ], true),
                'cancel': Ext.Function.bind(me.onUserActionCancel, me, [
                    resolutionContext,
                    redrawTask,
                    me.window,
                    detacherWrapper
                ], true),
                'close': Ext.Function.bind(me.onUserActionClose, me, [
                    resolutionContext,
                    redrawTask,
                    detacherWrapper
                ], true),
                destroyable: true
            });
            ganttPanel.completeEdit();
            me.window.show();
        } else {
            me.resolveSilently(resolutionContext, redrawTask);
        }
    },
    getStoredResolutions: function() {
        var me = this;
        if (!me.storedResolutions) {
            me.storedResolutions = {};
        }
        return me.storedResolutions;
    },
    getStoredResolutionKeyForContext: function(resolutionContext) {
        return resolutionContext.constraintClassName + resolutionContext.resolutions.length;
    },
    hasStoredResolutionForContext: function(resolutionContext) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.getStoredResolutions();
        return Ext.isDefined(storedResolutions[key]);
    },
    getStoredResolutionForContext: function(resolutionContext) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.getStoredResolutions();
        return storedResolutions[key];
    },
    storeResolutionForContext: function(resolutionContext, optionIndex) {
        var me = this,
            key = me.getStoredResolutionKeyForContext(resolutionContext),
            storedResolutions = me.storedResolutions;
        me.storedResolutions[key] = optionIndex;
    },
    resolveSilently: function(resolutionContext, redrawTaskFn) {
        var me = this,
            optionIndex = me.getStoredResolutionForContext(resolutionContext);
        resolutionContext.resolutions[optionIndex].resolve();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionOk: function(form, userChoice, eOpts, resolutionContext, redrawTaskFn, wnd, detacher) {
        var me = this;
        Ext.destroy(detacher);
        wnd.close();
        if (userChoice.dontAsk) {
            me.storeResolutionForContext(resolutionContext, userChoice.resolutionOption);
        }
        resolutionContext.resolutions[userChoice.resolutionOption].resolve();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionCancel: function(form, eOpts, resolutionContext, redrawTaskFn, wnd, detacher) {
        var me = this;
        Ext.destroy(detacher);
        wnd.close();
        resolutionContext.cancelAction();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    },
    onUserActionClose: function(wnd, eOpts, resolutionContext, redrawTaskFn, detacher) {
        var me = this;
        Ext.destroy(detacher);
        resolutionContext.cancelAction();
        // Redrawing the conflicting task again after user has decided what to do
        redrawTaskFn();
    }
});

/**
@class Gnt.plugin.ProjectLines
@extends Sch.plugin.Lines

A simple subclass of the {@link Sch.plugin.Lines} which sets project lines on the gantt chart.
Generally, there's no need to instantiate it manually, it can be activated with the {@link Gnt.panel.Gantt#showProjectLines} configuration option.
 */
Ext.define("Gnt.plugin.ProjectLines", {
    extend: 'Sch.plugin.Lines',
    alias: 'plugin.gantt_projectlines',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.data.Store'
    ],
    innerTpl: '<span class="sch-gantt-project-line-text" style="{Style}">{Text}</span>',
    // Some number to use to make sure labels don't overlap if project labels are rendered near each other.
    labelHeight: 25,
    showHeaderElements: true,
    /**
     * @cfg {Gnt.data.taskStore} taskStore The task store to extract projects from
     */
    taskStore: null,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     * - startOf  : 'Start of'
     * - endOf    : 'End of'
     */
    /**
     * @cfg {String} linesFor
     * Specifies what project dates should be used to build lines. Might be:
     *
     * - `start` - to build lines for project start dates
     * - `end` - to build lines for project end dates
     * - `both` - to build lines for both project start and end dates
     */
    linesFor: 'both',
    init: function(ganttPanel) {
        this.taskStore = this.taskStore || ganttPanel.getTaskStore();
        this.bindTaskStore(this.taskStore);
        if (!this.store) {
            this.store = new Ext.data.Store({
                fields: [
                    {
                        name: 'Id'
                    },
                    {
                        name: 'ProjectId'
                    },
                    {
                        name: 'Date',
                        type: 'date'
                    },
                    {
                        name: 'Cls',
                        type: 'string'
                    },
                    {
                        name: 'Text',
                        type: 'string'
                    }
                ]
            });
        }
        this.callParent(arguments);
        this.onTaskStoreLoad();
    },
    bindTaskStore: function(taskStore) {
        var listeners = {
                nodeappend: this.onTaskStoreNodeAppend,
                noderemove: this.onTaskStoreNodeRemove,
                update: this.onUpdate,
                load: this.onTaskStoreLoad,
                scope: this
            };
        if (this.taskStore) {
            this.taskStore.un(listeners);
        }
        if (taskStore) {
            taskStore.on(listeners);
        }
        this.taskStore = taskStore;
    },
    onUpdate: function(store, record, operation, modified) {
        // Can't trust "modified" to be an array :/
        // https://www.sencha.com/forum/showthread.php?314319-TreeStore-update-event-doesn-t-always-provide-an-array.&p=1142195#post1142195
        modified = modified || [];
        if (record && record.isProject && operation === Ext.data.Model.EDIT) {
            var update = Ext.Array.some([
                    record.startDateField,
                    record.endDateField,
                    record.nameField
                ], function(item) {
                    return Ext.Array.indexOf(modified, item) !== -1;
                });
            if (update) {
                var projectId = record.modified && record.modified.Id || record.getId();
                // re-create the project related lines
                this.store.remove(this.getProjectLines(projectId));
                this.store.add(this.retrieveProjectLines(record));
            }
        }
    },
    onTaskStoreNodeAppend: function(parent, node) {
        if (node && node.isProject && !this.taskStore.isSettingRoot) {
            this.store.add(this.retrieveProjectLines(node));
        }
    },
    onTaskStoreNodeRemove: function(parent, node) {
        if (node && node.isProject) {
            this.store.remove(this.getProjectLines(node.getId()));
        }
    },
    onTaskStoreLoad: function() {
        this.refreshAllProjects();
    },
    refreshAllProjects: function() {
        this.store.removeAll(true);
        this.store.add(this.retrieveProjectLines());
    },
    getProjectLines: function(projectId) {
        var result = [];
        this.store.each(function(line) {
            if (line.get('ProjectId') === projectId)  {
                result.push(line);
            }
            
        });
        return result;
    },
    /**
     * @protected
     * @method prepareProjectStartLine Prepares a record that corresponds to a project start date.
     * @param  {Gnt.model.Project} project Project
     * @return {Object} Object representing the record to be added to the store
     */
    prepareProjectStartLine: function(project, index) {
        return {
            Date: project.getStartDate(),
            Text: this.L('startOf') + ' ' + Ext.htmlEncode(project.getName()),
            Cls: 'sch-gantt-project-line sch-gantt-project-line-start sch-gantt-project-line-' + Ext.htmlEncode(project.getId()),
            ProjectId: project.getId(),
            Style: 'margin-top:' + (index * this.labelHeight) + 'px'
        };
    },
    /**
     * @protected
     * @method prepareProjectEndLine Prepares a record that corresponds to a project end date.
     * @param  {Gnt.model.Project} project Project
     * @return {Object} Object representing the record to be added to the store
     */
    prepareProjectEndLine: function(project, index) {
        return {
            Date: project.getEndDate(),
            Text: this.L('endOf') + ' ' + Ext.htmlEncode(project.getName()),
            Cls: 'sch-gantt-project-line sch-gantt-project-line-end sch-gantt-project-line-' + Ext.htmlEncode(project.getId()),
            ProjectId: project.getId(),
            Style: 'margin-top:' + (index * this.labelHeight) + 'px'
        };
    },
    retrieveProjectLines: function(project) {
        var me = this,
            projects = Ext.isArray(project) ? project : project && [
                project
            ] || this.taskStore.getProjects(),
            projectLines = [],
            linesFor = me.linesFor;
        for (var i = 0; i < projects.length; i++) {
            linesFor !== 'end' && projectLines.push(me.prepareProjectStartLine(projects[i], i));
            linesFor !== 'start' && projectLines.push(me.prepareProjectEndLine(projects[i], i));
        }
        return projectLines;
    },
    destroy: function() {
        this.bindTaskStore(null);
        this.store.destroy();
        this.callParent(arguments);
    }
});

/**
 * @class Gnt.plugin.Replicator
 * @extends Ext.grid.selection.Replicator
 *
 * This class provides selection replication feature to gantt panel and should be used instead of Ext.grid.selection.Replicator.
 * In addition to simple columns like {@link Gnt.column.Name}, it will also copy complex values like dependencies and resource
 * assignments. Following columns will be ignored:
 *
 * - {@link Gnt.column.LateEndDate}
 * - {@link Gnt.column.LateStartDate}
 * - {@link Gnt.column.Milestone}
 * - {@link Gnt.column.Sequence}
 * - {@link Gnt.column.Slack}
 * - {@link Gnt.column.WBS}
 *
 */
Ext.define('Gnt.plugin.Replicator', {
    extend: 'Ext.grid.selection.Replicator',
    alias: 'plugin.gantt_selectionreplicator',
    init: function(gantt) {
        this.gantt = gantt;
        this.callParent(arguments);
    },
    /**
     * This is the method which is called when the {@link Ext.grid.selection.SpreadsheetModel} selection model's extender
     * handle is dragged and released. It is passed contextual information about the selection and the extension area.
     * By default, the selection is extended to encompass the selection area, return false to prevent that.
     * @param {Gnt.panel.Gantt} ownerGrid
     * @param {Ext.grid.selection.Selection} sel
     * @param {Object} extension
     */
    replicateSelection: function(ownerGrid, sel, extension) {
        var me = this;
        if (extension.columns || sel.isColumns || me.gantt.isReadOnly()) {
            return;
        }
        var selFirstRowIdx = sel.getFirstRowIndex(),
            selLastRowIdx = sel.getLastRowIndex(),
            selectedRowCount = selLastRowIdx - selFirstRowIdx + 1,
            store = sel.view.dataSource,
            startIdx, endIdx, increment, record,
            columns = me.columns,
            colCount = columns.length,
            column, values, lastTwoRecords, i, j;
        // Single row, just duplicate values into extension
        if (selectedRowCount === 1) {
            values = me.getColumnValuesWithMetaData(store.getAt(selFirstRowIdx));
        } else // Multiple rows, take the numeric values from the closest two rows, calculate an array of differences and propagate it
        {
            values = new Array(colCount);
            if (extension.rows < 0) {
                lastTwoRecords = [
                    store.getAt(selFirstRowIdx + 1),
                    store.getAt(selFirstRowIdx)
                ];
            } else {
                lastTwoRecords = [
                    store.getAt(selLastRowIdx - 1),
                    store.getAt(selLastRowIdx)
                ];
            }
            lastTwoRecords[0] = me.getColumnValuesWithMetaData(lastTwoRecords[0]);
            lastTwoRecords[1] = me.getColumnValuesWithMetaData(lastTwoRecords[1]);
            // The values array will be the differences between all numeric columns in the selection of the closest two records.
            for (j = 0; j < colCount; j++) {
                values[j] = me.calculateDifference(lastTwoRecords[0][j], lastTwoRecords[1][j]);
            }
        }
        // Loop from end to start of extension area
        if (extension.rows < 0) {
            startIdx = extension.end.rowIdx;
            endIdx = extension.start.rowIdx - 1;
            increment = -1;
        } else {
            startIdx = extension.start.rowIdx;
            endIdx = extension.end.rowIdx + 1;
            increment = 1;
        }
        // Replicate single selected row
        if (selectedRowCount === 1) {
            var fromRecord = sel.startCell.record,
                startDateField = fromRecord.startDateField,
                endDateField = fromRecord.endDateField,
                // check if we have both start & end date copied
                valuesContainStartAndEndDate = Ext.Array.findBy(columns, function(col) {
                    return col.dataIndex === startDateField;
                }) && Ext.Array.findBy(columns, function(col) {
                    return col.dataIndex === endDateField;
                }),
                // check if we need propagation based on which fields get changed
                needPropagation = Boolean(Ext.Array.findBy(columns, function(col) {
                    var dataIndex = col.dataIndex;
                    return col.isResourceAssignmentColumn || dataIndex === startDateField || dataIndex === endDateField || dataIndex === fromRecord.calendarIdField || dataIndex === fromRecord.effortField || dataIndex === fromRecord.effortUnitField || dataIndex === fromRecord.constraintTypeField || dataIndex === fromRecord.constraintDateField || dataIndex === fromRecord.durationUnitField || dataIndex === fromRecord.durationField;
                })),
                propagationSources = [];
            // Function that copies data to the target records
            var changerFn = function() {
                    for (i = startIdx; i !== endIdx; i += increment) {
                        record = store.getAt(i);
                        var processedIndexes = {};
                        // skip if the record is not editable
                        if (!record.isReadOnly()) {
                            record.beginEdit();
                            propagationSources.push(record);
                            // if we have both start & end dates we use setStartEndDate*() method instead of calling steStartDate*() and setEndDate*()
                            if (valuesContainStartAndEndDate && record.isEditable(startDateField) && record.isEditable(endDateField)) {
                                record.setStartEndDateAndPinWithoutPropagation(fromRecord.getStartDate(), fromRecord.getEndDate());
                                // remember that we have processed start and end date fields
                                processedIndexes[startDateField] = true;
                                processedIndexes[endDateField] = true;
                            }
                            for (j = 0; j < colCount; j++) {
                                var colData = values[j],
                                    value = colData.value,
                                    column = columns[j];
                                // if the field is editable and is not processed yet
                                if (me.isEditable(column, record) && !processedIndexes[colData.dataIndex]) {
                                    if (colData.dataIndex === startDateField) {
                                        value = fromRecord.getStartDate();
                                    } else if (colData.dataIndex === endDateField) {
                                        value = fromRecord.getEndDate();
                                    }
                                    me.copyDataTo(colData, value, column, record);
                                }
                            }
                            record.endEdit();
                        }
                    }
                    return propagationSources;
                };
            // if we need to propagate changes wrap changerFn with propagateChanges() call
            if (needPropagation) {
                fromRecord.propagateChanges(changerFn);
            } else {
                changerFn();
            }
        } else // Add differences from closest two rows
        {
            var prevValues;
            for (i = startIdx; i !== endIdx; i += increment) {
                record = store.getAt(i);
                if (!record.isReadOnly()) {
                    prevValues = me.getColumnValuesWithMetaData(store.getAt(i - increment));
                    for (j = 0; j < colCount; j++) {
                        me.sumUpDifference(columns[j], record, prevValues[j], values[j]);
                    }
                }
            }
        }
    },
    isEditable: function(column, record) {
        if (column.dataIndex && !record.isEditable(column.dataIndex)) {
            return false;
        } else {
            return true;
        }
    },
    //called on multiple row selection - ignores unit related fields
    calculateDifference: function(first, second) {
        //we clone the meta of the second row
        var x = first.value,
            y = second.value,
            result = Ext.clone(second);
        if (!isNaN(x) && !isNaN(y)) {
            switch (second.dataIndex) {
                case second.record.durationField:
                    //TODO to be implemented if unit first and second is compatible
                    break;
                case second.record.effortField:
                    //TODO to be implemented if unit first and second is compatible
                    break;
                default:
                    result.value = Number(y) - Number(x);
            }
            return result;
        }
    },
    sumUpDifference: function(column, record, prevMeta, meta) {
        var prevValue = prevMeta.value,
            value = meta && meta.value,
            newValue;
        if (this.isEditable(column, record)) {
            if (!isNaN(prevValue) && !Ext.isEmpty(prevValue)) {
                switch (meta.dataIndex) {
                    case record.durationField:
                        //TODO to be implemented if unit prevmeta and meta is compatible
                        break;
                    case record.effortField:
                        //TODO to be implemented if unit prevmeta and meta is compatible
                        break;
                    default:
                        if (prevValue instanceof Date) {
                            newValue = Sch.util.Date.add(prevValue, 'ms', value);
                        } else {
                            newValue = Ext.coerce(Number(prevValue) + value, prevValue);
                        };
                        this.copyDataTo(meta, newValue, column, record);
                }
            }
        }
    },
    copyDataTo: function(meta, value, targetColumn, targetRecord) {
        var sourceTask = meta.record;
        if (targetColumn.isResourceAssignmentColumn) {
            targetRecord.assignAndUnassignAssignmentsWithoutPropagation(targetRecord.getResources(), value);
            return;
        }
        // Special treatment of fields causing propagation
        switch (meta.dataIndex) {
            case sourceTask.startDateField:
                targetRecord.setStartDateAndPinWithoutPropagation(value);
                break;
            case sourceTask.endDateField:
                targetRecord.setEndDateAndPinWithoutPropagation(value, false);
                break;
            case sourceTask.durationField:
                targetRecord.setDurationWithoutPropagation(value, sourceTask.getDurationUnit());
                break;
            case sourceTask.effortField:
                targetRecord.setEffortWithoutPropagation(value, sourceTask.getEffortUnit());
                break;
            case sourceTask.calendarIdField:
                targetRecord.setCalendarIdWithoutPropagation(value);
                break;
            case sourceTask.constraintTypeField:
                targetRecord.setConstraintTypeWithoutPropagation(value);
                break;
            case sourceTask.constraintDateField:
                targetRecord.setConstraintDateWithoutPropagation(value);
                break;
            default:
                if (targetColumn.putRawData) {
                    targetColumn.putRawData(Ext.clone(value), targetRecord);
                } else if (targetColumn.dataIndex) {
                    targetRecord.set(meta.dataIndex, value);
                };
        }
    },
    getColumnValuesWithMetaData: function(record) {
        return Ext.Array.map(this.columns, function(column) {
            var obj = {
                    dataIndex: column.dataIndex,
                    record: record
                };
            if (column.getRawData) {
                obj.value = column.getRawData(record);
            } else if (column.dataIndex) {
                obj.value = record.get(column.dataIndex);
            }
            return obj;
        });
    }
});

/**
 * Template class for rendering the task tooltip.
 */
Ext.define("Gnt.template.TaskTooltip", {
    extend: 'Ext.XTemplate',
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.util.Format'
    ],
    dateFormat: null,
    maxItemsInTooltip: 2,
    overflowTextTpl: null,
    adjustMilestones: true,
    /**
     * @cfg {String} markup
     * The tpl markup that will be passed to the Ext.XTemplate.
     * Default `_startText_`, `_endText_`, `_percentText` and `_format_` will be localised in the constructor.
     */
    markup: [
        '<tpl if="records">',
        '<tpl for="records">',
        '<tpl if="xindex &lt;= _maxItemsInTooltip_">',
        '_bodyTpl_',
        '</tpl>',
        '</tpl>',
        '<tpl if="records.length &gt; _maxItemsInTooltip_">',
        '<div class="sch-task-tip-extra">',
        '{[this.getOverflowText(values)]}',
        '</div>',
        '</tpl>',
        '<tpl else>',
        '_bodyTpl_',
        '</tpl>'
    ].join(''),
    bodyMarkup: [
        '<h2 class="sch-task-tip-header">{Name:htmlEncode}</h2>',
        '<table class="sch-task-tip">',
        '<tr><td>_startText_:</td> <td align="right">{[this.getStartDateString(values)]}</td></tr>',
        '<tr><td>_endText_:</td> <td align="right">{[this.getEndDateString(values)]}</td></tr>',
        '<tr><td>_percentText_:</td><td align="right">{[this.getPercentDoneString(values)]}%</td></tr>',
        '</table>'
    ].join(''),
    /**
     * Creates new template.
     * @param {String} markup The tpl markup that will be passed to the Ext.XTemplate. Default `_startText_`, `_endText_`, `_percentText` and `_format_` will be localised.
     */
    constructor: function(markup) {
        this.markup = markup || this.markup;
        this.markup = this.markup.replace(/_bodyTpl_/g, this.bodyMarkup).replace(/_maxItemsInTooltip_/g, this.maxItemsInTooltip).replace(/_startText_/g, this.L('startText')).replace(/_endText_/g, this.L('endText')).replace(/_percentText_/g, this.L('percentText'));
        this.dateFormat = this.L('format');
        this.overflowTextTpl = new Ext.XTemplate(this.L('overflowText'));
        this.callParent([
            this.markup
        ]);
    },
    getStartDateString: function(data) {
        var me = this,
            task = data._record,
            store = task.getTaskStore(true),
            date = data._useBaselineData ? task.getBaselineStartDate() : task.getStartDate();
        if (store && store.disableDateAdjustments) {
            return Ext.util.Format.date(date, me.dateFormat);
        }
        return task.getDisplayStartDate(me.dateFormat, me.adjustMilestones, date, false, data._useBaselineData);
    },
    getEndDateString: function(data) {
        var me = this,
            task = data._record,
            store = task.getTaskStore(true),
            date = data._useBaselineData ? task.getBaselineEndDate() : task.getEndDate();
        if (store && store.disableDateAdjustments) {
            return Ext.util.Format.date(date, me.dateFormat);
        }
        return task.getDisplayEndDate(me.dateFormat, me.adjustMilestones, date, false, data._useBaselineData);
    },
    getPercentDoneString: function(data) {
        var task = data._record;
        var value = data._useBaselineData ? task.getBaselinePercentDone() : task.getPercentDone();
        return Math.round(value);
    },
    getOverflowText: function(values) {
        if (values.records.length > this.maxItemsInTooltip) {
            return this.overflowTextTpl.apply({
                nbrOverflowing: values.records.length - this.maxItemsInTooltip
            });
        }
    }
});

/**
 * @class Gnt.panel.Gantt
 * @extends Sch.panel.TimelineTreePanel
 *
 * A gantt panel, which allows you to visualize and manage tasks and their dependencies.
 *
 * Please refer to the [getting started guide](#!/guide/gantt_getting_started) for a detailed introduction.
 *
 * {@img gantt/images/gantt-panel.png 2x}
 */
Ext.define("Gnt.panel.Gantt", {
    extend: "Sch.panel.TimelineTreePanel",
    alias: [
        'widget.ganttpanel'
    ],
    alternateClassName: [
        'Sch.gantt.GanttPanel'
    ],
    mixins: [
        'Gnt.view.dependency.Mixin'
    ],
    requires: [
        'Ext.layout.container.Border',
        'Ext.tree.plugin.TreeViewDragDrop',
        'Ext.util.CSS',
        'Sch.plugin.NonWorkingTime',
        'Gnt.patches.CellEditor',
        'Gnt.patches.Rows',
        'Gnt.patches.SpreadsheetModel',
        'Gnt.patches.SpreadsheetModel_2',
        'Gnt.patches.SpreadsheetModel_3',
        'Gnt.patches.SpreadsheetModel_4',
        'Gnt.patches.SpreadsheetModel_5',
        'Gnt.patches.TablePanel',
        'Gnt.patches.TreeView',
        'Gnt.patches.TreeViewDragDrop',
        'Gnt.patches.SelectionExtender2',
        'Gnt.patches.SelectionExtender3',
        'Gnt.patches.LockingView',
        'Gnt.data.ResourceStore',
        'Gnt.data.AssignmentStore',
        'Gnt.data.Calendar',
        'Gnt.data.TaskStore',
        'Gnt.data.DependencyStore',
        'Gnt.view.Gantt',
        'Gnt.plugin.ConstraintResolutionGui',
        'Gnt.plugin.ProjectLines',
        'Gnt.plugin.Replicator',
        'Gnt.template.TaskTooltip'
    ],
    uses: [
        'Sch.plugin.CurrentTimeLine'
    ],
    viewType: 'ganttview',
    layout: 'border',
    rowLines: true,
    syncRowHeight: false,
    rowHeight: 24,
    rowHeightStyleSheetNode: null,
    /**
     * @cfg {Boolean} disableDateAdjustments
     * If `true`, all dates in date fields, editors, columns, tooltips will be shown exactly as they are in data model.
     * {@link Gnt.model.Task#getDisplayStartDate getDisplayStartDate} and {@link Gnt.model.Task#getDisplayEndDate getDisplayEndDate} will not be invoked.
     */
    disableDateAdjustments: true,
    /**
     * @cfg {Boolean/String/Ext.Template} tooltipTpl
     * Template used to show a tooltip over a scheduled item, true by default (Gnt.template.TaskTooltip). Feel free to extend Gnt.template.TaskTooltip and set the instance directly on the property.
     * The tooltip will be populated with the data in record corresponding to the hovered element. See also {@link #tipCfg} and to provide your own custom data object for this
     * template, please see {@link Sch.mixin.TimelineView#getDataForTooltipTpl}.
     */
    tooltipTpl: true,
    // holds instance of row numberer column
    rowNumberColumn: null,
    /**
     * @cfg {String/Object} topLabelField
     * A configuration used to show/edit the field to the top of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    topLabelField: null,
    /**
     * @cfg {String/Object} leftLabelField
     * A configuration used to show/edit the field to the left of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    leftLabelField: null,
    /**
     * @cfg {String/Object} bottomLabelField
     * A configuration used to show/edit the field to the bottom of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    bottomLabelField: null,
    /**
     * @cfg {String/Object} rightLabelField
     * A configuration used to show/edit the field to the right of the task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `editor` : Ext.form.Field - The field used to edit the value inline
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    rightLabelField: null,
    /**
     * @cfg {String/Object} rollupLabelField
     * A configuration used to show the field to the top of the rollup task.
     * It can be either string indicating the field name in the data model or a custom object where you can set the
     * following possible properties:
     *
     * - `dataIndex` : String - The field name in the data model
     * - `renderer` : Function - A renderer method used to render the label. The renderer is called with the 'value' and the record as parameters.
     * - `scope` : Object - The scope in which the renderer is called
     */
    rollupLabelField: null,
    /**
     * @cfg {Number} rollupIntersectThreshold
     * If two rollup task elements intersect within this value - they are considered to be overlapping.
     * @private
     */
    rollupIntersectThreshold: 5,
    /**
     * @cfg {Boolean} weekendsAreWorkdays
     * Set to `true` to treat *all* days as working, effectively removing the concept of non-working time from gantt. Defaults to `false`.
     * This option just will be translated to the {@link Gnt.data.Calendar#weekendsAreWorkdays corresponding option} of the calendar
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Boolean} skipWeekendsDuringDragDrop
     * True to skip the weekends/holidays during drag&drop operations (moving/resizing) and also during cascading. Default value is `true`.
     *
     * Note, that holidays will still be excluded from the duration of the tasks. If you need to completely disable holiday skipping you
     * can do that on the gantt level with the {@link #weekendsAreWorkdays} option, or on the task level with the `SchedulingMode` field.
     *
     *
     * This option just will be translated to the {@link Gnt.data.TaskStore#skipWeekendsDuringDragDrop corresponding option} of the task store
     */
    skipWeekendsDuringDragDrop: true,
    /**
     * @cfg {Boolean} enableTaskDragDrop
     * True to allow drag drop of tasks (defaults to `true`). To customize the behavior of drag and drop, you can use {@link #dragDropConfig} option
     */
    enableTaskDragDrop: true,
    /**
     * @cfg {Boolean} enableProgressBarResize
     * True to allow resizing of the progress bar indicator inside tasks (defaults to `false`)
     */
    enableProgressBarResize: false,
    /**
     * @cfg {Boolean} toggleParentTasksOnClick
     * True to toggle the collapsed/expanded state when clicking a parent task bar (defaults to `true`)
     */
    toggleParentTasksOnClick: true,
    /**
     * @cfg {Boolean} addRowOnTab
     * True to automatically insert a new row when tabbing out of the last cell of the last row. Defaults to true.
     */
    addRowOnTab: true,
    /**
     * @cfg {Boolean} recalculateParents
     * True to update parent start/end dates after a task has been updated (defaults to `true`). This option just will be translated
     * to the {@link Gnt.data.TaskStore#recalculateParents corresponding option} of the task store
     */
    recalculateParents: true,
    /**
     * @cfg {Boolean} cascadeChanges
     * A boolean flag indicating whether a change in a task should be propagated to its successors.
     * If specified, this option will be passed to the {@link Gnt.data.TaskStore#cascadeChanges corresponding option} of the task store.
     */
    cascadeChanges: null,
    /**
     * @cfg {Boolean} enableBaseline
     * True to enable showing a base lines for tasks. Baseline information should be provided as the `BaselineStartDate`, `BaselineEndDate` and `BaselinePercentDone` fields.
     * Default value is `false`.
     */
    enableBaseline: false,
    /**
     * @cfg {Boolean} baselineVisible
     * True to show the baseline in the initial rendering. You can show and hide the baseline programmatically via {@link #showBaseline} and {@link #hideBaseline}.
     * Default value is `false`.
     */
    baselineVisible: false,
    enableAnimations: false,
    animate: false,
    /**
     * If the {@link #highlightWeekends} option is set to true, you can access the created zones plugin through this property.
     * @property {Sch.plugin.Zones} workingTimePlugin
     */
    workingTimePlugin: null,
    todayLinePlugin: null,
    highlightWeekends: true,
    /**
     * @cfg {Boolean} allowParentTaskMove True to allow moving parent tasks. Please note, that when moving a parent task, the
     * {@link Gnt.data.TaskStore#cascadeDelay cascadeDelay} option will not be used and cascading will happen synchronously (if enabled).
     *
     * Also, its possible to move the parent task as a group (along with its child tasks) or as individual task. This can be controlled with
     * {@link Gnt.data.TaskStore#moveParentAsGroup} option.
     */
    allowParentTaskMove: true,
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `false` to exclude parent tasks from the list of possible predecessors/successors.
     */
    allowParentTaskDependencies: true,
    /**
     * @cfg {Boolean} enableDragCreation
     * True to allow dragging to set start and end dates
     */
    enableDragCreation: true,
    /**
     * @cfg {Function} eventRenderer
     * Provided so that you can override the rendering attributes provided to the various task HTML templates at runtime. This function is called each time a task
     * is rendered into the gantt grid. The function should return an object with properties that will be applied to the relevant task template.
     * By default, the task templates include placeholders for :
     *
     * - `cls` - CSS class which will be added to the task bar element
     * - `ctcls` - CSS class which will be added to the 'root' element containing the task bar and labels
     * - `style` - inline style declaration for the task bar element
     * - `progressBarStyle` - an inline CSS style to be applied to the progress bar of this task
     * - `leftLabel` - the content for the left label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#leftLabelField leftLabelField} option.
     *   You still need to provide some value for the `leftLabelField` to activate the label rendering
     * - `rightLabel` - the content for the right label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#rightLabelField rightLabelField} option
     *   You still need to provide a value for the `rightLabelField` to activate the label rendering
     * - `topLabel` - the content for the top label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#topLabelField topLabelField} option
     *   You still need to provide a value for the `topLabelField` to activate the label rendering
     * - `bottomLabel` - the content for the bottom label (usually being extracted from the task, using the {@link Gnt.panel.Gantt#bottomLabelField bottomLabelField} option
     *   You still need to provide some value for the `bottomLabelField` to activate the label rendering
     * - `basecls` - a CSS class to be add to the baseline DOM element, only applicable when the {@link Gnt.panel.Gantt#baselineVisible baselineVisible} option is true and the task contains baseline information
     * - `baseStyle` - an inline CSS rule to be applied to the baseline DOM element, only applicable when the {@link Gnt.panel.Gantt#baselineVisible baselineVisible} option is true and the task contains baseline information
     * - `baseProgressBarStyle` - an inline CSS style to be applied to the baseline progress bar element
     *
     * Here is a sample usage of the config:
     *
     * ```javascript
     * eventRenderer : function (taskRec) {
     *     return {
     *         style : 'background-color:white',        // You can use inline styles too.
     *         cls   : taskRec.get('Priority'),         // Read a property from the task record, used as a CSS class to style the event
     *         foo   : 'some value'                     // Some custom value in your own template
     *     };
     * }
     * ```
     *
     * @param {Gnt.model.Task} taskRecord The task about to be rendered
     * @param {Gnt.data.TaskStore} ds The task store
     * @return {Object} The data which will be applied to the task template, creating the actual HTML
     */
    eventRenderer: null,
    /**
     * @cfg {Object} eventRendererScope The scope (the "this" object)to use for the `eventRenderer` function
     */
    eventRendererScope: null,
    /**
     * @cfg {Ext.XTemplate} eventTemplate The template used to render leaf tasks in the gantt view.
     * See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Task} for the definition.
     */
    eventTemplate: null,
    /**
     * @cfg {Ext.XTemplate} parentEventTemplate The template used to render parent tasks in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.ParentTask} for the definition
     */
    parentEventTemplate: null,
    /**
     * @cfg {Ext.XTemplate} rollupTemplate The template used to rollup tasks to the parent in the gantt view. See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.RollupTask} for the definition
     */
    rollupTemplate: null,
    /**
     * @cfg {Ext.XTemplate} milestoneTemplate The template used to render milestone tasks in the gantt view.
     * See {@link Ext.XTemplate} for more information, see also {@link Gnt.template.Milestone} for the definition.
     */
    milestoneTemplate: null,
    /**
     * @cfg {String} taskBodyTemplate The markup making up the body of leaf tasks in the gantt view. See also {@link Gnt.template.Task#innerTpl} for the definition.
     */
    taskBodyTemplate: null,
    /**
     * @cfg {String} parentTaskBodyTemplate The markup making up the body of parent tasks in the gantt view. See also {@link Gnt.template.ParentTask#innerTpl} for the definition.
     */
    parentTaskBodyTemplate: null,
    /**
     * @cfg {String} milestoneBodyTemplate The markup making up the body of milestone tasks in the gantt view. See also {@link Gnt.template.Milestone#innerTpl} for the definition.
     */
    milestoneBodyTemplate: null,
    /**
     * @cfg {Boolean} autoHeight Always hardcoded to null, the `true` value is not yet supported (by Ext JS).
     */
    autoHeight: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar a {@link Gnt.data.Calendar calendar} instance for this gantt panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.CrudManager} crudManager The CRUD manager instance controling all the gantt related stores
     *
     * ```javascript
     * var taskStore   = new Gnt.data.TaskStore({
     *     ...
     * });
     *
     * var crudManager = new Gnt.data.CrudManager({
     *     autoLoad    : true,
     *     taskStore   : taskStore,
     *     transport   : {
     *         load    : {
     *             url     : 'load.php'
     *         },
     *         sync    : {
     *             url     : 'save.php'
     *         }
     *     }
     * });
     *
     * var gantt       = new Gnt.panel.Gantt({
     *     // CRUD manager instance having references to all the related stores
     *     crudManager : crudManager,
     *
     *     height      : 300,
     *     width       : 500,
     *     renderTo    : Ext.getBody(),
     *     columns     : [
     *         {
     *             xtype : 'namecolumn'
     *         },
     *         {
     *             xtype : 'startdatecolumn'
     *         },
     *         {
     *             xtype : 'enddatecolumn'
     *         }
     *     ]
     * });
     * ```
     */
    crudManager: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks to be rendered into the gantt chart (required).
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore The {@link Gnt.data.DependencyStore store} holding the dependency information (optional).
     * See also {@link Gnt.model.Dependency}
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources that can be assigned to the tasks in the task store(optional).
     * See also {@link Gnt.model.Resource}
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore: null,
    columnLines: false,
    /**
     * @cfg {Function} dndValidatorFn
     *
     * A custom validation function to be called during the drag and drop process
     * and also after the drop operation is made but before it's finalized.
     * If you need to perform an async validation, please take a look at {@link #beforetaskdropfinalize} event instead.
     *
     * @param {Gnt.model.Task} taskRecord The task record being dragged
     * @param {Date} date The new start date
     * @param {Number} duration The duration of the item being dragged, in minutes
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    dndValidatorFn: Ext.emptyFn,
    /**
     * @cfg {Function} createValidatorFn
     * An empty function by default, but provided so that you can perform custom validation when a new task is being scheduled using drag and drop.
     * To indicate the newly scheduled dates of a task are invalid, simply return false from this method.
     *
     * @param {Gnt.model.Task} taskRecord the task
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {Event} e The browser event object
     * @return {Boolean} true if the creation event is valid, else false
     */
    createValidatorFn: Ext.emptyFn,
    /**
     * @cfg {String} eventResizeHandles
     * @hide
     */
    /**
     * @cfg {Number} startTime
     * @hide
     */
    /**
     * @cfg {Number} endTime
     * @hide
     */
    /**
     * @cfg {String} taskResizeHandles A string containing one of the following values
     *
     * - `none` - to disable resizing of tasks
     * - `left` - to enable changing of start date only
     * - `right` - to enable changing of end date only
     * - `both` - to enable changing of both start and end dates
     *
     * Default value is `both`. Resizing is performed with the {@link Gnt.feature.TaskResize} plugin.
     * You can customize it with the {@link #resizeConfig} and {@link #resizeValidatorFn} options
     */
    taskResizeHandles: 'both',
    /**
     * @cfg {Function} resizeValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * a task being resized. Simply return false from your function to indicate that the new duration is invalid.
     *
     * @param {Gnt.model.Task} taskRecord The task being resized
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date
     * @param {Ext.EventObject} e The event object
     *
     * @return {Boolean} true if the resize state is valid, else false to cancel
     */
    resizeValidatorFn: Ext.emptyFn,
    /**
     *  @cfg {Object} resizeConfig A custom config object to pass to the {@link Gnt.feature.TaskResize} feature.
     */
    resizeConfig: null,
    /**
     *  @cfg {Object} progressBarResizeConfig A custom config object to pass to the {@link Gnt.feature.ProgressBarResize} feature.
     */
    progressBarResizeConfig: null,
    /**
     *  @cfg {Object} dragDropConfig A custom config object to pass to the {@link Gnt.feature.taskdd.DragZone} feature.
     */
    dragDropConfig: null,
    /**
     *  @cfg {Object} createConfig A custom config to pass to the {@link Gnt.feature.DragCreator} instance
     */
    createConfig: null,
    /**
     *  @cfg {Boolean/Object} autoFitOnLoad True to change the timeframe of the gantt to fit all the tasks in it after every task store load.
     * Also accepts a config object passed as 'options' to the zoomToFit method
     * See also {@link #zoomToFit}.
     */
    autoFitOnLoad: false,
    /**
     *  @cfg {Boolean} showRollupTasks True to rollup information of tasks to their parent task bar.
     *  Only tasks with the {@link Gnt.model.Task#Rollup Rollup} field set to true will rollup.
     */
    showRollupTasks: false,
    /**
     * @cfg {Boolean} enableConstraintsResolutionGui `true` to enable the plugin, providing the constraint resolution popup window.
     * Enabled by default.
     */
    enableConstraintsResolutionGui: true,
    /**
     * @cfg {Boolean}
     * `True` to mark project start/end dates with vertical lines using {@link Gnt.plugin.ProjectLines} plugin.
     * Use {@link #projectLinesConfig} to configure the plugin.
     */
    showProjectLines: true,
    /**
     * @cfg {Object} projectLinesConfig
     * Config to use for {@link Gnt.plugin.ProjectLines} plugin.
     */
    projectLinesConfig: null,
    /**
     * @cfg {Object} constraintResolutionGuiConfig Config to use for {@link Gnt.plugin.ConstraintResolutionGui} plugin.
     */
    constraintResolutionGuiConfig: null,
    /**
     * @cfg {Boolean}
     * `True` to scroll tasks horizontally into view when clicking a task row.
     */
    scrollTaskIntoViewOnClick: false,
    /**
     * @cfg {Boolean/Object}
     * `True` to scroll tasks to be reordered in the left table section of the Gantt chart. Adds a Ext.tree.plugin.TreeViewDragDrop plugin
     * to the Gantt chart. You can configure this plugin by passing an Object instead of a boolean.
     *
     */
    enableTaskReordering: true,
    refreshLockedTreeOnDependencyUpdate: false,
    _lockedDependencyListeners: null,
    // when gantt is configured to keep selection this property will hold return value of selectionModel.getSelected()
    _lastSpreadsheetSelection: null,
    earlyColumns: null,
    lateColumns: null,
    columnListMenuItem: null,
    earlyDatesListeners: null,
    lateDatesListeners: null,
    fullRefreshColumnsListeners: null,
    refreshTimeout: 100,
    batchUpdate: false,
    // Default to border less task bars in our Triton, Crisp, Aria, Graphite, Material themes
    eventBorderWidth: (Ext.theme && Ext.theme.name.match('Triton|Crisp|Aria|Graphite|Material') ? 0 : 1),
    //A reference to the editing plugin, if it exists
    ganttEditingPlugin: null,
    /**
     * @cfg {Number} simpleCascadeThreshold If number of tasks affected during cascading (see {@link Gnt.data.TaskStore} for details on __cascading__ term)
     * is below this number, the panel does a per-row update instead of a full refresh.
     */
    simpleCascadeThreshold: 30,
    forceDefineTimeSpanByStore: true,
    crudManagerDetacher: null,
    taskStoreDetacher: null,
    assignmentStoreDetacher: null,
    resourceStoreDetacher: null,
    // Prevent excessive view refreshes, but can lead to an error in buffered rendering
    // https://app.assembla.com/spaces/bryntum/tickets/7479
    suspendRefreshOnTaskReorder: true,
    /**
     * This method shows or hides the visual presentation of task's rollups in the view.
     * @param {Boolean} show A boolean value indicating whether the visual presentation of task's rollups should be visible or not.
     */
    setShowRollupTasks: function(show) {
        this.showRollupTasks = show;
        this.getSchedulingView().setShowRollupTasks(show);
    },
    onCalendarSet: function(store, calendar) {
        if (this.needToTranslateOption('weekendsAreWorkdays')) {
            // may trigger a renormalization of all tasks - need all stores to be defined
            calendar.setWeekendsAreWorkDays(this.weekendsAreWorkdays);
        }
        if (this.workingTimePlugin) {
            this.workingTimePlugin.bindCalendar(calendar);
            this.timeAxisViewModel.setCalendar(calendar);
        }
    },
    bindTaskStore: function(taskStore) {
        var me = this;
        // if we have previously bound listeners - detach them
        Ext.destroy(me.taskStoreRelayers);
        taskStore.calendar.un('calendarchange', me.onCalendarChange, me);
        me.taskStoreRelayers = me.relayEvents(taskStore, [
            'resourcestorechange',
            'assignmentstorechange',
            'dependencystorechange'
        ]);
        // if we have previously bound listeners - detach them
        Ext.destroy(me.taskStoreDetacher);
        me.taskStoreDetacher = me.mon(taskStore, {
            'calendarset': me.onCalendarSet,
            'beforeindentationchange': me.onBeforeBatchStoreUpdate,
            'indentationchange': me.onBatchStoreUpdate,
            'indentationcancel': me.onCancelBatchStoreUpdate,
            'beforebatchremove': me.onBeforeBatchStoreUpdate,
            'batchremove': me.onBatchStoreUpdate,
            'beforecascade': me.onBeforeCascade,
            'cascade': me.onAfterCascade,
            scope: me,
            destroyable: true
        });
        // Make sure header is refreshed if project calendar is changed (non-working time added, removed or updated)
        taskStore.calendar.on('calendarchange', me.onCalendarChange, me);
    },
    onCalendarChange: function() {
        var timeAxisColumn = this.getHorizontalTimeAxisColumn();
        timeAxisColumn && timeAxisColumn.refresh();
    },
    setTaskStore: function(taskStore, initial) {
        var me = this,
            oldStore = me.getTaskStore();
        if (taskStore !== oldStore || initial) {
            taskStore = Ext.StoreMgr.lookup(taskStore);
            if (!taskStore) {
                Ext.Error.raise("You have provided an incorrect taskStore identifier");
            }
            if (!(taskStore instanceof Gnt.data.TaskStore)) {
                Ext.Error.raise("A `taskStore` should be an instance of `Gnt.data.TaskStore` (or of a subclass)");
            }
            me.taskStore = taskStore;
            taskStore.disableDateAdjustments = me.disableDateAdjustments;
            if (!initial) {
                me.reconfigure(taskStore);
                me.fireEvent('taskstorechange', me, taskStore, oldStore);
            } else {
                me.store = taskStore;
            }
            // bind task store listeners
            me.bindTaskStore(taskStore);
        }
    },
    setDependencyStore: function(dependencyStore, initial) {
        if (this.dependencyStore !== dependencyStore || initial) {
            this.dependencyStore = Ext.StoreMgr.lookup(dependencyStore);
            if (!(this.dependencyStore instanceof Gnt.data.DependencyStore)) {
                Ext.Error.raise("The Gantt dependency store should be a Gnt.data.DependencyStore, or a subclass thereof.");
            }
            this.dependencyStore.allowParentTaskDependencies = this.allowParentTaskDependencies;
            this.getTaskStore().setDependencyStore(this.dependencyStore);
        }
    },
    bindResourceStore: function(resourceStore) {
        var me = this;
        me.resourceStoreDetacher && me.resourceStoreDetacher.destroy();
        if (resourceStore) {
            me.resourceStoreDetacher = me.mon(resourceStore, {
                'update': me.onResourceStoreUpdate,
                'add': me.onResourceStoreDataChanged,
                'remove': me.onResourceStoreDataChanged,
                'write': me.onResourceStoreDataChanged,
                'refresh': me.onResourceStoreDataChanged,
                'sort': me.onResourceStoreDataChanged,
                'filter': me.onResourceStoreDataChanged,
                'clear': me.onResourceStoreDataChanged,
                destroyable: true,
                scope: me
            });
        }
    },
    setResourceStore: function(resourceStore, initial) {
        var prevStore = this.resourceStore;
        if (prevStore !== resourceStore || initial) {
            resourceStore = Ext.StoreMgr.lookup(resourceStore);
            if (!(resourceStore instanceof Gnt.data.ResourceStore)) {
                Ext.Error.raise("A `ResourceStore` should be an instance of `Gnt.data.ResourceStore` (or of a subclass)");
            }
            // destroy previous resource store if it's meant to be
            prevStore && prevStore.autoDestroy && prevStore.destroy();
            this.getTaskStore().setResourceStore(resourceStore);
            this.resourceStore = resourceStore;
            this.bindResourceStore(resourceStore);
            if (resourceStore && !initial) {
                this.refreshViews();
            }
        }
    },
    bindAssignmentStore: function(assignmentStore) {
        var me = this;
        me.assignmentStoreDetacher && me.assignmentStoreDetacher.destroy();
        if (assignmentStore) {
            me.assignmentStoreDetacher = me.mon(assignmentStore, {
                'beforetaskassignmentschange': me.onBeforeSingleTaskAssignmentChange,
                'taskassignmentschanged': me.onSingleTaskAssignmentChange,
                'update': me.onAssignmentStoreUpdate,
                'add': me.onAssignmentStoreDataChanged,
                'remove': me.onAssignmentStoreDataChanged,
                'write': me.onAssignmentStoreDataChanged,
                'refresh': me.onAssignmentStoreDataChanged,
                'filter': me.onAssignmentStoreDataChanged,
                'sort': me.onAssignmentStoreDataChanged,
                'clear': me.onAssignmentStoreDataChanged,
                // private event, required to update the UI after a removed assignment
                'commit': me.onAssignmentStoreDataChanged,
                destroyable: true,
                scope: me
            });
        }
    },
    setAssignmentStore: function(assignmentStore, initial) {
        var prevStore = this.assignmentStore;
        if (prevStore !== assignmentStore || initial) {
            assignmentStore = Ext.StoreMgr.lookup(assignmentStore);
            if (!(assignmentStore instanceof Gnt.data.AssignmentStore)) {
                Ext.Error.raise("An `assignmentStore` should be an instance of `Gnt.data.AssignmentStore` (or of a subclass)");
            }
            prevStore && prevStore.autoDestroy && prevStore.destroy();
            this.getTaskStore().setAssignmentStore(assignmentStore);
            this.assignmentStore = assignmentStore;
            this.bindAssignmentStore(assignmentStore);
            if (assignmentStore && !initial) {
                this.refreshViews();
            }
        }
    },
    bindCrudManager: function(crudManager) {
        this.crudManagerDetacher && this.crudManagerDetacher.destroy();
        this.crudManagerDetacher = this.mon(crudManager, {
            'beforeresponseapply': this.onBeforeCrudResponseApply,
            'requestdone': this.onCrudRequestDone,
            priority: -900,
            destroyable: true,
            scope: this
        });
    },
    initStores: function() {
        // if we have CrudManager instance assigned we can grab stores from it
        if (this.crudManager) {
            if (!(this.crudManager instanceof Gnt.data.CrudManager)) {
                this.crudManager = Ext.create(this.crudManager.xclass || 'Gnt.data.CrudManager', Ext.clone(this.crudManager));
            }
            if (!this.taskStore)  {
                this.taskStore = this.crudManager.getTaskStore(this);
            }
            
            if (!this.dependencyStore)  {
                this.dependencyStore = this.crudManager.getDependencyStore(this);
            }
            
            if (!this.resourceStore)  {
                this.resourceStore = this.crudManager.getResourceStore(this);
            }
            
            if (!this.assignmentStore)  {
                this.assignmentStore = this.crudManager.getAssignmentStore(this);
            }
            
            this.bindCrudManager(this.crudManager);
        }
        this.setTaskStore(this.taskStore, true);
        var taskStore = this.getTaskStore();
        this.setDependencyStore(this.dependencyStore || taskStore.getDependencyStore(), true);
        this.setResourceStore(this.resourceStore || taskStore.getResourceStore(), true);
        this.setAssignmentStore(this.assignmentStore || taskStore.getAssignmentStore(), true);
        if (this.needToTranslateOption('weekendsAreWorkdays')) {
            // may trigger a renormalization of all tasks - need all stores to be defined
            taskStore.getCalendar().setWeekendsAreWorkDays(this.weekendsAreWorkdays);
        }
    },
    // For buffered rendering, we need to avoid each indent/outdent operation causing a full view refresh + layouts + re-filtering
    // Tested in /#view/213_indent.t.js
    onBeforeBatchStoreUpdate: function() {
        var lockedView = this.lockedGrid.getView(),
            schedulingView = this.getSchedulingView();
        this.batchUpdate = true;
        this.taskStore.filterUpdateSuspended = true;
        // HACK prevent view from updating UI while indent is ongoing
        // this.lockedGrid.view.viewReady = this.normalGrid.view.viewReady = false;
        this._scrollStateBeforeBatchUpdate = {
            left: lockedView.getScrollX(),
            top: schedulingView.getVerticalScroll()
        };
        this.taskStore.suspendEvent('refresh', 'add', 'insert', 'remove');
        var position = this.getSchedulingView().getNavigationModel().getPosition();
        if (position) {
            // During indent (not outdent) operation store will fire few update events (for single record
            // 3 events will be fired) that will trigger view rows to be updated. Renderer will call getPosition() on
            // navigation model and that call will null position. So following refresh couldn't save navigation position
            // because it was already nulled. That doesn't happen on outdent, because no update events thrown on store
            // Idea behind this fix is to restore navigation position
            // 213_indent
            this._lastNavigationPosition = position.clone();
        }
        if (this.bufferedRenderer) {
            this.suspendLayouts();
        }
    },
    onBatchStoreUpdate: function() {
        var lockedView = this.lockedGrid.getView(),
            taskStore = this.getTaskStore(),
            navModel, lastNavigationPosition;
        taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
        // HACK prevent view from updating UI while indent is ongoing
        lockedView.viewReady = this.normalGrid.view.viewReady = true;
        taskStore.filterUpdateSuspended = false;
        lastNavigationPosition = this._lastNavigationPosition;
        if (lastNavigationPosition) {
            navModel = this.getSchedulingView().getNavigationModel();
            // HACK: This is the hack to solve #4699, but this all those hacks around I see no other method
            // https://app.assembla.com/spaces/bryntum/tickets/4699
            if (lastNavigationPosition.record && !taskStore.getNodeById(lastNavigationPosition.record.getId())) {
                lastNavigationPosition.record = taskStore.getAt(lastNavigationPosition.recordIndex);
            }
            navModel.setPosition(lastNavigationPosition);
            delete this._lastNavigationPosition;
        }
        this.refreshViews();
        // Ext JS resets grid scroll position when removing a task, restore it manually
        if (this._scrollStateBeforeBatchUpdate) {
            lockedView.setScrollX(this._scrollStateBeforeBatchUpdate.left);
            lockedView.setScrollY(this._scrollStateBeforeBatchUpdate.top);
            this._scrollStateBeforeBatchUpdate = null;
        }
        if (this.bufferedRenderer) {
            this.resumeLayouts(true);
            taskStore.onNeedToUpdateFilter();
        }
        this.batchUpdate = false;
    },
    onCancelBatchStoreUpdate: function() {
        var taskStore = this.getTaskStore(),
            navModel, lastNavigationPosition;
        taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
        // HACK prevent view from updating UI while indent is ongoing
        this.lockedGrid.view.viewReady = this.normalGrid.view.viewReady = true;
        taskStore.filterUpdateSuspended = false;
        lastNavigationPosition = this._lastNavigationPosition;
        if (lastNavigationPosition) {
            navModel = this.getSchedulingView().getNavigationModel();
            // HACK: This is the hack to solve #4699, but this all those hacks around I see no other method
            // https://app.assembla.com/spaces/bryntum/tickets/4699
            if (lastNavigationPosition.record && !taskStore.getNodeById(lastNavigationPosition.record.getId())) {
                lastNavigationPosition.record = taskStore.getAt(lastNavigationPosition.recordIndex);
            }
            navModel.setPosition(lastNavigationPosition);
            delete this._lastNavigationPosition;
        }
        if (this.bufferedRenderer) {
            this.resumeLayouts(true);
        }
        this.batchUpdate = false;
    },
    initComponent: function() {
        this.autoHeight = false;
        this.initStores();
        if (this.cascadeChanges != null) {
            this.setCascadeChanges(this.cascadeChanges);
        }
        if (this.needToTranslateOption('recalculateParents')) {
            this.setRecalculateParents(this.recalculateParents);
        }
        if (this.needToTranslateOption('skipWeekendsDuringDragDrop')) {
            this.setSkipWeekendsDuringDragDrop(this.skipWeekendsDuringDragDrop);
        }
        this.dependencyViewConfig = this.dependencyViewConfig || {};
        // Copy some settings to dependencyViewConfig instance
        Ext.applyIf(this.dependencyViewConfig, {
            enableDependencyDragDrop: this.enableDependencyDragDrop
        });
        this.normalViewConfig = this.normalViewConfig || {};
        // Copy some properties to the view instance
        Ext.applyIf(this.normalViewConfig, {
            taskStore: this.taskStore,
            dependencyStore: this.dependencyStore,
            snapRelativeToEventStartDate: this.snapRelativeToEventStartDate,
            progressBarResizeConfig: this.progressBarResizeConfig,
            enableDependencyDragDrop: this.enableDependencyDragDrop,
            enableTaskDragDrop: this.enableTaskDragDrop,
            enableProgressBarResize: this.enableProgressBarResize,
            enableDragCreation: this.enableDragCreation,
            allowParentTaskMove: this.allowParentTaskMove,
            allowParentTaskDependencies: this.allowParentTaskDependencies,
            toggleParentTasksOnClick: this.toggleParentTasksOnClick,
            taskResizeHandles: this.taskResizeHandles,
            enableBaseline: this.baselineVisible || this.enableBaseline,
            leftLabelField: this.leftLabelField,
            rightLabelField: this.rightLabelField,
            topLabelField: this.topLabelField,
            bottomLabelField: this.bottomLabelField,
            rollupLabelField: this.rollupLabelField,
            rollupIntersectThreshold: this.rollupIntersectThreshold,
            eventTemplate: this.eventTemplate,
            parentEventTemplate: this.parentEventTemplate,
            milestoneTemplate: this.milestoneTemplate,
            rollupTemplate: this.rollupTemplate,
            taskBodyTemplate: this.taskBodyTemplate,
            parentTaskBodyTemplate: this.parentTaskBodyTemplate,
            milestoneBodyTemplate: this.milestoneBodyTemplate,
            resizeConfig: this.resizeConfig,
            dragDropConfig: this.dragDropConfig,
            showRollupTasks: this.showRollupTasks
        });
        if (this.topLabelField || this.bottomLabelField) {
            this.addCls('sch-gantt-topbottom-labels ' + (this.topLabelField ? 'sch-gantt-top-label' : ''));
            this.rowHeight = Math.max(60, this.rowHeight);
        }
        this.configureFunctionality();
        if (this.tooltipTpl === true) {
            this.tooltipTpl = new Gnt.template.TaskTooltip();
        }
        this.callParent(arguments);
        var sm = this.getSelectionModel();
        var isSpreadsheetModel = Ext.grid.selection && Ext.grid.selection.SpreadsheetModel && sm instanceof Ext.grid.selection.SpreadsheetModel;
        // https://www.assembla.com/spaces/bryntum/tickets/2609
        // Selection should not be lost after record is removed
        if (isSpreadsheetModel) {
            this.mon(this.taskStore, {
                remove: this.tryRestoreSelectionAfterRemove,
                // catch event before selection model can react to that
                // for ext 6.0.1 it's enough priority to get correct selection in listener
                priority: 1,
                scope: this
            });
            // In ext 6.0.0 remove event has listeners with priority 1000 that will refresh view
            // and loose selection before we can restore it
            this.mon(this.taskStore, {
                remove: this.storeSelectionBeforeRemove,
                // this priority required to catch remove before view is refreshed
                // 200 is default priority in 6.2.0, look for "r.priority = 2000;"
                priority: 2001,
                scope: this
            });
            // batch remove will trigger refresh and clear cell selection, we need to save it
            this.mon(this.taskStore, {
                beforebatchremove: this.storeSelectionBeforeRemove,
                batchremove: this.tryRestoreSelectionAfterBatchRemove,
                scope: this
            });
        }
        // https://app.assembla.com/spaces/bryntum/tickets/3915
        if (isSpreadsheetModel) {
            // HACK - move the drag handle into locked grid since it should not live in the 'top' grid
            // because it will be visible in normal view
            var lockedGrid = this.lockedGrid;
            var old = sm.applyExtensible;
            sm.applyExtensible = function(extensible) {
                var selExt = old.apply(this, arguments);
                lockedGrid.view.el.appendChild(selExt.handle);
                this.applyExtensible = old;
                return selExt;
            };
        }
        if (this.autoFitOnLoad) {
            var fitOptions = typeof this.autoFitOnLoad === 'object' ? this.autoFitOnLoad : {};
            // in order to make zoomToFit work ok, normal view should have some width
            this.normalGrid.on('afterlayout', function() {
                // if store already loaded
                if (this.store.getCount()) {
                    this.zoomToFit(null, fitOptions);
                }
                // append listener now to make sure we do not fit twice during initial rendering
                this.mon(this.store, 'load', function() {
                    this.zoomToFit(null, fitOptions);
                }, this);
            }, this, {
                single: true
            });
        }
        this.bodyCls = (this.bodyCls || '') + " sch-ganttpanel-container-body";
        var ganttView = this.getSchedulingView();
        this.relayEvents(ganttView, [
            /**
             * @event taskclick
             * Fires when a task is clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskclick',
            /**
             * @event taskdblclick
             * Fires when a task is double clicked
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskdblclick',
            /**
             * @event taskcontextmenu
             * Fires when contextmenu is activated on a task
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Ext.EventObject} e The event object
             */
            'taskcontextmenu',
            // Resizing events start --------------------------
            /**
             * @event beforetaskresize
             * @preventable
             * Fires before a resize starts, return false to stop the execution
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskresize',
            /**
             * @event taskresizestart
             * Fires when resize starts
             *
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task about to be resized
             */
            'taskresizestart',
            /**
             * @event partialtaskresize
             * Fires during a resize operation and provides information about the current start and end of the resized event
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task being resized
             * @param {Date} startDate The start date of the task
             * @param {Date} endDate The end date of the task
             * @param {Ext.Element} element The element being resized
             */
            'partialtaskresize',
            /**
             * @event beforetaskresizefinalize
             * @preventable
             * Fires before a succesful resize operation is finalized. Return false to finalize the resize at a later time.
             * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
             * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
             * @param {Mixed} view The gantt view instance
             * @param {Object} resizeContext An object containing 'record', 'start', 'end', 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskresizefinalize',
            /**
             * @event aftertaskresize
             * Fires after a succesful resize operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task that has been resized
             */
            'aftertaskresize',
            // Resizing events end --------------------------
            // Task progress bar resizing events start --------------------------
            /**
             * @event beforeprogressbarresize
             * @preventable
             * Fires before a progress bar resize starts, return false to stop the execution
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'beforeprogressbarresize',
            /**
             * @event progressbarresizestart
             * Fires when a progress bar resize starts
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record about to be have its progress bar resized
             */
            'progressbarresizestart',
            /**
             * @event afterprogressbarresize
             * Fires after a succesful progress bar resize operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord record The updated record
             */
            'afterprogressbarresize',
            // Task progressbar resizing events end --------------------------
            // Dnd events start --------------------------
            /**
             * @event beforetaskdrag
             * @preventable
             * Fires before a task drag drop is initiated, return false to cancel it
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The task record that's about to be dragged
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskdrag',
            /**
             * @event taskdragstart
             * Fires when a dnd operation starts
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The record being dragged
             */
            'taskdragstart',
            /**
             * @event beforetaskdropfinalize
             * @preventable
             *
             * Fires before a SUCCESSFUL drop operation is finalized.
             * This event is supposed to be used as a SYNCHRONOUS hook before the drop finalizing, or as an ASYNCHRONOUS drop validator.
             * Return `true` to finalize the drop operation immediately, or return `false` to finalize it later.
             * To finalize the operation later, call the 'finalize' method available on the context object.
             * Pass `true` to the `finalize` function to accept the drop or `false` if you want to cancel it.
             *
             * Here is an example of a **sync** hook:
             *
             * ```javascript
             * beforetaskdropfinalize : function (view, dragContext, e) {
             *     dragContext.record.setCls('dropped');
             *     return true;
             * }
             *
             * ```
             *
             * Here is an example of an **async** hook:
             *
             * ```javascript
             * beforetaskdropfinalize : function (view, dragContext, e) {
             *     Ext.Ajax.request({
             *         url     : '/check-the-drop-operation',
             *         success : function (response) {
             *             // confirm the drop operation
             *             dragContext.finalize(true);
             *         },
             *         failure : function (response) {
             *             // decline the drop operation
             *             dragContext.finalize(false);
             *         }
             *     });
             *     return false;
             * }
             * ```
             *
             * **NOTE:** In case you return `false` from the listener, you should ALWAYS call the `finalize` function,
             * no matter with `true` argument to confirm the drop operation, or with `false` argument to decline it.
             *
             * **NOTE2:** If you need to perform SYNCHRONOUS drop validation please take a look at {@link #dndValidatorFn}.
             *
             * @param {Mixed} view The gantt view instance
             * @param {Object} dragContext An object containing 'record', 'start', 'duration' (in minutes), 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforetaskdropfinalize',
            /**
             * @event beforedragcreate
             * @preventable
             * Fires before a drag create operation starts, return false to prevent the operation
             * @param {Gnt.view.Gantt} gantt The gantt view
             * @param {Gnt.model.Task} task The task record being updated
             * @param {Date} date The date of the drag start point
             * @param {Ext.EventObject} e The event object
             */
            'beforedragcreate',
            /**
             * @event dragcreatestart
             * Fires before a drag starts, return false to stop the operation
             * @param {Gnt.view.Gantt} view The gantt view
             */
            'dragcreatestart',
            /**
             * @event beforedragcreatefinalize
             * @preventable
             * Fires before a succesful create operation is finalized. Return false to finalize creating at a later time.
             * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
             * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
             * @param {Mixed} view The gantt view instance
             * @param {Object} createContext An object containing 'record', 'start', 'end', 'finalize' properties.
             * @param {Ext.EventObject} e The event object
             */
            'beforedragcreatefinalize',
            /**
             * @event dragcreateend
             * Fires after a successful drag-create operation
             * @param {Gnt.view.Gantt} view The gantt view
             * @param {Gnt.model.Task} task The updated task record
             * @param {Ext.EventObject} e The event object
             */
            'dragcreateend',
            /**
             * @event afterdragcreate
             * Always fires after a drag-create operation
             * @param {Gnt.view.Gantt} view The gantt view
             */
            'afterdragcreate',
            /**
             * @event taskdrop
             * Fires after a succesful drag and drop operation
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} taskRecord The dropped record
             */
            'taskdrop',
            /**
             * @event aftertaskdrop
             * Fires after a drag and drop operation, regardless if the drop valid or invalid
             * @param {Gnt.view.Gantt} gantt The gantt panel instance
             * @param {Gnt.model.Task} task The task instance
             */
            'aftertaskdrop',
            // Dnd events end --------------------------
            /**
             * @event labeledit_beforestartedit
             * Fires before editing is started for a field
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Gnt.model.Task} taskRecord The task record
             * @param {Mixed} value The field value being set
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_beforestartedit',
            /**
             * @event labeledit_beforecomplete
             * Fires after a change has been made to a label field, but before the change is reflected in the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_beforecomplete',
            /**
             * @event labeledit_complete
             * Fires after editing is complete and any changed value has been written to the underlying field.
             * @param {Gnt.view.Gantt} gantt The gantt view instance
             * @param {Mixed} value The current field value
             * @param {Mixed} startValue The original field value
             * @param {Gnt.model.Task} taskRecord The affected record
             * @param {Gnt.feature.LabelEditor} editor The editor instance
             */
            'labeledit_complete',
            /**
             * @event scheduleclick
             * Fires after a click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduleclick',
            /**
             * @event scheduledblclick
             * Fires after a doubleclick on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'scheduledblclick',
            /**
             * @event schedulecontextmenu
             * Fires after a context menu click on the schedule area
             * @param {Gnt.panel.Gantt} gantt The gantt panel object
             * @param {Date} clickedDate The clicked date
             * @param {Number} rowIndex The row index
             * @param {Ext.EventObject} e The event object
             */
            'schedulecontextmenu',
            // Not supported in gridview as of Ext 6.0.1
            // https://www.sencha.com/forum/showthread.php?307978-GridPanel-should-fire-rowlongpress-celllongpress-etc&p=1124914#post1124914
            'rowlongpress',
            'containerlongpress'
        ]);
        this.relayEvents(this.lockedGrid.getView(), [
            // Not supported in gridview as of Ext 6.0.1
            // https://www.sencha.com/forum/showthread.php?307978-GridPanel-should-fire-rowlongpress-celllongpress-etc&p=1124914#post1124914
            'rowlongpress',
            'containerlongpress'
        ]);
        if (this.addRowOnTab) {
            var lockedView = this.lockedGrid.getView();
            lockedView.onRowExit = Ext.Function.createInterceptor(lockedView.onRowExit, this.beforeRowExit, this);
        }
        this.registerRenderer(ganttView.columnRenderer, ganttView);
        var cls = ' sch-ganttpanel sch-horizontal ';
        this.addCls(cls);
        if (this.eventBorderWidth < 1) {
            this.addCls('sch-gantt-no-task-border');
        }
        if (this.baselineVisible) {
            this.showBaseline();
        }
        // HACK: Editors belong in the locked grid, otherwise they float visibly on top of the normal grid when scrolling the locked grid
        this.on('add', function(me, cmp) {
            if (cmp instanceof Ext.Editor) {
                me.lockedGrid.suspendLayouts();
                me.suspendLayouts();
                me.lockedGrid.add(cmp);
                me.resumeLayouts();
                me.lockedGrid.resumeLayouts();
            }
        });
        this.on({
            viewready: this.onMyViewReady,
            // Prevent the Pan plugin from interfering with a dragcreate action
            dragcreatestart: function() {
                var panPlug = this.findPlugin('scheduler_pan');
                var scrollable = this.getSchedulingView().getScrollable();
                if (panPlug) {
                    panPlug.disable();
                }
                scrollable.setDisabled && scrollable.setDisabled(true);
            },
            afterdragcreate: function() {
                var panPlug = this.findPlugin('scheduler_pan');
                var scrollable = this.getSchedulingView().getScrollable();
                if (panPlug) {
                    panPlug.enable();
                }
                scrollable.setDisabled && scrollable.setDisabled(false);
            },
            scope: this
        });
        if (this.scrollTaskIntoViewOnClick) {
            this.lockedGrid.on('itemclick', this.onRowClicked, this);
        }
        Ext.Array.each(this.lockedGrid.plugins || [], function(plug) {
            if (Sch.plugin && Sch.plugin.TreeCellEditing && plug instanceof Sch.plugin.TreeCellEditing) {
                this.ganttEditingPlugin = plug;
                return false;
            }
        }, this);
    },
    tryRestoreSelectionAfterRemove: function(store, records, index, isMove) {
        // this listener is prioritized, it will get old data in selection model and modified store/view
        var selModel = this.getSelectionModel();
        var selected = this._lastSpreadsheetSelection || selModel.selected;
        this._lastSpreadsheetSelection = null;
        // Ignore move, or if nothing was selected yet or store is empty
        if (isMove || !selected || store.getCount() === 0) {
            return;
        }
        var view = this.lockedGrid.getView();
        if (selected.isCells) {
            var range = selected.getRange();
            // Do not do anything, if negative coordinates passed. Can happen when node is collapsed with
            // click in 6.0.1
            if (range[1][0] === -1) {
                return;
            }
            var nodesCount = view.getNodes().length - 1;
            selModel.selectCells([
                range[0][0],
                Math.min(nodesCount, range[0][1])
            ], [
                range[1][0],
                Math.min(nodesCount, range[1][1])
            ]);
        } else if (selected.isRows) {
            var selectedRecords = selected.getRecords();
            if (selectedRecords.length) {
                var selectedRecordExists = false;
                for (var i = 0,
                    len = selectedRecords.length; i < len; i++) {
                    // if any record from current selection is still alive - selection model will handle it itself
                    if (selectedRecordExists = selectedRecordExists || store.indexOf(selectedRecords[i]) !== -1) {
                        break;
                    }
                }
                // if smth was selected and nothing is now - select record by current index or last in store
                if (!selectedRecordExists) {
                    var recordToSelect = view.getRecord(Math.min(index, store.getCount() - 1));
                    recordToSelect && selModel.select(recordToSelect);
                }
            }
        }
    },
    storeSelectionBeforeRemove: function() {
        var selected = this.getSelectionModel().getSelected();
        if (!selected) {
            return;
        }
        selected = selected.clone();
        if (selected.isRows) {
            var records = selected.getRecords();
            if (records.length) {
                selected._lastRecordIndex = this.getView().indexOf(records[records.length - 1]);
            }
        }
        this._lastSpreadsheetSelection = selected;
    },
    tryRestoreSelectionAfterBatchRemove: function(store, records) {
        var selected = this._lastSpreadsheetSelection;
        this._lastSpreadsheetSelection = null;
        // We suspend remove event for some operations, firing batchremove instead. In this case we should notify
        // selection model that records were removed.
        // 3rd argument is not utilized, 4th - should be false, because we don't move records
        this.getSelectionModel().onStoreRemove(store, records, null, false);
        if (!selected || store.getCount() === 0) {
            return;
        }
        var selModel = this.getSelectionModel();
        var view = this.lockedGrid.getView();
        if (selected.isCells) {
            var range = selected.getRange();
            // Do not do anything, if negative coordinates passed. Can happen when node is collapsed with
            // click in 6.0.1
            if (range[1][0] === -1) {
                return;
            }
            var nodesCount = view.getNodes().length;
            selModel.selectCells([
                range[0][0],
                Math.min(nodesCount, range[0][1])
            ], [
                range[1][0],
                Math.min(nodesCount, range[1][1])
            ]);
        } else if (selected.isRows) {
            var selectedRecords = selected.getRecords();
            var selectedRecordExists = false;
            for (var i = 0,
                len = selectedRecords.length; i < len; i++) {
                // if any record from current selection is still alive - selection model will handle it itself
                if (selectedRecordExists = selectedRecordExists || store.indexOf(selectedRecords[i]) !== -1) {
                    break;
                }
            }
            // if smth was selected and nothing is now - select record by current index or last in store
            if (!selectedRecordExists) {
                var recordToSelect = view.getRecord(Math.min(selected._lastRecordIndex, store.getCount() - 1));
                recordToSelect && selModel.select(recordToSelect);
            }
        }
    },
    getTreeViewDragDropPlugin: function() {
        var plugins = this.lockedGrid.view.plugins || [];
        var plugin;
        for (var i = 0; i < plugins.length; i++) {
            plugin = plugins[i];
            // this class is required in patch
            if (plugin instanceof Ext.tree.plugin.TreeViewDragDrop) {
                return plugin;
            }
        }
    },
    doSetTreeViewDragDropDisabled: function(disabled) {
        var plugin = this.getTreeViewDragDropPlugin();
        if (plugin) {
            if (disabled) {
                plugin.disable();
            } else {
                plugin.enable();
            }
        }
    },
    setTreeViewDragDropDisabled: function(disabled) {
        var me = this;
        var view = this.lockedGrid.view;
        if (view.rendered) {
            me.doSetTreeViewDragDropDisabled(disabled);
        } else {
            view.on('render', function() {
                me.doSetTreeViewDragDropDisabled(disabled);
            });
        }
    },
    restoreSpreadsheetSelectionModel: function() {
        var selModel = this.getSelectionModel(),
            plugin = this.getTreeViewDragDropPlugin();
        // only restore listener if selection model and dragdrop plugin are disabled
        if (selModel.isLocked() && plugin && !plugin.disabled) {
            selModel.setLocked(false);
            this.setTreeViewDragDropDisabled(true);
            this.lockedGrid.view.on('cellmousedown', selModel.handleMouseDown, selModel);
            selModel.navigationListeners = selModel.navigationModel.on({
                navigate: selModel.onNavigate,
                scope: selModel,
                destroyable: true
            });
        }
    },
    //selectionModel.cellSelect = selectionModel._cellSelect;
    //selectionModel.rowSelect = selectionModel._rowSelect;
    setReadOnly: function(readOnly) {
        this.callParent(arguments);
        // notify other parts of readOnly mode switching
        this.fireEvent('setreadonly', this, readOnly);
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore;
    },
    bindAutoTimeSpanListeners: function() {
        if (!this.autoFitOnLoad) {
            this.callParent(arguments);
        }
    },
    // Make sure views don't react to store changes during cascading
    onBeforeCascade: function() {
        // make sure UI is already there
        if (this.lockedGrid && this.lockedGrid.view) {
            // HACK no easy way to disable grid view from reacting to the store
            this.lockedGrid.view.onUpdate = this.normalGrid.view.onUpdate = Ext.emptyFn;
            this.suspendLayouts();
        }
    },
    // Re-activate view->store listeners and update views if needed
    onAfterCascade: function(treeStore, context) {
        var me = this;
        // make sure UI is already there
        if (me.lockedGrid && me.lockedGrid.view && me.normalGrid && me.normalGrid.view) {
            me.lockedGrid.view.onUpdate = me.lockedGrid.view.self.prototype.onUpdate;
            me.normalGrid.view.onUpdate = me.normalGrid.view.self.prototype.onUpdate;
            me.resumeLayouts();
            if (me.batchUpdate)  {
                return;
            }
            
            // Views will be refreshed in when batch update is done
            if (context.nbrAffected > 0) {
                var lockedView = me.lockedGrid.getView();
                // Manual refresh of a few row nodes is way faster in large DOM scenarios where the
                // refresh operation takes too long (read/set scroll position, gridview refreshSize etc)
                if (context.nbrAffected <= me.simpleCascadeThreshold) {
                    var view = me.getView();
                    var ganttView = me.getSchedulingView();
                    // let the view finish redrawing all the rows before we are trying to repaint dependencies
                    ganttView.suspendEvents(true);
                    // "context.affected" will contain parent affected parent tasks as well
                    for (var id in context.affected) {
                        var task = context.affected[id];
                        var index = lockedView.store.indexOf(task);
                        // The target task may be inside a collapsed parent, in which case we should ignore updating it
                        if (index >= 0) {
                            view.refreshNode(index);
                        }
                    }
                    ganttView.resumeEvents();
                    return;
                }
                me.refreshViews();
            }
        }
    },
    updateFullRefreshColumns: function() {
        var me = this;
        if (!me.refreshTimer && me.fullRefreshColumns && me.fullRefreshColumns.length) {
            me.refreshTimer = setTimeout(function() {
                me.refreshTimer = null;
                me.redrawColumns(me.fullRefreshColumns);
            }, me.refreshTimeout);
        }
    },
    bindFullRefreshListeners: function() {
        var me = this;
        me.fullRefreshColumnsListeners = this.mon(this.taskStore, {
            nodeappend: me.updateFullRefreshColumns,
            nodeinsert: me.updateFullRefreshColumns,
            noderemove: me.updateFullRefreshColumns,
            destroyable: true,
            scope: this
        });
    },
    bindSequentialDataListeners: function(column) {
        var lockedView = this.lockedGrid.view;
        var taskStore = this.taskStore;
        // the combination of buffered renderer + tree will perform a full refresh on any CRUD,
        // no need to update only some of the cells
        // Update: Seems unreliable
        //if (lockedView.bufferedRenderer) return;
        column.mon(taskStore, {
            nodeappend: function(store, node) {
                if (!taskStore.fillCount) {
                    // We refresh all nodes following the inserted node parent (since at this point, node is not yet part of the store)
                    this.updateAutoGeneratedCells(column, lockedView.store.indexOf(node.parentNode));
                }
            },
            nodeinsert: function(store, node, insertedBefore) {
                this.updateAutoGeneratedCells(column, lockedView.store.indexOf(insertedBefore));
            },
            noderemove: function(store, node, isMove) {
                if (!isMove) {
                    this.updateAutoGeneratedCells(column, lockedView.store.indexOf(node));
                }
            },
            nodemove: function(store, oldParent) {
                this.updateAutoGeneratedCells(column, lockedView.store.indexOf(oldParent));
            },
            scope: this
        });
    },
    bindEarlyDatesListeners: function() {
        var updateEarlyDateColumns = Ext.Function.createBuffered(this.updateEarlyDateColumns, this.refreshTimeout, this, []);
        this.earlyDatesListeners = this.mon(this.taskStore, {
            earlydatesreset: updateEarlyDateColumns,
            scope: this,
            destroyable: true
        });
    },
    bindLateDatesListeners: function() {
        var updateLateDateColumns = Ext.Function.createBuffered(this.updateLateDateColumns, this.refreshTimeout, this, []);
        this.lateDatesListeners = this.mon(this.taskStore, {
            latedatesreset: updateLateDateColumns,
            scope: this,
            destroyable: true
        });
    },
    startEditScrollToEditor: function() {
        var editingPlugin = this.ganttEditingPlugin;
        // HACK: Need to do an extra 'realign' call since the Ext call to show the editor messes up the scrollposition
        // See test 1002_tabbing.t.js
        !Sch.disableOverrides && editingPlugin && editingPlugin.on('beforeedit', function(plug, context) {
            context.column.getEl().scrollIntoView(context.column.ownerCt.getEl());
            context.view.scrollCellIntoView(context.cell);
        }, this, {
            single: true
        });
    },
    beforeRowExit: function(keyEvent, prevRow, newRow, forward) {
        // In < Ext 6.2, only 3 arguments
        if (!(keyEvent instanceof Ext.event.Event)) {
            forward = newRow;
            newRow = prevRow;
            prevRow = keyEvent;
        }
        if (forward && !newRow) {
            var view = this.lockedGrid.getView();
            var record = view.getRecord(prevRow);
            // In ext 6.2.1 refreshSize method (called somewhere in store's 'endupdate' listener added by sencha)
            // began to save/restore scroll. In IEs that lead to blur/focus racing and editor, instead of being blurred,
            // is focused (having 0 dimentions at the same time). That leads to editor being unreachable by tabbing.
            // To reproduce this in IE9-11 run test, open editor in last cell of the last row and press TAB. Then check
            // DOM for class x-field-form-focus, there will two elements, first one is the previous editor,
            // focused erroneously, and 2nd is the active editor.
            // Covered by 1002_tabbing test
            var old = view.saveFocusState;
            view.saveFocusState = function() {
                return Ext.emptyFn;
            };
            record.addTaskBelow({
                leaf: true
            });
            view.saveFocusState = old;
            // HACK needed to sync header with new editor position
            if (Ext.getVersion().isGreaterThanOrEqual('6.5.0')) {
                this.startEditScrollToEditor();
            }
        }
    },
    // this function checks whether the configuration option should be translated to task store or calendar
    // idea is that some configuration option (`cascadeChanges` for example) actually belongs to TaskStore
    // so they are not persisted in the gantt panel (panel only provides accessors which reads/write from/to TaskStore)
    // however the values for those options could also be specified in the prototype of the Gnt.panel.Gantt subclass
    // see #172
    needToTranslateOption: function(optionName) {
        return this.hasOwnProperty(optionName) || this.self.prototype.hasOwnProperty(optionName) && this.self != Gnt.panel.Gantt;
    },
    /**
     * <p>Returns the task record for a DOM node</p>
     * @param {Ext.Element/HTMLElement} el The DOM node or Ext Element to lookup
     * @return {Gnt.model.Task} The task record
     */
    resolveTaskRecord: function(el) {
        return this.getSchedulingView().resolveTaskRecord(el);
    },
    /**
     * Tries to fit the time columns to the available view width
     */
    fitTimeColumns: function() {
        this.getSchedulingView().fitColumns();
    },
    /**
     * Returns the resource store associated with the Gantt panel instance
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function() {
        return this.getTaskStore().getResourceStore();
    },
    /**
     * Returns the assignment store associated with the Gantt panel instance
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.getTaskStore().getAssignmentStore();
    },
    /**
     * Returns the associated CRUD manager
     * @return {Gnt.data.CrudManager}
     */
    getCrudManager: function() {
        return this.crudManager;
    },
    /**
     * Returns the associated task store
     * @return {Gnt.data.TaskStore}
     */
    getTaskStore: function() {
        return this.taskStore;
    },
    /**
     * Returns the task store instance
     * @return {Gnt.data.TaskStore}
     */
    getEventStore: function() {
        return this.taskStore;
    },
    /**
     * Returns the associated dependency store
     * @return {Gnt.data.DependencyStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    // private
    onDragDropStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
    },
    // private
    onDragDropEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
    },
    // private
    configureFunctionality: function() {
        // Normalize to array
        var plugins = this.plugins = [].concat(this.plugins || []);
        if (this.enableConstraintsResolutionGui && !Ext.Array.findBy(plugins, function(item) {
            return (item instanceof Gnt.plugin.ConstraintResolutionGui) || (item.ptype == 'constraintresolutiongui');
        })) {
            plugins.push(Ext.apply(this.constraintResolutionGuiConfig || {}, {
                pluginId: "constraintresolutiongui",
                ptype: "constraintresolutiongui"
            }));
        }
        if (this.showProjectLines) {
            plugins.push(Ext.apply({
                pluginId: 'gantt_projectlines',
                ptype: 'gantt_projectlines'
            }, this.projectLinesConfig));
        }
        // Either object or boolean
        if (this.enableTaskReordering) {
            // if config is defined in prototype or not defined at all - define property on instance
            if (!this.hasOwnProperty('lockedViewConfig')) {
                this.lockedViewConfig = Ext.apply({}, this.lockedViewConfig || {});
            }
            this.lockedViewConfig.plugins = [].concat(this.lockedViewConfig.plugins || []);
            // HACK - remove post v4.0
            // Users may have added their own drag drop plugin, in such case we should not add our owns
            var lockedViewPlugins = this.lockedViewConfig.plugins;
            var userAddedOwnDragDropPlugin;
            Ext.Array.each(lockedViewPlugins, function(plug) {
                if (plug === 'treeviewdragdrop' || plug.ptype === 'treeviewdragdrop') {
                    userAddedOwnDragDropPlugin = true;
                }
            });
            if (!userAddedOwnDragDropPlugin) {
                var pluginConfig = Ext.apply({}, Ext.isObject(this.enableTaskReordering) && this.enableTaskReordering || {}, {
                        ptype: 'treeviewdragdrop',
                        pluginId: 'bryntum_treedragdrop',
                        nodeHighlightOnDrop: false,
                        nodeHighlightOnRepair: false,
                        containerScroll: true,
                        dragZone: {
                            onBeforeDrag: Ext.Function.bind(this.onBeforeTaskReorder, this)
                        },
                        dropZone: {
                            onNodeDrop: this.onTaskReorder,
                            onNodeOver: this.onTaskReorderOver
                        }
                    });
                lockedViewPlugins.push(pluginConfig);
            }
        }
    },
    /**
     * If configured to highlight non-working time, this method returns the {@link Sch.plugin.NonWorkingTime workingTime} feature
     * responsible for providing this functionality.
     * @return {Sch.plugin.NonWorkingTime} workingTime
     */
    getWorkingTimePlugin: function() {
        return this.workingTimePlugin;
    },
    registerLockedDependencyListeners: function() {
        var me = this;
        var depStore = this.getDependencyStore();
        // Need to save these to be able to deregister them properly.
        this._lockedDependencyListeners = this._lockedDependencyListeners || {
            load: function() {
                me.lockedGrid.getView().refreshView();
            },
            clear: function() {
                me.lockedGrid.getView().refreshView();
            },
            add: function(depStore, records) {
                me.refreshTasksForDependencies(records);
            },
            update: function(depStore, record, operation) {
                if (operation != Ext.data.Model.COMMIT) {
                    var view = me.lockedGrid.view;
                    if (record.previous[record.fromField]) {
                        var prevFromTask = me.taskStore.getModelById(record.previous[record.fromField]);
                        if (prevFromTask) {
                            view.refreshNode(prevFromTask);
                        }
                    }
                    if (record.previous[record.toField]) {
                        var prevToTask = me.taskStore.getModelById(record.previous[record.toField]);
                        if (prevToTask) {
                            view.refreshNode(prevToTask);
                        }
                    }
                }
                // we update the record related tasks not for EDIT operation only
                // since we need to react on record COMMIT as well
                me.refreshTasksForDependencies([
                    record
                ]);
            },
            remove: function(depStore, records) {
                me.refreshTasksForDependencies(records);
            }
        };
        // This could be called multiple times, if both predecessor and successor columns are used
        this.mun(depStore, this._lockedDependencyListeners);
        this.mon(depStore, this._lockedDependencyListeners);
    },
    getDependencyTasks: function(depRecord) {
        var sourceTask = depRecord.getSourceTask(this.taskStore),
            targetTask = depRecord.getTargetTask(this.taskStore),
            result = [];
        // we should not refresh node which is being removed
        if (sourceTask && sourceTask.getTreeStore()) {
            result.push(sourceTask);
        }
        if (targetTask && targetTask.getTreeStore()) {
            result.push(targetTask);
        }
        return result;
    },
    refreshLockedViewRows: function(tasks) {
        var lockedView = this.lockedGrid.view;
        for (var i = 0; i < tasks.length; i++) {
            lockedView.refreshNode(tasks[i]);
        }
    },
    refreshTasksForDependencies: function(dependencies) {
        var me = this,
            addedTasks = {},
            toRefresh = [];
        Ext.Array.each(dependencies, function(dependency) {
            // get dependency related tasks
            var tasks = me.getDependencyTasks(dependency);
            for (var i = 0; i < tasks.length; i++) {
                // put them into toRefresh array if they aren't there already
                if (!addedTasks[tasks[i].getId()]) {
                    addedTasks[tasks[i].getId()] = 1;
                    toRefresh.push(tasks[i]);
                }
            }
            me.refreshLockedViewRows(toRefresh);
        });
    },
    /**
     * Shows the baseline tasks
     */
    showBaseline: function() {
        //this.addCls('sch-ganttpanel-showbaseline');
        this.getSchedulingView().showBaseline();
    },
    /**
     * Hides the baseline tasks
     */
    hideBaseline: function() {
        //this.removeCls('sch-ganttpanel-showbaseline');
        this.getSchedulingView().hideBaseline();
    },
    /**
     * Toggles the display of the baseline
     */
    toggleBaseline: function() {
        //this.toggleCls('sch-ganttpanel-showbaseline');
        this.getSchedulingView().toggleBaseline();
    },
    /**
     * Changes the timeframe of the gantt chart to fit all the tasks in it. Provide left/right margin if you want to fit also
     * labels.
     * @param {Gnt.model.Task/Gnt.model.Task[]} [tasks] A list of tasks to zoom to. If not specified then the gantt will
     * try to fit all the tasks in the {@link #taskStore task store}.
     * @param {Object} [options] Options object for zooming.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first task start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last task end date and last visible date
     */
    zoomToFit: function(tasks, options) {
        options = Ext.apply({
            adjustStart: 1,
            adjustEnd: 1
        }, options);
        // If view is being filtered, only considered the matching results when zooming
        if (!tasks && this.taskStore.isTreeFiltered()) {
            tasks = this.getSchedulingView().store.getRange();
        }
        var span = tasks ? this.taskStore.getTimeSpanForTasks(tasks) : this.taskStore.getTotalTimeSpan();
        if (this.zoomToSpan(span, options) === null) {
            // if no zooming was performed - fit columns to view space
            if (!tasks)  {
                this.fitTimeColumns();
            }
            
        }
    },
    /**
     * "Get" accessor for the `cascadeChanges` option
     */
    getCascadeChanges: function() {
        return this.taskStore.cascadeChanges;
    },
    /**
     * "Set" accessor for the `cascadeChanges` option
     */
    setCascadeChanges: function(value) {
        this.taskStore.cascadeChanges = value;
    },
    /**
     * "Get" accessor for the `recalculateParents` option
     */
    getRecalculateParents: function() {
        return this.taskStore.recalculateParents;
    },
    /**
     * "Set" accessor for the `recalculateParents` option
     */
    setRecalculateParents: function(value) {
        this.taskStore.recalculateParents = value;
    },
    /**
     * "Set" accessor for the `skipWeekendsDuringDragDrop` option
     */
    setSkipWeekendsDuringDragDrop: function(value) {
        this.taskStore.skipWeekendsDuringDragDrop = this.skipWeekendsDuringDragDrop = value;
    },
    /**
     * "Get" accessor for the `skipWeekendsDuringDragDrop` option
     */
    getSkipWeekendsDuringDragDrop: function() {
        return this.taskStore.skipWeekendsDuringDragDrop;
    },
    // BEGIN RESOURCE STORE LISTENERS
    onResourceStoreUpdate: function(store, resource) {
        Ext.Array.each(resource.getTasks(), function(task) {
            var index = this.lockedGrid.view.store.indexOf(task);
            if (index >= 0) {
                this.getView().refreshNode(index);
            }
        }, this);
    },
    onResourceStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },
    // EOF RESOURCE STORE LISTENERS
    // BEGIN ASSIGNMENT STORE LISTENERS
    onAssignmentStoreDataChanged: function() {
        if (this.taskStore.getRootNode().childNodes.length > 0) {
            this.refreshViews();
        }
    },
    onAssignmentStoreUpdate: function(store, assignment) {
        var task = assignment.getTask();
        if (task) {
            var index = this.lockedGrid.view.store.indexOf(task);
            if (index >= 0) {
                this.getView().refreshNode(index);
            }
        }
    },
    // We should not react to changes in the assignment store when it is happening for a single resource
    // We rely on the "taskassignmentschanged" event for updating the UI
    onBeforeSingleTaskAssignmentChange: function() {
        this.assignmentStore.un('add', this.onAssignmentStoreDataChanged, this);
        this.assignmentStore.un('remove', this.onAssignmentStoreDataChanged, this);
    },
    onSingleTaskAssignmentChange: function(assignmentStore, taskId) {
        this.assignmentStore.on('add', this.onAssignmentStoreDataChanged, this);
        this.assignmentStore.on('remove', this.onAssignmentStoreDataChanged, this);
        if (this.rendered) {
            var task = this.taskStore.getModelById(taskId);
            // Make sure task is part of the tree and wasn't just removed
            if (task && task.parentNode) {
                var index = this.taskStore.indexOf(task);
                if (index >= 0) {
                    this.getView().refreshNode(index);
                }
            }
        }
    },
    // EOF ASSIGNMENT STORE LISTENERS
    updateAutoGeneratedCells: function(column, recordIndex) {
        var view = this.lockedGrid.view;
        var startIndex = view.all.startIndex;
        var endIndex = view.all.endIndex;
        if (recordIndex < 0 || recordIndex > endIndex)  {
            return;
        }
        
        for (var i = Math.max(startIndex, recordIndex); i <= endIndex; i++) {
            var rec = view.store.getAt(i);
            var cell = this.getCellDom(view, rec, column);
            if (cell) {
                cell.firstChild.innerHTML = column.renderer(null, null, rec);
            }
        }
    },
    getCellDom: function(view, record, column) {
        var row = view.getNode(record, true);
        return row && Ext.fly(row).down(column.getCellSelector(), true);
    },
    redrawCell: function(column, record, recordIndex, rowIndex, columnIndex) {
        if (!this.isDestroyed) {
            var view = this.lockedGrid.view;
            var cell = this.getCellDom(view, record, column);
            // cell might be null for a hidden column
            if (cell) {
                var out = [];
                if (recordIndex === undefined) {
                    recordIndex = this.taskStore.indexOf(record);
                }
                if (rowIndex === undefined) {
                    rowIndex = view.indexOf(record);
                }
                if (columnIndex === undefined) {
                    columnIndex = column.getIndex();
                }
                view.renderCell(column, record, recordIndex, rowIndex, columnIndex, out);
                // out contain whole cell element starting from <td>, but createDom will return only inner element
                var newContent = Ext.DomHelper.createDom(out.join(''));
                // use sync content for the inner element, because cell can still contain editor
                Ext.fly(cell).down('.' + Ext.baseCSSPrefix + 'grid-cell-inner').syncContent(newContent);
            }
        }
    },
    redrawColumns: function(cols) {
        // this method is called a lot from various buffered listeners, need to check
        // if component has not been destroyed
        if (cols.length && !this.isDestroyed) {
            var view = this.lockedGrid.view;
            for (var i = view.all.startIndex; i <= view.all.endIndex; i++) {
                var rec = view.store.getAt(i);
                for (var j = 0,
                    ll = cols.length; j < ll; j++) {
                    var col = cols[j];
                    this.redrawCell(col, rec, i, i, col.getIndex());
                }
            }
        }
    },
    updateEarlyDateColumns: function() {
        this.earlyColumns && this.earlyColumns.length && this.redrawColumns(this.earlyColumns);
    },
    updateLateDateColumns: function() {
        this.lateColumns && this.lateColumns.length && this.redrawColumns(this.lateColumns);
    },
    onMyViewReady: function() {
        // Prevent editing of non-editable fields
        this.on('beforeedit', this.onBeforeEdit, this);
        this.setupColumnListeners();
        var splitter = this.down('splitter');
        if (splitter) {
            // Since Ext JS doesn't handle locked grid sizing, we do this ourselves.
            splitter.on('dragend', function() {
                this.saveState();
            }, this, {
                delay: 10
            });
        }
        if (this.ganttEditingPlugin) {
            this.ganttEditingPlugin.on({
                editingstart: this.onEditingStart,
                edit: this.onAfterEdit,
                canceledit: this.onAfterEdit
            });
        }
    },
    onBeforeCrudResponseApply: function() {
        this.fireEvent('beforedatarefresh', this);
        var depView = this.getDependencyView();
        depView && depView.stopDrawDependencies();
    },
    onCrudRequestDone: function() {
        this.fireEvent('datarefresh', this);
        var depView = this.getDependencyView();
        depView && depView.startDrawDependencies();
    },
    onBeforeEdit: function(editor, o) {
        var column = o.column;
        var task = o.record;
        return !this.isReadOnly() && o.record.isEditable(o.field) && (!column.isEditable || column.isEditable(task));
    },
    onEditingStart: function(plug, editor) {
        var field = editor.field;
        // Set instant update enabled only after editing has started
        if (field.originalInstantUpdate) {
            field.setInstantUpdate(true);
        }
    },
    onAfterEdit: function(editor, context) {
        var field = context.column.getEditor();
        if (field.setInstantUpdate) {
            field.setInstantUpdate(false);
        }
    },
    setupColumnListeners: function() {
        var me = this;
        var lockedHeader = this.lockedGrid.getHeaderContainer();
        lockedHeader.on('add', this.onLockedColumnAdded, this);
        lockedHeader.on('remove', this.onLockedColumnRemoved, this);
        lockedHeader.items.each(function(col) {
            me.onLockedColumnAdded(lockedHeader, col);
        });
    },
    onLockedColumnRemoved: function(ct, col) {
        /*if (col.isWBSColumn || col.isSequenceColumn) {
            this.bindSequentialDataListeners(col);

        } else*/
        if (col.isDependencyColumn && col.useSequenceNumber) {
            Ext.Array.remove(this.fullRefreshColumns, col);
        } else if (col.isEarlyStartDateColumn || col.isEarlyEndDateColumn) {
            Ext.Array.remove(this.earlyColumns, col);
        } else if (col.isLateStartDateColumn || col.isLateEndDateColumn) {
            Ext.Array.remove(this.lateColumns, col);
        } else if (col.isTotalSlackColumn || col.isFreeSlackColumn) {
            Ext.Array.remove(this.earlyColumns, col);
            Ext.Array.remove(this.lateColumns, col);
        }
        if (this.earlyDatesListeners && !(this.slackColumns && this.slackColumns.length) && !(this.earlyColumns && this.earlyColumns.length)) {
            this.earlyDatesListeners.destroy();
        }
        if (this.lateDatesListeners && !(this.slackColumns && this.slackColumns.length) && !(this.lateColumns && this.lateColumns.length)) {
            this.lateDatesListeners.destroy();
        }
        if (this.fullRefreshColumnsListeners && !(this.fullRefreshColumns && this.fullRefreshColumns.length)) {
            this.fullRefreshColumnsListeners.destroy();
        }
    },
    onLockedColumnAdded: function(ct, col) {
        if (col.isWBSColumn || col.isSequenceColumn) {
            this.bindSequentialDataListeners(col);
        } else if (col.isDependencyColumn && col.useSequenceNumber) {
            this.fullRefreshColumns = this.fullRefreshColumns || [];
            this.fullRefreshColumns.push(col);
        } else if (col.isEarlyStartDateColumn || col.isEarlyEndDateColumn) {
            this.earlyColumns = this.earlyColumns || [];
            this.earlyColumns.push(col);
        } else if (col.isLateStartDateColumn || col.isLateEndDateColumn) {
            this.lateColumns = this.lateColumns || [];
            this.lateColumns.push(col);
        }
        // Slack columns depend on both Late & End dates changes
        else if (col.isTotalSlackColumn || col.isFreeSlackColumn) {
            this.earlyColumns = this.earlyColumns || [];
            this.earlyColumns.push(col);
            this.lateColumns = this.lateColumns || [];
            this.lateColumns.push(col);
        }
        if (!this.fullRefreshColumnsListeners && this.fullRefreshColumns && this.fullRefreshColumns.length) {
            this.bindFullRefreshListeners();
        }
        if (!this.earlyDatesListeners && (this.slackColumns && this.slackColumns.length || this.earlyColumns && this.earlyColumns.length)) {
            this.bindEarlyDatesListeners();
        }
        if (!this.lateDatesListeners && (this.slackColumns && this.slackColumns.length || this.lateColumns && this.lateColumns.length)) {
            this.bindLateDatesListeners();
        }
        // Clear column list in Group by menu to rebuild upon next menu show
        if (this.columnListMenuItem) {
            this.columnListMenuItem.removeAll();
        }
    },
    getState: function() {
        var me = this,
            state = me.callParent(arguments);
        if (me.lockedGrid.rendered) {
            state.lockedWidth = me.lockedGrid.getWidth();
        }
        return state;
    },
    applyState: function(state) {
        var me = this;
        me.callParent(arguments);
        if (state && state.lockedWidth) {
            me.lockedGrid.setWidth(state.lockedWidth);
        }
    },
    completeEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.completeEdit();
    },
    cancelEdit: function() {
        this.ganttEditingPlugin && this.ganttEditingPlugin.cancelEdit();
    },
    setRowHeight: function(height, preventRefresh) {
        var rootElSelector = this.isViewport ? '.sch-ganttpanel' : '#' + this.getId();
        var rowHeightSelector = rootElSelector + ' .' + Ext.baseCSSPrefix + 'grid-cell';
        var rule = rowHeightSelector + '{ height:' + height + 'px; }';
        if (!this.rowHeightStyleSheetNode) {
            // Create panel specific row height rule
            this.rowHeightStyleSheetNode = Ext.util.CSS.createStyleSheet(rule).ownerNode;
        } else {
            this.rowHeightStyleSheetNode.innerHTML = rule;
        }
        // Let view know about this too
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },
    // If task is provided returns a proper task editor plugin instance that can be used for editing.
    // Return any task editor instance available when no task is provided.
    getTaskEditor: function(task) {
        var plugins = this.plugins;
        for (var i = 0,
            l = plugins.length; i < l; i++) {
            var plugin = plugins[i];
            if (plugin.isTaskEditor && (!task || plugin.matchFilters(task)))  {
                return plugin;
            }
            
        }
    },
    onRowClicked: function(panel, task) {
        this.getSchedulingView().scrollEventIntoView(task, false, false);
    },
    // BEGIN TREE NODE REORDERING HOOKS
    // Prevents a readonly task reordering or any task reordering if the gantt is in readonly mode.
    onBeforeTaskReorder: function(data, e) {
        var task = e.record;
        var isSpreadsheetSelection = Ext.grid.selection && Ext.grid.selection.SpreadsheetModel && this.getSelectionModel() instanceof Ext.grid.selection.SpreadsheetModel;
        // store task being reordered
        data._reorderingTask = task;
        // 1. The panel is readonly
        // 2. The task being dragged is readonly
        // 3. When column grouping is active
        // 4. When using spread sheet model, only allow row reordering using the special drag drop column cells
        return (!isSpreadsheetSelection || Boolean(e.getTarget('.sch-gantt-column-dragdrop'))) && !this.isReadOnly() && task && !task.isReadOnly() && !this.taskStore.isTreeGrouped();
    },
    // Prevents dropping a task being reordered into another readonly task
    onTaskReorderOver: function(nodeData, source, e, data) {
        var result = this.self.prototype.onNodeOver.apply(this, arguments);
        if (result !== this.dropNotAllowed) {
            var target = this.getTargetFromEvent(e);
            if (target) {
                var targetTask = this.view.getRecord(target);
                result = targetTask !== data._reorderingTask && !targetTask.isReadOnly() ? this.dropAllowed : this.dropNotAllowed;
            }
        }
        return result;
    },
    // Prevent excessive parent node calculations during tree restructuring
    // https://app.assembla.com/spaces/bryntum/tickets/3049-treeviewdragdrop-is-slow-when-reordering-50+-nodes-/details#
    onTaskReorder: function(nodeData, source, e, data) {
        var valid = this.valid;
        if (valid) {
            var taskStore = source.view.store;
            var gantt = source.view.up('ganttpanel');
            var target = this.getTargetFromEvent(e);
            var targetTask = this.view.getRecord(target);
            var scrollTop = gantt.getSchedulingView().getVerticalScroll();
            valid = targetTask !== data._reorderingTask && !targetTask.isReadOnly();
            if (valid) {
                var tasks = data.records,
                    affectedParents = {},
                    lockedView = this.view;
                // Prevent excessive view refreshes
                // https://www.sencha.com/forum/showthread.php?322186-Full-refresh-after-tree-view-drag-drop-once-for-every-dropped-node&p=1151897#post1151897
                if (gantt.suspendRefreshOnTaskReorder) {
                    gantt.suspendRefresh();
                }
                // Collect all old parent nodes of all moved tasks
                Ext.Array.each(tasks, function(task) {
                    affectedParents[task.parentNode.id] = task.parentNode;
                });
                // Prevent excessive parent recalculation
                taskStore.suspendAutoRecalculateParents++;
                valid = this.self.prototype.onNodeDrop.apply(this, arguments);
                taskStore.suspendAutoRecalculateParents--;
                if (valid) {
                    // Add the new parent node of moved tasks
                    affectedParents[tasks[0].parentNode.id] = tasks[0].parentNode;
                    var affectedParentsArray = Ext.Object.getValues(affectedParents);
                    // Process deepest nodes first, sort accordingly
                    affectedParentsArray.sort(function(node1, node2) {
                        return node1.data.depth > node2.data.depth ? -1 : 1;
                    });
                    Ext.Array.each(affectedParentsArray, function(parent) {
                        parent.refreshCalculatedParentNodeData();
                    });
                }
                if (gantt.suspendRefreshOnTaskReorder) {
                    gantt.resumeRefresh(true);
                }
                // Required for IE11 / Safari, which have an async refresh/scroll behavior
                setTimeout(function() {
                    lockedView.setScrollY(scrollTop);
                }, 0);
            }
        }
        return valid;
    },
    // EOF TREE NODE REORDERING HOOKS
    /**
     * @return {Gnt.model.Task[]} An array of the currently selected rows
     */
    getSelectedRows: function() {
        var selected = this.getSelectionModel().getSelected();
        var tasks = [];
        if (Ext.grid.selection.Cells && selected instanceof Ext.grid.selection.Cells) {
            selected.eachRow(function(task) {
                tasks.push(task);
            });
        } else {
            // Rows are being selected
            tasks = this.getSelectionModel().getSelection();
        }
        return tasks;
    },
    destroy: function() {
        clearTimeout(this.refreshTimer);
        if (this.destroyStores) {
            var calendarManager = this.taskStore.calendarManager;
            this.assignmentStore && this.assignmentStore.destroy();
            this.assignmentStore = null;
            this.resourceStore && this.resourceStore.destroy();
            this.resourceStore = null;
            this.taskStore && this.taskStore.destroy();
            this.taskStore = null;
            this.dependencyStore && this.dependencyStore.destroy();
            this.dependencyStore = null;
            calendarManager && calendarManager.destroy();
        }
        if (this.rowHeightStyleSheetNode) {
            this.rowHeightStyleSheetNode.parentNode.removeChild(this.rowHeightStyleSheetNode);
            this.rowHeightStyleSheetNode = null;
        }
        this.callParent(arguments);
    },
    // Overrides disabled since they break selection model: https://app.assembla.com/spaces/bryntum/tickets/8771-selection-is-broken-after-collapsing-nodes/details#
    // @OVERRIDE Overridden due to bad performance in superclass implementation
    // collapseAll : function () {
    //     this.taskStore.suspendEvent('refresh', 'add', 'insert', 'remove');
    //     this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = true;
    //
    //     this.callParent(arguments);
    //
    //     this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = false;
    //     this.taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
    //
    //     this.refreshViews();
    // },
    // @OVERRIDE Overridden due to bad performance in superclass implementation
    // https://app.assembla.com/spaces/bryntum/tickets/9588-expandall-takes-too-long-when-first-level-node-is-expanded/details
    // expandAll : function () {
    //     this.taskStore.suspendEvent('refresh', 'add', 'insert', 'remove');
    //     this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = true;
    //
    //     this.callParent(arguments);
    //
    //     this.lockedGrid.getView().blockRefresh = this.normalGrid.getView().blockRefresh = false;
    //     this.taskStore.resumeEvent('refresh', 'add', 'insert', 'remove');
    //
    //     this.refreshViews();
    // },
    getCalendar: function() {
        return this.getTaskStore().getCalendar();
    }
});

/**

 @class Gnt.view.ResourceHistogram
 @extends Sch.view.TimelineGridView

 A view of the resource histogram panel. Use the {@link Gnt.panel.ResourceHistogram#getSchedulingView} method to get its instance from gantt panel.

 */
Ext.define('Gnt.view.ResourceHistogram', {
    extend: 'Sch.view.TimelineGridView',
    alias: 'widget.resourcehistogramview',
    requires: [
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Ext.XTemplate',
        'Ext.util.Format',
        'Sch.util.Date'
    ],
    mixins: [
        'Sch.mixin.GridViewCanvas'
    ],
    _cmpCls: 'gnt-resourcehistogramview',
    scheduledEventName: 'bar',
    // private
    eventSelector: '.gnt-resourcehistogram-bar',
    barTpl: null,
    barRenderer: Ext.emptyFn,
    limitLineRenderer: Ext.emptyFn,
    lineRenderer: Ext.emptyFn,
    lineTpl: null,
    limitLineTpl: null,
    // private cls properties
    _barCls: 'gnt-resourcehistogram-bar',
    _limitLineCls: 'gnt-resourcehistogram-limitline',
    _limitLineVerticalCls: 'gnt-resourcehistogram-limitline-vertical',
    _lineCls: 'gnt-resourcehistogram-line',
    barCls: null,
    limitLineCls: null,
    lineCls: null,
    limitLineWidth: 1,
    rowHeight: 60,
    showLimitLinesThreshold: 10,
    showVerticalLimitLines: true,
    labelMode: false,
    labelPercentFormat: '0',
    labelUnitsFormat: '0.0',
    histogram: null,
    unitHeight: null,
    /**
     * @event barclick
     * Fires when a histogram bar is clicked
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing a description of the clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event bardblclick
     * Fires when a histogram bar is double clicked
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing description of clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event barcontextmenu
     * Fires when contextmenu is activated on a histogram bar
     *
     * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
     * @param {Object} context Object containing description of clicked bar.
     * @param {Gnt.model.Resource} context.resource The resource record.
     * @param {Date} context.startDate Start date of corresponding period.
     * @param {Date} context.endDate End date of corresponding period.
     * @param {Number} context.allocationMS Resource allocation time in milliseconds.
     * @param {Number} context.totalAllocation Resource allocation (in percents).
     * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event beforetooltipshow
     * @preventable
     * Fires before the event tooltip is shown, return false to suppress it.
     *
     * @param {Sch.mixin.SchedulerPanel} view Resource histogram scheduling view
     * @param {Object} allocationData Allocation data
     * @param {Date} allocationData.startDate Allocation start date
     * @param {Date} allocationData.endDate Allocation end date
     * @param {Gnt.model.Assignment[]} allocationData.assignments Assignments for this allocation
     * @param {Number} allocationData.allocationMS Resource allocation time in milliseconds
     * @param {Number} allocationData.totalAllocation Resource allocation in percents
     * @param {Gnt.model.Resource} allocationData.resource Resource record
     */
    /**
     */
    initComponent: function(config) {
        if (this.barCls) {
            this.eventSelector = '.' + this.barCls;
        }
        this.createTemplates();
        this.callParent(arguments);
        // calculate pixels per scale step
        this.unitHeight = this.getAvailableRowHeight() / (this.scaleMax - this.scaleMin + this.scaleStep);
    },
    createTemplates: function(force) {
        var side = this.rtl ? 'right' : 'left';
        // bar template
        if (force || !this.barTpl) {
            this.barTpl = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="gnt-resourcehistogram-bar ' + (this.barCls || '') + ' {cls}" gnt-bar-index="{index}" style="' + side + ':{left}px;top:{top}px;height:{height}px;width:{width}px">', '<tpl if="text !== \'\'">', '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight / 2) + 'px">{text}</span>', '</tpl>', '</div>', '</tpl>');
        }
        // scale line template
        if (force || !this.lineTpl) {
            this.lineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-line ' + (this.lineCls || '') + ' {cls}" style="top:{top}px;"></div>', '</tpl>');
        }
        // limit line template
        if (force || !this.limitLineTpl) {
            this.limitLineTpl = new Ext.XTemplate('<tpl for=".">', '<div class="gnt-resourcehistogram-limitline ' + (this.limitLineCls || '') + ' {cls}" style="' + side + ':{left}px;top:{top}px;width:{width}px;height:{height}px"></div>', '</tpl>');
        }
    },
    // histogram scale lines renderer
    renderLines: function() {
        return this.lineTpl.apply(this.prepareLines());
    },
    // prepare data for scale lines renderer
    prepareLines: function() {
        var scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            value = scaleMin,
            labelStep = this.scaleLabelStep,
            rowHeight = this.getAvailableRowHeight(),
            tplData = [],
            lineCls = this._lineCls,
            cls = lineCls + 'min';
        var line, userData;
        // if scale point array specified
        if (this.scalePoints) {
            for (var i = 0,
                l = this.scalePoints.length; i < l; i++) {
                var point = this.scalePoints[i];
                line = {
                    value: point.value,
                    top: point.top || Math.round(rowHeight - this.unitHeight * (point.value - scaleMin)),
                    cls: point.cls + (point.label ? ' ' + lineCls + '-label' : '') + (i === 0 ? ' ' + lineCls + '-min' : (i == l ? ' ' + lineCls + '-max' : ''))
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
            }
        } else // otherwise we have to calculate line top-coordinates
        {
            // loop from scaleMin up to scaleMax
            while (value <= scaleMax) {
                line = {
                    value: value,
                    top: Math.round(rowHeight - this.unitHeight * (value - scaleMin)),
                    cls: cls
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
                // increment by scale step size
                value += this.scaleStep;
                cls = value % labelStep ? '' : lineCls + '-label';
                if (value == scaleMax)  {
                    cls += ' ' + lineCls + '-max';
                }
                
            }
            // ensure that we have scaleMax as last tplData element (we can step over it for some stepSize values)
            if (tplData.length && tplData[tplData.length - 1].value !== scaleMax) {
                line = {
                    value: scaleMax,
                    top: Math.round(rowHeight - this.unitHeight * (scaleMax - scaleMin)),
                    cls: (scaleMax % labelStep ? '' : lineCls + '-label') + ' ' + lineCls + '-max'
                };
                // call user provided function to modify the data
                userData = this.lineRenderer(tplData, line);
                tplData.push(Ext.apply(line, userData));
            }
        }
        return tplData;
    },
    renderLimitLines: function(data) {
        return this.limitLineTpl.apply(this.prepareLimitLines(data));
    },
    getLimitLinesConnector: function(from, to) {
        return {
            left: from.right,
            width: 1,
            top: Math.min(from.top, to.top),
            height: Math.abs(from.top - to.top) + this.limitLineWidth,
            cls: this._limitLineCls + '-top' + ' ' + this._limitLineVerticalCls
        };
    },
    pushLimitLine: function(tplData, line, toMerge) {
        var prev = tplData[tplData.length - 1];
        // if we had cached lines too small to display
        if (toMerge) {
            // let's lengthen the previous line (if any) right coordinate
            if (prev) {
                prev.width = toMerge.right - prev.left;
                prev.right = toMerge.right;
            } else {
                line.left = toMerge.left;
                line.width = line.right - toMerge.left;
            }
        }
        if (prev && this.showVerticalLimitLines) {
            // if previous line is invisible get rid of it
            if (!prev.visible)  {
                tplData.pop();
            }
            
            tplData.push(this.getLimitLinesConnector(prev, line));
        }
        // call user provided function to modify the data
        var userData = this.limitLineRenderer(tplData, line, toMerge);
        tplData.push(Ext.apply(line, userData));
    },
    prepareLimitLines: function(data) {
        if (!data)  {
            return;
        }
        
        var tplData = [],
            scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            scaleStep = this.scaleStep,
            scaleUnit = this.scaleUnit,
            rowHeight = this.getAvailableRowHeight(),
            lineCls = this._limitLineCls,
            maxWidth = this.getTimeAxisViewModel() && this.getTimeAxisViewModel().getTotalWidth(),
            toMerge, line, prev;
        for (var i = 0,
            l = data.length; i < l; i++) {
            // get allocation in scale units
            var allocation = this.calendar.convertMSDurationToUnit(data[i].allocationMS, scaleUnit);
            var visible = true;
            // if the line doesn't fit into row height
            if (allocation * this.unitHeight > rowHeight) {
                allocation = scaleMax + scaleStep;
                visible = false;
            } else if (allocation <= 0) {
                allocation = 0;
                visible = false;
            }
            var left = data[i].startDate && this.getCoordinateFromDate(data[i].startDate, true) || 0;
            var right = data[i].endDate && this.getCoordinateFromDate(data[i].endDate, true) || maxWidth;
            // interval may start 0 timeaxis start
            if (left < 0)  {
                left = 0;
            }
            
            if (right < 0)  {
                right = maxWidth;
            }
            
            line = {
                left: left,
                width: right - left,
                right: right,
                top: '',
                height: 0,
                cls: '',
                visible: visible
            };
            // get top-position based on max possible allocation
            line.top = Math.round(rowHeight - (allocation - scaleMin) * this.unitHeight);
            if (visible) {
                line.cls += ' ' + lineCls + '-top';
            }
            prev = tplData[tplData.length - 1] || toMerge;
            // check if line size is less than threshold
            var small = line.width <= this.showLimitLinesThreshold;
            // if the line has the same allocation as the previous one
            // or it's a small invisible line -> then we merge it w/ the previous line
            if (prev && (line.top == prev.top || (small && !visible))) {
                prev.width = right - prev.left;
                prev.right = right;
                // reset cached line
                line = null;
                // if we have a pushed line we simply skip small line(s) after it
                if (tplData[tplData.length - 1]) {
                    toMerge = null;
                }
                // if we enlarged "toMerge" line and its width got greater than threshold
                else if (toMerge.width > this.showLimitLinesThreshold) {
                    this.pushLimitLine(tplData, toMerge);
                    // reset cached line since we just pushed it
                    toMerge = null;
                }
            }
            // if the line is small and visible we'll try to merge it w/ next lines and approximate its top coordinate
            else if (small && visible) {
                // if the previous line was also too small
                if (toMerge) {
                    var width = toMerge.width + line.width;
                    // merge both lines and approximate average top level
                    toMerge.top = Math.round(line.top * line.width / width + toMerge.top * toMerge.width / width);
                    toMerge.width = right - toMerge.left;
                    toMerge.right = right;
                } else // remember this line hoping to merge w/ the next line
                {
                    toMerge = line;
                }
                // if merged line width is greater than threshold
                if (toMerge.width > this.showLimitLinesThreshold) {
                    this.pushLimitLine(tplData, toMerge);
                    // reset cached lines since we just pushed them
                    line = toMerge = null;
                }
            } else // if the current line is large enough to display
            {
                this.pushLimitLine(tplData, line, toMerge);
                // reset cached lines since we just pushed them
                line = toMerge = null;
            }
        }
        line && this.pushLimitLine(tplData, line, toMerge);
        // make sure we don't have invisible line in the last item
        prev = tplData[tplData.length - 1];
        if (prev && !prev.visible)  {
            tplData.pop();
        }
        
        return tplData;
    },
    renderBars: function(data, resourceId) {
        return this.barTpl.apply(this.prepareBars(data, resourceId));
    },
    prepareBars: function(data, resourceId) {
        if (!data)  {
            return;
        }
        
        // loop over periods that we have for the resource
        var tplData = [],
            rowHeight = this.getAvailableRowHeight(),
            barCls = this._barCls,
            scaleUnit = this.scaleUnit,
            scaleUnitName = Sch.util.Date.getShortNameOfUnit(scaleUnit),
            scaleMin = this.scaleMin,
            scaleMax = this.scaleMax,
            scaleStep = this.scaleStep,
            scaleMaximum = scaleMax + scaleStep,
            viewStart = this.timeAxis.getStart(),
            viewEnd = this.timeAxis.getEnd(),
            tplItem, allocation;
        for (var i = 0,
            l = data.length; i < l; i++) {
            var bar = data[i];
            // if resource is allocated
            if (bar.totalAllocation) {
                // get allocation in units (hours by default)
                allocation = this.calendar.convertMSDurationToUnit(bar.allocationMS, scaleUnit);
                var endsInsideView = bar.endDate <= viewEnd;
                var startsInsideView = Sch.util.Date.betweenLesser(bar.startDate, viewStart, viewEnd);
                var left = this.getCoordinateFromDate(startsInsideView ? bar.startDate : viewStart, true);
                var right = this.getCoordinateFromDate(endsInsideView ? bar.endDate : viewEnd, true);
                tplItem = {
                    id: 'bar-' + resourceId + '-' + i,
                    index: i,
                    left: left,
                    width: right - left,
                    height: rowHeight,
                    top: 0,
                    text: '',
                    cls: ''
                };
                // if label has to be shown
                if (this.labelMode) {
                    // what type of label requested
                    switch (this.labelMode) {
                        case 'percent':
                            tplItem.text = Ext.util.Format.number(bar.totalAllocation, this.labelPercentFormat) + '%';
                            break;
                        case 'units':
                            tplItem.text = Ext.util.Format.number(allocation, this.labelUnitsFormat) + scaleUnitName;
                            break;
                        // custom template
                        default:
                            tplItem.text = this.labelMode.apply({
                                allocation: allocation,
                                percent: bar.totalAllocation
                            });
                    }
                }
                // if the bar fits in row height
                if (allocation <= scaleMaximum) {
                    tplItem.height = allocation >= scaleMin ? Math.round((allocation - scaleMin) * this.unitHeight) : 0;
                    tplItem.top = rowHeight - tplItem.height;
                } else // if bar is higher than row height
                {
                    // add class to indicate it
                    tplItem.cls += ' ' + barCls + '-partofbar';
                }
                // overworking (allocation > 100%)
                if (bar.totalAllocation > 100 || bar.totalOverAllocationMS > 0) {
                    tplItem.cls += ' ' + barCls + '-overwork';
                }
                // get user provided data
                var userData = this.barRenderer(resourceId, bar, tplItem);
                // if CSS classes provided combine them w/ the panel defined ones
                if (userData && userData.cls) {
                    userData.cls = tplItem.cls + ' ' + userData.cls;
                }
                tplItem = Ext.apply(tplItem, userData);
                tplData.push(tplItem);
            }
        }
        return tplData;
    },
    getAvailableRowHeight: function() {
        return this.rowHeight - this.cellTopBorderWidth - this.cellBottomBorderWidth;
    },
    /**
     * Returns the allocation data for a DOM element
     * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
     * @return {Object} Allocation data
     * @return {Date} return.startDate Allocation start date
     * @return {Date} return.endDate Allocation end date
     * @return {Gnt.model.Assignment[]} return.assignments Assignments for this allocation
     * @return {Number} return.allocationMS Resource allocation time in milliseconds
     * @return {Number} return.totalAllocation Resource allocation in percents
     * @return {Gnt.model.Resource} return.resource Resource record
     */
    resolveEventRecord: function(el) {
        var node = this.findItemByChild(el);
        if (node) {
            var resource = this.getRecord(node);
            if (resource) {
                var result = {
                        resource: resource
                    };
                var data = this.histogram.allocationData[resource.getId()];
                var index = el.getAttribute('gnt-bar-index');
                var bar = data.bars[index];
                if (bar) {
                    result.startDate = bar.startDate;
                    result.endDate = bar.endDate;
                    result.assignments = bar.assignments;
                    result.allocationMS = bar.allocationMS;
                    result.totalAllocation = bar.totalAllocation;
                }
                return result;
            }
        }
        return null;
    },
    resolveEventRecordFromResourceRow: function(el) {
        return this.resolveEventRecord(el);
    },
    getDataForTooltipTpl: function(record) {
        return record;
    }
});

/**

@class Gnt.panel.ResourceHistogram
@extends Sch.panel.TimelineGridPanel

A histogram panel, which allows you to visualize resource utilization and highlight overallocation.
The panel is a subclass of the Ext.grid.Panel class so any normal grid configs can be applied to it.

#Two ways of using

You can either use this widget as a standalone panel or it can be used together with a {@link Gnt.panel.Gantt gantt panel}.
When using it together with a {@link Gnt.panel.Gantt gantt panel} you need to specify its instance as the {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} config.

#Predefined columns

The panel has a default set of columns which is used if no `columns` config has been specified.
The default columns include a resource name column and a {@link Gnt.column.Scale scale column} to display a resource utilization scale.

For example in the following code snippet, the histogram will be created with a default set of columns:

    var histogram = Ext.create('Gnt.panel.ResourceHistogram', {
        taskStore           : taskStore,
        resourceStore       : resourceStore,
        viewPreset          : 'weekAndDayLetter',
        startDate           : new Date(2010, 0, 11),
        endDate             : new Date(2010, 1, 11),
        renderTo            : Ext.getBody()
    });


{@img gantt/images/histogram-panel.png}

*/
Ext.define('Gnt.panel.ResourceHistogram', {
    extend: 'Sch.panel.TimelineGridPanel',
    requires: [
        'Ext.XTemplate',
        'Sch.util.Date',
        'Sch.plugin.NonWorkingTime',
        'Gnt.column.Scale',
        'Gnt.view.ResourceHistogram'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.resourcehistogram',
    viewType: 'resourcehistogramview',
    layout: 'border',
    preserveScrollOnRefresh: true,
    /**
     * @cfg {Ext.XTemplate} barTpl The template used to render the bars in the histogram view.
     *
     * When specifying a custom template please make sure that the bar element must have:
     *
     *  - unique `id` attribute, like this: ... id="{id}" ...
     *  - `gnt-bar-index` attribute defined this way: ... gnt-bar-index="{index}" ...
     *  - support for {@link #barCls} config.
     *  - support bar labels
     *
     * Please take a look at the default markup of this template to see an example of how the above restrictions can be applied:
     *
     *      this.barTpl = new Ext.XTemplate(
     *          '<tpl for=".">',
     *              '<div id="{id}" class="gnt-resourcehistogram-bar '+ (this.barCls || '') +' {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">',
     *                  '<tpl if="text !== \'\'">',
     *                      '<span class="gnt-resourcehistogram-bar-text" style="bottom:' + Math.floor(this.rowHeight/2) + 'px">{text}</span>',
     *                  '</tpl>',
     *              '</div>',
     *          '</tpl>'
     *      );
     *
     * See {@link Ext.XTemplate} for more information on templates syntax.
     */
    /**
     * @cfg {Function} barRenderer When provided this function creates a data object for {@link #barTpl} template.
     *
     *
     *      Ext.create('Gnt.panel.ResourceHistogram', {
     *          crudManager     : crudManager,
     *          viewPreset      : 'weekAndDayLetter',
     *          height          : 300,
     *          width           : 500,
     *          renderTo        : Ext.getBody(),
     *
     *          barTpl          : new Ext.XTemplate(
     *                              '<tpl for=".">',
     *                                  '<div id="{id}" class="gnt-resourcehistogram-bar {cls}" gnt-bar-index="{index}" style="left:{left}px;top:{top}px;height:{height}px;width:{width}px">',
     *                                      '<span class="gnt-resourcehistogram-bar-text" style="bottom:20px">{text}<br>{taskName}</span>',
     *                                  '</div>',
     *                              '</tpl>'
     *                            ),
     *
     *          barRenderer     : function (resourceId, allocationData, tplData) {
     *              var task = allocationData.assignments[0].getTask();
     *
     *              return {
     *                  taskName : task.getName(),
     *                  cls      : 'foo' // provide a custom CSS class for a histogram bar
     *              };
     *          }
     *      });
     *
     *
     * @param {Number} resourceId Id of the current resource
     *
     * @param {Object} allocationData
     * @param {Data} allocationData.startDate Bar start date
     * @param {Data} allocationData.endDate Bar end date
     * @param {Int} allocationData.allocationMS Duration of rendering bar
     * @param {Number} allocationData.totalAllocation Allocation of resource in percent
     * @param {Gnt.model.Assignment[]} allocationData.assignments Assignments for current resource
     *
     * @return {Object} Specify properties you would like to use in your {@link #barTpl template}
     */
    /**
     * @cfg {String} barCls The CSS class to apply to rendered bars in the histogram view.
     * This can be used if you want to implement your own bar styling.
     */
    /**
     * @cfg {Ext.XTemplate} lineTpl The template used to render the scale line in the histogram view.
     */
    /**
     * @cfg {String} lineCls The CSS class to apply to scale lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */
    /**
     * @cfg {Ext.XTemplate} limitLineTpl The template used to render the maximum resource utilization line in the histogram view.
     */
    /**
     * @cfg {String} limitLineCls The CSS class to apply to the maximum resource utilization lines in the histogram view.
     * This can be used if you want to implement your own line styling.
     */
    /**
     * @cfg {Number} limitLineWidth The width of the maximum resource utilization line. Used for the line coordinates calculations.
     * Should be specified only if the width of that utilization line was changed as result of any custom styling.
     */
    /**
     * @cfg {Mixed} labelMode Defines the type of scale labels to be used or disables labels completely.
     * Possible values are:
     *
     *  - empty string or `false` to disable labels (default).
     *  - `units` - displays the per day allocation in {@link #scaleUnit units}.
     *  - `percent` - displays the per day allocation in percents.
     *  - any other non-empty value will be considered as compiled `Ext.XTemplate` instance.
     */
    /**
     * @cfg {String} labelPercentFormat Defines the label format to use when the {@link #labelMode} is set to `percent`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */
    /**
     * @cfg {String} labelUnitsFormat Defines the label format to use when the {@link #labelMode} is set to `units`.
     *
     * For more details on format usage please refer to the `Ext.util.Format.number` method description.
     */
    /**
     * @cfg {Object[]} scalePoints Alternative way of defining the utilization scale.
     * Can be used instead of setting {@link #scaleMin}, {@link #scaleMax}, {@link #scaleStep} configs.
     * When using the default columns, this config will be applied to the {@link Gnt.column.Scale} instance.
     *
     * For usage details please refer to the {@link Gnt.column.Scale#scalePoints scalePoints} property.
     */
    /**
     * @cfg {Boolean} showScaleLines Whether to show scale lines or not.
     */
    showScaleLines: false,
    /**
     * @cfg {Boolean} showLimitLines
     * Whether to show maximum resource allocation lines or not.
     * See {@link #showVerticalLimitLines} to disable vertical segments of the lines drawing.
     */
    showLimitLines: true,
    /**
     * @cfg {Number} showLimitLinesThreshold Sets the histogram to show maximum resource allocation lines only wider than specified width in pixels.
     * This option allows to get rid of redundant details during zooming out (which also implicitly raises performance).
     * When line has smaller size than the provided value the histogram will merge it with neighbor segments and approximate its level.
     * Use {@link #showLimitLines} to completely disable resource allocation lines rendering.
     */
    showLimitLinesThreshold: 10,
    /**
     * @cfg {Boolean} showVerticalLimitLines
     * Set this to false to not render vertical segments of maximum resource allocation lines.
     * This implicitly raises performance due to reducing the number of DOM elements being generated.
     */
    showVerticalLimitLines: true,
    cacheLimitDurationMS: 0,
    /**
     * @cfg {Number} cacheLimitDuration Combined with {@link #cacheLimitDurationUnit} forces cache to hold only data
     * for visible time span and {@link #cacheLimitDuration} number of {@link #cacheLimitDurationUnit units} to the left/right from it.
     *
     * **Note:** Does not limit the cache size when set to zero `0`.
     */
    cacheLimitDuration: 6,
    /**
     * @cfg {String} cacheLimitDurationUnit Combined with {@link #cacheLimitDuration} forces cache to hold only data
     * for visible time span and {@link #cacheLimitDuration} number of units to the left/right from it.
     */
    cacheLimitDurationUnit: 'mo',
    calendarResources: null,
    calendarListenersHash: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar A {@link Gnt.data.Calendar calendar} instance for the histogram panel. Can be also provided
     * as a {@link Gnt.data.TaskStore#calendar configuration option} of the `taskStore`.
     *
     * **Please note,** that this option is required if the {@link #taskStore} option is not specified.
     */
    calendar: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore The {@link Gnt.data.TaskStore store} holding the tasks.
     * When using this option, the histogram will instantly reflect any changes made to a task.
     *
     * **Please note,** that this option is required if the {@link #calendar} option is not specified.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore The {@link Gnt.data.ResourceStore store} holding the resources to be rendered into the histogram (required).
     *
     * See also {@link Gnt.model.Resource}
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore The {@link Gnt.data.AssignmentStore store} holding the assignments information (optional).
     *
     * If not specified, it will be taken from the {@link #resourceStore} or {@link #taskStore}.
     *
     * See also {@link Gnt.model.Assignment}
     */
    assignmentStore: null,
    /**
     * @cfg {Date} startDate Defines the start date of this panel.
     *
     * **Note:** This option is **required** if a {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} is not specified.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate Defines the end date of this panel.
     *
     * **Note:** This option is **required** if a {@link Sch.mixin.TimelinePanel#partnerTimelinePanel partnerTimelinePanel} is not specified.
     */
    endDate: null,
    highlightWeekends: true,
    allocationData: null,
    /**
     * @cfg {String} scaleUnit Name of the resource utilization scale unit. `Sch.util.Date` constants can be used, like `Sch.util.Date.HOUR`.
     */
    scaleUnit: 'HOUR',
    /**
     * @cfg {Number} scaleMin Minimum for the resource utilization scale (required).
     */
    scaleMin: 0,
    /**
     * @cfg {Number} scaleMax Maximum for the resource utilization scale.
     *
     * **Note:** this option is **required** except in cases when you use {@link #scalePoints} to define utilization scale.
     */
    scaleMax: 24,
    /**
     * @cfg {Number} scaleLabelStep Defines the interval between two adjacent scale lines which have labels.
     * The histogram itself does not render any labels but corresponding lines will get a specific CSS class for styling purposes.
     */
    scaleLabelStep: 4,
    /**
     * @cfg {Number} scaleStep Defines the interval between two adjacent scale lines.
     *
     * **Also,** this value is used as a margin between the top scale line (defined by {@lin #scaleMax} option) and the top border of the cell
     * containing the histogram for a resource.
     */
    scaleStep: 2,
    rowHeight: 50,
    groupAllocationByDay: true,
    /**
     * Class name to be used for the scale column creating
     * @cfg {String} scaleColumnClass
     */
    scaleColumnClass: 'Gnt.column.Scale',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

        - resourceText : 'Resource'
     */
    scaleColumnConfigs: [
        'scalePoints',
        'scaleStep',
        'scaleLabelStep',
        'scaleMin',
        'scaleMax',
        'scaleLabelStep',
        'scaleStep'
    ],
    normalViewConfigs: [
        'barCls',
        'barTpl',
        'barRenderer',
        'lineRenderer',
        'limitLineRenderer',
        'lineTpl',
        'lineCls',
        'limitLineTpl',
        'limitLineCls',
        'limitLineWidth',
        'labelMode',
        'labelPercentFormat',
        'labelUnitsFormat',
        'scaleMin',
        'scaleMax',
        'scaleStep',
        'scaleLabelStep',
        'scalePoints',
        'scaleUnit',
        'loadMask',
        'showLimitLinesThreshold',
        'showVerticalLimitLines',
        'calendar'
    ],
    cacheUpdateSuspended: false,
    suspendedCacheUpdatesCount: 0,
    gapThreshold: 24 * 3600000,
    // 24 hrs
    rowLines: true,
    initComponent: function() {
        // convert "cacheLimitDuration" value to ms
        this.cacheLimitDurationMS = Sch.util.Date.getUnitDurationInMs(this.cacheLimitDurationUnit) * this.cacheLimitDuration;
        // initialize the allocation cache
        this.resetAllocationDataCache();
        // initialize store references
        this.initStores();
        this.lockedGridConfig = Ext.applyIf(this.lockedGridConfig || {}, {
            reserveScrollbar: false,
            width: 300,
            forceFit: true
        });
        this.normalViewConfig = Ext.apply(this.normalViewConfig || {}, {
            histogram: this,
            trackOver: false,
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        this.lockedViewConfig = Ext.apply(this.lockedViewConfig || {}, {
            rowHeight: this.rowHeight,
            preserveScrollOnRefresh: this.preserveScrollOnRefresh
        });
        // if scale was specified by scalePoints
        if (this.scalePoints) {
            this.scalePoints.sort(function(a, b) {
                return a.value > b.value ? 1 : -1;
            });
            this.scaleMin = this.scalePoints[0].value;
            this.scaleMax = this.scalePoints[this.scalePoints.length - 1].value;
            this.scaleStep = (this.scaleMax - this.scaleMin) / 10;
        }
        this.initColumns();
        // transfer some configs to the view instance
        Ext.Array.each(this.normalViewConfigs, function(prop) {
            if (prop in this)  {
                this.normalViewConfig[prop] = this[prop];
            }
            
        }, this);
        this.callParent(arguments);
        var cls = 'gnt-resourcehistogram sch-horizontal ';
        this.addCls(cls);
        // register our renderer
        this.registerRenderer(this.columnRenderer, this);
        var view = this.getSchedulingView();
        this.relayEvents(view, [
            /**
            * @event barclick
            * Fires when a histogram bar is clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing a description of the clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barclick',
            /**
            * @event bardblclick
            * Fires when a histogram bar is double clicked
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'bardblclick',
            /**
            * @event barcontextmenu
            * Fires when contextmenu is activated on a histogram bar
            *
            * @param {Gnt.view.ResourceHistogram} view The histogram panel view.
            * @param {Object} context Object containing description of clicked bar.
            * @param {Gnt.model.Resource} context.resource The resource record.
            * @param {Date} context.startDate Start date of corresponding period.
            * @param {Date} context.endDate End date of corresponding period.
            * @param {Number} context.allocationMS Resource allocation time in milliseconds.
            * @param {Number} context.totalAllocation Resource allocation (in percents).
            * @param {Gnt.model.Assignment[]} context.assignments List of resource assignments for the corresponding period.
            * @param {Ext.EventObject} e The event object
            */
            'barcontextmenu'
        ]);
    },
    onRender: function() {
        var scaleCol = this.getScaleColumn();
        if (scaleCol) {
            // before render give scale column information about row height
            scaleCol.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
        }
        this.callParent(arguments);
    },
    initStores: function() {
        var listenersBound = false;
        // if CrudManager is used let's grab store references from it
        if (this.crudManager) {
            this.setCrudManager(this.crudManager);
            // we called bindStores() in setCrudManager() call
            listenersBound = true;
        }
        // resourceStore acts as store for the grid
        this.store = this.resourceStore;
        this.taskStore = this.taskStore || this.store.getTaskStore();
        // get project calendar
        this.calendar = this.calendar || this.taskStore && this.taskStore.getCalendar();
        if (!this.calendar)  {
            throw 'Cannot get project calendar instance: please specify either "calendar" or "taskStore" option';
        }
        
        this.assignmentStore = this.assignmentStore || this.store.getAssignmentStore() || this.taskStore && this.taskStore.getAssignmentStore();
        if (!listenersBound)  {
            this.bindStores();
        }
        
    },
    getCrudManager: function() {
        return this.crudManager;
    },
    setCrudManager: function(crudManager) {
        this.unbindStores();
        // if we set another crud manager unbind from the previous one
        this.crudManagerListeners && this.crudManagerListeners.destroy();
        this.crudManager = crudManager;
        this.taskStore = this.crudManager.getTaskStore();
        this.store = this.resourceStore = this.crudManager.getResourceStore();
        this.assignmentStore = this.crudManager.getAssignmentStore();
        this.crudManagerListeners = this.mon(this.crudManager, {
            beforeloadapply: {
                fn: this.beforeCrudManagerLoad,
                // we want to listen to "beforeloadapply" the last one
                // to have some guarantee that the event is not cancelled
                priority: -999
            },
            load: this.afterCrudManagerLoad,
            destroyable: true,
            scope: this
        });
        this.bindStores();
    },
    beforeCrudManagerLoad: function() {
        // suspend store listeners upon crud manager stores loading
        this.suspendStoreListeners();
    },
    afterCrudManagerLoad: function() {
        // keep showing loading mask
        this.beforeCrudOperationStart(this.crudManager, null, 'load');
        // resume stores listeners and refresh the histogram
        this.resumeStoreListeners(true);
        // hide loading mask
        this.onCrudOperationComplete();
    },
    bindStores: function() {
        if (this.taskStore) {
            this.mon(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                // Ext JS 5: tree store doesn't fire 'refresh' on load completion so we listen to 'load' as well
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdateOrAppend,
                // we listen to append to support twisted case when someone first adds assignment and then adds a task
                nodeappend: this.onTaskUpdateOrAppend,
                scope: this
            });
        }
        if (this.assignmentStore) {
            // on assignments change we update corresponding resource row
            this.mon(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            });
        }
        // track the project calendar changes
        this.calendar && this.mon(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        // bind resource calendars listeners
        this.bindCalendarListeners();
        this.store && this.mon(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        });
    },
    unbindStores: function() {
        if (this.taskStore) {
            this.mun(this.taskStore, {
                refresh: this.onTaskStoreRefresh,
                // EtxJS5: tree store doesn't fire 'refresh' on load completion so we listen to 'load' as well
                load: this.onTaskStoreRefresh,
                update: this.onTaskUpdateOrAppend,
                // we listen to append to support twisted case when someone first adds assignment and then adds a task
                nodeappend: this.onTaskUpdateOrAppend,
                scope: this
            });
        }
        if (this.assignmentStore) {
            // on assignments change we update corresponding resource row
            this.mun(this.assignmentStore, {
                refresh: this.onAssignmentsRefresh,
                remove: this.onAssignmentsChange,
                update: this.onAssignmentUpdate,
                add: this.onAssignmentsChange,
                scope: this
            });
        }
        this.calendar && this.mun(this.calendar, {
            calendarchange: this.onProjectCalendarChange,
            scope: this
        });
        this.unbindCalendarListeners();
        this.store && this.mun(this.store, {
            update: this.onResourceUpdate,
            refresh: this.onResourceStoreRefresh,
            scope: this,
            priority: 100
        });
    },
    /**
     * Suspends the histogram stores listeners. Call this method before massive stores data modifications
     * (like data loading) if you want to speed the histogram up.
     * Use {@link #resumeStoreListeners} to restore store listeners back.
     */
    suspendStoreListeners: function() {
        // set flag to avoid cache updating
        this.cacheUpdateSuspended = true;
        this.suspendedCacheUpdatesCount = 0;
        // unbind stores listeners
        this.unbindStores();
    },
    /**
     * Resumes the histogram stores listeners suspended by {@link #suspendStoreListeners} call.
     * @param {Boolean} [refreshIfAttempted] Pass `true` to refresh the histogram if there were suspended refresh attempts
     */
    resumeStoreListeners: function(refreshIfAttempted) {
        // restore cache recalculations
        this.cacheUpdateSuspended = false;
        // restore listeners
        this.bindStores();
        // refresh if it's asked and there were attempts to update the histogram cache
        if (refreshIfAttempted && this.suspendedCacheUpdatesCount) {
            this.clearCacheAndRefresh();
        }
    },
    // Clears allocation cache for the resource and refreshes corresponding view node
    clearCacheAndRefresh: function(resource) {
        this.resetAllocationDataCache(resource);
        this.refreshIfRendered(resource);
    },
    createDefaultColumns: function() {
        var columns = [],
            scaleCol;
        columns.push({
            flex: 1,
            resizable: false,
            text: this.L('resourceText'),
            dataIndex: this.resourceStore.model.prototype.nameField,
            renderer: Ext.htmlEncode
        });
        scaleCol = {
            width: 40,
            resizable: false,
            availableHeight: this.rowHeight
        };
        // map some scale column configs from this panel
        Ext.copyTo(scaleCol, this, this.scaleColumnConfigs, true);
        scaleCol = this.scaleCol = Ext.create(this.scaleColumnClass, scaleCol);
        // before column render we'll give it information about row height
        scaleCol.on({
            beforerender: function() {
                scaleCol.setAvailableHeight(this.getSchedulingView().getAvailableRowHeight());
                if (this.scalePoints) {
                    // we update scalePoints since it was
                    // filled in with calculated top-coordinates
                    this.scalePoints = scaleCol.scalePoints;
                }
            },
            scope: this
        });
        columns.push(scaleCol);
        return columns;
    },
    initColumns: function() {
        // if no columns provided we'll generate default column set: resource name & scale
        if (!this.columns) {
            this.columns = this.createDefaultColumns();
            var scaleCol = this.scaleCol;
            // if scale was specified by scalePoints let's set params equal to scale column ones
            // since they were calculated there
            if (this.scalePoints) {
                this.scaleMin = scaleCol.scaleMin;
                this.scaleMax = scaleCol.scaleMax;
                this.scaleStep = scaleCol.scaleStep;
            }
        } else // if columns specified we try to find Gnt.column.Scale instances and set its configs
        {
            var columns = !Ext.isArray(this.columns) ? [
                    this.columns
                ] : this.columns;
            for (var i = 0; i < columns.length; i++) {
                var col = columns[i];
                if (this.isScaleColumn(col)) {
                    // map some scale column configs from this panel
                    Ext.copyToIf(col, this, this.scaleColumnConfigs);
                }
            }
        }
    },
    isScaleColumn: function(col) {
        var proto = col.xtype && (Ext.ClassManager.getByAlias('widget.' + col.xtype));
        proto = proto && proto.prototype;
        return (col instanceof Gnt.column.Scale || (proto && proto.isXType('scalecolumn')));
    },
    getScaleColumn: function() {
        return this.lockedGrid.down('scalecolumn');
    },
    destroy: function() {
        this.unbindStores();
        this.callParent(arguments);
    },
    /**
     * Returns the resource store instance
     * @return {Gnt.data.ResourceStore}
     */
    getResourceStore: function() {
        return this.resourceStore;
    },
    /**
     * Returns the assignment store instance
     * @return {Gnt.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.assignmentStore;
    },
    /**
     * Returns the task store instance
     * @return {Gnt.data.TaskStore}
     */
    getEventStore: function() {
        return this.taskStore;
    },
    getTimeSpanDefiningStore: function() {
        return this.taskStore;
    },
    unbindResourceCalendarListener: function(resource, calendarId) {
        var calendarResources = this.calendarResources[calendarId];
        if (calendarResources) {
            Ext.Array.remove(calendarResources, resource);
            // if no more resources left bound to the calendar
            // destroy the calendar listener
            if (!calendarResources.length) {
                this.calendarListenersHash[calendarId].destroy();
                delete this.calendarListenersHash[calendarId];
                delete this.calendarResources[calendarId];
            }
        }
    },
    bindResourceCalendarListener: function(resource) {
        var me = this,
            calendar = resource.getOwnCalendar(),
            calendarId = calendar.getCalendarId();
        // bind new listener to the calendar if it doesn't have it yet
        if (!me.calendarListenersHash[calendarId]) {
            me.calendarListenersHash[calendarId] = me.mon(calendar, {
                // on calendar load/change we'll recalculate allocation data and redraw resource(s) rows
                load: me.onCalendarChange,
                calendarchange: me.onCalendarChange,
                scope: me,
                destroyable: true
            });
        }
        if (!me.calendarResources[calendarId]) {
            me.calendarResources[calendarId] = [
                resource
            ];
        } else if (Ext.Array.indexOf(me.calendarResources, resource) === -1) {
            me.calendarResources[calendarId].push(resource);
        }
    },
    // resource is already bound to this calendar
    bindCalendarListeners: function() {
        var me = this;
        // unbind exisiting listeners (if any)
        me.unbindCalendarListeners();
        me.store.each(function(resource) {
            // if resource has own calendar and it differs from project one
            var calendar = resource.getOwnCalendar();
            if (calendar && calendar !== me.calendar) {
                me.bindResourceCalendarListener(resource);
            }
        });
    },
    unbindCalendarListeners: function() {
        for (var calendarId in this.calendarListenersHash) {
            this.calendarListenersHash[calendarId].destroy();
        }
        // reset array of listeners
        this.calendarResources = [];
        this.calendarListenersHash = {};
    },
    onTaskStoreRefresh: function() {
        this.clearCacheAndRefresh();
    },
    onCalendarChange: function(calendar) {
        var resources = this.calendarResources[calendar.getCalendarId()];
        if (resources) {
            // reset allocation cache and render row for each resource bound to the calendar
            for (var i = 0; i < resources.length; i++) {
                this.clearCacheAndRefresh(resources[i]);
            }
        }
    },
    onProjectCalendarChange: function() {
        this.clearCacheAndRefresh();
    },
    onTaskUpdateOrAppend: function(notUsed, task) {
        var assignments;
        var taskStore = task.getTreeStore();
        if (!taskStore.isSettingRoot && !task.isRoot()) {
            if (this.assignmentStore && task.getAssignmentStore() != this.assignmentStore) {
                assignments = this.assignmentStore.getAssignmentsForTask(task.getId());
            } else {
                assignments = task.getAssignments();
            }
            this.onAssignmentsChange(this.assignmentStore, assignments);
        }
    },
    onAssignmentsRefresh: function(assignmentStore) {
        this.onAssignmentsChange(assignmentStore, assignmentStore.getRange());
    },
    onAssignmentUpdate: function(assignmentStore, assignment, operation, modifiedFieldNames) {
        var me = this,
            resourceIdField = me.assignmentStore.model.prototype.resourceIdField,
            resource;
        if (operation == Ext.data.Model.EDIT) {
            // if the assignment resource has been changed
            if (modifiedFieldNames && Ext.Array.contains(modifiedFieldNames, resourceIdField)) {
                var oldResourceId = assignment.previous[resourceIdField];
                resource = this.resourceStore.getModelById(oldResourceId);
                if (resource) {
                    // resetting previous resource allocation and refresh corresponding row,
                    // resource allocation data will be updated upon row rendering
                    this.clearCacheAndRefresh(resource);
                }
            }
            // invoke refreshing of rows of all the resources associated w/ the assignment
            me.onAssignmentsChange(assignmentStore, [
                assignment
            ]);
        }
    },
    onAssignmentsChange: function(assignmentStore, assignments) {
        var me = this,
            resource;
        if (!Ext.isArray(assignments))  {
            assignments = [
                assignments
            ];
        }
        
        // for each provided assignment
        for (var i = 0,
            l = assignments.length; i < l; i++) {
            // get assigned resource
            resource = me.resourceStore.getModelById(assignments[i].getResourceId());
            // this might be called as result of resource calendar change
            // if task(s) get realigned, but we don't need this since the histogram also listens
            // to calendar changes and updates resource rows accordingly.
            // So here we skip resources that are in the middle of reacting on their calendar change
            if (resource && !resource.inOnCalendarChange) {
                // resetting resource allocation and refresh corresponding row,
                // resource allocation data will be updated upon row rendering
                me.clearCacheAndRefresh(resource);
            }
        }
    },
    findEndIndex: function(array, endDate) {
        endDate = endDate || this.getEndDate();
        var result = array.length - 1;
        for (var i = result; i >= 0; i--) {
            if (array[i].startDate < endDate) {
                result = i;
                break;
            }
        }
        return result;
    },
    findStartIndex: function(array, startDate) {
        startDate = startDate || this.getStartDate();
        var result = 0;
        for (var i = 0,
            l = array.length; i < l; i++) {
            if (array[i].endDate > startDate) {
                result = i;
                break;
            }
        }
        return result;
    },
    resetAllocationDataCache: function(resource) {
        var me = this;
        if (!resource) {
            me.allocationData = {};
        } else {
            me.allocationData = me.allocationData || {};
            me.allocationData[resource.getId()] = null;
        }
    },
    constrainAllocationDataCache: function(allocData) {
        var me = this,
            // minimum allowed cached date
            cacheMinStartDate = new Date(me.timeAxis.getStart() - this.cacheLimitDurationMS),
            // maximum allowed cached date
            cacheMaxEndDate = new Date(me.timeAxis.getEnd() - 0 + this.cacheLimitDurationMS),
            maxBarsLastIndex = allocData.maxBars.length - 1,
            maxBarsFirstIndex = 0,
            barsLastIndex = allocData.bars.length - 1,
            barsFirstIndex = 0,
            trimCache = false;
        // if right cache border violates its allowed maximum
        if (allocData.cacheEnd > cacheMaxEndDate) {
            maxBarsLastIndex = me.findEndIndex(allocData.maxBars, cacheMaxEndDate);
            barsLastIndex = me.findEndIndex(allocData.bars, cacheMaxEndDate);
            allocData.cacheEnd = cacheMaxEndDate;
            trimCache = true;
        }
        // if left cache border violates its allowed minimum
        if (allocData.cacheStart < cacheMinStartDate) {
            maxBarsFirstIndex = me.findStartIndex(allocData.maxBars, cacheMinStartDate);
            barsFirstIndex = me.findStartIndex(allocData.bars, cacheMinStartDate);
            allocData.cacheStart = cacheMinStartDate;
            trimCache = true;
        }
        // truncate caches if needed
        if (trimCache) {
            allocData.maxBars = Ext.Array.splice(allocData.maxBars, maxBarsFirstIndex, maxBarsLastIndex + 1 - maxBarsFirstIndex);
            allocData.bars = Ext.Array.splice(allocData.bars, barsFirstIndex, barsLastIndex + 1 - barsFirstIndex);
        }
        return trimCache;
    },
    updateAllocationDataCache: function(resource, start, end) {
        var DATE = Sch.util.Date,
            me = this,
            allocData, cacheStart, cacheEnd, left, right;
        if (me.cacheUpdateSuspended) {
            me.suspendedCacheUpdatesCount++;
            return;
        }
        start = start || me.getStartDate();
        end = end || me.getEndDate();
        if (!resource) {
            me.resourceStore.each(function(resource) {
                me.updateAllocationDataCache(resource, start, end);
            });
        } else {
            // Update resource cache
            allocData = me.allocationData[resource.getId()] || {};
            cacheStart = allocData.cacheStart;
            cacheEnd = allocData.cacheEnd;
            // check if update is needed at all
            if (cacheStart != start || cacheEnd != end) {
                // if we already have cached allocation data for required span or part of it
                if (cacheStart && cacheEnd && DATE.intersectSpans(cacheStart, cacheEnd, start, end)) {
                    // new span starts earlier, calculate missing allocation
                    if (cacheStart > start) {
                        left = me.processAllocationData(resource.getAllocationInfo({
                            startDate: start,
                            endDate: cacheStart,
                            includeResCalIntervals: true
                        }));
                        // there can be an extra max bar element for span end, that we don't need
                        if (left.maxBars.length) {
                            if (left.maxBars[left.maxBars.length - 1].startDate.getTime() === cacheStart.getTime()) {
                                // extra max bar can appear after merge
                                left.maxBars.pop();
                            }
                        }
                        // we don't split allocation bar element to avoid inconsistency
                        // if last new allocation element is a subset of first cached - we can drop it because it's cached
                        if (left.bars.length && allocData.bars.length) {
                            var lastNewBar = left.bars[left.bars.length - 1];
                            var firstOldBar = allocData.bars[0];
                            if (lastNewBar.startDate >= firstOldBar.startDate && lastNewBar.endDate <= firstOldBar.endDate) {
                                left.bars.pop();
                            }
                        }
                        // clue to previous cache borders
                        left.maxBars.length && (left.maxBars[left.maxBars.length - 1].endDate = cacheStart);
                        allocData.maxBars.length && (allocData.maxBars[0].startDate = cacheStart);
                        // insert missing allocation data to the allocation cache beginning
                        allocData.bars = left.bars.concat(allocData.bars);
                        allocData.maxBars = left.maxBars.concat(allocData.maxBars);
                        // visible span starts from the very first cached item
                        allocData.maxBarsStartIndex = 0;
                        allocData.barsStartIndex = 0;
                        allocData.cacheStart = start;
                    }
                    // new span ends later, calculate trailing allocation
                    if (cacheEnd < end) {
                        right = me.processAllocationData(resource.getAllocationInfo({
                            startDate: cacheEnd,
                            endDate: end,
                            includeResCalIntervals: true
                        }));
                        // there can be an extra max bar element that we don't need
                        if (right.maxBars.length) {
                            var firstBar = right.maxBars[0];
                            if (firstBar.endDate.getTime() === cacheEnd.getTime()) {
                                // extra max bar can appear after merge
                                right.maxBars.shift();
                            } else {
                                firstBar.startDate = cacheEnd;
                            }
                        }
                        // we don't split allocation bar element to avoid inconsistency
                        // if first new allocation element is a subset of last cached - we can drop it because it's cached
                        if (right.bars.length && allocData.bars.length) {
                            var firstNewBar = right.bars[0];
                            var lastOldBar = allocData.bars[allocData.bars.length - 1];
                            if (firstNewBar.startDate >= lastOldBar.startDate && firstNewBar.endDate <= lastOldBar.endDate) {
                                right.bars.shift();
                            }
                        }
                        right.maxBars.length && (right.maxBars[right.maxBars.length - 1].endDate = end);
                        allocData.maxBars.length && (allocData.maxBars[allocData.maxBars.length - 1].endDate = cacheEnd);
                        allocData.bars = allocData.bars.concat(right.bars);
                        allocData.maxBars = allocData.maxBars.concat(right.maxBars);
                        allocData.maxBarsEndIndex = allocData.maxBars.length - 1;
                        allocData.barsEndIndex = allocData.bars.length - 1;
                        allocData.cacheEnd = end;
                    }
                    // constrain cached data if needed
                    if (me.cacheLimitDuration > 0) {
                        me.constrainAllocationDataCache(allocData);
                    }
                    // update indexes of first/last visible cache elements
                    allocData.maxBarsStartIndex = me.findStartIndex(allocData.maxBars, start);
                    allocData.barsStartIndex = me.findStartIndex(allocData.bars, start);
                    allocData.maxBarsEndIndex = me.findEndIndex(allocData.maxBars, end);
                    allocData.barsEndIndex = me.findEndIndex(allocData.bars, end);
                } else // if new timespan does not intersect the cached one data
                {
                    allocData = me.processAllocationData(resource.getAllocationInfo({
                        startDate: start,
                        endDate: end,
                        includeResCalIntervals: true
                    }));
                    // we completely replace cache so indexes have to wrap whole arrays
                    allocData.maxBarsStartIndex = 0;
                    allocData.maxBarsEndIndex = allocData.maxBars.length - 1;
                    allocData.barsStartIndex = 0;
                    allocData.barsEndIndex = allocData.bars.length - 1;
                    allocData.cacheStart = start;
                    allocData.cacheEnd = end;
                }
            }
            me.allocationData[resource.getId()] = allocData;
        }
    },
    // Another set of task started
    isBarAssignmentsChanged: function(context) {
        var bar = context.bar,
            period = context.period;
        if (!bar.assignments || !period.inResourceCalendar || !period.totalAllocation || !period.inTasksCalendar)  {
            return false;
        }
        
        for (var i = 0,
            l = bar.assignments.length; i < l; i++) {
            if (period.assignmentsHash[bar.assignments[i].getTaskId()])  {
                return false;
            }
            
        }
        // no intersection with previous set of tasks
        return true;
    },
    // Opens new bar
    openBar: function(openDate, context) {
        if (this.groupAllocationByDay) {
            context.bar = {
                startDate: openDate,
                totalAllocation: context.totalAllocation,
                allocationMS: context.allocationMS,
                assignments: context.period.assignments,
                totalOverAllocationMS: context.totalOverAllocationMS
            };
        } else {
            context.bar = {
                startDate: openDate,
                totalAllocation: context.period.totalAllocation,
                allocationMS: context.period.totalAllocationMS,
                assignments: context.period.assignments,
                totalOverAllocationMS: context.period.totalOverAllocationMS || 0
            };
        }
        context.barOpened = true;
        return context.bar;
    },
    // Closes histogram bar
    closeBar: function(closeDate, context) {
        if (!context.barOpened)  {
            return false;
        }
        
        if (closeDate)  {
            context.bar.endDate = closeDate;
        }
        
        context.bars.push(context.bar);
        context.barOpened = false;
    },
    splitBar: function(closeDate, context, openDate) {
        this.closeBar(closeDate, context);
        return this.openBar(openDate || closeDate, context);
    },
    // Appends zero level limit line
    appendZeroMaxBars: function(fromDate, toDate, context) {
        if (!fromDate)  {
            return false;
        }
        
        var me = this,
            diff = Sch.util.Date.getDurationInDays(fromDate, toDate);
        if (diff < 2)  {
            return false;
        }
        
        var add = true,
            maxBar = context.maxBar,
            maxBars = context.maxBars;
        // if there is a previous level line
        if (maxBar) {
            if (!maxBar.allocationMS) {
                add = false;
            } else // and it's not zero
            {
                // let's close it
                maxBar.endDate = Sch.util.Date.getStartOfNextDay(fromDate, true);
                maxBars.push(maxBar);
            }
        }
        if (add) {
            // ..and start new line with zero level
            context.maxBar = {
                startDate: maxBar && maxBar.endDate || me.getStart(),
                allocationMS: 0
            };
        }
        // update last calculated allocation limit
        context.maxAllocationMS = 0;
        return context.maxBar;
    },
    // By default we sum up allocations per day.
    // So here we just trim time part to get period start by date
    getPeriodDay: function(date, period, context) {
        return this.getMergePeriodStart.apply(this, arguments);
    },
    getMergePeriodStart: function(date, period, context) {
        return Ext.Date.clearTime(date, true);
    },
    getTotalAllocationAverage: function(values) {
        var result = 0,
            totalDuration = 0;
        Ext.Array.each(values, function(item) {
            result += item.totalAllocation * item.duration;
            totalDuration += item.duration;
        });
        result /= totalDuration;
        return result;
    },
    // This function processes report made by resource.getAllocationInfo() method and build arrays of
    // histogram bars and levels of max resource allocation.
    // Returns:
    //      {
    //        bars: [], // array of histogram bars
    //        maxBars: [] // levels of max resource allocation
    //      }
    processAllocationData: function(data) {
        var period, bar, maxBar, prevPeriodStart, closeDate, openDate, allocationMS, prevAllocationMS, maxAllocationMS, prevMaxAllocationMS, totalOverAllocationMS, prevTotalOverAllocationMS, totalAllocation, totalAllocationChanged,
            bars = [],
            maxBars = [],
            me = this,
            context = {
                bars: bars,
                maxBars: maxBars
            };
        // if there's nothing to process
        if (!data || !data.length)  {
            return context;
        }
        
        var newPeriodStart = me.getPeriodDay(data[0].startDate, data[0]);
        if (this.showLimitLines && newPeriodStart > this.getStartDate()) {
            maxBars.push({
                startDate: this.getStartDate(),
                endDate: newPeriodStart,
                allocationMS: 0
            });
        }
        for (var i = 0,
            l = data.length; i < l; i++) {
            period = data[i];
            newPeriodStart = me.getPeriodDay(period.startDate, period, context);
            context.period = period;
            // if it's 1st period of a new day
            if (me.groupAllocationByDay && newPeriodStart - prevPeriodStart !== 0) {
                // if there is a gap between working days in resource calendar
                // we need to fill it with zero level lines
                if (this.showLimitLines) {
                    if (me.appendZeroMaxBars(prevPeriodStart, newPeriodStart, context)) {
                        maxBar = context.maxBar;
                    }
                }
                prevPeriodStart = newPeriodStart;
                prevAllocationMS = context.allocationMS;
                prevTotalOverAllocationMS = context.totalOverAllocationMS;
                prevMaxAllocationMS = context.maxAllocationMS;
                // reset allocation time counters
                allocationMS = 0;
                totalOverAllocationMS = 0;
                maxAllocationMS = 0;
                totalAllocation = 0;
                totalAllocationChanged = false;
                var j = i;
                var totalAllocationValues = [];
                // let's calculate allocation time for the period
                while (data[j] && me.getPeriodDay(data[j].startDate, data[j], context) - newPeriodStart === 0) {
                    // if it's working time according to resource calendar
                    if (data[j].inResourceCalendar) {
                        // increment maximum possible resource allocation time
                        maxAllocationMS += data[j].endDate - data[j].startDate;
                        // if it's working time and task is in progress
                        if (data[j].totalAllocationMS) {
                            // increment allocation time
                            allocationMS += data[j].totalAllocationMS;
                            totalOverAllocationMS += data[j].totalOverAllocationMS || 0;
                            if (!totalAllocationChanged && totalAllocation && totalAllocation != data[j].totalAllocation) {
                                totalAllocationChanged = true;
                            }
                            totalAllocationValues.push({
                                totalAllocation: data[j].totalAllocation,
                                duration: data[j].endDate - data[j].startDate
                            });
                            totalAllocation = data[j].totalAllocation;
                        }
                    }
                    j++;
                }
                if (totalAllocationChanged) {
                    totalAllocation = me.getTotalAllocationAverage(totalAllocationValues);
                }
                context.allocationMS = allocationMS;
                context.totalOverAllocationMS = totalOverAllocationMS;
                context.maxAllocationMS = maxAllocationMS;
                context.totalAllocation = totalAllocation;
            } else {
                newPeriodStart = false;
            }
            me.onProcessAllocationDataIterateFn && me.onProcessAllocationDataIterateFn(context);
            // if we need to render limit lines
            if (me.showLimitLines) {
                // here we trace resource max available allocation changes
                if (newPeriodStart && maxAllocationMS != prevMaxAllocationMS) {
                    // on change we close existing line
                    if (maxBar) {
                        maxBar.endDate = newPeriodStart;
                        maxBars.push(maxBar);
                    }
                    // ..and start new one with new allocationMS value
                    maxBar = context.maxBar = {
                        startDate: newPeriodStart,
                        allocationMS: maxAllocationMS
                    };
                }
                // update end of max available allocation line
                maxBar.endDate = period.endDate;
            }
            // if no bar opened
            if (!context.barOpened) {
                // if period belongs to some task(s)
                // need to open new bar
                if (period.inTask) {
                    bar = me.openBar(new Date(period.startDate), context);
                }
            }
            // bar opened & task is finished
            // need to close opened bar
            else if (!period.inTask) {
                me.closeBar(null, context);
            } else // bar opened & task in progress
            {
                var splitBar = false;
                // if all the tasks got ended ..and new set of tasks has started
                if (me.isBarAssignmentsChanged(context)) {
                    closeDate = bar.endDate;
                    openDate = new Date(period.startDate);
                    splitBar = true;
                }
                // if there is a gap we need to close old bar and start new one
                // ("gap" is when we have no periods during day before newPeriodStart)
                else if (newPeriodStart && newPeriodStart - bar.endDate >= me.gapThreshold) {
                    // close bar at midnight after bar.endDate
                    closeDate = Ext.Date.clearTime(bar.endDate, true);
                    if (closeDate < bar.endDate) {
                        closeDate = Sch.util.Date.add(closeDate, Sch.util.Date.DAY, 1);
                    }
                    // open new bar at midnight before period.startDate
                    openDate = Ext.Date.clearTime(period.startDate, true);
                    splitBar = true;
                }
                // if day allocation has changed (due to calendars)
                else if (newPeriodStart && allocationMS !== prevAllocationMS && period.totalAllocation) {
                    closeDate = openDate = Ext.Date.clearTime(period.startDate, true);
                    splitBar = true;
                }
                // let's update the current bar assignments
                // otherwise isBarAssignmentsChanged() above won't be able
                // to track changes properly
                bar.assignments = context.period.assignments;
                if (splitBar) {
                    me.closeBar(closeDate, context);
                    bar = me.openBar(openDate, context);
                } else if (!me.groupAllocationByDay) {
                    context.allocationMS += period.totalAllocationMS;
                    context.totalOverAllocationMS += period.totalOverAllocationMS || 0;
                    context.maxAllocationMS += period.endDate - period.startDate;
                    context.totalAllocation = period.totalAllocation;
                }
            }
            // if we have opened bar
            if (context.barOpened) {
                // update its end date
                bar.endDate = period.endDate;
            }
        }
        // close bar if task goes after timeline end
        me.closeBar(null, context);
        // if we need to render limits lines
        if (me.showLimitLines) {
            // if there is a gap between working days in resource calendar
            // we need to fill it with zero level lines
            if (me.appendZeroMaxBars(prevPeriodStart || me.getStart(), me.getEnd(), context)) {
                maxBar = context.maxBar;
            }
            // push last line to lines array
            if (maxBar) {
                maxBars.push(maxBar);
            }
        }
        me.onProcessAllocationDataFinalizeFn && me.onProcessAllocationDataFinalizeFn(context);
        return {
            bars: bars,
            maxBars: maxBars
        };
    },
    onResourceUpdate: function(store, resource, operation, changedFieldNames) {
        // if calendar on resource was changed
        if (Ext.Array.indexOf(changedFieldNames, resource.calendarIdField) > -1) {
            // setting allocation data for resource it will be updated upon next resource row rendering
            // which should happen as the result of update
            this.resetAllocationDataCache(resource);
            // unbind old listeners from resource calendar
            var oldCalendarId = resource.previous[resource.calendarIdField];
            this.unbindResourceCalendarListener(resource, oldCalendarId);
            // if new resource calendar differs from the project one
            var calendar = resource.getOwnCalendar();
            if (calendar && calendar !== this.calendar) {
                // bind listener on it
                this.bindResourceCalendarListener(resource);
            }
        }
    },
    onResourceStoreRefresh: function() {
        var me = this;
        // Reset all allocations data and refresh view
        me.clearCacheAndRefresh();
        // bind listeners to resources calendars
        me.bindCalendarListeners();
    },
    refreshIfRendered: function(resource) {
        var me = this;
        if (me.rendered && me.resourceStore && resource) {
            var index = me.resourceStore.indexOf(resource);
            if (index >= 0) {
                me.getView().refreshNode(index);
            }
        } else if (me.rendered) {
            me.refreshViews();
        }
    },
    columnRenderer: function(val, meta, resource, rowIndex, colIndex) {
        var me = this,
            resourceId = resource.getId(),
            view = this.normalGrid.getView(),
            data, bars, maxBars;
        // The method is protected against unneeded recalculation
        me.updateAllocationDataCache(resource);
        data = me.allocationData[resourceId];
        bars = data && data.bars;
        maxBars = data && data.maxBars;
        // if visible window for the histogram bars is less than all cached bars
        // let's cut this array to pass only related data
        if (bars && (data.barsStartIndex > 0 || data.barsEndIndex < bars.length - 1)) {
            bars = bars.slice(data.barsStartIndex, data.barsEndIndex + 1);
        }
        // if visible window for the resource limit lines is less than all cached limit lines info
        // let's cut this array to pass only related data
        if (maxBars && (data.maxBarsStartIndex > 0 || data.maxBarsEndIndex < maxBars.length - 1)) {
            maxBars = maxBars.slice(data.maxBarsStartIndex, data.maxBarsEndIndex + 1);
        }
        // changed, rowHeight must be matched in css '.' + Ext.baseCSSPrefix + '-grid-cell-inner'
        //meta.style = 'height:' + this.getSchedulingView().getAvailableRowHeight() + 'px';
        // render: scale lines (if requested),
        return (me.showScaleLines ? view.renderLines() : '') + // histogram bars,
        view.renderBars(bars, resourceId) + (// max resource allocation line (if requested)
        me.showLimitLines ? view.renderLimitLines(maxBars) : '');
    },
    setRowHeight: function(value, preventRefresh) {}
});
// TODO add support for setting row height

// https://www.sencha.com/forum/showthread.php?306174-Multiple-sources-do-not-really-work
Ext.define('Gnt.patches.AbstractClipboard', {
    extend: 'Sch.util.Patch',
    target: 'Ext.plugin.AbstractClipboard',
    minVersion: '6.0.0',
    overrides: {
        privates: {
            getData: function(erase, format) {
                var me = this,
                    formats = me.getFormats(),
                    data, i, name, names;
                if (Ext.isString(format)) {
                    if (!formats[format]) {
                        Ext.raise('Invalid clipboard format "' + format + '"');
                    }
                    data = me[formats[format].get](format, erase);
                } else {
                    data = {};
                    names = [];
                    if (format) {
                        for (name in format) {
                            if (!formats[name]) {
                                Ext.raise('Invalid clipboard format "' + name + '"');
                            }
                            names.push(name);
                        }
                    } else {
                        names = Ext.Object.getAllKeys(formats);
                    }
                    for (i = names.length; i-- > 0; ) {
                        name = names[i];
                        data[name] = me[formats[name].get](name, erase && !i);
                    }
                }
                return data;
            }
        }
    }
});

//Patch for https://www.sencha.com/forum/showthread.php?469449-EXTJS-6-5-3-Focus-bug-in-spreadsheet-selection-model&p=1316838#post1316838
Ext.define('Gnt.patches.CellContext', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellContext',
    minVersion: '6.2.1',
    overrides: {
        setRow: function(row) {
            if (row === null)  {
                row = undefined;
            }
            
            return this.callParent(arguments);
        },
        setColumn: function(col) {
            if (col === null)  {
                col = undefined;
            }
            
            return this.callParent(arguments);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?324990-Ext-grid-column-Check-not-checking-presence-of-config-variable
Ext.define('Gnt.patches.CheckColumn', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.column.Check',
    minVersion: '6.2.0',
    overrides: {
        constructor: function(config) {
            this.callParent([
                config || {}
            ]);
        },
        // OVERRIDE https://www.sencha.com/forum/showthread.php?470577-Check-column-setDisabled-on-locked-column&p=1320409#post1320409
        _setDisabled: function(disabled) {
            this.callParent(arguments);
            var el = this.up('tablepanel').view.el;
            //HACK ExtJS bug. onDisable fn uses wrong selector
            if (el) {
                var cells = el.select(this.getCellSelector());
                cells[disabled ? 'addCls' : 'removeCls'](this.disabledCls);
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?305868-Ext.util.TSV-decode-goes-infinite-loop
Ext.define('Gnt.patches.DelimitedValue', {
    extend: 'Sch.util.Patch',
    target: 'Ext.util.DelimitedValue',
    minVersion: '6.0.0',
    overrides: {
        decode: function(input) {
            if (input === "") {
                return [];
            }
            return this.callParent(arguments);
        }
    }
});

Ext.define('Gnt.patches.SelectionExtender', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.selection.SelectionExtender',
    minVersion: '6.0.0',
    overrides: {
        // prevent selection extending in normal view
        onDrag: function(e) {
            if (!Ext.fly(e.getTarget()).up('.sch-ganttview')) {
                this.callParent(arguments);
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?300781
Ext.define('Gnt.patches.Tooltip', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tip.ToolTip',
    minVersion: '5.1.0',
    overrides: {
        onDocMouseDown: function() {
            if (this.isDisabled()) {
                return;
            }
            this.callParent(arguments);
        }
    }
});

/**
 * Adds clipboard support to a gantt panel.
 *
 * *Note that the grid must use the {@link Ext.grid.selection.SpreadsheetModel spreadsheet selection model} to utilize this plugin.*
 *
 * This class supports the following `{@link #formats formats}`
 * for grid data:
 *
 *  * `text` - Cell content stripped of HTML tags. Data from clipboard cannot be pasted into gantt in this format.
 *  * `raw` - Underlying field values based on `dataIndex`. Alternatively you can define getRawData/putRawData on
 *  column class to implement any special logic for copying/pasting complex values. For example refer to
 *  {@link Gnt.column.ResourceAssignment#getRawData} and {@link Gnt.column.ResourceAssignment#putRawData}
 *
 * Only `text` format is valid for the `{@link Ext.grid.plugin.Clipboard#system system}`
 * clipboard format.
 */
Ext.define('Gnt.plugin.Clipboard', {
    extend: 'Ext.grid.plugin.Clipboard',
    alias: 'plugin.gantt_clipboard',
    requires: [
        'Gnt.patches.DelimitedValue',
        'Gnt.patches.AbstractClipboard'
    ],
    memory: 'raw',
    formats: {
        raw: {
            get: 'getRawData',
            put: 'putRawData'
        }
    },
    // TODO: implement conversion from visible value to data value
    putTextData: function(data, format) {
        return;
    },
    collectSelectionMeta: function(selection) {
        var result = {};
        selection.eachColumn(function(column) {
            // set flags indicating if some fields are copied
            // TODO: actually this is incorrect generally speaking. This will work only if we copy and paste into the same columns.
            // We need to do this NOT with copied data, but check which fields are pasted in.
            // Since we might copy, for example, baseline dates and paste them into start/end columns.
            switch (true) {
                case column.fieldProperty == 'startDateField':
                    result.startDate = 1;
                    break;
                case column.fieldProperty == 'endDateField':
                    result.endDate = 1;
                    break;
                case column.fieldProperty == 'durationField':
                    result.duration = 1;
                    break;
                case column.fieldProperty == 'constraintDateField':
                    result.constraintDate = 1;
                    break;
                case column.fieldProperty == 'constraintTypeField':
                    result.constraintType = 1;
                    break;
            }
        });
        return result;
    },
    /**
     * Will copy raw values to clipboard
     * @param {String} format Value of {@link #source} config
     * @param {Boolean} erase When true, values in original record will be replaced with field defaults
     */
    getRawData: function(format, erase) {
        var me = this,
            grid = me.getCmp(),
            selModel = me.getCmp().getSelectionModel(),
            ret = [],
            isRaw = format === 'raw',
            isText = format === 'text',
            selected = selModel.getSelected(),
            lastRecord, row,
            processedRecords = [];
        if (!selected)  {
            return ret;
        }
        
        // Embed info about what is being copied
        ret.schedulingFields = me.collectSelectionMeta(selected);
        grid.taskStore.suspendAutoCascade++;
        // selected rows are NOT guaranteed to be unique due to Ext JS bug in eachCell
        selected.eachCell(function(cellContext) {
            var column = cellContext.column,
                view = cellContext.column.getView(),
                record = cellContext.record,
                dataIndex = column.dataIndex,
                data;
            // Ignore columns that we don't want to/cannot copy (check column, row numberer, AddNew, dragcolumn etc.)
            if (!me.isColumnCopyPasteable(column, format)) {
                return;
            }
            // if new record cells started
            if (lastRecord !== record) {
                // Workaround for eachCell duplicating contents
                if (Ext.Array.contains(processedRecords, record))  {
                    return;
                }
                
                lastRecord = record;
                // start new row array
                ret.push(row = []);
                processedRecords.push(record);
            }
            if (isRaw) {
                if (column.getRawData) {
                    data = column.getRawData(record);
                } else if (dataIndex) {
                    data = record.data[dataIndex];
                }
            } else {
                // Try to access the view node.
                var viewNode = view.all.item(cellContext.rowIdx);
                // If we could not, it's because it's outside of the rendered block - recreate it.
                if (!viewNode) {
                    viewNode = Ext.fly(view.createRowElement(record, cellContext.rowIdx));
                }
                var cell = viewNode.down(column.getCellInnerSelector());
                data = cell.dom.innerHTML;
                if (isText) {
                    data = Ext.util.Format.stripTags(data);
                }
            }
            row.push(data);
            if (erase) {
                if (dataIndex) {
                    record.set(dataIndex, record.getField(dataIndex).getDefaultValue());
                } else if (column.eraseData) {
                    column.eraseData(record);
                }
            }
        });
        grid.taskStore.suspendAutoCascade--;
        return ret;
    },
    getCellData: function(format, erase) {
        return Ext.util.TSV.encode(this.getRawData(format, erase));
    },
    // @private
    // Returns if the provided column can be copied or pasted in the provided format
    isColumnCopyPasteable: function(column, format) {
        return !column.ignoreExport && (format != 'raw' || column.dataIndex || column.getRawData);
    },
    shouldSkipColumnPasting: function(column, data) {
        // If start & end date were provided we use setStartEndDateWithoutPropagation() call
        return (data.schedulingFields.hasOwnProperty('startDate') && data.schedulingFields.hasOwnProperty('endDate') && (column.isMilestoneColumn || column.fieldProperty === 'durationField' || column.fieldProperty === 'startDateField' || column.fieldProperty === 'endDateField')) || (// If constraint type & date were provided we use setConstraintWithoutPropagation() call
        data.schedulingFields.hasOwnProperty('constraintDate') && data.schedulingFields.hasOwnProperty('constraintType') && (column.fieldProperty === 'constraintDateField' || column.fieldProperty === 'constraintTypeField')) || // skip "index" column
        column.dataIndex == 'index';
    },
    collectRecordPasteContext: function(context, data, column, value, destination) {
        // if both start & end date values are copied
        if (data.schedulingFields.startDate && data.schedulingFields.endDate) {
            if (column.fieldProperty === 'startDateField') {
                context.start = value;
            } else if (column.fieldProperty === 'endDateField') {
                context.end = column.prepareNewEndDate(value, destination.record);
            }
        }
        // if both constraint date & type are copied
        if (data.schedulingFields.constraintDate && data.schedulingFields.constraintType) {
            if (column.fieldProperty === 'constraintDateField') {
                context.constraintDate = value;
            } else if (column.fieldProperty === 'constraintTypeField') {
                context.constraintType = value;
            }
        }
    },
    /**
     * Will paste values from clipboard
     * @param {Object} data Data to paste
     * @param {String} format Value of {@link #source} config. If clipboard contain some data for few formats - will
     * be called few times during one paste
     */
    putRawData: function(data, format) {
        var me = this,
            recCount = data.length,
            view = me.getCmp().getView(),
            maxRowIdx = view.dataSource.getCount() - 1,
            maxColIdx = view.getVisibleColumnManager().getColumns().length - 1,
            navModel = view.getNavigationModel(),
            destination = navModel.getPosition(),
            destinationStartColumn;
        if (!destination || me.getCmp().isReadOnly())  {
            return;
        }
        
        destination = new Ext.grid.CellContext(view).setPosition(destination.record, destination.column);
        destinationStartColumn = destination.colIdx;
        for (var sourceRowIdx = 0; sourceRowIdx < recCount; sourceRowIdx++) {
            var row = data[sourceRowIdx],
                targetTask = destination.record;
            // skip target record if it's read only
            if (targetTask.isReadOnly())  {
                
                continue;
            }
            
            var dataObject = {},
                context = {};
            // Collect new values in dataObject
            for (var sourceColIdx = 0; destination.colIdx < maxColIdx && sourceColIdx < row.length; ) {
                var currentColumn = destination.column,
                    currentValue = row[sourceColIdx];
                // Ignore columns that we don't want to/cannot copy (check column, row numberer, AddNew, dragcolumn etc.)
                if (me.isColumnCopyPasteable(currentColumn, format)) {
                    me.collectRecordPasteContext(context, data, currentColumn, currentValue, destination);
                    if (!me.shouldSkipColumnPasting(currentColumn, data)) {
                        var field = currentColumn.field,
                            dataIndex = currentColumn.dataIndex;
                        // make sure value is valid and apply it then
                        if (!field || !field.getErrors(currentValue).length) {
                            if (currentColumn.putRawData) {
                                currentColumn.putRawData(currentValue, destination.record);
                            } else if (dataIndex) {
                                dataObject[dataIndex] = currentValue;
                            }
                        }
                    }
                    sourceColIdx++;
                }
                // If we are at the end of the destination row, break the column loop.
                if (destination.colIdx === maxColIdx) {
                    break;
                }
                destination.setColumn(destination.colIdx + 1);
            }
            me.applyChangesToRecord(targetTask, dataObject, context);
            // If we are at the end of the destination store, break the row loop.
            if (destination.rowIdx === maxRowIdx) {
                break;
            }
            // Jump to next row in destination
            destination.setPosition(destination.rowIdx + 1, destinationStartColumn);
        }
    },
    shouldUsePropagation: function(record, data, context) {
        return (context.hasOwnProperty('start') && context.hasOwnProperty('end')) || (context.hasOwnProperty('constraintDate') && context.hasOwnProperty('constraintType'));
    },
    applyDataToRecord: function(record, data, context) {
        record.beginEdit();
        // Update the record in one go.
        record.set(data);
        // setting start + end, need to be done manually
        if (context.hasOwnProperty('start') && context.hasOwnProperty('end')) {
            record.setStartEndDateWithoutPropagation(context.start, context.end);
        }
        if (context.hasOwnProperty('constraintDate') && context.hasOwnProperty('constraintType')) {
            record.setConstraintWithoutPropagation(context.constraintType, context.constraintDate);
        }
        record.endEdit();
    },
    applyChangesToRecord: function(record, data, context) {
        var me = this;
        if (me.shouldUsePropagation(record, data, context)) {
            record.propagateChanges(function applyChangesToRecordChangerFn() {
                me.applyDataToRecord(record, data, context);
                return record;
            });
        } else {
            me.applyDataToRecord(record, data, context);
        }
    }
});

/**
 * {@img gantt/images/dependency-editor.png}
 *
 * A plugin which shows the dependency editor panel, when a user double-clicks a dependency line or arrow.
 *
 * You can add it to your gantt chart like this:
 *
 * ```javascript
 * var gantt = Ext.create('Gnt.panel.Gantt', {
 *     ...
 *     plugins : [
 *         {
 *             ptype      : 'gantt_dependencyeditor',
 *             // hide the editor if clicked outside it
 *             hideOnBlur : true
 *         }
 *     ],
 *     ...
 * })
 * ```
 * ##Customizing fields
 *
 * To customize the fields created by this plugin, override the {@link #buildFields} method.
 *
 * ```javascript
 * Ext.define('MyDependencyEditor', {
 *     extend : 'Gnt.plugin.DependencyEditor',
 *
 *     buildFields : function () {
 *         var fields = this.callParent(arguments);
 *
 *         // add extra "foo" field
 *         fields.push(new Ext.form.NumberField({
 *             name       : 'foo',
 *             fieldLabel : 'Bar'
 *         });
 *
 *         return fields;
 *     }
 * });
 * ```
 */
Ext.define("Gnt.plugin.DependencyEditor", {
    extend: "Ext.form.Panel",
    alias: 'plugin.gantt_dependencyeditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_dependencyeditor',
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    requires: [
        'Ext.data.ArrayStore',
        'Ext.util.Filter',
        'Ext.form.field.Display',
        'Ext.form.field.ComboBox',
        'Gnt.model.Dependency',
        'Gnt.field.Duration'
    ],
    /**
     * @cfg {Boolean} hideOnBlur True to hide this panel if a click is detected outside the panel (defaults to true)
     */
    hideOnBlur: true,
    /**
     * @cfg {Boolean} saveOnEnter True to save the form data and close if ENTER is pressed in one of the input fields inside the panel.
     */
    saveOnEnter: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - fromText         : 'From',
     - toText           : 'To',
     - typeText         : 'Type',
     - lagText          : 'Lag',
     - endToStartText   : 'Finish-To-Start',
     - startToStartText : 'Start-To-Start',
     - endToEndText     : 'Finish-To-Finish',
     - startToEndText   : 'Start-To-Finish',
     - okButtonText     : 'Ok',
     - cancelButtonText : 'Cancel',
     - deleteButtonText : 'Delete'
     */
    /**
     * @cfg {Object/false} lagField
     * Configuration object for the {@link #property-lagField lag editor}.
     *
     * Provide `false` to neither display nor create the {@link #lagField lag editor}.
     */
    /**
     * The {@link Gnt.model.Dependency#Lag lag} editor
     * @property {Gnt.field.Duration} lagField
     */
    lagField: null,
    /**
     * @cfg {Boolean} showLag
     * @deprecated Please use {@link #cfg-lagField} config to hide the {@link #property-lagField lag editor}.
     * `False` to hide the {@link #property-lagField lag editor}
     */
    showLag: true,
    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'dependencydblclick'.
     */
    triggerEvent: 'dependencydblclick',
    /**
     * @cfg {Boolean} constrain
     * Pass `true` to enable the constraining - ie editor panel will not exceed the document edges. This option will disable the animation
     * during the expansion.
     */
    constrain: true,
    lockableScope: 'top',
    // we don't use header at all
    header: false,
    border: false,
    frame: true,
    labelWidth: 60,
    fieldWidth: 280,
    floating: true,
    hideMode: 'offsets',
    bodyPadding: 10,
    model: null,
    initComponent: function() {
        this.defaults = this.defaults || {};
        Ext.applyIf(this.defaults, {
            labelWidth: this.labelWidth,
            width: this.fieldWidth
        });
        this.buttons = this.hasOwnProperty('buttons') ? this.buttons : (this.buttons || [
            {
                text: this.L('okButtonText'),
                itemId: 'okbutton',
                scope: this,
                handler: this.onSaveClick
            },
            {
                text: this.L('cancelButtonText'),
                itemId: 'cancelbutton',
                scope: this,
                handler: function() {
                    this.collapse();
                }
            },
            {
                text: this.L('deleteButtonText'),
                itemId: 'deletebutton',
                scope: this,
                handler: function() {
                    var dependencyStore = this.taskStore && this.taskStore.getDependencyStore();
                    dependencyStore.remove(this.dependencyRecord);
                    this.collapse();
                }
            }
        ]);
        this.callParent(arguments);
        this.saveButton = this.down('#okbutton');
        this.deleteButton = this.down('#deletebutton');
        this.addCls('sch-gantt-dependencyeditor');
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    init: function(cmp) {
        this.ownerCmp = cmp;
        cmp.on(this.triggerEvent, this.onTriggerEvent, this);
        this.gantt = cmp;
        this.taskStore = cmp.getTaskStore();
        // Add fields late, when we have access to taskStore
        this.add(this.buildFields());
    },
    renderAndCollapse: function() {
        this.render(Ext.getBody());
        // Collapse after render, otherwise rendering is messed up
        this.collapse(Ext.Component.DIRECTION_TOP, false);
        this.hide();
        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.on({
                show: function() {
                    this.mon(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    });
                },
                hide: function() {
                    this.mun(Ext.getBody(), {
                        click: this.onMouseClick,
                        scope: this
                    });
                },
                delay: 50
            });
        }
        if (this.saveOnEnter) {
            this.el.on({
                'keyup': function(e, t) {
                    if (e.getKey() === e.ENTER && t.tagName.toLowerCase() === 'input') {
                        this.onSaveClick();
                    }
                },
                scope: this
            });
        }
    },
    /**
     * Expands the editor
     * @param {Gnt.model.Dependency} dependencyRecord The record to show in the editor panel
     * @param {Array} xy the coordinates where the window should be shown
     */
    show: function(dependencyRecord, xy) {
        this.dependencyRecord = dependencyRecord;
        // Load form panel fields
        if (this.lagField) {
            this.lagField.durationUnit = dependencyRecord.getLagUnit();
        }
        this.getForm().loadRecord(dependencyRecord);
        this.fromLabel.setValue(this.dependencyRecord.getSourceTask().getName());
        this.toLabel.setValue(this.dependencyRecord.getTargetTask().getName());
        if (this.typeField) {
            var dependencyStore = this.taskStore && this.taskStore.getDependencyStore(),
                allowedTypes = dependencyStore && dependencyStore.allowedDependencyTypes;
            // filter out disabled dependency types
            this.typeField.store.filter();
            // if number of allowed dependency types is less 2 we won't allow to edit this field
            this.typeField.setReadOnly(allowedTypes && allowedTypes.length < 2);
        }
        this.callParent([]);
        this.el.setXY(xy);
        this.expand(!this.constrain);
        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()));
        }
        this.saveButton && this.saveButton.setVisible(!this.gantt.isReadOnly());
        this.deleteButton && this.deleteButton.setVisible(!this.gantt.isReadOnly());
    },
    onSaveClick: function() {
        if (this.getForm().isValid()) {
            this.doSave();
            this.collapse();
        }
    },
    doSave: function() {
        var me = this,
            data = me.getForm().getValues();
        delete data[me.fromLabel.name];
        delete data[me.toLabel.name];
        if (me.lagField) {
            var duration = me.lagField.getDurationValue() || {
                    value: 0,
                    unit: ''
                };
            data[me.model.lagField] = duration.value;
            data[me.model.lagUnitField] = duration.unit;
        }
        me.dependencyRecord.set(data);
    },
    /**
     * This method is called during the form initialization. It returns an array of fields to be assigned to the `items` property.
     * Override the method to add some extra fields or remove some of default ones. For example:
     *
     * ```javascript
     * Ext.define('MyDependencyEditor', {
     *     extend : 'Gnt.plugin.DependencyEditor',
     *
     *     buildFields : function () {
     *         var fields = this.callParent(arguments);
     *
     *         // add extra "foo" field
     *         fields.push(new Ext.form.NumberField({
     *             name       : 'foo',
     *             fieldLabel : 'Bar'
     *         });
     *
     *         return fields;
     *     }
     * });
     * ```
     *
     * @return {Ext.Component[]} List of the form fields.
     */
    buildFields: function() {
        var me = this,
            dependencyStore = me.taskStore && me.taskStore.getDependencyStore();
        me.model = dependencyStore ? dependencyStore.model.prototype : Gnt.model.Dependency.prototype;
        var fields = [
                me.fromLabel = new Ext.form.TextField({
                    readOnly: true,
                    border: false,
                    fieldLabel: me.L('fromText'),
                    cls: 'sch-gantt-dependencyeditor-readonly'
                }),
                me.toLabel = new Ext.form.TextField({
                    readOnly: true,
                    border: false,
                    fieldLabel: me.L('toText'),
                    cls: 'sch-gantt-dependencyeditor-readonly'
                }),
                me.typeField = me.buildTypeField()
            ];
        if (me.showLag !== false && me.lagField !== false && (!me.lagField || !me.lagField.isInstance)) {
            me.lagField = Ext.create(Ext.apply({
                xclass: 'Gnt.field.Duration',
                name: me.model.lagField,
                minValue: Number.NEGATIVE_INFINITY,
                fieldLabel: me.L('lagText')
            }, me.lagField));
            fields.push(me.lagField);
        }
        return fields;
    },
    onTriggerEvent: function(depView, record, e, t) {
        if (!this.rendered)  {
            this.renderAndCollapse();
        }
        
        if (record !== this.dependencyRecord) {
            this.show(record, e.getXY());
        }
    },
    filterAllowedTypes: function(record) {
        var dependencyStore = this.taskStore && this.taskStore.getDependencyStore();
        if (!dependencyStore || !dependencyStore.allowedDependencyTypes)  {
            return true;
        }
        
        var allowed = dependencyStore.allowedDependencyTypes;
        var depType = dependencyStore.model.Type;
        for (var i = 0,
            l = allowed.length; i < l; i++) {
            var type = depType[allowed[i]];
            if (record.getId() == type)  {
                return true;
            }
            
        }
        return false;
    },
    buildTypeField: function() {
        var depClass = this.taskStore ? this.taskStore.getDependencyStore().model : Gnt.model.Dependency;
        var depType = depClass.Type;
        this.typesFilter = new Ext.util.Filter({
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var store = new Ext.data.ArrayStore({
                fields: [
                    {
                        name: 'id',
                        type: 'int'
                    },
                    'text'
                ],
                data: [
                    [
                        depType.EndToStart,
                        this.L('endToStartText')
                    ],
                    [
                        depType.StartToStart,
                        this.L('startToStartText')
                    ],
                    [
                        depType.EndToEnd,
                        this.L('endToEndText')
                    ],
                    [
                        depType.StartToEnd,
                        this.L('startToEndText')
                    ]
                ]
            });
        store.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            name: depClass.prototype.typeField,
            fieldLabel: this.L('typeText'),
            cls: 'gnt-field-with-null-value',
            triggerAction: 'all',
            queryMode: 'local',
            editable: false,
            valueField: 'id',
            displayField: 'text',
            store: store,
            listConfig: {
                htmlEncode: true
            }
        });
    },
    onMouseClick: function(e) {
        if (this.collapsed || e.within(this.getEl()) || // ignore the click on the menus and combo-boxes (which usually floats as the direct child of <body> and
        // leaks through the `e.within(this.getEl())` check
        e.getTarget('.' + Ext.baseCSSPrefix + 'layer') || // if clicks should be ignored for any other element - it should have this class
        e.getTarget('.sch-ignore-click')) {
            return;
        }
        this.collapse();
    },
    // Always hide drag proxy on collapse
    afterCollapse: function() {
        delete this.dependencyRecord;
        // Currently the header is kept even after collapse, so need to hide the form completely
        this.hide();
        this.callParent(arguments);
        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.mun(Ext.getBody(), 'click', this.onMouseClick, this);
        }
    }
});

/**
 * This plugin will draw project progress line with SVG.
 *
 *      var gantt = new Gnt.panel.Gantt({
 *          plugins : [{
 *              ptype      : 'gantt_progressline',
 *              statusDate : new Date(2017, 2, 8)
 *          }]
 *      });
 *
 * Status date can be changed:
 *
 *      var plugin = gantt.findPlugin('gantt_progressline');
 *      plugin.setStatusDate(new Date(2017, 3, 8));
 *
 * If status date is not in the current gantt time span, progress line will use view start or end coordinates. This
 * behavior can be customized with {@link drawLineOnlyWhenStatusDateVisible} config. Or you can override {@link shouldDrawProgressLine}
 * method and provide more complex condition.
 *
 * Progress line is a set of SVG <line> elements drawn between all the tasks. The line can be customized with the {@link #tpl} config.
 * Additional render data for the template can be provided by overriding {@link #getProgressLineRenderData} method.
 */
Ext.define('Gnt.plugin.ProgressLine', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.gantt_progressline',
    config: {
        /**
         * @cfg {Date} statusDate Progress line status date. If not provided, current date is used.
         */
        statusDate: null
    },
    /**
     * @cfg {Boolean} drawLineOnlyWhenStatusDateVisible Set to true to hide progress line, when status date is not
     * in the current time axis.
     */
    drawLineOnlyWhenStatusDateVisible: false,
    /**
     * @cfg {String/Ext.XTemplate} tpl Template for line
     */
    tpl: '<tpl for=".">' + '<line x1="{x1}" y1="{y1}" x2="{x2}" y2="{y2}" class="sch-gantt-progress-line">' + '</line>' + '</tpl>',
    constructor: function(config) {
        if (typeof this.tpl === 'string') {
            this.tpl = new Ext.XTemplate(this.tpl);
        }
        this.callParent([
            config
        ]);
        if (!this.getStatusDate()) {
            this.setStatusDate(new Date());
        }
    },
    destroy: function() {
        this.cmp.un(this.getPanelListeners());
        this.unbindViewListeners();
        this.callParent(arguments);
    },
    init: function(gantt) {
        this.schedulerView = gantt.getSchedulingView();
        this.callParent(arguments);
        this.schedulerView.on({
            viewready: this.onViewReady,
            bufferedrefresh: this.onBufferedRendererRefresh,
            scope: this
        });
        gantt.on(this.getPanelListeners());
    },
    /**
     * Enables plugin and renders progress line.
     */
    enable: function() {
        if (this.disabled) {
            this.callParent(arguments);
            this.bindViewListeners();
            this.drawProgressLine();
        }
    },
    /**
     * Disables plugin and removes progress line.
     */
    disable: function() {
        if (!this.disabled) {
            this.removeCanvas();
            this.callParent(arguments);
            this.unbindViewListeners();
        }
    },
    /**
     * @param {Date} date New status date. Line will be updated.
     */
    setStatusDate: function(date) {
        this.callParent(arguments);
        this.drawProgressLine();
    },
    onViewReady: function() {
        this.bindViewListeners();
        this.drawProgressLine();
    },
    getTranslateYValue: function() {
        if (this.schedulerView.bufferedRenderer) {
            return this.schedulerView.bufferedRenderer.bodyTop;
        } else {
            return 0;
        }
    },
    // Line should be updated on top change (buffered renderer range fetched)
    onBufferedRendererRefresh: function() {
        if (!this.disabled) {
            this.drawProgressLine();
        }
    },
    bindViewListeners: function() {
        this.schedulerView.on(this.getViewListeners());
    },
    unbindViewListeners: function() {
        this.schedulerView.un(this.getViewListeners());
    },
    getViewListeners: function() {
        return {
            beforerefresh: {
                fn: this.onBeforeViewRefresh,
                priority: -900,
                scope: this
            },
            refresh: this.onViewRefresh,
            // TODO: itemupdate should ideally only redraw affected nodes
            itemupdate: this.drawProgressLine,
            // update and remove will affect vertical position of other elements, so we need to
            // repaint line completely
            itemadd: this.drawProgressLine,
            itemremove: this.drawProgressLine,
            scope: this
        };
    },
    getPanelListeners: function() {
        return {
            beforedatarefresh: this.onBeforeDataRefresh,
            datarefresh: this.onDataRefresh,
            scope: this
        };
    },
    onBeforeDataRefresh: function() {
        if (!this.disabled) {
            this._wasEnabled = true;
            this.disable();
        }
    },
    onDataRefresh: function() {
        if (this._wasEnabled) {
            this.enable();
        }
    },
    /**
     * This method will calculate point inside task element to be connected with line.
     * @param {Gnt.model.Task} record
     * @param {HTMLElement} node Row node to look for progress bar in
     * @param {Number[]} translateBy View xy coordinates to calculate relative point position
     * @returns {Object/undefined} Object containing coordinates for point in progress line, or undefined if no progress bar el is found
     * @private
     */
    calculateCoordinateForTask: function(record, node, translateBy) {
        var progressBarEl = record.isSegmented() ? Ext.fly(node).down('.sch-segment-in-progress .sch-gantt-progress-bar') : Ext.fly(node).down('.sch-gantt-progress-bar');
        if (progressBarEl) {
            var box = progressBarEl.getBox();
            return {
                x: box.right + translateBy[0],
                y: box.top + box.height / 2 + translateBy[1]
            };
        }
    },
    /**
     * @returns {Boolean} Return false if the line should not be drawn.
     */
    shouldDrawProgressLine: function() {
        return !this.disabled && (!this.drawLineOnlyWhenStatusDateVisible || this.schedulerView.timeAxis.dateInAxis(this.getStatusDate()));
    },
    onBeforeViewRefresh: function() {
        this.refreshSuspended = true;
    },
    onViewRefresh: function() {
        this.refreshSuspended = false;
        this.drawProgressLine();
    },
    /**
     * Renders the progress line.
     */
    drawProgressLine: function() {
        var schedulerView = this.schedulerView;
        if (this.disabled || !schedulerView || !schedulerView.rendered || !schedulerView.isItemCanvasAvailable() || this.refreshSuspended) {
            return;
        }
        var dateForStatusLine = this.getStatusDate(),
            isStatusDateInAxis = schedulerView.timeAxis.dateInAxis(dateForStatusLine);
        if (!isStatusDateInAxis) {
            dateForStatusLine = dateForStatusLine < schedulerView.timeAxis.getStart() ? schedulerView.timeAxis.getStart() : schedulerView.timeAxis.getEnd();
        }
        var dateX = schedulerView.getCoordinateFromDate(dateForStatusLine);
        var data = this.shouldDrawProgressLine() ? this.getProgressLineRenderData(dateX) : [];
        // IE11 doesn't support innerHTML property on SVG canvas, so we will destroy canvas each time and recreate with
        // correct innerHTML
        this.removeCanvas();
        var top = this.getTranslateYValue();
        schedulerView.getItemCanvasEl(11, {
            tag: 'svg',
            role: 'presentation',
            cls: 'sch-svg-canvas',
            style: 'transform: translateY(-' + top + 'px);',
            html: this.tpl.apply(data)
        });
    },
    removeCanvas: function() {
        var oldCanvas = this.schedulerView.getEl().down('.sch-svg-canvas') || this.schedulerView.getItemCanvasEl(11);
        oldCanvas && oldCanvas.remove();
    },
    /**
     * Returns data required to render progress line. Override this method to provide additional data for the template.
     * @param {Number} statusLineX Horizontal position of the status line.
     * @return {Object[]} Returns array of points for line.
     */
    getProgressLineRenderData: function(statusLineX) {
        var me = this,
            view = me.schedulerView,
            // we need to figure out view box xy position to calculate correct position for line element
            viewXY = [
                view.getX(),
                view.el.up('.' + Ext.baseCSSPrefix + 'scroller').getY()
            ],
            scroll = view.getScroll(),
            lineDefinitions = [],
            statusDate = this.getStatusDate();
        viewXY = [
            scroll.left - viewXY[0],
            scroll.top - viewXY[1]
        ];
        Ext.Array.each(view.getNodes(), function(node) {
            if (!node)  {
                return;
            }
            
            // view.getNodes() may temporarily contain undefined entries
            var taskRecord = view.getRecord(node),
                rowBox = Ext.fly(node).getBox(),
                point;
            // If the task:
            // - exists (in case of batch remove, view may still contain nodes that are removed from store)
            // - is in the visible timespan
            // - is not a milestone
            if (taskRecord && view.timeAxis.isRangeInAxis(taskRecord) && !taskRecord.isMilestone() && (// - is in progress
            taskRecord.isInProgress() || (// .. or is not started and its start date is before statusDate
            !taskRecord.isStarted() && taskRecord.getStartDate() < statusDate) || (// .. or is finished and its start date is after statusDate
            taskRecord.isCompleted() && taskRecord.getStartDate() > statusDate))) {
                point = me.calculateCoordinateForTask(taskRecord, node, viewXY);
                // If multiple rows are affected by event update, it could happen, that point
                // could not be resolved
                point && lineDefinitions.push({
                    x1: statusLineX,
                    y1: viewXY[1] + rowBox.top,
                    x2: point.x,
                    y2: point.y
                }, {
                    x1: point.x,
                    y1: point.y,
                    x2: statusLineX,
                    y2: viewXY[1] + rowBox.bottom
                });
            }
            // otherwise we render vertical status line
            if (!point) {
                lineDefinitions.push({
                    x1: statusLineX,
                    y1: viewXY[1] + rowBox.top,
                    x2: statusLineX,
                    y2: viewXY[1] + rowBox.bottom
                });
            }
        });
        return lineDefinitions;
    }
});

/**
 * Plugin for showing a context menu when right clicking a task:
 *
 * {@img gantt/images/context-menu.png}
 *
 * You can add it to your gantt chart like this:
 *
 * ```javascript
 * var gantt = Ext.create('Gnt.panel.Gantt', {
 *     plugins : [
 *         { ptype : 'gantt_taskcontextmenu' }
 *     ],
 *     ...
 * });
 * ```
 *
 * ##Customizing the menu
 *
 * To customize the content of the menu, subclass the plugin and provide your own implementation of the {@link #createMenuItems} method.
 * You can also customize various handlers for menu items, like {@link #addTaskAbove}, {@link #deleteTask} etc. For example:
 *
 * ```javascript
 * Ext.define('MyProject.plugin.TaskContextMenu', {
 *     extend     : 'Gnt.plugin.TaskContextMenu',
 *
 *     createMenuItems : function () {
 *         this.on('beforeshow', this.onMyBeforeShow, this);
 *
 *         // add a new menu entry
 *         return this.callParent().concat({
 *             text        : 'My handler',
 *
 *             handler     : this.onMyHandler,
 *             scope       : this
 *         });
 *     },
 *
 *     onMyHandler : function () {
 *         // the task on which the right click have occured
 *         var task        = this.rec;
 *
 *         ...
 *     },
 *
 *     onMyBeforeShow : function() {
 *         // Allow delete only based on some condition
 *         var isDeleteAllowed = this.rec.get('AllowDelete');
 *
 *         this.down('#deleteTask').setVisible(isDeleteAllowed);
 *     }
 * });
 * ```
 *
 * And to disable some menu items based on a condition override {@link #isMenuOptionEnabled} method:
 *
 * ```javascript
 * Ext.define('MyProject.plugin.TaskContextMenu', {
 *     extend : 'Gnt.plugin.TaskContextMenu',
 *
 *     isMenuOptionEnabled : function(item, task) {
 *         var allowAction = item.itemId !== 'deleteTask' || !task.get('IsSecretTask');
 *
 *         return allowAction;
 *     }
 * });
 * ```
 *
 * Note that when using right click to show the menu you should set the 'ignoreRightMouseSelection' to false on your selection model:
 *
 * ```javascript
 * var gantt = Ext.create('Gnt.panel.Gantt', {
 *     selModel : new Ext.selection.TreeModel({ ignoreRightMouseSelection : false }),
 *     plugins             : [
 *         Ext.create("MyProject.plugin.TaskContextMenu")
 *     ],
 *     ...
 * });
 * ```
 */
Ext.define("Gnt.plugin.TaskContextMenu", {
    extend: 'Ext.menu.Menu',
    requires: [
        'Sch.util.Date',
        'Gnt.model.Task'
    ],
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    alias: 'plugin.gantt_taskcontextmenu',
    xtype: 'gantt_taskcontextmenu',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_taskcontextmenu',
    lockableScope: 'top',
    plain: true,
    /**
     * @cfg {String/String[]} triggerEvent
     * The Gantt panel event(s) upon which the menu shall be shown. Might be provided as an array of multiple event names.
     * By defaults the menu is shown when right-clicking a row or task bar and when right-clicking an empty area in the grid.
     * You can change this to 'taskcontextmenu' if you want the menu to be shown only when right clicking a task bar.
     */
    triggerEvent: [
        'rowcontextmenu',
        'containercontextmenu',
        'rowlongpress',
        'containerlongpress'
    ],
    hideEvent: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - newTaskText         : 'New task'
     - deleteTask          : 'Delete task(s)'
     - editLeftLabel       : 'Edit left label'
     - editRightLabel      : 'Edit right label'
     - add                 : 'Add...'
     - deleteDependency    : 'Delete dependency...'
     - addTaskAbove        : 'Task above'
     - addTaskBelow        : 'Task below'
     - addMilestone        : 'Milestone'
     - addSubtask          : 'Sub-task'
     - addSuccessor        : 'Successor'
     - addPredecessor      : 'Predecessor'
     - splitTask           : 'Split task'
     */
    grid: null,
    /**
     * @property {Gnt.model.Task} rec The task model, for which the menu was activated
     */
    rec: null,
    triggerEventXY: null,
    lastHighlightedItem: null,
    taskEditorInjected: false,
    config: {
        /**
         * @cfg {Number} splitDuration The split duration to be used when "Split task" menu item is called.
         * Set this to zero to enable automatic split duration calculation depending on active zoom level.
         * In this mode the split duration is calculated as the clicked tick duration restricted by
         * {@link #minSplitDuration} and {@link #maxSplitDuration} values.
         */
        splitDuration: 0,
        /**
         * @cfg {String} splitDurationUnit Split duration unit to be used when "Split task" menu item is called
         * See {@link #splitDuration} for details.
         */
        splitDurationUnit: 'd',
        /**
         * @cfg {Number} maxSplitDuration Maximum allowed split duration (use {@link #maxSplitDurationUnit} to define unit for this value).
         * The value is used when automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        maxSplitDuration: 1,
        /**
         * @cfg {String} maxSplitDurationUnit Maximum allowed split duration unit.
         * See {@link #maxSplitDuration} for details.
         */
        maxSplitDurationUnit: 'd',
        /**
         * @cfg {Number} minSplitDuration Minimum allowed split duration (use {@link #minSplitDurationUnit} to define unit for this value).
         * The value is used when automatic split duration calculation is enabled (see {@link #splitDuration} for details).
         */
        minSplitDuration: 1,
        /**
         * @cfg {String} minSplitDurationUnit Minimum allowed split duration unit.
         * See {@link #minSplitDuration} for details.
         */
        minSplitDurationUnit: 'h'
    },
    initComponent: function() {
        var me = this;
        me.defaults = me.defaults || {};
        me.defaults.scope = me;
        me.triggerEvent = [].concat(me.triggerEvent);
        if (me.hideEvent && !Ext.isArray(me.hideEvent)) {
            me.hideEvent = [
                me.hideEvent
            ];
        }
        me.items = me.createMenuItems();
        me.callParent(arguments);
    },
    init: function(grid) {
        this.ownerCmp = grid;
        this.grid = grid;
        this.bindTriggerEvent();
        this.bindHideEvent();
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    isNotProject: function(task) {
        return !task || !task.isProject;
    },
    isReadOnly: function(task) {
        return this.getCmp().isReadOnly() || (task && task.isReadOnly());
    },
    /**
     * This method is being called during plugin initialization. Override if you need to customize the items in the menu.
     * The method should return an array of menu items, which will be used as the value of the `items` property.
     *
     * Each menu item is decorated with an itemId property for testability.
     *
     * @return {Array}
     */
    createMenuItems: function() {
        var me = this;
        return [
            {
                handler: this.deleteTask,
                requiresTask: true,
                itemId: 'deleteTask',
                text: this.L('deleteTask'),
                isValidAction: function(task) {
                    return !me.isReadOnly(task);
                }
            },
            {
                handler: this.editLeftLabel,
                requiresTask: true,
                itemId: 'editLeftLabel',
                text: this.L('editLeftLabel'),
                isValidAction: function(task) {
                    return me.grid.getSchedulingView().getLeftEditor() && !me.isReadOnly(task);
                }
            },
            {
                handler: this.editRightLabel,
                requiresTask: true,
                itemId: 'editRightLabel',
                text: this.L('editRightLabel'),
                isValidAction: function(task) {
                    return me.grid.getSchedulingView().getRightEditor() && !me.isReadOnly(task);
                }
            },
            {
                handler: this.toggleMilestone,
                requiresTask: true,
                itemId: 'toggleMilestone',
                text: this.L('convertToMilestone'),
                isValidAction: function(task) {
                    return this.isNotProject(task) && !me.isReadOnly(task);
                }
            },
            {
                handler: this.splitTask,
                requiresTask: true,
                itemId: 'splitTask',
                isValidAction: function(task, triggerDomEvent) {
                    return task && !me.isReadOnly(task) && task.getStartDate() && task.getEndDate() && !task.isMilestone() && task.isLeaf() && triggerDomEvent && triggerDomEvent.getTarget('.sch-gantt-task-bar');
                },
                text: this.L('splitTask')
            },
            {
                text: this.L('add'),
                itemId: 'addTaskMenu',
                menu: {
                    plain: true,
                    defaults: {
                        scope: this
                    },
                    items: [
                        {
                            handler: this.addTaskAboveAction,
                            requiresTask: true,
                            itemId: 'addTaskAbove',
                            text: this.L('addTaskAbove'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addTaskBelowAction,
                            itemId: 'addTaskBelow',
                            text: this.L('addTaskBelow'),
                            isValidAction: function(task) {
                                return (task && me.isNotProject(task) && !me.isReadOnly(task.parentNode)) || (!task && !me.isReadOnly());
                            }
                        },
                        {
                            handler: this.addMilestone,
                            itemId: 'addMilestone',
                            requiresTask: true,
                            text: this.L('addMilestone'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addSubtask,
                            requiresTask: true,
                            itemId: 'addSubtask',
                            text: this.L('addSubtask'),
                            isValidAction: function(task) {
                                // disable menu item when store is grouped
                                // no point in >1 level of hierarchy
                                return !me.isReadOnly(task) && !task.getTreeStore().isTreeGrouped();
                            }
                        },
                        {
                            handler: this.addSuccessor,
                            requiresTask: true,
                            itemId: 'addSuccessor',
                            text: this.L('addSuccessor'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        },
                        {
                            handler: this.addPredecessor,
                            requiresTask: true,
                            itemId: 'addPredecessor',
                            text: this.L('addPredecessor'),
                            isValidAction: function(task) {
                                return me.isNotProject(task) && !me.isReadOnly(task.parentNode);
                            }
                        }
                    ]
                }
            },
            {
                text: this.L('deleteDependency'),
                requiresTask: true,
                itemId: 'deleteDependencyMenu',
                isValidAction: function(task) {
                    return task && !me.isReadOnly(task) && task.getAllDependencies().length > 0;
                },
                menu: {
                    plain: true,
                    listeners: {
                        beforeshow: this.populateDependencyMenu,
                        // highlight dependencies on mouseover of the menu item
                        mouseover: this.onDependencyMouseOver,
                        // unhighlight dependencies on mouseout of the menu item
                        mouseleave: this.onDependencyMouseOut,
                        scope: this
                    }
                }
            }
        ];
    },
    bindGridEvents: function(events, fn, scope) {
        scope = scope || this;
        var grid = this.getCmp();
        if (events) {
            for (var i = events.length - 1; i >= 0; i--) {
                grid.on(events[i], fn, scope);
            }
        }
    },
    /**
     * This method is called once for each menuitem when the menu is shown. Return false from the method to disable a menu item. The method receives the
     * menuitem and the record (if applicable) as input parameters.
     *
     * @param  {Ext.menu.Item} menuItem The menu item, the built-in menu options have 'itemId' that you can compare with ('deleteTask', 'editLeftLabel', etc)
     * @param  {Gnt.model.Task} task
     *
     * @return {Boolean}
     */
    isMenuOptionEnabled: null,
    bindTriggerEvent: function() {
        this.bindGridEvents(this.triggerEvent, this.onTriggerEvent);
    },
    bindHideEvent: function() {
        this.bindGridEvents(this.hideEvent, this.onHideEvent);
    },
    onHideEvent: function() {
        this.hide();
    },
    swallowNextClickEvent: function() {
        Ext.getBody().on('click', function(e) {
            e.stopPropagation();
        }, null, {
            single: true,
            capture: true
        });
    },
    populateDependencyMenu: function(menu) {
        var grid = this.getCmp(),
            taskStore = grid.getTaskStore(),
            dependencies = this.rec.getAllDependencies(),
            depStore = grid.dependencyStore;
        menu.removeAll();
        if (!dependencies.length)  {
            return false;
        }
        
        var taskId = this.rec.getId() || this.rec.internalId;
        Ext.Array.each(dependencies, function(dependency) {
            var fromId = dependency.getSourceId(),
                task = taskStore.getModelById(fromId == taskId ? dependency.getTargetId() : fromId);
            if (task) {
                menu.add({
                    dependency: dependency,
                    text: Ext.htmlEncode(Ext.util.Format.ellipsis(task.getName(), 30)),
                    scope: this,
                    handler: function(menuItem) {
                        depStore.remove(menuItem.dependency);
                    },
                    disabled: this.isReadOnly(this.rec)
                });
            }
        }, this);
    },
    onDependencyMouseOver: function(menu, item, e) {
        if (item) {
            var schedulingView = this.getCmp().getSchedulingView();
            if (this.lastHighlightedItem) {
                schedulingView.unhighlightDependency(this.lastHighlightedItem.dependency);
            }
            this.lastHighlightedItem = item;
            schedulingView.highlightDependency(item.dependency);
        }
    },
    onDependencyMouseOut: function(menu, e) {
        if (this.lastHighlightedItem) {
            this.getCmp().getSchedulingView().unhighlightDependency(this.lastHighlightedItem.dependency);
        }
    },
    onTriggerEvent: function() {
        var context = this.getTriggerEventContext.apply(this, arguments);
        // Only trigger menu on longpress actions if not using a mouse
        if (!context.e.type.match('longpress') || context.e.pointerType !== 'mouse') {
            this.activateMenu(context.record, context.e);
        }
    },
    getTriggerEventContext: function() {
        var result = {};
        // loop over arguments forward searching for the task
        for (var i = 0,
            l = arguments.length - 1; i <= l; i++) {
            if (arguments[i] instanceof Gnt.model.Task) {
                result.record = arguments[i];
                break;
            }
        }
        // loop over arguments backward searching for the event
        for (i = arguments.length - 1; i >= 0; i--) {
            if (arguments[i] instanceof Ext.EventObjectImpl) {
                result.e = arguments[i];
                break;
            }
        }
        return result;
    },
    activateMenu: function(rec, e) {
        // Do not show menu for the root node of task store
        if (this.getCmp().taskStore.getRootNode() === rec) {
            return;
        }
        // The click event on a grid cell will trigger a focus event and context menu will hide
        if (e.type.match('longpress')) {
            this.swallowNextClickEvent();
        }
        e.stopEvent();
        this.rec = rec;
        this.triggerEventXY = e.getXY();
        this.configureMenuItems(e);
        this.showAt(e.getXY());
        // Needed in case menu is shown from windows keyboard shortcut. https://app.assembla.com/spaces/bryntum/tickets/9464-cell-context-menu-is-not-focused-when-called-from-keyboard/details#
        if (Ext.platformTags.windows) {
            this.focus();
        }
    },
    addTaskEditorEntry: function() {
        this.insert(0, {
            text: this.L('taskInformation'),
            itemId: 'taskEditor',
            requiresTask: true,
            handler: function() {
                this.getCmp().getTaskEditor(this.rec).showTask(this.rec);
            },
            isValidAction: function(task) {
                return this.getCmp().getTaskEditor(task);
            },
            scope: this
        });
        // remember that we added the entry
        this.taskEditorInjected = true;
    },
    setTaskEditorEntryLabel: function(task) {
        var taskEditor = this.down('#taskEditor');
        if (task && taskEditor) {
            taskEditor.setText(task.isProject ? this.L('projectInformation') : this.L('taskInformation'));
        }
    },
    configureMenuItems: function(triggerEvent) {
        var rec = this.rec;
        var me = this;
        if (this.getCmp().getTaskEditor()) {
            if (!this.taskEditorInjected)  {
                this.addTaskEditorEntry();
            }
            
            // set proper task editor menu entry title
            this.setTaskEditorEntryLabel(rec);
        }
        Ext.Array.each(this.query('menuitem'), function(item) {
            item.setDisabled(!me.isMenuItemEnabled(item, rec, triggerEvent));
        });
        var toggleMilestone = this.down('#toggleMilestone');
        if (rec && toggleMilestone) {
            toggleMilestone.setText(rec.isMilestone() ? this.L('convertToRegular') : this.L('convertToMilestone'));
        }
    },
    isMenuItemEnabled: function(item, task, triggerEvent) {
        // the menu entry has to be disabled:
        // - if it requires a task to be selected
        // - or it's not valid (dependends on its "isValidAction" result)
        var disabled = (item.requiresTask && !task) || (item.isValidAction && !item.isValidAction.call(item.scope || item, task, triggerEvent));
        return !disabled && (!this.isMenuOptionEnabled || this.isMenuOptionEnabled(item, task) !== false);
    },
    copyTask: function(original, extraData) {
        var model = original && original.self || this.getCmp().getTaskStore().getModel();
        var newTask = new model({
                leaf: true
            });
        newTask.setPercentDoneWithoutPropagation(0);
        newTask.setName(this.L('newTaskText', this.texts));
        newTask.set(newTask.startDateField, (original && original.getStartDate()) || null);
        newTask.set(newTask.endDateField, (original && original.getEndDate()) || null);
        newTask.set(newTask.durationField, (original && original.getDuration()) || null);
        newTask.set(newTask.durationUnitField, (original && original.getDurationUnit()) || Sch.util.Date.DAY);
        extraData && newTask.set(extraData);
        return newTask;
    },
    // Actions follow below
    // ---------------------------------------------
    /**
     * Handler for the "add task above" menu item
     */
    addTaskAbove: function(newTask) {
        var task = this.rec;
        if (task) {
            task.addTaskAbove(newTask);
        } else {
            this.getCmp().taskStore.getRootNode().appendChild(newTask);
        }
    },
    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelow: function(newTask) {
        var task = this.rec;
        if (task) {
            task.addTaskBelow(newTask);
        } else {
            this.getCmp().taskStore.getRootNode().appendChild(newTask);
        }
    },
    /**
     * Handler for the "delete task" menu item
     */
    deleteTask: function() {
        var toDelete = this.getCmp().getSelectedRows().slice();
        if (this.rec && !Ext.Array.contains(toDelete, this.rec)) {
            toDelete.push(this.rec);
        }
        this.getCmp().getTaskStore().removeTasks(toDelete);
    },
    /**
     * Handler for the "edit left label" menu item
     */
    editLeftLabel: function() {
        this.getCmp().getSchedulingView().editLeftLabel(this.rec);
    },
    /**
     * Handler for the "edit right label" menu item
     */
    editRightLabel: function() {
        this.getCmp().getSchedulingView().editRightLabel(this.rec);
    },
    /**
     * Handler for the "add task above" menu item
     */
    addTaskAboveAction: function() {
        this.addTaskAbove(this.copyTask(this.rec));
    },
    /**
     * Handler for the "add task below" menu item
     */
    addTaskBelowAction: function() {
        this.addTaskBelow(this.copyTask(this.rec));
    },
    /**
     * Handler for the "add subtask" menu item
     */
    addSubtask: function() {
        var task = this.rec;
        // we create a new task using the selected task as a pattern
        // but only if it's not a project ..since nested projects are not supported
        var copy = this.copyTask(this.isNotProject(task) && task);
        task.addSubtask(copy);
    },
    /**
     * Handler for the "add successor" menu item
     */
    addSuccessor: function() {
        var task = this.rec;
        task.addSuccessor(this.copyTask(task));
    },
    /**
     * Handler for the "add predecessor" menu item
     */
    addPredecessor: function() {
        var task = this.rec;
        task.addPredecessor(this.copyTask(task));
    },
    /**
     * Handler for the "add milestone" menu item
     */
    addMilestone: function() {
        var task = this.rec,
            extraData = {},
            newTask;
        // copy task fields but set start date equals end date, and duration to zero
        extraData[task.startDateField] = task.getEndDate();
        extraData[task.durationField] = 0;
        newTask = this.copyTask(task, extraData);
        task.addTaskBelow(newTask);
    },
    /**
     * Handler for the "Convert to milestone" menu item
     */
    toggleMilestone: function() {
        if (this.rec.isMilestone()) {
            this.rec.convertToRegular();
        } else {
            this.rec.convertToMilestone();
        }
    },
    /**
     * @protected
     * Returns a date for the task splitting.
     * Returns start date of the tick being clicked if the tick duration is less than {@link #maxSplitDuration} or {@link #maxSplitDuration} is zero.
     * When the tick duration is greater than {@link #maxSplitDuration} returns `context.date` rounded based on active time axis resolution unit.
     *
     * Override this method if you want to implement another way of the split date calculating.
     * See also: {@link #getSplitDuration}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Date}      Returns a date to be used to split.
     */
    getSplitDate: function(context) {
        var task = context.task,
            date = context.date,
            tick = context.tick,
            timeAxis = context.timeAxis,
            maxDuration = this.getMaxSplitDuration(),
            result;
        if (tick) {
            result = tick.getStartDate();
            // we use tick duration if it's less than maximal allowed split size
            if (maxDuration) {
                maxDuration = task.getUnitConverter().convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit());
                if (maxDuration < tick.getEndDate() - tick.getStartDate())  {
                    result = null;
                }
                
            }
        }
        // otherwise round clicked datetime relative to task start using active time axis resolution unit
        return result || timeAxis.roundDate(date, task.getStartDate());
    },
    /**
     * @protected
     * Returns a duration for the task splitting.
     * Returns duration of the tick being clicked constrained by {@link #minSplitDuration} and {@link #maxSplitDuration} values.
     * Override this method if you want to implement another way of the split duration calculating.
     * See also: {@link #getSplitDate}, {@link #getSplitDurationUnit}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {Number}      Returns split duration.
     */
    getSplitDuration: function(context) {
        if (this.splitDuration)  {
            return this.splitDuration;
        }
        
        var task = context.task,
            pos = context.pos,
            date = context.date,
            tick = context.tick;
        if (tick) {
            // let's get tick length in MS as initial duration
            var result = task.calculateDuration(tick.getStartDate(), tick.getEndDate(), Sch.util.Date.MILLI),
                converter = task.getUnitConverter(),
                minDuration = this.getMinSplitDuration(),
                maxDuration = this.getMaxSplitDuration();
            // if we have to constrain duration
            if (minDuration || maxDuration) {
                if (maxDuration) {
                    result = Math.min(result, converter.convertDurationToMs(maxDuration, this.getMaxSplitDurationUnit()));
                }
                if (minDuration) {
                    result = Math.max(result, converter.convertDurationToMs(minDuration, this.getMinSplitDurationUnit()));
                }
            }
            // turn duration to proper duration unit
            return converter.convertMSDurationToUnit(result, this.getSplitDurationUnit(task, pos, date, tick));
        }
    },
    /**
     * @protected
     * Returns a duration unit for the task splitting.
     * Returns {@link #splitDurationUnit} when {@link #splitDuration} provided or `ms`.
     * Override this method if you want to implement another way of the split duration unit defining.
     * See also: {@link #getSplitDate}, {@link #getSplitDuration}.
     * @param  {Object}                 context             Split call context
     * @param  {Gnt.model.Task}         context.task        Task being split
     * @param  {Array}                  context.pos         Click position. Array containing [x, y] coordinates of mouse click.
     * @param  {Date}                   context.date        Date corresponding to the click position.
     * @param  {Sch.model.TimeAxisTick} context.tick        Time axis tick corresponding to the click position.
     * @param  {Sch.data.TimeAxis}      context.timeAxis    Time axis instance.
     * @return {String}      Returns split duration unit.
     */
    getSplitDurationUnit: function(context) {
        // if we have constant "splitDuration" set then we use "splitDurationUnit"
        // otherwise let's use milliseconds
        return this.splitDuration ? this.splitDurationUnit : Sch.util.Date.MILLI;
    },
    /**
     * Handler for the "Split task" menu item
     */
    splitTask: function() {
        var me = this,
            view = me.grid.getSchedulingView(),
            cursorDate = view.getDateFromX(me.triggerEventXY[0]),
            timeAxis = view.timeAxis;
        var context = {
                task: me.rec,
                pos: me.triggerEventXY,
                date: cursorDate,
                timeAxis: timeAxis,
                tick: timeAxis.getAt(Math.floor(timeAxis.getTickFromDate(cursorDate)))
            };
        context.task.split(me.getSplitDate(context), me.getSplitDuration(context), me.getSplitDurationUnit(context));
    }
});

/**
 * The plugin allows to render custom indicators to a task row easily.
 * The indicators can be positioned by dates or coordinates.
 * To use this class the one should provide {@link #getIndicators} method either by doing this on the plugin instance level:
 *
 * ```javascript
 * var panel = new Gnt.panel.Gantt({
 *     ...
 *     plugins : [
 *         {
 *             ptype         : 'gantt_taskindicators',
 *
 *             getIndicators : function (task) {
 *                 return Ext.Array.map(task.get('Indicators'), function (data) {
 *                     return {
 *                         date    : Ext.Date.parse(data.Date, 'Y-m-d'),
 *                         iconCls : data.IconCls,
 *                         text    : data.Name,
 *                         tooltip : data.Tooltip
 *                     };
 *                 });
 *             }
 *         }
 *     ]
 * });
 * ```
 *
 * or by extending the class:
 *
 * ```javascript
 * Ext.define("MyCoolPlugin", {
 *     extend : 'Gnt.plugin.TaskIndicators',
 *
 *     alias  : 'plugin.mycoolplugin',
 *
 *     getIndicators : function (task) {
 *         return Ext.Array.map(task.get('Indicators'), function (data) {
 *             return {
 *                 date    : Ext.Date.parse(data.Date, 'Y-m-d'),
 *                 iconCls : data.IconCls,
 *                 text    : data.Name,
 *                 tooltip : data.Tooltip
 *             };
 *         });
 *     }
 * });
 *
 * var panel = new Gnt.panel.Gantt({
 *     ...
 *     plugins : [
 *         "mycoolplugin"
 *     ]
 * });
 * ```
 */
Ext.define('Gnt.plugin.TaskIndicators', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.gantt_taskindicators',
    requires: [
        'Ext.XTemplate'
    ],
    /**
     * @cfg {Ext.XTemplate/String}
     * Indicator template. In order to add custom properties to the template please override {@link #getTplData} method.
     */
    tpl: '<label data-qtip="{tooltip:htmlEncode}" data-qalign="{tooltipAlign:htmlEncode}" class="{cls:htmlEncode}" style="{side}:{position}px"><i class="{iconCls:htmlEncode}"></i>{text:htmlEncode}</label>',
    cls: 'gnt-indicator',
    /**
     * @cfg {String}
     * Default icon CSS class. Used when an indicator "iconCls" is empty.
     */
    iconCls: 'fa fa-check',
    side: null,
    /**
     * @cfg {Number}
     * Default icon size. Used when an indicator "iconSize" is not provided.
     */
    iconSize: 10,
    tooltipAlign: 'b-tl',
    init: function(cmp) {
        this.side = cmp.rtl ? 'right' : 'left';
        if (!this.tpl.isTemplate) {
            this.tpl = Ext.create('Ext.XTemplate', this.tpl);
        }
        cmp.registerRenderer(this.indicatorRenderer, this);
        this.callParent(arguments);
    },
    /**
     * @abstract
     * Returns list of indicators that should be rendered for the task.
     * @param  {Gnt.model.Task} task Task to return indicators for.
     * @return {Object[]} Array of objects describing the task indicators. Each object should have the following properties:
     * @return {Date} return.date Datetime to show the indicator on (alternatively the indicator "position" (see below) can be defined).
     * @return {Number} return.position (optional) The coordinate to show the indicator at (can be used instead of `date`).
     * @return {String} return.text (optional) Indicator text.
     * @return {String} return.tooltip (optional) Indicator tooltip text.
     * @return {String} return.cls (optional) Indicator CSS class.
     * @return {String} return.iconCls (optional) Indicator icon CSS class.
     * @return {Number} return.iconSize (optional) Indicator icon size in pixels. If not provided {@link #iconSize} value is used. The value is used to handle "iconAlign" properly.
     * @return {String} return.iconAlign (optional) Indicator icon align (used with `date` only). Defines the icon alignment relative to `date` coordinate. Possible values are:
     *
     *  - 'left' - (default) the icon left side is aligned with the 'date' coordinate.
     *  - 'right' - the icon right side is aligned with the 'date' coordinate.
     *  - 'middle' - the icon center is aligned with the 'date' coordinate.
     */
    getIndicators: function(task) {
        return [];
    },
    calculateIndicatorPosition: function(indicator) {
        var view = this.getCmp().getSchedulingView(),
            position = view.getCoordinateFromDate(indicator.date),
            iconSize = Ext.isNumeric(indicator.iconSize) ? indicator.iconSize : this.iconSize;
        // iconAlign == right - means the icon should snap its right border to the date
        // so we extract the icon width from the date coordinate
        if (indicator.iconAlign == 'right') {
            position -= iconSize;
        } else if (indicator.iconAlign == 'middle') {
            position -= iconSize / 2;
        }
        return position;
    },
    /**
     * @protected
     * Provides data for the {@link #tpl indicator template}.
     * @param  {Object} indicator Indicator object (see details on the object structure in {@link #getIndicators} method docs).
     * @return {Object} Template data.
     */
    getTplData: function(indicator) {
        if (indicator.date || indicator.position > 0) {
            var position = indicator.position || this.calculateIndicatorPosition(indicator);
            if (position > 0) {
                return {
                    iconCls: indicator.iconCls || this.iconCls,
                    text: indicator.text,
                    tooltip: indicator.tooltip || '',
                    tooltipAlign: indicator.tooltipAlign || this.tooltipAlign,
                    cls: this.cls + ' ' + (indicator.cls || ''),
                    side: this.side,
                    position: position
                };
            }
        }
    },
    indicatorRenderer: function(val, meta, task) {
        var indicators = this.getIndicators(task);
        if (indicators) {
            var renderedIndicators = [];
            // render each indicator
            Ext.each(indicators, function(indicator) {
                var tplData = this.getTplData(indicator);
                // skip ones that shouldn't be rendered (empty tpl data signaling about that)
                tplData && renderedIndicators.push(this.tpl.apply(tplData));
            }, this);
            // return as a single concatenated string
            return renderedIndicators.join('');
        }
    }
});

/**
@class Gnt.plugin.taskeditor.BaseEditor
*/
Ext.define('Gnt.plugin.taskeditor.BaseEditor', {
    extend: 'Ext.window.Window',
    requires: [
        'Ext.window.MessageBox'
    ],
    mixins: [
        'Ext.AbstractPlugin',
        'Gnt.mixin.Localizable'
    ],
    lockableScope: 'top',
    closeOnBlur: true,
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.TaskEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.TaskEditor',
    /**
     * @property {Boolean} isTaskEditor
     * @readonly
     * Indicates that the class extends {@link Gnt.plugin.taskeditor.BaseEditor} class.
     */
    isTaskEditor: true,
    /**
     * @property {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor widget contained by the plugin.
     */
    taskEditor: null,
    /**
     * @cfg {Object} panelConfig Configuration for {@link Gnt.widget.taskeditor.BaseEditor} instance.
     */
    panelConfig: null,
    /**
     * @cfg {Boolean} saveOnEnter True to save the form data and close if ENTER is pressed in one of the input fields inside the form panels.
     */
    saveOnEnter: true,
    height: 340,
    width: 600,
    layout: 'card',
    constrain: true,
    /**
     * @cfg {String} triggerEvent
     * The event upon which the editor shall be shown. Defaults to 'taskdblclick'.
     */
    triggerEvent: 'taskdblclick',
    closeAction: 'hide',
    modal: true,
    gantt: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     * If this config is not provided plugin will try to retrieve assignments store from {@link Gnt.panel.Gantt} instance.
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     * If this config is not provided plugin will try to retrieve resources store from {@link Gnt.panel.Gantt} instance.
     */
    resourceStore: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     * If this config is not provided plugin will try to retrieve tasks store from {@link Gnt.panel.Gantt} instance.
     * **Note:** Task store is required if task doesn't belong to any task store yet.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.model.Task} task The task to show in the task editor.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Task Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
     */
    /**
     * @cfg {Boolean} [monitorDataUpdates=false]
     *
     * Whether to actively monitor data updates or not, if set to true then Ok button (if present) will be enabled
     * only if there're data changes introduced in the Task Editor and those changes are valid.
     */
    monitorDataUpdates: false,
    /**
     * @cfg {Number} monitorDataUpdatesInterval
     *
     * Timeout to use to monitor data updates.
     */
    monitorDataUpdatesInterval: 500,
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore',
    taskFilters: null,
    /**
     * @event loadtask
     * Fires after task loading complete.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
     * @param {Gnt.model.Task} task The loaded task.
     *
     *
     * This event can be used to do additional data loading if task editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdatetask} event to have an example of how to implement custom data saving.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          panelConfig : {
     *              items       : customForm
     *          },
     *          listeners   : {
     *              // populate custom form with task values
     *              loadtask : function (taskeditor, task) {
     *                  customForm.loadRecord(task);
     *              },
     *              ....
     *          }
     *      });
     */
    /**
     * @event validate
     * @preventable
     * Fires when task validation occurs. Take a look at example of using this event {@link Gnt.widget.taskeditor.TaskEditor#event-validate here}.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
     */
    /**
     * @event beforeupdatetask
     * @preventable
     * Fires before task updating occurs. Return false to prevent the update.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance used for editing.
     * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
     *                      if (buttonId == 'yes') {
     *                          // here we continue updating asynchronously after user click "Yes" button
     *                          proceedCallback();
     *                          me.hide();
     *                      }
     *                  });
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     * **Note:** If a custom confirmation window messes with the default error message box you can disable it by overriding {@link #method-showErrorMessage} method. Example:
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // prevent default error message box showing
     *          showErrorMessage : Ext.emptyFn,
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.create('Ext.window.Window', {
     *                      title   : 'Complex confirmation',
     *                      width   : 100,
     *                      height  : 100,
     *                      items   : [....]
     *                  }).show();
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     */
    /**
     * @event afterupdatetask
     * Fires after task updating is finished.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor Task editor widget instance.
     *
     * This event can be used to do some extra processing after task was updated by task editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadtask} event to have an example of how to implement custom data loading.
     *
     *      // some custom user form
     *      var customForm = new Gnt.widget.taskeditor.TaskForm({
     *          title : 'Custom form panel',
     *          xtype : 'taskform',
     *          items : [
     *              {
     *                  fieldLabel  : 'Foo field',
     *                  // foo - is the name of custom task field
     *                  name        : 'foo',
     *                  allowBlank  : false
     *              }
     *          ],
     *          taskStore   : taskStore
     *      });
     *
     *      var taskEditor = Ext.create('Gnt.plugin.TaskEditor', {
     *          // register custom form as an additional tab
     *          panelConfig : {
     *              items       : customForm
     *          },
     *          listeners   : {
     *              afterupdatetask : function (taskeditor) {
     *                  // update form fields to loaded task
     *                  customForm.updateRecord();
     *              },
     *              ....
     *          }
     *      });
     */
    constructor: function(config) {
        config = config || {};
        this.taskFilters = [];
        // we need to apply config to let locale()
        // know about legacy locales since it will check them in 'this'
        Ext.apply(this, config);
        this.title = this.L('title');
        // by default we make 'Ok', 'Cancel' buttons
        if (!config.buttons) {
            this.buttons = [
                '->',
                {
                    itemId: 'teOkBtn',
                    text: this.L('okText'),
                    handler: this.onOkClick,
                    scope: this
                },
                {
                    text: this.L('cancelText'),
                    handler: this.close,
                    scope: this
                }
            ];
        }
        this.callParent([
            config
        ]);
        this.addCls('gnt-taskeditor-window');
        if (this.closeOnBlur) {
            this.on('show', this.onFirstShow, this, {
                single: true
            });
        }
        this.on('beforehide', this.onBeforeHide, this);
    },
    /**
     * Displays the error message box on validation fail.
     * Override this method to customize the dialog.
     */
    showErrorMessage: function() {
        !Ext.Msg.isVisible() && Ext.Msg.alert(this.L('alertCaption'), this.L('alertText'));
    },
    onOkClick: function() {
        // Show our alert only if singleton Ext.Msg is not yet visible
        !this.completeEditing() && this.showErrorMessage();
    },
    getState: function() {
        if (this.rendered) {
            return this.callParent(arguments);
        }
    },
    init: function(cmp) {
        var me = this;
        // if assignmentStore or resourceStore wasn't defined as configuration options
        // during plugin constructing we get them from Gnt.panel.Gantt instance
        me.setAssignmentStore(me.assignmentStore || cmp.getAssignmentStore());
        me.setResourceStore(me.resourceStore || cmp.getResourceStore());
        me.setTaskStore(me.taskStore || cmp.getTaskStore());
        // build taskEditor widget
        me.buildTaskEditor(Ext.apply(me.buildTaskEditorConfig(cmp), me.panelConfig));
        me.add(me.taskEditor);
        var listenerCfg = {
                taskstorechange: me.onTaskStoreChange,
                resourcestorechange: me.onResourceStoreChange,
                assignmentstorechange: me.onAssignmentStoreChange,
                dependencystorechange: me.onDependencyStoreChange,
                scope: me
            };
        listenerCfg[me.triggerEvent] = me.onTriggerEvent;
        me.mon(cmp, listenerCfg);
        me.gantt = cmp;
    },
    onTaskStoreChange: function(cmp, store) {
        this.setTaskStore(store);
    },
    onResourceStoreChange: function(cmp, store) {
        this.setResourceStore(store);
    },
    onAssignmentStoreChange: function(cmp, store) {
        this.setAssignmentStore(store);
    },
    onDependencyStoreChange: function(cmp, store) {
        this.setDependencyStore(store);
    },
    setTaskStore: function(store) {
        var me = this;
        me.taskStore = store;
        if (me.taskEditor && me.taskEditor.isComponent) {
            me.taskEditor.setTaskStore(store);
        }
    },
    setResourceStore: function(store) {
        var me = this;
        me.resourceStore = store;
        if (me.taskEditor && me.taskEditor.isComponent) {
            me.taskEditor.setResourceStore(store);
        }
    },
    setAssignmentStore: function(store) {
        var me = this;
        me.assignmentStore = store;
        if (me.taskEditor && me.taskEditor.isComponent) {
            me.taskEditor.setAssignmentStore(store);
        }
    },
    setDependencyStore: function(store) {
        var me = this;
        // there is no this.dependencyStore, value is taken from task store always
        if (me.taskEditor && me.taskEditor.isComponent) {
            me.taskEditor.setDependencyStore(store);
        }
    },
    // Prepares a configuration object to instantiate the taskEditor widget
    buildTaskEditorConfig: function(cmp) {
        var result = {
                width: null,
                height: null,
                border: false,
                showBaseline: cmp.enableBaseline,
                showRollup: cmp.showRollupTasks,
                allowParentTaskDependencies: cmp.allowParentTaskDependencies
            };
        var configs = this.taskEditorConfigs.split(',');
        // let's map some configuration options from plugin to taskEditor
        for (var i = 0; i < configs.length; i++) {
            var cfg = configs[i];
            if (typeof this[cfg] !== 'undefined') {
                result[cfg] = this[cfg];
            }
        }
        return result;
    },
    /**
     * @protected
     * Builds the task editor widget instance being used by the plugin.
     * By default this method creates {@link Gnt.widget.taskeditor.TaskEditor} instance and puts a reference to the instance to {@link #taskEditor} property.
     * Override this if you want to instantiate your custom class instead.
     * @param  {Object} cfg Configuration of the task editor widget being instantiated
     */
    buildTaskEditor: function(cfg) {
        this.taskEditor = Ext.create(this.taskEditorCls, cfg);
        var indicator = this.taskEditor.eventIndicator;
        this.relayEvents(this.taskEditor, [
            'load' + indicator,
            'validate',
            'beforeupdate' + indicator,
            'afterupdate' + indicator
        ]);
    },
    onTriggerEvent: function(gantt, task) {
        this.showTask(task);
    },
    /**
     * Shows window and loads task into the task editor.
     * @param {Gnt.model.Task} task Task to load.
     */
    showTask: function(task) {
        if (this.taskEditor && task && this.matchFilters(task)) {
            this.taskEditor.loadTask(task);
            var readOnly = this.gantt.isReadOnly();
            //  take into account the gantt readOnly state (the task being loaded readOnly and isEditable logic is supported on the widgets level)
            if (readOnly != this.taskEditor.setReadOnly()) {
                this.taskEditor.setReadOnly(readOnly);
            }
            var okBtn = this.down('#teOkBtn');
            if (okBtn) {
                okBtn.setVisible(!readOnly);
            }
            this.show();
        }
    },
    matchFilters: function(task) {
        if (!task)  {
            return;
        }
        
        for (var i = 0; i < this.taskFilters.length; i++) {
            var filter = this.taskFilters[i];
            if (!filter.fn.call(filter.scope, task))  {
                return false;
            }
            
        }
        return true;
    },
    addFilter: function(fn, scope) {
        this.taskFilters.push({
            fn: fn,
            scope: scope || this
        });
    },
    validate: function() {
        if (this.taskEditor) {
            return this.taskEditor.validate();
        }
    },
    /**
     * This function is a shorthand for the following typical steps:
     *
     *      if (!taskEditor.validate()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      } else {
     *          if (taskEditor.updateTask()) taskEditor.hide();
     *      }
     *
     * Instead of above code you can write:
     *
     *      if (!taskEditor.completeEditing()) {
     *          Ext.MessageBox.alert('Information', 'Please correct marked errors to save changes');
     *      }
     *
     * @param  {Function} callback A function to call when task modification is applied (or cancelled).
     * @return {Boolean} true if validation successfully passed and record update was initiated.
     */
    completeEditing: function(callback) {
        if (this.taskEditor) {
            var activeTab = this.taskEditor.getActiveTab();
            // Force any active editing to complete first
            if (activeTab.editingPlugin && activeTab.editingPlugin.completeEdit) {
                activeTab.editingPlugin.completeEdit();
            }
            if (!this.taskEditor.validate())  {
                return false;
            }
            
            if (this.taskEditor.updateTask(callback)) {
                this.hide();
                return true;
            }
            return false;
        }
    },
    /**
     * Persists the values in this task editor into corresponding {@link Gnt.model.Task}
     * object provided to {@link #showTask}.
     * Internally just calls {@link Gnt.widget.taskeditor.TaskEditor#updateTask updateTask} method of task editor panel.
     * @param  {Function} callback A function to call when task modification is applied (or cancelled).
     */
    updateTask: function(callback) {
        if (this.taskEditor) {
            return this.taskEditor.updateTask(callback);
        }
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.startDataUpdatesMonitoring();
        if (this.saveOnEnter) {
            this.el.on({
                'keyup': function(e, t) {
                    if (e.getKey() === e.ENTER && t.tagName.toLowerCase() === 'input' && this.taskEditor.getActiveTab() instanceof Gnt.widget.taskeditor.BaseForm) {
                        this.onOkClick();
                    }
                },
                scope: this
            });
        }
    },
    onFirstShow: function() {
        if (this.zIndexManager.mask) {
            this.mon(this.zIndexManager.mask, 'click', function() {
                if (this.isVisible()) {
                    this.hide();
                }
            }, this);
        }
    },
    startDataUpdatesMonitoring: function() {
        var me = this,
            okBtn = me.down('#teOkBtn'),
            timerId = true;
        function monitor() {
            if (timerId && okBtn && me.taskEditor) {
                okBtn.setDisabled(!me.taskEditor.isDataChanged() || !me.taskEditor.isDataValid());
                timerId = Ext.Function.defer(monitor, me.monitorDataUpdatesInterval);
            }
        }
        function unmonitor() {
            timerId !== true && clearTimeout(timerId);
            timerId = true;
        }
        if (me.monitorDataUpdates && okBtn) {
            me.on({
                'show': monitor,
                'hide': unmonitor,
                'destroy': unmonitor
            });
        }
    },
    // Cancel any ongoing cell editors before hiding
    onBeforeHide: function() {
        Ext.each(this.query('[cancelEdit]'), function(grid) {
            grid.cancelEdit();
        });
    }
});

Ext.define('Gnt.util.Data', {
    singleton: true,
    cloneModel: function(record) {
        var cloned = record.copy();
        cloned.phantom = false;
        // keep link to original record
        cloned.originalRecord = record;
        return cloned;
    },
    // Copies a collection of records performing a copy of each model.
    // Each model in the resulting set keeps a link to its original instance in the originalRecord property.
    // Copied models have their "phantom" property set to false.
    // To apply changes made in the copy to its original data, {@link #applyCloneChanges} can be used.
    //
    // @param {Ext.data.Store/Ext.util.MixedCollection/Ext.data.Model[]} dataSet Collection of records to copy.
    // @param {Function} [fn] The function to be called at each model copying iteration.
    // @param {Ext.data.Model} fn.cloned The newly created copy of the model.
    // @param {Ext.data.Model} fn.original The original model.
    // @param {Mixed} [scope] The scope for fn function call. By default it`s the dataSet.
    // @return {Ext.data.Model[]} Array of cloned records.
    cloneModelSet: function(dataSet, fn, scope) {
        var me = this,
            data = [];
        var process = function(record) {
                var cloned = me.cloneModel(record);
                // if callback is set
                if (fn) {
                    if (fn.call(scope || dataSet, cloned, record) === false)  {
                        return;
                    }
                    
                }
                data.push(cloned);
            };
        if (dataSet.each) {
            dataSet.each(process);
        } else {
            Ext.Array.each(dataSet, process);
        }
        return data;
    },
    findOriginalRecords: function(records) {
        var result = [];
        for (var i = 0,
            l = records.length; i < l; i++) {
            if (records[i].originalRecord) {
                result.push(records[i].originalRecord);
            }
        }
        return result;
    },
    applyCloneChanges: function(cloneStore, originalStore, fn, scope) {
        var autoSyncSuspended = originalStore.autoSyncSuspended;
        // suspend automatic sync calls we will call sync() manually in the end of changes applying
        if (originalStore.autoSync && !autoSyncSuspended)  {
            originalStore.suspendAutoSync();
        }
        
        // first apply deleted records
        var removed = cloneStore.getRemovedRecords();
        var toRemove = this.findOriginalRecords(removed);
        if (toRemove.length) {
            originalStore.remove(toRemove);
            cloneStore.removed.length = 0;
        }
        // let`s get updated & added records
        var modified = cloneStore.getModifiedRecords(),
            originalRecord, data, added;
        // and loop over them
        for (var i = 0,
            l = modified.length; i < l; i++) {
            // original instance of modified record
            originalRecord = modified[i].originalRecord;
            // new data
            data = modified[i].getData();
            delete data[modified[i].idProperty];
            // if it`s modification of existing record
            if (originalRecord) {
                // let`s update it
                originalRecord.beginEdit();
                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }
                originalRecord.set(data);
                originalRecord.endEdit();
            } else // new record creation
            {
                // if custom callback specified
                if (fn) {
                    fn.call(scope || modified[i], data, modified[i]);
                }
                added = originalStore.add(data);
                // let`s bind our record to the "real" one
                modified[i].originalRecord = added && added[0];
            }
            modified[i].commit(true);
        }
        // enable autoSync back and call sync to persist changes
        if (originalStore.autoSync && !autoSyncSuspended) {
            originalStore.resumeAutoSync();
            originalStore.sync();
        }
        return {
            removed: toRemove,
            modified: modified
        };
    }
});

Ext.define('Gnt.widget.taskeditor.mixin.TaskFieldsContainer', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        id: 'taskFieldsContainer',
        before: {
            loadRecord: 'beforeRecordLoaded',
            loadTask: 'beforeRecordLoaded'
        },
        after: {
            constructor: 'afterConstructed',
            loadRecord: 'afterRecordLoaded',
            loadTask: 'afterRecordLoaded'
        }
    },
    /**
     * @cfg {String[]} notUpdatableFields Task fields that should not be updated when applying the form data to the task being edited.
     */
    notUpdatableFields: [
        'index',
        'isLast'
    ],
    autofillStandaloneFields: true,
    isFieldStandalone: function(field) {
        return !field.up('form');
    },
    fillStandaloneFields: function(task) {
        var me = this,
            fields = me.query('field'),
            field, fieldName, modelField;
        for (var i = 0; i < fields.length; i++) {
            field = fields[i];
            fieldName = field.name;
            modelField = task.getField(fieldName);
            if (modelField && me.isFieldStandalone(field)) {
                field.setValue(task.get(fieldName));
            }
        }
    },
    getTaskUpdateData: function(targetTask, sourceTask) {
        var me = this,
            newData = Ext.apply({}, sourceTask.getProjection(), sourceTask.getData()),
            genericFields = me.query('field[isTaskField!=true]'),
            genericField, fieldName, field;
        // Loop over fields that are not mixed in w/ TaskField class
        // to collect their values
        for (var i = 0; i < genericFields.length; i++) {
            genericField = genericFields[i];
            fieldName = genericField.name;
            field = targetTask.getField(fieldName);
            if (field && me.isUpdatebleTaskField(targetTask, fieldName)) {
                newData[fieldName] = genericField.getValue();
            }
        }
        // A special processing for "Segments" field:
        // need to update segments internal reference to their owning task
        var segments = newData[targetTask.segmentsField];
        if (segments) {
            newData[targetTask.segmentsField] = Ext.Array.map(segments, function(segment) {
                // clone segment and provide "task" property targeting the target task
                return segment.copy(segment.getId(), false, {
                    task: targetTask
                });
            });
        }
        // sanitize taskBuffer data before applying it to the task
        for (fieldName in newData) {
            if (!me.shouldUpdateTaskField(targetTask, fieldName, newData)) {
                delete newData[fieldName];
            }
        }
        return newData;
    },
    isUpdatebleTaskField: function(task, fieldName) {
        return fieldName != task.idProperty && (!this.notUpdatableFields || !Ext.Array.contains(this.notUpdatableFields, fieldName));
    },
    shouldUpdateTaskField: function(task, fieldName, newData) {
        var field = task.getField(fieldName);
        return field && this.isUpdatebleTaskField(task, fieldName) && !field.isEqual(newData[fieldName], task.get(fieldName));
    },
    afterConstructed: function() {
        var fields = this.query('field');
        for (var i = 0; i < fields.length; i++) {
            this.onTaskFieldsContainterItemAdd(this, fields[i]);
        }
        this.on('add', this.onTaskFieldsContainterItemAdd, this);
    },
    onTaskFieldsContainterItemAdd: function(container, item) {
        if (item.isFormField) {
            this.mon(item, 'change', this.onTaskFieldsContainterItemChange, this);
        }
    },
    onTaskFieldsContainterItemChange: function(field, newValue, oldValue) {
        // mark the field w/ manuallyChanged flag if the last change is made after the task is loaded and not caused by other field changes
        field.manuallyChanged = !field.loadingRecord && (field.isTaskField ? !field.processingTaskUpdate && !field.settingTask : true);
    },
    beforeRecordLoaded: function() {
        var fields = this.query('field');
        for (var i = 0; i < fields.length; i++) {
            fields[i].loadingRecord = true;
        }
    },
    afterRecordLoaded: function(task) {
        if (this.autofillStandaloneFields) {
            this.fillStandaloneFields(task);
        }
        var fields = this.query('field');
        for (var i = 0; i < fields.length; i++) {
            fields[i].loadingRecord = false;
        }
    }
});

/**
 @class Gnt.widget.taskeditor.BaseEditor
 @extends Ext.tab.Panel

 This is the baseclass for editors, it keeps the references to the stores and the loaded task instances.

 */
Ext.define('Gnt.widget.taskeditor.BaseEditor', {
    extend: 'Ext.tab.Panel',
    requires: [
        'Gnt.util.Data'
    ],
    uses: [
        'Gnt.data.undoredo.Manager'
    ],
    mixins: {
        localizable: 'Gnt.mixin.Localizable',
        taskFieldsContainer: 'Gnt.widget.taskeditor.mixin.TaskFieldsContainer'
    },
    margin: '5 0 0 0',
    height: (Ext.theme && Ext.theme.name.match('Graphite|Material') ? 550 : 340),
    width: (Ext.theme && Ext.theme.name.match('Graphite|Material') ? 800 : 600),
    layout: 'fit',
    border: false,
    plain: false,
    defaults: {
        margin: 5,
        border: false
    },
    eventIndicator: 'task',
    /**
     * @cfg {Gnt.model.Task} task The task to edit.
     */
    task: null,
    //private a buffer for the task
    taskBuffer: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is a required option if the task being edited doesn't belong to any task store.
     */
    taskStore: null,
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #resourceStore}).
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     *
     * **Note:** It has to be provided to show the `Resources` tab (See also {@link #assignmentStore}).
     */
    resourceStore: null,
    tabBar: {
        cls: 'gnt-taskeditor-header'
    },
    clonedStores: null,
    taskStoreConfigsToClone: 'disableDateAdjustments,calendarManager,model,weekendsAreWorkdays,cascadeChanges,skipWeekendsDuringDragDrop,moveParentAsGroup,enableDependenciesForParentTasks,availabilitySearchLimit,dependenciesCalendar,scheduleByConstraints,projectStartDate',
    /**
     * @event validate
     * @preventable
     * Fires when task validating occurs.
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor instance.
     * @param {Ext.Component} tabToFocus The tab panel item where one or more invalid fields was detected.
     *
     * Fires during a {@link #method-validate} method call when task validation occurs.
     * Return `false` to make the validation fail, but take care of marking invalid component somehow (to let user know of error)
     * since normally invalid components are being highlighted during validate call.
     * For example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          items       : {
     *              title   : 'Some custom tab',
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          },
     *          listeners   : {
     *              validate    : function (taskeditor, tabToFocus) {
     *                  var field = taskeditor.down('#enter-your-name');
     *                  // if validation of our field failed
     *                  if (!field.isValid()) {
     *                      // if no other tabs with some invalid control
     *                      if (!tabToFocus) {
     *                          var activeTab = taskeditor.getActiveTab();
     *                          // if our field is not placed at currently active tab
     *                          if (!field.isDescendantOf(activeTab)) {
     *                              // then we'll switch to tab where our field resides
     *                              taskeditor.setActiveTab(taskeditor.getTabByComponent(field));
     *                          }
     *                      }
     *                      // return false since validation failed
     *                      return false;
     *                  }
     *              }
     *          }
     *      });
     *
     */
    /**/
    constructor: function(config) {
        var me = this;
        config = config || {};
        Ext.apply(me, config);
        // Prepare empty store clones (data loading occurs in loadTask() method).
        if (!me.clonedStores && (me.task || me.taskStore)) {
            me.cloneStores();
        }
        var items = me.buildItems(config);
        var its = me.items;
        // user defined tabs go after our predefined ones
        if (its) {
            items.push.apply(items, Ext.isArray(its) ? its : [
                its
            ]);
            delete config.items;
        }
        me.items = items;
        // if we have the only tab let's hide the tabBar
        if (me.items.length <= 1) {
            config.tabBar = config.tabBar || {};
            Ext.applyIf(config.tabBar, {
                hidden: true
            });
        }
        this.callParent([
            config
        ]);
        // if task is provided let's load it
        if (this.task) {
            this.loadTask(this.task);
        } else // otherwise update enclosed components readOnly state
        {
            me.setReadOnly(true);
        }
    },
    buildItems: function() {
        return [];
    },
    cloneTasks: function(task) {
        task = task || this.task;
        var me = this,
            taskStore = me.getTaskStore(),
            newRoot = me.cloneTask(taskStore.getRoot(), true),
            taskBuffer = newRoot.findChild(task.idProperty, task.getId(), true);
        return {
            task: taskBuffer,
            root: newRoot
        };
    },
    /**
     * Loads task data into task editor.
     * @param {Gnt.model.Task} task Task to load to editor.
     */
    loadTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.task = task;
        // clone stores ..if they were not cloned yet
        this.cloneStores({
            task: task
        });
        // fill cloned stores with data
        this.loadClonedStores(task);
    },
    buildTaskStoreCloneConfig: function(store, config) {
        // TODO: ideally we need to clone calendar manager as well
        // but this is not that trivial since adding records to a calendar manager
        // automatically causes calendars creation
        var cloneConfig = Ext.apply({
                calendar: store.getCalendar(),
                batchSync: false,
                recalculateParents: false,
                // Switch auto normalization, since it might corrupt parent nodes auto-calculated fields (Effort etc.)
                // because we don't clone all the children
                autoNormalizeNodes: false
            }, config);
        return Ext.copyIf(cloneConfig, store, this.taskStoreConfigsToClone);
    },
    // We need fake taskStore to give task copy ability to ask it for the project calendar
    cloneTaskStore: function(task, config) {
        var store = this.getTaskStore(),
            result;
        if (store) {
            result = this.cloneStore(store, this.buildTaskStoreCloneConfig(store, config));
            // on bind different calendar to the original task store we do the same for the copy
            this.mon(store, {
                calendarset: function(store, calendar) {
                    result.setCalendar(calendar);
                }
            });
        }
        return result;
    },
    cloneStore: function(store, config) {
        return new store.self(Ext.apply({
            isCloned: true,
            cloneOf: store,
            model: store.model,
            storeId: null,
            autoSync: false,
            autoLoad: false,
            proxy: {
                type: 'memory',
                reader: 'json'
            }
        }, config));
    },
    cloneDependencyStore: function(task, config) {
        var taskStore = this.getTaskStore(),
            store = this.dependencyStore || taskStore && taskStore.getDependencyStore();
        if (!store)  {
            return null;
        }
        
        return this.cloneStore(store, Ext.apply({
            transitiveDependencyValidation: store.transitiveDependencyValidation,
            strictDependencyValidation: store.strictDependencyValidation,
            allowedDependencyTypes: store.allowedDependencyTypes,
            allowParentTaskDependencies: store.allowParentTaskDependencies,
            autoCalculateLag: store.autoCalculateLag
        }, config));
    },
    cloneAssignmentStore: function(task, config) {
        var taskStore = this.getTaskStore(),
            store = this.assignmentStore || taskStore && taskStore.getAssignmentStore();
        if (!store)  {
            return null;
        }
        
        return this.cloneStore(store, config);
    },
    cloneResourceStore: function(task, config) {
        var taskStore = this.getTaskStore(),
            store = this.resourceStore || taskStore && taskStore.getResourceStore();
        if (!store)  {
            return null;
        }
        
        return this.cloneStore(store, config);
    },
    cloneStores: function(config) {
        config = config || {};
        var task = config.task || this.task,
            resourceStore = this.getResourceStoreClone() || this.cloneResourceStore(task, config.resourceStore),
            assignmentStore = this.getAssignmentStoreClone() || this.cloneAssignmentStore(task, config.assignmentStore),
            dependencyStore = this.getDependencyStoreClone() || this.cloneDependencyStore(task, config.dependencyStore);
        var taskStore = this.getTaskStoreClone() || this.cloneTaskStore(task, Ext.apply({
                assignmentStore: assignmentStore,
                resourceStore: resourceStore,
                dependencyStore: dependencyStore
            }, config.taskStore));
        resourceStore.taskStore = taskStore;
        this.setResourceStoreClone(resourceStore);
        this.setAssignmentStoreClone(assignmentStore);
        this.setDependencyStoreClone(dependencyStore);
        this.setTaskStoreClone(taskStore);
    },
    setTaskStore: function(store) {
        this.taskStore = store;
        this.destroyClonedStores();
    },
    getTaskStore: function(task) {
        task = task || this.task;
        return this.taskStore || task && task.getTaskStore();
    },
    setDependencyStore: function(store) {
        // there is no this.dependencyStore, value is taken from task store always
        this.destroyClonedStores();
    },
    getDependencyStore: function(task) {
        task = task || this.task;
        // there is no this.dependencyStore, value is taken from task store always
        return this.getTaskStore(task).getDependencyStore();
    },
    setResourceStore: function(store) {
        this.resourceStore = store;
        this.destroyClonedStores();
    },
    getResourceStore: function(task) {
        task = task || this.task;
        return this.resourceStore || this.getTaskStore(task).getResourceStore();
    },
    setAssignmentStore: function(store) {
        this.assignmentStore = store;
        this.destroyClonedStores();
    },
    getAssignmentStore: function(task) {
        task = task || this.task;
        return this.assignmentStore || this.getTaskStore(task).getAssignmentStore();
    },
    getTaskStoreClone: function() {
        return this.clonedStores && this.clonedStores.taskStore;
    },
    getDependencyStoreClone: function() {
        return this.clonedStores && this.clonedStores.dependencyStore;
    },
    getAssignmentStoreClone: function() {
        return this.clonedStores && this.clonedStores.assignmentStore;
    },
    getResourceStoreClone: function() {
        return this.clonedStores && this.clonedStores.resourceStore;
    },
    setTaskStoreClone: function(store) {
        this.clonedStores = this.clonedStores || {};
        this.clonedStores.taskStore = store;
    },
    setDependencyStoreClone: function(store) {
        this.clonedStores = this.clonedStores || {};
        this.clonedStores.dependencyStore = store;
    },
    setAssignmentStoreClone: function(store) {
        this.clonedStores = this.clonedStores || {};
        this.clonedStores.assignmentStore = store;
    },
    setResourceStoreClone: function(store) {
        this.clonedStores = this.clonedStores || {};
        this.clonedStores.resourceStore = store;
    },
    loadClonedStores: function(task) {
        var me = this;
        me.loadClonedTaskStore(task);
        me.loadClonedDependencyStore(task);
        me.loadClonedResourceStore(task);
        me.loadClonedAssignmentStore(task);
    },
    loadClonedTaskStore: function(task) {
        var me = this,
            store = me.getTaskStoreClone(),
            copy = me.cloneTasks(task),
            taskBuffer = copy.task;
        me.taskBuffer = taskBuffer;
        // fill task store clone w/ task copies
        store.setRoot(copy.root);
        taskBuffer.taskStore.on({
            update: function(store, record, operation) {
                if (record === taskBuffer && operation == Ext.data.Model.EDIT) {
                    me.onTaskUpdated.call(me, record);
                    record.fireEvent(me.eventIndicator + 'updated', record);
                }
            }
        });
    },
    loadClonedDependencyStore: function(task) {
        var store = this.getDependencyStoreClone();
        store && store.loadData(Gnt.util.Data.cloneModelSet(this.getDependencyStore(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    loadClonedResourceStore: function(task) {
        var store = this.getResourceStoreClone();
        store && store.loadData(Gnt.util.Data.cloneModelSet(this.getResourceStore(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    loadClonedAssignmentStore: function(task) {
        var store = this.getAssignmentStoreClone();
        store && store.loadData(Gnt.util.Data.cloneModelSet(this.getAssignmentStore(), function(copy, original) {
            copy.setId(original.getId());
        }));
    },
    cloneTask: function(task, deep) {
        var me = this,
            result = task.copy(task.getId(), false);
        result.taskStore = me.getTaskStoreClone();
        if (deep) {
            var len = task.childNodes.length;
            for (var i = 0; i < len; i++) {
                result.appendChild(me.cloneTask(task.childNodes[i], deep));
            }
        }
        return result;
    },
    /**
     * Returns the task editor tab that contains specified component.
     * @return {Ext.Component} Tab containing specified component or `undefined` if item is not found.
     */
    getTabByComponent: function(component) {
        var result;
        this.items.each(function(el) {
            if (component === el || component.isDescendantOf(el)) {
                result = el;
                return false;
            }
        }, this);
        return result;
    },
    /**
     * Checks data loaded or entered to task editor for errors.
     * Calls isValid methods of taskForm, dependencyGrid, advancedForm (if corresponding objects are presented at the task editor).
     * In case some of calls returns `false` switch active tab so that user can view invalid object.
     * Validation can be customized by handling {@link #event-validate} event.
     *
     * Returns `false` in that case.
     * @return {Boolean} Returns `true` if all components are valid.
     */
    validate: function() {
        var result,
            activeTab = this.getActiveTab(),
            invalidTabs = [],
            tabToActivate;
        result = this.doValidate(function(tab) {
            invalidTabs.push(tab);
        });
        if (!result && activeTab && !Ext.Array.contains(invalidTabs, activeTab)) {
            tabToActivate = invalidTabs[0];
            this.setActiveTab(tabToActivate);
        } else if (!result && activeTab) {
            tabToActivate = activeTab;
        } else if (!result) {
            tabToActivate = invalidTabs[0];
        }
        // validation result
        return (this.fireEvent('validate', this, tabToActivate) !== false) && result;
    },
    initRoboManager: function() {
        var taskStore = this.getTaskStore();
        // send "pause" command to other bound undo managers
        taskStore.fireEvent('robo-command', taskStore, 'pause', []);
        var robo = this.robo = new Gnt.data.undoredo.Manager({
                stores: [
                    taskStore,
                    taskStore.getDependencyStore(),
                    taskStore.getAssignmentStore(),
                    taskStore.getResourceStore()
                ]
            });
        // the undo manager should not listen to own "robo-command" events
        robo.disableIncomingCommands();
        robo.start();
        return this.robo;
    },
    onTaskUpdatePropagationComplete: function(cancelChanges, affectedTasks) {
        var robo = this.robo;
        var taskStore = this.getTaskStore();
        cancelChanges && robo.undo();
        var transaction = robo.currentTransaction;
        transaction && robo.endTransaction();
        if (cancelChanges) {
            robo.undo();
        } else {
            // If we've got a transaction recorded let's inform other registered undo/redo managers about it
            if (transaction && transaction.hasActions()) {
                taskStore.fireEvent('robo-command', taskStore, 'endTransaction', []);
                taskStore.fireEvent('robo-command', taskStore, 'addTransaction', [
                    transaction
                ]);
            }
        }
        // send "resume" command to other bound undo managers
        taskStore.fireEvent('robo-command', taskStore, 'resume', []);
        // destroy the undo/redo manager made for this operation
        robo.destroy();
    },
    propagateTaskUpdateChanger: function(task, continueFn) {
        var me = this;
        me.doUpdateTask(task, continueFn);
        me.fireEvent('afterupdate' + me.eventIndicator, me);
        continueFn(task);
    },
    propagateTaskUpdate: function(callback, scope) {
        var me = this,
            task = me.task;
        me.initRoboManager();
        task.propagateChanges(Ext.bind(me.propagateTaskUpdateChanger, me), function onPropagationComplete(cancelChanges, affectedTasks) {
            me.onTaskUpdatePropagationComplete(cancelChanges, affectedTasks);
            callback && callback.call(scope || me, cancelChanges, affectedTasks);
        }, null, true);
    },
    // async
    /**
     * Persists the changes made in the task editor into the loaded {@link Gnt.model.Task task}.
     * @return {Boolean} Returns `false` if some {@link #beforeupdatetask} listener returned `false` and `true` otherwise.
     */
    updateTask: function(callback) {
        var me = this,
            result = false;
        function finalizeUpdateTask() {
            me.propagateTaskUpdate(callback);
        }
        if (me.fireEvent('beforeupdate' + me.eventIndicator, me, finalizeUpdateTask) !== false) {
            finalizeUpdateTask();
            result = true;
        }
        return result;
    },
    destroyClonedStores: function() {
        if (this.clonedStores) {
            Ext.Object.each(this.clonedStores, function(storeKey, store) {
                store.destroy();
            });
        }
        this.clonedStores = null;
    },
    onDestroy: function() {
        this.destroyClonedStores();
        this.callParent(arguments);
    },
    doValidate: function() {
        return true;
    },
    isDataValid: function() {
        return this.doValidate();
    },
    isDataChanged: function() {
        return false;
    },
    doUpdateTask: function() {
        throw 'Abstract method called';
    },
    /**
     * Updates underlying components readOnly state as reaction on either the editor readOnly state change
     * or the task being editing update.
     * @protected
     */
    updateReadOnly: function() {
        throw 'Abstract method called';
    },
    getReadOnly: function() {
        return !this.task || this.readOnly;
    },
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.updateReadOnly();
    },
    onTaskUpdated: function() {
        this.updateReadOnly();
    },
    init: function(cmp) {
        // Make sure Ext can position the editor on top of the z-index stack
        this.ownerCmp = cmp;
        this.callParent(arguments);
    }
});

/**
 * Base class with common functionality for {@link Gnt.widget.taskeditor.TaskForm task} and {@link Gnt.widget.taskeditor.ProjectForm project form}.
 */
Ext.define('Gnt.widget.taskeditor.BaseForm', {
    extend: 'Ext.form.Panel',
    mixins: [
        'Gnt.mixin.Localizable',
        'Sch.widget.mixin.CustomizableRecordForm',
        'Gnt.widget.taskeditor.mixin.TaskFieldsContainer'
    ],
    isTaskEditorForm: true,
    /**
     * @cfg {Boolean} highlightTaskUpdates `true` to highlight fields updates initiated by changes of another fields.
     */
    highlightTaskUpdates: true,
    /**
     * @cfg {Gnt.model.Task} task A task to load to the form.
     */
    /**
     * @property {Gnt.model.Task} task The task loaded in the form.
     */
    task: null,
    /**
     * @cfg {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    /**
     * @property {Gnt.model.Task} taskBuffer A task used to keep intermediate values of fields implemented by {@link Gnt.field.mixin.TaskField} mixin.
     */
    taskBuffer: null,
    /**
     * @cfg {Gnt.data.TaskStore} taskStore A store with tasks.
     *
     * **Note:** This is required option if task being loaded isn't yet belong to any task store.
     */
    taskStore: null,
    taskListeners: null,
    autoScroll: true,
    labelWidth: (Ext.theme && Ext.theme.name.match('Graphite|Material') ? 180 : 130),
    padding: 10,
    propagateChanges: false,
    border: false,
    defaultType: 'textfield',
    // to reset dirty flags on every record load
    trackResetOnLoad: true,
    autofillStandaloneFields: false,
    initComponent: function() {
        this.defaults = this.defaults || {};
        this.defaults.labelWidth = this.defaults.labelWidth || this.labelWidth;
        // if no field definitions provided we make the default fields set
        if (!this.items) {
            this.buildFields();
        }
        this.callParent(arguments);
        this.addBodyCls('gnt-taskeditor-form');
        if (this.task) {
            this.loadRecord(this.task, this.taskBuffer);
        }
    },
    /**
     * Suppress task updates invoking by form fields. Calls setSuppressTaskUpdate() of each field that supports this method.
     * @param {Boolean} state Suppress or allow task updating.
     */
    setSuppressTaskUpdate: function(state) {
        var fields = this.getForm().getFields();
        fields.each(function(field) {
            // if field contains setTask() method
            field.setSuppressTaskUpdate && field.setSuppressTaskUpdate(state);
        });
    },
    isDataChanged: function() {
        return this.isDirty();
    },
    buildTaskBuffer: function(task) {
        var me = this;
        me.taskBuffer = task.copy();
        // since copy() doesn't copy taskStore let`s copy it ourself
        me.taskBuffer.taskStore = task.taskStore;
    },
    /**
     * Loads an Gnt.model.Task into this form.
     * @param {Gnt.model.Task} task The record to edit.
     * @param {Gnt.model.Task} [taskBuffer] The record to be used as a buffer to keep changed values of fields which implement {@link Gnt.field.mixin.TaskField}
     * mixin interface. This parameter can be used in case when you want to implement two form instances instantly
     * reflecting changes of each other:
     *
     *      // create 1st TaskForm instance
     *      var taskForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load record into 1st form
     *      taskForm.loadRecord(someTask);
     *
     *      // create 2nd TaskForm instance
     *      var anotherForm = Ext.create('Gnt.widget.taskeditor.TaskForm');
     *      // load the same record into 2nd form
     *      // and set to share taskBuffer with 1st form to immediately refect changes of each other
     *      anotherForm.loadRecord(someTask, taskForm.taskBuffer);
     */
    loadRecord: function(task, taskBuffer) {
        var me = this;
        me.task = task;
        me.taskBuffer = taskBuffer;
        // if no pre-created taskBuffer provided, let`s create it
        if (!me.taskBuffer) {
            me.buildTaskBuffer(task);
        }
        // destroy previous task listeners if any
        me.taskListeners && me.taskListeners.destroy();
        // listen to 'taskupdated' event and update fields "readonly" state
        me.taskListeners = me.mon(me.taskBuffer, {
            taskupdated: me.onTaskUpdated,
            destroyable: true,
            scope: me
        });
        var form = me.getForm();
        // following code is modified implementation
        // of Ext.form.Basic setValues() method
        form._record = task;
        this.suspendLayouts();
        var data = task.getData();
        form.getFields().each(function(field) {
            var fieldName = field.getName();
            // if the record has a field w/ this name
            if (fieldName && task.getField(fieldName)) {
                // if field contains setTask() method
                // we use it since setTask() execute setValue()
                if (field.setTask) {
                    field.setTask(me.taskBuffer);
                } else {
                    // set field value
                    field.setValue(data[field.getName()]);
                }
                // and set its readOnly state depending on gantt readOnly state and task.isEditable() result
                me.updateFieldReadOnly(field);
                if (form.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        });
        this.resumeLayouts(true);
        this.fireEvent('afterloadrecord', this, task);
    },
    updateFieldReadOnly: function(field) {
        var me = this;
        if (!field.disabled) {
            // Having forceReadOnly=true on a field disables TaskField and BaseForm logic that switches the field readOnly state
            // depending on the task being edited isEditable() result or the form readOnly state
            if (!field.forceReadOnly) {
                var isTaskField = field.isTaskField;
                // if the form is readOnly
                if (me.getReadOnly()) {
                    // we set the field readOnly too
                    field.setReadOnly(true);
                    // if it's a TaskField we suspend its own readOnly mechanism to prevent it from enabling the field back
                    isTaskField && !field.isReadOnlyUpdateSuspended() && field.suspendReadOnlyUpdate();
                } else // if the form is editable
                {
                    // if it's not a TaskField we take the task.isEditable() result into account
                    if (!isTaskField) {
                        var isEditable = me.taskBuffer.isEditable(field.name);
                        if (this.editable === false) {
                            if (isEditable && field.inputEl) {
                                field.inputEl.dom.readOnly = true;
                            }
                        }
                        field.setReadOnly(!isEditable);
                    } else {
                        field.resumeReadOnlyUpdate();
                        field.updateReadOnly(me.taskBuffer);
                    }
                }
            }
        }
    },
    // Updates readOnly state of all the form fields
    updateReadOnly: function() {
        var me = this,
            form = me.getForm();
        form.getFields().each(function(field) {
            me.updateFieldReadOnly(field);
        });
    },
    /**
     * Applies the values from this form into the passed {@link Gnt.model.Task} object.
     * If the task is not specified, it will attempt to update (if it exists) the record provided to {@link #loadRecord}.
     * @param {Gnt.model.Task} [task] The record to apply change to.
     */
    updateRecord: function(task) {
        var me = this;
        task = task || me.task;
        if (task && me.fireEvent('beforeupdaterecord', me, task, me.updateRecordFn) !== false) {
            var changerFn = function() {
                    me.setSuppressTaskUpdate(true);
                    me.updateRecordFn.call(me, task);
                    me.setSuppressTaskUpdate(false);
                    me.fireEvent('afterupdaterecord', me, task);
                    return true;
                };
            if (me.propagateChanges) {
                task.propagateChanges(changerFn);
            } else {
                changerFn();
            }
            return true;
        }
        return false;
    },
    /**
     * A function that applies changes to the task. Override this function for custom logic.
     * @param task
     */
    updateRecordFn: function(task) {
        var me = this;
        task.set(me.getTaskUpdateData(task, me.taskBuffer));
    },
    // Applies "task", "taskStore", "highlightTaskUpdates" and "readOnly" configs to a field
    initFieldDefinition: function(field, cfg) {
        var me = this;
        var commonParams = {
                taskStore: me.taskStore,
                task: me.task,
                highlightTaskUpdates: me.highlightTaskUpdates
            };
        // if field isn't already read only then let's take into account Task.isEditable() result
        if (!field.readOnly && me.task) {
            commonParams.readOnly = !me.task.isEditable(field.name);
        }
        return Ext.apply(field, commonParams, cfg);
    },
    // Gets the task field value
    getTaskFieldValue: function(field) {
        var me = this,
            task = this.task;
        return task ? task.get(me.customizableFieldNames[field]) : '';
    },
    onTaskUpdated: function(task, field) {
        // let's update fields "readonly" status after task data has been modified
        this.updateReadOnly();
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.updateReadOnly();
    }
});

/**
 @class Gnt.widget.taskeditor.ProjectForm
 @extends Gnt.widget.taskeditor.BaseForm

 This form is used to edit the project properties.
 By default it supports editing of the following fields:

 - the name of the project (project title)
 - the start date of the project
 - the end date of the project
 - the calendar assigned to the project
 - the dependency status, whether the project allows external tasks dependencies

 * **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

 ## Extending the default field set

 The default field set can be overwritten using the {@link #items} config.
 In case you want to keep the default fields and add some new custom fields, you can use the code below:

            // Extend the standard ProjectForm class
            Ext.define('MyProjectForm', {
                    extend : 'Gnt.widget.taskeditor.ProjectForm',

                    constructor : function(config) {
                        this.callParent(arguments);

                        // add some custom field
                        this.add({
                            fieldLabel  : 'Foo',
                            name        : 'Name',
                            width       : 200
                        });
                    }
            });

            // create customized form
            var form = new MyProjectForm({...});

 */
Ext.define('Gnt.widget.taskeditor.ProjectForm', {
    // This form by default contains various "standard" fields of the project
    // and it "knows" about their "applyChanges" methods (for our fields),
    // and about renamed field names
    // This form can be also used with any other set of fields, provided
    // as the "items" config
    extend: 'Gnt.widget.taskeditor.BaseForm',
    alias: 'widget.projectform',
    requires: [
        'Gnt.model.Project',
        'Ext.Date',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Gnt.field.Calendar',
        'Gnt.field.StartDate',
        'Gnt.field.EndDate',
        'Gnt.field.ReadOnly',
        'Gnt.field.ScheduleBackwards',
        'Ext.form.field.Checkbox'
    ],
    alternateClassName: [
        'Gnt.widget.ProjectForm'
    ],
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be added to this container.
     *
     * **Note:** By default this form provide pre-configured set of fields. Using this option will overwrite that field set.
     */
    /**
     * @cfg {Boolean} showCalendar Provide `true` to display `Calendar` field.
     */
    showCalendar: false,
    /**
     * @cfg {Object} l10n
     * An object, purposed for the class localization. Contains the following keys/values:
     *
     * - nameText                : 'Name',
     * - startText               : 'Start',
     * - finishText              : 'Finish',
     * - calendarText            : 'Calendar',
     * - readOnlyText            : 'Read Only',
     * - allowDependenciesText   : 'Allow cross-project dependencies',
     * - 'Schedule from'         : 'Schedule from'
     */
    /**
     * @cfg {Object} nameConfig A config object to be applied to the `Name` field.
     */
    nameConfig: null,
    /*
     * @cfg {Object} readOnlyConfig A config object to be applied to the `ReadOnly` field.
     */
    readOnlyConfig: null,
    /**
     * @cfg {Object} allowDependenciesConfig A config object to be applied to the `AllowDependencies` field.
     */
    allowDependenciesConfig: null,
    /**
     * @cfg {Object} startConfig A config object to be applied to the `Start` field.
     */
    startConfig: null,
    /**
     * @cfg {Object} finishConfig A config object to be applied to the `Finish` field.
     */
    finishConfig: null,
    /**
     * @cfg {Object} calendarConfig A config object to be applied to the `Calendar` field.
     */
    calendarConfig: null,
    /**
     * @cfg {Object} schedulebackwardsConfig A config object to be applied to the `Schedule from` field.
     */
    schedulebackwardsConfig: null,
    defaults: {
        anchor: '100%',
        labelWidth: 110
    },
    constructor: function(config) {
        config = config || {};
        // setup mixin that tracks "*Field" model properties and is responsible for fields renaming
        this.setupCustomizableRecordForm(this, Gnt.model.Project);
        this.callParent(arguments);
        this.addBodyCls('gnt-projecteditor-projectform');
    },
    // Builds default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.customizableFieldNames;
        me.items = me.items || [];
        me.items.push(me.initFieldDefinition({
            xtype: 'textfield',
            fieldLabel: me.L('nameText'),
            name: f.nameField,
            allowBlank: false,
            value: me.getTaskFieldValue(f.nameField)
        }, me.nameConfig), {
            xtype: 'container',
            layout: 'hbox',
            defaults: {
                flex: 1,
                labelWidth: 110,
                margin: '5 5 5 0'
            },
            items: [
                me.initFieldDefinition({
                    allowBlank: false,
                    xtype: 'startdatefield',
                    fieldLabel: me.L('startText'),
                    format: Ext.Date.defaultFormat,
                    name: f.startDateField,
                    value: me.getTaskFieldValue(f.startDateField)
                }, me.startConfig),
                me.initFieldDefinition({
                    allowBlank: false,
                    margin: '5 0',
                    xtype: 'enddatefield',
                    format: Ext.Date.defaultFormat,
                    fieldLabel: me.L('finishText'),
                    name: f.endDateField,
                    value: me.getTaskFieldValue(f.endDateField)
                }, me.finishConfig)
            ]
        }, me.initFieldDefinition({
            xtype: 'schedulebackwardsfield',
            fieldLabel: me.L('Schedule from'),
            name: f.scheduleBackwardsField
        }, me.schedulebackwardsConfig), {
            xtype: 'container',
            layout: 'hbox',
            padding: '0 0 0 110',
            defaults: {
                flex: 1,
                margin: '5 5 5 0'
            },
            items: [
                me.initFieldDefinition({
                    xtype: 'readonlyfield',
                    boxLabel: me.L('readOnlyText'),
                    allowBlank: false,
                    name: f.readOnlyField,
                    value: me.getTaskFieldValue(f.readOnlyField)
                }, me.readOnlyConfig),
                me.initFieldDefinition({
                    xtype: 'checkboxfield',
                    boxLabel: me.L('allowDependenciesText'),
                    allowBlank: false,
                    name: f.allowDependenciesField,
                    value: me.getTaskFieldValue(f.allowDependenciesField)
                }, me.allowDependenciesConfig)
            ]
        });
        if (me.showCalendar) {
            me.items.push(me.initFieldDefinition({
                xtype: 'calendarfield',
                fieldLabel: this.L('calendarText'),
                flex: 1,
                margin: '5 0 5 0',
                name: f.calendarIdField,
                value: me.getTaskFieldValue(f.calendarIdField)
            }, me.calendarConfig));
        }
    }
});

/**
 @class Gnt.widget.taskeditor.ProjectEditor
 @extends Gnt.widget.taskeditor.BaseEditor

 A widget used to display and edit project information.
 By default the widget is an Ext.tab.Panel instance which can contain the following tabs:

 - General information
 - Description

 You can easily add new custom tabs using {@link #items} config.

 # General

 Contains a customizable {@link Gnt.widget.ProjectForm form} instance for viewing and editing the following project data:

 - the name of the project
 - the start date of the project
 - the end date of the project
 - the readOnly status of the project
 - the allowDependencies status of the project

 ### Project form customization

 There is a {@link #projectFormConfig} config which can be used to customize the form panel.

        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // Configure the form located in the "General" tab
            projectFormConfig : {
                // turn off fields highlighting
                highlightTaskUpdates : false,
                // alter panel margin
                margin : 20
            }
        });

 ### Fields configuration

 The {@link Gnt.widget.ProjectForm} class has a config for each field presented at the `General` tab.
 And using {@link #projectFormConfig} we can get access for those options to setup fields.
 For example:

        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // setup form located at "General" tab
            projectFormConfig : {
                // set AllowDependencies field invisible
                allowDependenciesConfig : {
                    hidden : true
                }
            }
        });

 Here are some more configs for other fields:

 - {@link Gnt.widget.ProjectForm#nameConfig nameConfig} (the name of the project field)
 - {@link Gnt.widget.ProjectForm#startConfig startConfig} (the start date of the project field)
 - {@link Gnt.widget.ProjectForm#finishConfig finishConfig} (the end date of the project field)

 Please see {@link Gnt.widget.ProjectForm} class to see the full list of available config options.

 ### Extending the General field set

 If you want to add a new field to the `General` tab you will have to extend the {@link Gnt.widget.ProjectForm ProjectForm} class.
 After that you will need to configure the project editor to use your extended class:

        // extend standard ProjectForm class
        Ext.define('MyProjectForm', {
            extend : 'Gnt.widget.taskeditor.ProjectForm',

            constructor : function(config) {
                this.callParent(arguments);

                // add some custom field
                this.add({
                    fieldLabel  : 'Foo',
                    name        : 'Name',
                    width       : 200
                });
            }
        });

        // Let task editor know which class to use
        Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
            // to use MyProjectForm to build the "General" tab
            projectFormClass : 'MyProjectForm'
        });

 #Description

 Contains an {@link Ext.form.field.HtmlEditor} HTML editor instance for viewing and editing a freetext description about the Project.

You can enable/disable this tab by setting the {@link #showDescription} option.
To rename this tab you can use the `descriptionText` property of {@link #l10n} config.
Customizing the grid itself can be done via the {@link #descriptionConfig} config.

 */
Ext.define('Gnt.widget.taskeditor.ProjectEditor', {
    extend: 'Gnt.widget.taskeditor.BaseEditor',
    alias: 'widget.projecteditor',
    requires: [
        'Ext.form.field.HtmlEditor',
        'Gnt.widget.taskeditor.ProjectForm',
        'Ext.panel.Panel'
    ],
    alternateClassName: [
        'Gnt.widget.ProjectEditor'
    ],
    eventIndicator: 'project',
    /**
     * @event loadproject
     * Fires after project has been loaded into the editor.
     *
     * This event can be used to do additional data loading if project editor was extended with some extra fields.
     * Also please take a look at {@link #afterupdateproject} event to have an example of how to implement custom data saving.
     *
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor widget instance.
     * @param {Gnt.model.Project} project The project.
     */
    /**
     * @event beforeupdateproject
     * @preventable
     * Fires before project updating occurs. Return `false` to prevent the update.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor widget instance.
     * @param {Function} proceedCallback The function which can be called manually to continue project updating. Example:
     */
    /**
     * @event afterupdateproject
     * Fires after a project has been updated.
     *
     * This event can be used to do some extra processing after project was updated by project editor.
     * For example in case when you have some additional fields you can implement saving of them using this event.
     * Also please take a look at {@link #loadproject} event to have an example of how to implement custom data loading.
     *
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The project editor instance.
     */
    /**
     * @event validate
     * @preventable
     * Fires when task validating occurs.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor The task editor instance.
     * @param {Ext.Component} tabToFocus The tab panel item where one or more invalid fields was detected.
     *
     * Fires during a {@link #method-validate} method call when task validation occurs.
     * Return `false` to make the validation fail, but take care of marking invalid component somehow (to let user know of error)
     * since normally invalid components are being highlighted during validate call.
     */
    /**
     * @cfg {Gnt.model.Project} task The project to edit.
     */
    /**
     * @cfg {String} projectFormClass Class representing the form in the `General` tab.
     *
     * This option supposed to be used to implement a custom form in the `General` tab content.
     */
    projectFormClass: 'Gnt.widget.taskeditor.ProjectForm',
    /**
     * @cfg {Boolean} showDescription `true` to display a `Description` tab.
     */
    showDescription: true,
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be **appended** after default tabs to this container.
     * For example:
     *
     *      var projectEditor = Ext.create('Gnt.widget.taskeditor.ProjectEditor', {
     *          items: [{
     *              title   : "Some custom tab",
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          }]
     *      });
     */
    /**
     * @cfg {Object} projectFormConfig Configuration options to be supplied to the `General` tab.
     * For possible options take a look at the {@link Gnt.widget.ProjectForm}.
     */
    projectFormConfig: null,
    /**
     * @cfg {Object} descriptionConfig Configuration options for the HTML-editor placed in the `Description` tab.
     * For possible options take a look at the {@link Ext.form.field.HtmlEditor}.
     */
    descriptionConfig: null,
    /**
     * @property {Ext.panel.Panel} descriptionPanel The `Description` tab.
     * Please use {@link #descriptionEditor} to access an enclosed HTML-editor.
     */
    descriptionPanel: null,
    /**
     * @property {Ext.form.field.HtmlEditor} descriptionEditor The HTML-editor presented in the `Description` tab.
     * To specify setting for the HTML-editor please use {@link #descriptionConfig}.
     */
    descriptionEditor: null,
    /**
     * @property {Gnt.widget.ProjectForm} projectForm The `General` tab project form.
     * By default it's a {@link Gnt.widget.ProjectForm} instance but it might be customized by using {@link #projectFormClass} option.
     */
    projectForm: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - generalText         : 'General',
     - descriptionText     : 'Description',
     */
    buildItems: function() {
        var me = this,
            items = [],
            project = this.task;
        // create ProjectForm instance
        me.projectForm = Ext.create(me.projectFormClass, Ext.apply({
            task: project,
            border: false,
            taskStore: me.taskStore
        }, me.projectFormConfig));
        items.push(me.projectForm);
        // create description panel
        if (me.showDescription) {
            // create notes HtmlEditor instance
            me.descriptionEditor = Ext.create(Ext.apply({
                xclass: 'Ext.form.field.HtmlEditor',
                listeners: {
                    // we need this to draw content of HtmlEditor properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: function(el) {
                        me.descriptionEditor.setValue(me.task.get(me.task.descriptionField));
                    }
                },
                readOnly: project && !project.isEditable(project.descriptionField),
                isDataChanged: function() {
                    return this.isDirty();
                }
            }, me.descriptionConfig));
            // we have to wrap it in a panel since it'll be a tab in TabPanel
            // (to avoid some render bugs)
            me.descriptionPanel = Ext.create('Ext.panel.Panel', {
                border: false,
                layout: 'fit',
                items: me.descriptionEditor
            });
            items.push(me.descriptionPanel);
        }
        // make sure that each panel has its title
        if (!me.projectForm.title)  {
            me.projectForm.title = me.L('generalText');
        }
        
        if (me.descriptionPanel && !me.descriptionPanel.title)  {
            me.descriptionPanel.title = this.L('descriptionText');
        }
        
        return items;
    },
    /**
     * Loads project data into the project editor.
     * **Note**, it's an alias for the {@link #loadTask} method.
     * @param {Gnt.model.Project} project Project to load to the editor.
     */
    loadProject: function(project) {
        this.loadTask.apply(this, arguments);
    },
    loadTask: function(project) {
        if (!project)  {
            return;
        }
        
        this.task = project;
        var projectForm = this.projectForm;
        // on task loading step let's suppress task updating
        projectForm.setSuppressTaskUpdate(true);
        projectForm.getForm().reset();
        this.callParent(arguments);
        projectForm.loadRecord(project, this.taskBuffer);
        if (this.descriptionEditor) {
            this.descriptionEditor.setValue(project.getDescription());
        }
        this.setReadOnly(project.isReadOnly());
        // enable 'projectupdated' event processing back
        projectForm.setSuppressTaskUpdate(false);
        this.fireEvent('loadproject', this, project);
    },
    setReadOnly: function(readOnly) {
        var me = this,
            project = me.task;
        this.callParent(arguments);
        if (project) {
            if (me.descriptionEditor) {
                me.descriptionEditor.setReadOnly(readOnly || !project.isEditable(project.descriptionField));
            }
        }
    },
    onTaskUpdated: function(record) {
        this.setReadOnly(record.isReadOnly());
    },
    /**
     * Persists editor data into the project instance.
     * **Note**, this is an alias for the {@link #updateTask} method.
     * @param {Gnt.model.Project} project Project to load to the editor.
     */
    updateProject: function() {
        this.updateTask();
    },
    // Since we do not need dependencies/assignments and resources copies
    // we override following methods to not fullfil corresponding store clones w/ data
    loadClonedDependencyStore: Ext.emptyFn,
    loadClonedResourceStore: Ext.emptyFn,
    loadClonedAssignmentStore: Ext.emptyFn,
    doValidate: function(invalidComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.projectForm && !this.projectForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.projectForm));
        }
        return result;
    },
    doUpdateTask: function() {
        var me = this,
            project = me.task;
        project.beginEdit();
        project.set(me.getTaskUpdateData(project, me.taskBuffer));
        me.descriptionEditor && project.set(project.descriptionField, me.descriptionEditor.getValue());
        project.maybeMarkChildrenForRescheduling();
        project.endEdit();
    },
    isDataChanged: function(changedComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.projectForm && this.projectForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.projectForm));
        }
        if (this.descriptionEditor && this.descriptionEditor.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.descriptionEditor));
        }
        return result;
    },
    updateReadOnly: function() {
        var me = this,
            widgetReadOnly = me.getReadOnly();
        me.projectForm && me.projectForm.setReadOnly(widgetReadOnly);
    },
    propagateTaskUpdate: function(callback, scope) {
        var me = this,
            project = me.task;
        me.initRoboManager();
        project.propagateChanges(Ext.bind(me.propagateTaskUpdateChanger, me), function onPropagationComplete(cancelChanges, affectedTasks) {
            me.onTaskUpdatePropagationComplete(cancelChanges, affectedTasks);
            callback && callback.call(scope || me, cancelChanges, affectedTasks);
        }, undefined, true, // async
        me.isTasksReschedulingNeeded() || undefined);
    },
    isTasksReschedulingNeeded: function() {
        var me = this,
            project = me.task,
            data = me.getTaskUpdateData(project, me.taskBuffer);
        return (project.getScheduleBackwards() ? data[project.endDateField] : data[project.startDateField]) || data.hasOwnProperty(project.scheduleBackwardsField);
    }
});

/**

@class Gnt.plugin.taskeditor.ProjectEditor
@extends Gnt.plugin.taskeditor.BaseEditor

A plugin (ptype = 'gantt_projecteditor') which shows a {@link Gnt.widget.taskeditor.ProjectEditor} in a window when a user double-clicks
{@link Gnt.model.Project a task of project type} bar in the gantt chart.

You can enable this plugin in your Gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        ...
        plugins : ['gantt_projecteditor']
        ...
    });

*/
Ext.define('Gnt.plugin.taskeditor.ProjectEditor', {
    extend: 'Gnt.plugin.taskeditor.BaseEditor',
    alternateClassName: [
        'Gnt.plugin.ProjectEditor'
    ],
    requires: [
        'Gnt.widget.taskeditor.ProjectEditor'
    ],
    alias: 'plugin.gantt_projecteditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_projecteditor',
    height: 390,
    width: 600,
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.ProjectEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.ProjectEditor',
    /**
     * @cfg {Gnt.model.Task} task The task to show in the task editor.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Project Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
            - generalText         : 'General'
     */
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore,projectFormClass,showDescription,projectFormConfig,descriptionConfig',
    /**
     * @event loadproject
     * Fires after project loading complete.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance used for editing.
     * @param {Gnt.model.Project} project The loaded project.
     */
    /**
     * @event validate
     * Fires when project validation occurs. Take a look at example of using this event {@link Gnt.widget.taskeditor.TaskEditor#event-validate here}.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance.
     */
    /**
     * @event beforeupdateproject
     * @preventable
     * Fires before project updating occurs. Return false to prevent the update.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance used for editing.
     * @param {Function} proceedCallback The function which can be called manually to continue project updating. Example:
     */
    /**
     * @event afterupdateproject
     * Fires after project updating is finished.
     * @param {Gnt.widget.taskeditor.ProjectEditor} projectEditor Project editor widget instance.
     *
     */
    constructor: function(config) {
        this.callParent(arguments);
        this.addCls('gnt-projecteditor-window');
        // filter out all except project records
        this.addFilter(function(task) {
            return task && task.isProject;
        });
    },
    init: function(cmp) {
        this.callParent(arguments);
        // decorate the component with a reference to the plugin
        cmp.projectEditor = this;
    }
});

/**
@class Gnt.widget.taskeditor.TaskForm
@extends Gnt.widget.taskeditor.BaseForm

{@img gantt/images/taskeditor-form.png}

This form is used to edit the task properties.
By default it supports editing of the following fields:

 - the name of the task (task title)
 - the start date of the task
 - the end date of the task
 - the task duration
 - the task effort
 - the current status of a task, expressed as the percentage completed
 - the baseline start date of the task (editing of this field is optional)
 - the baseline end date of the task (editing of this field is optional)
 - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)
 - the calendar assigned to task
 - the scheduling mode for the task

* **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

## Extending the default field set

The default field set can be overwritten using the {@link #items} config.
In case you want to keep the default fields and add some new custom fields, you can use the code below:

    // Extend the standard TaskForm class
    Ext.define('MyTaskForm', {
        extend : 'Gnt.widget.taskeditor.TaskForm',

        constructor : function(config) {
            this.callParent(arguments);

            // add some custom field
            this.add({
                fieldLabel  : 'Foo',
                name        : 'Name',
                width       : 200
            });
        }
    });

    // create customized form
    var form = new MyTaskForm({...});

*/
Ext.define('Gnt.widget.taskeditor.TaskForm', {
    // This form by default contains various "standard" fields of the task
    // and it "knows" about their "applyChanges" methods (for our fields),
    // and about renamed field names
    // This form can be also used with any other set of fields, provided
    // as the "items" config
    extend: 'Gnt.widget.taskeditor.BaseForm',
    alias: 'widget.taskform',
    requires: [
        'Gnt.model.Task',
        'Ext.Date',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Ext.form.field.Date',
        'Ext.form.field.Checkbox',
        'Gnt.field.Percent',
        'Gnt.field.StartDate',
        'Gnt.field.EndDate',
        'Gnt.field.Duration',
        'Gnt.field.Effort',
        'Gnt.field.BaselineStartDate',
        'Gnt.field.BaselineEndDate',
        'Gnt.field.BaselineEffort'
    ],
    alternateClassName: [
        'Gnt.widget.TaskForm'
    ],
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be added to this container.
     *
     * For example:
     *
        var myForm  = new Gnt.widget.taskeditor.TaskForm({
            items       : [
                {
                    xtype       : 'calendarfield',
                    fieldLabel  : 'Calendar',
                    name        : 'CalendarId'
                },
                {
                    xtype       : 'displayfield',
                    fieldLabel  : "WBS",
                    name        : 'wbsCode'
                }
            ],
            task        : myTask,
            taskStore   : myTaskStore
        });


     *
     * **Note:** By default this form provide pre-configured set of fields. Using this option will overwrite that field set.
     */
    /**
     * @cfg {Boolean} [showGeneral=true] `true` to display general fields.
     */
    showGeneral: true,
    /**
     * @cfg {Boolean} [showBaseline=true] `true` to display baseline fields.
     */
    showBaseline: true,
    /**
     * @cfg {Boolean} [editBaseline=false] `true` to allow editing of baseline fields.
     */
    editBaseline: false,
    /**
     * @cfg {Object} l10n
     *    A object, purposed for the class localization. Contains the following keys/values:
     *
     * @cfg {String} l10n.taskNameText            'Name'
     * @cfg {String} l10n.durationText            'Duration'
     * @cfg {String} l10n.datesText               'Dates'
     * @cfg {String} l10n.baselineText            'Baseline'
     * @cfg {String} l10n.startText               'Start'
     * @cfg {String} l10n.finishText              'Finish'
     * @cfg {String} l10n.percentDoneText         'Percent Complete'
     * @cfg {String} l10n.baselineStartText       'Start'
     * @cfg {String} l10n.baselineFinishText      'Finish'
     * @cfg {String} l10n.baselinePercentDoneText 'Percent Complete'
     * @cfg {String} l10n.baselineEffortText      'Effort'
     * @cfg {String} l10n.effortText              'Effort'
     * @cfg {String} l10n.invalidEffortText       'Invalid effort value'
     */
    /**
     * @cfg {Object} nameConfig A config object to be applied to the `Name` field.
     */
    nameConfig: null,
    /**
     * @cfg {Object} durationConfig A config object to be applied to the `Duration` field.
     */
    durationConfig: null,
    /**
     * @cfg {Object} startConfig A config object to be applied to the `Start` field.
     */
    startConfig: null,
    /**
     * @cfg {Object} finishConfig A config object to be applied to the `Finish` field.
     */
    finishConfig: null,
    /**
     * @cfg {Object} percentDoneConfig A config object to be applied to the `Percent Complete` field.
     */
    percentDoneConfig: null,
    /**
     * @cfg {Object} baselineStartConfig A config object to be applied to the `Start` field of the `Baseline` fields container.
     */
    baselineStartConfig: null,
    /**
     * @cfg {Object} baselineFinishConfig A config object to be applied to the `Finish` field of the `Baseline` fields container.
     */
    baselineFinishConfig: null,
    /**
     * @cfg {Object} baselinePercentDoneConfig A config object to be applied to the `Percent Complete` field of the `Baseline` fields container.
     */
    baselinePercentDoneConfig: null,
    /**
     * @cfg {Object} baselineEffortConfig A config object to be applied to the `Effort` field of the `Baseline` fields container.
     */
    baselineEffortConfig: null,
    /**
     * @cfg {Object} effortConfig A config object to be applied to the `Effort` field.
     */
    effortConfig: null,
    constructor: function(config) {
        config = config || {};
        // setup mixin that tracks "*Field" model properties and is responsible for fields renaming
        this.setupCustomizableRecordForm(this, Gnt.model.Task);
        this.showBaseline = config.showBaseline;
        this.editBaseline = config.editBaseline;
        this.callParent(arguments);
        this.addBodyCls('gnt-taskeditor-taskform');
    },
    // Build the default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.customizableFieldNames;
        me.items = me.items || [];
        if (me.showGeneral) {
            me.items.push(me.initFieldDefinition({
                xtype: 'textfield',
                fieldLabel: me.L('taskNameText'),
                name: f.nameField,
                labelWidth: this.labelWidth,
                allowBlank: false,
                width: '100%',
                value: me.getTaskFieldValue(f.nameField)
            }, me.nameConfig), {
                xtype: 'fieldcontainer',
                layout: 'hbox',
                defaults: {
                    labelWidth: this.labelWidth,
                    allowBlank: false
                },
                items: [
                    me.initFieldDefinition({
                        xtype: 'percentfield',
                        fieldLabel: me.L('percentDoneText'),
                        name: f.percentDoneField,
                        margin: '0 8 0 0',
                        flex: 1,
                        value: me.getTaskFieldValue(f.percentDoneField)
                    }, me.percentDoneConfig),
                    me.initFieldDefinition({
                        xtype: 'durationfield',
                        fieldLabel: me.L('durationText'),
                        name: f.durationField,
                        allowBlank: true,
                        flex: 1,
                        value: me.getTaskFieldValue(f.durationField)
                    }, me.durationConfig)
                ]
            }, {
                xtype: 'fieldset',
                title: me.L('datesText'),
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        layout: 'anchor',
                        flex: 1,
                        margin: '0 8 0 0',
                        defaults: {
                            labelWidth: this.labelWidth
                        },
                        items: [
                            me.initFieldDefinition({
                                xtype: 'startdatefield',
                                fieldLabel: me.L('startText'),
                                width: '100%',
                                allowBlank: true,
                                format: Ext.Date.defaultFormat,
                                name: f.startDateField,
                                value: me.getTaskFieldValue(f.startDateField)
                            }, me.startConfig),
                            me.initFieldDefinition({
                                xtype: 'effortfield',
                                cls: 'gnt-field-with-null-value',
                                fieldLabel: me.L('effortText'),
                                name: f.effortField,
                                invalidText: me.L('invalidEffortText'),
                                width: '100%',
                                allowBlank: true,
                                value: me.getTaskFieldValue(f.effortField)
                            }, me.effortConfig)
                        ]
                    },
                    me.initFieldDefinition({
                        xtype: 'enddatefield',
                        fieldLabel: me.L('finishText'),
                        flex: 1,
                        format: Ext.Date.defaultFormat,
                        labelWidth: this.labelWidth,
                        allowBlank: true,
                        name: f.endDateField,
                        value: me.getTaskFieldValue(f.endDateField)
                    }, me.finishConfig)
                ]
            });
        }
        if (me.showBaseline) {
            me.items.push({
                xtype: 'fieldset',
                title: me.L('baselineText'),
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        layout: 'anchor',
                        flex: 1,
                        margin: '0 8 0 0',
                        defaults: {
                            labelWidth: this.labelWidth,
                            cls: 'gnt-baselinefield'
                        },
                        items: [
                            me.initFieldDefinition({
                                xtype: 'baselinestartdatefield',
                                fieldLabel: me.L('baselineStartText'),
                                name: f.baselineStartDateField,
                                value: me.getTaskFieldValue(f.baselineStartDateField),
                                width: '100%',
                                readOnly: !me.editBaseline,
                                // Setting forceReadOnly to true disables TaskField and BaseForm logic that switches the field readOnly state
                                // depending on the task being edited isEditable() result or the form readOnly state
                                forceReadOnly: !me.editBaseline
                            }, me.baselineStartConfig),
                            me.initFieldDefinition({
                                xtype: 'percentfield',
                                fieldLabel: me.L('baselinePercentDoneText'),
                                width: '100%',
                                name: f.baselinePercentDoneField,
                                value: me.getTaskFieldValue(f.baselinePercentDoneField),
                                readOnly: !me.editBaseline,
                                forceReadOnly: !me.editBaseline
                            }, me.baselinePercentDoneConfig)
                        ]
                    },
                    {
                        xtype: 'container',
                        layout: 'anchor',
                        flex: 1,
                        margin: '0 8 0 0',
                        defaults: {
                            labelWidth: this.labelWidth,
                            cls: 'gnt-baselinefield'
                        },
                        items: [
                            me.initFieldDefinition({
                                xtype: 'baselineenddatefield',
                                fieldLabel: me.L('baselineFinishText'),
                                name: f.baselineEndDateField,
                                cls: 'gnt-baselinefield',
                                flex: 1,
                                labelWidth: this.labelWidth,
                                value: me.getTaskFieldValue(f.baselineEndDateField),
                                readOnly: !me.editBaseline,
                                forceReadOnly: !me.editBaseline
                            }, me.baselineFinishConfig),
                            me.initFieldDefinition({
                                xtype: 'baselineeffortfield',
                                fieldLabel: me.L('baselineEffortText'),
                                name: f.baselineEffortField,
                                cls: 'gnt-baselinefield',
                                flex: 1,
                                labelWidth: this.labelWidth,
                                value: me.getTaskFieldValue(f.baselineEffortField),
                                readOnly: !me.editBaseline,
                                forceReadOnly: !me.editBaseline
                            }, me.baselineEffortConfig)
                        ]
                    }
                ]
            });
        }
    },
    updateRecordFn: function(task) {
        var me = this,
            fieldNames = me.customizableFieldNames,
            form = me.getForm(),
            constraintTypeField = form.findField(fieldNames.constraintTypeField),
            constraintDateField = form.findField(fieldNames.constraintDateField);
        task.beginEdit();
        this.callParent(arguments);
        // apply constraints if corresponding fields were shown
        // and task has constraint mixin mixed
        if (constraintTypeField && constraintDateField && task.setConstraint) {
            task.setConstraintWithoutPropagation(constraintTypeField.getValue(), constraintDateField.getValue());
        }
        task.endEdit();
    },
    buildTaskBuffer: function(task) {
        this.callParent(arguments);
        // "isEditable" result depends on the task parent nodes readonly state
        // so if some of the task parents is readonly
        // we simply return true
        if (!task.getReadOnly() && task.isReadOnly()) {
            this.taskBuffer.isReadOnly = function() {
                return true;
            };
        }
    }
});

/**
 @class Gnt.widget.taskeditor.AdvancedForm
 @extends Gnt.widget.taskeditor.TaskForm

 This form represents the `Advanced` tab of {@link Gnt.widget.taskeditor.TaskEditor the task editor widget}.
 By default it supports editing of the following fields:

 - calendar assigned to the task
 - scheduling mode for the task
 - manually scheduled flag
 - WBS code
 - rollup flag
 - constraint type
 - constraint date
 - read only flag

 * **Note:** However this standard set of fields can be easily overwritten (for more details check {@link #items}).

 ## Extending the default field set

 The default field set can be overwritten using the {@link #items} config.
 In case you want to keep the default fields and add some new custom fields, you can use the code below:

 // Extend the standard AdvancedForm class
 Ext.define('MyAdvancedForm', {
        extend : 'Gnt.widget.taskeditor.AdvancedForm',

        constructor : function(config) {
            this.callParent(arguments);

            // add some custom field
            this.add({
                fieldLabel  : 'Foo',
                name        : 'Name',
                width       : 200
            });
        }
    });

 // create customized form
 var form = new MyAdvancedForm({...});

 */
Ext.define('Gnt.widget.taskeditor.AdvancedForm', {
    extend: 'Gnt.widget.taskeditor.TaskForm',
    alias: 'widget.advanced_taskform',
    requires: [
        'Gnt.model.Task',
        'Ext.form.FieldSet',
        'Ext.form.FieldContainer',
        'Ext.form.field.Text',
        'Ext.form.field.Date',
        'Gnt.field.SchedulingMode',
        'Gnt.field.ManuallyScheduled',
        'Gnt.field.Calendar',
        'Gnt.field.ConstraintType',
        'Gnt.field.ConstraintDate',
        'Gnt.field.ReadOnly'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alternateClassName: [
        'Gnt.widget.AdvancedForm'
    ],
    border: false,
    margin: 0,
    layout: {
        type: 'table',
        columns: 2
    },
    defaults: {
        width: '97%'
    },
    /**
     * @hide
     * @cfg showGeneral
     */
    showGeneral: false,
    /**
     * @hide
     * @cfg showBaseline
     */
    showBaseline: false,
    /**
     * @hide
     * @cfg editBaseline
     */
    editBaseline: false,
    /**
     * @cfg {Boolean} showCalendar `true` to show `Calendar` field.
     */
    showCalendar: true,
    /**
     * @cfg {Boolean} showManuallyScheduled `true` to show `ManuallyScheduled` field.
     */
    showManuallyScheduled: true,
    /**
     * @cfg {Boolean} showSchedulingMode `true` to show `Scheduling Mode` field.
     */
    showSchedulingMode: true,
    /**
     * @cfg {Boolean} showWbsCode `true` to show `WBS code` field.
     */
    showWbsCode: true,
    /**
     * @cfg {Boolean} showRollup `true` to show `Rollup` field.
     */
    showRollup: false,
    /**
     * @cfg {Boolean} showConstraint `true` to show `Constraint Type`, `Constraint Date` fields.
     */
    showConstraint: true,
    /**
     * @cfg {Boolean} showReadOnly `true` to show `ReadOnly field`.
     */
    showReadOnly: false,
    /**
     * @cfg {Object} l10n
     *    A object, purposed for the class localization. Contains the following keys/values:
     *
     * @cfg {String} l10n.calendarText            'Calendar'
     * @cfg {String} l10n.manuallyScheduled       'Manually Scheduled'
     * @cfg {String} l10n.schedulingModeText      'Scheduling Mode'
     * @cfg {String} l10n.wbsCodeText             'WBS code'
     * @cfg {String} l10n."Constraint Type"       'Constraint Type'
     * @cfg {String} l10n."Constraint Date"       'Constraint Date'
     * @cfg {String} l10n.readOnlyText            'ReadOnly'
     */
    /**
     * @cfg {Object} calendarConfig A config object to be applied to the `Calendar` field.
     */
    calendarConfig: null,
    /**
     * @cfg {Object} manuallyScheduledConfig A config object to be applied to the `Manually Scheduled` field.
     */
    manuallyScheduledConfig: null,
    /**
     * @cfg {Object} schedulingModeConfig A config object to be applied to the `Scheduling Mode` field.
     */
    schedulingModeConfig: null,
    /**
     * @cfg {Object} wbsCodeConfig A config object to be applied to the `WBS code` field.
     */
    wbsCodeConfig: null,
    /**
     * @cfg {Object} rollupConfig A config object to be applied to the `Rollup` field.
     */
    rollupConfig: null,
    /**
     * @cfg {Object} constraintTypeConfig A config object to be applied to the `Constraint Type` field.
     */
    constraintTypeConfig: null,
    /**
     * @cfg {Object} constraintDateConfig A config object to be appied to the `Constraint Date` field.
     */
    constraintDateConfig: null,
    /*
     * @cfg {Object} readOnlyConfig A config object to be applied to the `ReadOnly` field.
     */
    readOnlyConfig: null,
    constructor: function(config) {
        this.callParent(arguments);
        this.addBodyCls('gnt-taskeditor-advancedtaskform');
    },
    // Builds default set of form fields.
    buildFields: function() {
        var me = this,
            f = me.customizableFieldNames;
        me.items = me.items || [];
        if (me.showCalendar) {
            me.items.push(me.initFieldDefinition({
                xtype: 'calendarfield',
                fieldLabel: this.L('calendarText'),
                name: f.calendarIdField,
                value: me.getTaskFieldValue(f.calendarIdField)
            }, me.calendarConfig));
        }
        if (me.showManuallyScheduled) {
            me.items.push(me.initFieldDefinition({
                xtype: 'manuallyscheduledfield',
                fieldLabel: me.L('manuallyScheduledText'),
                name: f.manuallyScheduledField,
                value: me.getTaskFieldValue(f.manuallyScheduledField)
            }, me.manuallyScheduledConfig));
        }
        if (me.showSchedulingMode) {
            me.items.push(me.initFieldDefinition({
                xtype: 'schedulingmodefield',
                fieldLabel: me.L('schedulingModeText'),
                name: f.schedulingModeField,
                value: me.getTaskFieldValue(f.schedulingModeField),
                allowBlank: false
            }, me.schedulingModeConfig));
        }
        if (me.showWbsCode) {
            me.wbsField = Ext.create(me.initFieldDefinition({
                xtype: 'textfield',
                fieldLabel: me.L('wbsCodeText'),
                name: 'wbsCode',
                forceReadOnly: true,
                readOnly: true,
                value: me.task && me.task.getWBSCode()
            }, me.wbsCodeConfig));
            me.items.push(me.wbsField);
        }
        if (me.showRollup) {
            this.items.push(me.initFieldDefinition({
                xtype: 'checkboxfield',
                fieldLabel: this.L('rollupText'),
                name: f.rollupField,
                // TO fix Ext JS 6.0.2 bug
                // https://www.sencha.com/forum/showthread.php?310395
                uncheckedValue: false,
                value: me.getTaskFieldValue(f.rollupField)
            }, me.rollupConfig));
        }
        if (me.showReadOnly) {
            this.items.push(me.initFieldDefinition({
                xtype: 'readonlyfield',
                fieldLabel: me.L('readOnlyText'),
                name: f.readOnlyField,
                value: me.getTaskFieldValue(f.readOnlyField)
            }, me.readOnlyConfig));
        }
        if (me.showConstraint) {
            me.items.push(me.initFieldDefinition({
                xtype: 'constrainttypefield',
                fieldLabel: me.L("Constraint Type"),
                name: f.constraintTypeField,
                value: me.getTaskFieldValue(f.constraintTypeField)
            }, me.constraintTypeConfig), me.initFieldDefinition({
                xtype: 'constraintdatefield',
                fieldLabel: me.L("Constraint Date"),
                name: f.constraintDateField,
                value: me.getTaskFieldValue(f.constraintDateField)
            }, me.constraintDateConfig));
        }
    },
    loadRecord: function(task) {
        var result = this.callParent(arguments);
        if (this.wbsField) {
            this.wbsField.setValue(task.getWBSCode());
        }
        return result;
    }
});

/**
@class Gnt.widget.AssignmentEditGrid
@extends Ext.grid.Panel

A widget used to display and edit the task assignments.
You can find this widget at the `Resources` tab of {@link Gnt.widget.taskeditor.TaskEditor}.
There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#assignmentGridConfig assignmentGridConfig} object
available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} (if you use TaskEditor by plugin).

{@img gantt/images/assignment-edit-grid2.png}

{@img gantt/images/assignment-edit-grid1.png}

You can also use this grid in your components, standalone:

    // the task store of the project
    var taskStore           = myGanttPanel.taskStore

    var assignmentGrid      = new Gnt.widget.AssignmentEditGrid({
        assignmentStore         : taskStore.assignmentStore,
        resourceStore           : taskStore.resourceStore,

        // identifier of task which assignments have to be displayed
        taskId                  : 100,
        // turn off in-place resource adding
        addResources            : false,

        renderTo                : Ext.getBody(),

        width                   : 800,
        height                  : 600
    })

*/
Ext.define('Gnt.widget.AssignmentEditGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.assignmenteditgrid',
    requires: [
        'Ext.util.Filter',
        'Ext.data.JsonStore',
        'Ext.window.MessageBox',
        'Ext.form.field.ComboBox',
        'Ext.grid.plugin.CellEditing',
        'Sch.patches.BoundList',
        'Gnt.util.Data',
        'Gnt.data.AssignmentStore',
        'Gnt.data.ResourceStore',
        'Gnt.column.ResourceName',
        'Gnt.column.AssignmentUnits'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Gnt.data.AssignmentStore} assignmentStore A store with assignments.
     */
    assignmentStore: null,
    /**
     * @cfg {Gnt.data.ResourceStore} resourceStore A store with resources.
     */
    resourceStore: null,
    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly: false,
    cls: 'gnt-assignmentgrid',
    /**
     * @cfg {Number} defaultAssignedUnits Default amount of units. This value applies for new assignments.
     */
    defaultAssignedUnits: 100,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - confirmAddResourceTitle : 'Confirm',
            - confirmAddResourceText  : 'No resource &quot;{0}&quot; in storage yet. Would you like to add it?',
            - noValueText             : 'Please select resource to assign',
            - noResourceText          : 'No resource &quot;{0}&quot; in storage'
     */
    /**
     * @cfg {Mixed} confirmAddResourceText A title for the confirmation window when a new resource is about to be added.
     * If you set this to `false`, no confirmation window will be displayed.
     * In this mode, for every "unknown" resource name entered into the combobox field, a new resource will be created.
     * @removed 2.5 Please use {@link #confirmAddResource} and {@link #l10n} instead.
     */
    /**
     * @cfg {Boolean} confirmAddResource False to not display a confirmation window before adding a new resource.
     */
    confirmAddResource: true,
    /**
     * @cfg {Boolean} addResources `true` to enable in-place resource adding.
     */
    addResources: true,
    /**
     * @property {String/Number} taskId Identifier of the task to which the assignments belong.
     */
    /**
     * @cfg {String/Number} taskId The task id indicating which assignments to load.
     * **Note**, that if the task doesn't have an identifier yet (a 'phantom' record), you can use its phantomId instead.
     */
    taskId: null,
    refreshTimeout: 100,
    // copy of resource store
    resourceDupStore: null,
    // copy of resource store used for resources combobox
    // (this store is affected by filters so we don't use `resourceDupStore` to always have "clean" copy there)
    resourceComboStore: null,
    assignmentUnitsEditor: null,
    refreshDataSuspended: 0,
    initComponent: function() {
        var me = this,
            assignmentStore = me.assignmentStore,
            taskStore = me.taskStore || assignmentStore.getTaskStore();
        // Use an Gnt.data.AssignmentStore instance since
        // we need it to play this role in case we link grid with TaskForm.taskBuffer
        if (!me.store) {
            me.store = new assignmentStore.self({
                model: assignmentStore.model,
                taskStore: taskStore
            });
        }
        var resourceStore = taskStore.getResourceStore();
        if (!me.resourceDupStore) {
            me.resourceDupStore = new resourceStore.self({
                sorters: resourceStore.model.prototype.nameField,
                model: resourceStore.model,
                taskStore: taskStore
            });
        }
        // resource combo store
        me.resourceComboStore = new resourceStore.self({
            model: resourceStore.model,
            autoLoad: false,
            autoDestroy: true
        });
        if (me.addResources !== undefined) {
            me.addResources = me.addResources;
        }
        me.columns = me.buildColumns();
        if (!me.readOnly) {
            me.plugins = me.buildPlugins();
        }
        me.loadResources();
        me.loadTaskAssignments();
        if (!me.tbar)  {
            me.tbar = me.buildToolbarItems();
        }
        
        me.callParent(arguments);
        me.setupListeners();
    },
    setAssignmentStore: function(store) {
        var me = this;
        if (store !== me.assignmentStore) {
            me.bindAssignmentStore(store);
            me.assignmentStore = store;
        }
    },
    setResourceStore: function(store) {
        var me = this;
        if (store !== me.resourceStore) {
            me.bindResourceStore(store);
            me.resourceStore = store;
        }
    },
    bindResourceStore: function(store) {
        var me = this;
        if (me.resourceStoreDetacher)  {
            me.resourceStoreDetacher.destroy();
        }
        
        if (store) {
            me.resourceStoreDetacher = me.mon(store, {
                'add': me.refreshResources,
                'remove': me.refreshResources,
                'load': me.refreshResources,
                'clear': me.refreshResources,
                scope: me,
                destroyable: true
            });
        }
    },
    bindAssignmentStore: function(store) {
        var me = this;
        if (me.assignmentStoreDetacher)  {
            me.assignmentStoreDetacher.destroy();
        }
        
        if (store) {
            me.assignmentStoreDetacher = me.mon(store, {
                'add': me.refreshAssignments,
                'remove': me.refreshAssignments,
                'load': me.refreshAssignments,
                'clear': me.refreshAssignments,
                scope: me,
                destroyable: true
            });
        }
    },
    setupListeners: function() {
        var me = this;
        me.bindResourceStore(me.resourceStore);
        me.bindAssignmentStore(me.assignmentStore);
        me.on({
            selectionchange: function(sm, sel) {
                if (!me.dropBtn) {
                    me.dropBtn = me.down('#drop-assignment-btn');
                }
                me.dropBtn && me.dropBtn.setDisabled(!sel.length);
            }
        });
    },
    buildToolbarItems: function() {
        var me = this;
        return [
            {
                xtype: 'button',
                iconCls: 'x-fa fa-plus',
                text: me.L('addAssignmentText'),
                itemId: 'add-assignment-btn',
                handler: function() {
                    me.insertAssignment();
                }
            },
            {
                xtype: 'button',
                iconCls: 'x-fa fa-trash',
                text: me.L('dropAssignmentText'),
                itemId: 'drop-assignment-btn',
                disabled: true,
                handler: function() {
                    // close all the opened editors
                    me.setActionableMode(false);
                    var recs = me.getSelectionModel().getSelection();
                    if (recs && recs.length) {
                        var index = me.store.indexOf(recs[0]);
                        me.store.remove(recs);
                        if (me.store.getCount() > 0) {
                            me.getSelectionModel().select((index === me.store.getCount()) ? index - 1 : index);
                        }
                    }
                }
            }
        ];
    },
    suspendDataRefresh: function() {
        this.refreshDataSuspended++;
    },
    resumeDataRefresh: function() {
        this.refreshDataSuspended--;
    },
    refreshResources: function() {
        if (!this.refreshDataSuspended && !this.isDestroyed) {
            this.loadResources();
        }
    },
    refreshAssignments: function() {
        if (!this.refreshDataSuspended && !this.isDestroyed) {
            this.loadTaskAssignments();
        }
    },
    loadResources: function(justResources) {
        if (!this.resourceStore)  {
            return false;
        }
        
        // make a copy of resourceStore
        var data = Gnt.util.Data.cloneModelSet(this.resourceStore);
        // clone data to not affect real store
        this.resourceDupStore.loadData(data);
        this.resourceComboStore.loadData(data);
        // we reload assignments as well since they depend on resources list
        if (!justResources) {
            this.loadTaskAssignments();
        }
        return true;
    },
    afterRender: function() {
        var task;
        this.callParent(arguments);
        // if taskId was provided at construction
        if (this.taskId) {
            var taskStore = this.taskStore || this.assignmentStore.getTaskStore();
            // trying to get task
            task = taskStore && taskStore.getModelById(this.taskId);
        }
        if (task) {
            this.setEditableFields(task);
        }
    },
    getUnitsEditor: function() {
        if (!this.readOnly) {
            // in readOnly mode we dont have cellEditing plugin instance and thus we don't have getEditor method at all
            if (!this.assignmentUnitsEditor)  {
                this.assignmentUnitsEditor = this.down('assignmentunitscolumn').getEditor();
            }
            
        }
        return this.assignmentUnitsEditor;
    },
    setEditableFields: function(task) {
        var unitsEditor = this.getUnitsEditor();
        if (unitsEditor) {
            switch (task.getSchedulingMode()) {
                case 'DynamicAssignment':
                    unitsEditor.setReadOnly(true);
                    break;
                default:
                    unitsEditor.setReadOnly(false);
            }
        }
    },
    /**
     * Pass 'true' to disable the cell editing
     * @param readOnly
     */
    setReadOnly: function(readOnly) {
        if (this.cellEditing) {
            if (readOnly) {
                this.cellEditing.disable();
            } else {
                this.cellEditing.enable();
            }
        }
    },
    /**
     * Loads task assignments from {@link #assignmentStore}.
     *
     * @param {Mixed} [taskId] The task id indicating which assignments to load.
     * If this parameter is not specified then it will use current {@link #property-taskId} value (identifier provided to this function before (if any)
     * or initially specified by {@link #cfg-taskId} config).
     * **Note**, that if the task doesn't have an identifier yet (a 'phantom' record), you can use the task phantomId instead.
     *
     * @return {Boolean} False if {@link #assignmentStore} doesn't yet exist or if no task identifier has been provided.
     * Otherwise returns `true`.
     */
    loadTaskAssignments: function(taskId) {
        taskId = taskId || this.taskId;
        if (!taskId)  {
            return false;
        }
        
        var taskStore = this.taskStore || this.assignmentStore.getTaskStore(),
            task = taskStore && taskStore.getModelById(taskId),
            taskAssignments;
        if (task) {
            taskAssignments = task.getAssignments();
        } else {
            if (!this.assignmentStore)  {
                return false;
            }
            
            // grab assignments for this task only
            taskAssignments = this.assignmentStore.queryBy(function(a) {
                return a.getTaskId() == taskId;
            });
        }
        this.taskId = taskId;
        var store = this.store,
            resStore = this.resourceDupStore,
            // clone assignments to not affect real records
            data = Gnt.util.Data.cloneModelSet(taskAssignments, function(copiedAssignment, srcAssignment) {
                // get original resource Id
                var resId = srcAssignment.getResourceId();
                // get cloned version of that resource
                var clonedRes = resStore.queryBy(function(resource) {
                        var r = resource.originalRecord;
                        return (r.getId() || r.internalId) == resId;
                    });
                if (clonedRes.getCount()) {
                    clonedRes = clonedRes.first();
                    // and bind cloned resource to copy of assignment instead of real resource
                    copiedAssignment.setResourceId(clonedRes.getId() || clonedRes.internalId);
                }
            });
        // load data to the store
        store.loadData(data);
        if (task && this.rendered) {
            this.setEditableFields(task);
        }
        return true;
    },
    /**
     * Adds a new assignment record and starts the editor.
     *
     * @param {Gnt.model.Assignment/Object} [assignment] The new assignment to be added.
     * If this parameter is not provided, a new record will be created using the TaskId of the current task,
     * empty ResourceId field and Units field set to {@link #defaultAssignedUnits} amount.
     * @param {Boolean} [doNotActivateEditor=False] `true` to just insert record without activating editor after.
     *
     * @return {Gnt.model.Assignment} The record that was added.
     */
    insertAssignment: function(assignment, doNotActivateEditor) {
        var newAssignment;
        if (!assignment || !assignment.isModel) {
            newAssignment = new this.store.model(assignment);
            if (!assignment) {
                newAssignment.setUnits(this.defaultAssignedUnits);
            }
        }
        // Fix for Ext.Editor bug when it tries to retrieve a value from the cell
        // when the corresponding field initial value is 'undefined'
        // ..problem is the cell might also contain invalid text tooltip
        if (newAssignment.getResourceId() === undefined) {
            newAssignment.setResourceId(null);
        }
        newAssignment.setTaskId(this.taskId);
        this.store.insert(0, newAssignment);
        var me = this,
            oldValidator = newAssignment.isValid;
        newAssignment.isValid = function() {
            return oldValidator.apply(this, arguments) && me.isValidAssignment(this);
        };
        // there might be no cellEditing if the grid is in readOnly mode
        if (!doNotActivateEditor && this.cellEditing) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 0
            });
        }
        return newAssignment;
    },
    /**
     * Returns an array of task assignment error messages.
     * @return {String[]} Array of error messages.
     */
    getAssignmentErrors: function(assignment) {
        var me = this,
            errors = [],
            resourceId = assignment.getResourceId();
        if (!resourceId) {
            errors.push(me.L('noValueText'));
        } else if (!me.resourceDupStore.getModelById(resourceId)) {
            errors.push(Ext.String.format(me.L('noResourceText'), resourceId));
        } else {
            me.store.each(function(record) {
                if (record.getResourceId() == resourceId && record !== assignment) {
                    errors.push(me.L('Resource is already assigned'));
                    return false;
                }
            });
        }
        return errors;
    },
    isValidAssignment: function(assignment) {
        return !this.getAssignmentErrors(assignment).length;
    },
    // @private
    buildPlugins: function() {
        var cellEditing = this.cellEditing = new Ext.grid.plugin.CellEditing({
                clicksToEdit: 1
            });
        var oldStartEdit = cellEditing.startEdit;
        cellEditing.startEdit = function() {
            this.completeEdit();
            return oldStartEdit.apply(this, arguments);
        };
        cellEditing.on({
            beforeedit: this.onEditingStart,
            scope: this
        });
        return [
            cellEditing
        ];
    },
    hide: function() {
        this.cancelEdit();
        this.callParent(arguments);
    },
    cancelEdit: function() {
        this.cellEditing.cancelEdit();
    },
    onEditingStart: function(ed, e) {
        var model = this.store.model.prototype;
        if (e.field == model.resourceIdField) {
            this.assignment = e.record;
            // keep resourceId of record being edited
            this.resourceId = e.record.getResourceId();
            this.resourceComboStore.loadData(this.resourceDupStore.getRange());
            // and re-apply filter to refresh dataset
            this.resourceComboStore.filter(this.resourcesFilter);
        }
    },
    resourceRender: function(value, meta, assignment) {
        var errors = this.getAssignmentErrors(assignment);
        var name = assignment.getResourceName(this.resourceDupStore) || value;
        if (errors && errors.length) {
            meta.tdCls = 'gnt-cell-invalid';
            meta.tdAttr = 'data-errorqtip="' + errors.join('<br>') + '"';
        } else {
            meta.tdCls = '';
            meta.tdAttr = 'data-errorqtip=""';
        }
        return Ext.htmlEncode(name);
    },
    // filters resources store to exclude resources that already assigned to the task.
    filterResources: function(resource) {
        var resourceId = resource.getId(),
            resourceField = this.store.model.prototype.resourceIdField,
            show = true;
        // record that is being edited should always be presented in combobox dataset
        if (resourceId !== this.resourceId) {
            // filter out already assigned resources
            this.store.each(function(assignment) {
                if (resourceId == assignment.get(resourceField)) {
                    show = false;
                    return false;
                }
            });
        }
        return show;
    },
    onAddResourceToCombo: function(name, assignment) {
        var me = this,
            model = me.resourceStore.model,
            resource = {},
            result;
        // let`s add a new record with such name
        resource[model.prototype.nameField] = name;
        resource = new model(resource);
        // set resource Id equal to internalId
        // we need filled Id to combobox proper working
        if (!resource.getId())  {
            resource.setId(resource.internalId);
        }
        
        // push to the store
        var added = me.resourceDupStore.add(resource);
        if (added && added.length) {
            assignment && assignment.setResourceId(added[0].getId());
            result = added[0];
        }
        return result;
    },
    onResourceComboAssert: function(combo) {
        var me = this,
            rawValue = combo.getRawValue();
        if (rawValue) {
            var idx = me.resourceDupStore.findExact(combo.displayField, rawValue);
            var record = idx !== -1 ? me.resourceDupStore.getAt(idx) : false;
            // if no matching record in the store
            if (!record) {
                var assignment = me.assignment;
                // if confirmation required
                if (me.confirmAddResource) {
                    if (!me.addResourceMessageBoxIsVisible) {
                        // HACK: extjs triggers assertValue() more than one time so we raise flag to not bother showing the message twice
                        me.addResourceMessageBoxIsVisible = true;
                        var text = Ext.String.format(me.L('confirmAddResourceText'), Ext.htmlEncode(rawValue));
                        var messageBox = Ext.Msg.confirm(me.L('confirmAddResourceTitle'), text, function(buttonId) {
                                if (buttonId === 'yes') {
                                    me.onAddResourceToCombo(rawValue, assignment);
                                }
                                me.addResourceMessageBoxIsVisible = false;
                            });
                        setTimeout(function() {
                            messageBox.toFront();
                        }, 10);
                    }
                } else {
                    var newResource = me.onAddResourceToCombo(rawValue);
                    combo.getStore().add(newResource);
                    // and set combobox value
                    combo.setValue(newResource.getId());
                }
            } else {
                combo.select(record, true);
            }
        }
    },
    buildColumns: function() {
        var me = this;
        // task name column editor
        this.resourceCombo = new Ext.form.field.ComboBox({
            queryMode: 'local',
            store: this.resourceComboStore,
            allowBlank: false,
            editing: this.addResources,
            validateOnChange: false,
            autoSelect: false,
            forceSelection: !this.addResources,
            valueField: this.resourceComboStore.model.prototype.idProperty,
            displayField: this.resourceComboStore.model.prototype.nameField,
            queryCaching: false,
            listConfig: {
                htmlEncode: true
            }
        });
        this.resourcesFilter = new Ext.util.Filter({
            filterFn: this.filterResources,
            scope: this
        });
        if (this.addResources) {
            // add new resource record to combo store before assertValue call
            Ext.Function.interceptBefore(this.resourceCombo, 'assertValue', function() {
                me.onResourceComboAssert(this);
            });
        }
        return [
            {
                xtype: 'resourcenamecolumn',
                editor: this.resourceCombo,
                dataIndex: this.assignmentStore.model.prototype.resourceIdField,
                renderer: this.resourceRender,
                resourceStore: me.resourceDupStore,
                scope: this
            },
            {
                xtype: 'assignmentunitscolumn',
                assignmentStore: this.assignmentStore,
                dataIndex: this.assignmentStore.model.prototype.unitsField
            }
        ];
    },
    saveResources: function() {
        this.suspendDataRefresh();
        Gnt.util.Data.applyCloneChanges(this.resourceDupStore, this.resourceStore);
        this.resumeDataRefresh();
    },
    /**
     * Persists task assignments to {@link #assignmentStore}.
     * @return {Boolean} `false` if saving error occurs. Otherwise returns `true`.
     */
    saveTaskAssignments: function() {
        // suspend the grid reacting on resource and assignment store changes
        // during applying changes to these stores
        this.suspendDataRefresh();
        // first we have to save resources in case of *new* resource assignment
        this.saveResources();
        var model = this.store.model,
            comboStore = this.resourceDupStore,
            result = true;
        Gnt.util.Data.applyCloneChanges(this.store, this.assignmentStore, function(data) {
            // get assigned resource
            var resource = comboStore.getById(this.getResourceId());
            // and its original record
            if (!resource || !resource.originalRecord) {
                // normally it should`t occur this way since we had to save resources at first
                result = false;
                return;
            }
            var r = resource.originalRecord;
            // now let's use real resource ID for saving
            data[model.prototype.resourceIdField] = r.getId() || r.internalId;
        });
        this.resumeDataRefresh();
        return result;
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    /**
     * Checks if the data in the grid store is valid.
     * @return {Boolean}
     */
    isValid: function() {
        var result = true;
        this.store.each(function(record) {
            if (!record.isValid()) {
                result = false;
                return false;
            }
        });
        return result;
    },
    isDataValid: function() {
        return this.isValid();
    }
});

/**
 @class Gnt.widget.DependencyGrid
 @extends Ext.grid.Panel

 A widget used to display and edit the dependencies of a task.
 This widget is used as the `Predecessors` tab of the {@link Gnt.widget.taskeditor.TaskEditor}.
 There you can configure it through the {@link Gnt.widget.taskeditor.TaskEditor#dependencyGridConfig dependencyGridConfig} object
 available both on the {@link Gnt.widget.taskeditor.TaskEditor} and on the {@link Gnt.plugin.TaskEditor} classes.

 {@img gantt/images/dependency-grid.png}

 You can create an instance of the grid like this:

```javascript
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
     renderTo : Ext.getBody()
 });
```

 To load data into the grid you can use the {@link #loadDependencies} method:

```javascript
 // create grid
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
     renderTo : Ext.getBody()
 });

 // load data
 dependencyGrid.loadDependencies(someTask);
```

 * **Note:** If you plan to use this grid for tasks that don't belong to any taskStore you should specify a {@link #dependencyStore}:

```javascript
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
     renderTo        : Ext.getBody(),
     dependencyStore : dependencyStore
 });
```

 Let's make our example more interesting by adding toolbar with buttons for editing:

```javascript
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
     renderTo        : Ext.getBody(),
     dependencyStore : dependencyStore,

     // toolbar with buttons
     tbar            : {
         items   : [
             {
                 xtype       : 'button',
                 iconCls     : 'add',
                 text        : 'Add',
                 handler     : function() {
                     dependencyGrid.insertDependency();
                 }
             },
             {
                 xtype       : 'button',
                 iconCls     : 'remove',
                 text        : 'Remove',
                 handler     : function() {
                     var recs = dependencyGrid.getSelectionModel().getSelection();
                     if (recs && recs.length) {
                         dependencyGrid.store.remove(recs);
                     }
                 }
             }
         ]
     }
 });
```

# Set grid direction

 By default this grid displays predecessors of a task. To display successors instead, set the {@link #cfg-direction} config to 'successors'.
 Example:

```javascript
 dependencyGrid = Ext.create('Gnt.widget.DependencyGrid', {
     // set grid to display successors
     direction : 'successors'
 });
```

# Embedded checks

 This class contains embedded transitivity and cycle detection algorithms. It runs them every time a new dependency is being added.
 * **For example**: There is `Task A`->`Task B` and `Task B`->`Task C` dependencies.
 In this case dependency `Task A`->`Task C` will be **transitive** and therefore will be considered invalid.
 And dependency `Task C`->`Task A` (or `Task B`->`Task A`) will form a **cycle** and will also be considered invalid.

 */
Ext.define('Gnt.widget.DependencyGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.dependencygrid',
    requires: [
        'Ext.data.JsonStore',
        'Ext.grid.plugin.CellEditing',
        'Ext.form.field.ComboBox',
        'Ext.util.Filter',
        'Sch.patches.BoundList',
        'Sch.util.Date',
        'Gnt.model.Dependency',
        'Gnt.model.Task',
        'Gnt.util.Data',
        'Gnt.field.Duration'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Boolean} readOnly Whether this grid is read only.
     */
    readOnly: false,
    /**
     * @cfg {Boolean} showCls Whether to show the column for `Cls` field of the dependencies.
     */
    showCls: false,
    cls: 'gnt-dependencygrid',
    /**
     * @property {Gnt.model.Task} task The task for which the dependencies are to be displayed.
     * @readonly
     */
    task: null,
    /**
     * @cfg {Gnt.data.DependencyStore} dependencyStore A store with dependencies.
     */
    dependencyStore: null,
    /**
     * @cfg {Gnt.model.Task} taskModel A task model class.
     * **Note:** This setting might be required when the grid shows dependencies of a task which subclasses {@link Gnt.model.Task}
     * and does not belong to any task store (if task store is not specified in dependency store).
     */
    taskModel: null,
    /**
     * @property {String} direction The type of dependencies that are displayed in the grid. Either 'predecessors' or 'successors'.
     * @readonly
     * **Note:** You should use this property for *reading only*.
     */
    /**
     * @cfg {String} direction Defines what kind of dependencies will be displayed in a grid. Either 'predecessors' or 'successors'.
     */
    direction: 'predecessors',
    oppositeStore: null,
    taskStoreListeners: null,
    refreshTimeout: 100,
    dependencyModel: 'Gnt.model.Dependency',
    /**
     * @cfg {Boolean} allowParentTaskDependencies Set to `true` to include parent tasks in the list of possible predecessors/successors.
     * @removed The panel now takes {@link Gnt.data.DependencyStore#allowParentTaskDependencies} setting into account.
     */
    allowParentTaskDependencies: false,
    /**
     * @cfg {Boolean} useSequenceNumber Set to `true` to use auto-generated sequential identifiers
     * to reference other tasks (see {@link Gnt.model.Task#getSequenceNumber} for definition).
     * If value is `false` then "real" id (that is stored in the database) will be used.
     */
    useSequenceNumber: false,
    /**
     * @cfg {Object} l10n
     * A object, purposed for class localization. Contains the following keys/values:

     - idText                      : 'ID',
     - taskText                    : 'Task Name',
     - blankTaskText               : 'Please select task',
     - invalidDependencyText       : 'Invalid dependency',
     - parentChildDependencyText   : 'Dependency between child and parent found',
     - duplicatingDependencyText   : 'Duplicating dependency found',
     - transitiveDependencyText    : 'Transitive dependency',
     - cyclicDependencyText        : 'Cyclic dependency',
     - typeText                    : 'Type',
     - lagText                     : 'Lag',
     - clsText                     : 'CSS class',
     - endToStartText              : 'Finish-To-Start',
     - startToStartText            : 'Start-To-Start',
     - endToEndText                : 'Finish-To-Finish',
     - startToEndText              : 'Start-To-Finish'
     */
    /**
     * @property {Gnt.field.Duration} lagEditor Editor instance used for the `Lag` column editing.
     */
    lagEditor: null,
    /**
     * @property {Ext.form.field.ComboBox} typesCombo Editor instance used for the `Type` column editing.
     */
    typesCombo: null,
    margin: 0,
    border: false,
    dependencyStoreRefreshSuspended: 0,
    initComponent: function() {
        var me = this;
        if (!me.readOnly) {
            me.plugins = me.buildPlugins();
        }
        // Configure taskModel automatically if not provided
        if (!me.taskModel) {
            if (me.dependencyStore) {
                var taskStore = me.dependencyStore.getTaskStore();
                if (taskStore) {
                    me.taskModel = taskStore.getModel();
                }
            }
            me.taskModel = me.taskModel || Gnt.model.Task;
        }
        if (me.oppositeStore) {
            me.setOppositeStore(me.oppositeStore);
        }
        me.store = me.store || new Ext.data.JsonStore({
            autoDestroy: true,
            model: me.dependencyModel
        });
        if (me.task) {
            me.setTask(me.task);
            me.loadDependencies(me.task);
        }
        if (!me.title) {
            me.title = me.direction === 'predecessors' ? me.L('predecessorsText') : me.L('successorsText');
        }
        me.columns = me.buildColumns();
        me.tbar = me.tbar || [
            {
                iconCls: 'x-fa fa-plus',
                text: me.L('addDependencyText'),
                itemId: 'add-dependency-btn',
                handler: function() {
                    me.insertDependency();
                }
            },
            {
                iconCls: 'x-fa fa-trash',
                text: me.L('dropDependencyText'),
                itemId: 'drop-dependency-btn',
                disabled: true,
                handler: function() {
                    var recs = me.getSelectionModel().getSelection();
                    if (recs && recs.length) {
                        var store = me.store;
                        var index = store.indexOf(recs[0]);
                        me.cancelEdit();
                        store.remove(recs);
                        if (store.getCount() > 0) {
                            me.getSelectionModel().select((index === store.getCount()) ? index - 1 : index);
                        }
                    }
                }
            }
        ];
        me.callParent(arguments);
        me.on({
            selectionchange: function(sm, sel) {
                if (!me.dropDepBtn) {
                    me.dropDepBtn = me.down('#drop-dependency-btn');
                }
                me.dropDepBtn && me.dropDepBtn.setDisabled(!sel.length);
            },
            scope: me
        });
    },
    destroy: function() {
        if (this.deferredStoreBind) {
            this.tasksCombo.un('render', this.bindTaskStore, this);
        }
        this.cellEditing.destroy();
        this.tasksCombo.destroy();
        this.typesCombo.destroy();
        this.lagEditor.destroy();
        this.callParent(arguments);
    },
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    setDependencyStore: function(dependencyStore) {
        if (dependencyStore !== this.dependencyStore) {
            this.bindDependencyStore(dependencyStore);
            this.dependencyStore = dependencyStore;
            if (this.typesCombo) {
                this.typesCombo.store.filter(this.typesFilter);
            }
            if (!this.deferredStoreBind) {
                this.bindTaskStore();
            }
        }
    },
    bindDependencyStore: function(store) {
        var me = this;
        if (me.dependencyStoreDetacher)  {
            me.dependencyStoreDetacher.destroy();
        }
        
        if (store) {
            me.dependencyStoreDetacher = me.mon(store, {
                'add': me.onDependencyStoreDataChanged,
                'remove': me.onDependencyStoreDataChanged,
                'load': me.onDependencyStoreDataChanged,
                'clear': me.onDependencyStoreDataChanged,
                scope: me,
                destroyable: true
            });
        }
    },
    setTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.task = task;
        this.setDependencyStore(task.dependencyStore || task.getTaskStore().dependencyStore);
        this.setReadOnly(task.isReadOnly());
    },
    /**
     * Disable the cellediting plugin
     * @param readOnly
     */
    setReadOnly: function(readOnly) {
        if (this.cellEditing) {
            if (readOnly) {
                this.cellEditing.disable();
            } else {
                this.cellEditing.enable();
            }
        }
        if (this.items) {
            this.down('toolbar').setVisible(!readOnly);
        }
    },
    onDependencyStoreDataChanged: function() {
        if (!this.dependencyStoreRefreshSuspended)  {
            this.loadDependencies();
        }
        
    },
    buildPlugins: function() {
        var cellEditing = this.cellEditing = new Ext.grid.plugin.CellEditing({
                clicksToEdit: 1
            });
        cellEditing.on({
            beforeedit: this.onEditingStart,
            edit: this.onEditingDone,
            scope: this
        });
        return [
            cellEditing
        ];
    },
    hide: function() {
        this.cancelEdit();
        this.callParent(arguments);
    },
    cancelEdit: function() {
        this.cellEditing.cancelEdit();
    },
    onEditingStart: function(ed, e) {
        var model = this.store.model.prototype;
        switch (e.field) {
            case model.lagField:
                this.lagEditor.durationUnit = e.record.getLagUnit();
                break;
            case model.typeField:
                this.typesCombo.store.filter(this.typesFilter);
                // if set of dependency types is restricted and allowed number of types is less than 2
                // we won't show dropdown list
                if (this.typesCombo.store.count() < 2)  {
                    return false;
                }
                ;
                break;
            case model.fromField:
                if (this.direction == 'predecessors') {
                    this.activeDependency = e.record;
                    this.refilterTasksCombo();
                };
                break;
            case model.toField:
                if (this.direction != 'predecessors') {
                    this.activeDependency = e.record;
                    this.refilterTasksCombo();
                };
                break;
        }
    },
    onEditingDone: function(ed, e) {
        var model = this.store.model.prototype;
        if (e.field == model.lagField) {
            e.record.setLagUnit(this.lagEditor.durationUnit);
        }
        // after editing we refresh view since some records could become invalid
        this.getView().refreshView();
    },
    // dependency type column renderer
    dependencyTypeRender: function(value) {
        var type = this.store.model.Type;
        switch (value) {
            case type.EndToStart:
                return this.L('endToStartText');
            case type.StartToStart:
                return this.L('startToStartText');
            case type.EndToEnd:
                return this.L('endToEndText');
            case type.StartToEnd:
                return this.L('startToEndText');
        }
        return value;
    },
    // Returns list of dependency errors, used at task column renderer
    taskValidate: function(value, depRec) {
        if (!value) {
            return [
                this.L('blankTaskText')
            ];
        }
        if (!depRec.isValid()) {
            var errors = this.getDependencyErrors(depRec);
            if (errors && errors.length) {
                return errors;
            }
            return [
                this.L('invalidDependencyText')
            ];
        }
    },
    // Task name column renderer
    taskRender: function(value, meta, depRec) {
        var errors = this.taskValidate(value, depRec),
            record;
        if (errors && errors.length) {
            meta.tdCls = 'gnt-cell-invalid';
            meta.tdAttr = 'data-errorqtip="' + errors.join('<br>') + '"';
        } else {
            meta.tdCls = '';
            meta.tdAttr = 'data-errorqtip=""';
        }
        var taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
        if (taskStore) {
            record = taskStore.getModelById(value);
            return (record && Ext.htmlEncode(record.getName())) || '';
        }
        return '';
    },
    filterTasks: function(record) {
        var taskId = record.getId(),
            preserveTaskId, fromId, toId;
        if (this.direction === 'predecessors') {
            fromId = taskId;
            toId = this.task.getId();
            preserveTaskId = this.activeDependency && this.activeDependency.getSourceId();
        } else {
            toId = taskId;
            fromId = this.task.getId();
            preserveTaskId = this.activeDependency && this.activeDependency.getTargetId();
        }
        // 1) we don't filter out the task used in the dependency being edited (it's kept in this.activeDependency)
        // 2) other than that we simply filter out all the tasks that build invalid dependencies
        return !this.activeDependency || taskId == preserveTaskId || this.isValidDependency(fromId, toId);
    },
    refilterTasksCombo: function() {
        this.tasksCombo.getStore().addFilter(this.tasksFilter);
    },
    rebuildTasksComboStore: function() {
        var me = this;
        if (!me.destroyed) {
            var taskStore = me.getDependencyStore().getTaskStore();
            // make new store for the tasks dropdown list
            var store = new Ext.data.JsonStore({
                    autoDestroy: true,
                    model: taskStore.model,
                    sorters: taskStore.model.prototype.nameField
                });
            var root = taskStore.getRoot();
            // load tasks from tasks store
            store.loadData(Gnt.util.Data.cloneModelSet(taskStore.toArray(), function(rec, src) {
                if (src === root || src.hidden || (me.direction === 'successors' && src.isReadOnly()))  {
                    return false;
                }
                
                // set phantomId as Id for records without Id
                // we need it since combo's valueField is 'Id'
                if (!src.getId()) {
                    rec.setId(src.getId());
                }
            }));
            me.tasksFilter = new Ext.util.Filter({
                id: 'dependencygrid-tasksfilter',
                filterFn: me.filterTasks,
                scope: me
            });
            // and apply filter to it
            store.filter(me.tasksFilter);
            if (me.tasksCombo) {
                me.tasksCombo.bindStore(store);
            } else {
                me.tasksComboStore = store;
            }
        }
    },
    bindTaskStore: function() {
        // This method is called via Ext.Function.createBuffered()
        // so in cases when task store get dirty during saveDependencies() call
        // this method can be called after the grid gets destroyed (happens in 1113_dependencygrid_negative_lag test)
        if (!this.destroyed) {
            var taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
            if (taskStore) {
                this.taskStoreListeners && this.taskStoreListeners.destroy();
                // merge multiple refreshes to single one
                var refreshTasks = Ext.Function.createBuffered(this.rebuildTasksComboStore, this.refreshTimeout, this, []);
                this.taskStoreListeners = this.mon(taskStore, {
                    nodeappend: refreshTasks,
                    nodeinsert: refreshTasks,
                    noderemove: refreshTasks,
                    update: refreshTasks,
                    refresh: refreshTasks,
                    clear: refreshTasks,
                    'nodestore-datachange-end': refreshTasks,
                    scope: this,
                    destroyable: true
                });
                this.rebuildTasksComboStore();
            }
        }
    },
    buildTasksCombo: function() {
        var me = this;
        return new Ext.form.field.ComboBox({
            queryMode: 'local',
            allowBlank: false,
            editing: false,
            forceSelection: true,
            store: this.tasksComboStore,
            valueField: this.taskModel.prototype.idProperty,
            displayField: this.taskModel.prototype.nameField,
            queryCaching: false,
            validator: function(value) {
                if (!value) {
                    return me.L('blankTaskText');
                }
                return true;
            },
            listConfig: {
                htmlEncode: true
            }
        });
    },
    filterAllowedTypes: function(record) {
        if (!this.dependencyStore || !this.dependencyStore.allowedDependencyTypes)  {
            return true;
        }
        
        var allowed = this.dependencyStore.allowedDependencyTypes;
        var depType = this.store.model.Type;
        for (var i = 0,
            l = allowed.length; i < l; i++) {
            var type = depType[allowed[i]];
            if (record.getId() == type)  {
                return true;
            }
            
        }
        return false;
    },
    buildTypesCombo: function() {
        var depType = this.store.model.Type;
        // https://www.sencha.com/forum/showthread.php?300987-How-re-filter-chained-store.&viewfull=1#post1103214
        // assign id to filter fn to use filter(this.typesFilter)
        this.typesFilter = new Ext.util.Filter({
            id: 'typesfilter',
            filterFn: this.filterAllowedTypes,
            scope: this
        });
        var store = new Ext.data.ArrayStore({
                fields: [
                    {
                        name: 'id',
                        type: 'int'
                    },
                    'text'
                ],
                data: [
                    [
                        depType.EndToStart,
                        this.L('endToStartText')
                    ],
                    [
                        depType.StartToStart,
                        this.L('startToStartText')
                    ],
                    [
                        depType.EndToEnd,
                        this.L('endToEndText')
                    ],
                    [
                        depType.StartToEnd,
                        this.L('startToEndText')
                    ]
                ]
            });
        // and apply filter to it
        store.filter(this.typesFilter);
        return new Ext.form.field.ComboBox({
            triggerAction: 'all',
            queryMode: 'local',
            editable: false,
            valueField: 'id',
            displayField: 'text',
            store: store,
            listConfig: {
                htmlEncode: true
            }
        });
    },
    buildLagEditor: function() {
        return new Gnt.field.Duration({
            minValue: Number.NEGATIVE_INFINITY
        });
    },
    /**
     * @protected
     * Builds a list of columns that appear in this grid.
     * @return {Ext.grid.column.Column[]/Object[]} An array of {@link Ext.grid.column.Column column} definition objects which define columns that appear in the grid.
     */
    buildColumns: function() {
        var me = this,
            model = this.store.model.prototype,
            result = [],
            taskStore = this.dependencyStore && this.dependencyStore.getTaskStore();
        // task name column editor
        this.tasksCombo = this.buildTasksCombo();
        // if no taskStore yet let`s defer its binding
        if (!taskStore) {
            this.deferredStoreBind = true;
            this.tasksCombo.on('afterrender', this.bindTaskStore, this);
        } else // let`s build & bind combobox store
        {
            this.bindTaskStore();
        }
        var fromOrToField = model[this.direction === 'predecessors' ? "fromField" : "toField"];
        if (this.useSequenceNumber) {
            result.push({
                text: this.L('snText'),
                dataIndex: fromOrToField,
                renderer: function(value, meta, record) {
                    var store = me.dependencyStore && me.dependencyStore.getTaskStore(),
                        node = store && store.getModelById(record.get(fromOrToField));
                    return node ? node.getSequenceNumber() : '';
                },
                width: 50
            });
        } else {
            result.push({
                text: this.L('idText'),
                dataIndex: fromOrToField,
                width: 50
            });
        }
        result.push({
            text: this.L('taskText'),
            dataIndex: fromOrToField,
            flex: 1,
            editor: this.tasksCombo,
            renderer: function(value, meta, depRec) {
                return me.taskRender(value, meta, depRec);
            }
        });
        this.lagEditor = this.buildLagEditor();
        this.typesCombo = this.buildTypesCombo();
        result.push({
            text: this.L('typeText'),
            dataIndex: model.typeField,
            width: 120,
            renderer: this.dependencyTypeRender,
            scope: this,
            editor: this.typesCombo
        }, {
            text: this.L('lagText'),
            dataIndex: model.lagField,
            width: 100,
            editor: this.lagEditor,
            renderer: function(value, meta, record) {
                return me.lagEditor.valueToVisible(value, record.get(model.lagUnitField), 2);
            }
        }, {
            text: this.L('clsText'),
            dataIndex: model.clsField,
            hidden: !this.showCls,
            width: 100
        });
        return result;
    },
    /**
     * Creates new record and starts process of its editing.
     * @param {Gnt.model.Dependency/Object} [newRecord] New dependency to be added.
     * @param {Boolean} [doNotActivateEditor=false] `true` to just insert record without starting the editing after insertion.
     * @return {Gnt.model.Dependency[]} The records that were added.
     */
    insertDependency: function(newRecord, doNotActivateEditor) {
        if (!this.dependencyStore)  {
            return;
        }
        
        var me = this,
            taskId = me.task.getId(),
            model = me.store.model;
        newRecord = newRecord || {};
        if (!newRecord.isModel) {
            if (!newRecord[model.prototype.typeField]) {
                var firstType = me.typesCombo && me.typesCombo.store && me.typesCombo.store.first();
                if (firstType) {
                    newRecord[model.prototype.typeField] = firstType.getId();
                }
            }
            newRecord = new model(newRecord);
        }
        if (this.direction === 'predecessors') {
            newRecord.setTo(taskId);
        } else {
            newRecord.setFrom(taskId);
        }
        // patch "isValid" method to use grid "isValidDependency" method
        var oldValidator = newRecord.isValid;
        newRecord.isValid = function() {
            return oldValidator.call(this, false) && me.isValidDependency(this);
        };
        var added = this.store.insert(0, newRecord);
        if (!doNotActivateEditor) {
            this.cellEditing.startEditByPosition({
                row: 0,
                column: 1
            });
        }
        return added;
    },
    onOppositeStoreChange: function() {
        this.getView().refreshView();
    },
    setOppositeStore: function(store) {
        // this can be made public after resolving the problem with transitivity detection
        //
        // Sets store with opposite to the grid dependencies direction.
        // This can be used for example to implement two grids one with predecessors and another one with successors of the task.
        // Grids will work in conjunction and validation of one grid will instantly react on changes made in another one.
        // @param {Ext.data.Store} store Store with dependencies.
        // @example
        //      var predecessorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'predecessors',
        //          dependencyStore : dependencyStore,
        //          task            : task
        //      });
        //
        //      var successorsGrid = Ext.create('Gnt.widget.DependencyGrid', {
        //          direction       : 'successors',
        //          dependencyStore : dependencyStore,
        //          // set predecessors grid store as opposite to successors
        //          oppositeStore   : predecessorsGrid.store,
        //          task            : task
        //      });
        //
        //      // set successors grid store as opposite to predecessors
        //      predecessorsGrid.setOppositeStore(successorsGrid.store);
        //
        var listeners = {
                update: this.onOppositeStoreChange,
                datachanged: this.onOppositeStoreChange,
                scope: this
            };
        if (this.oppositeStore) {
            this.mun(this.oppositeStore, listeners);
        }
        this.oppositeStore = store;
        // on opposite store changes we will refresh grid view
        // since it can affect rows validity
        this.mon(this.oppositeStore, listeners);
    },
    /**
     * Gets all dependencies of the provided task and loads them to the grid's store.
     * @param {Gnt.model.Task} task The task which dependencies should be loaded to the store.
     */
    loadDependencies: function(task) {
        var me = this;
        task = task || this.task;
        if (!task)  {
            return;
        }
        
        if (this.task !== task) {
            this.setTask(task);
        }
        var data;
        if (this.direction === 'predecessors') {
            data = task.getIncomingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = task.getOutgoingDependencies(true);
            }
        } else {
            data = task.getOutgoingDependencies(true);
            if (!this.oppositeStore) {
                this.oppositeData = task.getIncomingDependencies(true);
            }
        }
        // let`s clone it to not affect real data
        // we save changes only by saveDependencies() call
        var result = Gnt.util.Data.cloneModelSet(data, function(rec) {
                // validate record by our own validator
                var oldValidator = rec.isValid;
                rec.isValid = function() {
                    return oldValidator.call(this, false) && me.isValidDependency(this);
                };
            });
        this.store.loadData(result);
        this.fireEvent('loaddependencies', this, this.store, result, task);
    },
    /*
     * Gets an array of error messages for provided dependency.
     */
    getDependencyErrors: function(fromId, toId) {
        var me = this,
            depStore = me.dependencyStore,
            errors = [],
            dependency, type;
        if (fromId instanceof Gnt.model.Dependency) {
            dependency = fromId;
            fromId = me.task.getId();
            toId = fromId;
            type = dependency.getType();
            if (me.direction === 'predecessors') {
                fromId = dependency.getSourceId();
            } else {
                toId = dependency.getTargetId();
            }
        }
        if (dependency) {
            me.store.each(function(dep) {
                // check duplicating records
                if ((fromId == dep.getSourceId()) && (toId == dep.getTargetId()) && (dep !== dependency)) {
                    errors.push(me.L('duplicatingDependencyText'));
                    return false;
                }
            });
            if (errors.length)  {
                return errors;
            }
            
        }
        // let's ask dependency store to validate the dependency
        // we have to provide list of records that we're adding to the dependency store
        var toAdd = me.store.getRange();
        // ..minus dependency that we're validating (if we validating dependency instance)
        dependency && toAdd.splice(Ext.Array.indexOf(toAdd, dependency), 1);
        // and list of existing ..old dependencies ..that we plan to remove/replace
        var oldDependencies = me.task[me.direction];
        // run validation
        var error = depStore.getDependencyError(fromId, toId, type, toAdd, oldDependencies);
        if (error) {
            switch (error) {
                case -3:
                case -8:
                case -5:
                case -6:
                    return [
                        me.L('transitiveDependencyText')
                    ];
                case -4:
                case -7:
                    return [
                        me.L('cyclicDependencyText')
                    ];
                case -9:
                    return [
                        me.L('parentChildDependencyText')
                    ];
            }
            return [
                this.L('invalidDependencyText')
            ];
        }
        return errors;
    },
    /*
     * Checks if the dependency is valid.
     */
    isValidDependency: function() {
        return !this.getDependencyErrors.apply(this, arguments).length;
    },
    /*
     * Checks if the grid is valid.
     */
    isValid: function() {
        var result = true;
        this.store.each(function(record) {
            if (!record.isValid()) {
                result = false;
                return false;
            }
        });
        return result;
    },
    suspendDependencyStoreRefresh: function() {
        this.dependencyStoreRefreshSuspended++;
    },
    resumeDependencyStoreRefresh: function() {
        this.dependencyStoreRefreshSuspended--;
    },
    /**
     * Applies all changes that have been made to grid data to dependency store.
     */
    saveDependencies: function() {
        if (this.dependencyStore && this.isValid()) {
            this.suspendDependencyStoreRefresh();
            // push changes from grid store to real dependencyStore
            Gnt.util.Data.applyCloneChanges(this.store, this.dependencyStore);
            this.resumeDependencyStoreRefresh();
        }
    },
    isDataChanged: function() {
        var me = this;
        return me.store && me.store.getUpdatedRecords().length > 0 || me.store.getNewRecords().length > 0 || me.store.getRemovedRecords().length > 0;
    },
    isDataValid: function() {
        return this.isValid();
    }
});

/**
 * @class Gnt.widget.taskeditor.TaskEditor
 * @extends Gnt.widget.taskeditor.BaseEditor
 *
 * A widget used to display and edit task information.
 * By default the widget is an Ext.tab.Panel instance which can contain the following tabs:
 *
 * - General information
 * - Predecessors
 * - Resources
 * - Advanced
 * - Notes
 *
 * You can easily add new custom tabs using {@link #items} config.
 *
 * # General
 *
 * {@img gantt/images/taskeditor-panel-general.png}
 *
 * Contains a customizable {@link Gnt.widget.TaskForm form} instance for viewing and editing the following task data:
 *
 * - the name of the task
 * - the start date of the task
 * - the end date of the task
 * - the task duration
 * - the task effort
 * - the current status of a task, expressed as the percentage completed
 * - the baseline start date of the task (editing of this field is optional)
 * - the baseline end date of the task (editing of this field is optional)
 * - the baseline status of a task, expressed as the percentage completed (editing of this field is optional)
 *
 * # Task data loading and persisting
 *
 * In order to load a task into the task editor the one should use {@link #loadTask} method:
 *
 * ```javascript
 * taskEditor.loadTask(task);
 * ```
 *
 * The task editor tries to load all the contained forms with the loaded task data automatically.
 * To achieve that it calls the forms `loadRecord` method. And standalone fields, not belonging to any form, are also loaded.
 * The task editor maps them to the task model fields using their `name` properties.
 *
 * Please see {@link #beforeloadtasktoform} event to prevent some form auto-loading.
 *
 * In order to apply changes to the task the one should call {@link #updateTask} method:
 *
 * ```javascript
 * // applies changes to the loaded task
 * taskEditor.updateTask(function (cancelChanges) {
 *     // a function which is called when changes are applied or canceled if some constraint violation is met
 * });
 * ```
 *
 * When persisting changes the task editor collects all the contained fields changes (regardless if a field is standalone or belongs to a form)
 * and applies them itself (form `updateRecord` method is not used).
 *
 * Due to this behavior it's normally enough to just add a new field to the model and to the task editor to see the data loaded and persisted.
 *
 * ### Task form customization
 *
 * There is a {@link #taskFormConfig} config which can be used to customize the form panel.
 *
 * ```javascript
 *    Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        // Configure the form located in the "General" tab
 *        taskFormConfig : {
 *            // turn off fields highlighting
 *            highlightTaskUpdates : false,
 *            // alter panel margin
 *            margin : 20
 *        }
 *    });
 * ```
 *
 * ### Fields configuration
 *
 * The {@link Gnt.widget.TaskForm} class has a config for each field presented at the `General` tab.
 * And using {@link #taskFormConfig} we can get access for those options to setup fields.
 * For example:
 *
 * ```javascript
 *    Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        // setup form located at "General" tab
 *        taskFormConfig : {
 *            // set Baseline Finish Date field invisible
 *            baselineFinishConfig : {
 *                hidden : true
 *            }
 *        }
 *    });
 * ```
 *
 * Here are some more configs for other fields:
 *
 * - {@link Gnt.widget.TaskForm#taskNameConfig taskNameConfig} (the name of the task field)
 * - {@link Gnt.widget.TaskForm#startConfig startConfig} (the start date of the task field)
 * - {@link Gnt.widget.TaskForm#finishConfig finishConfig} (the end date of the task field)
 * - {@link Gnt.widget.TaskForm#durationConfig durationConfig} (the task duration field)
 *
 * Please see {@link Gnt.widget.TaskForm} class to see the full list of available config options.
 *
 * ### Extending the General field set
 *
 * If you want to add a new field to the `General` tab you will have to extend the {@link Gnt.widget.TaskForm TaskForm} class.
 * After that you will need to configure the task editor to use your extended class:
 *
 * ```javascript
 *    // extend standard TaskForm class
 *    Ext.define('MyTaskForm', {
 *        extend : 'Gnt.widget.taskeditor.TaskForm',
 *
 *        constructor : function(config) {
 *            this.callParent(arguments);
 *
 *            // add some custom field
 *            this.add({
 *                fieldLabel  : 'Foo',
 *                name        : 'Name',
 *                width       : 200
 *            });
 *        }
 *    });
 *
 *     // Let task editor know which class to use
 *     Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        // to use MyTaskForm to build the "General" tab
 *        taskFormClass : 'MyTaskForm'
 *    });
 * ```
 *
 * #Predecessors
 *
 * Contains a {@link Gnt.widget.DependencyGrid grid} instance displaying the predecessors for the task.
 * You can add, edit or remove dependencies of the task using this panel.
 *
 * {@img gantt/images/taskeditor-panel-predecessors.png}
 *
 * You can enable/disable this tab by setting the {@link #showDependencyGrid} option.
 * To rename this tab you can use `dependencyText` property of {@link #l10n} config.
 * Customizing the grid itself can be done via the {@link #dependencyGridConfig} config.
 * To change make this tab display successors instead of predecessors - use the following code:
 *
 * ```javascript
 *    Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        l10n : {
 *            // here we change tab title
 *            dependencyText : 'Successors'
 *        },
 *        // here is the grid config
 *        dependencyGridConfig : {
 *            // set grid to display successors
 *            direction : 'successors'
 *        }
 *    });
 * ```
 *
 * ### Customizing the dependency grid class
 *
 * You can also configure the task editor to use a custom class to build this tab using the {@link #dependencyGridClass} option.
 * If you need to add an extra column to the grid, you can do it like this:
 *
 * ```javascript
 *     // extend standard DependencyGrid
 *     Ext.define('MyDependencyGrid', {
 *        extend: 'Gnt.widget.DependencyGrid',
 *
 *        // extend buildColumns method to append extra column
 *        buildColumns : function () {
 *            // add custom column as last one
 *            return this.callParent(arguments).concat({
 *                header    : 'Foo',
 *                dataIndex : 'foo',
 *                width     : 100
 *            });
 *        }
 *    });
 *
 *     // setup task editor
 *     Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        // to use extended class to build tab
 *        dependencyGridClass : 'MyDependencyGrid'
 *    });
 * ```
 *
 * #Resources
 *
 * Contains a {@link Gnt.widget.AssignmentEditGrid grid} instance displaying the task assignments.
 * It allows you to add, edit or remove task assignments.
 *
 * {@img gantt/images/taskeditor-panel-resources2.png}
 *
 * It also supports inline resource adding (for more details, take a look at the {@link Gnt.widget.AssignmentEditGrid#addResources} config.
 *
 * {@img gantt/images/taskeditor-panel-resources1.png}
 *
 * You can enable/disable this tab by setting the {@link #showAssignmentGrid} option.
 * To rename this tab you can use the `resourcesText` property of {@link #l10n} config.
 * Customizing the grid can be done via the {@link #assignmentGridConfig} config.
 *
 * Example:
 *
 * ```javascript
 *    Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        assignmentStore : assignmentStore,
 *        resourceStore : resourceStore,
 *        l10n : {
 *            // rename tab
 *            resourcesText : 'Assignments'
 *        },
 *        // here is grid the config
 *        assignmentGridConfig : {
 *            // disable in-place resources adding
 *            addResources : false
 *        }
 *    });
 * ```
 *
 * ### Customizing the assignment grid class
 *
 * You can use a custom grid class for this tab by using the {@link #assignmentGridClass} option.
 * Example: if you need to add extra column to the grid you can do it like this:
 *
 * ```javascript
 *     // Extend the standard AssignmentGrid
 *     Ext.define('MyAssignmentGrid', {
 *        extend: 'Gnt.widget.AssignmentEditGrid',
 *
 *        // extend buildColumns method to append extra column
 *        buildColumns : function () {
 *            // add custom column as last one
 *            return this.callParent(arguments).concat({
 *                header       : 'Foo',
 *                dataIndex    : 'foo',
 *                width        : 100
 *            });
 *        }
 *    });
 *
 *     // setup task editor
 *     Ext.create('Gnt.widget.taskeditor.TaskEditor', {
 *        // use extended class
 *        assignmentGridClass : 'MyAssignmentGrid'
 *    });
 * ```
 *
 * #Advanced
 *
 * Contains a {@link Gnt.widget.AdvancedForm form} instance which can be customized, allowing the user to view and edit the following task data:
 *
 * - calendar assigned to the task
 * - scheduling mode for the task
 * - manually scheduled flag
 * - WBS code
 * - rollup flag
 * - constraint type
 * - constraint date
 * - read only flag
 *
 * {@img gantt/images/taskeditor-panel-advanced.png}
 *
 * You can enable/disable this tab by setting the {@link #showAdvancedForm} option.
 * To rename this tab you can use the `advancedText` property of {@link #l10n} config.
 *
 * Customizing the form itself can be done via the {@link #advancedFormConfig} config. For example this is how form content can be overwritten:
 *
 * ```javascript
 *    Ext.create("Gnt.widget.taskeditor.TaskEditor", {
 *        advancedFormConfig: {
 *            items: [
 *                 // new fields that will go here
 *                 // will replace standard presented in the "Advanced" tab
 *                 ...
 *            ]
 *        }
 *    });
 * ```
 *
 * ### Customizing the form class
 *
 * You can use your own custom class to build this tab by using the {@link #advancedFormClass} config:
 * For example if you need to add some extra field you can do it like this:
 *
 * ```javascript
 *     // Extend standard TaskForm class
 *     Ext.define('MyAdvancedForm', {
 *        extend : 'Gnt.widget.taskeditor.AdvancedForm',
 *
 *        constructor : function(config) {
 *            this.callParent(arguments);
 *
 *            // add some custom field
 *            this.add({
 *                fieldLabel  : 'Foo',
 *                name        : 'Name',
 *                width       : 200
 *            });
 *        }
 *    });
 *
 *     // setup task editor
 *     Ext.create("Gnt.widget.taskeditor.TaskEditor", {
 *        // to use new class to build the "Advanced" tab
 *        advancedFormClass: 'MyAdvancedForm',
 *    });
 * ```
 *
 * #Notes
 *
 * Contains an {@link Ext.form.field.HtmlEditor HTML editor instance} for viewing and editing a freetext note about the task.
 *
 * {@img gantt/images/taskeditor-panel-notes.png}
 *
 * You can enable/disable this tab by setting the {@link #showNotes} option.
 * To rename this tab you can use the `notesText` property of {@link #l10n} config.
 * Customizing the grid itself can be done via the {@link #notesConfig} config.
 *
 */
Ext.define('Gnt.widget.taskeditor.TaskEditor', {
    extend: 'Gnt.widget.taskeditor.BaseEditor',
    alias: 'widget.taskeditor',
    requires: [
        'Ext.form.field.HtmlEditor',
        'Ext.layout.container.Table',
        'Gnt.widget.taskeditor.TaskForm',
        'Gnt.widget.taskeditor.AdvancedForm',
        'Gnt.widget.AssignmentEditGrid',
        'Gnt.widget.DependencyGrid'
    ],
    alternateClassName: [
        'Gnt.widget.TaskEditor'
    ],
    /**
     * @event loadtask
     * Fires after task has been loaded into the editor.
     * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor widget instance.
     * @param {Gnt.model.Task} task The task.
     */
    /**
     * @cfg {String} taskFormClass Class representing the form in the `General` tab.
     *
     * This option supposed to be used to implement a custom form in the `General` tab content.
     */
    taskFormClass: 'Gnt.widget.taskeditor.TaskForm',
    /**
     * @cfg {String} advancedFormClass Class representing the form in the `Advanced` tab.
     *
     * This option supposed to be used to implement a custom form in the `Advanced` tab content.
     */
    advancedFormClass: 'Gnt.widget.taskeditor.AdvancedForm',
    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display the `Resources` tab.
     */
    showAssignmentGrid: true,
    /**
     * @cfg {Boolean} showDependencyGrid `true` to display the `Predecessors` tab.
     */
    showDependencyGrid: true,
    /**
     * @cfg {Boolean} allowParentTaskDependencies `false` to hide a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `false` as well) and also exclude parent tasks from the list
     * of possible predecessors.
     */
    allowParentTaskDependencies: true,
    /**
     * @cfg {Boolean} showNotes `true` to display the `Notes` tab.
     */
    showNotes: true,
    /**
     * @cfg {Boolean} showAdvancedForm `true` to display the `Advanced` tab.
     */
    showAdvancedForm: true,
    /**
     * @cfg {Boolean} showRollup `true` to display rollup field on the `Advanced` tab.
     */
    showRollup: false,
    /**
     * @cfg {Boolean} showReadOnly `false` to hide readonly field on the `Advanced` tab.
     */
    showReadOnly: true,
    /**
     * @event beforeupdatetask
     * @preventable
     * Fires before task updating occurs. Return `false` to prevent the update.
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor widget instance.
     * @param {Function} proceedCallback The function which can be called manually to continue task updating. Example:
     *
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          listeners   : {
     *              beforeupdatetask    : function (taskeditor, proceedCallback) {
     *                  var me  = this;
     *                  Ext.MessageBox.confirm('Confirm', 'Are you sure you want to do that?', function (buttonId) {
     *                      if (buttonId == 'yes') {
     *                          // here we continue updating asynchronously after user click "Yes" button
     *                          proceedCallback();
     *                          me.hide();
     *                      }
     *                  });
     *                  // here we return false to stop updating
     *                  return false;
     *              }
     *          }
     *      });
     *
     */
    /**
     * @event afterupdatetask
     * Fires after a task has been updated.
     * This event can be used to do some extra processing after the task got updated by the task editor.
     * @param {Gnt.widget.taskeditor.BaseEditor} taskEditor The task editor instance.
     */
    /**
     * @cfg {Object/Object[]} items A single item, or an array of child Components to be **appended** after default tabs to this container.
     * For example:
     *
     * ```javascript
     *      var taskEditor = Ext.create('Gnt.widget.taskeditor.TaskEditor', {
     *          items: [{
     *              title   : "Some custom tab",
     *              items   : [{
     *                  xtype       : 'textfield',
     *                  fieldLabel  : 'Enter your name',
     *                  id          : 'enter-your-name',
     *                  allowBlank  : false,
     *                  blankText   : 'Please enter your name'
     *              }]
     *          }]
     *      });
     * ```
     */
    /**
     * @cfg {Boolean} showBaseline `true` to display baseline fields in the `General` tab.
     */
    showBaseline: true,
    /**
     * @cfg {Object} taskFormConfig Configuration options to be supplied to the `General` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     */
    taskFormConfig: null,
    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    dependencyGridClass: 'Gnt.widget.DependencyGrid',
    /**
     * @cfg {Object} dependencyGridConfig Configuration options for the `Predecessors` tab.
     * For possible options take a look at the {@link Gnt.widget.DependencyGrid}.
     *
     */
    dependencyGridConfig: null,
    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    assignmentGridClass: 'Gnt.widget.AssignmentEditGrid',
    /**
     * @cfg {Object} assignmentGridConfig Configuration options for the `Resources` tab.
     * For possible options take a look at the {@link Gnt.widget.AssignmentEditGrid}.
     *
     */
    assignmentGridConfig: null,
    /**
     * @cfg {Object} advancedFormConfig Configuration options for the `Advanced` tab.
     * For possible options take a look at the {@link Gnt.widget.TaskForm}.
     *
     */
    advancedFormConfig: null,
    /**
     * @cfg {Object} notesConfig Configuration options for the HTML-editor placed in the `Notes` tab.
     * For possible options take a look at the {@link Ext.form.field.HtmlEditor}.
     */
    notesConfig: null,
    /**
     * @property {Ext.panel.Panel} notesPanel The `Notes` tab.
     * Please use {@link #notesEditor} to access an enclosed HTML-editor.
     */
    notesPanel: null,
    /**
     * @property {Ext.form.field.HtmlEditor} notesEditor The HTML-editor presented in the `Notes` tab.
     * To specify setting for the HTML-editor please use {@link #notesConfig}.
     */
    notesEditor: null,
    /**
     * @property {Gnt.widget.TaskForm} taskForm The `General` tab task form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it might be customized by using {@link #taskFormClass} option.
     */
    taskForm: null,
    /**
     * @property {Gnt.widget.AssignmentEditGrid} assignmentGrid The grid used for the `Resources` tab.
     *
     */
    assignmentGrid: null,
    /**
     * @property {Gnt.widget.DependencyGrid} dependencyGrid The `Predecessors` tab instance.
     *
     */
    dependencyGrid: null,
    /**
     * @property {Gnt.widget.TaskForm} advancedForm The `Advanced` tab form.
     * By default it's a {@link Gnt.widget.TaskForm} instance but it can be customized by using {@link #advancedFormClass} option.
     *
     */
    advancedForm: null,
    margin: 0,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     *  - generalText         : 'General',
     *  - resourcesText       : 'Resources',
     *  - dependencyText      : 'Predecessors',
     *  - addDependencyText   : 'Add new',
     *  - dropDependencyText  : 'Remove',
     *  - notesText           : 'Notes',
     *  - advancedText        : 'Advanced',
     *  - wbsCodeText         : 'WBS code',
     *  - addAssignmentText   : 'Add new',
     *  - dropAssignmentText  : 'Remove'
     */
    notUpdatableFields: [
        'index',
        'isLast'
    ],
    initComponent: function() {
        this.notUpdatableFields = this.notUpdatableFields.slice();
        this.notUpdatableFields.push(this.taskStore.parentIdProperty || 'parentId');
        this.callParent(arguments);
    },
    buildItems: function() {
        var me = this,
            items = [];
        if (me.taskForm !== false && (!me.taskForm || !me.taskForm.isInstance)) {
            me.taskForm = Ext.create(Ext.apply({
                xtype: 'taskform',
                xclass: me.taskFormClass,
                task: me.task,
                border: false,
                taskStore: me.taskStore,
                showBaseline: me.showBaseline,
                showRollup: false
            }, me.taskForm, me.taskFormConfig));
        }
        if (!me.taskForm.title) {
            me.taskForm.title = me.L('generalText');
        }
        items.push(me.taskForm);
        // create DependencyGrid instance
        if (me.showDependencyGrid) {
            me.dependencyGrid = Ext.create(me.dependencyGridClass, Ext.apply({
                allowParentTaskDependencies: me.allowParentTaskDependencies,
                taskModel: me.taskStore.model,
                dependencyModel: me.taskStore.getDependencyStore().getModel(),
                // task                        : me.task,
                margin: 0,
                border: false
            }, me.dependencyGridConfig));
            items.push(me.dependencyGrid);
        }
        // if AssignmentGrid required
        if (me.showAssignmentGrid && me.assignmentStore && me.resourceStore) {
            // clone assignment and resource stores if they were not copied before
            if (!me.getAssignmentStoreClone())  {
                me.setAssignmentStoreClone(me.cloneAssignmentStore(me.task));
            }
            
            if (!me.getResourceStoreClone())  {
                me.setResourceStoreClone(me.cloneResourceStore(me.task));
            }
            
            // create AssignmentGrid instance
            me.assignmentGrid = Ext.create(me.assignmentGridClass, Ext.apply({
                assignmentStore: me.getAssignmentStoreClone(),
                resourceStore: me.getResourceStoreClone(),
                border: false,
                margin: 0,
                listeners: {
                    // we need this to draw selection properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: {
                        fn: function(el) {
                            me.task && el.loadTaskAssignments(me.task.getId());
                        },
                        single: true
                    }
                }
            }, me.assignmentGridConfig));
            if (!me.assignmentGrid.title) {
                me.assignmentGrid.title = me.L('resourcesText');
            }
            items.push(me.assignmentGrid);
        }
        // if advanced form required
        if (me.showAdvancedForm) {
            me.advancedFormConfig = me.advancedFormConfig || {};
            // create TaskForm instance for the "Advanced" tab form
            me.advancedForm = Ext.create(me.advancedFormClass, Ext.applyIf(me.advancedFormConfig, {
                showRollup: me.showRollup,
                showReadOnly: me.showReadOnly,
                border: false,
                task: me.task,
                taskStore: me.taskStore
            }));
            if (!me.advancedForm.title) {
                me.advancedForm.title = me.L('advancedText');
            }
            items.push(me.advancedForm);
        }
        // create notes panel
        if (me.showNotes) {
            // create notes HtmlEditor instance
            me.notesEditor = Ext.create('Ext.form.field.HtmlEditor', Ext.apply({
                listeners: {
                    // we need this to draw content of HtmlEditor properly on very first activation of tab
                    // to gracefully process deferredRender = true
                    afterrender: function(el) {
                        me.task && me.notesEditor.setValue(me.task.getNote());
                    }
                },
                readOnly: me.task && !me.task.isEditable(me.task.noteField),
                isDataChanged: function() {
                    return this.isDirty();
                }
            }, me.notesConfig));
            // we have to wrap it to panel since it'll be a tab in TabPanel
            // (to avoid some render bugs)
            me.notesPanel = Ext.create('Ext.Container', {
                border: false,
                margin: 0,
                layout: 'fit',
                items: me.notesEditor
            });
            if (!me.notesPanel.title) {
                me.notesPanel.title = me.L('notesText');
            }
            items.push(me.notesPanel);
        }
        return items;
    },
    onDependencyGridStoreChange: function(store) {
        var me = this,
            dependencyGrid = me.dependencyGrid;
        dependencyGrid.suspendDependencyStoreRefresh();
        // On any change apply grid store changes to the dependency store copy
        Gnt.util.Data.applyCloneChanges(dependencyGrid.store, me.getDependencyStoreClone());
        dependencyGrid.resumeDependencyStoreRefresh();
    },
    onDependencyGridStoreAdd: function(store, records) {
        this.onDependencyGridStoreChange(store);
    },
    onDependencyGridStoreRemove: function(store, records) {
        this.onDependencyGridStoreChange(store);
    },
    onDependencyGridStoreUpdate: function(store, record, operation, modifiedFields) {
        if (operation != Ext.data.Model.COMMIT) {
            this.onDependencyGridStoreChange(store);
        }
    },
    /**
     * @private
     * Dependency grid shows only records related to the shown task.
     * At the same time we have cloned dependency store which has all the dependency copies on board.
     * Purpose of this method is to setup listeners that apply changes made in the grid store
     * to the cloned dependency store.
     */
    bindDependencyGrid: function() {
        var me = this,
            clonedDependencyStore = me.getDependencyStoreClone(),
            grid = me.dependencyGrid;
        // dependency grid store have to use cloned task store
        grid.store.taskStore = me.getTaskStoreClone();
        if (clonedDependencyStore) {
            me.mon(grid.store, {
                // add the same records to the dependency store clone as well
                'add': me.onDependencyGridStoreAdd,
                'update': me.onDependencyGridStoreUpdate,
                'remove': me.onDependencyGridStoreRemove,
                scope: me
            });
            me.dependencyGridBound = true;
        }
    },
    onAssignmentGridAssignmentStoreChange: function(store) {
        // On any change apply grid store changes to the assignment store copy
        this.assignmentGrid.saveTaskAssignments();
    },
    onAssignmentGridAssignmentStoreAdd: function(store, records) {
        this.onAssignmentGridAssignmentStoreChange(store);
    },
    onAssignmentGridAssignmentStoreRemove: function(store, records) {
        this.onAssignmentGridAssignmentStoreChange(store);
    },
    onAssignmentGridAssignmentStoreUpdate: function(store, record, operation, modifiedFields) {
        if (operation != Ext.data.Model.COMMIT) {
            this.onAssignmentGridAssignmentStoreChange(store);
        }
    },
    onAssignmentGridResourceStoreChange: function(store) {
        // On any change apply grid store changes to the resource store copy
        this.assignmentGrid.saveResources();
    },
    onAssignmentGridResourceStoreAdd: function(store, records) {
        this.onAssignmentGridResourceStoreChange(store);
    },
    onAssignmentGridResourceStoreRemove: function(store, records) {
        this.onAssignmentGridResourceStoreChange(store);
    },
    onAssignmentGridResourceStoreUpdate: function(store, record, operation, modifiedFields) {
        if (operation != Ext.data.Model.COMMIT) {
            this.onAssignmentGridResourceStoreChange(store);
        }
    },
    bindAssignmentGrid: function() {
        var me = this,
            clonedAssignmentStore = me.getAssignmentStoreClone(),
            clonedResourceStore = me.getResourceStoreClone(),
            grid = me.assignmentGrid;
        if (clonedAssignmentStore && clonedResourceStore) {
            me.mon(grid.store, {
                'add': me.onAssignmentGridAssignmentStoreAdd,
                'update': me.onAssignmentGridAssignmentStoreUpdate,
                'remove': me.onAssignmentGridAssignmentStoreRemove,
                scope: me
            });
            me.mon(grid.resourceDupStore, {
                'add': me.onAssignmentGridResourceStoreAdd,
                'update': me.onAssignmentGridResourceStoreUpdate,
                'remove': me.onAssignmentGridResourceStoreRemove,
                scope: me
            });
            me.assignmentGridBound = true;
        }
    },
    /**
     * Loads task data into task editor.
     * @param {Gnt.model.Task} task Task to load to editor.
     */
    loadTask: function(task) {
        if (!task)  {
            return;
        }
        
        this.task = task;
        var me = this,
            dependencyGrid = me.dependencyGrid,
            assignmentGrid = me.assignmentGrid,
            readOnly = task.isReadOnly();
        me.callParent(arguments);
        var taskBuffer = me.taskBuffer;
        if (dependencyGrid) {
            // TODO: review this
            if (!me.dependencyGridBound)  {
                me.bindDependencyGrid();
            }
            
            dependencyGrid.setTask(taskBuffer);
            // we always load records into the grid event when tab is not visible
            // since we use its ability to load task dependencies to fill our dependency store clone with records
            dependencyGrid.loadDependencies(taskBuffer);
            dependencyGrid.tab.setVisible(me.allowParentTaskDependencies || task.isLeaf());
        }
        if (assignmentGrid) {
            if (!me.assignmentGridBound)  {
                me.bindAssignmentGrid();
            }
            
            assignmentGrid.setAssignmentStore(me.getAssignmentStoreClone());
            assignmentGrid.setResourceStore(me.getResourceStoreClone());
            assignmentGrid.loadResources(true);
            // load task assignments to grid
            assignmentGrid.loadTaskAssignments(task.getId() || task.getPhantomId());
            assignmentGrid.task = taskBuffer;
        }
        me.loadTaskToForms(task, taskBuffer);
        if (me.notesEditor) {
            me.notesEditor.setValue(task.getNote());
        }
        me.setReadOnly(readOnly);
        me.fireEvent('loadtask', me, task);
    },
    loadTaskToForms: function(task, taskBuffer) {
        var me = this,
            forms = me.query('form');
        for (var i = 0; i < forms.length; i++) {
            /**
             * @preventable
             * @event beforeloadtasktoform
             * Fires before a task gets loaded into a form laying on the task editor.
             *
             * By default the task editor tries to load the task into all the contained forms. Returning `false` from this event listener
             * for a specific form will prevent the form loading:
             *
             * ```javascript
             * var editor = new Gnt.widget.TaskEditor({
             *     items : [
             *         {
             *             xtype  : 'form',
             *             itemId : custom-form',
             *             title  : 'Custom fields',
             *             items  : [
             *                 {
             *                     xtype      : 'textfield',
             *                     name       : 'foo',
             *                     fieldLabel : 'Some field'
             *                 }
             *             ]
             *         }
             *     ],
             *     listeners : {
             *         'beforeloadtasktoform' : function (taskEditor, task, form) {
             *             // we don't want the custom form to be loaded automatically
             *             return form.getItemId() !== 'custom-form';
             *         }
             *     }
             * });
             * ```
             *
             * @param {Gnt.widget.taskeditor.TaskEditor} taskEditor The task editor.
             * @param {Gnt.model.Task} task Task being loaded.
             * @param {Ext.form.Panel} form Form about to be loaded with the task.
             */
            if (me.fireEvent('beforeloadtasktoform', me, task, forms[i]) !== false) {
                me.loadTaskToForm(task, forms[i], taskBuffer);
            }
        }
    },
    loadTaskToForm: function(task, form, taskBuffer) {
        if (form.isTaskEditorForm) {
            form.setSuppressTaskUpdate(true);
            form.getForm().reset();
            form.loadRecord(task, taskBuffer);
            form.setSuppressTaskUpdate(false);
        } else {
            form.getForm().reset();
            form.loadRecord(task);
        }
    },
    updateReadOnly: function() {
        var me = this,
            task = me.taskBuffer,
            widgetReadOnly = me.getReadOnly(),
            readOnly = widgetReadOnly || task.isReadOnly();
        if (me.taskForm) {
            // we repeat the editor readOnly state on the taskForm
            if (widgetReadOnly != me.taskForm.getReadOnly()) {
                me.taskForm.setReadOnly(widgetReadOnly);
            } else {
                me.taskForm.updateReadOnly();
            }
        }
        if (me.assignmentGrid) {
            me.assignmentGrid.setReadOnly(readOnly);
            me.assignmentGrid.down('toolbar').setVisible(!readOnly);
        }
        if (me.dependencyGrid) {
            me.dependencyGrid.setReadOnly(readOnly);
        }
        if (me.notesEditor) {
            me.notesEditor.setReadOnly(readOnly || !task.isEditable(task.noteField));
        }
        if (me.advancedForm) {
            // we repeat the editor readOnly state on the advancedForm
            if (widgetReadOnly != me.advancedForm.getReadOnly()) {
                me.advancedForm.setReadOnly(widgetReadOnly);
            } else {
                me.advancedForm.updateReadOnly();
            }
        }
    },
    doValidate: function(invalidComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.taskForm && !this.taskForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.taskForm), this.taskForm);
        }
        if (this.dependencyGrid && !this.dependencyGrid.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.dependencyGrid), this.dependencyGrid);
        }
        if (this.assignmentGrid && !this.assignmentGrid.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.assignmentGrid), this.assignmentGrid);
        }
        if (this.advancedForm && !this.advancedForm.isValid()) {
            result = false;
            invalidComponentsAccFn && invalidComponentsAccFn(this.getTabByComponent(this.advancedForm), this.advancedForm);
        }
        return result;
    },
    doUpdateTask: function() {
        var me = this,
            task = me.task;
        // push dependency store changes from copy to real store
        Gnt.util.Data.applyCloneChanges(me.getDependencyStoreClone(), me.getDependencyStore());
        var resourceStoreClone = me.getResourceStoreClone();
        Gnt.util.Data.applyCloneChanges(resourceStoreClone, me.getResourceStore());
        var resourceIdField = me.getAssignmentStore().model.prototype.resourceIdField;
        var assignmentChanges = Gnt.util.Data.applyCloneChanges(me.getAssignmentStoreClone(), me.getAssignmentStore(), function(data, assignment) {
                // get assigned resource
                var resource = resourceStoreClone.getById(assignment.getResourceId());
                // and its original record
                if (resource && resource.originalRecord) {
                    var existingResource = resource.originalRecord;
                    // now let's use real resource ID for saving
                    data[resourceIdField] = existingResource.getId() || existingResource.internalId;
                }
            });
        task.beginEdit();
        task.set(me.getTaskUpdateData(task, me.taskBuffer));
        // if assignments are changed need to force rescheduling to adjust to new calendars combination
        if (assignmentChanges.removed.length || assignmentChanges.modified.length) {
            task.markForRescheduling();
        }
        me.notesEditor && me.task.set(me.task.noteField, me.notesEditor.getValue());
        task.endEdit();
    },
    isDataChanged: function(changedComponentsAccFn) {
        var result = this.callParent(arguments);
        if (this.taskForm && this.taskForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.taskForm));
        }
        var dependencyStoreCopy = this.getDependencyStoreClone();
        if (this.dependencyGrid && dependencyStoreCopy && (dependencyStoreCopy.getModifiedRecords().length || dependencyStoreCopy.getRemovedRecords().length)) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.dependencyGrid));
        }
        if (this.assignmentGrid && this.assignmentGrid.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.assignmentGrid));
        }
        if (this.advancedForm && this.advancedForm.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.advancedForm));
        }
        if (this.notesEditor && this.notesEditor.isDataChanged()) {
            result = true;
            changedComponentsAccFn && changedComponentsAccFn(this.getTabByComponent(this.notesEditor));
        }
        return result;
    }
});

/**

@class Gnt.plugin.taskeditor.TaskEditor
@extends Gnt.plugin.taskeditor.BaseEditor

{@img gantt/images/taskeditor-general.png}

A plugin (ptype = 'gantt_taskeditor') which shows a {@link Gnt.widget.taskeditor.TaskEditor} in a window when a user double-clicks a task bar in the gantt chart.

You can enable this plugin in your Gantt chart like this:

    var gantt = Ext.create('Gnt.panel.Gantt', {
        ...
        plugins : Ext.create("Gnt.plugin.TaskEditor", {
            // window title
            title : 'Task Editor'
        }),
        ...
    })


#Plugin customization
Essentially this widget extends Ext.window.Window so any regular window configs can be used for it.
Also it supports a lot of configs provided by the {@link Gnt.widget.taskeditor.TaskEditor} class.
So if you want to customize the task editor child components (task form, resources grid etc.) you can read
the {@link Gnt.widget.taskeditor.TaskEditor} guide and apply corresponding configs to the plugin.

Another way to customize the task editor panel is {@link #panelConfig} config. With it you can
customize any config of the task editor panel, even the ones not translated by this plugin
(like `title`, `width`, `height` etc). For example:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        title       : 'I am window title',
        // some window elements
        items       : [...],
        panelConfig : {
            title   : 'I am panel title'
            // append some tabs to task editor panel
            items   : [...]
        }
    });

* **Note:** Please see {@link Gnt.widget.taskeditor.TaskEditor} class for details on how to customize the components of the tabs.

#Buttons customization

By default the window has two buttons `Ok` and `Cancel` to apply and rollback changes respectively.
If you want to just rename them you can use {@link #l10n} config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        l10n : {
            okText      : 'Apply changes',
            cancelText  : 'Reject changes'
        }
    });

And if you need to implement custom buttons you can easily do it using `buttons` config. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : [
            {
                text    : 'Show some alert',
                handler : function() {
                    alert('Some alert');
                }
            }
        ]
    });

And finally if you don't want any buttons at all you can overwrite `buttons` config with an empty array. Like this:

    var plugin = Ext.create("Gnt.plugin.TaskEditor", {
        buttons : []
    });


*/
Ext.define('Gnt.plugin.taskeditor.TaskEditor', {
    extend: 'Gnt.plugin.taskeditor.BaseEditor',
    alternateClassName: [
        'Gnt.plugin.TaskEditor'
    ],
    requires: [
        'Gnt.widget.taskeditor.TaskEditor'
    ],
    alias: 'plugin.gantt_taskeditor',
    // ptype isn't filled automatically, because we do not extend AbstractPlugin
    ptype: 'gantt_taskeditor',
    /**
    * @cfg {Object} taskEditorCls Class for the {@link Gnt.widget.taskeditor.TaskEditor} instance.
    */
    taskEditorCls: 'Gnt.widget.taskeditor.TaskEditor',
    height: (Ext.theme && Ext.theme.name.match('Graphite|Material') ? 550 : 390),
    width: (Ext.theme && Ext.theme.name.match('Graphite|Material') ? 800 : 600),
    /**
     * @cfg {String} taskFormClass Class instance of which will represent form in the `General` tab.
     *
     * This option supposed to be used to implement custom form in the `General` tab content.
     */
    /**
     * @cfg {String} advancedFormClass Class instance of which will represent form in the `Advanced` tab.
     *
     * This option supposed to be used to implement custom form in the `Advanced` tab content.
     */
    /**
     * @cfg {Boolean} showAssignmentGrid `true` to display `Resources` tab.
     */
    /**
     * @cfg {Boolean} showDependencyGrid `true` to display `Predecessors` tab.
     */
    /**
     * @cfg {Boolean} allowParentTaskDependencies `false` to hide a `Predecessors` tab for parent tasks
     * (requires {@link #showDependencyGrid} to be `false` as well) and also exclude parent tasks from the list
     * of possible predecessors. Normally this config is read from the {@link Gnt.panel.Gantt#allowParentTaskDependencies}. Defaults to `true`.
     */
    /**
     * @cfg {Boolean} showNotes `true` to display `Notes` tab.
     */
    /**
     * @cfg {Boolean} showAdvancedForm `true` to display `Advanced` tab.
     */
    /**
     * @cfg {Object} taskFormConfig Configuration of task form placed at `General` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     */
    /**
     * @cfg {String} dependencyGridClass Class representing the grid panel in the `Predecessor` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.DependencyGrid} class.
     */
    /**
     * @cfg {Object} dependencyGridConfig Configuration of grid placed at `Predecessors` tab.
     * For possible options take a look at {@link Gnt.widget.DependencyGrid}.
     *
     * **Note:** This grid may not be created if {@link #showDependencyGrid} set to `false`.
     */
    /**
     * @cfg {String} assignmentGridClass Class representing the grid panel in the `Resources` tab.
     *
     * Override this to provide your own implementation subclassing the {@link Gnt.widget.AssignmentEditGrid} class.
     */
    /**
     * @cfg {Object} assignmentGridConfig Configuration of grid placed at `Resources` tab.
     * For possible options take a look at {@link Gnt.widget.AssignmentEditGrid}.
     *
     * **Note:** This grid may not be created if {@link #showAssignmentGrid} set to `false`
     * or {@link #assignmentStore} or {@link #resourceStore} is not specified.
     */
    /**
     * @cfg {Object} advancedFormConfig Configuration of task form placed at `Advanced` tab.
     * For possible options take a look at {@link Gnt.widget.TaskForm}.
     *
     * **Note:** This form may not be created if {@link #showAdvancedForm} set to `false`.
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title               : 'Task Information',
            - alertCaption        : 'Information',
            - alertText           : 'Please correct marked errors to save changes',
            - okText              : 'Ok',
            - cancelText          : 'Cancel',
            - generalText         : 'General',
            - resourcesText       : 'Resources',
            - dependencyText      : 'Predecessors',
            - addDependencyText   : 'Add new',
            - dropDependencyText  : 'Remove',
            - notesText           : 'Notes',
            - advancedText        : 'Advanced',
            - wbsCodeText         : 'WBS code',
            - addAssignmentText   : 'Add new',
            - dropAssignmentText  : 'Remove'
     */
    taskEditorConfigs: 'l10n,task,taskStore,assignmentStore,resourceStore,generalText,resourcesText,dependencyText,addDependencyText,' + 'dropDependencyText,notesText,advancedText,wbsCodeText,addAssignmentText,dropAssignmentText,showAssignmentGrid,showDependencyGrid,' + 'allowParentTaskDependencies,showNotes,showStyle,showAdvancedForm,taskFormClass,advancedFormClass,taskFormConfig,dependencyGridConfig,' + 'assignmentGridConfig,advancedFormConfig,styleFormConfig,dependencyGridClass,assignmentGridClass',
    constructor: function(config) {
        this.callParent(arguments);
        // filter out project records
        this.addFilter(function(task) {
            return task && !task.isProject;
        });
    },
    init: function(cmp) {
        this.callParent(arguments);
        // decorate the component with a reference to the plugin
        cmp.taskEditor = this;
    }
});

/**
 * @class Gnt.selection.SpreadsheetModel
 * @extends Ext.grid.selection.SpreadsheetModel
 *
 * Selection model used by default for Gantt panel. Provides {@link Gnt.column.WBS} column as a numberer column of spreadsheet selection.
 */
Ext.define('Gnt.selection.SpreadsheetModel', {
    extend: 'Ext.grid.selection.SpreadsheetModel',
    requires: [
        'Gnt.patches.CellContext'
    ],
    uses: [
        'Gnt.column.WBS'
    ],
    alias: 'selection.gantt_spreadsheet',
    /**
     * @cfg {Object} wbsColumnConfig The optional configuration for WBS column that
     * can override or add to the default configuration.
     */
    wbsColumnConfig: null,
    privates: {
        getNumbererColumnConfig: function() {
            var me = this;
            return Ext.apply({
                xtype: 'wbscolumn',
                width: me.rowNumbererHeaderWidth,
                editRenderer: '&#160;',
                tdCls: me.rowNumbererTdCls,
                cls: me.rowNumbererHeaderCls,
                // disabling all interactions
                sortable: false,
                //resizable  : false,
                draggable: false,
                hideable: false,
                menuDisabled: true,
                // to remove possibility to unlock column
                lockable: false,
                locked: true,
                // to exclude from export
                ignoreExport: true
            }, me.wbsColumnConfig);
        }
    }
});

/**
 @class Gnt.template.CalendarDateInfo
 @extends Ext.XTemplate

 Template class showing the legend for the calendar widget
 */
Ext.define("Gnt.template.CalendarDateInfo", {
    extend: 'Ext.XTemplate',
    workingHoursText: null,
    nonWorkingText: null,
    basedOnText: null,
    overrideText: null,
    inCalendarText: null,
    dayInCalendarText: null,
    markup: '<div class="gnt-calendar-overridedate">' + '<tpl if="isWorkingDay">__WORKINGHOURS__ {date}:<tpl else>{date} __NONWORKING__</tpl>' + '</div>' + '<ul class="gnt-calendar-availabilities">' + '<tpl for="availability">' + '<li>{.}</li>' + '</tpl>' + '</ul>' + '<span class="gnt-calendar-overridesource"> __BASEDON__: ' + '<tpl if="override">__OVERRIDE__ "{name:htmlEncode}" __INCALENDAR__ "{calendarName:htmlEncode}"<tpl else>__DAYINCALENDAR__ "{calendarName:htmlEncode}"</tpl>' + '</span>',
    constructor: function(config) {
        Ext.apply(this, config);
        this.markup = this.markup.replace('__WORKINGHOURS__', this.workingHoursText).replace('__NONWORKING__', this.nonWorkingText).replace('__BASEDON__', this.basedOnText).replace('__OVERRIDE__', this.overrideText).replace('__INCALENDAR__', this.inCalendarText).replace('__DAYINCALENDAR__', this.dayInCalendarText);
        this.callParent([
            this.markup
        ]);
    }
});

/**
 @class Gnt.template.CalendarLegend
 @extends Ext.Template

 Template class showing the legend for the calendar widget
 */
Ext.define("Gnt.template.CalendarLegend", {
    extend: 'Ext.Template',
    disableFormats: true,
    markup: '<ul class="gnt-calendar-legend">' + '<li class="gnt-calendar-legend-item">' + '<div class="gnt-calendar-legend-itemstyle {workingDayCls}"></div>' + '<span class="gnt-calendar-legend-itemname">{workingDayText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li>' + '<div class="gnt-calendar-legend-itemstyle {nonWorkingDayCls}"></div>' + '<span class="gnt-calendar-legend-itemname">{weekendsText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li class="gnt-calendar-legend-override">' + '<div class="gnt-calendar-legend-itemstyle {overriddenDayCls}">31</div>' + '<span class="gnt-calendar-legend-itemname">{overriddenDayText}</span>' + '<div style="clear: both"></div>' + '</li>' + '<li class="gnt-calendar-legend-override">' + '<div class="gnt-calendar-legend-itemstyle {overriddenWeekDayCls}">31</div>' + '<span class="gnt-calendar-legend-itemname">{overriddenWeekText}</span>' + '<div style="clear: both"></div>' + '</li>' + '</ul>',
    constructor: function() {
        this.callParent([
            this.markup
        ]);
    }
});

/**

@class Gnt.widget.Calendar
@extends Ext.picker.Date

{@img gantt/images/widget-calendar.png}

This a very simple subclass of the {@link Ext.picker.Date} which will show holidays and weekends from the provided calendar.
Any non-working time will be shown as disabled dates.

*/
Ext.define('Gnt.widget.Calendar', {
    extend: 'Ext.picker.Date',
    alias: 'widget.ganttcalendar',
    requires: [
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read the holidays from
     */
    calendar: null,
    /**
     * @cfg {Date} startDate The start date of the range to show holidays for.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate The end date of the range to show holidays for.
     */
    endDate: null,
    initComponent: function() {
        if (!this.calendar) {
            Ext.Error.raise('Required attribute "calendar" missing during initialization of `Gnt.widget.Calendar`');
        }
        if (!this.startDate) {
            Ext.Error.raise('Required attribute "startDate" missing during initialization of `Gnt.widget.Calendar`');
        }
        if (!this.endDate) {
            this.endDate = Sch.util.Date.add(this.startDate, Sch.util.Date.MONTH, 1);
        }
        this.setCalendar(this.calendar);
        this.minDate = this.value = this.startDate;
        this.callParent(arguments);
        // this method requires "this.format" presense which, starting from 4.2.1 is initialized in the parent "initComponent"
        this.injectDates();
    },
    injectDates: function() {
        var me = this;
        var disabledDates = me.disabledDates = [];
        Ext.Array.each(me.calendar.getHolidaysRanges(me.startDate, me.endDate), function(range) {
            range.forEachDate(function(date) {
                disabledDates.push(Ext.Date.format(date, me.format));
            });
        });
        me.setDisabledDates(disabledDates);
    },
    /**
     * Sets the calendar for this calendar picker
     *
     * @param {Gnt.data.Calendar} calendar The calendar
     */
    setCalendar: function(calendar) {
        var listeners = {
                update: this.injectDates,
                remove: this.injectDates,
                add: this.injectDates,
                load: this.injectDates,
                clear: this.injectDates,
                scope: this
            };
        if (this.calendar) {
            this.mun(calendar, listeners);
        }
        this.calendar = calendar;
        if (calendar) {
            this.mon(calendar, listeners);
        }
    }
});

Ext.define('Gnt.widget.calendar.AvailabilityGrid', {
    extend: 'Ext.grid.Panel',
    requires: [
        'Ext.Button',
        'Ext.data.Store',
        'Ext.grid.column.Date',
        'Ext.grid.plugin.CellEditing',
        'Ext.window.MessageBox'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendaravailabilitygrid',
    // input
    calendarDay: null,
    minHeight: 160,
    addButton: null,
    removeButton: null,
    maxIntervalsNum: 5,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText         : 'Start',
            - endText           : 'End',
            - addText           : 'Add',
            - removeText        : 'Remove',
            - error             : 'Error'
     */
    initComponent: function() {
        // in ext 5 tbar is null, so apply/applyif wouldn't work
        if (!this.tbar) {
            this.tbar = this.buildToolbar();
        }
        Ext.applyIf(this, {
            store: new Ext.data.Store({
                fields: [
                    'startTime',
                    'endTime'
                ],
                autoDestroy: true,
                data: this.calendarDay.getAvailability()
            }),
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2
                })
            ],
            columns: [
                {
                    xtype: 'datecolumn',
                    header: this.L('startText'),
                    format: 'g:i a',
                    dataIndex: 'startTime',
                    flex: 1,
                    editor: {
                        xtype: 'timefield',
                        allowBlank: false,
                        initDate: '31/12/1899'
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('endText'),
                    format: 'g:i a',
                    dataIndex: 'endTime',
                    flex: 1,
                    editor: {
                        xtype: 'timefield',
                        allowBlank: false,
                        initDate: '31/12/1899'
                    }
                }
            ],
            listeners: {
                selectionchange: this.onAvailabilityGridSelectionChange,
                scope: this
            }
        });
        this.callParent(arguments);
    },
    buildToolbar: function() {
        this.addButton = new Ext.Button({
            text: this.L('addText'),
            iconCls: 'x-fa fa-plus',
            handler: this.addAvailability,
            scope: this
        });
        this.removeButton = new Ext.Button({
            text: this.L('removeText'),
            iconCls: 'x-fa fa-trash',
            handler: this.removeAvailability,
            scope: this,
            disabled: true
        });
        return {
            padding: '0 0 5 0',
            items: [
                this.addButton,
                this.removeButton
            ]
        };
    },
    onAvailabilityGridSelectionChange: function(grid, selection) {
        this.removeButton.setDisabled(!selection.length);
    },
    setAvailability: function(availability) {
        this.store.loadData(availability);
        this.addButton.setDisabled(this.store.getCount() >= this.maxIntervalsNum);
    },
    addAvailability: function() {
        var store = this.getStore(),
            count = store.count();
        if (count >= this.maxIntervalsNum) {
            return;
        }
        store.add({
            startTime: new Date(0, 0, 0, 12, 0),
            endTime: new Date(0, 0, 0, 13, 0)
        });
        if (count + 1 >= this.maxIntervalsNum && this.addButton) {
            this.addButton.disable();
        }
    },
    removeAvailability: function() {
        var store = this.getStore(),
            count = store.getCount(),
            selection = this.getSelection();
        if (!selection.length)  {
            return;
        }
        
        store.remove(selection[0]);
        if (count < this.maxIntervalsNum && this.addButton) {
            this.addButton.enable();
        }
    },
    // output
    isValid: function(noMessage) {
        try {
            this.calendarDay.verifyAvailability(this.getIntervals());
        } catch (ex) {
            if (!noMessage) {
                Ext.MessageBox.show({
                    title: this.L('error'),
                    msg: ex,
                    modal: true,
                    icon: Ext.MessageBox.ERROR,
                    buttons: Ext.MessageBox.OK
                });
            }
            return false;
        }
        return true;
    },
    extractTimeFromDate: function(date) {
        return new Date(0, 0, 0, date.getHours(), date.getMinutes(), date.getSeconds());
    },
    // output
    getIntervals: function() {
        var intervals = [];
        var me = this;
        this.getStore().each(function(item) {
            var endTime = me.extractTimeFromDate(item.get('endTime'));
            // 12AM as the end time means 24:00
            if (endTime - new Date(0, 0, 0, 0, 0, 0) === 0)  {
                endTime = new Date(0, 0, 1, 0, 0);
            }
            
            intervals.push({
                startTime: me.extractTimeFromDate(item.get('startTime')),
                endTime: endTime
            });
        });
        return intervals;
    }
});

Ext.define('Gnt.widget.calendar.DayEditor', {
    extend: 'Gnt.widget.calendar.AvailabilityGrid',
    requires: [
        'Ext.grid.plugin.CellEditing',
        'Gnt.data.Calendar',
        'Sch.util.Date'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendardayeditor',
    height: 160,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - startText           : 'Start',
            - endText             : 'End',
            - workingTimeText     : 'Working time',
            - nonworkingTimeText  : 'Non-working time'
     */
    initComponent: function() {
        var isWorkingDay = this.calendarDay.getIsWorkingDay();
        this.dockedItems = this.dockedItems || [
            {
                xtype: 'radiogroup',
                dock: 'top',
                name: 'dayType',
                padding: "0 5px",
                margin: 0,
                items: [
                    {
                        boxLabel: this.L('workingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: true,
                        checked: isWorkingDay
                    },
                    {
                        boxLabel: this.L('nonworkingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: false,
                        checked: !isWorkingDay
                    }
                ],
                listeners: {
                    change: this.onDayTypeChanged,
                    scope: this
                }
            }
        ];
        this.on('afterrender', this.myApplyState, this);
        this.callParent(arguments);
    },
    getDayTypeRadioGroup: function() {
        return this.down('radiogroup[name="dayType"]');
    },
    myApplyState: function() {
        if (!this.isWorkingDay()) {
            this.viewSetDisabled(true);
            this.addButton.disable();
        }
    },
    // we cannot use view.disable() because it blocks also radio buttons to switch working/non working day modes
    // http://www.sencha.com/forum/showthread.php?291799
    viewSetDisabled: function(disabled) {
        if (disabled) {
            this.getView().getEl().mask();
            this.getHeaderContainer().getEl().mask();
        } else {
            this.getView().getEl().unmask();
            this.getHeaderContainer().getEl().unmask();
        }
    },
    onDayTypeChanged: function(sender) {
        var value = sender.getValue();
        if (Ext.isArray(value.IsWorkingDay))  {
            return;
        }
        
        this.viewSetDisabled(!value.IsWorkingDay);
        this.addButton.setDisabled(!value.IsWorkingDay || this.getStore().getCount() >= this.maxIntervalsNum);
    },
    isWorkingDay: function() {
        return this.getDayTypeRadioGroup().getValue().IsWorkingDay;
    },
    isValid: function() {
        if (this.isWorkingDay())  {
            return this.callParent();
        }
        
        return true;
    },
    getIntervals: function() {
        if (!this.isWorkingDay())  {
            return [];
        }
        
        return this.callParent();
    }
});

Ext.define('Gnt.widget.calendar.WeekEditor', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.grid.Panel',
        'Gnt.data.Calendar',
        'Sch.util.Date',
        'Gnt.widget.calendar.AvailabilityGrid'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarweekeditor',
    weekName: null,
    startDate: null,
    endDate: null,
    // the availability array for the week being edited
    weekAvailability: null,
    // the `weekAvailability` of the calendar
    calendarWeekAvailability: null,
    // the `defaultWeekAvailability` of the calendar
    defaultWeekAvailability: null,
    backupWeekAvailability: null,
    layout: 'anchor',
    defaults: {
        border: false,
        anchor: '100%'
    },
    calendarDayModel: null,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - defaultTimeText    : 'Default time',
            - workingTimeText    : 'Working time',
            - nonworkingTimeText : 'Non-working time',
            - error              : 'Error',
            - noOverrideError    : "Week override contains only 'default' days - can't save it"
     */
    currentDayIndex: null,
    _weekDaysGrid: null,
    _availabilityGrid: null,
    initComponent: function() {
        this.backupWeekAvailability = [];
        this.items = [
            {
                xtype: 'radiogroup',
                padding: "0 5px",
                name: 'dayType',
                items: [
                    {
                        boxLabel: this.L('defaultTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 0
                    },
                    {
                        boxLabel: this.L('workingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 1
                    },
                    {
                        boxLabel: this.L('nonworkingTimeText'),
                        name: 'IsWorkingDay',
                        inputValue: 2
                    }
                ],
                listeners: {
                    change: this.onDayTypeChanged,
                    scope: this
                }
            },
            {
                layout: {
                    type: 'hbox',
                    align: 'stretch'
                },
                padding: '0 0 5px 0',
                items: [
                    {
                        margin: '0 10px 0 5px',
                        flex: 1,
                        items: this.getWeekDaysGrid()
                    },
                    {
                        flex: 1,
                        margin: '0 5px 0 0',
                        items: this.getAvailabilityGrid()
                    }
                ]
            }
        ];
        this.callParent(arguments);
    },
    getWeekDaysGrid: function() {
        if (this._weekDaysGrid != null)  {
            return this._weekDaysGrid;
        }
        
        var DN = Ext.Date.dayNames;
        return this._weekDaysGrid = new Ext.grid.Panel({
            hideHeaders: true,
            minHeight: 160,
            columns: [
                {
                    dataIndex: 'name',
                    flex: 1
                }
            ],
            store: new Ext.data.Store({
                autoDestroy: true,
                fields: [
                    'id',
                    'name'
                ],
                idProperty: 'id',
                data: [
                    {
                        id: 1,
                        name: DN[1]
                    },
                    {
                        id: 2,
                        name: DN[2]
                    },
                    {
                        id: 3,
                        name: DN[3]
                    },
                    {
                        id: 4,
                        name: DN[4]
                    },
                    {
                        id: 5,
                        name: DN[5]
                    },
                    {
                        id: 6,
                        name: DN[6]
                    },
                    {
                        id: 0,
                        name: DN[0]
                    }
                ]
            }),
            listeners: {
                viewready: this.onWeekDaysListViewReady,
                selectionchange: this.onWeekDaysListSelectionChange,
                beforeselect: this.onWeekDaysListBeforeSelect,
                scope: this
            }
        });
    },
    getAvailabilityGrid: function() {
        if (!this._availabilityGrid) {
            this._availabilityGrid = new Gnt.widget.calendar.AvailabilityGrid({
                calendarDay: new this.calendarDayModel()
            });
        }
        return this._availabilityGrid;
    },
    getDayTypeRadioGroup: function() {
        if (!this.dayTypeRadioGroup)  {
            this.dayTypeRadioGroup = this.down('radiogroup[name="dayType"]');
        }
        
        return this.dayTypeRadioGroup;
    },
    getWeekAvailability: function() {
        return this.weekAvailability;
    },
    onWeekDaysListViewReady: function() {
        var weekDaysGrid = this.getWeekDaysGrid(),
            monday = weekDaysGrid.getStore().getAt(0);
        this.currentDayIndex = monday.getId();
        this.readFromData();
        weekDaysGrid.getSelectionModel().select(monday, false, true);
    },
    onWeekDaysListBeforeSelect: function() {
        if (!this.saveToData())  {
            return false;
        }
        
    },
    applyChanges: function(toWeekAvailability) {
        if (!this.saveToData())  {
            return false;
        }
        
        var weekAvailability = this.weekAvailability;
        var hasOverride = false;
        for (var i = 0; i < 7; i++) {
            var currentAvailability = weekAvailability[i];
            if (currentAvailability) {
                hasOverride = true;
                if (!toWeekAvailability[i])  {
                    toWeekAvailability[i] = currentAvailability;
                }
                
                toWeekAvailability[i].setIsWorkingDay(currentAvailability.getIsWorkingDay());
                toWeekAvailability[i].setAvailability(currentAvailability.getAvailability());
            } else {
                toWeekAvailability[i] = null;
            }
        }
        if (!hasOverride) {
            Ext.MessageBox.show({
                title: this.L('error'),
                msg: this.L('noOverrideError'),
                modal: true,
                icon: Ext.MessageBox.ERROR,
                buttons: Ext.MessageBox.OK
            });
            return false;
        }
        return true;
    },
    onWeekDaysListSelectionChange: function(view, records) {
        this.currentDayIndex = records[0].getId();
        this.readFromData();
    },
    // 0 - default, 1 - working , 2 - non-working
    getCurrentTypeOfWeekDay: function(index) {
        return this.weekAvailability[index] ? (this.weekAvailability[index].getIsWorkingDay() ? 1 : 2) : 0;
    },
    getCurrentWeekDay: function(index) {
        return this.weekAvailability[index] || this.calendarWeekAvailability[index] || this.defaultWeekAvailability[index];
    },
    saveToData: function() {
        var currentDayIndex = this.currentDayIndex;
        var type = this.getDayTypeRadioGroup().getValue().IsWorkingDay;
        var weekAvailability = this.weekAvailability;
        // default day - remove the element from `weekAvailability`
        if (type === 0) {
            weekAvailability[currentDayIndex] = null;
            return true;
        }
        var availabilityGrid = this.getAvailabilityGrid();
        // working day
        if (type == 1) {
            if (!availabilityGrid.isValid())  {
                return false;
            }
            
            if (!weekAvailability[currentDayIndex])  {
                weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
            }
            
            weekAvailability[currentDayIndex].setIsWorkingDay(true);
            weekAvailability[currentDayIndex].setAvailability(availabilityGrid.getIntervals());
            this.backupWeekAvailability[currentDayIndex] = null;
            return true;
        }
        // type == 2
        if (!weekAvailability[currentDayIndex])  {
            weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
        }
        
        weekAvailability[currentDayIndex].setIsWorkingDay(false);
        weekAvailability[currentDayIndex].setAvailability([]);
        return true;
    },
    copyDefaultWeekDay: function(index) {
        var copy = (this.calendarWeekAvailability[index] || this.defaultWeekAvailability[index]).copy();
        // copy should be a phantom
        copy.phantom = true;
        copy.beginEdit();
        copy.setType('WEEKDAYOVERRIDE');
        copy.setOverrideStartDate(this.startDate);
        copy.setOverrideEndDate(this.endDate);
        copy.setName(this.weekName);
        copy.endEdit();
        return copy;
    },
    readFromData: function(intervalsToRestore) {
        var day = this.getCurrentWeekDay(this.currentDayIndex);
        var type = this.getCurrentTypeOfWeekDay(this.currentDayIndex);
        var grid = this.getAvailabilityGrid();
        grid.setAvailability(intervalsToRestore || day.getAvailability());
        var group = this.getDayTypeRadioGroup();
        group.suspendEvents();
        group.setValue({
            IsWorkingDay: [
                type
            ]
        });
        group.resumeEvents();
        grid.setDisabled(type != 1);
    },
    onDayTypeChanged: function(sender, newValue, oldValue) {
        var value = sender.getValue();
        // ignore case when no radio buttons selected?
        // weird call with empty object as "newValue"
        if (value.IsWorkingDay == null || Ext.isArray(value.IsWorkingDay))  {
            return;
        }
        
        var weekAvailability = this.weekAvailability;
        var backupWeekAvailability = this.backupWeekAvailability;
        var currentDayIndex = this.currentDayIndex;
        var availabilityGrid = this.getAvailabilityGrid();
        var intervalsToRestore;
        if (oldValue.IsWorkingDay == 1)  {
            backupWeekAvailability[currentDayIndex] = availabilityGrid.getIntervals();
        }
        
        switch (value.IsWorkingDay) {
            case 0:
                weekAvailability[currentDayIndex] = null;
                break;
            case 1:
                if (!weekAvailability[currentDayIndex])  {
                    weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
                }
                ;
                intervalsToRestore = backupWeekAvailability[currentDayIndex];
                weekAvailability[currentDayIndex].setIsWorkingDay(true);
                break;
            case 2:
                if (!weekAvailability[currentDayIndex])  {
                    weekAvailability[currentDayIndex] = this.copyDefaultWeekDay(currentDayIndex);
                }
                ;
                weekAvailability[currentDayIndex].setAvailability([]);
                weekAvailability[currentDayIndex].setIsWorkingDay(false);
                break;
            default:
                throw "Unrecognized day type";
        }
        this.readFromData(intervalsToRestore);
    }
});

Ext.define('Gnt.widget.calendar.DatePicker', {
    extend: 'Gnt.widget.DatePickerWithDateHighlighting',
    alias: 'widget.gntdatepicker',
    getDateCls: function(date) {
        var cls = '';
        if (date.getMonth() !== this.getActive().getMonth()) {
            return;
        }
        var calendar = this.dayOverridesCalendar,
            calendarDay = calendar.getOwnCalendarDay(date);
        if (calendarDay) {
            cls += ' ' + this.overriddenDayCls;
            if (!calendar.isWorkingDay(date)) {
                cls += ' ' + this.nonWorkingDayCls;
            }
            cls += ' ' + this.getCalendarDayCls(calendar, date);
        } else {
            // this will be an internal week override model instance from the weekStore
            var week = null;
            this.weekOverridesStore.each(function(internalWeekModel) {
                var startDate = internalWeekModel.get('startDate'),
                    endDate = internalWeekModel.get('endDate');
                if (startDate != null && endDate != null && Ext.Date.between(date, startDate, endDate)) {
                    week = internalWeekModel;
                    return false;
                }
            });
            if (week) {
                cls += ' ' + this.overriddenWeekDayCls;
                var index = date.getDay(),
                    weekAvailability = week.get('weekAvailability');
                if (weekAvailability && weekAvailability[index] && !weekAvailability[index].getIsWorkingDay()) {
                    cls += ' ' + this.nonWorkingDayCls;
                }
            } else if (!calendar.isWorkingDay(date)) {
                cls += ' ' + this.nonWorkingDayCls;
            }
        }
        return cls || this.workingDayCls;
    }
});

/**

 @class Gnt.widget.calendar.Calendar
 @extends Ext.form.Panel
 @aside guide gantt_calendars

 {@img gantt/images/calendar.png}

 This widget can be used to edit the calendar content. As the input it should receive an instance of the {@link Gnt.data.Calendar} class.
 Once the editing is done and user is happy with the result the {@link #applyChanges} method should be called. It will apply
 all the changes user made in UI to the calendar.

 Note, this widget does not have the "Ok", "Apply changes" etc button intentionally, as you might want to combine it with your widgets.
 See {@link Gnt.widget.calendar.CalendarWindow} for this widget embedded in the Ext.window.Window instance.


 */
Ext.define('Gnt.widget.calendar.Calendar', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.XTemplate',
        'Ext.data.Store',
        'Ext.grid.Panel',
        'Ext.grid.plugin.CellEditing',
        'Ext.layout.container.HBox',
        'Ext.layout.container.Column',
        'Ext.layout.container.Fit',
        'Ext.layout.container.Anchor',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Text',
        'Ext.tab.Panel',
        'Sch.patches.BoundList',
        'Gnt.data.Calendar',
        'Gnt.model.Week',
        'Gnt.widget.calendar.DayEditor',
        'Gnt.widget.calendar.WeekEditor',
        'Gnt.widget.calendar.DatePicker',
        'Gnt.template.CalendarLegend',
        'Gnt.template.CalendarDateInfo'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendar',
    defaults: {
        border: false
    },
    /**
     * @cfg {String} workingDayCls class will be applied to all working days at legend block and datepicker
     */
    workingDayCls: 'gnt-datepicker-workingday',
    /**
     * @cfg {string} nonWorkingDayCls class will be applied to all non-working days at legend block and datepicker
     */
    nonWorkingDayCls: 'gnt-datepicker-nonworkingday',
    /**
     * @cfg {String} overriddenDayCls class will be applied to all overridden days at legend block and datepicker
     */
    overriddenDayCls: 'gnt-datepicker-overriddenday',
    /**
     * @cfg {String} overriddenWeekDayCls class will be applied to all overridden days inside overridden week at legend block and date picker
     */
    overriddenWeekDayCls: 'gnt-datepicker-overriddenweekday',
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar: null,
    calendarManager: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - dayOverrideNameHeaderText : 'Name',
     * - overrideName        : 'Name',
     * - startDate           : 'Start Date',
     * - endDate             : 'End Date',
     * - error               : 'Error',
     * - dateText            : 'Date',
     * - addText             : 'Add',
     * - editText            : 'Edit',
     * - removeText          : 'Remove',
     * - workingDayText      : 'Working day',
     * - weekendsText        : 'Weekends',
     * - overriddenDayText   : 'Overridden day',
     * - overriddenWeekText  : 'Overridden week',
     * - workingTimeText     : 'Working time',
     * - nonworkingTimeText  : 'Non-working time',
     * - dayOverridesText    : 'Day overrides',
     * - weekOverridesText   : 'Week overrides',
     * - okText              : 'OK',
     * - cancelText          : 'Cancel',
     * - parentCalendarText  : 'Parent calendar',
     * - noParentText        : 'No parent',
     * - selectParentText    : 'Select parent',
     * - newDayName          : '[Without name]',
     * - calendarNameText    : 'Calendar name',
     * - tplTexts            :
     *     - tplWorkingHours : 'Working hours for',
     *     - tplIsNonWorking : 'is non-working',
     *     - tplOverride     : 'override',
     *     - tplInCalendar   : 'in calendar',
     *     - tplDayInCalendar: 'standard day in calendar'
     * - overrideErrorText   : 'There is already an override for this day',
     * - overrideDateError   : 'There is already week override on this date: {0}',
     * - startAfterEndError  : 'Start date should be less than end date',
     * - weeksIntersectError : 'Week overrides should not intersect'
     */
    /**
     * @cfg {Object} dayGridConfig A custom config object to use when configuring the day overrides grid (Ext.grid.Panel instance).
     */
    dayGridConfig: null,
    /**
     * @cfg {Object} weekGridConfig A custom config object to use when configuring the week overrides grid (Ext.grid.Panel instance).
     */
    weekGridConfig: null,
    /**
     * @cfg {Object} datePickerConfig A custom config object to use when configuring the {@link Gnt.widget.calendar.DatePicker} instance.
     */
    datePickerConfig: null,
    /**
     * @cfg {Boolean} readOnly Set to true to disable editing
     */
    readOnly: false,
    /**
     * @property {Ext.grid.Panel} dayGrid Day overrides grid reference.
     */
    dayGrid: null,
    /**
     * @property {Ext.grid.Panel} weekGrid Week overrides grid reference.
     */
    weekGrid: null,
    /**
     * @property {Gnt.widget.calendar.DatePicker} datePicker Date picker reference.
     */
    datePicker: null,
    legendTpl: null,
    dateInfoTpl: null,
    dayOverridesCalendar: null,
    weekOverridesStore: null,
    // reference to a window with day override editor used only in tests for now
    currentDayOverrideEditor: null,
    calendarDayModel: null,
    scrollable: true,
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this;
        // compiles templates
        me.setupTemplates();
        var calendar = me.calendar;
        if (!calendar && me.calendarManager) {
            calendar = me.calendarManager.getProjectCalendar();
            if (!calendar) {
                var root = me.calendarManager.getRoot(),
                    calendarNode = root && root.firstChild;
                calendar = calendarNode && calendarNode.getCalendar();
            }
        }
        //  we need "calendarDayModel" to build days override grid
        if (!me.calendarDayModel && calendar) {
            me.calendarDayModel = calendar.getModel && calendar.getModel() || calendar.model;
        }
        // fills the panel "items"
        me.buildItems();
        me.bindListeners();
        me.callParent(arguments);
        me.projectCalendarCheckbox = me.down('#projectCalendarCheckbox');
        me.projectCalendarCheckbox.setVisible(me.calendarManager);
        me.setReadOnly(me.readOnly);
        // update the panel UI with active calendar data
        calendar && me.setCalendar(calendar);
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this.cmbParentCalendar.setDisabled(readOnly);
        this.down('#calendarName').setDisabled(readOnly);
        if (this.calendarManager && this.calendarManager.getProjectCalendar() !== this.calendar) {
            this.projectCalendarCheckbox.setDisabled(readOnly);
        }
        // disable/enable grids editing plugins and toolbar buttons
        this.setGridReadOnly(this.dayGrid, readOnly);
        this.setGridReadOnly(this.weekGrid, readOnly);
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    /**
     * Returns true if the widget is currently read only.
     * @return {Boolean} readOnly
     */
    isReadOnly: function() {
        return this.getReadOnly();
    },
    setGridReadOnly: function(grid, readOnly) {
        var editingPlugin = grid.getPlugin('editingPlugin');
        // disable/enable grid editing plugin if any
        editingPlugin && editingPlugin[readOnly ? 'disable' : 'enable']();
        // disable/enable toolbar buttons we're aware of
        grid.down('#btnAdd').setDisabled(readOnly);
        grid.down('#btnEdit').setDisabled(readOnly);
        grid.down('#btnRemove').setDisabled(readOnly);
    },
    bindListeners: function() {
        var me = this;
        me.on('calendarset', me.onCalendarSet);
        me.on('afterrender', me.onCalendarSet);
        me.dayGrid.on({
            selectionchange: me.onDayGridSelectionChange,
            validateedit: me.onDayGridValidateEdit,
            edit: me.onDayGridEdit,
            scope: me
        });
        me.dayGrid.store.on({
            update: me.refreshView,
            remove: me.refreshView,
            add: me.refreshView,
            scope: me
        });
        me.weekGrid.on({
            selectionchange: me.onWeekGridSelectionChange,
            validateedit: me.onWeekGridValidateEdit,
            edit: me.onWeekGridEdit,
            scope: me
        });
        me.weekGrid.store.on({
            update: me.refreshView,
            remove: me.refreshView,
            add: me.refreshView,
            scope: me
        });
        me.datePicker.on({
            select: me.onDateSelect,
            scope: me
        });
    },
    buildItems: function() {
        this.dateInfoPanel = new Ext.Component({
            cls: 'gnt-calendar-dateinfo',
            margin: '20 10',
            flex: 1,
            border: false
        });
        this.cmbParentCalendar = new Ext.form.field.ComboBox({
            name: 'cmb_parentCalendar',
            fieldLabel: this.L('parentCalendarText'),
            labelAlign: 'top',
            store: {
                autoDestroy: true,
                fields: [
                    'Id',
                    'Name'
                ]
            },
            listConfig: {
                htmlEncode: true
            },
            queryMode: 'local',
            displayField: 'Name',
            valueField: 'Id',
            anchor: '100%',
            editable: false,
            emptyText: this.L('selectParentText')
        });
        this.buildWeekGrid();
        this.buildDayGrid();
        this.buildDatePicker();
        this.items = [
            {
                xtype: 'container',
                layout: 'hbox',
                items: [
                    {
                        xtype: 'container',
                        flex: 1,
                        margin: '15 5 15 15',
                        layout: 'anchor',
                        items: [
                            {
                                xtype: 'fieldcontainer',
                                defaults: {
                                    width: '100%'
                                },
                                layout: 'vbox',
                                items: [
                                    {
                                        xtype: 'textfield',
                                        itemId: 'calendarName',
                                        labelAlign: 'top',
                                        fieldLabel: this.L('calendarNameText')
                                    },
                                    {
                                        xtype: 'checkbox',
                                        itemId: 'projectCalendarCheckbox',
                                        fieldLabel: this.L('isProjectCalendarText')
                                    },
                                    this.cmbParentCalendar
                                ]
                            },
                            {
                                xtype: 'component',
                                padding: '10 0 0 0',
                                renderTpl: this.legendTpl,
                                anchor: '100%',
                                renderData: {
                                    workingDayText: this.L('workingDayText'),
                                    weekendsText: this.L('weekendsText'),
                                    overriddenDayText: this.L('overriddenDayText'),
                                    overriddenWeekText: this.L('overriddenWeekText'),
                                    workingDayCls: this.workingDayCls,
                                    nonWorkingDayCls: this.nonWorkingDayCls,
                                    overriddenDayCls: this.overriddenDayCls,
                                    overriddenWeekDayCls: this.overriddenWeekDayCls
                                }
                            }
                        ]
                    },
                    this.datePicker,
                    this.dateInfoPanel
                ]
            },
            {
                xtype: 'tabpanel',
                minHeight: 200,
                flex: 1,
                items: [
                    this.dayGrid,
                    this.weekGrid
                ]
            }
        ];
    },
    buildDayGrid: function() {
        var calendarDayModel = this.calendarDayModel.prototype;
        // create day overrides grid
        this.dayGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L('dayOverridesText'),
            itemId: 'dayGrid',
            tbar: [
                {
                    text: this.L('addText'),
                    itemId: 'btnAdd',
                    action: 'add',
                    iconCls: 'x-fa fa-plus',
                    handler: this.addDay,
                    scope: this
                },
                {
                    text: this.L('editText'),
                    itemId: 'btnEdit',
                    action: 'edit',
                    iconCls: 'x-fa fa-edit',
                    handler: this.editDay,
                    scope: this
                },
                {
                    text: this.L('removeText'),
                    itemId: 'btnRemove',
                    action: 'remove',
                    iconCls: 'x-fa fa-trash',
                    handler: this.removeDay,
                    scope: this
                }
            ],
            store: new Gnt.data.Calendar(),
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2,
                    pluginId: 'editingPlugin'
                })
            ],
            columns: [
                {
                    header: this.L('dayOverrideNameHeaderText'),
                    dataIndex: calendarDayModel.nameField,
                    flex: 1,
                    renderer: Ext.htmlEncode,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('dateText'),
                    dataIndex: calendarDayModel.dateField,
                    width: 100,
                    format: this.L('format'),
                    editor: {
                        xtype: 'datefield',
                        format: this.L('format')
                    }
                }
            ]
        }, this.dayGridConfig || {}));
        this.dayOverridesCalendar = this.dayGrid.store;
    },
    updateGrids: function() {
        this.dayGrid && this.fillDaysStore();
        this.weekGrid && this.fillWeeksStore();
    },
    buildWeekGrid: function() {
        // create week overrides grid
        this.weekGrid = new Ext.grid.Panel(Ext.apply({
            title: this.L('weekOverridesText'),
            itemId: 'weekGrid',
            plugins: [
                new Ext.grid.plugin.CellEditing({
                    clicksToEdit: 2,
                    pluginId: 'editingPlugin'
                })
            ],
            store: new Ext.data.Store({
                autoDestroy: true,
                model: 'Gnt.model.Week'
            }),
            tbar: [
                {
                    text: this.L('addText'),
                    itemId: 'btnAdd',
                    action: 'add',
                    iconCls: 'x-fa fa-plus',
                    handler: this.addWeek,
                    scope: this
                },
                {
                    text: this.L('editText'),
                    itemId: 'btnEdit',
                    action: 'edit',
                    iconCls: 'x-fa fa-edit',
                    handler: this.editWeek,
                    scope: this
                },
                {
                    text: this.L('removeText'),
                    itemId: 'btnRemove',
                    action: 'remove',
                    iconCls: 'x-fa fa-trash',
                    handler: this.removeWeek,
                    scope: this
                }
            ],
            columns: [
                {
                    header: this.L('overrideName'),
                    dataIndex: 'name',
                    flex: 1,
                    renderer: Ext.htmlEncode,
                    editor: {
                        allowBlank: false
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('startDate'),
                    dataIndex: 'startDate',
                    width: 100,
                    format: this.L('format'),
                    editor: {
                        xtype: 'datefield',
                        format: this.L('format'),
                        allowBlank: false
                    }
                },
                {
                    xtype: 'datecolumn',
                    header: this.L('endDate'),
                    dataIndex: 'endDate',
                    width: 100,
                    format: this.L('format'),
                    editor: {
                        xtype: 'datefield',
                        format: this.L('format'),
                        allowBlank: false
                    }
                }
            ]
        }, this.weekGridConfig || {}));
        this.weekOverridesStore = this.weekGrid.store;
    },
    buildDatePicker: function() {
        this.datePicker = new Gnt.widget.calendar.DatePicker(Ext.apply({
            dayOverridesCalendar: this.dayGrid.store,
            weekOverridesStore: this.weekGrid.store,
            margin: '15 10 0 10',
            showToday: false
        }, this.datePickerConfig));
    },
    onCalendarSet: function() {
        // data is an array of objects and store is considered as containing a modified records
        this.weekOverridesStore.commitChanges();
    },
    setCalendar: function(calendar) {
        if (this.calendar) {
            this.mun(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            });
        }
        this.calendar = calendar;
        if (calendar) {
            this.mon(this.calendar, {
                load: this.onCalendarChange,
                add: this.onCalendarChange,
                remove: this.onCalendarChange,
                update: this.onCalendarChange,
                parentchange: this.onParentChange,
                scope: this
            });
        }
        this.onCalendarChange();
        this.fireEvent('calendarset', calendar);
    },
    onParentChange: function() {
        this.updateComboBox();
    },
    updateComboBox: function() {
        var me = this,
            calendars = [];
        // Collect records for the combobox dropdown list, all calendars except the one being edited
        if (me.calendarManager) {
            var root = me.calendarManager.getRoot();
            var activeNode = me.calendarManager.getNodeByCalendar(me.calendar);
            root.cascadeBy(function(item) {
                var calendar = item.getCalendar();
                if (item !== root && item !== activeNode && !activeNode.contains(item)) {
                    calendars.push({
                        Id: calendar.calendarId,
                        Name: item.getName() || calendar.calendarId
                    });
                }
            });
        } else {
            calendars = me.calendar.getParentableCalendars();
        }
        // fill the combobx store
        this.cmbParentCalendar.store.loadData([
            {
                Id: -1,
                Name: this.L('noParentText')
            }
        ].concat(calendars));
        var parent = this.calendar && this.calendar.parent,
            parentId = parent && parent.calendarId;
        this.cmbParentCalendar.setValue(parentId || -1);
    },
    onCalendarChange: function() {
        this.updateComboBox();
        if (this.calendarManager) {
            var isProjectCalendar = this.calendar === this.calendarManager.getProjectCalendar();
            this.projectCalendarCheckbox.setDisabled(isProjectCalendar);
            this.projectCalendarCheckbox.setValue(isProjectCalendar);
        }
        this.fillDaysStore();
        this.fillWeeksStore();
        this.refreshView();
        this.down('#calendarName').setValue(this.calendar.name);
    },
    setupTemplates: function() {
        var tplTexts = this.L('tplTexts');
        if (!(this.dateInfoTpl instanceof Ext.Template)) {
            this.dateInfoTpl = new Gnt.template.CalendarDateInfo({
                workingHoursText: tplTexts.tplWorkingHours,
                nonWorkingText: tplTexts.tplIsNonWorking,
                basedOnText: tplTexts.tplBasedOn,
                overrideText: tplTexts.tplOverride,
                inCalendarText: tplTexts.tplInCalendar,
                dayInCalendarText: tplTexts.tplDayInCalendar
            });
        }
        if (!(this.legendTpl instanceof Ext.Template)) {
            this.legendTpl = new Gnt.template.CalendarLegend();
        }
    },
    afterRender: function() {
        this.callParent(arguments);
        this.onDateSelect(this.datePicker, new Date());
    },
    fillDaysStore: function() {
        // only filter days with type "DAY" that has "Date" set
        var dataTemp = Gnt.util.Data.cloneModelSet(this.calendar, function(calendarDay) {
                return (calendarDay.getType() == 'DAY' && calendarDay.getDate());
            });
        this.dayOverridesCalendar.loadData(dataTemp);
    },
    copyCalendarDay: function(calendarDay) {
        var copy = calendarDay.copy(null);
        copy.__COPYOF__ = calendarDay.getId();
        return copy;
    },
    fillWeeksStore: function() {
        var me = this;
        var data = [];
        this.calendar.forEachNonStandardWeek(function(nonStandardWeek) {
            var week = Ext.apply({}, nonStandardWeek);
            week.weekAvailability = Ext.Array.map(week.weekAvailability, function(day) {
                return day && me.copyCalendarDay(day) || null;
            });
            week.mainDay = me.copyCalendarDay(week.mainDay);
            data.push(week);
        });
        this.weekOverridesStore.loadData(data);
    },
    addDay: function() {
        var date = this.datePicker.getValue();
        // do not allow duplicate day overrides
        if (this.dayOverridesCalendar.getOwnCalendarDay(date)) {
            this.alert({
                msg: this.L('overrideErrorText')
            });
            return;
        }
        var dayModel = this.calendar.model;
        var dayProto = dayModel.prototype;
        var newDay = {};
        newDay[dayProto.nameField] = this.L('newDayName');
        newDay[dayProto.typeField] = 'DAY';
        newDay[dayProto.dateField] = date;
        newDay = new dayModel(newDay);
        //this.dayOverridesCalendar.insert(0, newDay);
        this.dayGrid.getStore().insert(0, newDay);
        this.dayGrid.getSelectionModel().select([
            newDay
        ], false, false);
    },
    editDay: function() {
        var me = this,
            selection = this.dayGrid.getSelection(),
            day = selection[0];
        if (day) {
            var editor = this.currentDayOverrideEditor = new Gnt.widget.calendar.DayEditor({
                    addText: this.L('addText'),
                    removeText: this.L('removeText'),
                    workingTimeText: this.L('workingTimeText'),
                    nonworkingTimeText: this.L('nonworkingTimeText'),
                    calendarDay: day
                });
            var editorWindow = Ext.create('Ext.window.Window', {
                    title: this.L('dayOverridesText'),
                    modal: true,
                    width: 280,
                    height: 260,
                    layout: 'fit',
                    items: editor,
                    buttons: [
                        {
                            text: this.L('okText'),
                            handler: function() {
                                if (editor.isValid()) {
                                    var calendarDay = editor.calendarDay;
                                    calendarDay.setIsWorkingDay(editor.isWorkingDay());
                                    calendarDay.setAvailability(editor.getIntervals());
                                    me.applyCalendarDay(calendarDay, day);
                                    me.refreshView();
                                    editorWindow.close();
                                }
                            }
                        },
                        {
                            text: this.L('cancelText'),
                            handler: function() {
                                editorWindow.close();
                            }
                        }
                    ]
                });
            editorWindow.show();
        }
    },
    removeDay: function() {
        var grid = this.dayGrid,
            selection = grid.getSelection();
        if (!selection[0])  {
            return;
        }
        
        grid.getStore().remove(selection[0]);
        this.refreshView();
    },
    refreshView: function() {
        var date = this.datePicker.getValue(),
            day = this.getCalendarDay(date),
            weekGrid = this.weekGrid,
            dayGrid = this.dayGrid,
            dayOverride = this.dayOverridesCalendar.getOwnCalendarDay(date),
            weekOverride;
        var name;
        // First check if there is an override on day level
        if (dayOverride) {
            dayGrid.getSelectionModel().select([
                dayOverride
            ], false, true);
            name = dayOverride.getName();
        } else {
            // Now check if there is an override on week level
            weekOverride = this.getWeekOverrideByDate(date);
            if (weekOverride) {
                weekGrid.getSelectionModel().select([
                    weekOverride
                ], false, true);
                name = weekOverride.get('name');
            }
        }
        var dayData = {
                name: name || day.getName(),
                date: Ext.Date.format(date, this.L('dateInTextFormat')),
                calendarName: this.calendar.name || this.calendar.calendarId,
                availability: day.getAvailability(true),
                override: Boolean(dayOverride || weekOverride),
                isWorkingDay: day.getIsWorkingDay()
            };
        this.dateInfoPanel.update(this.dateInfoTpl.apply(dayData));
        this.datePicker.rendered && this.datePicker.refreshCssClasses();
    },
    onDayGridSelectionChange: function(grid, selection) {
        if (selection[0]) {
            this.datePicker.setValue(selection[0].getDate());
            this.refreshView();
        }
    },
    onDayGridEdit: function(editor, context) {
        if (context.field === 'Date') {
            context.grid.getStore().clearCache();
            this.datePicker.setValue(context.value);
        }
        this.refreshView();
    },
    onDayGridValidateEdit: function(editor, context) {
        var calendar = this.dayGrid.store;
        if (context.value && context.field === calendar.model.prototype.dateField && calendar.getOwnCalendarDay(context.value) && context.value - context.originalValue !== 0) {
            this.alert({
                msg: this.L('overrideErrorText')
            });
            return false;
        }
    },
    onDateSelect: function() {
        this.refreshView();
    },
    getCalendarDay: function(date) {
        var day = this.dayOverridesCalendar.getOwnCalendarDay(date);
        if (day)  {
            return day;
        }
        
        day = this.getWeekOverrideDay(date);
        if (day)  {
            return day;
        }
        
        return this.calendar.weekAvailability[date.getDay()] || this.calendar.defaultWeekAvailability[date.getDay()];
    },
    getWeekOverrideDay: function(date) {
        var internalWeekModel = this.getWeekOverrideByDate(date),
            index = date.getDay();
        if (internalWeekModel == null)  {
            return null;
        }
        
        var weekAvailability = internalWeekModel.get('weekAvailability');
        if (!weekAvailability)  {
            return null;
        }
        
        return weekAvailability[index];
    },
    getWeekOverrideByDate: function(date) {
        var week = null;
        this.weekOverridesStore.each(function(internalWeekModel) {
            if (Ext.Date.between(date, internalWeekModel.get('startDate'), internalWeekModel.get('endDate'))) {
                week = internalWeekModel;
                return false;
            }
        });
        return week;
    },
    intersectsWithCurrentWeeks: function(startDate, endDate, except) {
        var result = false;
        this.weekOverridesStore.each(function(internalWeekModel) {
            if (internalWeekModel == except)  {
                return;
            }
            
            var weekStartDate = internalWeekModel.get('startDate');
            var weekEndDate = internalWeekModel.get('endDate');
            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    },
    addWeek: function() {
        var weekOverridesStore = this.weekOverridesStore;
        var startDate = this.datePicker.getValue();
        var endDate;
        // we are about to create a week override and we need to make sure it does not
        // intersect with already created week overrides. Also we'd like to make it 1w long initially
        // but in case there will be an intersection with current overrides we are ok to shorten it
        for (var duration = 7; duration > 0; duration--) {
            endDate = Sch.util.Date.add(startDate, Sch.util.Date.DAY, duration);
            if (!this.intersectsWithCurrentWeeks(startDate, endDate))  {
                break;
            }
            
        }
        if (!duration) {
            this.alert({
                msg: Ext.String.format(this.L('overrideDateError'), Ext.Date.format(startDate, 'Y/m/d'))
            });
            return;
        }
        var mainDay = new this.calendar.model();
        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setName(this.L('newDayName'));
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);
        var newWeek = weekOverridesStore.insert(0, {
                name: this.L('newDayName'),
                startDate: startDate,
                endDate: endDate,
                weekAvailability: [],
                mainDay: mainDay
            })[0];
        this.weekGrid.getSelectionModel().select([
            newWeek
        ], false, false);
    },
    editWeek: function() {
        var selection = this.weekGrid.getSelection(),
            me = this;
        if (selection.length === 0)  {
            return;
        }
        
        var weekModel = selection[0];
        var editor = new Gnt.widget.calendar.WeekEditor({
                startDate: weekModel.get('startDate'),
                endDate: weekModel.get('endDate'),
                weekName: weekModel.get('name'),
                calendarDayModel: this.calendar.model,
                // keep the "weekModel" private and pass individual fields to the editor
                weekAvailability: weekModel.get('weekAvailability'),
                calendarWeekAvailability: this.calendar.weekAvailability,
                defaultWeekAvailability: this.calendar.defaultWeekAvailability
            });
        var editorWindow = Ext.create('Ext.window.Window', {
                title: this.L('weekOverridesText'),
                modal: true,
                width: 370,
                defaults: {
                    border: false
                },
                layout: 'fit',
                items: editor,
                buttons: [
                    {
                        // this property will be used in test to locate the button
                        action: 'ok',
                        text: this.L('okText'),
                        handler: function() {
                            if (editor.applyChanges(weekModel.get('weekAvailability'))) {
                                me.refreshView();
                                editorWindow.close();
                            }
                        }
                    },
                    {
                        text: this.L('cancelText'),
                        handler: function() {
                            editorWindow.close();
                        }
                    }
                ]
            });
        editorWindow.show();
    },
    removeWeek: function() {
        var selection = this.weekGrid.getSelection();
        if (selection[0]) {
            this.weekOverridesStore.remove(selection[0]);
            this.refreshView();
        }
    },
    onWeekGridSelectionChange: function(grid, selection) {
        if (selection[0]) {
            this.datePicker.setValue(selection[0].get('startDate'));
        }
    },
    onWeekGridEdit: function(editor, context) {
        var weekModel = context.record,
            startDate = weekModel.get('startDate'),
            endDate = weekModel.get('endDate');
        if (context.field == 'startDate' || context.field == 'endDate') {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    weekDay.setOverrideStartDate(startDate);
                    weekDay.setOverrideEndDate(endDate);
                }
            });
            this.datePicker.setValue(startDate);
        }
        //        if (context.field == 'name') {
        //            weekModel.setName(weekModel.getName());
        //            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function (weekDay) {
        //                if (weekDay) {
        //                    weekDay.setName(weekModel.get('name'));
        //                }
        //            });
        //        }
        this.refreshView();
    },
    alert: function(config) {
        config = config || {};
        Ext.MessageBox.show(Ext.applyIf(config, {
            title: this.L('error'),
            icon: Ext.MessageBox.WARNING,
            buttons: Ext.MessageBox.OK
        }));
    },
    onWeekGridValidateEdit: function(editor, context) {
        var weekModel = context.record,
            startDate = context.field == 'startDate' ? context.value : weekModel.get('startDate'),
            endDate = context.field == 'endDate' ? context.value : weekModel.get('endDate');
        if (startDate > endDate) {
            this.alert({
                msg: this.L('startAfterEndError')
            });
            context.cancel = true;
            return false;
        }
        if (this.intersectsWithCurrentWeeks(startDate, endDate, weekModel)) {
            this.alert({
                msg: this.L('weeksIntersectError')
            });
            context.cancel = true;
            return false;
        }
    },
    applyCalendarDay: function(from, to) {
        to.beginEdit();
        to.setName(from.getName());
        to.setIsWorkingDay(from.getIsWorkingDay());
        to.setDate(from.getDate());
        to.setOverrideStartDate(from.getOverrideStartDate());
        to.setOverrideEndDate(from.getOverrideEndDate());
        var fromAvailability = from.getAvailability(true);
        var toAvailability = to.getAvailability(true);
        if (fromAvailability + '' != toAvailability + '')  {
            to.setAvailability(from.getAvailability());
        }
        
        to.endEdit();
    },
    applySingleDay: function(copyDay, toAdd) {
        if (copyDay.__COPYOF__) {
            this.applyCalendarDay(copyDay, this.calendar.getModelById(copyDay.__COPYOF__));
        } else {
            if (copyDay.store) {
                copyDay.unjoin(copyDay.store);
            }
            // we reset id to not intersect w/ existing records
            copyDay.setId(null);
            toAdd.push(copyDay.getData());
        }
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     *
     */
    applyChanges: function() {
        var me = this;
        var calendar = this.calendar;
        var parent = this.down('combobox[name="cmb_parentCalendar"]').getValue(),
            newName = this.down('#calendarName').getValue(),
            setProjectCalendar = this.projectCalendarCheckbox.getValue();
        if (this.calendarManager) {
            var node = this.calendarManager.getModelById(calendar.calendarId);
            if (node) {
                node.setName(newName);
            }
            if (this.calendarManager.getProjectCalendar() !== calendar && setProjectCalendar) {
                this.projectCalendarCheckbox.setDisabled(true);
                this.calendarManager.setProjectCalendar(calendar);
            }
        }
        calendar.suspendEvents(true);
        calendar.suspendCacheUpdate++;
        calendar.name = newName;
        calendar.setParent(parent ? Gnt.data.Calendar.getCalendar(parent) : null);
        if (calendar.getProxy() && calendar.getProxy().extraParams) {
            calendar.getProxy().extraParams.calendarId = calendar.calendarId;
        }
        // days part
        Gnt.util.Data.applyCloneChanges(this.dayOverridesCalendar, calendar, function(newData, recordCopy) {
            // forces clearing the CalendarDay availability cache
            recordCopy.originalRecord && recordCopy.originalRecord.setAvailability(recordCopy.getAvailability(true));
        });
        var daysToAdd = [];
        var daysToRemove = [];
        var remainingWeekDays = {};
        // weeks part
        this.weekOverridesStore.each(function(weekModel) {
            Ext.Array.each(weekModel.get('weekAvailability').concat(weekModel.get('mainDay')), function(weekDay) {
                if (weekDay) {
                    if (weekDay.__COPYOF__)  {
                        remainingWeekDays[weekDay.__COPYOF__] = true;
                    }
                    
                    me.applySingleDay(weekDay, daysToAdd);
                }
            });
        });
        calendar.forEachNonStandardWeek(function(originalWeek) {
            Ext.Array.each(originalWeek.weekAvailability.concat(originalWeek.mainDay), function(originalWeekDay) {
                if (originalWeekDay && !remainingWeekDays[originalWeekDay.getId()])  {
                    daysToRemove.push(originalWeekDay);
                }
                
            });
        });
        calendar.add(daysToAdd);
        calendar.remove(daysToRemove);
        calendar.suspendCacheUpdate--;
        calendar.clearCache();
        calendar.resumeEvents();
        this.fireEvent('calendarset', calendar);
    },
    hasChanges: function() {
        if (!this.calendar)  {
            return false;
        }
        
        var dayChanges = this.dayOverridesCalendar.getModifiedRecords().length || this.dayOverridesCalendar.getRemovedRecords().length,
            weekChanges = this.weekOverridesStore.getModifiedRecords().length || this.weekOverridesStore.getRemovedRecords().length,
            // isDirty on field wouldn't work correct, so we are going to check it differently
            nameChanged = this.down('#calendarName').getValue() != this.calendar.name,
            parentId = this.calendar.parent && this.calendar.parent.calendarId || -1,
            parentChanged = this.cmbParentCalendar.getValue() != parentId,
            checkboxChanged = false;
        if (this.calendarManager) {
            checkboxChanged = this.projectCalendarCheckbox.getValue() && (this.calendarManager.getProjectCalendar() !== this.calendar);
        }
        return dayChanges || weekChanges || nameChanged || parentChanged || checkboxChanged;
    }
});

/**
 * @class Gnt.widget.calendar.CalendarManager
 * @aside guide gantt_calendars
 *
 * {@img gantt/images/calendar_manager.png}
 *
 * This widget can be used to manage calendars. As the input it should receive an instance of the {@link Gnt.data.CalendarManager} class.
 * Displays hierarchy of calendars attached to this CalendarManager and allows to edit calendar itself using {@link Gnt.data.widget.calendar.Calendar}.
 * Once the editing is done and user is happy with the result the {@link #applyChanges} method should be called. It will apply
 * all the changes user made in UI to the calendar.
 * This widget also checks changes in calendar when user navigates through the tree. In case changes were made widget displays confirmation
 * window with buttons "yes", "no", "cancel".
 *
 * Note, this widget does not have the "Ok", "Apply changes" etc button intentionally, as you might want to combine it with your widgets.
 * See {@link Gnt.widget.calendar.CalendarManagerWindow} for this widget embedded in the Ext.window.Window instance.
 *
 * ```javascript
 *     var calendarManager = Ext.create('Gnt.data.CalendarManager', {});
 *
 *     calendarManagerWidget = new Gnt.widget.calendar.CalendarManager({
 *         calendarManager : calendarManager
 *     });
 * ```
 *
 */
Ext.define('Gnt.widget.calendar.CalendarManager', {
    extend: 'Ext.Container',
    requires: [
        'Ext.tree.Panel',
        'Ext.menu.Menu',
        'Ext.tree.plugin.TreeViewDragDrop',
        'Gnt.patches.TreeViewDragDrop',
        'Gnt.widget.calendar.Calendar',
        'Gnt.data.calendar.BusinessTime'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarmanager',
    /**
     * @cfg {Object} treePanelConfig A configuration for the underlying tree panel
     */
    treePanelConfig: null,
    /**
     * @property {Ext.tree.Panel} treePanel Underlying tree panel
     */
    treePanel: null,
    /**
     * @cfg {Object} calendarPanelConfig A configuration for the underlying {@link Gnt.widget.calendar.Calendar calendar widget instance}
     */
    calendarPanelConfig: null,
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager Store keeping calendars to be shown in the component
     */
    calendarManager: null,
    /**
     * @cfg {Boolean} readOnly Set to true to disable editing
     */
    readOnly: false,
    /**
     * @property {Gnt.widget.calendar.Calendar} calendarPanel Underlying {@link Gnt.widget.calendar.Calendar calendar widget instance}
     */
    calendarPanel: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - addText         : 'Add',
     * - removeText      : 'Remove',
     * - add_child       : 'Add child',
     * - add_node        : 'Add calendar',
     * - add_sibling     : 'Add sibling',
     * - remove          : 'Remove',
     * - calendarName    : 'Calendar',
     * - confirm_action  : 'Confirm action',
     * - confirm_message : 'Calendar has unsaved changes. Would you like to save your changes?'
     */
    layout: 'border',
    width: 800,
    height: 600,
    initComponent: function() {
        var me = this;
        me.cls = me.cls + ' gnt-calendarmanager';
        me.treePanel = me.buildTreePanel();
        me.calendarPanel = new Gnt.widget.calendar.Calendar(Ext.apply({
            region: 'center',
            calendar: me.calendar,
            split: true,
            scrollable: true,
            calendarManager: me.calendarManager,
            readOnly: me.readOnly
        }, me.calendarPanelConfig));
        me.items = [
            me.treePanel,
            me.calendarPanel
        ];
        me.callParent(arguments);
        me.contextMenu = me.buildContextMenu();
        me.setReadOnly(me.readOnly);
        var calendarManager = me.calendarManager;
        me.setCalendar(me.calendar || calendarManager.getProjectCalendar() || calendarManager.getRoot().firstChild);
        // for debug purposes
        me.counter = 1;
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        var treePanel = this.treePanel;
        treePanel.down('#btnAdd').setDisabled(readOnly);
        treePanel.down('#btnRemove').setDisabled(readOnly);
        var treeView = treePanel.getView(),
            method = readOnly ? 'disable' : 'enable';
        if (treeView.rendered) {
            treeView.getPlugin('treeDragDrop')[method]();
        } else {
            treeView.on('render', function() {
                treeView.getPlugin('treeDragDrop')[method]();
            }, this, {
                single: true
            });
        }
        this.contextMenu.setDisabled(readOnly);
        this.calendarPanel.setReadOnly(readOnly);
    },
    getReadOnly: function() {
        return this.readOnly;
    },
    /**
     * Returns true if the widget is currently read only.
     * @return {Boolean} readOnly
     */
    isReadOnly: function() {
        return this.getReadOnly();
    },
    buildTreePanel: function() {
        var me = this;
        return new Ext.tree.Panel(Ext.apply({
            split: true,
            region: 'west',
            width: 200,
            store: me.calendarManager,
            displayField: me.calendarManager.model.prototype.nameField,
            rootVisible: false,
            tbar: [
                {
                    itemId: 'btnAdd',
                    text: me.L('addText'),
                    action: 'add',
                    iconCls: 'x-fa fa-plus',
                    handler: me.doAddRootNode,
                    scope: me
                },
                {
                    itemId: 'btnRemove',
                    text: me.L('removeText'),
                    action: 'remove',
                    iconCls: 'x-fa fa-trash',
                    handler: me.doRemoveCalendar,
                    scope: me
                }
            ],
            viewConfig: {
                plugins: {
                    ptype: 'treeviewdragdrop',
                    pluginId: 'treeDragDrop',
                    allowContainerDrops: true,
                    dropZone: {
                        // we want to always append child node to the hovered one
                        // this behavior isn't supported out of the box by the plugin
                        // so we override a template "onNodeDrop" method
                        onNodeDrop: function(node, dz, ev, dd) {
                            var valid = this.valid;
                            this.overRecord = this.view.getRecord(node);
                            this.currentPosition = 'append';
                            Ext.Array.each(dd.records, function(r) {
                                if (r.contains(this.overRecord)) {
                                    valid = false;
                                    return false;
                                }
                            }, this);
                            this.valid = valid;
                            // If node is not expanded yet and we're trying to append child to it (which is not
                            // supported out of the box) ext will try to expand new parent and scroll to dropped node.
                            // But node is not visible yet, so buffered renderer will throw exception. To avoid that
                            // we set 'expanded' flag on leaf to prevent auto expand on drop and expand node later manually
                            // caught by 1121_calendar_read_only test
                            if (this.overRecord.isLeaf()) {
                                this.overRecord.set('expanded', true);
                                this.overRecord.childNodes = [];
                            }
                            // call overridden method
                            return this.self.prototype.onNodeDrop.apply(this, arguments);
                        }
                    }
                },
                getRowClass: function(record) {
                    if (me.calendarManager.getProjectCalendar() == record.calendar) {
                        return 'gnt-project-calendar-row';
                    }
                },
                listeners: {
                    drop: me.onDrop,
                    scope: me
                }
            },
            listeners: {
                containercontextmenu: me.onContainerContextMenu,
                itemcontextmenu: me.onItemContextMenu,
                selectionchange: me.onSelectionChange,
                scope: me
            }
        }, me.treePanelConfig));
    },
    buildContextMenu: function() {
        return new Ext.menu.Menu({
            margin: '0 0 10 0',
            items: [
                {
                    text: this.L('add_node'),
                    handler: this.doAddRootNode,
                    itemId: 'add-node',
                    scope: this
                },
                {
                    text: this.L('add_child'),
                    handler: this.doAddChildNode,
                    scope: this
                },
                {
                    text: this.L('add_sibling'),
                    handler: this.doAddSiblingCalendar,
                    scope: this
                },
                {
                    text: this.L('remove'),
                    handler: this.doRemoveCalendar,
                    itemId: 'remove-node',
                    scope: this
                }
            ]
        });
    },
    showContextMenu: function(e, calendar) {
        var menuItems = this.contextMenu.query('menuitem');
        Ext.Array.each(menuItems, function(x) {
            x.setVisible(!!calendar);
        });
        this.contextMenu.down('#add-node').setVisible(!calendar);
        e.stopEvent();
        this.contextMenu.showAt(e.getXY());
    },
    onContainerContextMenu: function(view, e) {
        this.showContextMenu(e);
    },
    onItemContextMenu: function(view, calendar, item, index, e) {
        this.showContextMenu(e, calendar);
    },
    hasChanges: function() {
        return this.calendarPanel.hasChanges();
    },
    onSelectionChange: function(treePanelView, selected, eOpts) {
        // Note, that when this method is called, the selection in the tree actually has already been changed.
        // But, the calendar in the center region has not been updated yet (we do it manually below with
        // calendarPanel.setCalendar() call
        // that is why `calendarPanel.calendar` still contains the data calendar from previously(!) selected calendar row in tree
        var me = this,
            calendarManager = me.calendarManager,
            calendarPanel = me.calendarPanel;
        if (selected.length > 0) {
            var selectedNode = selected[0];
            var selectedCalendar = selectedNode.getCalendar();
            var projectCalendar = calendarManager.getProjectCalendar();
            var isProjectCalendar = selectedCalendar === projectCalendar || projectCalendar && Boolean(selectedNode.findChild(selectedNode.idProperty, projectCalendar.calendarId));
            if (!me.isReadOnly()) {
                // if project calendar selected we disable remove button/menu entry
                me.treePanel.down('#btnRemove').setDisabled(isProjectCalendar);
                me.contextMenu.down('#remove-node').setDisabled(isProjectCalendar);
            }
            if (calendarPanel.calendar && calendarPanel.hasChanges()) {
                Ext.Msg.show({
                    title: me.L('confirm_action'),
                    msg: me.L('confirm_message'),
                    buttons: Ext.Msg.YESNOCANCEL,
                    icon: Ext.Msg.QUESTION,
                    fn: function(btn) {
                        // changes were accepted
                        if (btn == 'yes') {
                            me.applyChanges();
                            calendarPanel.setCalendar(selectedCalendar);
                        }
                        // changes were ignored
                        else if (btn == 'no') {
                            calendarPanel.setCalendar(selectedCalendar);
                        } else // cancel selection change
                        {
                            treePanelView.suspendEvents();
                            // select previous active node
                            treePanelView.select(calendarManager.getNodeByCalendar(calendarPanel.calendar));
                            treePanelView.resumeEvents();
                        }
                    }
                });
            } else {
                calendarPanel.setCalendar(selectedCalendar);
            }
        }
    },
    onDrop: function(node, data, overModel, dropPosition) {
        overModel = overModel || this.calendarManager.getRootNode();
        // let's expand the node in which we're dropping
        overModel.expand();
    },
    onDestroy: function() {
        this.contextMenu.destroy();
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     * @method applyChanges
     */
    applyChanges: function() {
        this.calendarPanel.applyChanges();
    },
    doAddRootNode: function() {
        this.addCalendar();
    },
    doAddChildNode: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(selection[0]);
    },
    doAddSiblingCalendar: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.addCalendar(selection[0] && selection[0].parentNode);
    },
    doRemoveCalendar: function() {
        var selection = this.treePanel.getSelectionModel().getSelection();
        this.removeCalendar(selection[0]);
    },
    addCalendar: function(parent) {
        // calendar class prototype
        var calendarProto = Ext.ClassManager.get(this.calendarManager.calendarClass).prototype;
        // node class prototype
        var nodeProto = this.calendarManager.model.prototype;
        // extract calendar data to new node config
        var config = nodeProto.getModelConfig(calendarProto, true);
        config[nodeProto.nameField] = this.L('calendarName') + this.counter++;
        config.expanded = true;
        config.leaf = true;
        parent = parent || this.treePanel.getRootNode();
        // expand parent node
        parent.data.expanded = true;
        parent.appendChild(config);
    },
    removeCalendar: function(node) {
        var root = this.treePanel.getRootNode();
        if (node) {
            var next = node.nextSibling || node.previousSibling || (node.parentNode == root ? root.firstChild : node.parentNode);
            if (next) {
                this.treePanel.getSelectionModel().select(next);
            }
            node.remove();
        }
    },
    setCalendar: function(calendar) {
        if (calendar instanceof Gnt.model.Calendar) {
            // set focus in tree
            this.treePanel.setSelection(calendar);
        } else {
            // set focus in tree
            this.treePanel.setSelection(this.calendarManager.getNodeByCalendar(calendar));
        }
    }
});

/**

 @class Gnt.widget.calendar.CalendarManagerWindow
 @extends Ext.window.Window
 @aside guide gantt_calendars

 {@img gantt/images/calendar_manager_window.png}

 This is just a {@link Gnt.widget.calendar.CalendarManager} widget, wrapped with the Ext.window.Window instance.
 It proxies the {@link #calendar} config and {@link #applyChanges} method.

 */
Ext.define('Gnt.widget.calendar.CalendarManagerWindow', {
    extend: 'Ext.window.Window',
    requires: [
        'Gnt.widget.calendar.CalendarManager'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarmanagerwindow',
    layout: 'fit',
    border: false,
    constrain: true,
    defaultFocus: 'btnCancel',
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}
     */
    calendarConfig: null,
    /**
     * @cfg {Gnt.data.CalendarManager} calendarManager An instance of the {@link Gnt.data.CalendarManager}
     */
    calendarManager: null,
    /**
     * @property {Gnt.widget.calendar.Calendar} panel The underlying calendar widget instance
     */
    panel: null,
    /**
     * @cfg {Boolean} readOnly Set to true to disable editing
     */
    readOnly: false,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - title           : 'Calendar manager',
     * - ok              : 'Ok',
     * - cancel          : 'Cancel',
     * - confirm_action  : 'Confirm action',
     * - confirm_message : 'Calendar has unsaved changes. Would you like to save your changes?'
     */
    closing: false,
    initComponent: function() {
        this.panel = new Gnt.widget.calendar.CalendarManager({
            readOnly: this.readOnly,
            calendarManager: this.calendarManager,
            calendarPanelConfig: this.calendarConfig
        });
        // Only constrain width/height this way if user haven't set size
        Ext.applyIf(this, {
            width: Math.min(Ext.getBody().getWidth() - 100, 1050),
            height: Math.min(Ext.getBody().getHeight() - 100, 700)
        });
        Ext.apply(this, {
            title: this.title || this.L('title'),
            items: [
                this.panel
            ],
            buttons: [
                {
                    text: this.L('ok'),
                    hidden: this.readOnly,
                    handler: function() {
                        this.applyChanges();
                    },
                    scope: this
                },
                {
                    text: this.L('cancel'),
                    itemId: 'btnCancel',
                    handler: function() {
                        this.close();
                    },
                    scope: this
                }
            ],
            listeners: {
                beforeclose: this.onBeforeClose,
                close: this.onAfterClose,
                show: this.onAfterShow
            }
        });
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     */
    applyChanges: function() {
        this.panel.applyChanges();
    },
    onBeforeClose: function() {
        var me = this;
        var panel = this.panel;
        if (!me.closing && panel.hasChanges()) {
            Ext.Msg.show({
                title: me.L('confirm_action'),
                msg: me.L('confirm_message'),
                buttons: Ext.Msg.YESNOCANCEL,
                icon: Ext.Msg.QUESTION,
                fn: function(btn) {
                    switch (btn) {
                        case 'yes':
                            panel.applyChanges();
                            me.close();
                            break;
                        case 'no':
                            // set flag to skip this onBeforeClose processing again when we call me.close()
                            me.closing = true;
                            me.close();
                            break;
                    }
                }
            });
            return false;
        }
    },
    onAfterClose: function() {
        this.closing = false;
    },
    onAfterShow: function() {
        this.focus();
    }
});

/**

@class Gnt.widget.calendar.CalendarWindow
@extends Ext.window.Window
@aside guide gantt_calendars

{@img gantt/images/calendar.png}

This is just a {@link Gnt.widget.calendar.Calendar} widget, wrapped with the Ext.window.Window instance.
It proxies the {@link #calendar} config and {@link #applyChanges} method.

*/
Ext.define('Gnt.widget.calendar.CalendarWindow', {
    extend: 'Ext.window.Window',
    requires: [
        'Gnt.widget.calendar.Calendar'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.calendarwindow',
    /**
     * @cfg {Object} calendarConfig An object to be applied to the newly created instance of the {@link Gnt.widget.calendar.Calendar}
     */
    calendarConfig: null,
    /**
     * @cfg {Gnt.data.Calendar} calendar An instance of the {@link Gnt.data.Calendar} to read/change the holidays from/in.
     */
    calendar: null,
    /**
     * @property {Gnt.widget.calendar.Calendar} calendarWidget An underlying calendar widget instance
     */
    calendarWidget: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - ok         : 'Ok',
     * - cancel     : 'Cancel',
     */
    initComponent: function() {
        // Only constrain width/height this way if user haven't set size
        Ext.applyIf(this, {
            width: Math.min(Ext.getBody().getWidth() - 100, 800),
            height: Math.min(Ext.getBody().getHeight() - 100, 650)
        });
        Ext.apply(this, {
            layout: 'fit',
            title: this.title || this.L('title'),
            items: this.calendarWidget = new Gnt.widget.calendar.Calendar(Ext.apply({
                calendar: this.calendar
            }, this.calendarConfig)),
            buttons: [
                {
                    text: this.L('ok'),
                    handler: function() {
                        this.applyChanges();
                        this.close();
                    },
                    scope: this
                },
                {
                    text: this.L('cancel'),
                    handler: this.close,
                    scope: this
                }
            ]
        });
        this.callParent(arguments);
    },
    /**
     * Call this method when user is satisfied with the current state of the calendar in the UI. It will apply all the changes made in the UI
     * to the original calendar.
     */
    applyChanges: function() {
        this.calendarWidget.applyChanges();
    },
    setCalendar: function(calendar) {
        this.calendarWidget.setCalendar(calendar);
    }
});

Ext.define('Gnt.widget.calendar.ResourceCalendarGrid', {
    extend: 'Ext.grid.Panel',
    requires: [
        'Ext.data.Store',
        'Ext.grid.plugin.CellEditing',
        'Ext.form.field.ComboBox',
        'Sch.patches.BoundList',
        'Sch.util.Date',
        'Gnt.model.Calendar',
        'Gnt.data.Calendar'
    ],
    mixins: [
        'Gnt.mixin.Localizable'
    ],
    alias: 'widget.resourcecalendargrid',
    resourceStore: null,
    calendarStore: null,
    border: true,
    height: 180,
    /*
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - name      : 'Name',
            - calendar  : 'Calendar'
     */
    cellEditingConfig: null,
    initComponent: function() {
        var me = this;
        this.calendarStore = this.calendarStore || {
            xclass: 'Ext.data.Store',
            model: 'Gnt.model.Calendar'
        };
        if (!(this.calendarStore instanceof Ext.data.Store)) {
            this.calendarStore = Ext.create(this.calendarStore);
        }
        var plugin = Ext.create('Ext.grid.plugin.CellEditing', Ext.apply({
                clicksToEdit: 2
            }, this.cellEditingConfig));
        plugin.on({
            beforeedit: function(editor, e) {
                var resource = e.record;
                if (e.value === null || e.value === undefined) {
                    var projectCal = resource.getProjectCalendar();
                    if (projectCal) {
                        e.value = projectCal.calendarId;
                    }
                }
            },
            edit: function(editor, e) {
                this.onCalendarChange(e.record, e.value);
            },
            scope: this
        });
        Ext.apply(me, {
            store: me.resourceStore,
            columns: [
                {
                    text: this.L('name'),
                    dataIndex: me.resourceStore.getModel().prototype.nameField,
                    flex: 1
                },
                {
                    text: this.L('calendar'),
                    dataIndex: me.resourceStore.getModel().prototype.calendarIdField,
                    flex: 1,
                    renderer: function(value, meta, record) {
                        var cal = record.getCalendar();
                        var fn = me.calendarStore.getModelById ? 'getModelById' : 'getById';
                        var rec = me.calendarStore[fn](cal && cal.calendarId);
                        return rec && rec.getName() || value;
                    },
                    editor: {
                        xtype: 'combobox',
                        store: me.calendarStore,
                        queryMode: 'local',
                        displayField: 'Name',
                        valueField: 'Id',
                        editable: false,
                        allowBlank: false,
                        listConfig: {
                            htmlEncode: true
                        }
                    }
                }
            ],
            plugins: plugin
        });
        this.calendarStore.loadData(this.getCalendarData());
        this.callParent(arguments);
    },
    getCalendarData: function() {
        return Ext.Array.map(Gnt.data.Calendar.getAllCalendars(), function(cal) {
            return {
                Id: cal.calendarId,
                Name: cal.name || cal.calendarId
            };
        });
    },
    onCalendarChange: function(record, calendarId) {
        record.setCalendarId(calendarId);
    },
    destroy: function() {
        this.calendarStore.destroy();
        this.callParent(arguments);
    }
});

