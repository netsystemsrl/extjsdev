/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling {@link #clearFilter} will return you to a full time axis.

*/
Ext.define("Sch.data.TimeAxis", {
    extend      : "Ext.data.JsonStore",

    requires    : [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],

    model               : 'Sch.model.TimeAxisTick',

    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous          : true,

    originalContinuous  : null,

    /**
     * @cfg {Boolean} autoAdjust
     * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
     * may lead to shifting time/date of ticks.
     */
    autoAdjust          : true,

    unit                : null,
    increment           : null,
    resolutionUnit      : null,
    resolutionIncrement : null,

    weekStartDay        : null,

    mainUnit            : null,
    shiftUnit           : null,

    shiftIncrement      : 1,
    defaultSpan         : 1,

    isConfigured        : false,

    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart       : null,
    adjustedEnd         : null,
    // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
    visibleTickStart    : null,
    // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
    visibleTickEnd      : null,

    // name of the current preset
    presetName          : null,

    /**
     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for weekview we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'week']
     * @private
     */
    mode                : 'plain',

    /**
     * @cfg {Number} startTime Start time for weekview mode, used only with day/week presets.
     */
    startTime           : 0,

    /**
     * @cfg {Number} endTime End time for weekview mode, used only with day/week presets.
     */
    endTime             : 24,

    /**
     * @cfg {Number} timeZone
     * Difference in **minutes** between UTC and expected time zone. Examples:
     *
     * ```
     * 120  : +2 hours from UTC
     * 0    : UTC
     * -180 : -3 hours from UTC
     * ```
     *
     * Default value `null` means current system timeZone is used.
     *
     * **NOTE**: DST transitions are not supported, this config only specifies time zone offset from UTC. If value is
     * 0, UTC time zone is used. UTC time zone has no DST.
     */
    timeZone            : null,

    /**
     * @event beforereconfigure
     * @preventable
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */

    /**
     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */

    /**
     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */

    // private
    constructor : function(config) {
        var me = this;

        config = config || {};

        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }

        me.setMode(config.mode || me.mode);

        me.originalContinuous = me.continuous;

        me.callParent(arguments);

        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function() {
            me.fireEvent('reconfigure', me, false);
        });

        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });

        if (config.viewPreset) {
            var preset      = Sch.preset.Manager.getPreset(config.viewPreset);
            preset && me.consumeViewPreset(preset);
        }

        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },

    /**
     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
     * @param {Object} config
     * @param {Boolean} [suppressRefresh]
     * @private
     */
    reconfigure : function (config, suppressRefresh) {
        this.isConfigured   = true;

        Ext.apply(this, config);

        var adjusted        = this.getAdjustedDates(config.start, config.end, true);
        var normalized      = this.getAdjustedDates(config.start, config.end);

        var start           = normalized.start;
        var end             = normalized.end;

        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {

            this._isTickLengthVarying = null;
            this._hasTimeZone = null;

            this.fireEvent('beginreconfigure', this);

            var unit                = this.unit;
            var increment           = this.increment || 1;
            var ticks               = this.generateTicks(start, end, unit, increment);

            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);

            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();

            var DATE                = Sch.util.Date;
            var count               = ticks.length;

            if (this.isContinuous()) {
                this.adjustedStart      = adjusted.start;
                // For timeZone we don't want any extra date skipping
                this.adjustedEnd        = this.hasTimeZone() ? adjusted.end : this.getNext(count > 1 ? ticks[ count - 1 ].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart      = this.getStart();
                this.adjustedEnd        = this.getEnd();
            }

            var tickScale = DATE.getUnitDurationInMs(unit) * increment;

            // Normally time axis expects every tick to be equal in size. If ticks are not equal, it uses visibleTickStart
            // logic to correct for partial ticks.
            // But in case of timezones visibleTickStart approach doesn't work. First and last ticks could be partial, but
            // lookups on them has to be normal. We need property similar to visibleTickStart, but working in a different way
            if (this.hasTimeZone()) {
                this.timezoneTickStart = 1 - (this.first().getEndDate() - this.first().getStartDate()) / tickScale;
                this.timezoneTickEnd   = count - 1 + (this.last().getEndDate() - this.last().getStartDate()) / tickScale;
            }

            // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust "adjustedStart" accordingly
            do {
                // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
                this.visibleTickStart   = (this.getStart() - this.adjustedStart) / tickScale;

                if (this.visibleTickStart >= 1) this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment, this.weekStartDay, this.timeZone);
            } while (this.visibleTickStart >= 1);

            do {
                this.visibleTickEnd     = count - (this.adjustedEnd - this.getEnd()) / tickScale;

                if (count - this.visibleTickEnd >= 1) this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1, this.weekStartDay, this.timeZone);
            } while (count - this.visibleTickEnd >= 1);


            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },

    isWeek : function () {
        return this.mode !== 'plain';
    },

    hasTimeZone : function () {
        if (this._hasTimeZone == null) {
            this._hasTimeZone = this.timeZone != null &&
                Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.unit) >= 0 &&
                // Do not adjust timeline if local timezone is same as configured
                // Do not run this check for UTC0 which we treat as UTC timezone, not London standard time
                (this.timeZone === 0 || (!this.first() || this.first() && this.getStart().getTimezoneOffset() !== -this.timeZone));
        }

        return this._hasTimeZone;
    },

    isUTCTimeZone : function () {
        return this.hasTimeZone() && this.timeZone === 0;
    },

    roundDateInTimeZone : function (value, roundingMethod) {
        var isUTC = this.isUTCTimeZone();

        if (!isUTC) {
            value = this.toTimeZone(value);
        }

        if (roundingMethod) {
            if (isUTC && roundingMethod === 'floor') {
                value = this.floorUTCDate(value);
            }
            else if (roundingMethod === 'round') {
                var relativeTo = this.getStart();

                if (Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.unit) <= 0) {
                    if (isUTC) {
                        relativeTo = this.floorUTCDate(relativeTo);
                    }
                    else {
                        relativeTo = this.fromTimeZone(relativeTo);
                    }
                }

                value = this.roundDate(value, relativeTo);
            }
            else {
                value = this[roundingMethod + 'Date'](value);
            }
        }

        return value;
    },

    // In case unit is day ticks may have different length and would require more complex lookup
    isTickLengthVarying : function () {
        if (this._isTickLengthVarying == null) {
            this._isTickLengthVarying = this.hasTimeZone() && (
                // With timeZone ticks will have different width in case tick unit is day
                this.unit === Sch.util.Date.DAY ||
                // or hour with sub-hour timeZone offset, e.g. UTC+03:30
                this.unit === Sch.util.Date.HOUR && this.timeZone % 60 !== 0
            );
        }

        return this._isTickLengthVarying;
    },

    setMode : function (mode) {
        this.mode = mode;

        if (this.isWeek()) {
            this.generateTicksValidatorFn = function (start) {
                if (this.startTime > 0 || this.endTime < 24) {
                    return (start.getHours() >= this.startTime && start.getHours() < this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function () { return true; };
        }
    },

    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     * @param {Number} timeZone (Optional) New timeZone
     */
    setTimeSpan : function (start, end, timeZone) {
        var adjusted    = this.getAdjustedDates(start, end);

        start           = adjusted.start;
        end             = adjusted.end;

        timeZone        = timeZone === undefined ? this.timeZone : timeZone;

        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0 || this.timeZone != timeZone) {
            this.reconfigure({
                start    : start,
                end      : end,
                timeZone : timeZone
            });
        }
    },

    setTimeZone : function (timeZone) {
        if (timeZone != null && timeZone !== this.timeZone) {
            this.setTimeSpan(
                this.getStart(),
                this.getEnd(),
                timeZone
            );
        }
    },

    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy : function(fn, scope) {
        this.continuous = false;
        scope = scope || this;

        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([{
            filterFn : function(t, index) {
                return fn.call(scope, t.data, index);
            }
        }]);

        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },

    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous : function() {
        var result = this.continuous && !this.isFiltered();
        if (this.isWeek()) {
            result = result && this.startTime === 0 && this.endTime === 24;
        }
        return result;
    },

    /**
     * Clear the current filter of the time axis
     */
    clearFilter : function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },

    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} start The start date of the interval
     * @param {Date} end The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Number} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks : function (start, end, unit, increment) {
        var ticks           = [],
            intervalEnd,
            DATE            = Sch.util.Date,
            dstDiff         = 0;

        unit                = unit || this.unit;
        increment           = increment || this.increment;

        var adjusted        = this.getAdjustedDates(start, end);

        start = adjusted.start;
        end   = adjusted.end;

        while (start < end) {
            intervalEnd     = this.getNext(start, unit, increment);

            if ((!this.autoAdjust || this.hasTimeZone()) && intervalEnd > end) {
                intervalEnd = end;
            }

            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            // Do not correct for UTC time zone, it should have no DST
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0 && !this.isUTCTimeZone()) {
                var prev    = ticks[ ticks.length - 1 ];

                dstDiff     = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }

            this.generateTicksValidatorFn(start) && ticks.push({
                start   : start,
                end     : intervalEnd
            });

            start           = intervalEnd;
        }

        return ticks;
    },


    getVisibleTickTimeSpan : function () {
        var result;

        // Filtered time axis with uneven ticks is not supported yet
        if (this.hasTimeZone() && this.isContinuous()) {
            result = this.timezoneTickEnd - this.timezoneTickStart;
        }
        else if (this.isContinuous()) {
            result = this.visibleTickEnd - this.visibleTickStart;
        }
        else {
            result = this.getCount();
        }

        return result;
    },

    // Given that _adjusted_ date will be different date from same time zone - this method is NOT idempotent.
    // For this reason it cannot be embedded into getAdjustedDate call, since that method IS idempotent and called multiple
    // times for same dates.
    // Returns date and time in the requested time zone, if you ignore timeZone offset of the returned value
    toTimeZone : function (date) {
        date = new Date(date);

        if (this.hasTimeZone()) {
            date = Sch.util.Date.toTimeZone(date, this.timeZone);
        }

        return date;
    },

    fromTimeZone : function (date) {
        date = new Date(date);

        if (this.hasTimeZone()) {
            date = Sch.util.Date.fromTimeZone(date, this.timeZone);
        }

        return date;
    },

    getAdjustedDates : function (start, end, forceAdjust) {
        var DATE    = Sch.util.Date;
        start       = start || this.getStart();
        end         = end || DATE.add(start, this.mainUnit, this.defaultSpan);

        if (this.isWeek()) {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit);
                    end = this.ceilDate(end, false, this.mainUnit);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start   : start,
                        end     : end
                    };
                }
            }

            var adjustedStart, adjustedEnd, clone;
            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            adjustedStart   = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart   = this.floorDate(adjustedStart, false, this.mainUnit, 1);

            // https://www.assembla.com/spaces/bryntum/tickets/2811
            // Disabled autoAdjust will allow to show any time span
            if (this.autoAdjust) {
                clone           = this.getNext(start, this.shiftUnit, 1);
                adjustedEnd     = this.ceilDate(clone, false, this.shiftUnit);
                adjustedEnd     = this.ceilDate(adjustedEnd, false, this.mainUnit);
            } else {
                adjustedEnd     = this.ceilDate(end, false, this.shiftUnit);
                adjustedEnd     = this.ceilDate(adjustedEnd, false, this.mainUnit);
            }

            return {
                start   : adjustedStart,
                end     : adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start   : this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end     : this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start   : start,
                end     : end
            };
        }
    },

    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate : function (date) {
        var ticks           = this.data.items;
        var lastTickIndex   = ticks.length - 1;

        // quick bailout
        if (date.valueOf() < ticks[ 0 ].data.start.valueOf() || date.valueOf() > ticks[ lastTickIndex ].data.end.valueOf()) {
            return -1;
        }

        var tick, tickStart, tickEnd;

        if (this.isContinuous() && !(this.hasTimeZone() && this.isTickLengthVarying())) {
            if (date - ticks[ 0 ].data.start === 0) return this.visibleTickStart;
            if (date - ticks[ lastTickIndex ].data.end === 0) return this.visibleTickEnd;

            var adjustedStart   = this.adjustedStart;
            var adjustedEnd     = this.adjustedEnd;

            var tickIndex = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));

            // for the date == adjustedEnd case
            if (tickIndex > lastTickIndex) tickIndex = lastTickIndex;

            tickStart           = tickIndex === 0 ? adjustedStart : ticks[ tickIndex ].data.start;
            tickEnd             = tickIndex == lastTickIndex ? adjustedEnd : ticks[ tickIndex ].data.end;

            tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);

            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // but still
            if (tick < this.visibleTickStart || tick > this.visibleTickEnd) return -1;

            return tick;
        } else {
            for (var i = 0; i <= lastTickIndex; i++) {
                tickEnd         = ticks[ i ].data.end;

                if (date <= tickEnd) {
                    tickStart   = ticks[ i ].data.start;

                    // date < tickStart can occur in filtered case
                    tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

                    return tick;
                }
            }
        }

        return -1;
    },

    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Number} tick the tick "coordinate"
    * @param {String} [roundingMethod] The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick : function (tick, roundingMethod) {
        if (
            tick === this.visibleTickEnd ||
            // On a filtered timeaxis check if we received last tick
            (!this.isContinuous() && tick === this.getCount())
        ) {
            return this.getEnd();
        }

        var wholeTick   = Math.floor(tick),
            fraction    = tick - wholeTick,
            t           = this.getAt(wholeTick);

        if (!t) return null;

        var tickData    = t.data;
        var start       = wholeTick === 0 && this.isContinuous() ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end         = (wholeTick === this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : tickData.end;

        var date        = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));

        if (roundingMethod) {
            date        = this[ roundingMethod + 'Date' ](date);
        }

        return date;
    },

    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks : function() {
        var ticks = [];

        this.each(function (r) { ticks.push(r.data); });
        return ticks;
    },

    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart : function() {
        var first = this.first();

        if (first) {
            return first.data.start;
        }
        return null;
    },

    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd : function() {
        var last = this.last();

        if (last) {
            return last.data.end;
        }
        return null;
    },

    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate : function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;

        var dt          = Ext.Date.clone(date),
            relativeTo  = relativeToStart ? this.getStart() : null,
            increment   = incr || this.resolutionIncrement,
            unit;

        if (resolutionUnit) {
            unit        = resolutionUnit;
        } else {
            unit        = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        var DATE        = Sch.util.Date;
        var snap        = function (value, increment) { return Math.floor(value / increment) * increment; };

        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                }
                break;

            case DATE.SECOND:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setUTCMilliseconds(0);
                    dt.setUTCSeconds(snap(dt.getUTCSeconds(), increment));
                }
                break;

            case DATE.MINUTE:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setUTCMinutes(snap(dt.getUTCMinutes(), increment));
                    dt.setUTCSeconds(0);
                    dt.setUTCMilliseconds(0);
                }
                break;

            case DATE.HOUR:
                if (relativeToStart) {
                    dt           = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt = this.floorUTCDate(dt, unit, increment);
                }
                break;

            case DATE.DAY:
                if (relativeToStart) {
                    dt            = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                }
                break;

            case DATE.WEEK:
                var day      = dt.getDay()       || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);

                dt      = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));

                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay && dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                }
                break;

            case DATE.MONTH:
                if (relativeToStart) {
                    dt      = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                }
                break;

            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt                      = DATE.add(dt, DATE.MONTH, - (dt.getMonth() % 3));
                break;

            case DATE.YEAR:
                if (relativeToStart) {
                    dt                  = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    var fullYear        = snap(date.getFullYear() - 1, increment) + 1;
                    // Using setFullYear to handle case when year is in range 0-99 (0-99 are handled as 1900-1999)
                    dt                  = new Date(0, 0, 1);
                    dt.setFullYear(fullYear);
                }
                break;
        }

        return dt;
    },

    // We need separate method for that, because if we embed this logic into floorDate time axis dates would change when
    // changing timezone. We want those to be intact, so we will use this method for occasional lookups instead.
    floorUTCDate : function (date, unit, incr) {
        var dt          = Ext.Date.clone(date),
            increment   = incr || this.resolutionIncrement;

        if (!unit) {
            unit        = this.resolutionUnit;
        }

        var DATE        = Sch.util.Date;
        var snap        = function (value, increment) { return Math.floor(value / increment) * increment; };

        switch (unit) {
            case DATE.HOUR:
                // We need to snap local hours to find difference and then apply it to UTC hours. That way floor would
                // work correct around DST and would return nicely snapped hours
                var diff = snap(dt.getHours(), increment) - dt.getHours();
                dt.setUTCHours(dt.getUTCHours() + diff, 0, 0, 0);
                break;

            case DATE.DAY:
                dt = DATE.clearUTCTime(dt);
                // days are 1-based so need to make additional adjustments
                dt.setUTCDate(snap(dt.getUTCDate() - 1, increment) + 1);
                break;

            default:
                dt = this.floorDate(date, null, unit, incr);
                break;
        }

        return dt;
    },


    /**
     * Rounds the date to nearest unit increment
     * @private
     */
    roundDate : function (date, relativeTo) {
        var dt        = Ext.Date.clone(date),
            increment = this.resolutionIncrement;

        relativeTo = relativeTo || this.getStart();

        // Need to find the difference of timeZone offsets between relativeTo and original dates.
        // 0 if timeZone offsets are the same.
        var offsetInMinutes = relativeTo.getTimezoneOffset() - dt.getTimezoneOffset();

        switch (this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds         = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt);
                var offsetInMilliseconds = offsetInMinutes * 60 * 1000;
                var snappedMilliseconds  = Math.round((milliseconds + offsetInMilliseconds) / increment) * increment;

                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, (snappedMilliseconds - offsetInMilliseconds));
                break;

            case Sch.util.Date.SECOND:
                var seconds         = Sch.util.Date.getDurationInSeconds(relativeTo, dt);
                var offsetInSeconds = offsetInMinutes * 60;
                var snappedSeconds  = Math.round((seconds + offsetInSeconds) / increment) * increment;

                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, (snappedSeconds - offsetInSeconds) * 1000);
                break;

            case Sch.util.Date.MINUTE:
                var minutes        = Sch.util.Date.getDurationInMinutes(relativeTo, dt);
                var snappedMinutes = Math.round((minutes + offsetInMinutes) / increment) * increment;

                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, (snappedMinutes - offsetInMinutes) * 60);
                break;

            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt);
                // offsetInHours is 0 if timezones are the same
                var offsetInHours = offsetInMinutes / 60;
                // First we need to add the offset to the whole amount of hours, so the divided value will take DST into account
                var snappedHours  = Math.round((nbrHours + offsetInHours) / increment) * increment;

                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, (snappedHours - offsetInHours) * 60);
                break;

            case Sch.util.Date.DAY:
                var nbrDays     = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;

                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);

                if (this.hasTimeZone()) {
                    dt = Sch.util.Date.add(dt, Sch.util.Date.MINUTE, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset());
                }

                break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);

                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay/7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                }

                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;

            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }

        return dt;
    },

    // private
    ceilDate : function(date, relativeToStart, resolutionUnit, increment) {
        var dt = Ext.Date.clone(date);

        relativeToStart = relativeToStart !== false;
        increment       = increment || (relativeToStart ? this.resolutionIncrement : 1);

        var doCall = false,
            unit;

        if (resolutionUnit){
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            default:
            break;
        }

        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },

    // private
    getNext : function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay, this.hasTimeZone() ? this.timeZone : null);
    },

    // private
    getResolution : function() {
        return {
            unit : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    },

    // private
    setResolution : function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },

    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function (amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
     * Moves the time axis to a passed start date.
     * @param {Date} startDate
     */
    shiftTo: function (startDate) {
        var timeAxisSpanInMs = this.getEnd() - this.getStart(),
            newEnd = new Date(startDate.getTime() + timeAxisSpanInMs);

        this.setTimeSpan(startDate, newEnd);
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        amount      = amount || this.getShiftIncrement();
        var unit    = this.getShiftUnit();

        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    getShiftUnit: function () {
        return this.shiftUnit || this.mainUnit;
    },

    // private
    getShiftIncrement: function () {
        return this.shiftIncrement || 1;
    },

    // private
    getUnit: function () {
        return this.unit;
    },

    // private
    getIncrement: function () {
        return this.increment;
    },

    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
    getRowTicks    : function () {
        if (this.isWeek()) {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);

            var endIndex = this.findBy(function (record) {
                return record.getStartDate().getTime() >= end.getTime();
            });

            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }

            return this.getRange(0, endIndex - 1);
        }
    },

    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date, inclusiveEnd) {
        var result    = false;
        var axisStart = this.getStart();
        var axisEnd   = this.getEnd();

        // Date is between axis start/end and axis is not continuous - need to perform better lookup
        if (this.isContinuous()) {
            result = inclusiveEnd ? Sch.util.Date.betweenLesserEqual(date, axisStart, axisEnd) : Sch.util.Date.betweenLesser(date, axisStart, axisEnd);
        } else {
            var length = this.getCount(), tickStart, tickEnd;

            for (var i = 0; i < length; i++) {
                var tick  = this.getAt(i);
                tickStart = tick.data.start;
                tickEnd   = tick.data.end;

                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {
                    return date >= tickStart;
                }
            }
        }

        return result;
    },


    /**
     * Returns true if the passed timespan is part of the time axis range (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
     * @return {Boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        var axisStart = this.getStart();
        var axisEnd   = this.getEnd();
        var duration    = end - start;

        if (duration === 0) {
            return this.dateInAxis(start, true);
        }

        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, axisStart, axisEnd);
        } else {
            var coversRange = start < axisStart && end > axisEnd;

            if (coversRange) return true;

            var startTick   = this.getTickFromDate(start);
            var endTick     = this.getTickFromDate(end);

            return (startTick !== endTick && (start < axisEnd && end > axisStart));
        }
    },

    // Accepts a Sch.model.Range model
    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();

        // only consider fully scheduled ranges
        if (!start || !end) return false;

        return this.timeSpanInAxis(start, end);
    },


    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachAuxInterval : function (unit, increment, iteratorFn, scope) {
        scope               = scope || this;

        var end             = this.getEnd(),
            dt              = this.getStart(),
            i               = 0,
            intervalEnd;

        if (dt > end) throw new Error('Invalid time axis configuration');

        while (dt < end) {
            intervalEnd     =  Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt              = intervalEnd;
            i++;
        }
    },


    consumeViewPreset : function (preset) {
        Ext.apply(this, {
            unit                : preset.getBottomHeader().unit,
            increment           : preset.getBottomHeader().increment || 1,

            resolutionUnit      : preset.timeResolution.unit,
            resolutionIncrement : preset.timeResolution.increment,

            mainUnit            : preset.getMainHeader().unit,
            shiftUnit           : preset.shiftUnit,
            shiftIncrement      : preset.shiftIncrement || 1,

            defaultSpan         : preset.defaultSpan || 1,
            presetName          : preset.name,

            // Weekview columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig        : preset.headerConfig
        });
    }
});
