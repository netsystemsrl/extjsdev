Ext.define('Robo.util.Array', {
    singleton: true,
    reduce: function(array, reduceFn, initialValue) {
        array = Object(array);
        if (!Ext.isFunction(reduceFn)) {
            Ext.raise('Invalid parameter: expected a function.');
        }
        var index = 0,
            length = array.length >>> 0,
            reduced = initialValue;
        if (arguments.length < 3) {
            while (true) {
                if (index in array) {
                    reduced = array[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
            }
        }
        for (; index < length; ++index) {
            if (index in array) {
                reduced = reduceFn(reduced, array[index], index, array);
            }
        }
        return reduced;
    }
});

/**
 @class Robo.Transaction

 This class encapsulates a single undo/redo transaction used with the {@link Robo.Manager}.

 Transaction consists from at least one action {@link Robo.action.Base}

 */
Ext.define('Robo.Transaction', {
    actions: null,
    /**
     * @cfg {String} title
     *
     * A human-readable name for this transaction.
     */
    title: null,
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        this.callParent([
            config
        ]);
        this.actions = [];
    },
    /**
     * Checks wheither a transaction has any actions recorded
     *
     * @return {Boolean}
     */
    hasActions: function() {
        return this.actions.length > 0;
    },
    addAction: function(action) {
        this.actions.push(action);
    },
    getActions: function() {
        return this.actions;
    },
    /**
     * Undoes this transaction. Generally should not be called directly.
     */
    undo: function() {
        for (var i = this.actions.length - 1; i >= 0; i--) {
            this.actions[i].undo();
        }
    },
    /**
     * Redoes this transaction. Generally should not be called directly.
     */
    redo: function() {
        for (var i = 0; i < this.actions.length; i++) {
            this.actions[i].redo();
        }
    },
    /**
     * Returns the title for this transaction. If not provided explicitly, a title of the first action is returned.
     *
     * @return {String}
     */
    getTitle: function() {
        if (this.title)  {
            return this.title;
        }
        
        var firstAction = this.actions[0];
        return firstAction ? firstAction.getTitle() : null;
    }
});

/**
 @class Robo.data.Model

 This is a mixin for your models, enabling integration with the Robo undo/redo framework.
 It should be included in your model classes as any other mixin:

 Ext.define('Example.model.Branch', {
        extend      : 'Ext.data.Model',

        mixins      : { robo : 'Robo.data.Model' },

        ...
    });

 You might want to define an additional method {@link #getTitle} in your models. It will be used to build
 a transaction {@link Robo.Transaction#getTitle title}.

 */
Ext.define('Robo.data.Model', {
    extend: 'Ext.Mixin',
    /**
     * @cfg modelName
     *
     * Human readable name for transaction titles. Should be defined at the class level. This can be used
     * to build a simplified transaction title, including this "modelName" and model id.
     *
     * For detailed control of transaction titles, see {@link #getTitle} method.
     */
    modelName: null,
    editMementoFix: null,
    mixinConfig: {
        before: {
            endEdit: 'onBeforeEndEdit'
        },
        after: {
            endEdit: 'onAfterEndEdit'
        }
    },
    // Fix for the incorrect behavior of the "previousValues" implementation in ExtJS
    onBeforeEndEdit: function(silent, modifiedFieldNames) {
        var editMemento = this.editMemento;
        if (editMemento) {
            this.editMementoFix = editMemento;
            if (!modifiedFieldNames) {
                modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
            }
            if (!editMemento.previousValues)  {
                editMemento.previousValues = {};
            }
            
            Ext.Array.each(modifiedFieldNames, function(fieldName) {
                editMemento.previousValues[fieldName] = editMemento.data[fieldName];
            });
        }
    },
    onAfterEndEdit: function(silent, modifiedFieldNames) {
        delete this.editMementoFix;
    },
    /**
     * By default this method is empty, but you can override it in your models, to return a human-readable
     * title of this model instance. String should (probably) include the id of the record,
     * along with some additional information.
     *
     * For example, for the employee model you might want to return the id, first name and last name
     * (or any other important fields).
     *

     Ext.define('Example.model.Employee', {
        extend      : 'Ext.data.Model',
        mixins      : { robo : 'Robo.data.Model' },

        ...

        getTitle : function () {
            return (this.get('firstName') || '') + ' ' + (this.get('lastName') || '') + " (" + this.getId() + ")"
        }
    });

     *
     * @return {String}
     */
    getTitle: function() {
        return '';
    }
});

/**
 @class Robo.action.Base

 Base class for actions - entities that represents a change in a managed store.

 */
Ext.define('Robo.action.Base', {
    constructor: function(config) {
        Ext.apply(this, config);
    },
    undo: function() {
        throw new Error('Abstract method call');
    },
    redo: function() {
        throw new Error('Abstract method call');
    },
    getTitle: function() {
        return '';
    },
    prepareRecord: function(record) {
        // It is enough to make record phantom for it to appear in the new records array (given that record is valid)
        record.phantom = true;
        // If record (task) has phantomIdField defined - fill it with current id. That will make loaded tasks appear as
        // phantom for CRUD backend
        if (record.phantomIdField) {
            record.data[record.phantomIdField] = record.getId();
        }
        return record;
    }
});

Ext.define('Robo.action.flat.Update', {
    extend: 'Robo.action.Base',
    requires: [
        'Ext.Array'
    ],
    inheritableStatics: {
        CUSTOMLY_PROCESSED: {}
    },
    config: {
        record: null,
        fieldNames: null
    },
    oldValues: null,
    newValues: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.initConfig(config);
        me.saveValues();
    },
    saveValues: function() {
        var me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames();
        if (fieldNames) {
            me.oldValues = Ext.Array.map(fieldNames, function(fieldName) {
                return me.processSavingOldValue(fieldName, record);
            });
            me.newValues = Ext.Array.map(fieldNames, function(fieldName) {
                return me.processSavingNewValue(fieldName, record);
            });
        }
    },
    undo: function() {
        var CPM,
            me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames(),
            setObj;
        if (fieldNames) {
            CPM = me.self.CUSTOMLY_PROCESSED;
            record.beginEdit();
            setObj = Robo.util.Array.reduce(fieldNames, function(prev, curr, i) {
                var processedVal;
                // we'll be a bit defensive
                if (curr) {
                    processedVal = me.processRestoringValue(me.oldValues[i], curr, record, 'undo');
                    if (processedVal !== CPM) {
                        prev[curr] = processedVal;
                    }
                }
                return prev;
            }, {});
            record.set(setObj);
            record.endEdit();
        }
    },
    redo: function() {
        var CPM,
            me = this,
            record = me.getRecord(),
            fieldNames = me.getFieldNames(),
            setObj;
        if (fieldNames) {
            CPM = me.self.CUSTOMLY_PROCESSED;
            record.beginEdit();
            setObj = Robo.util.Array.reduce(fieldNames, function(prev, curr, i) {
                var processedVal;
                // we'll be a bit defensive
                if (curr) {
                    processedVal = me.processRestoringValue(me.newValues[i], curr, record, 'redo');
                    if (processedVal !== CPM) {
                        prev[curr] = processedVal;
                    }
                }
                return prev;
            }, {});
            record.set(setObj);
            record.endEdit();
        }
    },
    /**
     * @method
     */
    processSavingOldValue: function(fieldName, record) {
        //                 our own implementation for Ext4 || Ext6 implementation
        var previousValues = (record.previous && record.previous.hasOwnProperty(fieldName) && record.previous || record.previousValues && record.previousValues.hasOwnProperty(fieldName) && record.previousValues || record.editMementoFix && record.editMementoFix.previousValues && record.editMementoFix.previousValues.hasOwnProperty(fieldName) && record.editMementoFix.previousValues || record.editMementoFix && record.editMementoFix.data && record.editMementoFix.data.hasOwnProperty(fieldName) && record.editMementoFix.data);
        if (!previousValues) {
            throw 'Can not get previous value';
        }
        return previousValues[fieldName];
    },
    /**
     * @method
     */
    processSavingNewValue: function(fieldName, record) {
        return record.get(fieldName);
    },
    /**
     * @method
     */
    processRestoringValue: Ext.identityFn,
    getTitle: function() {
        var record = this.getRecord();
        var fieldNames = this.getFieldNames();
        if (record.getTitle)  {
            return 'Edit of ' + fieldNames[0] + ' for ' + record.getTitle(this);
        }
        
        if (record.modelName)  {
            return 'Edit of ' + record.modelName + ' ' + record.getId();
        }
        
        return '';
    }
});

Ext.define('Robo.action.flat.Add', {
    extend: 'Robo.action.Base',
    store: null,
    records: null,
    index: null,
    autoSync: false,
    undo: function() {
        var records = this.records;
        this.store.remove(records);
        // We should only interfere with store's removed property when changes are not synced automatically. If they are,
        // we will remove record from `removed` property, telling store that record should not be sent to server as deleted
        if (!this.autoSync) {
            for (var i = 0; i < records.length; i++) {
                this.store.removeFromRemoved(records[i]);
            }
        }
    },
    redo: function() {
        // When adding records back to the store we should prepare them to make them appear new
        if (this.autoSync) {
            this.records = Ext.Array.map(this.records, this.prepareRecord);
        }
        this.store.insert(this.index, this.records);
    },
    getRecord: function() {
        return this.records[0];
    },
    getTitle: function() {
        var me = this;
        var titles = Ext.Array.map(this.records, function(record) {
                if (record.getTitle)  {
                    return record.getTitle(me);
                }
                
                if (record.modelName)  {
                    return record.modelName + ' ' + record.getId();
                }
                
                return 'unknown';
            });
        return 'Addition of ' + titles.join(',');
    }
});

Ext.define('Robo.action.flat.Remove', {
    extend: 'Robo.action.Base',
    store: null,
    records: null,
    index: null,
    autoSync: false,
    undo: function() {
        var me = this;
        // See comment in action.flat.Add#redo
        if (me.autoSync) {
            me.records = Ext.Array.map(me.records, me.prepareRecord);
        }
        me.store.insert(me.index, me.records);
    },
    redo: function() {
        var me = this;
        me.store.remove(me.records);
    },
    getRecord: function() {
        return this.records[0];
    },
    getTitle: function() {
        var me = this;
        var titles = Ext.Array.map(this.records, function(record) {
                if (record.getTitle)  {
                    return record.getTitle(me);
                }
                
                if (record.modelName)  {
                    return record.modelName + ' ' + record.getId();
                }
                
                return 'unknown';
            });
        return 'Removal of ' + titles.join(',');
    }
});

Ext.define('Robo.action.tree.Append', {
    extend: 'Robo.action.Base',
    parent: null,
    newChild: null,
    autoSync: false,
    undo: function() {
        var newChild = this.newChild;
        this.parent.removeChild(newChild);
        delete newChild.data.lastParentId;
        // See comment in action.flat.Add#undo
        if (!this.autoSync) {
            Ext.Array.remove(this.parent.getTreeStore().removedNodes, newChild);
        }
    },
    redo: function() {
        // See comment in action.flat.Add#redo
        if (this.autoSync) {
            this.newChild = this.prepareRecord(this.newChild);
        }
        this.parent.appendChild(this.newChild);
    },
    getRecord: function() {
        return this.newChild;
    },
    getTitle: function() {
        var record = this.newChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + ' ' + record.getId();
        }
        
        return 'Append of ' + title;
    }
});

Ext.define('Robo.action.tree.Insert', {
    extend: 'Robo.action.Base',
    parent: null,
    newChild: null,
    insertedBefore: null,
    autoSync: false,
    undo: function() {
        var newChild = this.newChild;
        this.parent.removeChild(newChild);
        delete newChild.data.lastParentId;
        // See comment in action.flat.Add#undo
        if (!this.autoSync) {
            Ext.Array.remove(this.parent.getTreeStore().removedNodes, newChild);
        }
    },
    redo: function() {
        var insertedBefore = this.insertedBefore,
            insertedAsFirst = insertedBefore && insertedBefore.isFirst();
        // See comment in action.flat.Add#redo
        if (this.autoSync) {
            this.newChild = this.prepareRecord(this.newChild);
        }
        this.parent.insertBefore(this.newChild, insertedBefore);
        // https://www.sencha.com/forum/showthread.php?308814-6.0.1-quot-isFirst-quot-field-is-not-updated-correctly-after-the-child-node-insertion&p=1127985#post1127985
        if (insertedAsFirst)  {
            insertedBefore.updateInfo(false, {
                isFirst: false
            });
        }
        
    },
    getRecord: function() {
        return this.newChild;
    },
    getTitle: function() {
        var record = this.newChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + ' ' + record.getId();
        }
        
        return 'Insertion of ' + title;
    }
});

Ext.define('Robo.action.tree.Remove', {
    extend: 'Robo.action.Base',
    parent: null,
    removedChild: null,
    nextSibling: null,
    newParent: null,
    newNextSibling: null,
    dirty: false,
    isMove: false,
    autoSync: false,
    constructor: function(config) {
        this.callParent(arguments);
        this.dirty = this.removedChild.dirty;
    },
    undo: function() {
        var me = this;
        if (me.isMove) {
            me.newParent = me.removedChild.parentNode;
            me.newNextSibling = me.removedChild.nextSibling;
        }
        var nextSibling = me.nextSibling;
        var insertedAsFirst = nextSibling && nextSibling.isFirst();
        if (!me.isMove && me.autoSync) {
            me.removedChild = me.prepareRecord(me.removedChild);
        }
        var removedChild = me.removedChild;
        me.parent.insertBefore(removedChild, nextSibling);
        removedChild.dirty = me.dirty;
        if (!me.isMove && !me.autoSync) {
            var store = removedChild.getTreeStore();
            removedChild.cascadeBy(function(node) {
                Ext.Array.remove(store.removedNodes, node);
            });
        }
        if (insertedAsFirst)  {
            nextSibling.updateInfo(false, {
                isFirst: false
            });
        }
        
    },
    redo: function() {
        if (this.isMove) {
            var newNextSibling = this.newNextSibling;
            var insertedAsFirst = newNextSibling && newNextSibling.isFirst();
            this.newParent.insertBefore(this.removedChild, newNextSibling);
            // https://www.sencha.com/forum/showthread.php?308814-6.0.1-quot-isFirst-quot-field-is-not-updated-correctly-after-the-child-node-insertion&p=1127985#post1127985
            if (insertedAsFirst)  {
                newNextSibling.updateInfo(false, {
                    isFirst: false
                });
            }
            
        } else {
            this.parent.removeChild(this.removedChild);
            delete this.removedChild.data.lastParentId;
        }
    },
    getRecord: function() {
        return this.removedChild;
    },
    getTitle: function() {
        var record = this.removedChild;
        var title;
        if (record.getTitle)  {
            title = record.getTitle(this);
        }
        else if (record.modelName)  {
            return record.modelName + ' ' + record.getId();
        }
        
        return this.isMove ? 'Move of ' + title : 'Removal of ' + title;
    }
});

Ext.define('Robo.action.tree.Update', {
    extend: 'Robo.action.flat.Update',
    // Ext JS UI doesn't react to record.set('expanded', false). Need to call API methods for this field
    processRestoringValue: function(value, fieldName, record, op) {
        var me = this;
        if (fieldName === 'expanded') {
            if (value) {
                record.expand();
            } else {
                record.collapse();
            }
            value = me.self.CUSTOMLY_PROCESSED;
        } else if (fieldName == 'leaf') {
            value = me.callParent(arguments);
            if (value === true && op == 'undo')  {
                record.data.loaded = false;
            }
            
        } else {
            value = me.callParent(arguments);
        }
        return value;
    }
});

/**
 * @class Robo.Manager
 * @extends Ext.util.Observable
 *
 * This is the main class that provides undo-redo capabilities for an array of {@link Ext.data.Store} instances.
 * To enable undo support, simply create a Robo.Manager instance and configure it with your stores:
 *
 * ```
 * var yourStore1  = new Ext.data.Store({ ... });
 * var yourStore2  = new Ext.data.TreeStore({ ... });
 *
 * var robo        = new Robo.Manager({
 *        stores              : [ yourStore1, yourStore2 ]
 *    });
 *
 * // start monitoring
 * robo.start();
 * ```
 *
 * See also {@link Robo.data.Model} and {@link Robo.data.Store} mixins - they need to be mixed into your models and stores.
 *
 * By default, Robo uses timeout-based transactions (see {@link #transactionBoundary}). So all changes during {@link #transactionMaxDuration}
 * ms will be batched into a single transaction:
 *
 * ```
 * // in some button handler, several changes are batched in single transaction
 * yourStore.getAt(0).set('name', 'a new name');
 * yourStore.getAt(1).set('value', 'a new value');
 *
 * // user clicks the `undo` button after some time
 * // whole transaction is reverted
 * robo.undo();
 * ```
 */
Ext.define('Robo.Manager', {
    extend: 'Ext.util.Observable',
    requires: [
        'Robo.util.Array',
        'Robo.Transaction',
        'Robo.data.Model',
        'Robo.action.flat.Update',
        'Robo.action.flat.Add',
        'Robo.action.flat.Remove',
        'Robo.action.tree.Append',
        'Robo.action.tree.Insert',
        'Robo.action.tree.Remove',
        'Robo.action.tree.Update',
        'Ext.data.Store',
        'Ext.data.StoreManager'
    ],
    /**
     * @cfg {Ext.data.Store[]} stores An array of stores to be managed by the Robo
     */
    stores: null,
    storesById: null,
    /**
     * @cfg {Boolean} autoSync Pass true to avoid messing with added/removed properties on store. Useful when
     * crudManager or store is configured with autoSync : true
     */
    autoSync: false,
    treeStoreListeners: null,
    flatStoreListeners: null,
    stub: function() {},
    undoQueue: null,
    redoQueue: null,
    ignoredFieldNames: {
        // Tree store view state should not be considered 'data' to be tracked
        expanded: 1
    },
    // one of the 'created', 'enabled', 'disabled', 'paused', 'hold'
    state: 'created',
    /**
     * @cfg {String} transactionBoundary
     *
     * Transaction boundary mode, either 'manual' or 'timeout'.
     *
     * In the 'timeout' mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
     * records any changes in its monitored stores. The transaction lasts for {@link #transactionMaxDuration} and
     * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
     *
     * In 'manual' mode you have to call {@link #startTransaction} / {@link #endTransaction} to start and end
     * a transaction. Note, that in this mode a change in any tracked store will start a transaction automatically,
     * so you will need to issue a finalizing {@link #endTransaction} call manually.
     */
    transactionBoundary: 'timeout',
    /**
     * @cfg {Number} transactionMaxDuration
     *
     * The transaction duration (in ms) for the 'manual' {@link #transactionBoundary transaction boundary}
     */
    transactionMaxDuration: 100,
    /**
     * @cfg {Boolean} clearQueuesOnLoad
     *
     * True to automatically clear the queues upon 'load' and 'clear' events on any of the stores monitored
     */
    clearQueuesOnLoad: false,
    transactionTimeout: null,
    currentTransaction: null,
    /**
     * @event start Fired when the undo manager starts recording events
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event stop Fired after the undo manager has stopped recording events
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event transactionadd
     *
     * @param {Robo.Manager} this
     * @param {Robo.Transaction} transaction
     */
    /**
     * @event undoqueuechange
     *
     * @param {Robo.Manager} this
     * @param {[Robo.Transaction]} undoQueue
     */
    /**
     * @event redoqueuechange
     *
     * @param {Robo.Manager} this
     * @param {[Robo.Transaction]} redoQueue
     */
    /**
     * @event beforeundo Fired before an undo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event afterundo Fired after an undo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event beforeredo Fired before a redo operation
     *
     * @param {Robo.Manager} this
     */
    /**
     * @event afterredo Fired after a redo operation
     *
     * @param {Robo.Manager} this
     */
    constructor: function(config) {
        var me = this;
        config = config || {};
        Ext.apply(me, config);
        me.treeStoreListeners = {
            nodeappend: me.onTreeStoreAppend,
            nodeinsert: me.onTreeStoreInsert,
            noderemove: me.onTreeStoreRemove,
            update: me.onTreeStoreUpdate,
            'robo-command': me.onIncomingCommand,
            scope: me
        };
        me.flatStoreListeners = {
            add: me.onFlatStoreAdd,
            remove: me.onFlatStoreRemove,
            update: me.onFlatStoreUpdate,
            'robo-command': me.onIncomingCommand,
            scope: me
        };
        if (me.clearQueuesOnLoad) {
            Ext.apply(me.treeStoreListeners, {
                load: me.clearQueues,
                clear: me.clearQueues
            });
            Ext.apply(me.flatStoreListeners, {
                load: me.clearQueues,
                clear: me.clearQueues
            });
        }
        me.callParent([
            config
        ]);
        var myStores = me.stores || [];
        me.stores = [];
        me.storesById = {};
        me.undoQueue = [];
        me.redoQueue = [];
        Ext.Array.forEach(myStores, function(store) {
            me.addStore(store);
        });
    },
    /**
     * Adds a store to the list of managed stores
     *
     * @param {Ext.data.Store/String} store A data store or a 'storeId' identifier
     */
    addStore: function(store, id) {
        store = Ext.data.StoreManager.lookup(store);
        Ext.Assert && Ext.Assert.isObject(store, 'Must provide a store or a valid store id');
        this.stores.push(store);
        if (id)  {
            store.setStoreId(id);
        }
        
        var model = store.getModel();
        var associations = model.prototype.associations || {};
        for (var roleName in associations) {
            var role = associations[roleName];
            var old = role.getAssociatedStore;
            if (old && (!role.ROBO_MANAGED || !role.ROBO_MANAGED[this.getId()])) {
                var me = this;
                role.getAssociatedStore = function() {
                    var store = old.apply(this, arguments);
                    if (!me.hasStore(store)) {
                        me.addStore(store);
                        if (me.state !== 'disabled' && me.state !== 'created') {
                            me.bindStore(store);
                        }
                    }
                    return store;
                };
                role.ROBO_MANAGED = role.ROBO_MANAGED || {};
                role.ROBO_MANAGED[this.getId()] = me;
            }
        }
        if (store.storeId) {
            this.storesById[store.storeId] = store;
        }
    },
    /**
     * Gets a store from the managed store list by its id
     *
     * @param {String} id
     * @return {Ext.data.Store}
     */
    getStoreById: function(id) {
        return this.storesById[id];
    },
    hasStore: function(store) {
        return Ext.Array.indexOf(this.stores, store) !== -1;
    },
    bindStore: function(store) {
        (store.undoRedoEventBus || store).on(this.getStoreTypeListeners(store));
        // subscribe to the stubs (empty functions) to fill the "hasListeners" cache of the store
        // this is to enable events propagation in tree store, in which event first bubbles through the
        // nodes (to the root) and then is fired on the store itself (if the "hasListeners" check passes)
        if (store.undoRedoEventBus)  {
            store.on(this.getStoreTypeListenerStubs(store));
        }
        
    },
    unbindStore: function(store) {
        (store.undoRedoEventBus || store).un(this.getStoreTypeListeners(store));
        if (store.undoRedoEventBus)  {
            store.un(this.getStoreTypeListenerStubs(store));
        }
        
    },
    getStoreTypeListenerStubs: function(store) {
        var me = this;
        var listeners = this.getStoreTypeListeners(store);
        listeners = Ext.apply({}, listeners);
        Ext.Object.each(listeners, function(key) {
            listeners[key] = me.stub;
        });
        return listeners;
    },
    /**
     * Returns the listeners object to use with a particular store type
     *
     * @param {Ext.data.Store} store
     * @return {Object}
     *
     * @protected
     */
    getStoreTypeListeners: function(store) {
        var listeners;
        if (Ext.data.TreeStore && store instanceof Ext.data.TreeStore) {
            listeners = this.treeStoreListeners;
        } else {
            listeners = this.flatStoreListeners;
        }
        return listeners;
    },
    /**
     * Removes a store from the list of managed stores
     *
     * @param {Ext.data.Store} store
     */
    removeStore: function(store) {
        Ext.Array.remove(this.stores, store);
        this.storesById[store.storeId] = null;
        this.unbindStore(store);
    },
    forEachStore: function(func) {
        Ext.Array.forEach(this.stores, func, this);
    },
    onAnyChangeInAnyStore: function(store) {
        if (this.state === 'paused' || (store.isRootSettingOrLoading && store.isRootSettingOrLoading())) {
            return false;
        }
        if (!this.currentTransaction) {
            this.startTransaction();
        }
        return true;
    },
    hasPersistableChanges: function(record, modifiedFieldNames) {
        var ignored = this.ignoredFieldNames;
        return Robo.util.Array.reduce(modifiedFieldNames, function(result, field) {
            var fieldInstance = record.getField(field);
            return result || !fieldInstance || (fieldInstance.persist && !ignored.hasOwnProperty(field));
        }, false);
    },
    onIncomingCommand: function(store, command, args) {
        args = args || [];
        var me = this;
        if (me.areIncomingCommandsEnabled()) {
            switch (command) {
                case 'pause':
                case 'resume':
                case 'endTransaction':
                case 'startTransaction':
                case 'addTransaction':
                    me[command].apply(me, args);
                    break;
            }
        }
    },
    incomingCommandsDisabled: 0,
    areIncomingCommandsEnabled: function() {
        return !this.incomingCommandsDisabled;
    },
    disableIncomingCommands: function() {
        this.incomingCommandsDisabled++;
    },
    enableIncomingCommands: function() {
        this.incomingCommandsDisabled--;
    },
    onFlatStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        var me = this;
        if (!me.onAnyChangeInAnyStore(store) || operation !== 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !me.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        me.currentTransaction.addAction(new Robo.action.flat.Update({
            record: record,
            fieldNames: modifiedFieldNames.filter(function(field) {
                return !(field in me.ignoredFieldNames);
            })
        }));
    },
    onFlatStoreAdd: function(store, records, index) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.flat.Add({
            autoSync: this.autoSync,
            store: store,
            records: records,
            index: index
        }));
    },
    onFlatStoreRemove: function(store, records, index, isMove) {
        if (!this.onAnyChangeInAnyStore(store)) {
            return;
        }
        this.currentTransaction.addAction(new Robo.action.flat.Remove({
            autoSync: this.autoSync,
            store: store,
            records: records,
            index: index,
            isMove: isMove
        }));
    },
    onTreeStoreUpdate: function(store, record, operation, modifiedFieldNames) {
        var me = this;
        if (!me.onAnyChangeInAnyStore(store) || operation !== 'edit' || !modifiedFieldNames || !modifiedFieldNames.length || !me.hasPersistableChanges(record, modifiedFieldNames)) {
            return;
        }
        me.currentTransaction.addAction(new Robo.action.tree.Update({
            record: record,
            fieldNames: modifiedFieldNames.filter(function(field) {
                return !(field in me.ignoredFieldNames);
            })
        }));
    },
    onTreeStoreAppend: function(parent, newChild) {
        if (!parent || !this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (newChild.$undoRedoMoving && newChild.$undoRedoMoving[this.getId()]) {
            delete newChild.$undoRedoMoving[this.getId()];
        } else {
            this.currentTransaction.addAction(new Robo.action.tree.Append({
                autoSync: this.autoSync,
                parent: parent,
                newChild: newChild
            }));
        }
    },
    onTreeStoreInsert: function(parent, newChild, insertedBefore) {
        // Don't react to root loading
        if (!parent || !this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (newChild.$undoRedoMoving && newChild.$undoRedoMoving[this.getId()]) {
            delete newChild.$undoRedoMoving[this.getId()];
        } else {
            this.currentTransaction.addAction(new Robo.action.tree.Insert({
                autoSync: this.autoSync,
                parent: parent,
                newChild: newChild,
                insertedBefore: insertedBefore
            }));
        }
    },
    onTreeStoreRemove: function(parent, removedChild, isMove, context) {
        if (!parent || !this.onAnyChangeInAnyStore(parent.getTreeStore())) {
            return;
        }
        if (isMove) {
            removedChild.$undoRedoMoving = removedChild.$undoRedoMoving || {};
            removedChild.$undoRedoMoving[this.getId()] = true;
        }
        this.currentTransaction.addAction(new Robo.action.tree.Remove({
            autoSync: this.autoSync,
            parent: parent,
            removedChild: removedChild,
            nextSibling: context.nextSibling,
            isMove: isMove
        }));
    },
    /**
     * Starts the undo/redo monitoring.
     */
    start: function() {
        // when we start first time - fire events to notify the possibly listening UI about our current state
        if (this.state === 'created' || this.state === 'disabled') {
            this.fireEvent('start', this);
            this.fireEvent('undoqueuechange', this, this.undoQueue);
            this.fireEvent('redoqueuechange', this, this.redoQueue);
        }
        if (this.state !== 'hold') {
            this.forEachStore(this.bindStore);
            this.state = 'enabled';
        }
    },
    /**
     * Stops the undo/redo monitoring and clears any recorded transactions (since we cannot guarantee correct
     * undo or redo after monitoring has stopped).
     */
    stop: function() {
        this.endTransaction();
        this.forEachStore(this.unbindStore);
        this.state = 'disabled';
        this.clearQueues();
        this.fireEvent('stop', this);
    },
    /**
     * Clears the undo and redo queues.
     */
    clearQueues: function() {
        this.clearUndoQueue();
        this.clearRedoQueue();
    },
    // @protected
    pause: function() {
        this.state = 'paused';
    },
    // @protected
    resume: function() {
        this.state = 'enabled';
    },
    // @protected
    hold: function() {
        Ext.Assert && Ext.Assert.isObject(this.currentTransaction, 'Can\'t hold, no transaction is currently in progress');
        this.state = 'hold';
    },
    // @protected
    release: function() {
        Ext.Assert && Ext.Assert.isObject(this.currentTransaction, 'Can\'t release, no transaction is currently in progress');
        this.state = 'enabled';
    },
    /**
     * Gets the undo queue
     *
     * @return {Robo.Transaction[]}
     */
    getUndoQueue: function() {
        return this.undoQueue.slice();
    },
    /**
     * Gets the redo queue
     *
     * @return {Robo.Transaction[]}
     */
    getRedoQueue: function() {
        return this.redoQueue.slice();
    },
    clearUndoQueue: function() {
        if (this.undoQueue.length) {
            this.undoQueue = [];
            this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        }
    },
    clearRedoQueue: function() {
        if (this.redoQueue.length) {
            this.redoQueue = [];
            this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        }
    },
    /**
     * Starts a new undo/redo transaction.
     *
     * @param {String} [title] Transaction title
     */
    startTransaction: function(title) {
        var me = this,
            transaction;
        if (me.state === 'disabled') {
            return;
        }
        if (me.currentTransaction) {
            me.endTransaction();
        }
        transaction = new Robo.Transaction({
            title: title
        });
        me.currentTransaction = transaction;
        me.notifyStoresAboutTransactionStart(transaction);
        if (me.transactionBoundary === 'timeout') {
            me.scheduleEndTransaction();
        }
    },
    scheduleEndTransaction: function() {
        var me = this;
        if (me.transactionTimeout) {
            clearTimeout(me.transactionTimeout);
        }
        me.transactionTimeout = setTimeout(function() {
            if (me.state !== 'hold') {
                me.endTransaction();
                me.transactionTimeout = null;
            } else {
                me.scheduleEndTransaction();
            }
        }, me.transactionMaxDuration);
    },
    /**
     * Ends the current undo/redo transaction.
     */
    endTransaction: function() {
        var me = this,
            currentTransaction = me.currentTransaction;
        if (!currentTransaction) {
            return false;
        }
        me.currentTransaction = null;
        if (me.transactionBoundary === 'timeout') {
            clearTimeout(me.transactionTimeout);
            me.transactionTimeout = null;
        }
        if (currentTransaction.hasActions()) {
            me.addTransaction(currentTransaction);
        }
        me.notifyStoresAboutTransactionEnd(currentTransaction);
        return currentTransaction.hasActions();
    },
    addTransaction: function(transaction) {
        this.undoQueue.push(transaction);
        this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        if (this.redoQueue.length) {
            this.redoQueue.length = 0;
            this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        }
        this.fireEvent('transactionadd', this, transaction);
    },
    /**
     * Undoes previously recorded undo/redo transaction(s), amount of transactions defined by the optional parameter.
     *
     * @param {Number} [howMany] The number of transactions to undo. Optional, default value is 1
     */
    undo: function(howMany) {
        var undoQueue = this.undoQueue,
            index, transaction, i,
            l = undoQueue.length;
        if (this.state === 'disabled' || howMany === 0 || !undoQueue.length) {
            return;
        }
        // is this feature used anywhere? probably unnesessary complication
        if (howMany instanceof Robo.Transaction) {
            index = Ext.Array.indexOf(undoQueue, howMany);
            if (index === -1) {
                return;
            }
            howMany = undoQueue.length - index;
        }
        howMany = howMany || 1;
        this.fireEvent('beforeundo', this);
        this.pause();
        this.notifyStoresAboutUndoRedoStart();
        for (i = 0; i < Math.min(howMany, l); i++) {
            transaction = undoQueue.pop();
            transaction.undo();
            this.redoQueue.unshift(transaction);
        }
        this.notifyStoresAboutUndoRedoComplete();
        this.fireEvent('undoqueuechange', this, undoQueue.slice());
        this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        this.resume();
        this.fireEvent('afterundo', this);
    },
    /**
     * Redoes previously recorded undo/redo transaction(s), amount of transactions defined by the optional parameter.
     *
     * @param {Number} [howMany] how many transactions to redo. Optional, default value is 1
     */
    redo: function(howMany) {
        var redoQueue = this.redoQueue,
            transaction, index, i,
            l = redoQueue.length;
        if (this.state === 'disabled' || howMany === 0 || !redoQueue.length) {
            return;
        }
        // is this feature used anywhere? probably unnesessary complication
        if (howMany instanceof Robo.Transaction) {
            index = Ext.Array.indexOf(redoQueue, howMany);
            if (index === -1) {
                return;
            }
            howMany = index + 1;
        }
        howMany = howMany || 1;
        this.fireEvent('beforeredo', this);
        this.pause();
        this.notifyStoresAboutUndoRedoStart();
        for (i = 0; i < Math.min(howMany, l); i++) {
            transaction = this.redoQueue.shift();
            transaction.redo();
            this.undoQueue.push(transaction);
        }
        this.notifyStoresAboutUndoRedoComplete();
        this.fireEvent('redoqueuechange', this, this.redoQueue.slice());
        this.fireEvent('undoqueuechange', this, this.undoQueue.slice());
        this.resume();
        this.fireEvent('afterredo', this);
    },
    /**
     * Undoes all previously recorded transactions
     */
    undoAll: function() {
        this.undo(this.undoQueue.length);
    },
    /**
     * Redoes all previously recorded transactions
     */
    redoAll: function() {
        this.redo(this.redoQueue.length);
    },
    notifyStoresAboutTransactionStart: function(transaction) {
        this.forEachStore(function(store) {
            store.onUndoRedoTransactionStart && store.onUndoRedoTransactionStart(this, transaction);
        });
    },
    notifyStoresAboutTransactionEnd: function(transaction) {
        this.forEachStore(function(store) {
            store.onUndoRedoTransactionEnd && store.onUndoRedoTransactionEnd(this, transaction);
        });
    },
    notifyStoresAboutUndoRedoStart: function() {
        this.forEachStore(function(store) {
            store.beforeUndoRedo && store.beforeUndoRedo(this);
        });
    },
    notifyStoresAboutUndoRedoComplete: function() {
        this.forEachStore(function(store) {
            store.afterUndoRedo && store.afterUndoRedo(this);
        });
    }
}, function() {
    Ext.apply(Robo, {
        VERSION: '6.1.17'
    });
});

/**
 @class Robo.data.Store

 This is a mixin for your data stores, enabling integration with the Robo undo/redo framework.
 It should be included in your store classes as any other mixin:

 Ext.define('Example.store.Branch', {
        extend      : 'Ext.data.Store',

        mixins      : { robo : 'Robo.data.Store' },

        ...
    });

 With this mixin, {@link Robo.Manager} will call various "hook" methods of the store, notifying it about
 the current state of the data flow, like {@link #beforeUndoRedo}, {@link #afterUndoRedo}.

 The Store might override those methods, for example to turn off/on cache recalculation or other additional
 processing during the execution of the transaction.

 */
Ext.define('Robo.data.Store', {
    extend: 'Ext.Mixin',
    requires: [
        'Ext.util.Observable'
    ],
    undoRedoPostponed: null,
    inUndoRedoTransaction: false,
    undoRedoEventBus: null,
    /**
     * This is an important part of undo/redo management, it allows an undo/redo manager to always be notified about
     * low-level events of a store.
     */
    mixinConfig: {
        before: {
            constructor: 'constructor',
            destroy: 'destroy',
            fireEventArgs: 'fireEventArgs',
            setRoot: 'beforeSetRoot',
            fillNode: 'beforeFillNode'
        },
        after: {
            setRoot: 'afterSetRoot',
            fillNode: 'afterFillNode'
        }
    },
    constructor: function() {
        var me = this;
        me.undoRedoEventBus = new Ext.util.Observable();
    },
    destroy: function() {
        Ext.destroy(this.undoRedoEventBus);
    },
    fireEventArgs: function(eventName, args) {
        var me = this;
        // HACK:
        // Args is an array (i.e. passes by reference) we will use it to mark it as being fired already
        // by undo/redo event bus by adding a private property to it, otherwise we will be firing the same event
        // twice if/when the event is suspended on the original bus, queued and then fired again upon resuming.
        // Since the same args array might be used several times (in 'before' event and 'normal' event, for example),
        // we do not use just boolean flag, instead we use a map with event names as keys.
        if (!args.hasOwnProperty('$undoRedoEventBusFired')) {
            args.$undoRedoEventBusFired = {};
        }
        if (!args.$undoRedoEventBusFired[eventName]) {
            args.$undoRedoEventBusFired[eventName] = true;
            me.undoRedoEventBus.hasListener(eventName) && me.undoRedoEventBus.fireEventArgs(eventName, args);
        }
    },
    /**
     * Checks whether an undo/redo transaction is currently in progress. Not to be confused
     * with the {@link #isUndoingOrRedoing}
     *
     * @return {Boolean}
     */
    isInUndoRedoTransaction: function() {
        return this.inUndoRedoTransaction;
    },
    /**
     * Called by undo/redo manager when starting a new undo/redo transaction
     *
     * @param {Robo.Manager} manager
     * @param {Robo.Transaction} transaction
     */
    onUndoRedoTransactionStart: function(manager, transaction) {
        this.inUndoRedoTransaction = true;
    },
    /**
     * Called by undo/redo manager when finishing an undo/redo transaction
     *
     * @param {Robo.Manager} manager
     * @param {Robo.Transaction} transaction
     */
    onUndoRedoTransactionEnd: function(manager, transaction) {
        this.inUndoRedoTransaction = false;
    },
    /**
     * Checks wheither a previously recorded undo/redo transaction is being rolled back or replayed.
     *
     * @return {Boolean}
     */
    isUndoingOrRedoing: function() {
        return !!this.undoRedoPostponed;
    },
    /**
     * Called by undo manager before executing a previously recorded undo/redo transaction
     *
     * @param {Robo.Manager} manager
     */
    beforeUndoRedo: function(manager) {
        this.undoRedoPostponed = [];
    },
    /**
     * Called by undo manager after executing a previously recorded undo/redo transaction
     *
     * @param {Robo.Manager} manager
     */
    afterUndoRedo: function(manager) {
        var me = this;
        if (me.undoRedoPostponed) {
            Ext.Array.forEach(me.undoRedoPostponed, function(fn) {
                fn();
            });
        }
        me.undoRedoPostponed = null;
    },
    /**
     * Store might use this method to postpone code execution to the moment right before undo/redo transaction is
     * done. The code postponed will be called right before the call to the {@link afterUndoRedo()} method.
     *
     * @param {Function} fn A code to postpone
     */
    postponeAfterUndoRedo: function(fn) {
        Ext.Assert && Ext.Assert.isFunction(fn, 'Parameter must be a function');
        this.undoRedoPostponed.push(fn);
    },
    beforeSetRoot: function() {
        this.__isSettingRoot = true;
    },
    afterSetRoot: function() {
        this.__isSettingRoot = false;
        // https://www.sencha.com/forum/showthread.php?307767-TreeStore-removeAll-doesn-t-fire-quot-clear-quot&p=1124119#post1124119
        if (!this.getRoot()) {
            this.fireEvent('clear', this);
        }
    },
    beforeFillNode: function(node) {
        if (node.isRoot())  {
            this.beforeSetRoot();
        }
        
    },
    afterFillNode: function(node) {
        if (node.isRoot())  {
            this.afterSetRoot();
        }
        
    },
    /**
     * Returns true if this store is in process of loading/filling the root node
     *
     * @return {Boolean}
     */
    isRootSettingOrLoading: function() {
        return this.isLoading() || (this.isTreeStore && this.__isSettingRoot);
    }
});

/**
 @class Robo.widget.UndoButton

 A subclass of ExtJS split button, integrated with the {@link Robo.Manager} and reflecting the current list of Robo transactions,
 available for "undo".

 See the base class for a list of available config options.

 */
Ext.define('Robo.widget.UndoButton', {
    extend: 'Ext.button.Split',
    alias: 'widget.roboundobutton',
    iconCls: Ext.baseCSSPrefix + 'fa fa-undo',
    /**
     * @cfg {Robo.Manager} robo (required) Robo.Manager instance this button is bound to.
     */
    robo: null,
    transactionList: null,
    type: 'undo',
    text: 'Undo',
    disabled: true,
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        if (!this.robo)  {
            throw new Error('`robo` is a required config for the ' + this.$className);
        }
        
        this.callParent(config);
    },
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            menu: new Ext.menu.Menu({
                cls: 'robo-transaction-list',
                items: this.getTransactionItems(),
                listeners: {
                    click: this.onTransactionClick,
                    scope: this
                }
            })
        });
        this.on('click', function() {
            me.robo[me.type]();
        });
        this.mon(me.robo, me.type + 'queuechange', this.onTransactionQueueChange, this);
        this.callParent();
    },
    onTransactionQueueChange: function(robo, queue) {
        this.setDisabled(queue.length === 0);
        var menu = this.menu;
        menu.removeAll();
        menu.add(this.getTransactionItems());
        if (!queue.length)  {
            menu.hide();
        }
        
    },
    getTransactionItems: function() {
        var me = this;
        var res = Ext.Array.map(this.robo[this.type + 'Queue'], function(transaction) {
                return new Ext.menu.Item({
                    text: transaction.getTitle(),
                    transaction: transaction,
                    listeners: {
                        activate: me.onTransactionItemActivated,
                        deactivate: me.onTransactionItemDeActivated,
                        scope: me
                    }
                });
            });
        if (this.type == 'undo')  {
            res.reverse();
        }
        
        return res;
    },
    onTransactionClick: function(menu, menuItem) {
        if (!menuItem)  {
            return;
        }
        
        this.robo[this.type](menuItem.transaction);
    },
    onTransactionItemActivated: function(activatedItem) {
        this.menu.items.each(function(item) {
            if (item == activatedItem)  {
                return false;
            }
            
            if (item.rendered)  {
                item.el.addCls(item.activeCls);
            }
            
        });
    },
    onTransactionItemDeActivated: function(deActivatedItem) {
        this.menu.items.each(function(item) {
            if (item == deActivatedItem)  {
                return false;
            }
            
            if (item.rendered)  {
                item.el.removeCls(item.activeCls);
            }
            
        });
    }
});

/**
 @class Robo.widget.RedoButton

 A subclass of ExtJS split button, integrated with the {@link Robo.Manager} and reflecting the current list of Robo transactions,
 available for "redo".

 See the base class for a list of available config options.

 */
Ext.define('Robo.widget.RedoButton', {
    extend: 'Robo.widget.UndoButton',
    alias: 'widget.roboredobutton',
    iconCls: Ext.baseCSSPrefix + 'fa fa-repeat fa-redo',
    // fa-redo is available in 7.0
    type: 'redo',
    text: 'Redo'
});

/**
 @class Robo.widget.StatusPanel

 */
Ext.define('Robo.widget.StatusPanel', {
    extend: 'Ext.tree.Panel',
    alias: 'widget.robostatuspanel',
    /**
     * @cfg {Robo.Manager} robo (required) Robo.Manager instance this button is bound to.
     */
    robo: null,
    type: 'undo',
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        if (!this.robo)  {
            throw new Error('`robo` is a required config for the ' + this.$className);
        }
        
        this.callParent(config);
    },
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            rootVisible: false,
            columns: [
                {
                    xtype: 'treecolumn',
                    text: 'Title',
                    dataIndex: 'title',
                    width: 250
                },
                {
                    text: 'Changed fields',
                    dataIndex: 'fieldNames',
                    flex: 1,
                    tdCls: 'fieldnames'
                }
            ],
            store: {
                fields: [
                    'title',
                    'fieldNames',
                    'isActive'
                ]
            },
            viewConfig: {
                getRowClass: Ext.Function.bind(this.getActiveRowClass, this)
            }
        });
        this.mon(me.robo, me.type + 'queuechange', this.onTransactionQueueChange, this);
        this.callParent();
    },
    getActiveRowClass: function(record, rowIndex, rowParams, store) {
        return record.get('isActive') ? 'robo-status-active' : '';
    },
    onTransactionQueueChange: function(robo, queue) {
        var type = this.type;
        var transactions = Ext.Array.map(queue, function(transaction, i) {
                var isActive = type == 'undo' ? i == queue.length - 1 : i === 0;
                return {
                    leaf: false,
                    expanded: true,
                    title: transaction.getTitle(),
                    isActive: isActive,
                    children: Ext.Array.map(transaction.getActions(), function(action) {
                        var record = action.getRecord();
                        return {
                            leaf: true,
                            title: action.getTitle(),
                            fieldNames: action instanceof Robo.action.flat.Update ? action.fieldNames.join(', ') : '',
                            isActive: isActive
                        };
                    })
                };
            });
        this.store.setRootNode({
            expanded: true,
            children: transactions
        });
        this.getView().scrollTo(0, Infinity);
    }
});

/**
 * @class Sch.crud.AbstractManager
 * @abstract
 *
 * This is an abstract class serving as the base for the Sch.data.CrudManager class.
 * It implements basic mechanisms to organize batch communication with a server.
 * Yet it does not contain methods related to _data transfer_ nor _encoding_.
 * These methods are to be provided in sub-classes by consuming the appropriate mixins.
 *
 * For example, this is how the class can be used to implement an XML encoding system:
 *
 * ```javascript
 *     // let's make new CrudManager using AJAX as a transport system and XML for encoding
 *     Ext.define('MyCrudManager', {
 *         extend  : 'Sch.crud.AbstractManager',
 *
 *         mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
 *     });
 * ```
 *
 * # Data transfer and encoding methods
 *
 * Here are the methods that must be provided by subclasses of this class:
 *
 * - {@link #sendRequest}
 * - {@link #cancelRequest}
 * - {@link #encode}
 * - {@link #decode}
 *
 */
Ext.define('Sch.crud.AbstractManager', {
    requires: [
        'Ext.data.StoreManager'
    ],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    isCrudManager: true,
    /**
     * @property {Number} revision
     * @readonly
     * The server revision stamp.
     * The _revision stamp_ is a number which should be incremented after each server-side change.
     * This property reflects the current version of the data retrieved from the server and gets updated after each {@link #load} and {@link #sync} call.
     */
    revision: null,
    /**
     * @property {Object[]} stores
     * A list of registered stores whose server communication will be collected into a single batch.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} stores.storeId Unique store identifier.
     * @property {Ext.data.AbstractStore} stores.store Store itself.
     * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    /**
     * @cfg {Ext.data.AbstractStore[]/String[]/Object[]} stores
     * Sets the list of stores controlled by the CRUD manager.
     * Store can be provided by itself, its storeId or an object having the following structure:
     * @cfg {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
     * @cfg {Ext.data.AbstractStore} stores.store The store itself.
     * @cfg {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
     * @cfg {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    stores: null,
    /**
     * @cfg {String} storeIdProperty Name of a store property to retrieve store identifiers from.
     * Store identifier is used as a container name holding corresponding store data while transferring them to/from the server.
     * By default `storeId` property is used. And in case a container identifier has to differ this config can be used:
     *
     * ```javascript
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON, so we create a new property "storeIdForCrud"
     *         storeId          : 'meow',
     *         storeIdForCrud   : 'cats',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow'],
     *         // crud manager will get store identifier from "storeIdForCrud" property
     *         storeIdProperty  : 'storeIdForCrud'
     *     });
     * ```
     * The `storeIdProperty` property can also be specified directly on a store:
     *
     * ```javascript
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON
     *         storeId          : 'meow',
     *         // so we create a new property "storeIdForCrud"..
     *         storeIdForCrud  : 'cats',
     *         // and point CrudManager to use it as the store identifier source
     *         storeIdProperty  : 'storeIdForCrud',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('DogStore', {
     *         model            : 'MyModel',
     *         // storeId is "dogs" and it will be used as a container name for the store data
     *         storeId          : 'dogs',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow', 'dogs']
     *     });
     * ```
     *
     */
    storeIdProperty: 'storeId',
    /**
     * @cfg {String} filterParam The name of the 'filter' parameter to send in a load request.
     * This config is also can be defined and a store level:
     *
     *
     */
    filterParam: 'filter',
    storesIndex: null,
    activeRequests: null,
    delayedSyncs: null,
    /**
     * @method sendRequest
     * @abstract
     * Sends request to the server.
     * @param {Object} request The request to send. An object having following properties:
     * @param {String} request.data {@link #encode Encoded} request.
     * @param {String} request.type Request type, can be either `load` or `sync`
     * @param {Function} request.success Callback to be started on successful request transferring
     * @param {Function} request.failure Callback to be started on request transfer failure
     * @param {Object} request.scope A scope for the above `success` and `failure` callbacks
     * @return {Object} The request descriptor.
     */
    /**
     * @method cancelRequest
     * @abstract
     * Cancels request to the server.
     * @param {Object} request The request to cancel (a value returned by corresponding {@link #sendRequest} call).
     */
    /**
     * @method encode
     * @abstract
     * Encodes request to the server.
     * @param {Object} request The request to encode.
     * @returns {String} The encoded request.
     */
    /**
     * @method decode
     * @abstract
     * Decodes response from the server.
     * @param {String} response The response to decode.
     * @returns {Object} The decoded response.
     */
    transport: null,
    /**
     * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
     * So `load` request may be responded with `sync` response for example.
     * Can be used for smart server logic allowing the server to decide when it's better to respond with a complete data set (`load` response)
     * or it's enough to return just a delta (`sync` response).
     * @cfg {Boolean} trackResponseType
     */
    trackResponseType: false,
    /**
     * @cfg {String} phantomIdField
     * Field name to be used to transfer a phantom record identifier.
     */
    phantomIdField: '$PhantomId',
    /**
     * @cfg {Boolean} autoLoad
     * `true` to automatically call {@link #load} method after creation.
     */
    autoLoad: false,
    /**
     * @cfg {Number} autoSyncTimeout
     * The timeout in milliseconds to wait before persisting changes to the server.
     * Used when {@link #autoSync} is set to `true`.
     */
    autoSyncTimeout: 100,
    /**
     * @cfg {Boolean} autoSync
     * `true` to automatically persist store changes after edits are made in any of the stores monitored.
     * Please note that sync request will not be invoked immediately but only after {@link #autoSyncTimeout} interval.
     */
    autoSync: false,
    /**
     * @cfg {Boolean} resetIdsBeforeSync
     * `True` to reset identifiers (defined by `idProperty` config) of phantom records before submitting them to the server.
     */
    resetIdsBeforeSync: true,
    /**
     * @property {Object[]} syncApplySequence
     * An array of stores presenting an alternative sync responses apply order.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} syncApplySequence.storeId Unique store identifier.
     * @property {Ext.data.Store/Ext.data.TreeStore} syncApplySequence.store Store itself.
     * @property {String} [syncApplySequence.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [syncApplySequence.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    /**
     * @cfg {String[]} syncApplySequence
     * An array of store identifiers sets an alternative sync responses apply order.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But in case of some tricky dependencies between stores this order can be changed:
     *
     *```javascript
     * Ext.create('MyCrudManager', {
     *     // register stores (they will be loaded in the same order: 'store1' then 'store2' and finally 'store3')
     *     stores : ['store1', 'store2', 'store3'],
     *     // but we apply changes from server to them in an opposite order
     *     syncApplySequence : ['store3', 'store2', 'store1']
     * });
     *```
     */
    syncApplySequence: null,
    /**
     * @cfg {Boolean} writeAllFields true to write all fields from the record to the server.
     * If set to false it will only send the fields that were modified.
     * Note that any fields that have Ext.data.field.Field.persist set to false will still be
     * ignored while those with Ext.data.field.Field.critical set to true will be included.
     */
    writeAllFields: false,
    /**
     * @cfg {Boolean/String/Function} fieldMapping
     * This property is used to read the key for each value that will be sent to the server.
     * Possible values are:
     *
     * - `false` - to disable fields mapping support;
     * - `true` - to enable fields mapping and "mapping" property on a field is used to get the field name;
     * - a string defining a custom property on a field is used to get the field name;
     * - a function to perform a custom processing of the data which is going to be sent to the server.
     * Accepts `data` and `record` and expects `data` object to be changed.
     *
     * This config is needed to achive something similar to Ext.data.writer.Writer.nameProperty in ExtJS.
     * Here is an example of the mapping:
     *
     * ```javascript
     *       Ext.define('Person', {
     *           extend : 'Ext.data.Model',
     *           fields : [
     *               {
     *                   name    : 'first',
     *                   mapping : 'firstName'
     *               },
     *               {
     *                   name    : 'last',
     *                   mapping : 'lastName'
     *               },
     *               {
     *                   name : 'age'
     *               }
     *           ]
     *       });
     *
     *       new Sch.data.CrudManager({
     *           // enable field mapping support
     *           fieldMapping : true,
     *           ...
     *       });
     *
     *       // This will be sent to the server
     *       {
     *           firstName : 'first name value',
     *           lastName  : 'last name value',
     *           age       : 1
     *       }
     * ```
     *
     */
    fieldMapping: false,
    /**
     * @property {Boolean} destroyed
     * This property is set to `true` after the `destroy` method is called.
     * @protected
     */
    destroyed: false,
    ignoreUpdates: 0,
    // Flag that shows if crud manager performed successful load request
    loaded: false,
    createMissingRecords: false,
    autoSyncTimerId: null,
    applyingLoadResponse: false,
    applyingSyncResponse: false,
    constructor: function(config) {
        config = config || {};
        this.mixins.observable.constructor.call(this, config);
        this.activeRequests = {};
        this.delayedSyncs = [];
        this.transport = config.transport || this.transport || {};
        // support stores defined in the class prototype as well
        var stores = config.stores || this.stores;
        this.stores = [];
        this.addStore(stores);
        var syncApplySequence = config.syncApplySequence || this.syncApplySequence;
        if (syncApplySequence) {
            // reset this.syncApplySequence since addStoreToApplySequence() will build it
            this.syncApplySequence = null;
            this.addStoreToApplySequence(syncApplySequence);
        }
        if (this.autoLoad)  {
            this.load();
        }
        
    },
    updateStoreIndex: function() {
        var storesIndex = {};
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var store = this.stores[i];
            if (store.storeId) {
                storesIndex[store.storeId] = this.stores[i];
            }
        }
        this.storesIndex = storesIndex;
    },
    /**
     * Returns a registered store descriptor.
     * @param {String/Ext.data.AbstractStore} storeId The store identifier or registered store instance.
     * @returns {Object} The descriptor of the store.
     * Store descriptor is an object having following structure:
     *
     *  - `storeId` The store identifier that will be used as a key in requests.
     *  - `store` The store itself.
     *  - `idProperty` The idProperty of the store.
     *  - `phantomIdField` The field holding unique Ids of phantom records (if store has such model).
     */
    getStoreDescriptor: function(storeId) {
        if (!storeId)  {
            return;
        }
        
        if (storeId.isStore) {
            for (var i = 0,
                l = this.stores.length; i < l; i++) {
                if (this.stores[i].store === storeId)  {
                    return this.stores[i];
                }
                
            }
        } else if (typeof storeId == 'object') {
            return this.storesIndex[storeId.storeId];
        } else {
            return this.storesIndex[storeId] || this.getStoreDescriptor(Ext.data.StoreManager.get(storeId));
        }
    },
    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Ext.data.AbstractStore} Found store instance.
     */
    getStore: function(storeId) {
        var storeInfo = this.getStoreDescriptor(storeId);
        return storeInfo && storeInfo.store;
    },
    forEachStore: function(fn, scope) {
        if (!fn)  {
            return;
        }
        
        var stores = this.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            if (fn.call(scope || this, stores[i].store, stores[i].storeId, stores[i]) === false)  {
                break;
            }
            
        }
    },
    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Ext.data.AbstractStore/String/Object/Ext.data.AbstractStore[]/String[]/Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {String} [store.filterParam] The name of the 'filter' parameter to send in a load request
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link #getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addStore(store7, 1, store3);
     * ```
     */
    addStore: function(store, position, fromStore) {
        if (!store)  {
            return;
        }
        
        if (!Ext.isArray(store))  {
            store = [
                store
            ];
        }
        
        var data = [];
        // loop over list of stores to be added
        for (var i = 0,
            l = store.length; i < l; i++) {
            var storeInfo = store[i];
            // if store instance provided
            if (storeInfo.isStore) {
                storeInfo = {
                    store: storeInfo
                };
            } else if (typeof storeInfo == 'object') {
                // normalize sub-stores (if any)
                if (storeInfo.stores) {
                    if (!Ext.isArray(storeInfo.stores))  {
                        storeInfo.stores = [
                            storeInfo.stores
                        ];
                    }
                    
                    for (var j = 0,
                        n = storeInfo.stores.length; j < n; j++) {
                        var subStore = storeInfo.stores[j],
                            subStoreInfo = subStore;
                        if ('string' === typeof subStore) {
                            subStoreInfo = {
                                storeId: subStore
                            };
                        }
                        // keep reference to the "master" store descriptor
                        subStoreInfo.masterStoreInfo = storeInfo;
                        storeInfo.stores[j] = subStoreInfo;
                    }
                }
            } else // if it's a store identifier
            {
                storeInfo = {
                    store: Ext.data.StoreManager.get(storeInfo)
                };
            }
            data.push(this.fillStoreDescriptor(storeInfo));
            // if the store has "setCrudManager" hook - use it
            if (storeInfo.store.setCrudManager) {
                storeInfo.store.setCrudManager(this);
            } else // otherwise decorate the store w/ "crudManager" property
            {
                storeInfo.store.crudManager = this;
            }
            // Prevent any ajax proxy from loading data into the store
            if (storeInfo.store.isTreeStore) {
                storeInfo.store.setProxy({
                    type: 'memory'
                });
            }
            // Required to prevent Sencha from using setTimeout
            // https://www.sencha.com/forum/showthread.php?316098-Store.setProxy-should-change-value-of-asynchronousLoad
            storeInfo.store.setAsynchronousLoad(false);
            // listen to store changes
            this.bindStoreListeners(storeInfo.store);
        }
        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            this.stores.push.apply(this.stores, data);
        } else // if position specified
        {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore.isStore || typeof fromStore !== 'object')  {
                    fromStore = this.getStoreDescriptor(fromStore);
                }
                
                // get its position
                pos += Ext.Array.indexOf(this.stores, fromStore);
            }
            // insert new store(-s)
            this.stores.splice.apply(this.stores, [].concat([
                pos,
                0
            ], data));
        }
        this.updateStoreIndex();
    },
    bindStoreListeners: function(store, un) {
        var listeners = {
                update: this.onStoreUpdate,
                clear: this.onStoreChange,
                scope: this
            };
        // tree store has specific event names
        if (store.isTreeStore) {
            Ext.apply(listeners, {
                nodeappend: this.onTreeStoreInsertOrAppend,
                nodeinsert: this.onTreeStoreInsertOrAppend,
                noderemove: this.onNodeRemove
            });
        } else {
            Ext.apply(listeners, {
                add: this.onStoreChange,
                remove: this.onStoreChange
            });
        }
        if (un) {
            this.mun(store, listeners);
        } else {
            this.mon(store, listeners);
        }
    },
    unbindStoreListeners: function(store) {
        this.bindStoreListeners(store, true);
    },
    fillStoreDescriptor: function(descriptor) {
        var store = descriptor.store,
            storeIdProperty = store.storeIdProperty || this.storeIdProperty,
            model = store.getModel && store.getModel() || store.model;
        model = model && model.prototype;
        Ext.applyIf(descriptor, {
            storeId: store[storeIdProperty],
            phantomIdField: model && model.phantomIdField,
            idProperty: model && model.idProperty,
            writeAllFields: store.writeAllFields
        });
        return descriptor;
    },
    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.
     *
     * ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeStore("foo");
     *
     *    // remove store3
     *    crudManager.removeStore(store3);
     * ```
     *
     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStore: function(store) {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var s = this.stores[i];
            if (s === store || s.store === store || s.storeId === store) {
                // unbind store listeners
                this.unbindStoreListeners(s.store);
                delete this.storesIndex[s.storeId];
                this.stores.splice(i, 1);
                if (this.syncApplySequence) {
                    this.removeStoreFromApplySequence(store);
                }
                break;
            }
        }
    },
    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #syncApplySequence} option
     * or but calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:
     *
     *    ```javascript
     *    // alternative sequence was not set for this crud manager
     *    // so let's fill it with existing stores keeping the same order
     *    crudManager.addStoreToApplySequence(crudManager.stores);
     *
     *    // and now we can add our new store
     *
     *    // we will load its data last
     *    crudManager.addStore(someNewStore);
     *    // but changes to it will be applied first
     *    crudManager.addStoreToApplySequence(someNewStore, 0);
     *    ```
     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Ext.data.AbstractStore/Object/Ext.data.AbstractStore[]/Object[]} store The store to add or its _descriptor_ (or array of stores or descriptors).
     * Where _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).

     * @param {Integer} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.
     *
     *    ```javascript
     *    // insert stores store4, store5 to the start of sequence
     *    crudManager.addStoreToApplySequence([ store4, store5 ], 0);
     *    ```
     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of {@link #getStoreDescriptor} call).
     *
     *    ```javascript
     *    // insert store6 just before a store having storeId equal to 'foo'
     *    crudManager.addStoreToApplySequence(store6, 0, 'foo');
     *
     *    // insert store7 just after store3 store
     *    crudManager.addStoreToApplySequence(store7, 1, store3);
     *    ```
     */
    addStoreToApplySequence: function(store, position, fromStore) {
        if (!store)  {
            return;
        }
        
        if (!Ext.isArray(store))  {
            store = [
                store
            ];
        }
        
        var data = [];
        // loop over list of stores to add
        for (var i = 0,
            l = store.length; i < l; i++) {
            var s = this.getStoreDescriptor(store[i]);
            if (s)  {
                data.push(s);
            }
            
        }
        if (!this.syncApplySequence)  {
            this.syncApplySequence = [];
        }
        
        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            this.syncApplySequence.push.apply(this.syncApplySequence, data);
        } else // if position specified
        {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore.isStore || typeof fromStore !== 'object')  {
                    fromStore = this.getStoreDescriptor(fromStore);
                }
                
                // get its position
                pos += Ext.Array.indexOf(this.syncApplySequence, fromStore);
            }
            // insert new store(-s)
            this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([
                pos,
                0
            ], data));
        }
    },
    /**
     * Removes a store from the alternative sync sequence.
     *
     *    ```javascript
     *    // remove store having storeId equal to "foo"
     *    crudManager.removeStore("foo");
     *
     *    // remove store3
     *    crudManager.removeStore(store3);
     *    ```
     *
     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStoreFromApplySequence: function(store) {
        for (var i = 0,
            l = this.syncApplySequence.length; i < l; i++) {
            var s = this.syncApplySequence[i];
            if (s === store || s.store === store || s.storeId === store) {
                this.syncApplySequence.splice(i, 1);
                break;
            }
        }
    },
    onNodeRemove: function(oldParent) {
        var treeStore = oldParent && oldParent.getTreeStore();
        // "noderemove" event is fired too early and getRemovedRecords() don't not have the removed node yet
        // so we wait till tree store "endupdate" event and only then invoke "onStoreChange" method
        treeStore && treeStore.on('endupdate', this.onStoreChange, this, {
            single: true
        });
    },
    onStoreUpdate: function(store, record, operation, fields) {
        if ((!store.isTreeStore || record !== store.getRoot())) {
            // If only a single field was changed, make sure it's a persistable field to avoid full scan of the store
            // Collapsing/expanding a tree node will trigger this behavior otherwise
            var isSingleNonPersistField = fields && fields.length === 1 && record.getField(fields[0]) && !record.getField(fields[0]).persist;
            if (!isSingleNonPersistField) {
                this.onStoreChange();
            }
        }
    },
    onTreeStoreInsertOrAppend: function(parent, child) {
        if (!child.isRoot()) {
            this.onStoreChange();
        }
    },
    suspendChangesTracking: function() {
        this.ignoreUpdates++;
    },
    resumeChangesTracking: function(triggerCheck) {
        this.ignoreUpdates--;
        triggerCheck && this.onStoreChange();
    },
    onStoreChange: function() {
        if (this.ignoreUpdates)  {
            return;
        }
        
        var me = this;
        /**
         * @event haschanges
         * Fires when any record in a registered stores is changed.
         *
         * ```javascript
         *     crudManager.on('haschanges', function (crud) {
         *         // enable persist changes button when some store gets changed
         *         saveButton.enable();
         *     });
         * ```
         *
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         */
        if (this.hasChanges()) {
            this.fireEvent('haschanges', this);
            if (this.autoSync) {
                // add deferred call if it's not scheduled yet
                if (!this.autoSyncTimerId) {
                    this.autoSyncTimerId = setTimeout(function() {
                        me.autoSyncTimerId = null;
                        me.sync();
                    }, this.autoSyncTimeout);
                }
            }
        } else {
            this.fireEvent('nochanges', this);
        }
    },
    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.
     *
     *    ```javascript
     *    // if we have any unsaved changes
     *    if (crudManager.hasChanges()) {
     *        // persist them
     *        crudManager.sync();
     *    // otherwise
     *    } else {
     *        alert("There are no unsaved changes...");
     *    }
     *    ```
     *
     * @param {String/Ext.data.AbstractStore} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     */
    hasChanges: function(storeId) {
        var store;
        if (storeId) {
            store = this.getStore(storeId);
            if (!store)  {
                return false;
            }
            
            return this.isStoreDirty(store);
        }
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            if (this.isStoreDirty(this.stores[i].store))  {
                return true;
            }
            
        }
        return false;
    },
    isStoreDirty: function(store) {
        if (store.getRemovedRecords().length)  {
            return true;
        }
        
        if (store.isTreeStore) {
            for (var o in store.byIdMap) {
                var record = store.byIdMap[o];
                // NOTE: 'expanded' might be a persitent field which a user might want to store as well,
                //       it's better to check for field persistency instead of comparing it by name.
                //
                // root node "expanded" state should not be regarded as a dirty record
                if (record.dirty === true && !record.get('root') && (Ext.Object.getKeys(record.modified).length !== 1 || (!("expanded" in record.modified) && !("lastParentId" in record.modified)))) {
                    return true;
                } else if (!record.get('root') && record.phantom && record.isValid()) {
                    return true;
                }
            }
        } else {
            var records = store.getData().items;
            for (var i = 0,
                l = records.length; i < l; i++) {
                if (records[i].dirty || records[i].phantom)  {
                    return true;
                }
                
            }
        }
        return false;
    },
    getLoadPackage: function(options) {
        var pack = {
                type: 'load',
                requestId: this.getRequestId(),
                stores: []
            };
        var stores = this.stores,
            packStores = pack.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var store = stores[i],
                filterParam = store.filterParam || store.store.filterParam || this.filterParam,
                opts = options && options[store.storeId],
                pageSize = store.pageSize || store.store.pageSize;
            // if the store uses remote filtering
            if (store.store.remoteFilter && filterParam) {
                opts = opts || {};
                var filters = [];
                store.store.getFilters().each(function(f) {
                    filters.push(f.serialize());
                });
                // put filters info into the package
                opts[filterParam] = filters;
            }
            if (opts || pageSize) {
                var params = Ext.apply({
                        storeId: store.storeId,
                        page: 1,
                        pageSize: pageSize
                    }, opts);
                stores[i].currentPage = params.page;
                packStores.push(params);
            } else {
                packStores.push(store.storeId);
            }
        }
        return pack;
    },
    // Extracts added record data to be persisted on the server
    getAddedRecordData: function(record, phantomIdField, stores) {
        var me = this,
            data = record.getData({
                serialize: true,
                persist: true
            }),
            criticalData = record.getData({
                serialize: true,
                persist: true,
                critical: true,
                changes: true
            });
        // We need to have all fields including critical, but getData returns critical only if changes flag is true,
        // but if changes is true that means that only modified fields will be returned.
        // Sencha assumes that getData returns all the fields by default (including critical), but in fact it's not.
        // So we merge critical fields with all fields manually.
        data = Ext.applyIf(data, criticalData);
        if (!data.hasOwnProperty(phantomIdField)) {
            data[phantomIdField] = record.getId();
        }
        if (me.resetIdsBeforeSync) {
            delete data[record.idProperty];
        }
        me.processFieldMapping(data, record);
        // if the store has embedded ones
        if (stores) {
            me.processSubStores(record, data, stores);
        }
        return data;
    },
    prepareAdded: function(records, phantomIdField, stores) {
        return records.map(function(record) {
            return this.getAddedRecordData(record, phantomIdField, stores);
        }, this);
    },
    // Extracts updated record data to be persisted on the server
    getUpdatedRecordData: function(record, stores, storeInfo) {
        var me = this,
            writeAllFields = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && me.writeAllFields),
            data = record.getData({
                serialize: true,
                persist: true,
                critical: !writeAllFields,
                changes: !writeAllFields
            });
        // idProperty might be missing from getData output if `changes` value is true (writeAllFields - false)
        // In that case getData will return only fields which were changed and normally exclude id field
        data[record.idProperty] = record.getId();
        for (var fieldName in data) {
            var field = record.getField(fieldName);
            var toDelete = !field || (writeAllFields ? (!field.persist && !field.critical) : !field.persist);
            // remove not persistable/critical fields if writeAllFields is true,
            // or not persistable fields only otherwise
            if (toDelete) {
                delete data[fieldName];
            }
        }
        me.processFieldMapping(data, record);
        // if the store has embedded stores
        if (stores) {
            me.processSubStores(record, data, stores);
        }
        return data;
    },
    prepareUpdated: function(records, stores, storeInfo) {
        return records.map(function(record) {
            return this.getUpdatedRecordData(record, stores, storeInfo);
        }, this);
    },
    prepareRemoved: function(records) {
        var result = [];
        for (var i = 0,
            l = records.length; i < l; i++) {
            var record = records[i],
                data = {};
            data[record.idProperty] = record.getId();
            result.push(data);
        }
        return result;
    },
    // changes `data`
    processFieldMapping: function(data, record) {
        var me = this;
        if (!me.fieldMapping)  {
            return;
        }
        
        // maybe custom handler is applied
        if (Ext.isFunction(me.fieldMapping)) {
            me.fieldMapping(data, record);
            return;
        }
        for (var fieldName in data) {
            var field = record.getField(fieldName),
                newFieldName = field && field[Ext.isString(me.fieldMapping) ? me.fieldMapping : 'mapping'];
            // ignore if new name matches old name
            if (newFieldName && newFieldName !== fieldName) {
                data[newFieldName] = data[fieldName];
                delete data[fieldName];
            }
        }
    },
    processSubStores: function(record, data, stores) {
        for (var j = 0,
            n = stores.length; j < n; j++) {
            var id = stores[j].storeId,
                store = record.get(id);
            // if embedded store is assigned to the record
            if (store) {
                // let's collect its changes as well
                var changes = this.getStoreChanges(Ext.apply({
                        store: store
                    }, stores[j]));
                if (changes) {
                    data[id] = Ext.apply(changes, {
                        $store: true
                    });
                } else {
                    delete data[id];
                }
            } else {
                delete data[id];
            }
        }
    },
    getStoreChanges: function(store, phantomIdField) {
        phantomIdField = phantomIdField || store.phantomIdField || this.phantomIdField;
        var s = store.store,
            added = s.getNewRecords(),
            updated = s.getUpdatedRecords(),
            removed = s.getRemovedRecords(),
            // sub-stores
            stores = store.stores;
        var result;
        if (added.length)  {
            added = this.prepareAdded(added, phantomIdField, stores);
        }
        
        if (updated.length)  {
            updated = this.prepareUpdated(updated, stores, store);
        }
        
        if (removed.length)  {
            removed = this.prepareRemoved(removed);
        }
        
        // if this store has changes
        if (added.length || updated.length || removed.length) {
            result = {};
            if (added.length)  {
                result.added = added;
            }
            
            if (updated.length)  {
                result.updated = updated;
            }
            
            if (removed.length)  {
                result.removed = removed;
            }
            
        }
        return result;
    },
    getChangeSetPackage: function() {
        var pack = {
                type: 'sync',
                requestId: this.getRequestId(),
                revision: this.revision
            };
        var stores = this.stores,
            found = 0;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var store = stores[i],
                phantomIdField = store.phantomIdField || this.phantomIdField,
                storeId = store.storeId;
            var changes = this.getStoreChanges(store, phantomIdField);
            if (changes) {
                found++;
                pack[storeId] = changes;
            }
        }
        return found ? pack : null;
    },
    getSubStoresData: function(rows, subStores, idProperty, isTree) {
        if (!rows)  {
            return;
        }
        
        var result = [];
        var processRow = function(row, subStores) {
                for (var j = 0,
                    m = subStores.length; j < m; j++) {
                    var storeId = subStores[j].storeId;
                    // if row contains data for this sub-store
                    if (row[storeId]) {
                        // keep them for the later loading
                        result.push({
                            id: row[idProperty],
                            storeDesc: subStores[j],
                            data: row[storeId]
                        });
                        // and remove reference from the row
                        delete row[storeId];
                    }
                }
            };
        var i = 0,
            l = rows.length;
        // if it's a TreeStore
        if (isTree) {
            // loop over nodes
            for (; i < l; i++) {
                processRow(rows[i], subStores);
                // also let's grab sub-stores from node children
                var childrenSubData = this.getSubStoresData(rows[i].children, subStores, idProperty, true);
                if (childrenSubData) {
                    result = result.concat(childrenSubData);
                }
            }
        } else // if it's a "flat" store
        {
            for (; i < l; i++) processRow(rows[i], subStores);
        }
        return result;
    },
    loadDataToTreeStore: function(store, data, options, storeDesc) {
        var rows = data && data.rows || [];
        // Root might contain modified fields, clear them
        var root = store.getRoot();
        if (root) {
            // If 'expanded' field is persisted, view will be empty after load until we expand root again
            // 060_crud_1
            root.modified = null;
            root.reject();
        }
        store.proxy.data = rows;
        // When store is loaded filters are not applied properly. This private callback allows us to reapply filters
        // before load event
        store.load({
            onChildNodesAvailable: function() {
                var filters = this.getFilters();
                filters.beginUpdate();
                filters.endUpdate();
            }
        });
    },
    loadDataToFlatStore: function(store, data, options, storeDesc) {
        var rows = data && data.rows || [];
        store.totalCount = data.total;
        store.currentPage = storeDesc.currentPage;
        // instantiate models since we have to pass them to "load" event
        var records = Ext.Array.map(rows, function(recordData) {
                return new store.model(recordData);
            });
        store.loadData(records, options && options.append || data.append);
        store.fireEvent('load', store, records, true);
    },
    applyMetaDataToStore: function(store, metaData) {
        if (metaData) {
            if (store.applyMetaData) {
                store.applyMetaData(metaData, this);
            } else {
                store.metaData = metaData;
            }
        }
    },
    loadDataToStore: function(storeDesc, data, options) {
        var store = storeDesc.store,
            model = store.getModel(),
            // nested stores list
            subStores = storeDesc.stores,
            idProperty = storeDesc.idProperty || model && model.prototype && model.prototype.idProperty || 'id',
            isTree = store.isTreeStore,
            subData;
        store.__loading = true;
        if (data) {
            // apply server provided meta data to the store
            this.applyMetaDataToStore(store, data.metaData);
            var rows = data.rows || [];
            if (rows) {
                if (subStores)  {
                    subData = this.getSubStoresData(rows, subStores, idProperty, isTree);
                }
                
                // use load method dependeing on store type (tree/flat)
                var loadMethod = isTree ? this.loadDataToTreeStore : this.loadDataToFlatStore;
                loadMethod.call(this, store, data, options, storeDesc);
                if (subData) {
                    // load sub-stores as well (if we have them)
                    for (var i = 0,
                        l = subData.length; i < l; i++) {
                        var subDatum = subData[i];
                        this.loadDataToStore(Ext.apply({
                            store: store[isTree ? 'getNodeById' : 'getById'](subDatum.id).get(subDatum.storeDesc.storeId)
                        }, subDatum.storeDesc), subDatum.data);
                    }
                }
            }
        }
        store.__loading = false;
    },
    loadData: function(response, options) {
        options = options || {};
        // we don't want reacting on store changes during loading of them
        this.suspendChangesTracking();
        // we load data to the stores in the order they're kept in this.stores array
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var storeDesc = this.stores[i],
                storeId = storeDesc.storeId,
                data = response[storeId];
            if (data)  {
                this.loadDataToStore(storeDesc, data, options[storeId]);
            }
            
        }
        this.resumeChangesTracking();
    },
    // Returns for the provided record:
    // - changes sent to the server as part of the active sync request
    // - current changes
    getRecordChangesStates: function(record, changes, stores, store) {
        var storeInfo = this.getStoreDescriptor(store),
            idProperty = record.idProperty,
            phantomIdField = storeInfo && storeInfo.phantomIdField || record.phantomIdField || this.phantomIdField,
            id = record.getId(),
            activeSync = this.activeRequests.sync,
            currentChanges, sentChanges;
        // If we have info on the active sync operation
        if (activeSync && storeInfo) {
            var sentData = activeSync.pack[storeInfo.storeId],
                syncUpdated = sentData && sentData.updated,
                syncAdded = sentData && sentData.added;
            // Get current changes snapshot made before CM started applying the response
            var currentData = this._currentChangeSetPackage && this._currentChangeSetPackage[storeInfo.storeId],
                currentUpdated = currentData && currentData.updated,
                currentAdded = currentData && currentData.added;
            // Get snapshot of the record data sent to the server (if it was updated)
            sentChanges = syncUpdated && Ext.Array.findBy(syncUpdated, function(entry) {
                return entry[idProperty] == id;
            });
            // the record was updated and sent to the server
            if (sentChanges) {
                // get its current state
                currentChanges = currentUpdated && Ext.Array.findBy(currentUpdated, function(entry) {
                    return entry[idProperty] == id;
                });
            } else // ..no snapshot means the record could be sent to the server as added
            {
                // searching the record data in sent added data
                sentChanges = syncAdded && Ext.Array.findBy(syncAdded, function(entry) {
                    return entry[phantomIdField] == id;
                });
                currentChanges = currentAdded && Ext.Array.findBy(currentAdded, function(entry) {
                    return entry[phantomIdField] == id;
                });
            }
        }
        return {
            sent: sentChanges,
            current: currentChanges
        };
    },
    // Returns true if the provided field values are equal. The method is used when applying sync response.
    isFieldValueEqual: function(record, field, value1, value2) {
        if (field.isDateField) {
            if (value1 instanceof Date) {
                value1 = field.serialize(value1);
            }
            if (value2 instanceof Date) {
                value2 = field.serialize(value2);
            }
        }
        return record.isEqual(value1, value2, field);
    },
    // Applies value to a record field. The method is used when applying sync response.
    applyChangeToField: function(record, name, value, store) {
        var parentIdProperty = store && store.parentIdProperty || 'parentId';
        // for the record ID we will use setId() call
        if (name === record.idProperty) {
            record.setId(value);
        }
        // parentId requires special treatment
        else if (name === parentIdProperty && store.isTreeStore) {
            var parent = (value && store.getNodeById(value)) || store.getRoot();
            parent.appendChild(record);
        }
        // if the field exists
        else if (record.getField(name)) {
            record.set(name, value);
        }
    },
    applyChangesToRecord: function(record, changes, stores, store) {
        var data = record.data,
            done = {},
            editStarted = false,
            name;
        var changesStates = this.getRecordChangesStates.apply(this, arguments),
            sentChanges = changesStates.sent,
            currentChanges = changesStates.current,
            // copy current changes to a temporary object
            tmpCurrentChanges = Ext.apply({}, currentChanges);
        // if this store has sub-stores assigned to some fields
        if (stores) {
            // then first we apply changes to that stores
            for (var j = 0,
                n = stores.length; j < n; j++) {
                name = stores[j].storeId;
                if (changes.hasOwnProperty(name)) {
                    // remember that we processed this field
                    done[name] = true;
                    var subStore = record.get(name);
                    if (subStore) {
                        this.applyChangesToStore(Ext.apply({
                            store: subStore
                        }, stores[j]), changes[name]);
                    } else {
                        Ext.log("Can't find store for the response sub-package");
                    }
                }
            }
        }
        var hasModifiedField = false,
            // combine sent and responded changes
            fieldValues = Ext.apply({}, changes, sentChanges),
            fieldsToCommit = Ext.apply({}, fieldValues);
        // sanitize done fields
        // TODO adjust this to support nested stores
        for (name in done) {
            if (done.hasOwnProperty(name)) {
                delete tmpCurrentChanges[name];
            }
        }
        // Iterate over fields sent to the server combined w/ responded ones
        for (name in fieldValues) {
            if (fieldValues.hasOwnProperty(name) && !done[name]) {
                var value = fieldValues[name];
                var field = record.getField(name);
                // Check if the field was modified while sync was in progress
                var modifiedField = sentChanges && !this.isFieldValueEqual(record, field || name, sentChanges[name], currentChanges ? currentChanges[name] : data[name]);
                hasModifiedField = hasModifiedField || modifiedField;
                // Remove the field from tmp list of current changes
                // to have in the end list of changes made on the client during the request
                delete tmpCurrentChanges[name];
                // If the client hasn't changed the field value while waiting for response
                if (!modifiedField) {
                    // If responded value doesn't match the client one
                    if (!this.isFieldValueEqual(record, field || name, data[name], value)) {
                        // Don't commit field modified on the server
                        delete fieldsToCommit[name];
                        // we call beginEdit/endEdit only if real changes were applied
                        if (!editStarted) {
                            editStarted = true;
                            record.beginEdit();
                        }
                        // Set field value
                        this.applyChangeToField(record, name, value, store);
                    }
                } else // Don't commit fields changed while waiting for response
                {
                    delete fieldsToCommit[name];
                    // In case the field change was reverted on the client while new value was sent to the server
                    // and appluied there.
                    // Then the field is not marked as changed on the client.
                    // So we manually mark the record as dirty and put the field value to record.modified.
                    if (!currentChanges || !currentChanges[name]) {
                        record.dirty = true;
                        record.modified[name] = data[name];
                    }
                }
            }
        }
        // we call beginEdit/endEdit only if real changes were applied
        if (editStarted)  {
            record.endEdit();
        }
        
        // Only commit if no records changed while a sync was ongoing
        // - if no sent field was modified
        // - and no other field changes
        if (!hasModifiedField && !Ext.Object.getValues(tmpCurrentChanges).length) {
            record.commit();
        } else if (record.modified) {
            var toCommit = Ext.Object.getKeys(fieldsToCommit);
            for (var i = 0,
                l = toCommit.length; i < l; i++) {
                delete record.modified[toCommit[i]];
            }
        }
        // Record data came from the server ...shouldn't be phantom anymore
        if (record.phantom) {
            record.phantom = false;
        }
    },
    applyRemovals: function(store, removed, context) {
        var idProperty = context.idProperty,
            removedStash = store.isTreeStore ? store.removedNodes : store.removed,
            findByIdFn = context.findByIdFn,
            removeRecordFn = context.removeRecordFn,
            nbrRemoved = 0;
        for (var j = 0,
            k = removed.length; j < k; j++) {
            var done = false;
            var id = removed[j][idProperty];
            // just find the record in store.removed array and delete it from it
            for (var jj = 0,
                kk = removedStash.length; jj < kk; jj++) {
                if (removedStash[jj].getId() == id) {
                    removedStash.splice(jj, 1);
                    done = true;
                    // number of removals applied
                    nbrRemoved++;
                    break;
                }
            }
            // if removed record in response isn`t found in store.removed
            // then probably wasn't removed on the client side yet (server driven removes)
            if (!done) {
                var record = findByIdFn(id);
                if (record) {
                    this.suspendChangesTracking();
                    removeRecordFn(record);
                    Ext.Array.remove(removedStash, record);
                    // number of removals applied
                    nbrRemoved++;
                    this.resumeChangesTracking();
                } else {
                    Ext.log("Can't find record to remove from the response package");
                }
            }
        }
        return nbrRemoved;
    },
    getApplyChangesToStoreHelpers: function(store) {
        // TODO: this might need to be refactored taking Sch.data.mixin.UniversalModelGetter methods into account
        // if it's a tree store
        if (store.isTreeStore) {
            var findNode = function(id) {
                    return store.getNodeById(id);
                },
                parentIdProperty = store.parentIdProperty || 'parentId';
            return {
                findByPhantomFn: findNode,
                findByIdFn: findNode,
                addRecordFn: function(data) {
                    var parent = (data[parentIdProperty] && store.getNodeById(data[parentIdProperty])) || store.getRoot();
                    return parent.appendChild(data);
                },
                removeRecordFn: function(record) {
                    return record.parentNode.removeChild(record);
                }
            };
        } else // plain store
        {
            return {
                findByPhantomFn: function(id) {
                    return store.data.getByKey(id);
                },
                findByIdFn: function(id) {
                    return store.getById(id);
                },
                addRecordFn: function(data) {
                    return store.add(data)[0];
                },
                removeRecordFn: function(record) {
                    return store.remove(record);
                }
            };
        }
    },
    applyChangesToStore: function(storeDesc, storeResponse) {
        var me = this,
            phantomIdField = storeDesc.phantomIdField || me.phantomIdField,
            idProperty = storeDesc.idProperty,
            store = storeDesc.store;
        if (!idProperty) {
            var model = store.getModel && store.getModel() || store.model;
            model = model && model.prototype;
            idProperty = model && model.idProperty || 'id';
        }
        var helpers = me.getApplyChangesToStoreHelpers(store),
            findByPhantomFn = helpers.findByPhantomFn,
            findByIdFn = helpers.findByIdFn,
            addRecordFn = helpers.addRecordFn,
            removeRecordFn = helpers.removeRecordFn,
            metaData = storeResponse.metaData,
            rows = storeResponse.rows,
            removedRecords = storeResponse.removed,
            nbrRemoved = 0,
            record;
        // apply server provided meta data to the store
        metaData && me.applyMetaDataToStore(store, metaData);
        if (removedRecords) {
            // process removed records
            nbrRemoved = me.applyRemovals(store, removedRecords, {
                idProperty: idProperty,
                findByIdFn: findByIdFn,
                removeRecordFn: removeRecordFn
            });
        }
        // process added/updated records
        if (rows) {
            var data, id, phantomId, hasPhantomId, hasId,
                // sub-stores
                stores = storeDesc.stores;
            for (var j = 0,
                k = rows.length; j < k; j++) {
                data = rows[j];
                phantomId = data[phantomIdField];
                id = data[idProperty];
                hasPhantomId = phantomId != null && phantomId !== '';
                hasId = id != null && id !== '';
                record = null;
                // if phantomId is provided then we will use it to find persisted phantom record
                if (hasPhantomId) {
                    record = findByPhantomFn(phantomId);
                }
                // if id is provided then we will use it to find updated (or pushed by the server) record
                else if (hasId) {
                    record = findByIdFn(id);
                }
                // record found - apply changes to it
                if (record) {
                    me.applyChangesToRecord(record, data, stores, store);
                } else // record not found
                {
                    var removedStash = store.getRemovedRecords();
                    // add it if it was not removed while sync was in progress
                    if (!removedStash.length || (!hasId && !hasPhantomId) || !Ext.Array.findBy(removedStash, id ? function(entry) {
                        return entry.getId() == id;
                    } : function(entry) {
                        return entry.data[phantomIdField] == phantomId;
                    })) {
                        // create new record in the store
                        record = addRecordFn(data);
                        record.commit();
                    }
                }
            }
        }
        if (nbrRemoved > 0) {
            store.fireEvent('datachanged', store);
            // HACK Fire an event (Ext JS private event) indicating records were committed in the store
            store.fireEvent('commit', store);
        }
    },
    applySyncResponse: function(response) {
        this.applyingSyncResponse = true;
        this.suspendChangesTracking();
        // remember modified data state before we start applying the response
        this._currentChangeSetPackage = this.getChangeSetPackage();
        // we apply received changes to the stores in the order they're kept in either this.syncApplySequence or this.stores array
        var stores = this.syncApplySequence || this.stores;
        for (var i = 0,
            l = stores.length; i < l; i++) {
            var storeResponse = response[stores[i].storeId];
            if (storeResponse) {
                this.applyChangesToStore(stores[i], storeResponse);
            }
        }
        this.applyingSyncResponse = false;
        this.resumeChangesTracking();
    },
    applyLoadResponse: function(response, options) {
        this.applyingLoadResponse = true;
        this.loadData(response, options);
        this.applyingLoadResponse = false;
    },
    applyResponse: function(requestType, response, options) {
        // in trackResponseType we check response type before deciding how to react on the response
        if (this.trackResponseType) {
            requestType = response.type || requestType;
        }
        switch (requestType) {
            case 'load':
                this.applyLoadResponse(response, options);
                break;
            case 'sync':
                this.applySyncResponse(response);
                break;
        }
    },
    /**
     * Generates unique request identifier.
     * @protected
     * @template
     * @return {Integer} The request identifier.
     */
    getRequestId: function() {
        return Math.floor(Math.random() * Date.now());
    },
    onResponse: function(requestType, rawResponse, responseOptions, options) {
        var response = this.decode(rawResponse);
        if (!response || !response.success) {
            /**
             * @event requestfail
             * Fires when a request gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent('requestfail', this, requestType, response, responseOptions);
            /**
             * @event loadfail
             * Fires when {@link #load load request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             * @param {Object} options Options provided to the {@link #load} method.
             */
            /**
             * @event syncfail
             * Fires when {@link #sync sync request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent(requestType + 'fail', this, response, responseOptions, options);
            // convert rawResponse to string to avoid exception in further rawResponse.length get
            if ('string' != typeof rawResponse) {
                rawResponse = '' + rawResponse;
            }
            this.warn('CrudManager: ' + requestType + ' failed, please inspect the server response', rawResponse.length < 1024 * 1024 && rawResponse || '');
        } else {
            /**
             * @event requestsuccess
             * Fires when a request is done right after the response is decoded successfully and before it's applied to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent('requestsuccess', this, requestType, response, responseOptions);
            /**
             * @event loadsuccess
             * Fires when a {@link #load load request} is done right after the response is decoded successfully and before it's applied to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            /**
             * @event syncsuccess
             * Fires when a {@link #sync sync request} is done right after the response is decoded successfully and before it's applied to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent(requestType + 'success', this, response, responseOptions, options);
            /**
             * @event beforeresponseapply
             * @preventable
             * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
             * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             */
            /**
             * @event beforeloadapply
             * @preventable
             * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
             * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} options Options provided to the {@link #load} method.
             */
            /**
             * @event beforesyncapply
             * @preventable
             * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
             * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} options Options provided to the {@link #sync} method.
             */
            if ((this.fireEvent('beforeresponseapply', this, requestType, response) !== false) && (this.fireEvent('before' + requestType + 'apply', this, response, options) !== false)) {
                this.revision = response.revision;
                this.applyResponse(requestType, response, options);
                /**
                 * @event requestdone
                 * Fires on successful request completion after data gets applied to the stores.
                 * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                 * @param {String} requestType The request type (`sync` or `load`).
                 * @param {Object} response The decoded server response object.
                 * @param {Object} responseOptions The server response options.
                 */
                this.fireEvent('requestdone', this, requestType, response, responseOptions);
                /**
                 * @event load
                 * Fires on successful {@link #load load request} completion after data gets loaded to the stores.
                 * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                 * @param {Object} response The decoded server response object.
                 * @param {Object} responseOptions The server response options.
                 * @param {Object} options Options provided to the {@link #load} method.
                 */
                /**
                 * @event sync
                 * Fires on successful {@link #sync sync request} completion.
                 * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                 * @param {Object} response The decoded server response object.
                 * @param {Object} responseOptions The server response options.
                 */
                this.fireEvent(requestType, this, response, responseOptions, options);
                if (requestType === 'load' || !this.hasChanges()) {
                    /**
                     * @event nochanges
                     * Fires when registered stores get into state when they don't have any
                     * not persisted change. This happens after {@link #method-load load} or {@link #method-sync sync} request
                     * completion. Or this may happen after a record update which turns its fields back to their original state.
                     *
                     * ```javascript
                     *     crudManager.on('nochanges', function (crud) {
                     *         // disable persist changes button when there is no changes
                     *         saveButton.disable();
                     *     });
                     * ```
                     *
                     * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                     */
                    this.fireEvent('nochanges', this);
                }
            } else {
                this.fireEvent('responseapplycancelled', this, requestType, response);
                this.fireEvent(requestType + 'applycancelled', this, response, options);
            }
        }
        // reset last requested package ID
        this.activeRequests[requestType] = null;
        return response;
    },
    onLoad: function(rawResponse, responseOptions, options) {
        // Successful load request, mark crud manager as loaded
        this.loaded = true;
        return this.onResponse('load', rawResponse, responseOptions, options);
    },
    onSync: function(rawResponse, responseOptions, options) {
        return this.onResponse('sync', rawResponse, responseOptions, options);
    },
    /**
     * Loads data to the stores registered in the crud manager. For example:
     *
     *    ```javascript
     *    crudManager.load(
     *        // here are request parameters
     *        {
     *            store1 : { append : true, page : 3, smth : 'foo' },
     *            store2 : { page : 2, bar : '!!!' }
     *        },
     *        // here is callback
     *        function () { alert('OMG! It works!') },
     *        // here is errback
     *        function (response) { alert('Oops: '+response.message); }
     *    );
     *    ```
     *
     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by {@link #cancelRequest} calling.
     * @param {Object} [parameters] The request parameters. This argument can be omitted like this:
     *
     *    ```javascript
     *    crudManager.load(
     *        // here is callback
     *        function () { alert('OMG! It works!') },
     *        // here is errback
     *        function (response) { alert('Oops: '+response.message); }
     *    );
     *    ```
     *
     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. And these parameters will be transferred with a load request.
     *
     *    ```javascript
     *    {
     *        store1 : { page : 3, append : true, smth : 'foo' },
     *        store2 : { page : 2, bar : '!!!' }
     *    },
     *    ```
     *
     * Additionally for flat stores `append: true` can be specified to add loaded records to the existing records, default is to remove corresponding store's existing records first.
     * And for tree stores you can use Ext.data.TreeStore.clearOnLoad option to achieve a similar result.
     * **Please note** that for delta loading you can also use an {@link #trackResponseType alternative approach}.
     * @param {Function} [callback] An optional callback to be started on successful request completion.
     * There is also a {@link #event-load load} event which can be used for load request completion processing.
     * @param {Function} [errback] A callback to be started on request failure.
     * There is also an {@link #loadfail} event which can be used for load request failures processing.
     * @param {Object/Function} [scope] A scope to be used for `callback` and `errback` calls.
     */
    load: function(callback, errback, scope) {
        var options;
        if (typeof callback === 'object') {
            options = callback;
            callback = errback;
            errback = scope;
            scope = arguments[3];
        }
        var pack = this.getLoadPackage(options);
        /**
         * @event beforeload
         * @preventable
         * Fires before {@link #load load request} is sent. Return `false` to cancel load request.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforeload', this, pack) !== false) {
            scope = scope || this;
            // if another load request is in progress let's cancel it
            if (this.activeRequests.load) {
                this.cancelRequest(this.activeRequests.load.desc);
                this.fireEvent('loadcanceled', this, pack);
            }
            this.activeRequests.load = {
                id: pack.requestId
            };
            this.activeRequests.load.desc = this.sendRequest({
                data: this.encode(pack),
                type: 'load',
                success: function(rawResponse, responseOptions) {
                    var response = this.onLoad(rawResponse, responseOptions, options);
                    if (errback && (!response || !response.success)) {
                        errback.call(scope, response, rawResponse, options);
                    } else if (callback) {
                        callback.call(scope, response, rawResponse, options);
                    }
                },
                failure: function(rawResponse, responseOptions) {
                    this.onLoad(rawResponse, responseOptions);
                    if (errback)  {
                        errback.apply(scope, arguments);
                    }
                    
                },
                scope: this
            });
        } else // if loading was canceled let's fire event
        {
            /**
             * @event loadcanceled
             * Fired after {@link #load load request} was canceled by some {@link #beforeload} listener
             * or due to incomplete prior load request.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('loadcanceled', this, pack);
        }
    },
    /**
     * Persists changes made on the registered stores to the server.
     * Request runs asynchronously so if some code needs to run after the request completion it has to be provided in the `callback` function:
     *
     * ```javascript
     *     // persist and run a callback on request completion
     *     sync(function(){ alert("Changes saved..."); }, function(response){ alert("Error: "+response.message); });
     * ```
     *
     * ** Note: ** If there is another incomplete sync request in progress then system will queue the call and delay it until previous request completion.
     * In this case {@link #syncdelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #autoSync} config. This option allows to persist changes automatically after any data modification.
     *
     * @param {Function} [callback] A function to start on successful request completion.
     * There is also a {@link #event-sync sync} event which can be used for sync request completion processing.
     *
     * **Note:** If there is no changes to persist then callback will be started immediately without sending any request
     * and {@link #event-sync sync} event will not be fired.
     * @param {Function} [errback] A function to start on request failure.
     * There is also an {@link #syncfail} event which can be used for sync request failures processing.
     * @param {Object} [scope] A scope for above `callback` and `errback` functions.
     */
    sync: function(callback, errback, scope) {
        if (this.activeRequests.sync) {
            // let's delay this call and start it only after server response
            this.delayedSyncs.push(arguments);
            /**
             * @event syncdelayed
             * Fires after {@link #sync sync request} was delayed due to incomplete previous one.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} arguments The arguments of {@link #sync} call.
             */
            this.fireEvent('syncdelayed', this, arguments);
            return;
        }
        // get current changes set package
        var pack = this.getChangeSetPackage();
        scope = scope || this;
        // if no data to persist we run callback and exit
        if (!pack) {
            if (callback)  {
                callback.call(scope, null, null);
            }
            
            return;
        }
        /**
         * @event beforesync
         * @preventable
         * Fires before {@link #sync sync request} is sent. Return `false` to cancel sync request.
         *
         * ```javascript
         *     crudManager.on('beforesync', function() {
         *        // cannot persist changes before at least one record is added
         *        // to the `someStore` store
         *        if (!someStore.getCount()) return false;
         *     });
         * ```
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforesync', this, pack) === false) {
            // if this sync was canceled let's fire event about it
            /**
             * @event synccanceled
             * Fires after {@link #sync sync request} was canceled by some {@link #beforesync} listener.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('synccanceled', this, pack);
            return;
        }
        // keep active request data
        this.activeRequests.sync = {
            id: pack.requestId,
            pack: pack
        };
        // send sync package
        this.activeRequests.sync.desc = this.sendRequest({
            data: this.encode(pack),
            type: 'sync',
            success: function(rawResponse, options) {
                var request = this.activeRequests.sync;
                var response = this.onSync(rawResponse, options);
                if (errback && (!response || !response.success)) {
                    errback.call(scope, response, rawResponse, request);
                } else if (callback) {
                    callback.call(scope, response, rawResponse, request);
                }
                // execute delayed sync() call
                this.runDelayedSync();
            },
            failure: function(rawResponse, options) {
                this.onSync(rawResponse, options);
                if (errback)  {
                    errback.apply(scope, arguments);
                }
                
                // execute delayed sync() call
                this.runDelayedSync();
            },
            scope: this
        });
    },
    runDelayedSync: function() {
        var args = this.delayedSyncs.shift();
        if (!args)  {
            return;
        }
        
        this.sync.apply(this, args);
    },
    /**
     * Commits all records changes of all the registered stores.
     * @deprecated We plan to remove this method so please use store `commitChanges` method instead.
     */
    commit: function() {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            var store = this.stores[i].store;
            // Need to suspend events here, for the commit to be 100% done before event is fired
            // Assignment column rendering looks at removed records to decide if a task resource assignment is 'dirty'
            // If we react to 'commit' operation of the store, the internal removedRecords array of the store has not yet been cleared
            store.suspendEvents(true);
            store.commitChanges();
            store.resumeEvents();
        }
    },
    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     * @deprecated We plan to remove this method so please use store `rejectChanges` method instead.
     */
    reject: function() {
        for (var i = 0,
            l = this.stores.length; i < l; i++) {
            this.stores[i].store.rejectChanges();
        }
    },
    warn: function() {
        if ('console' in window) {
            var c = console;
            c.log && c.log.apply && c.log.apply(c, arguments);
        }
    },
    // Used to help the UI know if the manager is already working and a loadmask should be shown when a consuming UI panel is created.
    isLoading: function() {
        return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    },
    /**
     * Removes all stores and cancels active requests.
     */
    destroy: function() {
        var me = this;
        if (me.destroyed)  {
            return;
        }
        
        me.activeRequests.load && me.cancelRequest(me.activeRequests.load.desc);
        me.activeRequests.sync && me.cancelRequest(me.activeRequests.sync.desc);
        while (me.stores.length > 0) {
            me.removeStore(me.stores[0]);
        }
        clearTimeout(me.autoSyncTimerId);
        me.destroyed = true;
    }
});

/**
 * This class implements an event domain for CRUD manager instances (classes extending Sch.crud.AbstractManager).
 * So that when MVC approach is used a Controller would be able to attach listeners for CRUD manager events in a declarative way.
 *
 *       Ext.define('MyApplication', {
 *           extend          : 'Ext.app.Application',
 *
 *           requires        : [
 *               // we need this to enable CRUD managers domain
 *               'Sch.app.CrudManagerDomain',
 *               'Ext.window.MessageBox'
 *           ],
 *
 *           listen          : {
 *               crudmanager : {
 *                   // listen to all CRUD managers available
 *                   '*' : {
 *                       'loadfail' : 'onCrudException'
 *                       'syncfail' : 'onCrudException'
 *                   },
 *
 *                   // this selector matches to a CRUD manager having an alias set to `crudmanager.specific-crud`
 *                   'specific-crud' : {
 *                       'load' : 'onSpecificCrudLoaded'
 *                   }
 *               }
 *           },
 *
 *           onCrudException : function (crud, response, responseOptions) {
 *               Ext.Msg.show({
 *                   title    : 'Error',
 *                   msg      : response.message || 'Unknown error',
 *                   icon     : Ext.Msg.ERROR,
 *                   buttons  : Ext.Msg.OK,
 *                   minWidth : Ext.Msg.minWidth
 *               });
 *           },
 *
 *           onSpecificCrudLoaded : function () {
 *               ...
 *           },
 *
 *           ....
 *       });
 *
 *
 * Selectors are either CRUD manager's alias or '*' wildcard for any CRUD manager.
 */
Ext.define('Sch.app.CrudManagerDomain', {
    extend: 'Ext.app.EventDomain',
    singleton: true,
    requires: [
        'Sch.crud.AbstractManager'
    ],
    type: 'crudmanager',
    prefix: 'crudmanager.',
    constructor: function() {
        var me = this;
        me.callParent();
        me.monitor(Sch.crud.AbstractManager);
    },
    match: function(target, selector) {
        var result = false,
            alias = target.alias;
        if (selector === '*') {
            result = true;
        } else if (alias) {
            result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
        }
        return result;
    }
});

/**
 * @class Sch.column.Day
 * @private
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in weekview mode
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.Day', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.weekview-day',
    align: 'center',
    // date range for this Day column
    start: null,
    end: null,
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    menuDisabled: true,
    enableLocking: false,
    lockable: false,
    flex: 1,
    resizable: false,
    cellFocusable: false,
    tdCls: 'sch-timetd',
    initComponent: function() {
        var now = new Date();
        this.addCls('sch-daycolumn-header');
        if (this.isWeekend()) {
            this.addCls('sch-daycolumn-header-weekend');
            this.tdCls = (this.tdCls || '') + ' sch-daycolumn-weekend';
        }
        if (this.start.getDate() === now.getDate() && this.start.getMonth() === now.getMonth() && this.start.getYear() === now.getYear()) {
            this.addCls('sch-daycolumn-header-today');
            this.tdCls = (this.tdCls || '') + ' sch-daycolumn-today';
        }
        this.callParent(arguments);
    },
    isWeekend: function() {
        var day = this.start.getDay();
        return day === 6 || day === 0;
    }
});

/**
@class Sch.column.Resource
@extends Ext.grid.Column
@private

A Column representing a resource, used only in vertical orientation. By default this column will use the resource
name as the header text. To get complete control over the rendering, you can use your own custom Column class by
using the {@link Sch.mixin.SchedulerPanel#resourceColumnClass resourceColumnClass} config on your SchedulerPanel.

*/
Ext.define('Sch.column.Resource', {
    extend: 'Ext.grid.Column',
    alias: 'widget.resourcecolumn',
    /*
     * Default resource column properties
     */
    align: 'center',
    menuDisabled: true,
    hideable: false,
    sortable: false,
    locked: false,
    lockable: false,
    draggable: false,
    enableLocking: false,
    // Prevents Ext from focusing cells on mousedown anywhere, which resets scroll to 0
    cellFocusable: false,
    /*
     * @property {Sch.model.Resource} model The resource model associated with this column
     * Default resource column properties
     */
    model: null,
    initComponent: function() {
        this.tdCls = (this.tdCls || '') + ' sch-timetd';
        this.cls = (this.cls || '') + ' sch-resourcecolumn-header';
        this.callParent(arguments);
    }
});

/**
 * Base locale class. You need to subclass it, when creating new locales for Bryntum components. Usually subclasses of this class
 * will be singletones.
 *
 * See <a href="#!/guide/gantt_scheduler_localization">Localization guide</a> for additional details.
 */
Ext.define('Sch.locale.Locale', {
    /**
     * @cfg {Object} l10n An object with the keys corresponding to class names and values are in turn objects with "phraseName/phraseTranslation"
     * key/values. For example:
     *
     * ```javascript
     *    l10n : {
     *       'Sch.plugin.EventEditor' : {
     *           saveText   : 'Speichern',
     *           deleteText : 'Löschen',
     *           cancelText : 'Abbrechen'
     *       },
     *
     *       'Sch.plugin.CurrentTimeLine' : {
     *           tooltipText : 'Aktuelle Zeit'
     *       },
     *
     *       ...
     *   }
     * ```
     */
    l10n: null,
    localeName: null,
    namespaceId: null,
    constructor: function() {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire();
        }
        var name = this.self.getName().split('.');
        var localeName = this.localeName = name.pop();
        this.namespaceId = name.join('.');
        var currentLocale = Sch.locale.Active[this.namespaceId];
        // let's localize all the classes that are loaded
        // except the cases when English locale is being applied over some non-english locale
        if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En'))  {
            this.apply();
        }
        
    },
    bindRequire: function() {
        // OVERRIDE
        // we need central hook to localize class once it's been created
        // to achieve it we override Ext.ClassManager.triggerCreated
        var _triggerCreated = Ext.ClassManager.triggerCreated;
        Ext.ClassManager.triggerCreated = function(className) {
            _triggerCreated.apply(this, arguments);
            if (className) {
                var cls = Ext.ClassManager.get(className);
                // trying to apply locales for the loaded class
                for (var namespaceId in Sch.locale.Active) {
                    Sch.locale.Active[namespaceId].apply(cls);
                }
            }
        };
    },
    applyToClass: function(className, cls) {
        var me = this,
            localeId = me.self.getName();
        cls = cls || Ext.ClassManager.get(className);
        if (cls && (cls.activeLocaleId !== localeId)) {
            // if (className=='Gnt.column.StartDate') debugger
            var locale = me.l10n[className];
            // if it's procedural localization - run provided callback
            if (typeof locale === 'function') {
                locale(className);
            } else {
                // if it's a singleton - apply to it
                if (cls.singleton) {
                    cls.l10n = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);
                } else // otherwise we override class
                {
                    if (cls.prototype.hasOwnProperty('l10n'))  {
                        locale = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);
                    }
                    
                    Ext.override(cls, {
                        l10n: locale
                    });
                }
            }
            // keep applied locale
            cls.activeLocaleId = localeId;
            // for singletons we can have some postprocessing
            if (cls.onLocalized)  {
                cls.onLocalized();
            }
            
        }
    },
    /**
     * Apply this locale to classes.
     * @param {String[]/Object[]} [classNames] Array of class names (or classes themself) to localize.
     * If no classes specified then will localize all existing classes.
     */
    apply: function(classNames) {
        if (this.l10n) {
            var me = this;
            // if class name is specified
            if (classNames) {
                if (!Ext.isArray(classNames))  {
                    classNames = [
                        classNames
                    ];
                }
                
                var name, cls;
                for (var i = 0,
                    l = classNames.length; i < l; i++) {
                    if (Ext.isObject(classNames[i])) {
                        if (classNames[i].singleton) {
                            cls = classNames[i];
                            name = Ext.getClassName(Ext.getClass(cls));
                        } else {
                            cls = Ext.getClass(classNames[i]);
                            name = Ext.getClassName(cls);
                        }
                    } else {
                        cls = null;
                        name = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
                    }
                    if (name) {
                        if (name in this.l10n) {
                            me.applyToClass(name, cls);
                        }
                    }
                }
            } else // localize all the classes that we know about
            {
                // update active locales
                Sch.locale.Active[this.namespaceId] = this;
                for (var className in this.l10n) {
                    me.applyToClass(className);
                }
            }
        }
    }
});

/**
 * English translations for the Scheduler component
 *
 * NOTE: To change locale for month/day names you have to use the corresponding Ext JS language file.
 */
Ext.define('Sch.locale.En', {
    extend: 'Sch.locale.Locale',
    singleton: true,
    l10n: {
        'Sch.util.Date': {
            unitNames: {
                YEAR: {
                    single: 'year',
                    plural: 'years',
                    abbrev: 'yr'
                },
                QUARTER: {
                    single: 'quarter',
                    plural: 'quarters',
                    abbrev: 'q'
                },
                MONTH: {
                    single: 'month',
                    plural: 'months',
                    abbrev: 'mon'
                },
                WEEK: {
                    single: 'week',
                    plural: 'weeks',
                    abbrev: 'w'
                },
                DAY: {
                    single: 'day',
                    plural: 'days',
                    abbrev: 'd'
                },
                HOUR: {
                    single: 'hour',
                    plural: 'hours',
                    abbrev: 'h'
                },
                MINUTE: {
                    single: 'minute',
                    plural: 'minutes',
                    abbrev: 'min'
                },
                SECOND: {
                    single: 'second',
                    plural: 'seconds',
                    abbrev: 's'
                },
                MILLI: {
                    single: 'ms',
                    plural: 'ms',
                    abbrev: 'ms'
                }
            }
        },
        'Sch.model.CalendarDay': {
            startTimeAfterEndTime: 'Start time {0} is greater than end time {1}',
            availabilityIntervalsShouldNotIntersect: 'Availability intervals should not intersect: [{0}] and [{1}]',
            invalidFormat: 'Invalid format for availability string: {0}. It should have exact format: hh:mm-hh:mm'
        },
        "Sch.panel.SchedulerTree": {
            'All day': 'All day'
        },
        "Sch.panel.SchedulerGrid": {
            'All day': 'All day'
        },
        'Sch.panel.TimelineGridPanel': {
            weekStartDay: 1,
            loadingText: 'Loading, please wait...',
            savingText: 'Saving changes, please wait...'
        },
        'Sch.panel.TimelineTreePanel': {
            weekStartDay: 1,
            loadingText: 'Loading, please wait...',
            savingText: 'Saving changes, please wait...'
        },
        'Sch.mixin.SchedulerView': {
            loadingText: 'Loading events...'
        },
        'Sch.plugin.CurrentTimeLine': {
            tooltipText: 'Current time'
        },
        //region Recurrence
        'Sch.widget.recurrence.ConfirmationDialog': {
            'delete-title': 'You\u2019re deleting an event',
            'delete-all-message': 'Do you want to delete all occurrences of this event?',
            'delete-further-message': 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',
            'delete-all-btn-text': 'Delete All',
            'delete-further-btn-text': 'Delete All Future Events',
            'delete-only-this-btn-text': 'Delete Only This Event',
            'update-title': 'You\u2019re changing a repeating event',
            'update-all-message': 'Do you want to change all occurrences of this event?',
            'update-further-message': 'Do you want to change only this occurrence of the event, or this and all future occurrences?',
            'update-all-btn-text': 'All',
            'update-further-btn-text': 'All Future Events',
            'update-only-this-btn-text': 'Only This Event',
            'Yes': 'Yes',
            'Cancel': 'Cancel'
        },
        'Sch.widget.recurrence.Dialog': {
            'Repeat event': 'Repeat event',
            'Cancel': 'Cancel',
            'Save': 'Save'
        },
        'Sch.widget.recurrence.Form': {
            'Frequency': 'Frequency',
            'Every': 'Every',
            'DAILYintervalUnit': 'day(s)',
            'WEEKLYintervalUnit': 'week(s) on:',
            'MONTHLYintervalUnit': 'month(s)',
            'YEARLYintervalUnit': 'year(s) in:',
            'Each': 'Each',
            'On the': 'On the',
            'End repeat': 'End repeat',
            'time(s)': 'time(s)'
        },
        'Sch.widget.recurrence.field.DaysComboBox': {
            'day': 'day',
            'weekday': 'weekday',
            'weekend day': 'weekend day'
        },
        'Sch.widget.recurrence.field.PositionsComboBox': {
            'position1': 'first',
            'position2': 'second',
            'position3': 'third',
            'position4': 'fourth',
            'position5': 'fifth',
            'position-1': 'last'
        },
        'Sch.data.util.recurrence.Legend': {
            // list delimiters
            ', ': ', ',
            ' and ': ' and ',
            // frequency patterns
            'Daily': 'Daily',
            // Weekly on Sunday
            // Weekly on Sun, Mon and Tue
            'Weekly on {1}': 'Weekly on {1}',
            // Monthly on 16
            // Monthly on the last weekday
            'Monthly on {1}': 'Monthly on {1}',
            // Yearly on 16 of January
            // Yearly on the last weekday of January and February
            'Yearly on {1} of {2}': 'Yearly on {1} of {2}',
            // Every 11 days
            'Every {0} days': 'Every {0} days',
            // Every 2 weeks on Sunday
            // Every 2 weeks on Sun, Mon and Tue
            'Every {0} weeks on {1}': 'Every {0} weeks on {1}',
            // Every 2 months on 16
            // Every 2 months on the last weekday
            'Every {0} months on {1}': 'Every {0} months on {1}',
            // Every 2 years on 16 of January
            // Every 2 years on the last weekday of January and February
            'Every {0} years on {1} of {2}': 'Every {0} years on {1} of {2}',
            // day position translations
            'position1': 'the first',
            'position2': 'the second',
            'position3': 'the third',
            'position4': 'the fourth',
            'position5': 'the fifth',
            'position-1': 'the last',
            // day options
            'day': 'day',
            'weekday': 'weekday',
            'weekend day': 'weekend day',
            // {0} - day position info ("the last"/"the first"/...)
            // {1} - day info ("Sunday"/"Monday"/.../"day"/"weekday"/"weekend day")
            // For example:
            //  "the last Sunday"
            //  "the first weekday"
            //  "the second weekend day"
            'daysFormat': '{0} {1}'
        },
        'Sch.widget.recurrence.field.StopConditionComboBox': {
            'Never': 'Never',
            'After': 'After',
            'On date': 'On date'
        },
        'Sch.widget.recurrence.field.FrequencyComboBox': {
            'Daily': 'Daily',
            'Weekly': 'Weekly',
            'Monthly': 'Monthly',
            'Yearly': 'Yearly'
        },
        'Sch.widget.recurrence.field.RecurrenceComboBox': {
            'None': 'None',
            'Custom...': 'Custom...'
        },
        'Sch.widget.EventEditor': {
            'Repeat': 'Repeat',
            saveText: 'Save',
            deleteText: 'Delete',
            cancelText: 'Cancel',
            nameText: 'Name',
            allDayText: 'All day',
            startDateText: 'Start',
            endDateText: 'End',
            resourceText: 'Resource'
        },
        //endregion Recurrence
        'Sch.plugin.SimpleEditor': {
            newEventText: 'New booking...'
        },
        'Sch.widget.ExportDialogForm': {
            formatFieldLabel: 'Paper format',
            orientationFieldLabel: 'Orientation',
            rangeFieldLabel: 'Schedule range',
            showHeaderLabel: 'Show header',
            showFooterLabel: 'Show footer',
            orientationPortraitText: 'Portrait',
            orientationLandscapeText: 'Landscape',
            completeViewText: 'Complete schedule',
            currentViewText: 'Visible schedule',
            dateRangeText: 'Date range',
            dateRangeFromText: 'Export from',
            dateRangeToText: 'Export to',
            exportersFieldLabel: 'Control pagination',
            adjustCols: 'Adjust column width',
            adjustColsAndRows: 'Adjust column width and row height',
            specifyDateRange: 'Specify date range',
            columnPickerLabel: 'Select columns',
            completeDataText: 'Complete schedule (for all events)',
            dpiFieldLabel: 'DPI (dots per inch)',
            rowsRangeLabel: 'Rows range',
            allRowsLabel: 'All rows',
            visibleRowsLabel: 'Visible rows',
            columnEmptyText: '[no title]'
        },
        'Sch.widget.ExportDialog': {
            title: 'Export Settings',
            exportButtonText: 'Export',
            cancelButtonText: 'Cancel',
            progressBarText: 'Exporting...'
        },
        'Sch.plugin.Export': {
            generalError: 'An error occurred',
            fetchingRows: 'Fetching row {0} of {1}',
            builtPage: 'Built page {0} of {1}',
            requestingPrintServer: 'Please wait...'
        },
        'Sch.plugin.Printable': {
            dialogTitle: 'Print settings',
            exportButtonText: 'Print',
            disablePopupBlocking: 'Please disable pop-up blocker since the print-plugin needs to be able to open new tabs',
            popupBlockerDetected: 'Browser pop-up blocker detected'
        },
        'Sch.plugin.exporter.AbstractExporter': {
            name: 'Exporter'
        },
        'Sch.plugin.exporter.SinglePage': {
            name: 'Single page'
        },
        'Sch.plugin.exporter.MultiPageVertical': {
            name: 'Multiple pages (vertically)'
        },
        'Sch.plugin.exporter.MultiPage': {
            name: 'Multiple pages'
        },
        'Sch.plugin.Split': {
            splitText: 'Split',
            mergeText: 'Hide split part'
        },
        'Sch.plugin.SummaryBar': {
            totalText: 'Total'
        },
        'Sch.column.ResourceName': {
            name: 'Name'
        },
        'Sch.template.DependencyInfo': {
            fromText: 'From',
            toText: 'To'
        },
        // -------------- View preset date formats/strings -------------------------------------
        'Sch.preset.Manager': {
            hourAndDay: {
                displayDateFormat: 'G:i',
                middleDateFormat: 'G:i',
                topDateFormat: 'D d/m'
            },
            secondAndMinute: {
                displayDateFormat: 'g:i:s',
                topDateFormat: 'D, d g:iA'
            },
            dayAndWeek: {
                displayDateFormat: 'm/d h:i A',
                middleDateFormat: 'D d M'
            },
            weekAndDay: {
                displayDateFormat: 'm/d',
                bottomDateFormat: 'd M',
                middleDateFormat: 'Y F d'
            },
            weekAndMonth: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'm/d',
                topDateFormat: 'm/d/Y'
            },
            weekAndDayLetter: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'D d M Y'
            },
            weekDateAndMonth: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'd',
                topDateFormat: 'Y F'
            },
            monthAndYear: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'M Y',
                topDateFormat: 'Y'
            },
            year: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'Y'
            },
            manyYears: {
                displayDateFormat: 'm/d/Y',
                middleDateFormat: 'Y'
            }
        }
    }
});

/**
 * A mixin providing localization functionality to the consuming class.
 *
 * ```javascript
 * Ext.define('MyToolbar', {
 *     extend : 'Ext.Toolbar',
 *     mixins : [ 'Sch.mixin.Localizable' ],
 *
 *     initComponent : function () {
 *         Ext.apply(this, {
 *             items : [
 *                 {
 *                     xtype : 'button',
 *                     // get the button label from the current locale
 *                     text  : this.L('loginText')
 *                 }
 *             ]
 *         });
 *         this.callParent(arguments);
 *     }
 * });
 * ```
 */
Ext.define('Sch.mixin.Localizable', {
    extend: 'Ext.Mixin',
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires: [
        'Sch.locale.En'
    ],
    activeLocaleId: '',
    /**
     * @cfg {Object} l10n Container of locales for the class.
     */
    l10n: null,
    inTextLocaleRegExp: /L\{([^}]+)\}/g,
    localizableProperties: null,
    isLocaleApplied: function() {
        var activeLocaleId = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;
        if (!activeLocaleId)  {
            return false;
        }
        
        for (var ns in Sch.locale.Active) {
            if (activeLocaleId === Sch.locale.Active[ns].self.getName())  {
                return true;
            }
            
        }
        return false;
    },
    applyLocale: function() {
        // loop over activated locale classes and call apply() method of each one
        for (var ns in Sch.locale.Active) {
            Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
        }
    },
    /**
     * @inheritdoc #localize
     * @localdoc This is shorthand reference to {@link #localize}.
     */
    L: function() {
        return this.localize.apply(this, arguments);
    },
    /**
     * Retrieves translation of a phrase.
     * @localdoc There is a shorthand {@link #L} for this method.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    localize: function(id, legacyHolderProp, skipLocalizedCheck) {
        var result = this.getLocale(id, legacyHolderProp, skipLocalizedCheck);
        if (result === null || result === undefined)  {
            throw 'Cannot find locale: ' + id + ' [' + this.self.getName() + ']';
        }
        
        return result;
    },
    getLocale: function(id, legacyHolderProp, skipLocalizedCheck) {
        // if not localized yet let's do it
        if (!this.isLocaleApplied() && !skipLocalizedCheck) {
            this.applyLocale();
        }
        // `l10n` instance property has highest priority
        if (this.hasOwnProperty('l10n') && this.l10n && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id])  {
            return this.l10n[id];
        }
        
        var clsProto = this.self && this.self.prototype;
        // let's try to get locale from class prototype `l10n` property
        var result = clsProto.l10n && clsProto.l10n[id];
        // if no transalation found
        if (result === null || result === undefined) {
            var superClass = clsProto && clsProto.superclass;
            // if parent class also has localize() method
            if (superClass && superClass.localize) {
                // try to get phrase translation from parent class
                result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
            }
        }
        return result;
    },
    // TODO: cover below methods w/ tests and make localizeText & localizableProperties public
    localizeText: function(text) {
        var match, locale,
            regExp = this.inTextLocaleRegExp;
        while (match = regExp.exec(text)) {
            if (locale = this.getLocale(match[1])) {
                text = text.replace(match[0], locale);
            }
        }
        return text;
    },
    localizeProperties: function() {
        var me = this,
            properties = me.localizableProperties;
        if (properties) {
            properties = properties.split(',');
            for (var i = properties.length - 1; i >= 0; i--) {
                me[properties[i]] = me.localizeText(me[properties[i]]);
            }
        }
    },
    mixinConfig: {
        before: {
            'initComponent': 'beforeInitComponent'
        }
    },
    beforeInitComponent: function() {
        this.localizeProperties();
    }
});

/**
 @class Sch.column.ResourceName
 @extends Ext.grid.Column

 A basic grid column showing the Name field of a resource
 */
Ext.define('Sch.column.ResourceName', {
    extend: 'Ext.grid.Column',
    alias: 'widget.scheduler_resourcenamecolumn',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    initComponent: function() {
        Ext.apply(this, {
            text: this.L('name')
        });
        this.callParent(arguments);
    },
    renderer: function(value, meta, resource) {
        return resource.getName();
    }
});

/**
@class Sch.column.Summary
@extends Ext.grid.column.Column

A Column showing the currently allocated time for the resources in the grid. It will simply summarize the durations **of the events that are in the current view**.
The information can be displayed as either a time unit or a percentage of the available time.

To add this column to the scheduler:

    var summaryCol = Ext.create("Sch.column.Summary", {
        header      : 'Time allocated',
        width       : 80,
        showPercent : false
    });

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        resourceStore   : resourceStore,
        eventStore      : eventStore,

        columns         : [
            ...
            summaryCol,
            ...
        ]
    });

*/
Ext.define('Sch.column.Summary', {
    extend: "Ext.grid.column.Column",
    alias: [
        "widget.summarycolumn"
    ],
    lockableScope: 'top',
    /**
     * @cfg {Boolean} showPercent True to show percentage values, false to show summarized time. Default value is `false`.
     */
    showPercent: false,
    /**
     * @cfg {Number} nbrDecimals The number of decimals to show, only applicable when `showPercent` is set to false
     */
    nbrDecimals: 1,
    sortable: false,
    fixed: true,
    menuDisabled: true,
    width: 80,
    dataIndex: '_sch_not_used',
    schedulerPanel: null,
    lockable: false,
    // We don't subclass AbstractPlugin so we need to have some methods indicating that this is a proper plugin
    init: Ext.emptyFn,
    constructor: function(config) {
        this.scope = this;
        this.callParent(arguments);
        this.on('beforerender', this.onMyBeforeRender, this);
    },
    onMyBeforeRender: function() {
        this.schedulerPanel = this.up('tablepanel[lockable=true]');
    },
    getTimeAxis: function() {
        return this.schedulerPanel.getTimeAxis();
    },
    getEventStore: function() {
        return this.schedulerPanel.getEventStore();
    },
    renderer: function(v, p, record) {
        var timeAxis = this.getTimeAxis(),
            eventStore = this.getEventStore(),
            viewStart = timeAxis.getStart(),
            viewEnd = timeAxis.getEnd(),
            totalAllocatedMinutesInView = this.calculate(eventStore.getEventsForResource(record), viewStart, viewEnd);
        if (totalAllocatedMinutesInView <= 0) {
            return '';
        }
        if (this.showPercent) {
            var timeInView = Sch.util.Date.getDurationInMinutes(viewStart, viewEnd);
            return (Math.round((totalAllocatedMinutesInView * 100) / timeInView)) + ' %';
        } else {
            if (totalAllocatedMinutesInView > 1440) {
                return (totalAllocatedMinutesInView / 1440).toFixed(this.nbrDecimals) + ' ' + Sch.util.Date.getShortNameOfUnit("DAY");
            }
            if (totalAllocatedMinutesInView >= 30) {
                return (totalAllocatedMinutesInView / 60).toFixed(this.nbrDecimals) + ' ' + Sch.util.Date.getShortNameOfUnit("HOUR");
            }
            return totalAllocatedMinutesInView + ' ' + Sch.util.Date.getShortNameOfUnit("MINUTE");
        }
    },
    calculate: function(eventRecords, viewStart, viewEnd) {
        var totalTime = 0,
            eventStart, eventEnd,
            D = Sch.util.Date;
        Ext.Array.each(eventRecords, function(eRec) {
            eventStart = eRec.getStartDate();
            eventEnd = eRec.getEndDate();
            if (D.intersectSpans(viewStart, viewEnd, eventStart, eventEnd)) {
                totalTime += D.getDurationInMinutes(D.max(eventStart, viewStart), D.min(eventEnd, viewEnd));
            }
        });
        return totalTime;
    }
});

/**
* @class Sch.view.HorizontalTimeAxis
* @extends Ext.util.Observable
* @private
*
* A visual representation of the time axis described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
* Normally you should not interact with this class directly.
*/
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.XTemplate'
    ],
    statics: {
        encodeDateFormat: 'Ymd_His'
    },
    /**
    * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
    */
    trackHeaderOver: true,
    /**
    * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class to the row (for special styling).
    *            Defaults to 15px.
    */
    compactCellWidthThreshold: 15,
    baseCls: 'sch-column-header',
    tableCls: 'sch-header-row',
    enableTickResizing: false,
    // a 2nd template for the 2nd mode, w/o `containerEl`
    headerHtmlRowTpl: '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}">' + '<tbody>' + '<tr>' + '<tpl for="cells">' + '<td class="{{baseCls}} {headerCls} sch-header-cell-{align}" data-date="{[fm.date(values.start, Sch.view.HorizontalTimeAxis.encodeDateFormat)]}" style="text-align: {align}; width: {width}px; {style}" tabIndex="0"' + 'headerPosition="{parent.position}" headerIndex="{[xindex-1]}">' + '<div class="sch-simple-timeheader">{header}</div>{{resizeHandle}}' + '</td>' + '</tpl>' + '</tr>' + '</tbody>' + '</table>',
    // TODO DOCS
    model: null,
    // TODO DOCS
    hoverCls: '',
    // optional
    // this view class will work in 2 modes - one with provided `containerEl` and one w/o it
    containerEl: null,
    height: null,
    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event refresh
     * Fires after the view has been updated, (after the time axis has been reconfigured,
     * or as a result of time column width change or available schedule width change).
     * @param {Sch.view.HorizontalTimeAxis} timeAxisView The time axis view
     */
    constructor: function(config) {
        var me = this;
        var isTouch = !!Ext.versions.touch;
        Ext.apply(this, config);
        me.callParent(arguments);
        me.model.on('update', me.onModelUpdate, this, {
            priority: 5
        });
        me.containerEl = Ext.get(me.containerEl);
        if (!(me.headerHtmlRowTpl instanceof Ext.Template)) {
            if (Ext.isString(me.headerHtmlRowTpl)) {
                me.headerHtmlRowTpl = me.headerHtmlRowTpl.replace('{{baseCls}}', this.baseCls).replace('{{tableCls}}', this.tableCls).replace('{{resizeHandle}}', this.enableTickResizing ? '<div class="sch-header-cell-resizehandle"></div>' : '');
            }
            me.headerHtmlRowTpl = new Ext.XTemplate(me.headerHtmlRowTpl);
        }
        if (me.trackHeaderOver && me.hoverCls) {
            me.containerEl.on({
                mousemove: me.highlightCell,
                delegate: '.' + this.baseCls,
                scope: me
            });
            me.containerEl.on({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }
        var listenerCfg = {
                scope: this,
                delegate: '.' + this.baseCls
            };
        if (isTouch) {
            listenerCfg.tap = this.onElClick('tap');
            listenerCfg.doubletap = this.onElClick('doubletap');
        } else {
            listenerCfg.click = this.onElClick('click');
            listenerCfg.dblclick = this.onElClick('dblclick');
            listenerCfg.contextmenu = this.onElClick('contextmenu');
        }
        me._listenerCfg = listenerCfg;
        if (me.containerEl)  {
            me.containerEl.on(listenerCfg);
        }
        
    },
    destroy: function() {
        var me = this;
        if (me.containerEl) {
            me.containerEl.un(me._listenerCfg);
            me.containerEl.un({
                mousemove: me.highlightCell,
                delegate: '.sch-simple-timeheader',
                scope: me
            });
            me.containerEl.un({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }
        me.model.un('update', me.onModelUpdate, this, {
            priority: 5
        });
    },
    onModelUpdate: function() {
        // Header should be sized according to locking partner, that's why before rendering new header
        // we set height to null - to prevent time axis from stretching header container
        this.height = null;
        this.render();
    },
    getHTML: function() {
        var columnConfig = this.model.getColumnConfig();
        var totalWidth = this.model.getTotalWidth();
        var nbrRows = Ext.Object.getKeys(columnConfig).length;
        var html = '';
        if (columnConfig.top) {
            this.embedCellWidths(columnConfig.top);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.top,
                position: 'top',
                tstyle: 'border-top : 0;'
            });
        }
        if (columnConfig.middle) {
            this.embedCellWidths(columnConfig.middle);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.middle,
                position: 'middle',
                tstyle: columnConfig.top ? '' : 'border-top : 0;',
                cls: !columnConfig.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        if (columnConfig.bottom) {
            this.embedCellWidths(columnConfig.bottom);
            html += this.headerHtmlRowTpl.apply({
                totalWidth: totalWidth,
                cells: columnConfig.bottom,
                position: 'bottom',
                cls: this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        return html;
    },
    // Removes previously rendered timeaxis rows
    deleteTimeAxisRows: function() {
        var innerCt = this.containerEl,
            ctDom = innerCt.dom;
        Ext.fly(ctDom).select('table').remove();
    },
    // Outputs the tables and cells based on the header row config in the active viewPreset
    render: function() {
        if (!this.containerEl)  {
            return;
        }
        
        var innerCt = this.containerEl,
            ctDom = innerCt.dom,
            oldDisplay = ctDom.style.display,
            columnConfig = this.model.getColumnConfig(),
            parent = ctDom.parentNode;
        ctDom.style.display = 'none';
        parent.removeChild(ctDom);
        // Remove header table els manually, keeping secondary canvas element intact
        this.deleteTimeAxisRows();
        ctDom.insertAdjacentHTML('afterbegin', this.getHTML());
        if (!columnConfig.top && !columnConfig.middle) {
            this.containerEl.addCls('sch-header-single-row');
        } else {
            this.containerEl.removeCls('sch-header-single-row');
        }
        parent && parent.appendChild(ctDom);
        ctDom.style.display = oldDisplay;
        this.fireEvent('refresh', this);
    },
    embedCellWidths: function(cells, isLowestRow) {
        for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
            var width = this.model.getDistanceBetweenDates(cell.start, cell.end);
            if (width) {
                cell.width = width;
            } else {
                cell.width = 0;
                cell.style = 'display: none';
            }
        }
    },
    // private
    onElClick: function(eventName) {
        return function(event, target) {
            // Normalize ST vs Ext JS (Ext passes the delegated target as the target argument, ST passes the clicked DOM node)
            target = event.delegatedTarget || target;
            var position = Ext.fly(target).getAttribute('headerPosition'),
                index = Ext.fly(target).getAttribute('headerIndex'),
                headerConfig = this.model.getColumnConfig()[position][index];
            this.fireEvent('timeheader' + eventName, this, headerConfig.start, headerConfig.end, event);
        };
    },
    highlightCell: function(e, cell) {
        var me = this;
        if (cell !== me.highlightedCell) {
            me.clearHighlight();
            me.highlightedCell = cell;
            Ext.fly(cell).addCls(me.hoverCls);
        }
    },
    clearHighlight: function() {
        var me = this,
            highlighted = me.highlightedCell;
        if (highlighted) {
            Ext.fly(highlighted).removeCls(me.hoverCls);
            delete me.highlightedCell;
        }
    }
});
/* EOF Proxied model methods */

Ext.define('Sch.feature.HeaderResize', {
    extend: 'Ext.AbstractPlugin',
    selector: null,
    currentCell: null,
    originalCellWidth: null,
    startClientX: null,
    timeAxisViewModel: null,
    minCellWidth: 15,
    init: function(column) {
        column.on('render', this.onColumnRender, this);
    },
    onColumnRender: function(column) {
        column.getEl().on('mousedown', this.onMouseDown, this, {
            delegate: this.selector
        });
    },
    getClientX: function(e) {
        return Ext.isNumber(e.clientX) ? e.clientX : e.browserEvent.clientX;
    },
    onMouseDown: function(e, t) {
        var me = this,
            cellEl = t.parentElement;
        me.originalCellWidth = Ext.fly(cellEl).getWidth();
        me.startClientX = me.getClientX(e);
        me.currentCell = cellEl;
        me.getCmp().mon(Ext.getBody(), 'mousemove', me.onMouseMove, me);
        me.getCmp().mon(Ext.getBody(), 'mouseup', me.onMouseUp, me, {
            capture: true,
            single: true
        });
    },
    onMouseMove: function(e, t) {
        var me = this,
            cellEl = me.currentCell,
            nextCellEl = cellEl.nextSibling,
            delta = me.startClientX - me.getClientX(e),
            originalWidth = me.originalCellWidth,
            newWidth = Math.max(me.minCellWidth, originalWidth - delta);
        if (nextCellEl && newWidth < originalWidth) {
            // Resize adjacent cell if shrinking this cell
            var nextWidth = Math.min(originalWidth * 2 - me.minCellWidth, originalWidth + delta);
            nextCellEl.style.width = nextWidth + 'px';
        }
        cellEl.style.width = newWidth + 'px';
    },
    onMouseUp: function(e, t) {
        var me = this,
            // HACK, should avoid using cmp.up() but this plugin + timeaxisColumn are heavily tied to Timeline Panel anyway
            // Better having the life cycle of this feature managed by column, then to place this code in top Scheduler component
            timelinePanel = me.getCmp().up('timelinegrid,timelinetree'),
            date = timelinePanel.getSchedulingView().getDateFromCoordinate(Ext.fly(me.currentCell).getLeft()),
            // The position of the time cell in the schedule view port, we want to maintain this scroll point after changing the tick width
            scrollOffset = Ext.fly(me.currentCell).getX() - timelinePanel.getSchedulingView().getX(),
            deltaX = me.getClientX(e) - me.startClientX,
            ratio = (me.originalCellWidth / me.timeAxisViewModel.getTickWidth()),
            newTickWidth = Math.max(me.minCellWidth, me.timeAxisViewModel.getTickWidth() + (deltaX / ratio));
        me.timeAxisViewModel.setTickWidth(Math.round(newTickWidth));
        timelinePanel.scrollToDate(date, false, scrollOffset);
        me.getCmp().mun(Ext.getBody(), 'mousemove', me.onMouseMove, me);
        this.currentCell = this.offset = null;
    }
});

/**
 * @class Sch.column.timeAxis.Horizontal
 * @extends Ext.grid.column.Column
 *
 *
 * A simple grid column providing a visual representation of the time axis. This class does not produce any real Ext JS grid columns, instead it just renders a Sch.view.HorizontalTimeAxis inside its element.
 * This class can represent up to three different axes, that are defined in the view preset config object.
 */
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.timeaxiscolumn',
    requires: [
        'Sch.view.HorizontalTimeAxis',
        'Sch.feature.HeaderResize'
    ],
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    resizable: false,
    menuDisabled: true,
    cls: 'sch-simple-timeaxis',
    tdCls: 'sch-timetd',
    enableLocking: false,
    locked: false,
    lockable: false,
    /**
    * @cfg {Boolean} enableTickResizing true to enable resizing the timeaxis 'ticks'
    **/
    enableTickResizing: false,
    // Prevents Ext from focusing cells on mousedown anywhere, which resets scroll to 0
    cellFocusable: false,
    timeAxisViewModel: null,
    headerView: null,
    // Disable Ext JS default header hover highlight
    hoverCls: '',
    ownHoverCls: 'sch-column-header-over',
    /*
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver: true,
    /*
     * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact',
     * which adds a special CSS class to the header row.
     */
    compactCellWidthThreshold: (Ext.theme && Ext.theme.name.toLowerCase() === 'classic') ? 15 : 35,
    initComponent: function() {
        if (this.enableTickResizing) {
            this.addPlugin(new Sch.feature.HeaderResize({
                selector: '.sch-header-cell-resizehandle',
                timeAxisViewModel: this.timeAxisViewModel
            }));
        }
        this.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        // HACK relying on private accessor 'titleEl'
        var ct = me.titleEl.createChild({
                cls: 'sch-horizontaltimeaxis-ct'
            });
        if (!(me.headerView instanceof Sch.view.HorizontalTimeAxis)) {
            me.headerView = Ext.create(Ext.applyIf(me.headerView || {}, {
                xclass: 'Sch.view.HorizontalTimeAxis',
                model: me.timeAxisViewModel,
                containerEl: ct,
                hoverCls: me.ownHoverCls,
                trackHeaderOver: me.trackHeaderOver,
                enableTickResizing: this.enableTickResizing,
                compactCellWidthThreshold: me.compactCellWidthThreshold
            }));
        }
        me.headerView.on('refresh', me.onTimeAxisViewRefresh, me);
        me.headerView.render();
        me.ownerCt.grid.on('afterlayout', function() {
            // column can be rendered after grid was reconfigured
            if (!me.ownerCt) {
                return;
            }
            // If the container of this column changes size, we need to re-evaluate the size for the
            // time axis view
            me.mon(me.ownerCt, "resize", me.onHeaderContainerResize, me);
            if (this.getWidth() > 0) {
                // In case the timeAxisViewModel is shared, no need to update it
                if (me.getAvailableWidthForSchedule() !== me.timeAxisViewModel.getAvailableWidth()) {
                    me.timeAxisViewModel.update(me.getAvailableWidthForSchedule());
                }
                me.setWidth(me.timeAxisViewModel.getTotalWidth());
            }
        }, null, {
            single: true
        });
        this.enableBubble('timeheaderclick', 'timeheaderdblclick', 'timeheadercontextmenu', 'horizontaltimeaxiscolumnrender');
        me.relayEvents(me.headerView, [
            'timeheaderclick',
            'timeheaderdblclick',
            'timeheadercontextmenu'
        ]);
        me.callParent(arguments);
        // we don't need timeline to be focusable, it messes up the 'timeheader*' events and looses scroll in IE
        me.focusable = false;
        this.fireEvent('horizontaltimeaxiscolumnrender', this);
    },
    initRenderData: function() {
        var me = this;
        me.renderData.headerCls = me.renderData.headerCls || me.headerCls;
        return me.callParent(arguments);
    },
    destroy: function() {
        if (this.headerView) {
            this.headerView.destroy();
            this.headerView = null;
        }
        this.callParent(arguments);
    },
    onTimeAxisViewRefresh: function() {
        var owningScheduler = this.getRootHeaderCt().grid;
        // No action if the Scheduler has not completed its initial layout <--------------------- This is a general principle. on render is not useful for this reason.
        if (!owningScheduler || owningScheduler.componentLayoutCounter) {
            // Make sure we don't create an infinite loop
            this.headerView.un('refresh', this.onTimeAxisViewRefresh, this);
            var newWidth = this.timeAxisViewModel.getTotalWidth();
            if (this.getWidth() !== newWidth) {
                this.setWidth(newWidth);
            } else {
                // trigger update layout in order to flush header height
                this.updateLayout();
            }
            this.ensureSizing();
            this.headerView.on('refresh', this.onTimeAxisViewRefresh, this);
        }
    },
    getAvailableWidthForSchedule: function() {
        // When applying state to rendered scheduler, Ext will remove content from normal and locked headers keeping
        // instances alive (#2580)
        if (!this.ownerCt) {
            return 0;
        }
        // In case owner container is hidden then it and it's items will return zero width, if so we fallback to
        // lastBox private property of Ext.AbstractComponent
        var available = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : (this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0),
            items = this.ownerCt.items,
            item;
        // substracting the widths of all columns starting from 2nd ("right" columns)
        for (var i = 1; i < items.length; i++) {
            item = items.get(i);
            if (!item.hidden) {
                available -= item.isVisible(true) ? item.getWidth() : (item.lastBox && item.lastBox.width || 0);
            }
        }
        return Math.max(0, available - Ext.getScrollbarSize().width - 1);
    },
    onResize: function() {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
    },
    onHeaderContainerResize: function(header, width, height, oldWidth, oldHeight) {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        if (height !== oldHeight) {
            this.headerView.render();
        }
    },
    // Check to make sure the timeaxis column content is at least the size of the locked grid
    // Scenario is a locked column with tall content, e.g. a text + text field, or foo<br>bar<br>baz
    // If time axis is only one level, we need to stretch it to match the height of the column
    ensureSizing: function() {
        var viewContainerEl = this.headerView.containerEl;
        var availableHeight = this.ownerCt.getHeight();
        var renderedTimeAxisHeight = viewContainerEl.getHeight();
        var heightDiff = availableHeight - renderedTimeAxisHeight;
        if (heightDiff > 0) {
            var lastRow = viewContainerEl.down('table:last-of-type tr');
            if (lastRow) {
                viewContainerEl.select('table tr').setHeight(availableHeight / this.timeAxisViewModel.getHeaders().length);
            }
        }
    },
    /*
     * Refreshes the column header contents. Useful if you have some extra meta data in your timeline header that
     * depends on external data such as the EventStore or ResourceStore.
     */
    refresh: function() {
        if (this.rendered) {
            // Update the model, but don't fire any events which will fully redraw view
            this.timeAxisViewModel.update(null, true);
            // Now the model state has been refreshed so headers can be rerendered
            this.headerView.render();
        }
    }
});

/**
 * @class Sch.column.timeAxis.Vertical
 *
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in vertical orientation
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.timeAxis.Vertical', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.verticaltimeaxis',
    /*
     * Default timeaxis column properties
     */
    align: 'right',
    draggable: false,
    groupable: false,
    hideable: false,
    sortable: false,
    menuDisabled: true,
    timeAxis: null,
    timeAxisViewModel: null,
    enableLocking: false,
    locked: true,
    lockable: false,
    dataIndex: 'start',
    initComponent: function() {
        this.callParent(arguments);
        this.tdCls = (this.tdCls || '') + ' sch-verticaltimeaxis-cell';
        this.scope = this;
        this.addCls('sch-verticaltimeaxis-header');
    },
    renderer: function(val, meta, record, rowIndex) {
        var viewModel = this.timeAxisViewModel;
        // With forceFit option in timeAxisViewModel in vertical mode we may try to render timeaxis column
        // which doesn't make sense, because header config is empty so just skip it
        if (!viewModel.columnConfig.middle) {
            return;
        }
        // subtract 1px for cell top border, defined in Sch/view/Vertical.scss
        meta.style = 'height:' + (viewModel.getTickWidth() - 1) + 'px';
        var header;
        // We only need fancy rendering in vertical mode
        // 040_schedulergrid
        if (!viewModel.isWeek() && val && viewModel.isMajorTick(val)) {
            header = viewModel.headerConfig[viewModel.getMajorHeaderName()];
            meta.tdCls += ' sch-column-line-solid';
        } else {
            header = viewModel.getBottomHeader();
        }
        if (header.renderer) {
            return header.renderer.call(header.scope || this, record.data.start, record.data.end, meta, rowIndex);
        } else {
            return Ext.Date.format(val, header.dateFormat);
        }
    }
});

/**
@class Sch.crud.encoder.Json
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _JSON_ as an encoding system.

```javascript
    // let's make new CrudManager using AJAX as a transport system and JSON for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Json', 'Sch.crud.transport.Ajax']
    });
```

*/
Ext.define('Sch.crud.encoder.Json', {
    format: 'json',
    /**
     * Encodes an request object to _JSON_ encoded string.
     * @param {Object} request The request to encode.
     */
    encode: function(request) {
        return Ext.JSON.encode(request);
    },
    /**
     * Decodes (parses) a _JSON_ response string to an object.
     * @param {Object} response The response to decode.
     */
    decode: function(response) {
        if (typeof response == 'object')  {
            return response;
        }
        
        return Ext.JSON.decode(response, true);
    }
});

/**
@class Sch.crud.encoder.Xml
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _XML_ as an encoding system.

```javascript
    // let's make new CrudManager using AJAX as a transport system and XML for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
    });
```

# Request structure

Load request example:

```xml
    <load requestId="123890">
        <store id="store1" page="1" pageSize="10"/>
        <store id="store2"/>
        <store id="store3"/>
    </load>
```

Sync request:

```xml
    <sync requestId="123890" revision="123">
        <store id="store1">
            <added>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="SomeField">smth</field>
                    ...
                </record>
                ...
            </added>
            <updated>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">new value</field>
                    ...
                </record>
                ...
            </updated>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <added>...</added>
            <updated>...</updated>
            <removed>...</removed>
        </store>
    </sync>
```

# Response structure

Load response example:

```xml
    <data requestId="123890" revision="123" success="true">

        <store id="store1">
            <rows total="5">
                <record>
                    <field id="Id">9000</field>
                    <field id="SomeField">xxxx</field>
                    ...
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">yyyy</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store2">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field1">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field1">bbb</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store3">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field2">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field2">bbb</field>
                    ...
                </record>
            </rows>
        </store>
    </data>
```

Sync response:

```xml
    <data requestId="123890" success="true" revision="124">
        <store id="store1">
            <rows>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="Id">9000</field>
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField2">2013-08-01</field>
                </record>
            </rows>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <rows>...</rows>
            <removed>...</removed>
        </store>
    </data>
```

# Error response

```xml
    <data requestId="123890" success="true" code="13">
        <message>Error description goes here</message>
    </data>
```

*/
Ext.define("Sch.crud.encoder.Xml", {
    requires: [
        'Ext.XTemplate'
    ],
    format: 'xml',
    stringReplaces: [
        [
            /&/g,
            '&amp;'
        ],
        [
            /</g,
            '&lt;'
        ],
        [
            />/g,
            '&gt;'
        ],
        [
            /"/g,
            '&quot;'
        ]
    ],
    // Translates a string characters to XML safe ones
    encodeString: function(text) {
        if (!text)  {
            return text;
        }
        
        var result = text.toString(),
            replaces = this.stringReplaces;
        for (var i = 0,
            l = replaces.length; i < l; i++) {
            result = result.replace(replaces[i][0], replaces[i][1]);
        }
        return result;
    },
    encodeRecords: function(records) {
        var result = '';
        for (var i = 0,
            l = records.length; i < l; i++) {
            result += this.encodeRecord(records[i]);
        }
        return result;
    },
    encodeRecord: function(record) {
        var result = '<record>';
        for (var i in record) {
            var field = record[i];
            result += '<field id="' + this.encodeString(i) + '">' + (field && field.$store ? this.encodeStoreChanges({
                storeId: i
            }, field) : this.encodeString(field)) + '</field>';
        }
        result += '</record>';
        return result;
    },
    encodeStoreChanges: function(store, changes) {
        var result = '<store id="' + this.encodeString(store.storeId) + '">';
        if (changes.added) {
            result += '<added>' + this.encodeRecords(changes.added) + '</added>';
        }
        if (changes.updated) {
            result += '<updated>' + this.encodeRecords(changes.updated) + '</updated>';
        }
        if (changes.removed) {
            result += '<removed>' + this.encodeRecords(changes.removed) + '</removed>';
        }
        result += '</store>';
        return result;
    },
    /**
     * Encodes an request object to _XML_ encoded string. The formats of requests are displayed in an intro.
     * @param {Object} request The request to encode.
     */
    encode: function(packet) {
        var result, i, l, store;
        switch (packet.type) {
            case 'load':
                result = '<load requestId="' + this.encodeString(packet.requestId) + '">';
                for (i = 0 , l = packet.stores.length; i < l; i++) {
                    store = packet.stores[i];
                    if (typeof store === 'string') {
                        result += '<store id="' + this.encodeString(store) + '"/>';
                    } else {
                        result += '<store id="' + this.encodeString(store.storeId) + '" page="' + this.encodeString(store.page) + '" pageSize="' + this.encodeString(store.pageSize) + '"/>';
                    }
                };
                result += '</load>';
                return result;
            case 'sync':
                result = '<sync requestId="' + this.encodeString(packet.requestId) + '" revision="' + this.encodeString(packet.revision) + '">';
                for (i in packet) {
                    if (packet.hasOwnProperty(i)) {
                        store = this.getStore(i);
                        if (store) {
                            result += this.encodeStoreChanges(store, packet[i]);
                        }
                    }
                };
                result += '</sync>';
                break;
        }
        return result;
    },
    stringToXML: function(text) {
        if (!text)  {
            return;
        }
        
        var document;
        /*global DOMParser: false, ActiveXObject: false */
        if (window.DOMParser) {
            document = (new DOMParser()).parseFromString(text, 'text/xml');
        } else if (window.ActiveXObject) {
            document = new ActiveXObject('Microsoft.XMLDOM');
            document.async = false;
            document.loadXML(text);
        }
        return document;
    },
    decodeRecords: function(rows) {
        var result = [];
        for (var j = 0,
            m = rows.length; j < m; j++) {
            result.push(this.decodeRecord(rows[j]));
        }
        return result;
    },
    decodeRecord: function(node) {
        var fields = node.childNodes,
            result = {},
            value;
        for (var i = 0,
            l = fields.length; i < l; i++) {
            var field = fields[i];
            if (field.nodeName == 'field') {
                value = '';
                if (field.firstChild) {
                    var store = this.getElementByTagName(field, 'store');
                    value = store ? this.decodeStore(store) : field.firstChild.nodeValue;
                }
                result[field.getAttribute('id')] = value;
            }
        }
        return result;
    },
    // search specified nodes only in a first level of children
    getElementsByTagName: function(node, name) {
        var children = node.childNodes,
            records = [];
        for (var i = 0,
            l = children.length; i < l; i++) {
            if (children[i].nodeName == name)  {
                records.push(children[i]);
            }
            
        }
        return records;
    },
    getElementByTagName: function(node, name) {
        var children = node.childNodes;
        for (var i = 0,
            l = children.length; i < l; i++) {
            if (children[i].nodeName == name)  {
                return children[i];
            }
            
        }
    },
    decodeStore: function(store) {
        var data = {},
            rows = this.getElementsByTagName(store, 'rows');
        if (rows.length) {
            data.rows = this.decodeRecords(this.getElementsByTagName(rows[0], 'record'));
            var total = parseInt(rows[0].getAttribute('total'), 10);
            if (isNaN(total) || total < data.rows.length)  {
                total = data.rows.length;
            }
            
            data.total = total;
        }
        var removed = this.getElementByTagName(store, 'removed');
        if (removed) {
            data.removed = this.decodeRecords(this.getElementsByTagName(removed, 'record'));
        }
        return data;
    },
    /**
     * Decodes (parses) a _XML_ response string to an object. The formats of processable server responses are displayed in an intro.
     * @param {Object} response The response to decode.
     */
    decode: function(packet) {
        var xml = typeof packet == 'string' ? this.stringToXML(packet) : packet;
        if (!xml)  {
            return;
        }
        
        var result = {},
            root = xml.documentElement,
            stores = root.getElementsByTagName('store'),
            store, storeId;
        result.requestId = root.getAttribute('requestId');
        result.revision = root.getAttribute('revision');
        result.success = root.getAttribute('success') || 'false';
        result.success = result.success.toLowerCase() == 'true';
        if (!result.success) {
            // extract error code
            result.code = root.getAttribute('code');
            var message = root.getElementsByTagName('message')[0];
            result.message = message && message.firstChild && message.firstChild.nodeValue;
        }
        for (var i = 0,
            l = stores.length; i < l; i++) {
            store = stores[i];
            storeId = store.getAttribute('id');
            if (this.getStore(storeId)) {
                result[storeId] = this.decodeStore(store);
            }
        }
        return result;
    }
});

/**
@class Sch.crud.transport.Ajax
@abstract
Implements data transferring functional that can be used for {@link Sch.crud.AbstractManager} super classing.
Uses AJAX as a transport system.

```javascript
// let's make new CrudManager using AJAX as a transport system and XML for encoding
Ext.define('MyCrudManager', {
    extend  : 'Sch.crud.AbstractManager',
    mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
});
```

*/
Ext.define('Sch.crud.transport.Ajax', {
    /**
     * @cfg {Object} transport
     * Configuration of the AJAX requests used to communicate with a server-side.
     * An object where you can set the following possible properties:
     * @cfg {Object} transport.load Load requests configuration:
     * @cfg {String} transport.load.url URL to request for data loading.
     * @cfg {String} [transport.load.method='POST'] HTTP method to be used for load requests.
     * @cfg {String} [transport.load.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.load.params] Extra load request params if needed.
     * @cfg {Object} [transport.load.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     * ```javascript
     * transport   : {
     *     load    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             }
     *         }
     *     }
     * }
     * ```
     *
     * @cfg {Object} transport.sync Sync requests configuration:
     * @cfg {String} transport.sync.url URL to request for data persisting.
     * @cfg {String} [transport.sync.method='POST'] HTTP method to be used for sync requests.
     * @cfg {String} [transport.sync.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.sync.params] Extra sync request params if needed.
     * @cfg {Object} [transport.sync.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     * ```javascript
     * transport   : {
     *     sync    : {
     *         requestConfig : {
     *             url             : 'http://some-url',
     *             method          : 'GET',
     *             // get rid of cache-buster parameter
     *             disableCaching  : false,
     *             // extra request parameters
     *             params          : {
     *                 foo         : 'bar'
     *             },
     *             // custom request headers
     *             headers         : {
     *                 ...
     *             }
     *         }
     *     }
     * }
     * ```
     */
    defaultMethod: {
        load: 'GET',
        sync: 'POST'
    },
    /**
     * Cancels sent request.
     * @param {Object} request The descriptor of request to be canceled. The _request descriptor_ is a value returned by corresponding {@link #sendRequest} call.
     */
    cancelRequest: function(request) {
        Ext.Ajax.abort(request);
    },
    /**
     * Sends request to the server.
     * @param {Object} request The request configuration object having following properties:
     * @param {String} request.data The encoded request.
     * @param {String} request.type The request type. Either `load` or `sync`.
     * @param {Function} request.success A function to be started on successful request transferring.
     * @param {Function} request.failure A function to be started on request transfer failure.
     * @param {Object} request.scope A scope for the above `success` and `failure` functions.
     * @return {Object} The request descriptor.
     */
    sendRequest: function(config) {
        var pack = config.data,
            packCfg = this.transport[config.type],
            paramName = packCfg.paramName,
            params = Ext.apply({}, packCfg && packCfg.params),
            method = packCfg.method || this.defaultMethod[config.type];
        var requestConfig = Ext.apply({
                url: packCfg.url,
                method: method,
                params: params,
                failure: config.failure,
                success: function(response, options) {
                    if (config.success) {
                        config.success.call(config.scope || this, response.responseXml || response.responseText);
                    }
                },
                scope: config.scope
            }, packCfg.requestConfig);
        // if no param name specified then we'll transfer package in the request body
        if (!paramName) {
            if (this.format === 'xml') {
                Ext.apply(requestConfig, {
                    xmlData: pack
                });
            } else {
                Ext.apply(requestConfig, {
                    jsonData: pack
                });
            }
        } else // ..otherwise we use parameter
        {
            requestConfig.params = requestConfig.params || {};
            requestConfig.params[paramName] = pack;
        }
        /**
         * @event beforesend
         * Fires before a request is sent to the server.
         *
         * ```javascript
         * crudManager.on('beforesend', function (crud, params, requestType) {
         *     // let's set "sync" request parameters
         *     if (requestType == 'sync') {
         *         // dynamically depending on "flag" value
         *         if (flag) {
         *             params.foo = 'bar';
         *         } else {
         *             params.foo = 'smth';
         *         }
         *     }
         * });
         * ```
         *
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} params Request params
         * @param {String} requestType Request type (`load`/`sync`)
         * @param {Object} requestConfig Configuration object for Ext.Ajax.request call
         */
        this.fireEvent('beforesend', this, params, config.type, requestConfig);
        return Ext.Ajax.request(requestConfig);
    }
});

/**
 * @class Sch.util.Patch
 * @static
 * @private
 * Private utility class for Ext JS patches for the Bryntum components.
 *
 * Each subclass of this should patch *ONE* platform bug, to be able to easily scope the fix only to affected versions
 */
Ext.define('Sch.util.Patch', {
    // Trial package dependencies
    uses: [
        'Ext.util.Cookies',
        'Ext.data.Connection',
        'Ext.Component'
    ],
    /**
     * @cfg {String} target The class name to override
     */
    target: null,
    /**
     * @cfg {String} minVersion The minimum Ext JS version for which this override is applicable. E.g. "4.0.5"
     */
    minVersion: null,
    /**
     * @cfg {String} maxVersion The highest Ext JS version for which this override is applicable. E.g. "4.0.7"
     */
    maxVersion: null,
    /**
     * @cfg {String} reportUrl A url to the forum post describing the bug/issue in greater detail
     */
    reportUrl: null,
    /**
     * @cfg {String} obsoleteTestName A name of the test checking if this patch is obsolete and might be removed
     */
    obsoleteTestName: null,
    /**
     * @cfg {String} description A brief description of why this override is required
     */
    description: null,
    /**
     * @cfg {Function} applyFn A function that will apply the patch(es) manually, instead of using 'overrides';
     */
    applyFn: null,
    /**
     * @cfg {Boolean} ieOnly true if patch is only applicable to IE
     */
    ieOnly: false,
    /**
     * @cfg {Boolean} macOnly true if patch is only applicable for Mac
     */
    macOnly: false,
    /**
     * @cfg {Object} overrides a custom object containing the methods to be overridden.
     */
    overrides: null,
    onClassExtended: function(cls, data) {
        if (Sch.disableOverrides) {
            return;
        }
        if (data.ieOnly && !Ext.isIE) {
            return;
        }
        if (data.macOnly && !Ext.isMac) {
            return;
        }
        if ((!data.minVersion || Ext.versions.extjs.equals(data.minVersion) || Ext.versions.extjs.isGreaterThan(data.minVersion)) && (!data.maxVersion || Ext.versions.extjs.equals(data.maxVersion) || Ext.versions.extjs.isLessThan(data.maxVersion))) {
            // Make sure class is loaded before applying override
            Ext.require(data.target, function() {
                if (data.applyFn) {
                    // Custom override, implementor has full control
                    data.applyFn();
                } else if (data.overrides) {
                    // Simple case, just an Ext override
                    Ext.ClassManager.get(data.target).override(data.overrides);
                }
            });
        }
    }
});

Ext.define('Sch.patches.CollectionKey', {
    extend: 'Sch.util.Patch',
    target: 'Ext.util.CollectionKey',
    minVersion: '6.0.0',
    reportUrl: 'https://www.sencha.com/forum/showthread.php?310532-Ext.util.Collection-key-configuration-application-and-cloning-is-broken',
    obsoleteTestName: 'patches/001_collection_key.t.js',
    description: [
        'Ext.util.CollectionKey::clone() is broken due to wrong usage of Ext\'s configuration facility.',
        'We relay on the (though) private Ext.data.LocalStore::extraKeys configuration, we use it to define additional',
        'unique but complex keys for Assignment and Dependency stores. Upon store filtering such keys are being cloned',
        'but due to the broken config key\'s clone() method throws an exception'
    ].join(' '),
    applyFn: function() {
        var applyFn;
        applyFn = Ext.util.CollectionKey.prototype.applyKeyFn;
        Ext.util.CollectionKey.prototype.applyKeyFn = Ext.identityFn;
        Ext.util.CollectionKey.prototype.updateKeyFn = applyFn;
    }
});

/**
 * Simple caching utility.
 *
 * Internaly obtains a key value suitable to be used as object property name via {@link Sch.util.Cache#key key()}
 * method and caches a value provided under the key obtained, values with the same key are groupped
 * into single array. Cached values are obtained via {@link Sch.util.Cache#get get()} method and are managed via
 * {@link Sch.util.Cache#add add()}, {@link Sch.util.Cache#remove remove()}, {@link Sch.util.Cache#move move()},
 * {@link Sch.util.Cache#clear clear()}
 * methods.
 */
Ext.define('Sch.util.Cache', {
    cache: null,
    /**
     * @constructor
     */
    constructor: function() {
        var me = this;
        me.cache = {};
        me.self.stats[Ext.getClassName(me)] = me.stats = {
            hit: 0,
            miss: 0
        };
    },
    /**
     * A function returning a key for given value.
     *
     * @param  {Mixed} v
     * @return {String}
     * @template
     */
    key: function(v) {
        var result;
        if (v && v.isModel) {
            result = v.getId().toString();
        } else if (v === undefined || v === null) {
            result = "[ undefined / null ]";
        } else {
            result = (v).toString();
        }
        return result;
    },
    /**
     * Checks if cache has given key cached
     *
     * @param {Mixed} k
     * @return {Boolean}
     */
    has: function(k) {
        var me = this;
        k = me.key(k);
        return me.cache.hasOwnProperty(k);
    },
    /**
     * Returns all values cached with a given key, or if key isn't present executes a given function, caches
     * it's result (which should be array) after it's mapped over {@link #map} and returns it.
     *
     * *Warning*: the array returned must not be modified otherwise cache integrity will be violated.
     *
     * @param {Mixed} k
     * @param {Function} [fn]
     * @param {[Mixed]}  [fn.return]
     * @return {[Mixed]}
     */
    get: function(k, fn) {
        var me = this,
            result;
        k = me.key(k);
        result = me.cache.hasOwnProperty(k) && me.cache[k];
        !result && fn ? (++me.stats.miss) : (++me.stats.hit);
        if (!result && fn) {
            result = fn();
        } else if (!result) {
            result = [];
        }
        me.cache[k] = result;
        return result;
    },
    /**
     * Caches a value using either a key provided or a key obtained from {@link #key key()} method.
     * If value is not given then the key is added to the cache with nothing cached under it.
     *
     * @param {Mixed} k
     * @param {Mixed} [v]
     * @chainable
     */
    add: function(k, v) {
        var me = this,
            kAdopted = me.key(k);
        if (!me.cache.hasOwnProperty(kAdopted)) {
            me.cache[kAdopted] = me.get(k);
        }
        // initial key cache filling
        arguments.length > 1 && Ext.Array.include(me.cache[kAdopted], v);
        return me;
    },
    /**
     * Sets cached values for the given key, replace everything cached for the given key with new values.
     *
     * @param {Mixed} k
     * @param {[Mixed]} vals
     * @chainable
     */
    set: function(k, vals) {
        var me = this,
            kAdopted = me.key(k);
        me.cache[kAdopted] = vals;
        return me;
    },
    /**
     * Removes cached value from cache under a given key or under a key obtained from {@link #key key()} method.
     *
     * @param {Mixed} k
     * @param {Mixed} v
     * @chainable
     */
    remove: function(k, v) {
        var me = this;
        k = me.key(k);
        if (me.cache.hasOwnProperty(k)) {
            Ext.Array.remove(me.cache[k], v);
        }
        return me;
    },
    /**
     * Moves all items or a single item under old key to new key
     *
     * @param {Mixed} oldKey
     * @param {Mixed} newKey
     * @chainable
     */
    move: function(oldKey, newKey, v) {
        var me = this;
        oldKey = me.key(oldKey);
        newKey = me.key(newKey);
        if (oldKey != newKey && arguments.length >= 3) {
            me.remove(oldKey, v);
            me.add(newKey, v);
        } else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey) && me.cache.hasOwnProperty(newKey)) {
            me.cache[newKey] = Ext.Array.union(me.cache[newKey], me.cache[oldKey]);
            me.cache[oldKey] = [];
        } else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey)) {
            me.cache[newKey] = me.cache[oldKey];
            me.cache[oldKey] = [];
        }
        return me;
    },
    /**
     * Clears entire cache, or clears cache for a given key.
     *
     * @param {Mixed} [k]
     * @chainable
     */
    clear: function(k) {
        var me = this;
        if (!arguments.length) {
            me.cache = {};
        } else {
            k = me.key(k);
            if (me.cache.hasOwnProperty(k)) {
                delete me.cache[k];
            }
        }
        return me;
    },
    /**
     * Removes value from entire cache (from every key it exists under).
     *
     * @param {Mixed} v
     * @chainable
     */
    uncache: function(v) {
        var me = this,
            k;
        for (k in me.cache) {
            if (me.cache.hasOwnProperty(k)) {
                me.cache[k] = Ext.Array.remove(me.cache[k], v);
            }
        }
        return me;
    },
    inheritableStatics: {
        stats: {}
    }
});

/**
 * Assignment store event->assignments cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.EventAssignmentsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    assignmentStoreFiltersDetacher: null,
    eventStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.add(assignment.getEventId(), assignment);
            });
        }
        function onAssignmentRemove(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.remove(assignment.getEventId(), assignment);
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField];
            if (eventIdChanged) {
                me.move(previousEventId, assignment.getEventId(), assignment);
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
        }
        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.clear(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(store) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = store && store.on({
                idchanged: onEventIdChanged,
                remove: onEventRemove,
                cacheresethint: onEventStoreClearOrReset,
                clear: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            cacheresethint: onAssignmentStoreClearOrReset,
            clear: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStoreFiltersDetacher = assignmentStore.getFilters().on({
            endupdate: onAssignmentStoreClearOrReset,
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToEventStore(eventStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'assignmentStoreFiltersDetacher', 'eventStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getEventId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/**
 * Assignment store resource->assignments cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceAssignmentsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.add(assignment.getResourceId(), assignment);
            });
        }
        function onAssignmentRemove(store, assignments) {
            Ext.Array.each(assignments, function(assignment) {
                me.remove(assignment.getResourceId(), assignment);
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField];
            if (resourceIdChanged) {
                me.move(previousResourceId, assignment.getResourceId(), assignment);
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            clear: onAssignmentStoreClearOrReset,
            cacheresethint: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStoreFiltersDetacher = assignmentStore.getFilters().on('endupdate', onAssignmentStoreClearOrReset, me, {
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'assignmentStoreFiltersDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getResourceId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/**
 * This mixin eliminates differences between flat/tree store in get by [internal] id functionality and it should be
 * mixed into data model stores.
 *
 * It adds two methods {@link #getModelById getModelById()} and {@link #getModelByInternalId getModelByInternalId()}
 * which should be used everywhere in the code instead of native getById() / getByInternalId() methods.
 *
 * @private
 */
Ext.define('Sch.data.mixin.UniversalModelGetter', {
    /**
     * @method getModelById
     * @param {String/Number} id
     * @return {Ext.data.Model/Null}
     */
    /**
     * @method getModelByInternalId
     * @param {String/Number} internalId
     * @return {Ext.data.Model/Null}
     */
    onClassMixedIn: function(targetClass) {
        var overrides = {};
        // getModelById:
        // -------------
        // - Tree store case
        if (targetClass.prototype.isTreeStore) {
            overrides.getModelById = targetClass.prototype.getNodeById;
        } else // - Flat store case
        {
            overrides.getModelById = targetClass.prototype.getById;
        }
        // getModelByInternalId:
        // ---------------------
        // - Tree store case (relaying heavily on the Sch.patch.TreeStoreInternalIdMap)
        if (targetClass.prototype.isTreeStore) {
            overrides.getModelByInternalId = function(id) {
                return this.byInternalIdMap[id] || null;
            };
        } else // - Flat store case
        {
            overrides.getModelByInternalId = targetClass.prototype.getByInternalId;
        }
        Ext.override(targetClass, overrides);
    }
});

/**
 * This mixin intercepts a set of store methods and firing a set of events providing a cache with a better hint
 * when to update itself.
 *
 * @private
 */
Ext.define('Sch.data.mixin.CacheHintHelper', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        before: {
            loadRecords: 'loadRecords',
            removeAll: 'removeAll'
        }
    },
    // Call to loadRecords() results in 'datachanged' and 'refresh' events, but 'datachanged' is also fired upon
    // call to add/remove/write/filter/sort/removeAll so a cache cannot detect what method call results in 'datachanged'
    // in case of previosly mentioned methods a cache shouldn't handle 'datachanged' event it is not affected by
    // write/filter/sort at all, as for add/remove/removeAll it listens to preceding events like 'add'/'remove'/'clear'
    // and reflects updates correspondingly. But in case of loadRecords() the sequence of events fired 'datachanged' and
    // 'refresh' provides too little information to make right decision whether to reset a cache or not, moreover resetting
    // a cache on 'refresh' is to late since a lot of logic (rendering logic especially) start quering the store
    // upon 'datachanged' event and thus if cache wasn't reset it will provide that logic with outdated data.
    // Thus I have to override loadRecords() and make it fire private 'cacheresethint' event to provide a cache with
    // a way to reset itself beforehand.
    loadRecords: function() {
        this.fireEvent('cacheresethint', this);
    },
    // If no event is fired for the removal, we need to clear cache manually
    removeAll: function(silent) {
        if (silent) {
            this.fireEvent('cacheresethint', this);
        }
    }
});

/**
 * @class Sch.util.Date
 * @static
 * Static utility class for Date manipulation
 */
Ext.define('Sch.util.Date', {
    requires: 'Ext.Date',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    singleton: true,
    // These stem from Ext.Date in Ext JS but since they don't exist in Sencha Touch we'll need to keep them here
    stripEscapeRe: /(\\.)/g,
    hourInfoRe: /([gGhHisucUOPZ]|MS)/,
    unitHash: null,
    unitsByName: {},
    // Readonly
    MIN_VALUE: new Date(-8.64E15),
    MAX_VALUE: new Date(8.64E15),
    // Override this to localize the time unit names.
    //unitNames   : {
    //YEAR    : { single : 'year', plural : 'years', abbrev : 'yr' },
    //QUARTER : { single : 'quarter', plural : 'quarters', abbrev : 'q' },
    //MONTH   : { single : 'month', plural : 'months', abbrev : 'mon' },
    //WEEK    : { single : 'week', plural : 'weeks', abbrev : 'w' },
    //DAY     : { single : 'day', plural : 'days', abbrev : 'd' },
    //HOUR    : { single : 'hour', plural : 'hours', abbrev : 'h' },
    //MINUTE  : { single : 'minute', plural : 'minutes', abbrev : 'min' },
    //SECOND  : { single : 'second', plural : 'seconds', abbrev : 's' },
    //MILLI   : { single : 'ms', plural : 'ms', abbrev : 'ms' }
    //},
    constructor: function() {
        var me = this,
            ED = Ext.Date;
        var unitHash = me.unitHash = {
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MILLI: ED.MILLI,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                SECOND: ED.SECOND,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MINUTE: ED.MINUTE,
                /** Date interval constant
             * @static
             * @type String
             */
                HOUR: ED.HOUR,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                DAY: ED.DAY,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                WEEK: "w",
                /**
             * Date interval constant
             * @static
             * @type String
             */
                MONTH: ED.MONTH,
                /**
             * Date interval constant
             * @static
             * @type String
             */
                QUARTER: "q",
                /**
             * Date interval constant
             * @static
             * @type String
             */
                YEAR: ED.YEAR
            };
        Ext.apply(me, unitHash);
        me.units = [
            me.MILLI,
            me.SECOND,
            me.MINUTE,
            me.HOUR,
            me.DAY,
            me.WEEK,
            me.MONTH,
            me.QUARTER,
            me.YEAR
        ];
    },
    onLocalized: function() {
        this.setUnitNames(this.L('unitNames'));
    },
    /**
     * Call this method to provide your own, localized values for duration unit names. See the "/js/Sch/locale/sch-lang-*.js" files for examples
     *
     * @param {Object} unitNames
     */
    setUnitNames: function(unitNames) {
        var unitsByName = this.unitsByName = {};
        this.l10n.unitNames = unitNames;
        this._unitNames = Ext.apply({}, unitNames);
        var unitHash = this.unitHash;
        // Make it possible to lookup readable date names from both 'DAY' and 'd' etc.
        for (var name in unitHash) {
            if (unitHash.hasOwnProperty(name)) {
                var unitValue = unitHash[name];
                this._unitNames[unitValue] = this._unitNames[name];
                unitsByName[name] = unitValue;
                unitsByName[unitValue] = unitValue;
            }
        }
    },
    /**
     * Checks if this date is >= start and < end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on the start date or between the given start and end dates.
     * @static
     */
    betweenLesser: function(date, start, end) {
        return start <= date && date < end;
    },
    /**
     * Checks if this date is >= start and <= end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @static
     */
    betweenLesserEqual: function(date, start, end) {
        return start <= date && date <= end;
    },
    /**
     * Constrains the date within a min and a max date
     * @param {Date} date The date to constrain
     * @param {Date} min Min date
     * @param {Date} max Max date
     * @return {Date} The constrained date
     * @static
     */
    constrain: function(date, min, max) {
        return this.min(this.max(date, min), max);
    },
    /**
     * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    compareUnits: function(u1, u2) {
        var ind1 = Ext.Array.indexOf(this.units, u1),
            ind2 = Ext.Array.indexOf(this.units, u2);
        return ind1 > ind2 ? 1 : (ind1 < ind2 ? -1 : 0);
    },
    /**
     * Returns true if first unit passed is strictly greater than the second.
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    isUnitGreater: function(u1, u2) {
        return this.compareUnits(u1, u2) > 0;
    },
    /**
     * Copies hours, minutes, seconds, milliseconds from one date to another
     * @static
     *
     * @param {Date} targetDate The target date
     * @param {Date} sourceDate The source date
     * @return {Date} The adjusted target date
     */
    copyTimeValues: function(targetDate, sourceDate) {
        targetDate.setHours(sourceDate.getHours());
        targetDate.setMinutes(sourceDate.getMinutes());
        targetDate.setSeconds(sourceDate.getSeconds());
        targetDate.setMilliseconds(sourceDate.getMilliseconds());
        return targetDate;
    },
    /**
     * Adds a date unit and interval
     * @param {Date} date The source date
     * @param {String} unit The date unit to add
     * @param {Number} value The number of units to add to the date
     * @return {Date} The new date
     * @static
     */
    add: function(date, unit, value) {
        var d = Ext.Date.clone(date);
        if (!unit || value === 0)  {
            return d;
        }
        
        switch (unit.toLowerCase()) {
            case this.MILLI:
                d = new Date(date.getTime() + value);
                break;
            case this.SECOND:
                d = new Date(date.getTime() + (value * 1000));
                break;
            case this.MINUTE:
                d = new Date(date.getTime() + (value * 60000));
                break;
            case this.HOUR:
                d = new Date(date.getTime() + (value * 3600000));
                break;
            case this.DAY:
                d.setDate(date.getDate() + value);
                if (d.getHours() === 23 && date.getHours() === 0) {
                    d = Ext.Date.add(d, Ext.Date.HOUR, 1);
                };
                break;
            case this.WEEK:
                d.setDate(date.getDate() + value * 7);
                break;
            case this.MONTH:
                var day = date.getDate();
                if (day > 28) {
                    day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
                };
                d.setDate(day);
                d.setMonth(d.getMonth() + value);
                break;
            case this.QUARTER:
                d = this.add(date, this.MONTH, value * 3);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + value);
                break;
        }
        return d;
    },
    getUnitDurationInMs: function(unit) {
        // hopefully there were no DST changes in year 1
        return this.add(new Date(1, 0, 1), unit, 1) - new Date(1, 0, 1);
    },
    getMeasuringUnit: function(unit) {
        if (unit === this.WEEK) {
            return this.DAY;
        }
        return unit;
    },
    /**
     * @method getDurationInUnit
     * Returns a duration of the timeframe in the given unit.
     * @static
     * @param {Date} start The start date of the timeframe
     * @param {Date} end The end date of the timeframe
     * @param {String} unit Duration unit
     * @return {Number} The duration in the units
     */
    /** @ignore */
    getDurationInUnit: function(start, end, unit, doNotRound) {
        var units;
        switch (unit) {
            case this.YEAR:
                units = this.getDurationInYears(start, end);
                break;
            case this.QUARTER:
                units = this.getDurationInMonths(start, end) / 3;
                break;
            case this.MONTH:
                units = this.getDurationInMonths(start, end);
                break;
            case this.WEEK:
                units = this.getDurationInDays(start, end) / 7;
                break;
            case this.DAY:
                units = this.getDurationInDays(start, end);
                break;
            case this.HOUR:
                units = this.getDurationInHours(start, end);
                break;
            case this.MINUTE:
                units = this.getDurationInMinutes(start, end);
                break;
            case this.SECOND:
                units = this.getDurationInSeconds(start, end);
                break;
            case this.MILLI:
                units = this.getDurationInMilliseconds(start, end);
                break;
        }
        return doNotRound ? units : Math.round(units);
    },
    getUnitToBaseUnitRatio: function(baseUnit, unit) {
        if (baseUnit === unit) {
            return 1;
        }
        switch (baseUnit) {
            case this.YEAR:
                switch (unit) {
                    case this.QUARTER:
                        return 1 / 4;
                    case this.MONTH:
                        return 1 / 12;
                };
                break;
            case this.QUARTER:
                switch (unit) {
                    case this.YEAR:
                        return 4;
                    case this.MONTH:
                        return 1 / 3;
                };
                break;
            case this.MONTH:
                switch (unit) {
                    case this.YEAR:
                        return 12;
                    case this.QUARTER:
                        return 3;
                };
                break;
            case this.WEEK:
                switch (unit) {
                    case this.DAY:
                        return 1 / 7;
                    case this.HOUR:
                        return 1 / 168;
                };
                break;
            case this.DAY:
                switch (unit) {
                    case this.WEEK:
                        return 7;
                    case this.HOUR:
                        return 1 / 24;
                    case this.MINUTE:
                        return 1 / 1440;
                };
                break;
            case this.HOUR:
                switch (unit) {
                    case this.DAY:
                        return 24;
                    case this.MINUTE:
                        return 1 / 60;
                };
                break;
            case this.MINUTE:
                switch (unit) {
                    case this.HOUR:
                        return 60;
                    case this.SECOND:
                        return 1 / 60;
                    case this.MILLI:
                        return 1 / 60000;
                };
                break;
            case this.SECOND:
                switch (unit) {
                    case this.MILLI:
                        return 1 / 1000;
                };
                break;
            case this.MILLI:
                switch (unit) {
                    case this.SECOND:
                        return 1000;
                };
                break;
        }
        return -1;
    },
    // Returns true if a unit can be expressed as a whole number of subunits
    isUnitDivisibleIntoSubunit: function(unit, subunit) {
        var indivisible = unit === this.MONTH && subunit === this.WEEK;
        return !indivisible;
    },
    /**
     * Returns the number of milliseconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMilliseconds: function(start, end) {
        return (end - start);
    },
    /**
     * Returns the number of seconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of seconds between the two dates
     * @static
     */
    getDurationInSeconds: function(start, end) {
        return (end - start) / 1000;
    },
    /**
     * Returns the number of minutes between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMinutes: function(start, end) {
        return (end - start) / 60000;
    },
    /**
     * Returns the number of hours between the two dates.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of hours between the two dates
     * @static
     */
    getDurationInHours: function(start, end) {
        return (end - start) / 3600000;
    },
    /**
     * This method returns the number of days between the two dates. It assumes a day is 24 hours and tries to take the DST into account.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of days between the two dates
     *
     * @static
     */
    getDurationInDays: function(start, end) {
        var dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        return (end - start + dstDiff * 60 * 1000) / 86400000;
    },
    /**
     * Returns the number of whole months between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInMonths: function(start, end) {
        return ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
    },
    /**
     * Returns the number of years between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInYears: function(start, end) {
        return this.getDurationInMonths(start, end) / 12;
    },
    /**
     * Returns the lesser of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the lesser of the two dates
     * @static
     */
    min: function(d1, d2) {
        return (d1 && d1.valueOf() || d1) < (d2 && d2.valueOf() || d2) ? d1 : d2;
    },
    // valueOf() is better for Chrome optimization
    /**
     * Returns the greater of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the greater of the two dates
     * @static
     */
    max: function(d1, d2) {
        return (d1 && d1.valueOf() || d1) > (d2 && d2.valueOf() || d2) ? d1 : d2;
    },
    // valueOf() is better for Chrome optimization
    /**
     * Returns true if dates intersect
     * @param {Date} start1
     * @param {Date} end1
     * @param {Date} start2
     * @param {Date} end2
     * @return {Boolean} Returns true if dates intersect
     * @static
     */
    intersectSpans: function(date1Start, date1End, date2Start, date2End) {
        return this.betweenLesser(date1Start, date2Start, date2End) || this.betweenLesser(date2Start, date1Start, date1End);
    },
    /**
     * Returns a name of the duration unit, matching its property on the Sch.util.Date class.
     * So, for example:
     *
     *      Sch.util.Date.getNameOfUnit(Sch.util.Date.DAY) == 'DAY' // true
     *
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getNameOfUnit: function(unit) {
        unit = this.getUnitByName(unit);
        switch (unit.toLowerCase()) {
            case this.YEAR:
                return 'YEAR';
            case this.QUARTER:
                return 'QUARTER';
            case this.MONTH:
                return 'MONTH';
            case this.WEEK:
                return 'WEEK';
            case this.DAY:
                return 'DAY';
            case this.HOUR:
                return 'HOUR';
            case this.MINUTE:
                return 'MINUTE';
            case this.SECOND:
                return 'SECOND';
            case this.MILLI:
                return 'MILLI';
        }
        throw "Incorrect UnitName";
    },
    /**
     * Returns a human-readable name of the duration unit. For for example for `Sch.util.Date.DAY` it will return either
     * "day" or "days", depending from the `plural` argument
     * @static
     * @param {String} unit Duration unit
     * @param {Boolean} plural Whether to return a plural name or singular
     * @return {String}
     */
    getReadableNameOfUnit: function(unit, plural) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        return this._unitNames[unit][plural ? 'plural' : 'single'];
    },
    /**
     * Returns an abbreviated form of the name of the duration unit.
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getShortNameOfUnit: function(unit) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        return this._unitNames[unit].abbrev;
    },
    getUnitByName: function(name) {
        if (!this.isLocaleApplied())  {
            this.applyLocale();
        }
        
        if (!this.unitsByName[name]) {
            Ext.Error.raise('Unknown unit name: ' + name);
        }
        return this.unitsByName[name];
    },
    /**
     * Returns the beginning of the Nth next duration unit, after the provided `date`.
     * For example for the this call:
     *      Sch.util.Date.getNext(new Date('Jul 15, 2011'), Sch.util.Date.MONTH, 1)
     *
     * will return: Aug 1, 2011
     *
     * @static
     * @param {Date} date The date
     * @param {String} unit The duration unit
     * @param {Number} increment How many duration units to skip
     * @param {Number} [weekStartDay] The day index of the 1st day of the week.
     *                Only required when `unit` is `WEEK`. 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on (defaults to 1).
     * @param {Number} [timeZone] Time zone offset in minutes
     * @return {Date} The beginning of the next duration unit interval
     */
    getNext: function(date, unit, increment, weekStartDay, timeZone) {
        var dt = Ext.Date.clone(date);
        var hasTimeZone = timeZone != null;
        var isUTC = timeZone === 0;
        // convert to/from TZ only days and above, or hours for TZ with uneven hours offset
        var correctForTZ = this.compareUnits(this.DAY, unit) <= 0 || (unit === this.HOUR && timeZone % 60 !== 0);
        // UTC timezone has own DST correction
        if (hasTimeZone && !isUTC && correctForTZ) {
            dt = Sch.util.Date.toTimeZone(dt, timeZone);
        }
        weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
        // support 0 increment
        increment = increment == null ? 1 : increment;
        switch (unit) {
            case this.MILLI:
                dt = this.add(dt, unit, increment);
                break;
            case this.SECOND:
                dt = this.add(dt, unit, increment);
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                };
                break;
            case this.MINUTE:
                dt = this.add(dt, unit, increment);
                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                };
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                };
                break;
            case this.HOUR:
                if (isUTC) {
                    dt = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate(), dt.getUTCHours() + increment));
                } else {
                    dt = this.add(dt, unit, increment);
                    // Without these checks Firefox messes up the date and it changes timezone in certain edge cases
                    // See test 021_sch_util_date_dst.t.js
                    if (dt.getMinutes() > 0) {
                        dt.setMinutes(0);
                    }
                    if (dt.getSeconds() > 0) {
                        dt.setSeconds(0);
                    }
                    if (dt.getMilliseconds() > 0) {
                        dt.setMilliseconds(0);
                    }
                };
                break;
            case this.DAY:
                if (isUTC) {
                    // In case of UTC we just want to get start of the next day, or beginning of current day
                    dt = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate() + increment));
                } else {
                    // Check if date has 23 hrs and is in Chile timezone
                    var midnightNotInTimeScale = dt.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;
                    if (midnightNotInTimeScale) {
                        // Correct the date manually for DST transitions happening at 00:00
                        dt = this.add(dt, this.DAY, 2);
                        this.clearTime(dt);
                        return dt;
                    }
                    this.clearTime(dt);
                    dt = this.add(dt, this.DAY, increment);
                    // Brazil timezone issue #1642, tested in 028_timeaxis_dst.t.js
                    if (dt.getHours() === 1) {
                        this.clearTime(dt);
                    }
                };
                break;
            case this.WEEK:
                var day;
                if (isUTC) {
                    day = dt.getUTCDay();
                    var daysToAdd = weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1));
                    dt.setUTCDate(dt.getUTCDate() + daysToAdd);
                    dt = this.clearUTCTime(dt);
                } else {
                    this.clearTime(dt);
                    day = dt.getDay();
                    dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));
                    // For south american timezones, midnight does not exist on DST transitions, adjust...
                    if (dt.getDay() !== weekStartDay) {
                        dt = this.add(dt, this.HOUR, 1);
                    } else {
                        this.clearTime(dt);
                    }
                };
                break;
            case this.MONTH:
                if (isUTC) {
                    dt = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth() + increment, 1));
                } else {
                    dt = this.add(dt, this.MONTH, increment);
                    dt.setDate(1);
                    this.clearTime(dt);
                };
                break;
            case this.QUARTER:
                if (isUTC) {
                    var toAdd = (increment - 1) * 3 + (3 - dt.getUTCMonth() % 3);
                    dt = new Date(Date.UTC(dt.getUTCFullYear(), dt.getUTCMonth() + toAdd, 1));
                } else {
                    dt = this.add(dt, this.MONTH, ((increment - 1) * 3) + (3 - (dt.getMonth() % 3)));
                    this.clearTime(dt);
                    dt.setDate(1);
                };
                break;
            case this.YEAR:
                if (isUTC) {
                    dt = new Date(Date.UTC(dt.getUTCFullYear() + increment, 0, 1));
                } else {
                    dt = new Date(dt.getFullYear() + increment, 0, 1);
                };
                break;
            default:
                throw new Error('Invalid date unit' + unit);
        }
        if (hasTimeZone && !isUTC && correctForTZ) {
            // do not correct for weeks and above
            if (Sch.util.Date.compareUnits(Sch.util.Date.WEEK, unit) > 0) {
                // if DST occurred between input and output, we need to add correction
                var offset = dt.getTimezoneOffset() - date.getTimezoneOffset();
                if (offset !== 0) {
                    dt = Sch.util.Date.add(dt, this.MINUTE, offset);
                }
            }
            dt = Sch.util.Date.fromTimeZone(dt, timeZone);
            // getNext shouldn't return same date, if it wants to - just call getNext without TZ info
            if (dt - date === 0) {
                dt = this.getNext(date, unit, increment, weekStartDay);
            }
        }
        return dt;
    },
    getNumberOfMsFromTheStartOfDay: function(date) {
        return date - this.clearTime(date, true) || 86400000;
    },
    getNumberOfMsTillTheEndOfDay: function(date) {
        return this.getStartOfNextDay(date, true) - date;
    },
    getStartOfNextDay: function(date, clone, noNeedToClearTime) {
        var nextDay = this.add(noNeedToClearTime ? date : this.clearTime(date, clone), this.DAY, 1);
        // DST case
        if (nextDay.getDate() == date.getDate()) {
            var offsetNextDay = this.add(this.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
            var offsetDate = date.getTimezoneOffset();
            nextDay = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
        }
        return nextDay;
    },
    getEndOfPreviousDay: function(date, noNeedToClearTime) {
        var dateOnly = noNeedToClearTime ? date : this.clearTime(date, true);
        // dates are different
        if (dateOnly - date) {
            return dateOnly;
        } else {
            return this.add(dateOnly, this.DAY, -1);
        }
    },
    /**
     * Returns true if the first time span completely 'covers' the second time span. E.g.
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
     * @static
     * @param {Date} spanStart The start date for initial time span
     * @param {Date} spanEnd The end date for initial time span
     * @param {Date} otherSpanStart The start date for the 2nd time span
     * @param {Date} otherSpanEnd The end date for the 2nd time span
     * @return {Boolean}
     */
    timeSpanContains: function(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
    },
    /**
     * Compares two days with given precision, for example if `date1` is Aug 1st, 2014 08:00 AM and `date2`
     * is Aug 1st, 2014 09:00 and `precisionUnit` is {@link Sch.util.Date.DAY} then both dates a considered equal
     * since they point to the same day.
     *
     * @param {Date} date1
     * @param {Date} date2
     * @param {String} [precisionUnit=Sch.util.Date.MILLI]
     * @return {Integer}
     * - -1 if `date1` is lesser than `date2`
     * - +1 if `date1` is greater than `date2`
     * -  0 if `date1` is equal to `date2`
     */
    compareWithPrecision: function(date1, date2, precisionUnit) {
        var D = Sch.util.Date,
            ED = Ext.Date,
            result;
        switch (precisionUnit) {
            case D.DAY:
                date1 = Number(ED.format(date1, 'Ymd'));
                date2 = Number(ED.format(date2, 'Ymd'));
                break;
            case D.WEEK:
                date1 = Number(ED.format(date1, 'YmW'));
                date2 = Number(ED.format(date2, 'YmW'));
                break;
            case D.MONTH:
                date1 = Number(ED.format(date1, 'Ym'));
                date2 = Number(ED.format(date2, 'Ym'));
                break;
            case D.QUARTER:
                date1 = date1.getFullYear() * 4 + Math.floor(date1.getMonth() / 3);
                date2 = date2.getFullYear() * 4 + Math.floor(date2.getMonth() / 3);
                break;
            case D.YEAR:
                date1 = date1.getFullYear();
                date2 = date2.getFullYear();
                break;
            default:
            case D.MILLI:
            case D.SECOND:
            case D.MINUTE:
            case D.HOUR:
                precisionUnit = precisionUnit && this.getUnitDurationInMs(precisionUnit) || 1;
                date1 = Math.floor(date1.valueOf() / precisionUnit);
                date2 = Math.floor(date2.valueOf() / precisionUnit);
                break;
        }
        ((date1 < date2) && (result = -1)) || ((date1 > date2) && (result = +1)) || (result = 0);
        return result;
    },
    getValueInUnits: function(date, unit) {
        switch (unit) {
            case this.YEAR:
                return date.getFullYear();
            case this.QUARTER:
                return Math.floor(date.getMonth() / 3) + 1;
            case this.MONTH:
                return date.getMonth();
            case this.WEEK:
                return Ext.Date.getWeekOfYear(date);
            case this.DAY:
                return date.getDate();
            case this.HOUR:
                return date.getHours();
            case this.MINUTE:
                return date.getMinutes();
            case this.SECOND:
                return date.getSeconds();
        }
    },
    setValueInUnits: function(date, unit, value) {
        var result = Ext.Date.clone(date),
            f;
        switch (unit) {
            case this.YEAR:
                f = 'setFullYear';
                break;
            case this.MONTH:
                f = 'setMonth';
                break;
            case this.DAY:
                f = 'setDate';
                break;
            case this.HOUR:
                f = 'setHours';
                break;
            case this.MINUTE:
                f = 'setMinutes';
                break;
            case this.SECOND:
                f = 'setSeconds';
                break;
            case this.MILLI:
                f = 'setMilliseconds';
                break;
        }
        result[f](value);
        return result;
    },
    getSubUnit: function(unit) {
        switch (unit) {
            case this.YEAR:
                return this.MONTH;
            /* falls through */
            case this.MONTH:
                return this.DAY;
            /* falls through */
            case this.DAY:
                return this.HOUR;
            /* falls through */
            case this.HOUR:
                return this.MINUTE;
            /* falls through */
            case this.MINUTE:
                return this.SECOND;
            /* falls through */
            case this.SECOND:
                return this.MILLI;
        }
    },
    /* falls through */
    setValueInSubUnits: function(date, unit, value) {
        unit = this.getSubUnit(unit);
        return this.setValueInUnits(date, unit, value);
    },
    /*
     * section for calendar view related functions
     */
    // Copies date parts from source to target
    mergeDates: function(target, source, unit) {
        var copy = Ext.Date.clone(target);
        switch (unit) {
            case this.YEAR:
                copy.setFullYear(source.getFullYear());
            /* falls through */
            case this.MONTH:
                copy.setMonth(source.getMonth());
            /* falls through */
            case this.WEEK:
            /* falls through */
            case this.DAY:
                // we want to return week start day for this case
                if (unit === this.WEEK) {
                    copy = this.add(copy, this.DAY, source.getDay() - copy.getDay());
                } else {
                    copy.setDate(source.getDate());
                };
            /* falls through */
            case this.HOUR:
                copy.setHours(source.getHours());
            /* falls through */
            case this.MINUTE:
                copy.setMinutes(source.getMinutes());
            /* falls through */
            case this.SECOND:
                copy.setSeconds(source.getSeconds());
            /* falls through */
            case this.MILLI:
                copy.setMilliseconds(source.getMilliseconds());
        }
        return copy;
    },
    // splitting specified unit to subunits including start of the next span
    // e.g. week will be split to days, days to hours, etc.
    splitToSubUnits: function(start, unit, increment, weekStartDay) {
        increment = increment || 1;
        weekStartDay = arguments.length < 4 ? 1 : weekStartDay;
        switch (unit) {
            //            case this.YEAR      : return this.splitYear(start, increment, weekStartDay);
            case this.MONTH:
                return this.splitMonth(start, increment, weekStartDay);
            case this.WEEK:
            //return this.splitWeek(start, increment, weekStartDay);
            /* falls through */
            case this.DAY:
                return this.splitDay(start, increment);
            //            case this.HOUR      : return this.splitHour(start, increment);
            //            case this.MINUTE    : return this.splitMinute(start, increment);
            default:
                break;
        }
    },
    splitYear: function(start, increment) {
        var newStart = this.clearTime(start, true);
        newStart.setMonth(0);
        newStart.setDate(1);
        var result = [];
        for (var i = 0; i <= 12; i = i + increment) {
            result.push(this.add(newStart, this.MONTH, i));
        }
        return result;
    },
    splitMonth: function(start, increment, weekStartDay) {
        var newStart = this.clearTime(start, true);
        newStart.setDate(1);
        newStart = this.add(newStart, this.DAY, weekStartDay - newStart.getDay());
        var currentDate = Ext.Date.clone(newStart);
        var monthEnd = this.add(newStart, this.MONTH, 1);
        var result = [];
        for (var i = 0; currentDate.getTime() < monthEnd.getTime(); i = i + increment) {
            currentDate = this.add(newStart, this.WEEK, i);
            result.push(currentDate);
        }
        return result;
    },
    splitWeek: function(start, increment, weekStartDay) {
        var newStart = this.add(start, this.DAY, weekStartDay - start.getDay());
        newStart = this.clearTime(newStart);
        var result = [];
        for (var i = 0; i <= 7; i = i + increment) {
            result.push(this.add(newStart, this.DAY, i));
        }
        return result;
    },
    splitDay: function(start, increment) {
        var copy = this.clearTime(start, true);
        var result = [];
        for (var i = 0; i <= 24; i = i + increment) {
            result.push(this.add(copy, this.HOUR, i));
        }
        return result;
    },
    splitHour: function(start, increment) {
        var copy = new Date(start.getTime());
        copy.setMinutes(0);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        var result = [];
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.MINUTE, i));
        }
        return result;
    },
    splitMinute: function(start, increment) {
        var copy = Ext.Date.clone(start);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        var result = [];
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.SECOND, i));
        }
        return result;
    },
    // Need this to prevent some browsers (Safari in Sydney timezone) to not mess up a date
    // See tests marked *dst* and https://www.assembla.com/spaces/bryntum/tickets/1757#/activity/ticket:
    clearTime: function(dt, clone) {
        if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0) {
            return Ext.Date.clearTime(dt, clone);
        }
        return clone ? Ext.Date.clone(dt) : dt;
    },
    clearUTCTime: function(dt) {
        dt = new Date(dt);
        dt.setUTCHours(0, 0, 0, 0);
        return dt;
    },
    getWeekNumber: function(date) {
        var target = new Date(date.valueOf());
        // ISO week date weeks start on monday
        // so correct the day number
        var dayNr = (date.getDay() + 6) % 7;
        // ISO 8601 states that week 1 is the week
        // with the first thursday of that year.
        // Set the target date to the thursday in the target week
        target.setDate(target.getDate() - dayNr + 3);
        // Store the millisecond value of the target date
        var firstThursday = target.valueOf();
        // Set the target to the first thursday of the year
        // First set the target to january first
        target.setMonth(0, 1);
        // Not a thursday? Correct the date to the next thursday
        if (target.getDay() != 4) {
            target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
        }
        // The weeknumber is the number of weeks between the
        // first thursday of the year and the thursday in the target week
        return 1 + Math.ceil((firstThursday - target) / 604800000);
    },
    // 604800000 = 7 * 24 * 3600 * 1000
    // Returns first day of week (Monday by default)
    getWeekStartDate: function(date, weekStartDay) {
        var midday = this.setDateToMidday(date, true);
        weekStartDay = typeof weekStartDay !== 'number' ? 1 : weekStartDay;
        while (midday.getDay() !== weekStartDay) {
            midday = Sch.util.Date.add(midday, Sch.util.Date.DAY, -1);
        }
        return midday;
    },
    // Returns last day of week (Sunday by default)
    getWeekEndDate: function(date, weekEndDay) {
        var midday = this.setDateToMidday(date, true);
        weekEndDay = typeof weekEndDay !== 'number' ? 0 : weekEndDay;
        while (midday.getDay() !== weekEndDay) {
            midday = Sch.util.Date.add(midday, Sch.util.Date.DAY, 1);
        }
        return midday;
    },
    setDateToHours: function(date, clone, hours) {
        if (clone) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours);
        }
        date.setHours(hours);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date;
    },
    setDateToMidnight: function(date, clone) {
        return this.setDateToHours(date, clone, 0);
    },
    setDateToMidday: function(date, clone) {
        return this.setDateToHours(date, clone, 12);
    },
    isLaterDate: function(date, compareDate) {
        return !this.isSameDate(date, compareDate) && date > compareDate;
    },
    isSameDate: function(date, compareDate) {
        return date.getFullYear() === compareDate.getFullYear() && date.getMonth() === compareDate.getMonth() && date.getDate() === compareDate.getDate();
    },
    isEarlierDate: function(date, compareDate) {
        return !this.isSameDate(date, compareDate) && date < compareDate;
    },
    /**
     * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this timezone?"
     *
     * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
     * specified time zone, without altering the time zone. Thus it wont hold the same time as the original date.
     *
     * ```javascript
     * const localDate = new Date(2020, 7, 31, 7); // UTC+2
     * const utcDate   = Sch.util.Date.toTimeZone(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
     * ```
     * @static
     * @param {Date} date
     * @param {Number} timeZone
     * @returns {Date}
     */
    toTimeZone: function(date, timeZone) {
        var offset = date.getTimezoneOffset() + timeZone;
        var result = this.add(date, this.MINUTE, offset);
        // If date is the different time zone, add tz offset difference to it
        return this.add(result, this.MINUTE, result.getTimezoneOffset() - date.getTimezoneOffset());
    },
    /**
     * Adjusts the time of the specified date to match same local time in the specified time zone. i.e. "what time in my
     * timezone would match time in this timezone?"
     *
     * ```javascript
     * const localDate = new Date(2020, 7, 31, 7); // UTC+2
     * const utcDate   = Sch.util.Date.fromTimeZone(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
     * ```
     * @static
     * @param {Date} date
     * @param {Number} timeZone
     * @returns {Date}
     */
    fromTimeZone: function(date, timeZone) {
        var offset = -date.getTimezoneOffset() - timeZone;
        return this.add(date, this.MINUTE, offset);
    },
    // returns date with time part matching UTC time
    getUTCTime: function(date) {
        // Pick any date in the mid of summer to not suffer from DST switch
        return new Date(2020, 6, 1, date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
    },
    // returns date without time, date is matching date in UTC
    getUTCDate: function(date) {
        return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    },
    // Useful handle to format date in UTC without DST and in regular timezones. Real date in -> time zone formatted date out
    format: function(date, format, timeZone) {
        if (timeZone === 0) {
            // For UTC timezone to get rid of DST switch dates we need to remove hour information from the format string
            // and use specially crafted date to render hour info in UTC.
            // aAgGhH should be our only point of interest
            // hours
            format = format.replace('a', '%10');
            format = format.replace('A', '%11');
            format = format.replace('g', '%12');
            format = format.replace('G', '%13');
            format = format.replace('h', '%14');
            format = format.replace('H', '%15');
            // tz
            format = format.replace('O', '%16');
            format = format.replace('P', '%17');
            format = format.replace('Z', '%18');
            // iso
            format = format.replace('c', '%19');
            // days
            format = format.replace('d', '%20');
            format = format.replace('D', '%21');
            format = format.replace('j', '%22');
            format = format.replace('l', '%23');
            format = format.replace('N', '%24');
            format = format.replace('w', '%25');
            format = format.replace('z', '%26');
            // month
            format = format.replace('F', '%27');
            format = format.replace('m', '%28');
            format = format.replace('M', '%29');
            format = format.replace('n', '%30');
            // year
            format = format.replace('Y', '%31');
            format = format.replace('y', '%32');
            var result = Ext.Date.format(date, format);
            var noDSTDate = this.getUTCTime(date);
            var noDSTHours = this.getUTCDate(date);
            result = result.replace('%10', Ext.Date.format(noDSTDate, 'a'));
            result = result.replace('%11', Ext.Date.format(noDSTDate, 'A'));
            result = result.replace('%12', Ext.Date.format(noDSTDate, 'g'));
            result = result.replace('%13', Ext.Date.format(noDSTDate, 'G'));
            result = result.replace('%14', Ext.Date.format(noDSTDate, 'h'));
            result = result.replace('%15', Ext.Date.format(noDSTDate, 'H'));
            result = result.replace('%16', '+0000');
            result = result.replace('%17', '+00:00');
            result = result.replace('%18', '0');
            result = result.replace('%19', Ext.Date.format(noDSTHours, 'Y-m-d') + 'T' + Ext.Date.format(noDSTDate, 'H:i:s+00:00'));
            result = result.replace('%20', Ext.Date.format(noDSTHours, 'd'));
            result = result.replace('%21', Ext.Date.format(noDSTHours, 'D'));
            result = result.replace('%22', Ext.Date.format(noDSTHours, 'j'));
            result = result.replace('%23', Ext.Date.format(noDSTHours, 'l'));
            result = result.replace('%24', Ext.Date.format(noDSTHours, 'N'));
            result = result.replace('%25', Ext.Date.format(noDSTHours, 'w'));
            result = result.replace('%26', Ext.Date.format(noDSTHours, 'z'));
            result = result.replace('%27', Ext.Date.format(noDSTHours, 'F'));
            result = result.replace('%28', Ext.Date.format(noDSTHours, 'm'));
            result = result.replace('%29', Ext.Date.format(noDSTHours, 'M'));
            result = result.replace('%30', Ext.Date.format(noDSTHours, 'n'));
            result = result.replace('%31', Ext.Date.format(noDSTHours, 'Y'));
            result = result.replace('%32', Ext.Date.format(noDSTHours, 'y'));
            return result;
        } else {
            date = this.toTimeZone(date, timeZone);
            return Ext.Date.format(date, format);
        }
    }
});

/**
@class Sch.model.Customizable
@extends Ext.data.Model

This class represent a model with customizable field names. Customizable fields are defined in separate
class config `customizableFields`. The format of definition is just the same as for usual fields:

        Ext.define('BaseModel', {
            extend             : 'Sch.model.Customizable',

            customizableFields : [
                { name : 'StartDate', type : 'date', dateFormat : 'c' },
                { name : 'EndDate',   type : 'date', dateFormat : 'c' }
            ],

            fields             : [
                'UsualField'
            ],

            getEndDate : function () {
                return "foo"
            }
        });

For each customizable field will be created getter and setter, using the camel-cased name of the field ("stable name"),
prepended with "get/set" respectively. They will not overwrite any existing methods:

        var baseModel   = new BaseModel({
            StartDate   : new Date(2012, 1, 1),
            EndDate     : new Date(2012, 2, 3)
        });

        // using getter for "StartDate" field
        // returns date for "2012/02/01"
        var startDate   = baseModel.getStartDate();

        // using custom getter for "EndDate" field
        // returns "foo"
        var endDate     = baseModel.getEndDate();

You can change the name of customizable fields in a subclass of the model or completely redefine them.
To do this, add a special property to the class with the name of the field with a lowercased first
letter, appended with "Field". The value of the property should contain the new name of the field.

        Ext.define('SubModel', {
            extend         : 'BaseModel',

            startDateField : 'beginDate',
            endDateField   : 'finalizeDate',

            fields         : [
                { name : 'beginDate', type : 'date', dateFormat : 'Y-m-d' },
            ]
        });

        var subModel     = new SubModel({
            beginDate    : new Date(2012, 1, 1),
            finalizeDate : new Date(2012, 2, 3)
        });

        // name of getter is still the same
        var startDate = subModel.getStartDate();

In the example above the `StartDate` field was completely re-defined to the `beginDate` field with different date format.
The `EndDate` has just changed its name to "finalizeDate". Note, that getters and setters are always named after "stable"
field name, not the customized one.
*/
Ext.define('Sch.model.Customizable', function(thisClass) {
    return {
        extend: 'Ext.data.Model',
        requires: [
            'Sch.util.Date'
        ],
        mixins: {
            robo: 'Robo.data.Model'
        },
        isCustomizableModel: true,
        /**
        * @cfg {Array} customizableFields
        *
        * The array of customizable fields definitions.
        */
        customizableFields: null,
        // @private
        // Keeps temporary state of the previous state for a model, but is only available
        // when a model has changed, e.g. after 'set' or 'reject'. After those operations are completed, this property is cleared.
        previous: null,
        // temp flag to check if we're currently editing the model
        __editing: null,
        // To support nested beginEdit calls (see 043_nested_beginedit.t.js in Gantt)
        __editCounter: 0,
        constructor: function() {
            // Sencha Touch requires the return value to be returned, hard crash without it
            var retVal = this.callParent(arguments);
            return retVal;
        },
        storePreviousFlex: Ext.Function.flexSetter(function(fieldName, value) {
            var me = this,
                currentValue = me.get(fieldName);
            // convert new value to Date if needed
            if (currentValue instanceof Date && !(value instanceof Date)) {
                value = me.getField(fieldName).convert(value, me);
            }
            // Store previous field value if it changed, if value didn't change - just return
            if ((currentValue instanceof Date && (currentValue - value)) || !(currentValue instanceof Date) && currentValue !== value) {
                // if record has a hook to process old value
                if (me.processFieldPreviousValue) {
                    currentValue = me.processFieldPreviousValue(fieldName, currentValue);
                }
                me.previous[fieldName] = currentValue;
            }
        }),
        deletePreviousFlex: Ext.Function.flexSetter(function(fieldName, value) {
            delete this.previous[fieldName];
        }),
        // Overridden to be able to track previous record field values
        set: function(fieldName, value) {
            var me = this,
                ownPrevious = false,
                result = null;
            if (!me.previous) {
                ownPrevious = true;
                me.previous = {};
            }
            me.storePreviousFlex(fieldName, value);
            // This call is mandatory, otherwise model's dirty flag / modified fields might not be properly reset
            result = me.callParent(arguments);
            if (!me.__editing) {
                if (ownPrevious) {
                    delete me.previous;
                } else {
                    me.deletePreviousFlex(fieldName, value);
                }
            }
            return result;
        },
        // Overridden to be able to track previous record field values
        reject: function() {
            var me = this,
                modified = me.modified || {},
                field;
            // Ext could call 'set' during the callParent which should not reset the 'previous' object
            me.__editing = true;
            me.previous = me.previous || {};
            for (field in modified) {
                if (modified.hasOwnProperty(field)) {
                    if (typeof modified[field] != "function") {
                        me.previous[field] = me.get(field);
                    }
                }
            }
            me.callParent(arguments);
            // Reset the previous tracking object
            delete me.previous;
            me.__editing = false;
        },
        // -------------- Supporting nested beginEdit calls - see test 043_nested_beginedit.t.js
        beginEdit: function() {
            this.__editCounter++;
            this.__editing = true;
            this.callParent(arguments);
        },
        cancelEdit: function() {
            this.__editCounter = 0;
            this.__editing = false;
            this.callParent(arguments);
            delete this.previous;
        },
        // Overridden to be able to clear the previous record field values. Must be done here to have access to the 'previous' object after
        // an endEdit call.
        endEdit: function(silent, modifiedFieldNames) {
            if (--this.__editCounter === 0) {
                // OVERRIDE HACK: If no fields were changed, make sure no events are fired by signaling 'silent'
                if (!silent && this.getModifiedFieldNames) /* Touch doesn't have this method, skip optimization */
                {
                    var editMemento = this.editMemento;
                    if (!modifiedFieldNames) {
                        modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
                    }
                    if (modifiedFieldNames && modifiedFieldNames.length === 0) {
                        silent = true;
                    }
                }
                this.callParent([
                    silent
                ].concat(Array.prototype.slice.call(arguments, 1)));
                this.__editing = false;
                delete this.previous;
            }
        }
    };
}, // -------------- EOF Supporting nested beginEdit calls - see test 043_nested_beginedit.t.js
function(thisClass) {
    // thisClass.onExtended() used few lines below puts a provided function to the end of thisClass.$onExtended array.
    // That's why we cannot use it. We need this function to start early to be able to backup originally defined "fields" config.
    // Ext.data.Model provided a function to onExtended that removes the config and it stays earlier in the thisClass.$onExtended queue.
    // So we simply put our function to the beginning of thisClass.$onExtended.
    thisClass.$onExtended.unshift({
        fn: function(cls, data) {
            if (data) {
                if (Ext.isArray(data)) {
                    cls.fieldsInitialValue = data.slice();
                } else if (data.fields) {
                    if (!Ext.isArray(data.fields)) {
                        cls.fieldsInitialValue = [
                            data.fields
                        ];
                    } else {
                        cls.fieldsInitialValue = data.fields.slice();
                    }
                }
            }
        }
    });
    thisClass.onExtended(function(cls, data, hooks) {
        var classManager = Ext.ClassManager,
            triggerCreatedOriginal = classManager.triggerCreated;
        // just before the ClassManager notifies that the class is ready we do our fields adjustments
        classManager.triggerCreated = function(className) {
            var proto = cls.prototype;
            // Combining our customizable fields with ones collected by the superclass.
            // This array has all the inherited customizable fields (yet some of them might be duplicated because of overrides)
            if (proto.customizableFields) {
                proto.allCustomizableFields = (cls.superclass.allCustomizableFields || []).concat(proto.customizableFields);
            } else {
                proto.allCustomizableFields = (cls.superclass.allCustomizableFields || []);
            }
            // we will collect fields here, overwriting old ones with new to remove duplication
            var customizableFieldsByName = {};
            Ext.Array.each(proto.allCustomizableFields, function(field) {
                // normalize to object
                if (typeof field == 'string')  {
                    field = {
                        name: field
                    };
                }
                
                customizableFieldsByName[field.name] = field;
            });
            // already processed by the Ext.data.Model `onBeforeCreated`
            var fields = proto.fields;
            var toAdd = [];
            var toRemove = [];
            Ext.Array.each(fields, function(field) {
                if (field.isCustomizableField) {
                    toRemove.push(field.getName());
                }
            });
            if (proto.idProperty !== 'id' && proto.getField('id')) {
                if (!proto.getField('id').hasOwnProperty('name')) {
                    toRemove.push('id');
                }
            }
            if (proto.idProperty !== 'Id' && proto.getField('Id')) {
                if (!proto.getField('Id').hasOwnProperty('name')) {
                    toRemove.push('Id');
                }
            }
            cls.removeFields(toRemove);
            // Finds the provided field config in the provided array of configs
            // and applies it to the provided resulting object (using Ext.applyIf)
            // @param result Resulting configuration object
            // @param fields Array of field configs
            // @param fieldName Field name
            function applyFieldConfig(result, fields, fieldName) {
                if (!fields)  {
                    return;
                }
                
                if (!Ext.isArray(fields))  {
                    fields = [
                        fields
                    ];
                }
                
                var fieldConfig;
                for (var i = fields.length - 1; i >= 0; i--) {
                    if (fields[i].name == fieldName) {
                        fieldConfig = fields[i];
                        break;
                    }
                }
                Ext.applyIf(result, fieldConfig);
            }
            // Collects the provided customizable field config based on the class inheritance
            // @param stableFieldName Stable field name (the one provided as "name" in the "customizableFields" section)
            // @return Field config
            function getFieldConfig(stableFieldName) {
                var c = cls,
                    proto = c.prototype,
                    fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field',
                    result = {
                        name: proto[fieldProperty] || stableFieldName,
                        isCustomizableField: true
                    },
                    fieldName;
                while (proto && proto.isCustomizableModel) {
                    fieldName = proto[fieldProperty] || stableFieldName;
                    // first apply "customizableFields" config data
                    // ..we use applyIf() and "customizableFields" has higher priority than "fields" config
                    proto.hasOwnProperty('customizableFields') && applyFieldConfig(result, proto.customizableFields, stableFieldName);
                    // apply "fields" config data
                    applyFieldConfig(result, c.fieldsInitialValue, fieldName);
                    // proceed to parent class
                    proto = c.superclass;
                    c = proto && proto.self;
                }
                return result;
            }
            // let's reset array there might be some more fields to remove
            toRemove = [];
            Ext.Object.each(customizableFieldsByName, function(name, customizableField) {
                var stableFieldName = customizableField.name || customizableField.getName();
                var fieldProperty = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
                var realFieldName = proto[fieldProperty] || stableFieldName;
                // if such field already exists we will remove it
                proto.getField(realFieldName) && toRemove.push(realFieldName);
                var field = getFieldConfig(stableFieldName);
                // we create a new copy of the `customizableField` using possibly new name
                toAdd.push(Ext.create('data.field.' + (field.type || 'auto'), field));
                var capitalizedStableName = Ext.String.capitalize(stableFieldName);
                // don't overwrite `getId` method
                if (capitalizedStableName != 'Id') {
                    var getter = 'get' + capitalizedStableName;
                    var setter = 'set' + capitalizedStableName;
                    // overwrite old getters, pointing to a different field name
                    if (!proto[getter] || proto[getter].__getterFor__ && proto[getter].__getterFor__ != realFieldName) {
                        proto[getter] = function() {
                            // Need to read this property from the prototype if it exists, instead of relying on the field
                            // Since if someone subclasses a model and redefines a fieldProperty - the realFieldName variable
                            // will still have the value of the superclass
                            // See test 024_event.t.js
                            return this.get(this[fieldProperty] || realFieldName);
                        };
                        proto[getter].__getterFor__ = realFieldName;
                    }
                    // same for setters
                    if (!proto[setter] || proto[setter].__setterFor__ && proto[setter].__setterFor__ != realFieldName) {
                        proto[setter] = function(value) {
                            // Need to read this property from the prototype if it exists, instead of relying on the field
                            // Since if someone subclasses a model and redefines a fieldProperty - the realFieldName variable
                            // will still have the value of the superclass
                            // See test 024_event.t.js
                            return this.set(this[fieldProperty] || realFieldName, value);
                        };
                        proto[setter].__setterFor__ = realFieldName;
                    }
                }
            });
            cls.replaceFields(toAdd, toRemove);
            // call && restore original Ext.ClassManager.triggerCreated function
            triggerCreatedOriginal.apply(this, arguments);
            classManager.triggerCreated = triggerCreatedOriginal;
        };
    });
});

/**
 * @class Sch.model.Assignment
 * @extends Sch.model.Customizable
 *
 * This class represent a single assignment of a resource to an event in scheduler.
 * It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * The class fields can be customized by subclassing this class.
 * Please refer to {@link Sch.model.Customizable} for details.
 */
Ext.define('Sch.model.Assignment', {
    extend: 'Sch.model.Customizable',
    idProperty: 'Id',
    isAssignmentModel: true,
    customizableFields: [
        /**
         * @field Id
         * The id of the assignment
         */
        /**
         * @field
         * The id of the resource assigned
         */
        {
            name: 'ResourceId'
        },
        /**
         * @field
         * The id of the event to which the resource is assigned
         */
        {
            name: 'EventId'
        }
    ],
    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an assignment belongs.
     * Defaults to "ResourceId".
     */
    resourceIdField: 'ResourceId',
    /**
     * @cfg {String} eventIdField The name of the field identifying an event to which an assignment belongs.
     * Defaults to "EventId".
     */
    eventIdField: 'EventId',
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * Returns an assigment store this assignment is part of. Assignment must be part of an assigment store
     * to be able to retrieve it.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        return this.joined && this.joined[0];
    },
    /**
     * Returns an event store this assignment uses as default event store. Assignment must be part
     * of an assignment store to be able to retrieve default event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore: function() {
        var assignmentStore = this.getAssignmentStore();
        return assignmentStore && assignmentStore.getEventStore();
    },
    /**
     * Returns a resource store this assignment uses as default resource store. Assignment must be part
     * of an assignment store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },
    /**
     * Returns an event associated with this assignment.
     * @method getEvent
     * @return {Sch.model.Range} Event instance
     */
    /**
     * @ignore
     */
    getEvent: function(eventStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get an event via provided
        // event store
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getModelById(me.getEventId());
    },
    /**
     * Returns the resource associated with this assignment.
     * @method getResource
     * @return {Sch.model.Resource} Instance of resource
     */
    /**
     * @ignore
     */
    getResource: function(resourceStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get a resource via provided
        // resource store
        resourceStore = resourceStore || me.getResourceStore();
        return resourceStore && resourceStore.getModelById(me.getResourceId());
    },
    /**
     * Convenience method to get a name of the associated event.
     * @method getEventName
     * @return {String} name
     */
    /**
     * @ignore
     */
    getEventName: function(eventStore) {
        var evnt = this.getEvent(eventStore);
        return evnt && evnt.getName() || '';
    },
    /**
     * Convenience method to get a name of the associated resource.
     * @method getResourceName
     * @return {String} name
     */
    /**
     * @ignore
     */
    getResourceName: function(resourceStore) {
        var resource = this.getResource(resourceStore);
        return resource && resource.getName() || '';
    },
    /**
     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var me = this,
            event = me.getEvent(),
            resource = me.getResource();
        return event && !event.phantom && resource && !resource.phantom;
    },
    fullCopy: function() {
        return this.copy.apply(this, arguments);
    },
    // private
    getEventResourceCompositeKey: function() {
        var me = this;
        return me.self.makeAssignmentEventResourceCompositeKey(me.getEventId(), me.getResourceId());
    },
    inheritableStatics: {
        makeAssignmentEventResourceCompositeKey: function() {
            var arr = [];
            return function(eventId, resourceId) {
                arr.length = 0;
                arr.push('event(', eventId, ')-resource(', resourceId, ')');
                return arr.join('');
            };
        }()
    }
});

/**
 * @class Sch.data.AssignmentStore
 * @extends Ext.data.Store
 *
 * A class representing a collection of assignments between events in the {@link Sch.data.EventStore} and resources
 * in the {@link Sch.data.ResourceStore}.
 *
 * Contains a collection of {@link Sch.model.Assignment} records.
 */
Ext.define('Sch.data.AssignmentStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Sch.patches.CollectionKey',
        'Sch.data.util.EventAssignmentsCache',
        'Sch.data.util.ResourceAssignmentsCache'
    ],
    uses: [
        'Sch.data.util.EventAssignmentsCache',
        'Sch.data.util.ResourceAssignmentsCache',
        'Sch.data.util.AssignmentStoreEventResourcesCache',
        'Sch.data.util.AssignmentStoreResourceEventsCache'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Robo.data.Store'
    ],
    config: {
        // WARNING: this is a private config in Ext.data.LocalStore
        extraKeys: {
            byEventIdResourceId: {
                keyFn: 'getEventResourceCompositeKey'
            }
        }
    },
    model: 'Sch.model.Assignment',
    alias: 'store.assignmentstore',
    storeId: 'assignments',
    eventResourceCache: null,
    resourceEventsCache: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    /**
     * @property {Sch.data.EventStore} eventStore The event store to which this assignment store is associated.
     * Usually it is configured automatically, by the event store itself.
     *
     * @readonly
     */
    eventStore: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.eventAssignmentsCache = me.eventAssignmentsCache || me.createEventAssignmentCache();
        me.resourceAssignmentsCache = me.resourceAssignmentsCache || me.createResourceAssignmentCache();
    },
    // The caches commented are conflicting with the fact that assignments might be added to assignment store
    // before corresponding events/records are. For example SchedulerDragZone::updateRecords() does that
    // as soon as it's fixed this might be uncommented thus we might gain more performace at
    // event::getResources()/resource::getEvents() and corresponding methods
    //me.eventResourceCache       = me.eventResourceCache       || me.createAssignmentStoreEventResourcesCache();
    //me.resourceEventsCache      = me.resourceEventsCache      || me.createAssignmentStoreResourceEventsCache();
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventResourceCache', 'resourceEventsCache', 'eventAssignmentsCache', 'resourceEventsCache', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.callParent();
    },
    createEventAssignmentCache: function() {
        return new Sch.data.util.EventAssignmentsCache(this);
    },
    createResourceAssignmentCache: function() {
        return new Sch.data.util.ResourceAssignmentsCache(this);
    },
    createAssignmentStoreEventResourcesCache: function() {
        return new Sch.data.util.AssignmentStoreEventResourcesCache(this);
    },
    createAssignmentStoreResourceEventsCache: function() {
        return new Sch.data.util.AssignmentStoreResourceEventsCache(this);
    },
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore = me.eventStore;
        me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
        me.attachToEventStore(me.eventStore);
        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.AssignmentStore} this
             * @param {Sch.data.EventStore} newEventStore
             * @param {Sch.data.EventStore} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    attachToEventStore: function(eventStore) {
        var me = this;
        Ext.destroy(me.eventStoreDetacher);
        if (eventStore && eventStore.isTreeStore) {
            me.eventStoreDetacher = eventStore.on({
                'noderemove': me.onEventNodeRemove,
                'resourcestorechange': me.onEventStoreResourceStoreChange,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher then in cache, we need those handlers to do their job before cache update
        else if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                'remove': me.onEventRemove,
                'resourcestorechange': me.onEventStoreResourceStoreChange,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher then in cache, we need those handlers to do their job before cache update
        me.attachToResourceStore(eventStore && eventStore.getResourceStore());
    },
    attachToResourceStore: function(resourceStore) {
        var me = this;
        Ext.destroy(me.resourceStoreDetacher);
        if (resourceStore) {
            if (resourceStore.isTreeStore) {
                me.resourceStoreDetacher = resourceStore.on({
                    'noderemove': me.onResourceNodeRemove,
                    scope: me,
                    destroyable: true,
                    priority: 200
                });
            } else // higher then in cache
            {
                me.resourceStoreDetacher = resourceStore.on({
                    'remove': me.onResourceRemove,
                    scope: me,
                    destroyable: true,
                    priority: 200
                });
            }
        }
    },
    // higher then in cache
    onEventStoreResourceStoreChange: function(eventStore, newResourceStore, oldResourceStore) {
        this.attachToResourceStore(newResourceStore);
    },
    onEventRemove: function(eventStore, events, index, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            Ext.Array.each(events, function(event) {
                assignments = assignments.concat(me.getAssignmentsForEvent(event));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onEventNodeRemove: function(eventStore, event, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            event.cascadeBy(function(cascadingEvent) {
                assignments = assignments.concat(me.getAssignmentsForEvent(cascadingEvent));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onResourceRemove: function(resourceStore, resources, index, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            Ext.Array.each(resources, function(resource) {
                assignments = assignments.concat(me.getAssignmentsForResource(resource));
            });
            assignments.length && me.remove(assignments);
        }
    },
    onResourceNodeRemove: function(resourceStore, resource, isMove) {
        var me = this,
            assignments;
        if (!isMove) {
            assignments = [];
            resource.cascadeBy(function(cascadingResource) {
                assignments = assignments.concat(me.getAssignmentsForResource(cascadingResource));
            });
            assignments.length && me.remove(assignments);
        }
    },
    /**
     * Maps over event assignments.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForEvent: function(event, fn, filterFn) {
        var me = this,
            result = [];
        fn = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;
        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.each(me.eventAssignmentsCache.get(event), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        } else {
            result = result.concat(me.eventAssignmentsCache.get(event));
        }
        return result;
    },
    /**
     * Maps over resource assignments.
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {Mixed[]}
     */
    mapAssignmentsForResource: function(resource, fn, filterFn) {
        var me = this,
            result = [];
        fn = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;
        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.each(me.resourceAssignmentsCache.get(resource), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        } else {
            result = [].concat(me.resourceAssignmentsCache.get(resource));
        }
        return result;
    },
    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Range/Mixed} event
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForEvent: function(event) {
        return this.mapAssignmentsForEvent(event);
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Range/Mixed} event
     */
    removeAssignmentsForEvent: function(event) {
        var me = this;
        me.remove(me.getAssignmentsForEvent(event));
    },
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource/Mixed} event
     * @return {Sch.model.Range[]}
     */
    getAssignmentsForResource: function(resource) {
        return this.mapAssignmentsForResource(resource);
    },
    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     */
    removeAssignmentsForResource: function(resource) {
        var me = this;
        me.remove(me.getAssignmentsForResource(resource));
    },
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Range/Mixed} event
     * @return {Sch.model.Resource[]}
     */
    getResourcesForEvent: function(event) {
        var me = this,
            result;
        if (me.eventResourceCache) {
            result = me.eventResourceCache.get(event);
        } else {
            result = me.mapAssignmentsForEvent(event, function mapper(assignment) {
                return assignment.getResource();
            }, function filter(resource) {
                return !!resource;
            });
        }
        return result;
    },
    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Range[]}
     */
    getEventsForResource: function(resource) {
        var me = this,
            eventStore = this.getEventStore(),
            result;
        // SEE COMMENT IN CONSTRUCTOR
        // if (me.resourceEventsCache) {
        //     result = me.resourceEventsCache.get(resource);
        // }
        // else {
        result = me.mapAssignmentsForResource(resource, function mapper(assignment) {
            return assignment.getEvent();
        }, function filter(event) {
            return !!event && (!eventStore.isFiltered() || eventStore.contains(event));
        });
        // }
        return result;
    },
    /**
     * Creates and adds assignment record for a given event and a resource.
     * @method assignEventToResource
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed/Array} resource The resource(s) to assign to the event
     * @return {Sch.model.Assignment[]} An array with the created assignment(s)
     */
    /**
     * @ignore
     */
    assignEventToResource: function(event, resource, assignmentSetupFn) {
        var me = this,
            assignments = [];
        assignmentSetupFn = assignmentSetupFn || Ext.identityFn;
        var resources = Ext.isArray(resource) ? resource : [
                resource
            ];
        Ext.Array.each(resources, function(resource) {
            if (!me.isEventAssignedToResource(event, resource)) {
                var assignment = new me.model();
                assignment = assignmentSetupFn(assignment);
                assignment.setEventId(event && event.isModel && event.getId() || event);
                assignment.setResourceId(resource && resource.isModel && resource.getId() || resource);
                assignments.push(assignment);
            }
        });
        me.add(assignments);
        return assignments;
    },
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed} [resource] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
     * @return {Sch.model.Assignment}
     */
    unassignEventFromResource: function(event, resource) {
        var me = this,
            assignment;
        if (!resource) {
            this.removeAssignmentsForEvent(event);
        } else if (me.isEventAssignedToResource(event, resource)) {
            assignment = me.getAssignmentForEventAndResource(event, resource);
            me.remove(assignment);
        }
        return assignment;
    },
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Range/Mixed} event
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Boolean}
     */
    isEventAssignedToResource: function(event, resource) {
        var me = this,
            records = me.getResourcesForEvent(event),
            result = false,
            i, len;
        if (resource && resource.isModel) {
            resource = resource.getId();
        }
        for (i = 0 , len = records.length; !result && i < len; i++) {
            result = records[i];
            result = result.getId() == resource;
        }
        return result;
    },
    /**
     * Returns an assignment record for a given event and resource
     *
     * @param {Sch.model.Range/Mixed} The event or its id
     * @param {Sch.model.Resource/Mixed} The resource or its id
     * @return {Sch.model.Assignment}
     */
    getAssignmentForEventAndResource: function(event, resource) {
        var me = this;
        if (event && event.isModel) {
            event = event.getId();
        }
        if (resource && resource.isModel) {
            resource = resource.getId();
        }
        return me.byEventIdResourceId.get(me.model.makeAssignmentEventResourceCompositeKey(event, resource));
    },
    // Override to make sure reflects accurately after a commit on the store, which first triggers commit ('update' event)
    // while the removedRecords array is still not cleaned up
    // #4904 - Resource assignment column shows incorrect dirty flag
    commitChanges: function() {
        this.suspendEvents(true);
        this.callParent(arguments);
        this.resumeEvents();
    }
});

/**
@class Sch.model.CalendarDay

A model representing a single day in the calendar. Depending from the `Type` field, day may be a concrete day per se (2012/01/01),
a certain weekday (all Thursdays), or an override for all certain weekdays in the timeframe
(all Fridays between 2012/01/01 - 2012/01/15, inclusive).

A collection of CalendarDay instances is supposed to be provided for the {@link Sch.data.Calendar calendar}.

The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

*/
Ext.define('Sch.model.CalendarDay', {
    requires: [
        'Ext.data.Types'
    ],
    extend: 'Sch.model.Customizable',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    idProperty: 'Id',
    isCalendarDayModel: true,
    customizableFields: [
        /**
         * @field Id
         * The id of the date. Can be an arbitrary unique value, assigned by the server. For backward compatibility, if this field has one of the special formats
         * then some data will be extracted from it. This behavior will be kept for several coming releases, but you should not rely on it anymore.
         */
        /**
         * @method getDate
         *
         * Returns the value of the {@link #Date} field
         *
         * @return {Date} The date of this calendar day
         */
        /**
         * @field
         * The date for this day in the ISO 8601 format. Any time information in this field will be cleared. If this instance
         * represents a weekday or week override, this field will be ignored.
         */
        {
            name: 'Date',
            type: 'date',
            dateFormat: 'c',
            persist: true,
            convert: function(value, record) {
                if (!value)  {
                    return;
                }
                
                var converted = Ext.data.Types.DATE.convert.call(this, value);
                if (converted) {
                    Ext.Date.clearTime(converted);
                }
                return converted;
            }
        },
        /**
         * @method getWeekday
         *
         * Returns the value of the {@link #Weekday} field
         *
         * @return {Number} The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        /**
         * @method setWeekday
         *
         * Sets value of the {@link #Weekday} field
         *
         * @param {Number} weekday The index of the week day (0 - Sunday, 1 - Monday, etc).
         */
        /**
         * @field
         * The index of the week day (0 - Sunday, 1 - Monday and so on) if this instance contains information about the week day (applicable for `WEEKDAY` and `WEEKDAYOVERRIDE`).
         * Should be set to -1 for the "main" instance of the week overrides.
         */
        {
            name: 'Weekday',
            type: 'int'
        },
        /**
         * @method getOverrideStartDate
         *
         * Returns the start date of the timespan for the week day override.
         *
         * @return {Date} The start date
         */
        /**
         * @method setOverrideStartDate
         *
         * Sets the start date of the timespan for the week day override
         *
         * @param {Date} startDate The new start date
         */
        /**
         * @field
         * The start date of the timespan for week day override.
         */
        {
            name: 'OverrideStartDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @method getOverrideEndDate
         *
         * Returns the end date of the timespan for the week day override.
         *
         * @return {Date} The end date
         */
        /**
         * @method setOverrideEndDate
         *
         * Sets the end date of the timespan for the week day override
         *
         * @param {Date} endDate The new end date
         */
        /**
         * @field
         * The end date of the timespan for week day override.
         */
        {
            name: 'OverrideEndDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @field
         * The type of this calendar day. Can be one of the following `DAY`, `WEEKDAY`, `WEEKDAYOVERRIDE`:
         *
         * - Default value is `DAY` meaning this day represents a "real" day in the calendar (2012/01/01 for example) and contains availability information for that particular day only.
         *  The date is stored in the {@link #Date} field.
         * - The `WEEKDAY` value means calendar day contains information about all weekdays with the index, given in the {@link #Weekday} field (0 - Sunday, 1 - Monday and so on).
         *  For example - all Fridays. {@link #Date} field is ignored.
         * - <p>The `WEEKDAYOVERRIDE` value means calendar day contains information about all weekdays within certain timespan. For example - all Fridays between 2012/01/01 - 2012/01/15.
         *  Week day index should be stored in the {@link #Weekday} field again, beginning of the timespan - in the {@link #OverrideStartDate} field and the end of timespan - in the {@link #OverrideEndDate}.
         *  </p>
         *  <p>
         *  A single day instance contains the override for a single week day. So, to define overrides for several days (Monday and Tuesday for example) - add an additional instance
         *  to the calendar with the same `Name/OverrideStartDate/OverrideEndDate` values. There's no need to define an override for every weekday - if some day is not defined - the
         *  default availability will be used.
         *  </p>
         *  <p>
         *  **Note** Every week override should also have a "main" calendar day instance, representing the override itself. It should have the same
         *  values for `Name/OverrideStartDate/OverrideEndDate` fields and -1 for {@link #Weekday}. Also, the timespans of all week overrides should not intersect.
         *  </p>
         *  <p>
         *  To avoid manual creation of week overrides you can use the calendar API (for example, {@link Sch.data.Calendar#addNonStandardWeek addNonStandardWeek},
         *  {@link Sch.data.Calendar#removeNonStandardWeek removeNonStandardWeek} methods).
         *  </p>
         */
        {
            name: 'Type',
            defaultValue: 'DAY'
        },
        // 'DAY', 'WEEKDAY', 'WEEKDAYOVERRIDE'
        /**
         * @field
         * Optional boolean flag, allowing you to specify exceptions - working days which fall on weekends.
         *
         * **Please note**, that simply setting this field to "true" is not enough - you also need to specify
         * the exact hours that are available for work with the {@link #Availability} field.
         */
        {
            name: 'IsWorkingDay',
            type: 'boolean',
            defaultValue: false
        },
        /**
         * @method getCls
         *
         * Gets the "class" of the day
         *
         * @return {String} cls The "class" of the day
         */
        /**
         * @method setCls
         *
         * Sets the CSS class of the day, used when visualised in the UI
         *
         * @param {String} cls The new class of the day
         */
        /**
         * @field
         * Optional name of the CSS class, which can be used by various plugins working with weekends and holidays.
         * If a holiday lasts for several days, then all days should have the same `Cls` value.
         */
        {
            name: 'Cls',
            defaultValue: 'sch-nonworkingtime'
        },
        /**
         * @method getName
         *
         * Gets the "name" of the day
         *
         * @return {String} name The "name" of the day
         */
        /**
         * @method setName
         *
         * Sets the "name" of the day
         *
         * @param {String} name The new name of the day
         */
        /**
         * @field
         * Optional name of the day (holiday name for example)
         */
        'Name',
        // [ '08:00-12:00', '13:00-17:00' ]
        /**
         * @field
         * Should be an array of strings, containing the hourly availability for this day. Strings should have the following format:
         *
         *      // two working intervals
         *      [ '08:00-12:00', '13:00-17:00' ]
         *
         *      // whole 24 hours are available
         *      [ '00:00-24:00' ]
         *
         * **Please note**, that this field overrides the {@link #IsWorkingDay} - for example, a day with "IsWorkingDay : false" and "Availability : [ '08:00-12:00' ]" - will be considered working.
         */
        {
            name: 'Availability',
            persist: true,
            convert: function(value, record) {
                if (value) {
                    return typeof value === 'string' ? [
                        value
                    ] : value;
                } else {
                    return [];
                }
            }
        }
    ],
    availabilityCache: null,
    /**
     * @cfg {String} weekdayField The name of the {@link #Weekday} field.
     */
    weekdayField: 'Weekday',
    /**
     * @cfg {String} overrideStartDateField The name of the {@link #OverrideStartDate} field.
     */
    overrideStartDateField: 'OverrideStartDate',
    /**
     * @cfg {String} overrideEndDateField The name of the {@link #OverrideEndDate} field.
     */
    overrideEndDateField: 'OverrideEndDate',
    /**
     * @cfg {String} typeField The name of the {@link #Type} field.
     */
    typeField: 'Type',
    /**
     * @cfg {String} dateField The name of the {@link #Date} field.
     */
    dateField: 'Date',
    /**
     * @cfg {String} isWorkingDayField The name of the {@link #IsWorkingDay} field.
     */
    isWorkingDayField: 'IsWorkingDay',
    /**
     * @cfg {String} clsField The name of the {@link #Cls} field.
     */
    clsField: 'Cls',
    /**
     * @cfg {String} nameField The name of the {@link #Name} field.
     */
    nameField: 'Name',
    /**
     * @cfg {String} availabilityField The name of the {@link #Availability} field.
     */
    availabilityField: 'Availability',
    /**
     * Sets the date for this day (will clear the time part)
     * @param {Date} date
     */
    setDate: function(date) {
        if (date)  {
            date = Ext.Date.clearTime(date, true);
        }
        
        this.set(this.dateField, date);
    },
    /**
     * Clears the date for this day
     * @param {Date} date
     */
    clearDate: function() {
        this.set(this.dateField, null);
    },
    /**
     * This method returns the availability for this day. By default it will decode an array of strings '08:00-12:00' to an
     * array of objects like:
     *
     *      {
     *          startTime       : new Date(2016, 11, 0, 8),
     *          endTime         : new Date(2016, 11, 0, 12)
     *      }
     *
     * You can pass the "asString" flag to disable that and just return strings.
     *
     * @param {Boolean} asString Whether to just return an array of strings, instead of objects.
     * @return {Object[]/String[]} Array of objects with "startTime", "endTime" properties.
     */
    getAvailability: function(asString) {
        var me = this;
        if (asString) {
            // Return the raw availability array with strings
            return this.get(this.availabilityField);
        }
        if (this.availabilityCache) {
            return this.availabilityCache;
        }
        var parsed = Ext.Array.map(this.get(this.availabilityField), function(value) {
                return typeof value === 'string' ? me.parseInterval(value) : value;
            });
        this.verifyAvailability(parsed);
        return this.availabilityCache = parsed;
    },
    /**
     * This method updates the availability information for this day. It accept an array of strings: '08:00-12:00', or
     * objects like:
     *
     *      {
     *          startTime       : new Date(0, 0, 0, 8),
     *          endTime         : new Date(0, 0, 0, 12)
     *      }
     *
     * @param {Object[]/String[]} intervals Array of availability intervals
     */
    setAvailability: function(intervals) {
        // clear cache
        this.availabilityCache = null;
        this.set(this.availabilityField, this.stringifyIntervals(intervals));
        // to trigger the `verifyAvailability`
        this.getAvailability();
    },
    verifyAvailability: function(intervals) {
        var me = this;
        intervals.sort(function(a, b) {
            return a.startTime - b.startTime;
        });
        Ext.Array.each(intervals, function(interval, i) {
            if (interval.startTime > interval.endTime) {
                throw new Error(Ext.String.format(me.L('startTimeAfterEndTime'), Ext.Date.format(interval.startTime, 'H:i'), Ext.Date.format(interval.endTime, 'H:i')));
            }
            if (i > 0 && intervals[i - 1].endTime > interval.startTime) {
                throw new Error(Ext.String.format(me.L('availabilityIntervalsShouldNotIntersect'), me.stringifyInterval(intervals[i - 1]), me.stringifyInterval(interval)));
            }
        });
    },
    prependZero: function(value) {
        return value < 10 ? '0' + value : value;
    },
    stringifyInterval: function(interval) {
        var startTime = interval.startTime;
        var endTime = interval.endTime;
        return this.prependZero(startTime.getHours()) + ':' + this.prependZero(startTime.getMinutes()) + '-' + (endTime.getDate() == 1 ? 24 : this.prependZero(endTime.getHours())) + ':' + this.prependZero(endTime.getMinutes());
    },
    stringifyIntervals: function(intervals) {
        var me = this;
        return Ext.Array.map(intervals, function(interval) {
            if (typeof interval === 'string')  {
                return interval;
            }
            
            return me.stringifyInterval(interval);
        });
    },
    parseInterval: function(string) {
        var match = /(\d\d):(\d\d)-(\d\d):(\d\d)/.exec(string);
        if (!match)  {
            throw new Error(Ext.String.format(this.L('invalidFormat'), string));
        }
        
        return {
            startTime: new Date(2016, 11, 0, match[1], match[2]),
            endTime: new Date(2016, 11, 0, match[3], match[4])
        };
    },
    /**
     * Returns the total length of all availability intervals for this day in hours.
     *
     * @return {Number}
     */
    getTotalHours: function() {
        return this.getTotalMS() / 1000 / 60 / 60;
    },
    /**
     * Returns the total length of all availability intervals for this day in milliseconds.
     *
     * @return {Number}
     */
    getTotalMS: function() {
        var totalMS = 0;
        Ext.Array.each(this.getAvailability(), function(interval) {
            totalMS += interval.endTime - interval.startTime;
        });
        return totalMS;
    },
    /**
     * Adds a new availability interval to this day. Both arguments should have the same format.
     *
     * @param {Date/String} startTime Start time of the interval. Can be a Date object (new Date(2016, 11, 0, 8)) or just a plain string: '08'
     * @param {Date/String} endTime End time of the interval. Can be a Date object (new Date(2016, 11, 0, 12)) or just a plain string: '12'
     */
    addAvailabilityInterval: function(startTime, endTime) {
        var interval;
        // User might provide something like: new Date(0, 0, 0, 12, 34)
        // but we need to have exact year & month to be able to compare interval borders
        function prepareDate(date) {
            return new Date(2016, 11, date.getDate() == 1 ? 1 : 0, date.getHours(), date.getMinutes());
        }
        if (startTime instanceof Date) {
            interval = {
                startTime: prepareDate(startTime),
                endTime: prepareDate(endTime)
            };
        } else {
            interval = this.parseInterval(startTime + (endTime ? '-' + endTime : ''));
        }
        var intervals = this.getAvailability().concat(interval);
        this.verifyAvailability(intervals);
        this.setAvailability(intervals);
    },
    /**
     * Removes the availability interval by its index.
     *
     * @param {Number} index Ordinal position of the interval to be removed
     */
    removeAvailabilityInterval: function(index) {
        var intervals = this.getAvailability();
        intervals.splice(index, 1);
        this.setAvailability(intervals);
    },
    /**
     * Applies the availability intervals to a concrete day. For example the availability intervals [ '08:00-12:00', '13:00-17:00' ],
     * applied to a day 2012/01/01 will return the following result:
     *
     *    [
     *        {
     *            startDate       : new Date(2012, 0, 1, 8),
     *            endDate         : new Date(2012, 0, 1, 12)
     *        },
     *        {
     *            startDate       : new Date(2012, 0, 1, 13),
     *            endDate         : new Date(2012, 0, 1, 17)
     *        }
     *    ]
     *
     *
     * @param {Date} date The date to apply the intervals to
     *
     * @returns {Object[]} Array of objects with "startDate / endDate" properties.
     */
    getAvailabilityIntervalsFor: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        var year = timeDate.getFullYear();
        var month = timeDate.getMonth();
        var date = timeDate.getDate();
        return Ext.Array.map(this.getAvailability(), function(interval) {
            var endDate = interval.endTime.getDate();
            return {
                startDate: new Date(year, month, date, interval.startTime.getHours(), interval.startTime.getMinutes()),
                endDate: new Date(year, month, date + (endDate == 1 ? 1 : 0), interval.endTime.getHours(), interval.endTime.getMinutes())
            };
        });
    },
    /**
     * Returns the earliest available time for the given date. If this day has no availability intervals it returns `null`.
     *
     * @param {Date} date The date to get the earliest availability time for.
     *
     * @return {Date}
     */
    getAvailabilityStartFor: function(timeDate) {
        var intervals = this.getAvailabilityIntervalsFor(timeDate);
        if (!intervals.length) {
            return null;
        }
        return intervals[0].startDate;
    },
    /**
     * Returns the latest available time for the given date. If this day has no availability intervals, it returns `null`.
     *
     * @param {Date} date The date to get the latest availability time for.
     *
     * @return {Date}
     */
    getAvailabilityEndFor: function(timeDate) {
        var intervals = this.getAvailabilityIntervalsFor(timeDate);
        if (!intervals.length) {
            return null;
        }
        return intervals[intervals.length - 1].endDate;
    }
});

// When converting date from ISO string Ext.Date.parse adds extra hour, so use native JS parsing instead
// https://app.assembla.com/spaces/bryntum/tickets/9623
// Test in tests/datalayer/024_event_dst_switch_parse_iso_string.t.js
Ext.define('Sch.patches.DateFieldConvertDate', {
    extend: 'Sch.util.Patch',
    target: 'Ext.data.field.Date',
    minVersion: '7.0.0',
    maxVersion: '8.0.0',
    overrides: {
        // Override private implementation of convert function
        convert: function(v) {
            if (!v) {
                return null;
            }
            // instanceof check ~10 times faster than Ext.isDate. Values here will not be
            // cross-document objects
            if (v instanceof Date) {
                return v;
            }
            /* eslint-disable-next-line vars-on-top */
            var dateFormat = this.dateReadFormat || this.dateFormat,
                parsed;
            if (dateFormat) {
                //region OVERRIDE
                // Use native JS parsing in case of zero UTC string (for example '2021-03-28T01:00:00.000Z')
                // when format is one of the following:
                // - c         ISO 8601 date represented as the local time with an offset to UTC appended.
                // - C         An ISO date string as implemented by the native Date.toISOString method
                if ((dateFormat === 'c' || dateFormat === 'C') && /Z$/.test(v)) {
                    var result = new Date(v);
                    // Check if the result is not an Invalid Date object
                    return !isNaN(result.getTime()) ? result : null;
                }
                //endregion
                return Ext.Date.parse(v, dateFormat, this.useStrict);
            }
            parsed = Date.parse(v);
            return parsed ? new Date(parsed) : null;
        }
    }
});

/**
 @class Sch.model.Range

 This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.

 Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
 Please refer to documentation of those classes to become familar with the base interface of this class.

 The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.
 */
Ext.define('Sch.model.Range', {
    extend: 'Sch.model.Customizable',
    requires: [
        'Sch.util.Date',
        'Sch.patches.DateFieldConvertDate'
    ],
    idProperty: 'Id',
    isRangeModel: true,
    /**
     * @cfg {String} startDateField The name of the field that defines the range start date. Defaults to "StartDate".
     */
    startDateField: 'StartDate',
    /**
     * @cfg {String} endDateField The name of the field that defines the range end date. Defaults to "EndDate".
     */
    endDateField: 'EndDate',
    /**
     * @cfg {String} nameField The name of the field that defines the range name. Defaults to "Name".
     */
    nameField: 'Name',
    /**
     * @cfg {String} clsField The name of the field that holds the range "class" value (usually corresponds to a CSS class). Defaults to "Cls".
     */
    clsField: 'Cls',
    customizableFields: [
        /**
         * @field Id
         * A unique identifier of the range
         */
        /**
         * @method getStartDate
         *
         * Returns the range start date
         *
         * @return {Date} The start date
         */
        /**
         * @field
         * The start date of the range in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
         */
        {
            name: 'StartDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @method getEndDate
         *
         * Returns the range end date
         *
         * @return {Date} The end date
         */
        /**
         * @field
         * The end date of the range in the ISO 8601 format. See {@link Ext.Date} for a formats definitions.
         */
        {
            name: 'EndDate',
            type: 'date',
            dateFormat: 'c'
        },
        /**
         * @method getCls
         *
         * Gets the "class" of the range
         *
         * @return {String} cls The "class" of the range
         */
        /**
         * @method setCls
         *
         * Sets the "class" of the range
         *
         * @param {String} cls The new class of the range
         */
        /**
         * @field
         * An optional CSS class to be associated with the range.
         */
        {
            name: 'Cls',
            type: 'string'
        },
        /**
         * @method getName
         *
         * Gets the name of the range
         *
         * @return {String} name The "name" of the range
         */
        /**
         * @method setName
         *
         * Sets the "name" of the range
         *
         * @param {String} name The new name of the range
         */
        /**
         * @field
         * An optional name of the range
         */
        {
            name: 'Name',
            type: 'string'
        }
    ],
    /**
     * @method setStartDate
     *
     * Sets the range start date
     *
     * @param {Date} date The new start date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setStartDate: function(date, keepDuration) {
        var endDate = this.getEndDate();
        var oldStart = this.getStartDate();
        this.beginEdit();
        this.set(this.startDateField, date);
        if (keepDuration === true && endDate && oldStart) {
            this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
        }
        this.endEdit();
    },
    /**
     * @method setEndDate
     *
     * Sets the range end date
     *
     * @param {Date} date The new end date
     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
     * Defaults to `false`
     */
    setEndDate: function(date, keepDuration) {
        var startDate = this.getStartDate();
        var oldEnd = this.getEndDate();
        this.beginEdit();
        this.set(this.endDateField, date);
        if (keepDuration === true && startDate && oldEnd) {
            this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
        }
        this.endEdit();
    },
    /**
     * Sets the event start and end dates
     *
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     */
    setStartEndDate: function(start, end) {
        this.beginEdit();
        this.set(this.startDateField, start);
        this.set(this.endDateField, end);
        this.endEdit();
    },
    /**
     * Returns an array of all dates between start and end for this range.
     * @return {Date[]}
     */
    getDates: function() {
        var dates = [],
            endDate = this.getEndDate();
        if (this.isScheduled()) {
            var startFloored = Ext.Date.clearTime(this.getStartDate(), true);
            // Zero duration range
            if (endDate - this.getStartDate() === 0) {
                dates.push(startFloored);
            } else {
                for (var date = startFloored; date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) {
                    dates.push(date);
                }
            }
        }
        return dates;
    },
    /**
     * Iterates over the results from {@link #getDates}
     * @param {Function} func The function to call for each date
     * @param {Object} scope The scope to use for the function call
     */
    forEachDate: function(func, scope) {
        return Ext.Array.each(this.getDates(), func, scope);
    },
    /**
     * Checks if the range record has both start and end dates set and start <= end
     *
     * @return {Boolean}
     */
    isScheduled: function() {
        var me = this;
        return Boolean(me.getStartDate() && me.getEndDate() && me.areDatesValid());
    },
    // Simple check if end date is greater than start date
    isValid: function() {
        var me = this,
            result = me.callParent(),
            start, end;
        if (result) {
            start = me.getStartDate() , end = me.getEndDate();
            result = !start || !end || (end - start >= 0);
        }
        return result;
    },
    // Simple check if just end date is greater than start date
    areDatesValid: function() {
        var me = this,
            start = me.getStartDate(),
            end = me.getEndDate();
        return !start || !end || (end - start >= 0);
    },
    /**
     * Shift the dates for the date range by the passed amount and unit
     * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
     * @param {Number} amount The amount to shift
     */
    shift: function(unit, amount) {
        this.setStartEndDate(Sch.util.Date.add(this.getStartDate(), unit, amount), Sch.util.Date.add(this.getEndDate(), unit, amount));
    },
    fullCopy: function() {
        return this.copy.apply(this, arguments);
    },
    intersectsRange: function(start, end) {
        var myStart = this.getStartDate();
        var myEnd = this.getEndDate();
        return myStart && myEnd && Sch.util.Date.intersectSpans(myStart, myEnd, start, end);
    }
});

/**

@class Sch.data.Calendar
@extends Ext.data.Store
@aside guide gantt_calendars

A class representing a customizable calendar with weekends, holidays and availability information for any day.
Internally, it's just a subclass of the Ext.data.Store class which should be loaded with a collection
of {@link Sch.model.CalendarDay} instances. Additionally, calendars may have parent-child relations, allowing "child" calendars to "inherit"
all special dates from its "parent" and add its own. See {@link #parent} property for details.

A calendar can be instantiated like this:

    var calendar        = new Sch.data.Calendar({
        data    : [
            {
                Date            : new Date(2010, 0, 13),
                Cls             : 'national-holiday'
            },
            {
                Date            : new Date(2010, 1, 1),
                Cls             : 'company-holiday'
            },
            {
                Date            : new Date(2010, 0, 16),
                IsWorkingDay    : true
            }
        ]
    });

Please refer to the {@link Sch.model.CalendarDay} class to learn the data model used for the calendar.

*/
Ext.define('Sch.data.Calendar', {
    extend: 'Ext.data.Store',
    alias: 'store.calendar',
    requires: [
        'Ext.Date',
        'Sch.model.CalendarDay',
        'Sch.model.Range',
        'Sch.util.Date'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Robo.data.Store'
    ],
    model: 'Sch.model.CalendarDay',
    /**
     * Number of days per month. Will be used when converting the big duration units like month/year to days.
     *
     * @cfg {Number} daysPerMonth
     */
    daysPerMonth: 30,
    /**
     * Number of days per week. Will be used when converting the duration in weeks to days.
     *
     * @cfg {Number} daysPerWeek
     */
    daysPerWeek: 7,
    /**
     * Number of hours per day. Will be used when converting the duration in days to hours.
     *
     * **Please note**, that this config is used for duration convertion and not anything else. If you need to change
     * the number of working hours in the day, update the {@link #defaultAvailability}
     *
     * @cfg {Number} hoursPerDay
     */
    hoursPerDay: 24,
    unitsInMs: null,
    defaultNonWorkingTimeCssCls: 'sch-nonworkingtime',
    /**
     * @cfg {Boolean} weekendsAreWorkdays Setting this option to `true` will treat *all* days as working. Default value is `false`.
     */
    weekendsAreWorkdays: false,
    /**
     * @cfg {Number} weekendFirstDay The index of the first day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 6 - Saturday
     */
    weekendFirstDay: 6,
    /**
     * @cfg {Number} weekendSecondDay The index of the second day in weekend, 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on.
     * Default value is 0 - Sunday
     */
    weekendSecondDay: 0,
    holidaysCache: null,
    availabilityIntervalsCache: null,
    daysIndex: null,
    // a "cached" array of WEEKDAY days
    weekAvailability: null,
    // the "very default" availability array, calculated based on `defaultAvailability` property
    defaultWeekAvailability: null,
    nonStandardWeeksByStartDate: null,
    nonStandardWeeksStartDates: null,
    /**
     * @cfg {String} calendarId The unique id for the calendar. Providing a `calendarId` will register this calendar in the calendars registry
     * and it can be retrieved later with {@link #getCalendar}. Generally only required if want to use {@link #parent parent-child relations} between the calendars,
     * or assign this calendar to a particular task or resource.
     *
     * Note, that when loading the calendar using ExtJS proxy this field will not be set.
     */
    calendarId: null,
    /**
     * @cfg {String/Sch.data.Calendar} parent The parent calendar. Can be provided as the calendar id or calendar instance itself. If this property is provided
     * or set with {@link #setParent} method, this calendar becomes a "child" of the specified calendar.
     *
     * This means that it will "inherit" from its "parent":
     *
     * * day overrides,
     * * week days,
     * * week day overrides.
     *
     * In the same time, special days, defined in this calendar take priority over the ones from the "parent".
     *
     * You can use this feature if you'd like to create a single "main" calendar for the whole project, and then allow some task or resource to
     * have slightly different calendar (with an additional day off for example). You will not have to re-create all special days in the calendar of such task/resource - just
     * set the "main" calendar as a "parent" for it.
     */
    parent: null,
    /**
     * @cfg {String[]} defaultAvailability The array of default availability intervals (in the format of the `Availability` field
     * in the {@link Sch.model.CalendarDay}) for each working weekday (Monday-Friday). Defaults to whole day (00-24) for backward compatibility.
     */
    defaultAvailability: [
        '00:00-24:00'
    ],
    /**
     * @cfg {String} name The name of this calendar
     */
    name: null,
    suspendCacheUpdate: 0,
    /**
    * @cfg {Number} availabilitySearchLimit Maximum number of days to search for calendar availability intervals.
    * Used in various calculations requiring to respect working time.
    * In these cases system iterate through working time day by day. This option determines a maximum distance iteration will be done.
    * Prevents from infinite loop in case of wrong calendar configuration.
    */
    availabilitySearchLimit: 1825,
    //5*365
    inheritableStatics: {
        /**
         * Returns the registered calendar with the given id.
         *
         * @param {String} id The calendar id
         * @return {Sch.data.Calendar}
         */
        getCalendar: function(id) {
            if (id instanceof Sch.data.Calendar)  {
                return id;
            }
            
            return Ext.data.StoreManager.lookup('GNT_CALENDAR:' + id);
        },
        /**
         * Returns an array of all registered calendars.
         *
         * @return {Sch.data.Calendar[]}
         */
        getAllCalendars: function() {
            var result = [];
            Ext.data.StoreManager.each(function(store) {
                if (store instanceof Sch.data.Calendar) {
                    result.push(store);
                }
            });
            return result;
        },
        /**
         * Destroys all registered calendars.
         *
         * @return {Sch.data.Calendar[]}
         */
        removeAll: function() {
            var sm = Ext.data.StoreManager;
            sm.each(function(store) {
                if (store instanceof Sch.data.Calendar) {
                    sm.unregister(store);
                    Ext.destroy(store);
                }
            });
        }
    },
    constructor: function(config) {
        config = config || {};
        var parent = config.parent;
        delete config.parent;
        var calendarId = config.calendarId;
        delete config.calendarId;
        this.callParent(arguments);
        this.setParent(parent);
        this.setCalendarId(calendarId);
        this.unitsInMs = {
            MILLI: 1,
            SECOND: 1000,
            MINUTE: 60 * 1000,
            HOUR: 60 * 60 * 1000,
            DAY: this.hoursPerDay * 60 * 60 * 1000,
            WEEK: this.daysPerWeek * this.hoursPerDay * 60 * 60 * 1000,
            MONTH: this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            QUARTER: 3 * this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000,
            YEAR: 12 * this.daysPerMonth * this.hoursPerDay * 60 * 60 * 1000
        };
        this.defaultWeekAvailability = this.getDefaultWeekAvailability();
        // traditional "on-demand" caching seems to be not so efficient for calendar (in theory)
        // calculating any cached property, like, "weekAvailability" or "nonStandardWeeksStartDates" will require full calendar scan each time
        // so we update ALL cached values on any CRUD operations
        this.on({
            update: this.onCalendarUpdate,
            add: this.onCalendarDataChange,
            remove: this.onCalendarDataChange,
            filter: this.onCalendarDataChange,
            sort: this.onCalendarDataChange,
            clear: this.onCalendarDataChange,
            refresh: this.onCalendarDataChange,
            write: this.onCalendarDataChange,
            scope: this
        });
        this.clearCache();
    },
    shouldReactOnCalendarDayFieldUpdate: function(record, modifiedFields) {
        return Boolean(Ext.Array.some(modifiedFields, function(item) {
            return item !== record.clsField && item !== record.nameField;
        }));
    },
    onCalendarUpdate: function(store, record, operation, modified) {
        if (operation == Ext.data.Model.EDIT && this.shouldReactOnCalendarDayFieldUpdate(record, modified)) {
            this.onCalendarDataChange();
        }
    },
    onCalendarDataChange: function() {
        this.clearCache();
    },
    /**
     * Returns the {@link #calendarId} of the current calendar
     * @return {String}
     */
    getCalendarId: function() {
        return this.calendarId;
    },
    /**
     * Sets the {@link #calendarId} of the current calendar and register it in the calendar registry.
     *
     * @param {String} id
     */
    setCalendarId: function(id) {
        // allow "0" as the calendarId
        if (this.calendarId != null)  {
            Ext.data.StoreManager.unregister(this);
        }
        
        this.calendarId = id;
        if (id != null) {
            this.storeId = 'GNT_CALENDAR:' + id;
            Ext.data.StoreManager.register(this);
        } else  {
            this.storeId = null;
        }
        
        var proxy = this.proxy;
        if (proxy && proxy.extraParams)  {
            proxy.extraParams.calendarId = id;
        }
        
    },
    getDefaultWeekAvailability: function() {
        var availability = this.defaultAvailability;
        var weekendFirstDay = this.weekendFirstDay;
        var weekendSecondDay = this.weekendSecondDay;
        var res = [];
        for (var i = 0; i < 7; i++) {
            res.push(this.weekendsAreWorkdays || i != weekendFirstDay && i != weekendSecondDay ? new this.model({
                Type: 'WEEKDAY',
                Weekday: i,
                Availability: availability && availability.slice() || [],
                IsWorkingDay: true
            }) : new this.model({
                Type: 'WEEKDAY',
                Weekday: i,
                Availability: []
            }));
        }
        return res;
    },
    resetCache: function() {
        if (this.suspendCacheUpdate > 0)  {
            return;
        }
        
        this.holidaysCache = {};
        this.availabilityIntervalsCache = {};
        var daysIndex = this.daysIndex = {};
        var weekAvailability = this.weekAvailability = [];
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates = [];
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate = {};
        this.each(function(calendarDay) {
            // backward compat
            var id = calendarDay.getId();
            var overrideMatch = /^(\d)-(\d\d\d\d\/\d\d\/\d\d)-(\d\d\d\d\/\d\d\/\d\d)$/.exec(id);
            var weekDayMatch = /^WEEKDAY:(\d+)$/.exec(id);
            var type = calendarDay.getType();
            var weekDay = calendarDay.getWeekday();
            if (type == 'WEEKDAYOVERRIDE' || overrideMatch) {
                var startDate, endDate;
                if (type == 'WEEKDAYOVERRIDE') {
                    startDate = calendarDay.getOverrideStartDate();
                    endDate = calendarDay.getOverrideEndDate();
                }
                // backward compat
                if (overrideMatch) {
                    startDate = Ext.Date.parse(overrideMatch[2], 'Y/m/d');
                    endDate = Ext.Date.parse(overrideMatch[3], 'Y/m/d');
                    weekDay = overrideMatch[1];
                }
                // allow partially defined days - they will not be included in calculations
                if (startDate && endDate && weekDay != null) {
                    var startDateNum = startDate - 0;
                    if (!nonStandardWeeksByStartDate[startDateNum]) {
                        nonStandardWeeksByStartDate[startDateNum] = {
                            startDate: new Date(startDate),
                            endDate: new Date(endDate),
                            name: calendarDay.getName(),
                            weekAvailability: [],
                            // main day representing the week override itself - for example for overrides w/o any re-defined availability
                            mainDay: null
                        };
                        nonStandardWeeksStartDates.push(startDateNum);
                    }
                    if (weekDay >= 0)  {
                        nonStandardWeeksByStartDate[startDateNum].weekAvailability[weekDay] = calendarDay;
                    }
                    else  {
                        nonStandardWeeksByStartDate[startDateNum].mainDay = calendarDay;
                    }
                    
                }
            } else if (type == 'WEEKDAY' || weekDayMatch) {
                if (weekDayMatch)  {
                    weekDay = weekDayMatch[1];
                }
                
                // again - only fully defined records will be taken into account
                if (weekDay != null) {
                    if (weekDay < 0 || weekDay > 6) {
                        throw new Error("Incorrect week day index");
                    }
                    weekAvailability[weekDay] = calendarDay;
                }
            } else {
                var date = calendarDay.getDate();
                if (date)  {
                    daysIndex[date - 0] = calendarDay;
                }
                
            }
        });
        // Numeric sort, can't use default JS sort which is string based
        nonStandardWeeksStartDates.sort(function(a, b) {
            return a - b;
        });
    },
    // will scan through all calendar days in the store and save references to special ones to the properties, for speedup
    clearCache: function() {
        if (this.suspendCacheUpdate > 0)  {
            return;
        }
        
        this.resetCache();
        this.fireEvent('calendarchange', this);
    },
    /**
     * Returns `true` or `false` depending whether the given time span intersects with one of the defined week day overrides.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     *
     * @return {Boolean}
     */
    intersectsWithCurrentWeeks: function(startDate, endDate) {
        var result = false;
        this.forEachNonStandardWeek(function(week) {
            var weekStartDate = week.startDate;
            var weekEndDate = week.endDate;
            if (weekStartDate <= startDate && startDate < weekEndDate || weekStartDate < endDate && endDate <= weekEndDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    },
    /**
     * Adds a week day override ("non-standard" week) to the calendar. As a reminder, week day override consists from up to 7 days,
     * that re-defines the default week days availability only within certain time span.
     *
     * @param {Date} startDate The start date of the time span
     * @param {Date} endDate The end date of the time span
     * @param {Sch.model.CalendarDay[]/String[][]} weekAvailability The array indexed from 0 to 7, containing items for week days.
     * Index 0 corresponds to Sunday, 1 to Monday, etc. Some items can be not defined or set to `null`, indicating that override does not
     * change this week day. Item can be - an instance of {@link Sch.model.CalendarDay} (only `Availability` field needs to be set), or
     * an array of strings, defining the availability (see the description of the `Availability` field in the {@link Sch.model.CalendarDay}).
     * @param {String} name The name of this week day override
     */
    addNonStandardWeek: function(startDate, endDate, weekAvailability, name) {
        startDate = Ext.Date.clearTime(new Date(startDate));
        endDate = Ext.Date.clearTime(new Date(endDate));
        if (this.intersectsWithCurrentWeeks(startDate, endDate)) {
            throw new Error("Can not add intersecting week");
        }
        var DayModel = this.model;
        var days = [];
        Ext.Array.each(weekAvailability, function(day, index) {
            if (day && day.isCalendarDayModel) {
                day.setType('WEEKDAYOVERRIDE');
                day.setOverrideStartDate(startDate);
                day.setOverrideEndDate(endDate);
                day.setWeekday(index);
                day.setName(name || 'Week override');
                days.push(day);
            } else if (Ext.isArray(day)) {
                var newDay = new DayModel();
                newDay.setType('WEEKDAYOVERRIDE');
                newDay.setOverrideStartDate(startDate);
                newDay.setOverrideEndDate(endDate);
                newDay.setWeekday(index);
                newDay.setName(name || 'Week override');
                newDay.setAvailability(day);
                days.push(newDay);
            }
        });
        var mainDay = new DayModel();
        mainDay.setType('WEEKDAYOVERRIDE');
        mainDay.setOverrideStartDate(startDate);
        mainDay.setOverrideEndDate(endDate);
        mainDay.setWeekday(-1);
        mainDay.setName(name || 'Week override');
        days.push(mainDay);
        this.add(days);
    },
    /**
     * Returns an object describing a week day override ("non-standard" week), that starts at the given date or `null` if there's no any.
     *
     * @param {Date} startDate The start date of the week day override
     *
     * @return {Object} An object with the following properties
     * @return {Object} return.name A "Name" field of the week days in the override
     * @return {Date} return.startDate An "OverrideStartDate" field of the week days in the override
     * @return {Date} return.endDate An "OverrideEndDate" field of the week days in the override
     * @return {Sch.model.CalendarDay[]} return.weekAvailability An array with the week days, defined by this override. May be filled only partially if
     * week day override does not contain all days.
     * @return {Sch.model.CalendarDay} return.mainDay A "main" day instance for this override
     */
    getNonStandardWeekByStartDate: function(startDate) {
        return this.nonStandardWeeksByStartDate[Ext.Date.clearTime(new Date(startDate)) - 0] || null;
    },
    /**
     * Returns an object describing a week day override ("non-standard" week), that contains the given date or `null` if there's no any.
     *
     * @param {Date} startDate The date that falls within some of the week day overrides
     *
     * @return {Object} An object describing week day override. See {@link #getNonStandardWeekByStartDate} method for details.
     */
    getNonStandardWeekByDate: function(timeDate) {
        timeDate = Ext.Date.clearTime(new Date(timeDate)) - 0;
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
        for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
            var week = nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]];
            // since `nonStandardWeeksStartDates` are sorted inc and week overrides do not intersect
            // we can shorcut in this case
            if (week.startDate > timeDate)  {
                break;
            }
            
            if (week.startDate <= timeDate && timeDate <= week.endDate) {
                return week;
            }
        }
        return null;
    },
    /**
     * Removes all calendar day instances, that forms a week day override ("non-standard" week) with the given start date.
     *
     * @param {Date} startDate The start date of the week day override
     */
    removeNonStandardWeek: function(startDate) {
        startDate = Ext.Date.clearTime(new Date(startDate)) - 0;
        var week = this.getNonStandardWeekByStartDate(startDate);
        if (!week)  {
            return;
        }
        
        this.remove(Ext.Array.clean(week.weekAvailability).concat(week.mainDay));
    },
    /**
     * Iterator for each week day override, defined in this calendar.
     *
     * @param {Function} func The function to call for each override. It will receive a single argument - object, describing the override.
     * See {@link #getNonStandardWeekByStartDate} for details. Returning `false` from the function stops the iterator.
     * @param {Object} scope The scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the function calls have returned `false`
     */
    forEachNonStandardWeek: function(func, scope) {
        var me = this;
        var nonStandardWeeksStartDates = this.nonStandardWeeksStartDates;
        var nonStandardWeeksByStartDate = this.nonStandardWeeksByStartDate;
        for (var i = 0; i < nonStandardWeeksStartDates.length; i++) {
            if (func.call(scope || me, nonStandardWeeksByStartDate[nonStandardWeeksStartDates[i]]) === false)  {
                return false;
            }
            
        }
    },
    /**
     * Updates the default availability information based on the value provided.
     *
     * @param {Boolean} value true if weekends should be regarded as working time.
     */
    setWeekendsAreWorkDays: function(value) {
        if (value !== this.weekendsAreWorkdays) {
            this.weekendsAreWorkdays = value;
            // Must generate new defaultWeekAvailability
            this.defaultWeekAvailability = this.getDefaultWeekAvailability();
            this.clearCache();
        }
    },
    /**
     * Returns true if weekends are regarded as working time.
     *
     * @return {Boolean} true if weekends should be regarded as working time.
     */
    areWeekendsWorkDays: function() {
        return this.weekendsAreWorkdays;
    },
    /**
     * Returns a corresponding {@link Sch.model.CalendarDay} instance for the given date. First, this method checks for {@link #getOverrideDay day overrides}
     * (either in this or parent calendars), then for week days (again, in this or parent calendars) and finally fallbacks to the
     * calendar day with the {@link #defaultAvailability} availability.
     *
     * @param {Date} timeDate A date (can contain time portion which will be ignored)
     *
     * @return {Sch.model.CalendarDay}
     */
    getCalendarDay: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        return this.getOverrideDay(timeDate) || this.getWeekDay(timeDate.getDay(), timeDate) || this.getDefaultCalendarDay(timeDate.getDay());
    },
    /**
     * Returns a day override corresponding to the given date (possibly found in the parent calendars) or `null` if the given date
     * has no overrides in this calendar and all its parents.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Sch.model.CalendarDay}
     */
    getOverrideDay: function(timeDate) {
        return this.getOwnCalendarDay(timeDate) || this.parent && this.parent.getOverrideDay(timeDate) || null;
    },
    /**
     * Returns an "own" day override corresponding to the given date. That is - day override defined in the current calendar only.
     *
     * @param {Date} timeDate The date to check for day overrides for
     * @return {Sch.model.CalendarDay}
     */
    getOwnCalendarDay: function(timeDate) {
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        return this.daysIndex[Ext.Date.clearTime(timeDate, true) - 0];
    },
    /**
     * Returns a "special" week day corresponding to the given date. Under "special" week day we mean a calendar day with the `Type = WEEKDAY` or `WEEKDAYOVERRIDE`.
     * See the {@link Sch.model.CalendarDay} class for details. If the concrete date is given as 2nd argument, this method will
     * first check for any week overrides passing on it.
     *
     * If not found in current calendar, this method will consult parent. If no "special" week day found neither in this calendar, no parents - it returns `null`.
     *
     * @param {Number} weekDayIndex The index of the week day to retrieve (0-Sunday, 1-Monday, etc)
     * @param {Date} [timeDate] The date for which the week day is being retrieved.
     * @return {Sch.model.CalendarDay}
     */
    getWeekDay: function(weekDayIndex, timeDate) {
        // if 2nd argument is provided then try to search in non-standard weeks first
        if (timeDate) {
            var week = this.getNonStandardWeekByDate(timeDate);
            if (week && week.weekAvailability[weekDayIndex])  {
                return week.weekAvailability[weekDayIndex];
            }
            
        }
        return this.weekAvailability[weekDayIndex] || this.parent && this.parent.getWeekDay(weekDayIndex, timeDate) || null;
    },
    /**
     * Returns a "default" calendar day instance, corresponding to the one, generated from {@link #defaultAvailability}. By default all working days in the week
     * corresponds to the day with {@link #defaultAvailability} set in the `Availability` field and non-working days has empty `Availability`.
     *
     * @param {Number} weekDayIndex The index of the "default" week day to retrieve (0-Sunday, 1-Monday, etc)
     * @return {Sch.model.CalendarDay}
     */
    getDefaultCalendarDay: function(weekDayIndex) {
        if (!this.hasOwnProperty('defaultAvailability') && !this.hasOwnProperty('weekendsAreWorkdays') && this.parent) {
            return this.parent.getDefaultCalendarDay(weekDayIndex);
        }
        return this.defaultWeekAvailability[weekDayIndex];
    },
    /**
     * Returns a boolean indicating whether a passed date falls on the weekend or holiday.
     *
     * @param {Date} timeDate A given date (can contain time portion)
     *
     * @return {Boolean}
     */
    isHoliday: function(timeDate) {
        var secondsSinceEpoch = timeDate - 0;
        var holidaysCache = this.holidaysCache;
        if (holidaysCache[secondsSinceEpoch] != null) {
            return holidaysCache[secondsSinceEpoch];
        }
        timeDate = typeof timeDate == 'number' ? new Date(timeDate) : timeDate;
        var day = this.getCalendarDay(timeDate);
        if (!day)  {
            throw new Error("Can't find day for " + timeDate);
        }
        
        return holidaysCache[secondsSinceEpoch] = !day.getIsWorkingDay();
    },
    /**
     * Returns `true` if given date passes on the weekend and `false` otherwise. Weekend days can be re-defined with the {@link #weekendFirstDay} and {@link #weekendSecondDay} options.
     *
     * @param {Date} timeDate The date to check
     * @return {Boolean}
     */
    isWeekend: function(timeDate) {
        var dayIndex = timeDate.getDay();
        return dayIndex === this.weekendFirstDay || dayIndex === this.weekendSecondDay;
    },
    /**
     * Returns a boolean indicating whether a passed date is a working day.
     *
     * @param {Date} date A given date (can contain time portion which will be ignored)
     *
     * @return {Boolean}
     */
    isWorkingDay: function(date) {
        return !this.isHoliday(date);
    },
    /**
     * Convert the duration given in milliseconds to a given unit. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs Duration in milliseconds
     * @param {String} unit Duration unit to which the duration should be converted
     *
     * @return {Number} converted value
     */
    convertMSDurationToUnit: function(durationInMs, unit) {
        return durationInMs / this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
    },
    /**
     * Convert the duration given in some unit to milliseconds. Uses the {@link #daysPerMonth} configuration option.
     *
     * @param {Number} durationInMs
     * @param {String} unit
     *
     * @return {Number} converted value
     */
    convertDurationToMs: function(duration, unit) {
        return duration * this.unitsInMs[Sch.util.Date.getNameOfUnit(unit)];
    },
    // TODO: cover this w/ a test and make public
    convertDuration: function(duration, fromUnit, toUnit) {
        var me = this,
            result = duration;
        if (fromUnit != toUnit) {
            result = me.convertMSDurationToUnit(me.convertDurationToMs(duration, fromUnit), toUnit);
        }
        return result;
    },
    /**
     * Returns an array of ranges for non-working days between `startDate` and `endDate`. For example, when given a full month,
     * it will return an array of 4 `Sch.model.Range` instances, containing the ranges for the weekends. If a holiday lasts for several days
     * and all {@link Sch.model.CalendarDay} instances have the same `Cls` value then all days will be combined into ae single range.
     *
     * @param {Date} startDate - A start date of the timeframe to extract the holidays from
     * @param {Date} endDate - An end date of the timeframe to extract the holidays from
     *
     * @return {Sch.model.Range[]}
     */
    getHolidaysRanges: function(startDate, endDate, includeWeekends, timeZone) {
        if (startDate > endDate) {
            Ext.Error.raise("startDate can't be bigger than endDate");
        }
        startDate = Ext.Date.clearTime(startDate, true);
        endDate = endDate - Ext.Date.clearTime(endDate, true) > 0 ? Sch.util.Date.getStartOfNextDay(endDate, true, true) : endDate;
        var ranges = [],
            currentRange, date;
        for (date = startDate; date < endDate; date = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1, null, timeZone)) {
            var localDate = date;
            if (timeZone) {
                localDate = Sch.util.Date.toTimeZone(localDate, timeZone);
            }
            if (this.isHoliday(localDate) || (this.weekendsAreWorkdays && includeWeekends && this.isWeekend(localDate))) {
                var day = this.getCalendarDay(localDate);
                var cssClass = day && day.getCls() || this.defaultNonWorkingTimeCssCls;
                var nextDate = Sch.util.Date.getNext(date, Sch.util.Date.DAY, 1, null, timeZone);
                // starts new range
                if (!currentRange) {
                    currentRange = new Sch.model.Range({
                        StartDate: date,
                        EndDate: nextDate,
                        Cls: cssClass
                    });
                } else {
                    // checks if the range is still the same
                    if (currentRange.getCls() == cssClass) {
                        currentRange.setEndDate(nextDate);
                    } else {
                        ranges.push(currentRange);
                        currentRange = new Sch.model.Range({
                            StartDate: date,
                            EndDate: nextDate,
                            Cls: cssClass
                        });
                    }
                }
            } else {
                if (currentRange) {
                    ranges.push(currentRange);
                    currentRange = null;
                }
            }
        }
        if (currentRange) {
            ranges.push(currentRange);
        }
        return ranges;
    },
    /**
     * This an iterator that passes through the all availability intervals (working time intervals) in the given date range.
     *
     * For example if the default availability in this calendar is [ '09:00-13:00', '14:00-18:00' ] and this function is called, like this:
     *
     *      calendar.forEachAvailabilityInterval(
     *           //             midnight  Friday                 midnight Tuesday
     *          { startDate : new Date(2013, 1, 8), endDate : new Date(2013, 1, 12) },
     *          function (startDate, endDate) { ... }
     *      )
     * then the provided function will be called 4 times with the following arguments:
     *
     *      startDate : new Date(2013, 1, 8, 9),    endDate : new Date(2013, 1, 8, 13)
     *      startDate : new Date(2013, 1, 8, 14),   endDate : new Date(2013, 1, 8, 18)
     *      startDate : new Date(2013, 1, 11, 9),   endDate : new Date(2013, 1, 11, 13)
     *      startDate : new Date(2013, 1, 11, 14),  endDate : new Date(2013, 1, 11, 18)
     *
     *
     * @param {Object} options An object with the following properties:
     * @param {Date} options.startDate A start date of the date range. Can be omitted, if `isForward` flag is set to `false`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Date} options.endDate An end date of the date range. Can be omitted, if `isForward` flag is set to `true`. In this case iterator
     * will not stop until the call to `func` will return `false`.
     * @param {Boolean} [options.isForward=true] A flag, defining the direction, this iterator advances in. If set to `true` iterations
     * will start from the `startDate` option and will advance in date increasing direction. If set to `false` iterations will start from the `endDate`
     * option and will advance in date decreasing direction.
     * @param {Function} func A function to call for each availability interval, in the given date range. It receives 2 arguments - the start date
     * of the availability interval and the end date.
     * @param {Object} scope A scope to execute the `func` with.
     *
     * @return {Boolean} `false` if any of the calls to `func` has returned `false`
     */
    forEachAvailabilityInterval: function(options, func, scope) {
        scope = scope || this;
        var startDate = options.startDate;
        var endDate = options.endDate;
        // isForward by default
        var isForward = options.isForward !== false;
        if (isForward ? !startDate : !endDate) {
            throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
        }
        var cursorDate = new Date(isForward ? startDate : endDate);
        var DATE = Sch.util.Date;
        // if no boundary we still have to specify some limit
        if (isForward) {
            if (!endDate) {
                endDate = DATE.add(startDate, DATE.DAY, options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365);
            }
        } else {
            if (!startDate) {
                startDate = DATE.add(endDate, DATE.DAY, -(options.availabilitySearchLimit || this.availabilitySearchLimit || 5 * 365));
            }
        }
        // the Ext.Date.clearTime() method is called a lot during this method (like 200k times for 2k tasks project)
        // sometimes w/o real need for it since we always advance to the next day's boundary
        // this optimization brings it down to ~10k, ~10% speed up in the profiles
        var noNeedToClearTime = false;
        while (isForward ? cursorDate < endDate : cursorDate > startDate) {
            // - 1 for backward direction ensures that we are checking correct day,
            // since the endDate is not inclusive - 02/10/2012 means the end of 02/09/2012
            // for backward direction we always clear time, because intervals are cached by the beginning of the day
            var intervals = this.getAvailabilityIntervalsFor(cursorDate - (isForward ? 0 : 1), isForward ? noNeedToClearTime : false);
            // the order of processing is different for forward / backward processing
            for (var i = isForward ? 0 : intervals.length - 1; isForward ? i < intervals.length : i >= 0; isForward ? i++ : i--) {
                var interval = intervals[i];
                var intervalStartDate = interval.startDate;
                var intervalEndDate = interval.endDate;
                // availability interval is out of [ startDate, endDate )
                if (intervalStartDate >= endDate || intervalEndDate <= startDate)  {
                    
                    continue;
                }
                
                var countingFrom = intervalStartDate < startDate ? startDate : intervalStartDate;
                var countingTill = intervalEndDate > endDate ? endDate : intervalEndDate;
                if (func.call(scope, countingFrom, countingTill) === false)  {
                    return false;
                }
                
            }
            cursorDate = isForward ? DATE.getStartOfNextDay(cursorDate, false, noNeedToClearTime) : DATE.getEndOfPreviousDay(cursorDate, noNeedToClearTime);
            noNeedToClearTime = true;
        }
    },
    /**
     * Calculate the duration in the given `unit` between 2 dates, taking into account the availability/holidays information (non-working time will be excluded from the duration).
     *
     * @param {Date} startDate The start date
     * @param {Date} endDate The end date
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Number} Working time duration between given dates.
     */
    calculateDuration: function(startDate, endDate, unit) {
        var duration = 0;
        this.forEachAvailabilityInterval({
            startDate: startDate,
            endDate: endDate
        }, function(intervalStartDate, intervalEndDate) {
            var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            duration += intervalEndDate - intervalStartDate + dstDiff * 60 * 1000;
        });
        return this.convertMSDurationToUnit(duration, unit);
    },
    /**
     * Calculate the end date for the given start date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} startDate The start date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The end date
     */
    calculateEndDate: function(startDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(startDate);
        }
        var DATE = Sch.util.Date,
            endDate;
        duration = this.convertDurationToMs(duration, unit);
        var startFrom = // milestone case, which we don't want to re-schedule to the next business days
            // milestones should start/end in the same day as its incoming dependency
            duration === 0 && Ext.Date.clearTime(startDate, true) - startDate === 0 ? DATE.add(startDate, Sch.util.Date.DAY, -1) : startDate;
        this.forEachAvailabilityInterval({
            startDate: startFrom
        }, function(intervalStartDate, intervalEndDate) {
            var diff = intervalEndDate - intervalStartDate;
            var dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            if (diff >= duration) {
                endDate = new Date(intervalStartDate - 0 + duration);
                return false;
            } else {
                duration -= diff + dstDiff * 60 * 1000;
            }
        });
        return endDate;
    },
    /**
     * Calculate the start date for the given end date and duration, taking into account the availability/holidays information (non-working time will not be counted as duration).
     *
     * @param {Date} endDate The end date
     * @param {Number} duration The "pure" duration (w/o any non-working time).
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date} The start date
     */
    calculateStartDate: function(endDate, duration, unit) {
        // if duration is 0 - return the same date
        if (!duration) {
            return new Date(endDate);
        }
        var startDate;
        duration = this.convertDurationToMs(duration, unit);
        this.forEachAvailabilityInterval({
            endDate: endDate,
            isForward: false
        }, function(intervalStartDate, intervalEndDate) {
            var diff = intervalEndDate - intervalStartDate;
            if (diff >= duration) {
                startDate = new Date(intervalEndDate - duration);
                return false;
            } else  {
                duration -= diff;
            }
            
        });
        return startDate;
    },
    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `isForward` flag) skiping the non-working time.
     * It returns the nearest edge of the first working time interval it encounters. If the given `date` falls on the working time, then `date` itself is returned.
     *
     * For example, if this function is called with some Saturday as `date` and `isForward` flag is set, it will return the earliest working hours on following Monday.
     * If `isForward` flag will be set to `false` - it will return the latest working hours on previous Friday.
     *
     * @param {Date} date A date (presumably falling on the non-working time).
     * @param {Boolean} isForward Pass `true` to skip the non-working time in forward direction, `false` - in backward
     *
     * @return {Date} Nearest working date.
     */
    skipNonWorkingTime: function(date, isForward) {
        var found = false;
        // reseting the date to the earliest availability interval
        this.forEachAvailabilityInterval(isForward ? {
            startDate: date
        } : {
            endDate: date,
            isForward: false
        }, function(intervalStartDate, intervalEndDate) {
            date = isForward ? intervalStartDate : intervalEndDate;
            found = true;
            return false;
        });
        if (!found)  {
            throw new Error('skipNonWorkingTime: Cannot skip non-working time, please ensure that this calendar has any working period of time specified');
        }
        
        return new Date(date);
    },
    /**
     * This method starts from the given `date` and moves forward/backward in time (depending from the `duration` argument).
     * It stops as soon as it skips the amount of *working* time defined by the `duration` and `unit` arguments. Skipped non-working time simply will not
     * be counted.
     *
     * **Note** that this method behaves differently from the {@link #skipNonWorkingTime} - that method stops as soon as it encounters the non-working time.
     * This method stops as soon as it accumulate enough skipped working time.
     *
     * @param {Date} date A starting point
     * @param {Number} duration The duration of the working time. To skip working time in backward direction pass a negative value.
     * @param {String} unit One of the units of the {@link Sch.util.Date} class, for example `Sch.util.Date.DAY`.
     *
     * @return {Date}
     */
    skipWorkingTime: function(date, duration, unit) {
        return duration >= 0 ? this.calculateEndDate(date, duration, unit) : this.calculateStartDate(date, -duration, unit);
    },
    /**
     * Returns the availability intervals of a specific day. Potentially can consult a parent calendar.
     *
     * @param {Date/Number} timeDate A date or timestamp
     * @return {Object[]} Array of objects, like:

    {
        startDate       : new Date(...),
        endDate         : new Date(...)
    }
     */
    getAvailabilityIntervalsFor: function(timeDate, noNeedToClearTime) {
        // This is more robust method of clearing time than direct call to Ext.Date.clearTime
        if (noNeedToClearTime) {
            timeDate = (timeDate).valueOf();
        } else if (timeDate instanceof Date) {
            timeDate = (new Date(timeDate.getFullYear(), timeDate.getMonth(), timeDate.getDate())).valueOf();
        } else {
            timeDate = Ext.Date.clearTime(new Date(timeDate)).valueOf();
        }
        return this.availabilityIntervalsCache[timeDate] = (this.availabilityIntervalsCache[timeDate] || this.getCalendarDay(timeDate).getAvailabilityIntervalsFor(timeDate));
    },
    isChildOf: function(calendar) {
        var parent = this,
            found = false;
        while (parent && !found) {
            found = parent === calendar;
            parent = parent.parent;
        }
        return found;
    },
    getParentableCalendars: function() {
        var me = this,
            result = [],
            calendars = Sch.data.Calendar.getAllCalendars();
        Ext.Array.each(calendars, function(calendar) {
            if (calendar !== me && !calendar.isChildOf(me))  {
                result.push({
                    Id: calendar.calendarId,
                    Name: calendar.name || calendar.calendarId
                });
            }
            
        });
        return result;
    },
    /**
     * Sets the {@link #parent} for this calendar. Pass `null` to remove the parent.
     *
     * @param {Null/String/Sch.data.Calendar} parentOrId String with {@link #calendarId} value or calendar instance itself.
     */
    setParent: function(parentOrId) {
        var parent = Sch.data.Calendar.getCalendar(parentOrId);
        if (parentOrId && !parent)  {
            throw new Error("Invalid parent specified for the calendar");
        }
        
        if (this.parent != parent) {
            var proxy = this.proxy;
            var listeners = {
                    calendarchange: this.onParentCalendarChange,
                    destroy: this.onParentDestroy,
                    scope: this
                };
            var oldParent = this.parent;
            if (oldParent)  {
                oldParent.un(listeners);
            }
            
            this.parent = parent;
            if (parent)  {
                parent.on(listeners);
            }
            
            if (proxy && proxy.extraParams)  {
                proxy.extraParams.parentId = parent ? parent.calendarId : null;
            }
            
            this.clearCache();
            /**
             * @event parentchange
             *
             * @param {Sch.data.Calendar} calendar The calendar which parent has changed
             * @param {Sch.data.Calendar} newParent The new parent of this calendar (can be `null` if parent is being removed)
             * @param {Sch.data.Calendar} oldParent The old parent of this calendar (can be `null` if there were no parent)
             */
            this.fireEvent('parentchange', this, parent, oldParent);
        }
    },
    onParentCalendarChange: function() {
        this.clearCache();
    },
    onParentDestroy: function() {
        this.setParent(null);
    },
    isAvailabilityIntersected: function(withCalendar, startDate, endDate) {
        var ownWeekDay, ownAvailability, testWeekDay, testAvailability;
        // first let's try to find overlapping of weeks (check daily intervals)
        // loop over week days
        for (var i = 0; i < 7; i++) {
            ownWeekDay = this.getWeekDay(i) || this.getDefaultCalendarDay(i);
            testWeekDay = withCalendar.getWeekDay(i) || withCalendar.getDefaultCalendarDay(i);
            if (!ownWeekDay || !testWeekDay)  {
                
                continue;
            }
            
            // get daily intervals
            ownAvailability = ownWeekDay.getAvailability();
            testAvailability = testWeekDay.getAvailability();
            // loop over intervals to find overlapping
            for (var j = 0,
                l = ownAvailability.length; j < l; j++) {
                for (var k = 0,
                    ll = testAvailability.length; k < ll; k++) {
                    if (testAvailability[k].startTime < ownAvailability[j].endTime && testAvailability[k].endTime > ownAvailability[j].startTime) {
                        return true;
                    }
                }
            }
        }
        var result = false;
        this.forEachNonStandardWeek(function(week) {
            if (week.startDate >= endDate)  {
                return false;
            }
            
            if (startDate < week.endDate) {
                result = true;
                // stop the iteration
                return false;
            }
        });
        return result;
    }
});

/**
@class Sch.data.CrudManager

The Crud Manager (or "CM") is a class implementing centralized loading and saving of data in multiple stores.
Loading the stores and saving all changes is done using one ajax request. This class uses AJAX as a transport mechanism and JSON as the data encoding format.

For usage details please see [this guide](#!/guide/scheduler_crud_manager).

# Scheduler stores

The class supports Ext Scheduler specific stores (namely: resource, event and assignment stores).
For these stores, the CM has separate configs ({@link #resourceStore}, {@link #eventStore}, {@link #assignmentStore})
to register them. The class can also grab them from the task store (this behavior can be changed using
{@link #addRelatedStores} config).

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

# AJAX request configuration

To configure AJAX request parameters please take a look at the {@link #transport} config.

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url         : 'php/read.php',
                // use GET request
                method      : 'GET',
                // pass request JSON in "rq" parameter
                paramName   : 'rq',
                // extra HTTP request parameters
                params      : {
                    foo     : 'bar'
                }
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });


# Load order

The CM is aware of the proper load order for Scheduler specific stores so you don't need to worry about it.
If you provide any extra stores (using {@link #stores} config) they will be added to the start of collection before
 the Scheduler specific stores.
If you a different load order, you should use {@link #addStore} method to register your store:

    var crudManager = Ext.create('Sch.data.CrudManager', {
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        // extra user defined stores will get to the start of collection
        // so they will be loaded first
        stores          : [ store1, store2 ],
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

    // append store3 to the end so it will be loaded last
    crudManager.addStore(store3);

    // now when we registered all the stores let's load them
    crudManager.load();

*/
Ext.define('Sch.data.CrudManager', {
    extend: 'Sch.crud.AbstractManager',
    mixins: [
        'Sch.crud.encoder.Json',
        'Sch.crud.transport.Ajax'
    ],
    /**
     * @cfg {Sch.data.ResourceStore/Object} resourceStore A store with resources (or its descriptor).
     */
    /**
     * @property {Object} resourceStore The resource store descriptor.
     */
    resourceStore: null,
    /**
     * @cfg {Sch.data.EventStore/Object} eventStore A store with events (or its descriptor).
     */
    /**
     * @property {Object} eventStore The event store descriptor.
     */
    eventStore: null,
    /**
     * @cfg {Sch.data.AssignmentStore/Object} assignmentStore A store with assignments (or its descriptor).
     */
    /**
     * @property {Object} assignmentStore The assignment store descriptor.
     */
    assignmentStore: null,
    /**
     * @cfg {Sch.data.DependencyStore/Object} dependencyStore A store with dependencies (or its descriptor).
     */
    /**
     * @property {Object} dependencyStore The dependency store descriptor.
     */
    dependencyStore: null,
    /**
     * @cfg {Boolean} addRelatedStores
     * When set to `true` this class will try to get the {@link #resourceStore} and {@link #assignmentStore} stores from
     * the specified {@link #eventStore} instance.
     */
    addRelatedStores: true,
    constructor: function(config) {
        config = config || {};
        var resourceStore = config.resourceStore || this.resourceStore || new Sch.data.ResourceStore(),
            eventStore = config.eventStore || this.eventStore || new Sch.data.EventStore(),
            assignmentStore = config.assignmentStore || this.assignmentStore,
            dependencyStore = config.dependencyStore || this.dependencyStore,
            // list of stores to add
            stores = [];
        // retrieve stores registered on the provided taskStore
        if (eventStore && config.addRelatedStores !== false) {
            var extracted = this.getEventStoreInfo(eventStore, config);
            assignmentStore = assignmentStore || extracted.assignmentStore;
            resourceStore = resourceStore || extracted.resourceStore;
            dependencyStore = dependencyStore || extracted.dependencyStore;
        }
        // event store
        eventStore && stores.push(eventStore);
        // resource store
        resourceStore && stores.push(resourceStore);
        // assignment store
        assignmentStore && stores.push(assignmentStore);
        // dependency store
        dependencyStore && stores.push(dependencyStore);
        // all the Scheduler related stores will go after the user defined stores from the config.stores
        if (stores.length) {
            var syncSequence = [];
            // For applying sync results we have a different order:
            // resources -> events -> assignments -> dependencies
            resourceStore && syncSequence.push(resourceStore);
            eventStore && syncSequence.push(eventStore);
            assignmentStore && syncSequence.push(assignmentStore);
            dependencyStore && syncSequence.push(dependencyStore);
            if (syncSequence.length) {
                config.syncApplySequence = (config.syncApplySequence || config.stores || []).concat(syncSequence);
            }
            var _stores = config.stores || this.stores;
            if (_stores && !Ext.isArray(_stores))  {
                _stores = [
                    _stores
                ];
            }
            
            config.stores = (_stores || []).concat(stores);
        }
        this.callParent([
            config
        ]);
        this.eventStore = this.getStoreDescriptor(eventStore);
        this.resourceStore = this.getStoreDescriptor(resourceStore);
        this.assignmentStore = this.getStoreDescriptor(assignmentStore);
        this.dependencyStore = this.getStoreDescriptor(dependencyStore);
    },
    getEventStoreInfo: function(eventStore, config) {
        if (!eventStore.isStore) {
            if (typeof eventStore == 'string') {
                eventStore = Ext.data.StoreManager.get(eventStore);
            } else {
                eventStore = eventStore.store;
            }
        }
        var result = {},
            assignmentStore = config.assignmentStore,
            resourceStore = config.resourceStore,
            dependencyStore = config.dependencyStore;
        !assignmentStore && (result.assignmentStore = eventStore.getAssignmentStore());
        !resourceStore && (result.resourceStore = eventStore.getResourceStore());
        !dependencyStore && (result.dependencyStore = eventStore.getDependencyStore());
        return result;
    },
    /**
     * Returns the resource store bound to the CRUD manager.
     * @return {Sch.data.ResourceStore} The resource store.
     */
    getResourceStore: function() {
        return this.resourceStore && this.resourceStore.store;
    },
    /**
     * Sets the resource store bound to the CRUD manager.
     * @param {Sch.data.ResourceStore} The resource store.
     */
    setResourceStore: function(store) {
        if (this.getResourceStore()) {
            this.removeStore(this.getResourceStore());
        }
        this.addStore(store);
        this.resourceStore = {
            store: store
        };
    },
    /**
     * Returns the event store bound to the CRUD manager.
     * @return {Sch.data.EventStore} The event store.
     */
    getEventStore: function() {
        return this.eventStore && this.eventStore.store;
    },
    /**
     * Sets the event store bound to the CRUD manager.
     * @param {Sch.data.EventStore} The event store.
     */
    setEventStore: function(store) {
        if (this.getEventStore()) {
            this.removeStore(this.getEventStore());
        }
        this.addStore(store);
        this.eventStore = {
            store: store
        };
    },
    /**
     * Returns the assignment store bound to the CRUD mananger.
     * @return {Sch.data.AssignmentStore} The assignment store
     */
    getAssignmentStore: function() {
        return this.assignmentStore && this.assignmentStore.store;
    },
    /**
     * Sets the assignment store bound to the CRUD mananger.
     * @param {Sch.data.AssignmentStore} The assignment store
     */
    setAssignmentStore: function(store) {
        if (this.getAssignmentStore()) {
            this.removeStore(this.getAssignmentStore());
        }
        this.addStore(store);
        this.assignmentStore = {
            store: store
        };
    },
    /**
     * Returns the dependency store bound to the CRUD mananger.
     * @return {Sch.data.DependencyStore} The dependency store
     */
    getDependencyStore: function() {
        return this.dependencyStore && this.dependencyStore.store;
    },
    /**
     * Sets the dependency store bound to the CRUD mananger.
     * @param {Sch.data.DependencyStore} The dependency store
     */
    setDependencyStore: function(store) {
        if (this.getDependencyStore()) {
            this.removeStore(this.getDependencyStore());
        }
        this.addStore(store);
        this.dependencyStore = {
            store: store
        };
    }
});

/**
 * Dependency store event->dependencies cache.
 * Uses event records or event record ids as keys.
 *
 * The cache uses 3 keys for each event:
 * - {EventId} - contains both successors and predecessors
 * - {EventId}-succ - contains successors only
 * - {EventId}-pred - contains predecessors only
 *
 * @private
 */
Ext.define('Sch.data.util.EventDependencyCache', function() {
    var collectOptions = {
            allowNull: false,
            filtered: false,
            collapsed: true
        };
    var cellArray = [
            null
        ];
    function cacheDependencies(me, dependencies) {
        Ext.Array.each(dependencies, function(dependency) {
            var sourceId = dependency.getSourceId(),
                targetId = dependency.getTargetId();
            if (sourceId) {
                me.add(sourceId, dependency);
            }
            if (targetId) {
                me.add(targetId, dependency);
            }
            if (sourceId && targetId) {
                me.addSuccessor(sourceId, dependency);
                me.addPredecessor(targetId, dependency);
            }
        });
    }
    function uncacheDependencies(me, dependencies) {
        Ext.Array.each(dependencies, function(dependency) {
            var sourceId = dependency.getSourceId(),
                targetId = dependency.getTargetId();
            if (sourceId) {
                me.remove(sourceId, dependency);
                me.removeSuccessor(sourceId, dependency);
            }
            if (targetId) {
                me.remove(targetId, dependency);
                me.removePredecessor(targetId, dependency);
            }
        });
    }
    function uncacheEventDependencies(me, events) {
        Ext.Array.each(events, function(event) {
            me.clear(event);
            me.clearSuccessors(event);
            me.clearPredecessors(event);
        });
    }
    function updateDependency(me, newSourceId, oldSourceId, newTargetId, oldTargetId, dependency) {
        if (newSourceId !== oldSourceId) {
            me.move(oldSourceId, newSourceId, dependency);
            me.moveSuccessors(oldSourceId, newSourceId, dependency);
        }
        if (newTargetId !== oldTargetId) {
            me.move(oldTargetId, newTargetId, dependency);
            me.movePredecessors(oldTargetId, newTargetId, dependency);
        }
    }
    function moveDependencies(me, oldEventId, newEventId) {
        me.move(oldEventId, newEventId);
        me.moveSuccessors(oldEventId, newEventId);
        me.movePredecessors(oldEventId, newEventId);
    }
    function complementCache(me, events) {
        Ext.Array.each(events, function(event) {
            if (!me.has(event)) {
                me.set(event, []);
                me.setSuccessors(event, []);
                me.setPredecessors(event, []);
            }
        });
    }
    function recacheAll(me, dependencyStore, eventStore) {
        me.clear();
        cacheDependencies(me, dependencyStore.getRange());
        eventStore && (!eventStore.getRoot || eventStore.getRoot()) && complementCache(me, eventStore.collect(eventStore.getModel().idProperty, collectOptions));
    }
    function recacheKeys(me, keys, dependencyStore, eventStore) {
        // Adopting keys for fast checking and removing corresponding key from cache
        keys = Ext.Array.reduce(keys, function(result, key) {
            me.set(key, []);
            result[me.key(key)] = true;
        }, {});
        // Re-caching
        dependencyStore.each(function(dependency) {
            var sourceId = dependency.getSourceId(),
                targetId = dependency.getTargetId(),
                isSuccessor = keys.hasOwnProperty(sourceId),
                // this dependency defines succesor of source task
                isPredecessor = keys.hasOwnProperty(targetId);
            // this dependency defines predecessor of a target task
            isSuccessor && me.add(sourceId, dependency);
            isSuccessor && me.addSuccessor(sourceId, dependency);
            isPredecessor && me.add(targetId, dependency);
            isPredecessor && me.addPredecessor(targetId, dependency);
        });
        // Complementing
        Ext.Object.each(keys, function(key) {
            if (!me.has(key) && (eventStore.getNodeById ? eventStore.getNodeById(key) : eventStore.getById(key))) {
                me.set(key, []);
            }
        });
    }
    return {
        extend: 'Sch.util.Cache',
        dependencyStore: null,
        dependencyStoreDetacher: null,
        eventStoreDetacher: null,
        constructor: function(dependencyStore) {
            var me = this;
            me.callParent();
            me.dependencyStore = dependencyStore;
            function onDependencyAdd(store, dependencies) {
                cacheDependencies(me, dependencies);
            }
            function onDependencyRemove(store, dependencies, index, isMove) {
                !isMove && uncacheDependencies(me, dependencies);
            }
            function onDependencyUpdate(store, dependency, operation) {
                var sourceIdField = dependency.fromField,
                    targetIdField = dependency.toField,
                    sourceIdChanged = dependency.previous && sourceIdField in dependency.previous,
                    targetIdChanged = dependency.previous && targetIdField in dependency.previous,
                    previousSourceId = sourceIdChanged && dependency.previous[sourceIdField],
                    previousTargetId = targetIdChanged && dependency.previous[targetIdField];
                if (sourceIdChanged || targetIdChanged) {
                    if ((!previousSourceId && dependency.previous.hasOwnProperty(sourceIdField)) || (!previousTargetId && dependency.previous.hasOwnProperty(targetIdField))) {
                        // We had the dependency not 100% filled previously so we cannot rely on its predecessors/successors cached values
                        uncacheDependencies(me, [
                            dependency
                        ]);
                        cacheDependencies(me, [
                            dependency
                        ]);
                    } else {
                        updateDependency(me, sourceIdChanged ? dependency.getSourceId() : false, sourceIdChanged ? previousSourceId : false, targetIdChanged ? dependency.getTargetId() : false, targetIdChanged ? previousTargetId : false, dependency);
                    }
                }
            }
            function onDependencyStoreRefreshClearReset(store) {
                recacheAll(me, store, store.getEventStore());
            }
            function onDependencyStoreEventStoreChange(store, eventStore) {
                recacheAll(me, store, eventStore);
                attachToEventStore(eventStore);
            }
            function onEventIdChanged(eventStore, event, oldId, newId) {
                moveDependencies(me, oldId, newId);
            }
            function onEventAdd(eventStore, events) {
                complementCache(me, events);
            }
            function onEventNodeAppend(parent, node) {
                complementCache(me, cellArray[0] = node, cellArray);
            }
            function onEventNodeInsert(parent, node) {
                complementCache(me, cellArray[0] = node, cellArray);
            }
            function onEventRemove(store, events, index, isMove) {
                !isMove && uncacheEventDependencies(me, events);
            }
            function onEventNodeRemove(parent, node, isMove) {
                !isMove && uncacheEventDependencies(me, cellArray[0] = node, cellArray);
            }
            function onEventStoreRefreshClearReset() {
                recacheAll(me, me.dependencyStore, me.dependencyStore.getEventStore());
            }
            function onCacheInvalidate(store, keys) {
                if (!keys) {
                    recacheAll(me, me.dependencyStore, me.eventStore);
                } else {
                    if (!Ext.isArray(keys)) {
                        keys = [
                            keys
                        ];
                    }
                    recacheKeys(me, keys, me.dependencyStore, me.eventStore);
                }
            }
            function attachToEventStore(store) {
                var listeners;
                Ext.destroy(me.eventStoreDetacher);
                if (store) {
                    listeners = {
                        'idchanged': onEventIdChanged,
                        'cacheresethint': onEventStoreRefreshClearReset,
                        'clear': onEventStoreRefreshClearReset,
                        'refresh': onEventStoreRefreshClearReset,
                        // escape hatch
                        'event-dependency-cache-invalidate': onCacheInvalidate,
                        // subscribing to the CRUD using priority - should guarantee that our listeners
                        // will be called first (before any other listeners, that could be provided in the "listeners" config)
                        // and state in other listeners will be correct
                        priority: 100,
                        destroyable: true
                    };
                    if (store.isTreeStore) {
                        listeners = Ext.apply(listeners, {
                            'nodeappend': onEventNodeAppend,
                            'nodeinsert': onEventNodeInsert,
                            'noderemove': onEventNodeRemove,
                            'rootchange': onEventStoreRefreshClearReset
                        });
                    } else {
                        listeners = Ext.apply(listeners, {
                            'add': onEventAdd,
                            'remove': onEventRemove
                        });
                    }
                    me.eventStoreDetacher = store.on(listeners);
                }
            }
            me.dependencyStoreDetacher = dependencyStore.on({
                'add': onDependencyAdd,
                'remove': onDependencyRemove,
                'update': onDependencyUpdate,
                'refresh': onDependencyStoreRefreshClearReset,
                'cacheresethint': onDependencyStoreRefreshClearReset,
                'clear': onDependencyStoreRefreshClearReset,
                'eventstorechange': onDependencyStoreEventStoreChange,
                // escape hatch
                'event-dependency-cache-invalidate': onCacheInvalidate,
                // subscribing to the CRUD using priority - should guarantee that our listeners
                // will be called first (before any other listeners, that could be provided in the "listeners" config)
                // and state in other listeners will be correct
                priority: 100,
                destroyable: true
            });
            recacheAll(me, dependencyStore, dependencyStore.getEventStore());
        },
        destroy: function() {
            var me = this;
            Ext.destroyMembers(me, 'dependencyStoreDetacher', 'eventStoreDetacher');
            me.dependencyStore = null;
        },
        // This cache maintain it's own content and doesn't need fallback query via fn parameter,
        // so I override this method to ignore the fallback query
        get: function(k, fn) {
            var me = this;
            return me.callParent([
                k
            ]);
        },
        getSuccessors: function(k, fn) {
            var me = this;
            return me.get(me.self.makeSuccessorsKey(me.key(k)), fn);
        },
        getPredecessors: function(k, fn) {
            var me = this;
            return me.get(me.self.makePredecessorsKey(me.key(k)), fn);
        },
        addSuccessor: function(k, v) {
            var me = this;
            return arguments.length > 1 ? me.add(me.self.makeSuccessorsKey(me.key(k)), v) : me.add(me.self.makeSuccessorsKey(me.key(k)));
        },
        addPredecessor: function(k, v) {
            var me = this;
            return arguments.length > 1 ? me.add(me.self.makePredecessorsKey(me.key(k)), v) : me.add(me.self.makePredecessorsKey(me.key(k)));
        },
        setSuccessors: function(k, vals) {
            var me = this;
            me.set(me.self.makeSuccessorsKey(me.key(k)), vals);
        },
        setPredecessors: function(k, vals) {
            var me = this;
            me.set(me.self.makePredecessorsKey(me.key(k)), vals);
        },
        removeSuccessor: function(k, v) {
            var me = this;
            return me.remove(me.self.makeSuccessorsKey(me.key(k)), v);
        },
        removePredecessor: function(k, v) {
            var me = this;
            return me.remove(me.self.makePredecessorsKey(me.key(k)), v);
        },
        moveSuccessors: function(oldKey, newKey, v) {
            var me = this;
            return arguments.length >= 3 ? me.move(me.self.makeSuccessorsKey(me.key(oldKey)), me.self.makeSuccessorsKey(me.key(newKey)), v) : me.move(me.self.makeSuccessorsKey(me.key(oldKey)), me.self.makeSuccessorsKey(me.key(newKey)));
        },
        movePredecessors: function(oldKey, newKey, v) {
            var me = this;
            return arguments.length >= 3 ? me.move(me.self.makePredecessorsKey(me.key(oldKey)), me.self.makePredecessorsKey(me.key(newKey)), v) : me.move(me.self.makePredecessorsKey(me.key(oldKey)), me.self.makePredecessorsKey(me.key(newKey)));
        },
        clearSuccessors: function(k) {
            var me = this;
            return me.clear(me.self.makeSuccessorsKey(me.key(k)));
        },
        clearPredecessors: function(k) {
            var me = this;
            return me.clear(me.self.makePredecessorsKey(me.key(k)));
        },
        inheritableStatics: {
            splitKey: function(k) {
                k = k.split('@#!#@');
                return {
                    id: k[0],
                    type: k.length && k[1] || false
                };
            },
            makeSuccessorsKey: function(k) {
                return k + '@#!#@succ';
            },
            makePredecessorsKey: function(k) {
                return k + '@#!#@pred';
            }
        }
    };
});

/**
 * @class Sch.model.DependencyBase
 *
 * Base class used for both Ext Scheduler and Ext Gantt. Not intended to be used directly.
 */
Ext.define('Sch.model.DependencyBase', {
    extend: 'Sch.model.Customizable',
    isDependencyModel: true,
    inheritableStatics: {
        /**
         * @static
         * @property {Object} Type The enumerable object, containing names for the dependency types integer constants.
         */
        Type: {
            StartToStart: 0,
            StartToEnd: 1,
            EndToStart: 2,
            EndToEnd: 3
        }
    },
    idProperty: 'Id',
    customizableFields: [
        /**
         * @field Id
         * The id of the dependency itself
         */
        // 3 mandatory fields
        /**
         * @field
         * The id of the event at which the dependency starts
         */
        {
            name: 'From'
        },
        /**
         * @field
         * The id of the event at which the dependency ends
         */
        {
            name: 'To'
        },
        /**
         * @field
         * An integer constant representing the type of the dependency:
         *
         * - 0 - start-to-start dependency
         * - 1 - start-to-end dependency
         * - 2 - end-to-start dependency
         * - 3 - end-to-end dependency
         */
        {
            name: 'Type',
            type: 'int',
            defaultValue: 2
        },
        /**
         * @field
         * An optional CSS class that will be added to the rendered dependency elements.
         */
        {
            name: 'Cls',
            defaultValue: ''
        },
        /**
         * @field
         * A boolean indicating if a dependency goes both directions (default false).
         */
        {
            name: 'Bidirectional',
            type: 'boolean'
        },
        {
            name: 'FromSide',
            type: 'string'
        },
        {
            name: 'ToSide',
            type: 'string'
        },
        /**
         * @field
         * A field that keeps dependency highlight CSS classes.
         */
        {
            name: 'Highlighted',
            type: 'string',
            persist: false,
            defaultValue: ''
        }
    ],
    /**
     * @cfg {String} fromField The name of the field that contains the id of the source event.
     */
    fromField: 'From',
    /**
     * @cfg {String} toField The name of the field that contains the id of the target event.
     */
    toField: 'To',
    /**
     * @cfg {String} typeField The name of the field that contains the dependency type.
     */
    typeField: 'Type',
    /**
     * @cfg {String} clsField The name of the field that contains a CSS class that will be added to the rendered dependency elements.
     */
    clsField: 'Cls',
    /**
     * @cfg {String} bidirectionalField The name of the boolean field that controls if arrows should be drawn at both start and end points.
     */
    bidirectionalField: 'Bidirectional',
    /**
     * @cfg {String} highlightedField The name of the field that controls dependency highlight state.
     */
    highlightedField: 'Highlighted',
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (config) {
            // Allow passing in event instances too
            if (config[me.fromField] && config[me.fromField].isRangeModel) {
                me.setSourceEvent(config[me.fromField]);
                delete config.fromField;
            }
            if (config[me.toField] && config[me.toField].isRangeModel) {
                me.setTargetEvent(config[me.toField]);
                delete config.toField;
            }
        }
    },
    getEventStore: function() {
        return this.store.getEventStore();
    },
    /**
     * Returns the source event of the dependency
     *
     * @return {Sch.model.Event} The source event of this dependency
     */
    getSourceEvent: function(eventStore) {
        var me = this;
        return (eventStore || me.getEventStore()).getModelById(me.getSourceId());
    },
    /**
     * Sets the source event of the dependency
     *
     * @param {Sch.model.Event} event The new source event of this dependency
     */
    setSourceEvent: function(event) {
        this.setSourceId(event.getId());
    },
    /**
     * Returns the target event of the dependency
     *
     * @return {Sch.model.Event} The target event of this dependency
     */
    getTargetEvent: function(eventStore) {
        var me = this;
        return (eventStore || me.getEventStore()).getModelById(me.getTargetId());
    },
    /**
     * Sets the target event of the dependency
     *
     * @param {Sch.model.Event} event The new target event of this dependency
     */
    setTargetEvent: function(event) {
        this.setTargetId(event.getId());
    },
    /**
     * Returns the source event id of the dependency
     *
     * @return {Mixed} The id of the source event for the dependency
     *
     * @method getFrom
     */
    /**
     * Returns the source event id of the dependency
     *
     * @return {Mixed} The id of the source event for the dependency
     */
    getSourceId: function() {
        return this.getFrom();
    },
    /**
     * Sets the source event id of the dependency
     *
     * @param {Mixed} id The id of the source event for the dependency
     *
     * @method setFrom
     */
    /**
     * Sets the source event id of the dependency
     *
     * @param {Mixed} id The id of the source event for the dependency
     */
    setSourceId: function(id) {
        return this.setFrom(id);
    },
    /**
     * Returns the target event id of the dependency
     *
     * @return {Mixed} The id of the target event for the dependency
     *
     * @method getTo
     */
    /**
     * Returns the target event id of the dependency
     *
     * @return {Mixed} The id of the target event for the dependency
     */
    getTargetId: function() {
        return this.getTo();
    },
    /**
     * Sets the target event id of the dependency
     *
     * @param {Mixed} id The id of the target event for the dependency
     *
     * @method setTo
     */
    /**
     * Sets the target event id of the dependency
     *
     * @param {Mixed} id The id of the target event for the dependency
     */
    setTargetId: function(id) {
        return this.setTo(id);
    },
    /**
     * @method getType
     *
     * Returns the dependency type
     * @return {Mixed} The type of the dependency
     */
    /**
     * @method setType
     *
     * Sets the dependency type
     * @param {Mixed} type The type of the dependency
     */
    /**
     * @method getCls
     *
     * Returns the dependency CSS class (see {@link #Cls} field).
     *
     * @return {String} The CSS class
     */
    /**
     * @method setCls
     *
     * Sets the dependency CSS class (see {@link #Cls} field).
     *
     * @return {String} The CSS class
     */
    /**
     * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var me = this,
            source = me.getSourceEvent(),
            target = me.getTargetEvent();
        return source && !source.phantom && target && !target.phantom;
    },
    getDateRange: function() {
        var sourceTask = this.getSourceEvent();
        var targetTask = this.getTargetEvent();
        if (sourceTask && targetTask && sourceTask.isScheduled() && targetTask.isScheduled()) {
            var Type = this.self.Type;
            var sourceDate, targetDate;
            switch (this.getType()) {
                case Type.StartToStart:
                    sourceDate = sourceTask.getStartDate();
                    targetDate = targetTask.getStartDate();
                    break;
                case Type.StartToEnd:
                    sourceDate = sourceTask.getStartDate();
                    targetDate = targetTask.getEndDate();
                    break;
                case Type.EndToEnd:
                    sourceDate = sourceTask.getEndDate();
                    targetDate = targetTask.getEndDate();
                    break;
                case Type.EndToStart:
                    sourceDate = sourceTask.getEndDate();
                    targetDate = targetTask.getStartDate();
                    break;
            }
            return {
                start: Sch.util.Date.min(sourceDate, targetDate),
                end: Sch.util.Date.max(sourceDate, targetDate)
            };
        }
        return null;
    },
    /**
     * Applies given CSS class to dependency, the value doesn't persist
     *
     * @param {String} cls
     */
    highlight: function(cls) {
        var me = this,
            classes = me.getHighlighted().split(' ');
        if (!Ext.Array.contains(classes, cls)) {
            var newClasses = classes.concat(cls);
            me.setHighlighted(newClasses.join(' '));
        }
    },
    /**
     * Removes given CSS class from dependency if applied, the value doesn't persist
     *
     * @param {String} cls
     */
    unhighlight: function(cls) {
        var me = this,
            classes = me.getHighlighted().split(' ');
        if (Ext.Array.contains(classes, cls)) {
            var newClasses = Ext.Array.remove(classes, cls);
            me.setHighlighted(newClasses.join(' '));
        }
    },
    /**
     * Checks if the given CSS class is applied to dependency.
     *
     * @param {String} cls
     * @return {Boolean}
     */
    isHighlightedWith: function(cls) {
        var me = this,
            classes = me.getHighlighted().split(' ');
        return Ext.Array.contains(classes, cls);
    }
});

/**

@class Sch.model.Dependency
@extends Sch.model.DependencyBase

This class represents a single Dependency between two events. It is a subclass of the {@link Sch.model.DependencyBase}
class, which in its turn subclasses {@link Sch.model.Customizable} and {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of this class.

Subclassing the Dependency class
--------------------

The name of any model field can be customized in the subclass, see the example below. Please also refer to {@link Sch.model.Customizable}
for details.

    Ext.define('MyProject.model.Dependency', {
        extend      : 'Sch.model.Dependency',

        toField     : 'targetId',
        fromField   : 'sourceId',

        ...
    })

*/
Ext.define('Sch.model.Dependency', {
    extend: 'Sch.model.DependencyBase',
    /**
     * Returns `true` if the dependency is valid. Has valid type and both source and target ids set and not links to itself.
     *
     * @return {Boolean}
     */
    isValid: function(taskStore) {
        var me = this,
            valid = me.callParent(arguments),
            sourceId = me.getSourceId(),
            targetId = me.getTargetId(),
            type = me.getType();
        return Ext.isNumber(type) && !Ext.isEmpty(sourceId) && !Ext.isEmpty(targetId) && sourceId != targetId;
    },
    // Determines the type of dependency based on fromSide and toSide
    // TODO: Check with vertical orientation
    getTypeFromSides: function(fromSide, toSide, rtl) {
        var types = this.self.Type,
            startSide = rtl ? 'right' : 'left',
            endSide = rtl ? 'left' : 'right';
        if (fromSide === startSide) {
            return (toSide === startSide) ? types.StartToStart : types.StartToEnd;
        }
        return (toSide === endSide) ? types.EndToEnd : types.EndToStart;
    }
});

// @tag dependencies
/**
 * @class Sch.data.DependencyStore
 * @extends Ext.data.Store
 *
 * A class representing a collection of dependencies between events in the {@link Sch.data.EventStore}.
 * Contains a collection of {@link Sch.model.Dependency} records.
 */
Ext.define('Sch.data.DependencyStore', {
    extend: 'Ext.data.Store',
    requires: [
        'Sch.patches.CollectionKey',
        'Sch.data.util.EventDependencyCache'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Robo.data.Store'
    ],
    config: {
        // WARNING: this is a private config in Ext.data.LocalStore
        extraKeys: {
            bySourceTargetId: {
                keyFn: function(dependency) {
                    return Sch.data.DependencyStore.makeDependencySourceTargetCompositeKey(dependency.getSourceId(), dependency.getTargetId());
                }
            }
        }
    },
    model: 'Sch.model.Dependency',
    alias: 'store.sch_dependencystore',
    storeId: 'dependencies',
    eventStoreDetacher: null,
    eventStore: null,
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.eventDependencyCache = me.eventDependencyCache || me.createEventDependencyCache();
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventDependencyCache', 'eventStoreDetacher');
        me.callParent();
    },
    /**
     * Event->dependency cache factory
     *
     * @return {Sch.util.Cache}
     * @protected
     */
    createEventDependencyCache: function() {
        return new Sch.data.util.EventDependencyCache(this);
    },
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore = me.eventStore;
        me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
        me.attachToEventStore(me.eventStore);
        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * @event eventstorechange
             * Fires when a new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.DependencyStore} this
             * @param {Sch.data.EventStore} newEventStore
             * @param {Sch.data.EventStore} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    attachToEventStore: function(eventStore) {
        var me = this;
        Ext.destroy(me.eventStoreDetacher);
        if (eventStore && eventStore.isTreeStore) {
            me.eventStoreDetacher = eventStore.on({
                'noderemove': me.onEventNodeRemove,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
        // higher than in cache, we need those handlers to do their job before cache update
        else if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                'remove': me.onEventRemove,
                scope: me,
                destroyable: true,
                priority: 200
            });
        }
    },
    // higher than in cache, we need those handlers to do their job before cache update
    onEventRemove: function(eventStore, events, index, isMove) {
        !isMove && this.removeEventDependencies(events, false);
    },
    onEventNodeRemove: function(eventStore, event, isMove) {
        !isMove && this.removeEventDependencies(event, false);
    },
    // TODO: document
    reduceEventDependencies: function(event, reduceFn, result, flat, depsGetterFn) {
        var me = this;
        depsGetterFn = depsGetterFn || function(event) {
            var eventId = event && event.isModel ? event.getId() : event;
            return me.eventDependencyCache.get(event, function() {
                // Full scan, but cache makes everything possible to avoid it
                return Ext.Array.filter(me.getRange(), function(dependency) {
                    return dependency.getTargetId() == eventId || dependency.getSourceId() == eventId;
                });
            });
        };
        event = Ext.isArray(event) ? event : [
            event
        ];
        flat = flat === undefined ? true : false;
        Ext.Array.reduce(event, function(result, event) {
            if (event.isNode && !flat) {
                event.cascadeBy(function(event) {
                    result = Ext.Array.reduce(depsGetterFn(event), reduceFn, result);
                });
            } else {
                result = Ext.Array.reduce(depsGetterFn(event), reduceFn, result);
            }
        }, result);
        return result;
    },
    // TODO: document
    reduceEventIncomingDependencies: function(event, reduceFn, result, flat) {
        var me = this;
        return me.reduceEventDependencies(event, reduceFn, result, flat, function(event) {
            var eventId = event && event.isModel ? event.getId() : event;
            return me.eventDependencyCache.getPredecessors(event, function() {
                // Full scan, but cache makes everything possible to avoid it
                return Ext.Array.filter(me.getRange(), function(dependency) {
                    return dependency.getTargetId() == eventId;
                });
            });
        });
    },
    // TODO: document
    reduceEventOutgoingDependencies: function(event, reduceFn, result, flat) {
        var me = this;
        return me.reduceEventDependencies(event, reduceFn, result, flat, function(event) {
            var eventId = event && event.isModel ? event.getId() : event;
            return me.eventDependencyCache.getSuccessors(event, function() {
                // Full scan, but cache makes everything possible to avoid it
                return Ext.Array.filter(me.getRange(), function(dependency) {
                    return dependency.getSourceId() == eventId;
                });
            });
        });
    },
    // TODO: document
    mapEventDependencies: function(event, fn, filterFn, flat, depsGetterFn) {
        return this.reduceEventDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat, depsGetterFn);
    },
    // TODO: document
    mapEventIncomingDependencies: function(event, fn, filterFn, flat) {
        return this.reduceEventIncomingDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    },
    // TODO: document
    mapEventOutgoingDependencies: function(event, fn, filterFn, flat) {
        return this.reduceEventOutgoingDependencies(event, function(result, dependency) {
            filterFn(dependency) && result.push(dependency);
            return result;
        }, [], flat);
    },
    /**
     * Returns all dependencies of for a certain event (both incoming and outgoing)
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventDependencies: function(event, flat) {
        return this.mapEventDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    /**
     * Returns all incoming dependencies of the given event
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventIncomingDependencies: function(event, flat) {
        return this.mapEventIncomingDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    /**
     * Returns all outcoming dependencies of a event
     *
     * @param {Sch.model.Event} event
     * @param {Boolean} flat
     * @return {Sch.model.Dependency[]}
     */
    getEventOutgoingDependencies: function(event, flat) {
        return this.mapEventOutgoingDependencies(event, Ext.identityFn, Ext.returnTrue, flat);
    },
    // TODO: document
    getEventPredecessors: function(event, flat) {
        var me = this,
            eventStore = me.getEventStore();
        Ext.Assert && Ext.Assert.truthy(eventStore, "Can't get event predecessors, no event store configured");
        return me.reduceEventDependencies(event, function(result, dependency) {
            var predecessorId = dependency.getFrom(),
                predecessor = predecessorId && eventStore.getModelById(predecessorId);
            if (predecessor) {
                result.push(predecessor);
            }
            return result;
        }, [], flat, function(event) {
            return me.eventDependencyCache.getPredecessors(event);
        });
    },
    // TODO: document
    getEventSuccessors: function(event, flat) {
        var me = this,
            eventStore = me.getEventStore();
        Ext.Assert && Ext.Assert.truthy(eventStore, "Can't get event successors, no event store configured");
        return me.reduceEventDependencies(event, function(result, dependency) {
            var successorId = dependency.getTo(),
                successor = successorId && eventStore.getModelById(successorId);
            if (successor) {
                result.push(successor);
            }
            return result;
        }, [], flat, function(event) {
            return me.eventDependencyCache.getSuccessors(event);
        });
    },
    // TODO: document
    removeEventDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    // TODO: document
    removeEventIncomingDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventIncomingDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    // TODO: document
    removeEventOutgoingDependencies: function(event, flat) {
        var me = this,
            dependencies;
        dependencies = me.getEventOutgoingDependencies(event, flat);
        dependencies.length && me.remove(Ext.Array.unique(dependencies));
    },
    /**
     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
     * task to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Sch.model.Event|String} sourceEvent 1st event
     * @param {Sch.model.Event|String} targetEvent 2nd event
     * @return {Sch.model.Dependency|Null}
     */
    getDependencyForSourceAndTargetEvents: function(sourceEvent, targetEvent) {
        // NOTE: In case this will not work switch to cache get and linear search
        var me = this;
        sourceEvent = sourceEvent && sourceEvent.isModel && sourceEvent.getId() || sourceEvent;
        targetEvent = targetEvent && targetEvent.isModel && targetEvent.getId() || targetEvent;
        return me.bySourceTargetId.get(me.self.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
    },
    /**
     * Returns a dependency model instance linking given events if such dependency exists in the store.
     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
     *
     * @param {Sch.model.Event|String} sourceEvent
     * @param {Sch.model.Event|String} targetEvent
     * @return {Scm.model.Dependency|null}
     */
    getEventsLinkingDependency: function(event1, event2) {
        var me = this;
        return me.getDependencyForSourceAndTargetEvents(event1, event2) || me.getDependencyForSourceAndTargetEvents(event2, event1);
    },
    /**
     * Validation method used to validate a dependency. Override and return `true` to indicate that an
     * existing dependency (or a new dependency being created) between two tasks is valid.
     *
     * @param {Sch.model.Dependency} dependency The dependency model
     * @return {Boolean}
     */
    isValidDependency: function(dependency) {
        var fromId = dependency.getSourceId();
        var toId = dependency.getTargetId();
        return fromId != null && toId != null && fromId !== toId;
    },
    /**
     * Returns all dependencies highlighted with the given CSS class
     *
     * @param {String} cls
     * @return {Sch.model.DependencyBase[]}
     */
    getHighlightedDependencies: function(cls) {
        return Ext.Array.reduce(this.getRange(), function(result, dep) {
            if (dep.isHighlightedWith(cls)) {
                result.push(dep);
            }
            return result;
        }, []);
    },
    inheritableStatics: {
        makeDependencySourceTargetCompositeKey: function() {
            var arr = [];
            return function(sourceId, targetId) {
                arr.length = 0;
                arr.push('source(', sourceId, ')-target(', targetId, ')');
                return arr.join('');
            };
        }()
    }
});

/**
 * This class manages id consistency among model stores, it listens to 'idchanged' event on each store and updates
 * referential fields referencing records with changed ids in other model entities.
 *
 * Note on update process:
 *  at the time when 'idchanged' handler is called we can effectively query stores which are using caches for
 *  a data cached under old id, but we cannot update related models with the new id since at the time of
 *  'idchanged' handler is called a record which id has been updated is still marked as phantom, it's
 *  phantom flag will be reset only at 'update' event time (and 'idchanged' event is always followed by 'update'
 *  event) and it's important we start updating related records after primary records are not phantoms
 *  any more since we might rely on this flag (for example a related store sync operation might be blocked
 *  if primary store records it relies on are still phantom).
 *
 * @private
 */
Ext.define('Sch.data.util.IdConsistencyManager', {
    config: {
        eventStore: null,
        resourceStore: null,
        assignmentStore: null,
        dependencyStore: null
    },
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(config) {
        this.initConfig(config);
    },
    // {{{ Event attachers
    updateEventStore: function(newEventStore, oldEventStore) {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher');
        if (newEventStore) {
            me.eventStoreDetacher = newEventStore.on({
                idchanged: me.onEventIdChanged,
                scope: me,
                destroyable: true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new event id already if this priority is lower then the one used in cache
                priority: 200
            });
        }
    },
    updateResourceStore: function(newResourceStore, oldResourceStore) {
        var me = this;
        Ext.destroyMembers(me, 'resourceStoreDetacher');
        if (newResourceStore) {
            me.resourceStoreDetacher = newResourceStore.on({
                idchanged: me.onResourceIdChanged,
                scope: me,
                destroyable: true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new resource id already if this priority is lower then the one used in cache
                priority: 200
            });
        }
    },
    // }}}
    // {{{ Event handlers
    // Please see the note at the class description
    onEventIdChanged: function(eventStore, event, oldId, newId) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            dependencyStore = me.getDependencyStore(),
            assignmentsUpdater, dependenciesUpdater;
        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentEventIdFieldFn(assignmentStore, oldId, newId);
        }
        if (dependencyStore) {
            dependenciesUpdater = me.getUpdateDependencySourceTargedIdFieldFn(dependencyStore, oldId, newId);
        }
        if (assignmentsUpdater || dependenciesUpdater) {
            eventStore.on('update', function() {
                assignmentsUpdater && assignmentsUpdater();
                dependenciesUpdater && dependenciesUpdater();
            }, null, {
                single: true,
                priority: 200
            });
        }
    },
    // Please see the note at the class description
    onResourceIdChanged: function(resourceStore, resource, oldId, newId) {
        var me = this,
            eventStore = me.getEventStore(),
            assignmentStore = me.getAssignmentStore(),
            eventsUpdater, assignmentsUpdater;
        if (eventStore && !assignmentStore) {
            eventsUpdater = me.getUpdateEventResourceIdFieldFn(eventStore, oldId, newId);
        }
        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentResourceIdFieldFn(assignmentStore, oldId, newId);
        }
        if (eventsUpdater || assignmentStore) {
            resourceStore.on('update', function() {
                eventsUpdater && eventsUpdater();
                assignmentsUpdater && assignmentsUpdater();
            }, null, {
                single: true,
                priority: 200
            });
        }
    },
    // }}}
    // {{{ Update rules
    getUpdateEventResourceIdFieldFn: function(eventStore, oldId, newId) {
        var events = eventStore.getRange();
        return function() {
            Ext.Array.each(events, function(event) {
                event.getResourceId() == oldId && event.setResourceId(newId);
            });
        };
    },
    getUpdateAssignmentEventIdFieldFn: function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForEvent(oldId);
        return function() {
            Ext.Array.each(assignments, function(assignment) {
                assignment.getEventId() == oldId && assignment.setEventId(newId);
            });
        };
    },
    getUpdateAssignmentResourceIdFieldFn: function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForResource(oldId);
        return function() {
            Ext.Array.each(assignments, function(assignment) {
                assignment.getResourceId() == oldId && assignment.setResourceId(newId);
            });
        };
    },
    getUpdateDependencySourceTargedIdFieldFn: function(dependencyStore, oldId, newId) {
        var dependencies = dependencyStore.getEventDependencies(oldId);
        return function() {
            Ext.Array.each(dependencies, function(dependency) {
                dependency.getSourceId() == oldId && dependency.setSourceId(newId);
                dependency.getTargetId() == oldId && dependency.setTargetId(newId);
            });
        };
    }
});
// }}}

/**
 * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable
 * records from sync operation. The logic has meaning only for CRUD-less sync operations.
 *
 * @private
 */
Ext.define('Sch.data.util.ModelPersistencyManager', {
    config: {
        eventStore: null,
        resourceStore: null,
        assignmentStore: null,
        dependencyStore: null
    },
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    assignmentStoreDetacher: null,
    dependencyStoreDetacher: null,
    constructor: function(config) {
        this.initConfig(config);
    },
    // {{{ Event attachers
    updateEventStore: function(newEventStore, oldEventStore) {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher');
        if (newEventStore && newEventStore.autoSync) {
            me.eventStoreDetacher = newEventStore.on({
                beforesync: me.onEventStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateResourceStore: function(newResourceStore, oldResourceStore) {
        var me = this;
        Ext.destroyMembers(me, 'resourceStoreDetacher');
        if (newResourceStore && newResourceStore.autoSync) {
            me.resourceStoreDetacher = newResourceStore.on({
                beforesync: me.onResourceStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateAssignmentStore: function(newAssignmentStore, oldAssignmentStore) {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher');
        if (newAssignmentStore && newAssignmentStore.autoSync) {
            me.assignmentStoreDetacher = newAssignmentStore.on({
                beforesync: me.onAssignmentStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    updateDependencyStore: function(newDependencyStore, oldDependencyStore) {
        var me = this;
        Ext.destroyMembers(me, 'dependencyStoreDetacher');
        if (newDependencyStore && newDependencyStore.autoSync) {
            me.dependencyStoreDetacher = newDependencyStore.on({
                beforesync: me.onDependencyStoreBeforeSync,
                scope: me,
                destroyable: true,
                // Just in case
                priority: 100
            });
        }
    },
    // }}}
    // {{{ Event handlers
    onEventStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onResourceStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onAssignmentStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    onDependencyStoreBeforeSync: function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    // }}}
    // {{{ Management rules
    removeNonPersistableRecordsToCreate: function(options) {
        var recordsToCreate = options.create || [],
            r, i;
        // We remove from the array we iterate thus we iterate from end to start
        for (i = recordsToCreate.length - 1; i >= 0; --i) {
            r = recordsToCreate[i];
            if (!r.isPersistable()) {
                Ext.Array.remove(recordsToCreate, r);
            }
        }
        // Prevent empty create request
        if (recordsToCreate.length === 0) {
            delete options.create;
        }
    },
    shallContinueSync: function(options) {
        return Boolean((options.create && options.create.length > 0) || (options.update && options.update.length > 0) || (options.destroy && options.destroy.length > 0));
    }
});
// }}}

/**
 * Event store's resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceEventsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    eventStore: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(eventStore) {
        var me = this,
            resourceStore = eventStore.getResourceStore();
        me.callParent();
        function onEventAdd(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.add(event.getResourceId(), event);
            });
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.remove(event.getResourceId(), event);
            });
        }
        function onEventUpdate(eventStore, event, operation, modifiedFieldNames) {
            var resourceIdField = event.resourceIdField,
                resourceIdChanged = event.previous && resourceIdField in event.previous,
                previousResourceId = resourceIdChanged && event.previous[resourceIdField];
            if (resourceIdChanged) {
                me.move(previousResourceId, event.getResourceId(), event);
            }
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(eventStore, newResourceStore, oldResourceStore) {
            me.clear();
            attachToResourceStore(newResourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.eventStoreDetacher = eventStore.on({
            add: onEventAdd,
            remove: onEventRemove,
            update: onEventUpdate,
            clear: onEventStoreClearOrReset,
            cacheresethint: onEventStoreClearOrReset,
            rootchange: onEventStoreClearOrReset,
            resourcestorechange: onEventStoreResourceStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.eventStoreFiltersDetacher = eventStore.getFilters().on('endupdate', onEventStoreClearOrReset, this, {
            // priority is calculated as:
            // Ext.util.Collection.$endUpdatePriority + 1
            // to reset our cache before ExtJS "on filter end update" listeners run
            priority: 1002,
            destroyable: true
        });
        attachToResourceStore(resourceStore);
        me.eventStore = eventStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'eventStoreDetacher', 'eventStoreFiltersDetacher', 'resourceStoreDetacher');
        me.eventStore = null;
    },
    get: function(k, fn) {
        var me = this;
        k = me.key(k);
        fn = fn || function() {
            return Ext.Array.filter(me.eventStore.getRange(), function(event) {
                return event.getResourceId() == k;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/**
 * This is a mixin, containing functionality related to managing events.
 *
 * It is consumed by the regular {@link Sch.data.EventStore} class and {@link Gnt.data.TaskStore} class
 * to allow data sharing between gantt chart and scheduler. Please note though, that datasharing is still
 * an experimental feature and not all methods of this mixin can be used yet on a TaskStore.
 *
 */
Ext.define("Sch.data.mixin.EventStore", {
    extend: 'Ext.Mixin',
    requires: [
        'Sch.util.Date',
        'Sch.data.util.IdConsistencyManager',
        'Sch.data.util.ModelPersistencyManager',
        'Sch.data.util.ResourceEventsCache'
    ],
    /**
     * Identifies an object as an instantiated event store, or subclass thereof.
     * @type {Boolean}
     */
    isEventStore: true,
    /**
     * @cfg {Sch.data.AssignmentStore} assignmentStore Provide assignment store to enable multiple connections between
     * events and resources
     */
    assignmentStore: null,
    resourceStore: null,
    resourceEventsCache: null,
    idConsistencyManager: null,
    modelPersistencyManager: null,
    mixinConfig: {
        after: {
            constructor: 'constructor',
            destroy: 'destroy'
        }
    },
    /**
     * @constructor
     */
    constructor: function() {
        var me = this;
        me.resourceEventsCache = me.createResourceEventsCache();
        me.idConsistencyManager = me.createIdConsistencyManager();
        me.modelPersistencyManager = me.createModelPersistencyManager();
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'resourceEventsCache', 'idConsistencyManager', 'modelPersistencyManager');
    },
    /**
     * Creates and returns Resource->Events cache.
     *
     * @return {Sch.data.util.ResourceEventsCache}
     * @template
     * @protected
     */
    createResourceEventsCache: function() {
        return new Sch.data.util.ResourceEventsCache(this);
    },
    /**
     * Creates and returns id consistency manager
     *
     * @return {Sch.data.util.IdConsistencyManager}
     * @tempalte
     * @protected
     */
    createIdConsistencyManager: function() {
        var me = this;
        return new Sch.data.util.IdConsistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    /**
     * Creates and returns model persistency manager
     *
     * @return {Sch.data.util.ModelPersistencyManager}
     * @tempalte
     * @protected
     */
    createModelPersistencyManager: function() {
        var me = this;
        return new Sch.data.util.ModelPersistencyManager({
            eventStore: me,
            resourceStore: me.getResourceStore(),
            assignmentStore: me.getAssignmentStore(),
            dependencyStore: me.getDependencyStore()
        });
    },
    /**
     * Gets the resource store for this store
     *
     * @return {Sch.data.ResourceStore} resourceStore
     */
    getResourceStore: function() {
        return this.resourceStore;
    },
    /**
     * Sets the resource store for this store
     *
     * @param {Sch.data.ResourceStore} resourceStore
     */
    setResourceStore: function(resourceStore) {
        var me = this,
            oldStore = me.resourceStore;
        if (me.resourceStore) {
            me.resourceStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
        }
        me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;
        if (me.resourceStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
            resourceStore.setEventStore(me);
        }
        if ((oldStore || resourceStore) && oldStore !== resourceStore) {
            /**
             * @event resourcestorechange
             * Fires when new resource store is set via {@link #setResourceStore} method.
             * @param {Sch.data.EventStore}         this
             * @param {Sch.data.ResourceStore|null} newResourceStore
             * @param {Sch.data.ResourceStore|null} oldResourceStore
             */
            me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
        }
    },
    /**
     * Returns assignment store this event store is using by default.
     *
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        return this.assignmentStore;
    },
    /**
     * Sets assignment store instance this event store will be using by default.
     *
     * @param {Sch.data.AssignmentStore} store
     */
    setAssignmentStore: function(assignmentStore) {
        var me = this,
            oldStore = me.assignmentStore;
        if (me.assignmentStore) {
            me.assignmentStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
        }
        me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;
        if (me.assignmentStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
            me.assignmentStore.setEventStore(me);
            // If assignment store's set then caching now will be done by it
            // and event store doesn't need to maintain it's own resource-to-events cache.
            Ext.destroy(me.resourceEventsCache);
        } else {
            // If assignment store's reset then caching now should be done by
            // event store again.
            me.resourceEventsCache = me.createResourceEventsCache();
        }
        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * @event assignmentstorechange
             * Fires when new assignment store is set via {@link #setAssignmentStore} method.
             * @param {Sch.data.EventStore}           this
             * @param {Sch.data.AssignmentStore|null} newAssignmentStore
             * @param {Sch.data.AssignmentStore|null} oldAssignmentStore
             */
            me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
        }
    },
    /**
     * Returns a dependecy store instance this event store is associated with. See also {@link #setDependencyStore}.
     *
     * @return {Sch.data.DependencyStore}
     */
    getDependencyStore: function() {
        return this.dependencyStore;
    },
    /**
     * Sets the dependency store for this event store
     *
     * @param {Sch.data.DependencyStore} dependencyStore
     */
    setDependencyStore: function(dependencyStore) {
        var me = this,
            oldStore = me.DependencyStore;
        if (me.dependencyStore) {
            me.dependencyStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(null);
        }
        me.dependencyStore = dependencyStore && Ext.StoreMgr.lookup(dependencyStore) || null;
        if (me.dependencyStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setDependencyStore(me.dependencyStore);
            me.idConsistencyManager && me.idConsistencyManager.setDependencyStore(me.dependencyStore);
            me.dependencyStore.setEventStore(me);
        }
        if ((oldStore || dependencyStore) && oldStore !== dependencyStore) {
            /**
             * @event dependencystorechange
             * Fires when new dependency store is set via {@link #setDependencyStore} method.
             * @param {Sch.data.EventStore}           this
             * @param {Sch.data.DependencyStore|null} newDependencyStore
             * @param {Sch.data.DependencyStore|null} oldDependencyStore
             */
            me.fireEvent('dependencystorechange', me, dependencyStore, oldStore);
        }
    },
    /**
     * Checks if a date range is allocated or not for a given resource.
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {[Sch.model.Event/Sch.model.Assignment]} excludeEvent An event (or assignment) to exclude from the check (or null)
     * @param {Sch.model.Resource} resource The resource
     * @return {Boolean} True if the timespan is available for the resource
     */
    isDateRangeAvailable: function(start, end, excludeEvent, resource) {
        var DATE = Sch.util.Date,
            events = resource ? this.getEventsForResource(resource) : this.getRange(),
            available = true;
        if (Sch.model.Assignment && excludeEvent instanceof Sch.model.Assignment) {
            excludeEvent = excludeEvent.getEvent(this);
        }
        // This can be optimized further if we use simple for() statement (will lead to -1 function call in the loop)
        Ext.each(events, function(ev) {
            available = excludeEvent === ev || !DATE.intersectSpans(start, end, ev.getStartDate(), ev.getEndDate());
            return available;
        });
        // to immediately stop looping if interval is occupied by a non excluding event
        return available;
    },
    /**
     * Returns events between the supplied start and end date
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Boolean} allowPartial false to only include events that start and end inside of the span
     * @return {Ext.util.MixedCollection} the events
     */
    getEventsInTimeSpan: function(start, end, allowPartial) {
        var coll = new Ext.util.MixedCollection();
        var events = [];
        if (allowPartial !== false) {
            var DATE = Sch.util.Date;
            this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
                if (DATE.intersectSpans(eventStart, eventEnd, start, end)) {
                    events.push(event);
                }
            });
        } else {
            this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
                if (eventStart - start >= 0 && end - eventEnd >= 0) {
                    events.push(event);
                }
            });
        }
        coll.addAll(events);
        return coll;
    },
    getEventsByStartDate: function(start) {
        var DATE = Sch.util.Date;
        var events = [];
        this.forEachScheduledEvent(function(event, eventStart, eventEnd) {
            if (DATE.compareWithPrecision(eventStart, start, DATE.DAY) === 0) {
                events.push(event);
            }
        });
        return events;
    },
    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     *      - event : the event record
     *      - startDate : the event start date
     *      - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} scope scope for the function
     */
    forEachScheduledEvent: function(fn, scope) {
        this.each(function(event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();
            if (eventStart && eventEnd) {
                return fn.call(scope || this, event, eventStart, eventEnd);
            }
        }, this);
    },
    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     */
    getTotalTimeSpan: function() {
        var earliest = Sch.util.Date.MAX_VALUE,
            latest = Sch.util.Date.MIN_VALUE,
            D = Sch.util.Date;
        this.each(function(r) {
            if (r.getStartDate()) {
                earliest = D.min(r.getStartDate(), earliest);
            }
            if (r.getEndDate()) {
                latest = D.max(r.getEndDate(), latest);
            }
        });
        earliest = earliest < Sch.util.Date.MAX_VALUE ? earliest : null;
        latest = latest > Sch.util.Date.MIN_VALUE ? latest : null;
        // keep last calculated value to be able to track total timespan changes
        this.lastTotalTimeSpan = {
            start: earliest || null,
            end: latest || earliest || null
        };
        return this.lastTotalTimeSpan;
    },
    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @private {Sch.model.Resource} resource
     * @param {Sch.model.Resource} resource
     * @param {Function} fn The function
     * @param {Object} [scope] The 'this object' for the function
     * @return {Sch.model.Event[]} the events in the time span
     */
    filterEventsForResource: function(resource, fn, scope) {
        // `getEvents` method of the resource will use either `indexByResource` or perform a full scan of the event store
        var events = resource.getEvents(this);
        return Ext.Array.filter(events, fn, scope || this);
    },
    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    append: function(record) {
        throw 'Must be implemented by consuming class';
    },
    // {{{ Entire data model management methods
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Event/Mixed} event
     * @return {Sch.model.Resource[]}
     */
    getResourcesForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore = me.getResourceStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.getResourcesForEvent(event);
        } else if (resourceStore) {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            result = event && resourceStore.getModelById(event.getResourceId());
            result = result && [
                result
            ] || [];
        } else {
            result = [];
        }
        return result;
    },
    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Event[]}
     */
    getEventsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.getEventsForResource(resource);
        }
        // Resource->Events cache is not always accessible, a subclass might override createResourceEventsCache() method
        // returning null
        else if (me.resourceEventsCache) {
            result = me.resourceEventsCache.get(resource);
        } else {
            result = [];
        }
        return result;
    },
    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Event/Mixed} event
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForEvent(event) || [];
    },
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource/Mixed} resource
     * @return {Sch.model.Assignment[]}
     */
    getAssignmentsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        return assignmentStore && assignmentStore.getAssignmentsForResource(resource) || [];
    },
    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resource/Mixed/Sch.model.Resource[]/Mixed[]} resource The resource(s) to assign to the event
     */
    assignEventToResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.assignEventToResource(event, resource);
        } else {
            if (Ext.isArray(resource))  {
                resource = resource[0];
            }
            
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            event && event.setResourceId(resource);
        }
    },
    // This will update resource events cache via 'update' event.
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resource/Mixed} resource
     */
    unassignEventFromResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.unassignEventFromResource(event, resource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            if (event && (typeof resource == 'undefined' || event.getResourceId() == resource)) {
                event.setResourceId(null);
            }
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Sch.model.Event}    event    An event or id of the event to reassign
     * @param {Sch.model.Resource/Sch.model.Resource[]} oldResource A resource or id to unassign from
     * @param {Sch.model.Resource/Sch.model.Resource[]} newResource A resource or id to assign to
     */
    reassignEventFromResourceToResource: function(event, oldResource, newResource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        var newResourceId = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource;
        // resource id might be 0 thus we use ? operator
        var oldResourceId = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource;
        // resource id might be 0 thus we use ? operator
        if (assignmentStore) {
            var assignment = assignmentStore.getAssignmentForEventAndResource(event, oldResource);
            if (assignment) {
                assignment.setResourceId(newResourceId);
            } else {
                assignmentStore.assignEventToResource(event, newResource);
            }
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            if (event.getResourceId() == oldResourceId) {
                event.setResourceId(newResourceId);
            }
        }
    },
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Event/Mixed} event
     * @param {Sch.model.Resouce/Mixed} resource
     * @return {Boolean}
     */
    isEventAssignedToResource: function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            result;
        if (assignmentStore) {
            result = assignmentStore.isEventAssignedToResource(event, resource);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            result = event && (event.getResourceId() == resource) || false;
        }
        return result;
    },
    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Event/Mixed} event
     */
    removeAssignmentsForEvent: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();
        if (assignmentStore) {
            assignmentStore.removeAssignmentsForEvent(event);
        } else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            event && event.setResourceId(null);
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource/Mixed} resource
     */
    removeAssignmentsForResource: function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore = me.getResourceStore();
        if (assignmentStore) {
            assignmentStore.removeAssignmentsForResource(resource);
        } else if (resourceStore) {
            resource = resource instanceof Sch.model.Resource && resource || resourceStore.getModelById(resource);
            resource && Ext.Array.each(me.resourceEventsCache.get(resource), function(event) {
                event.setResourceId(null);
            });
        } else // This will update resource events cache via 'update' event
        {
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource;
            // resource id might be 0 thus we use ? operator
            Ext.Array.each(me.getRange(), function(event) {
                event.getResourceId() == resource && event.setResourceId(null);
            });
        }
    },
    // This will update resource events cache via 'update' event
    /**
     * Checks if given event record is persistable.
     * In case assignment store is used to assign events to resources and vise versa event is considered to be always
     * persistable. Otherwise backward compatible logic is used, i.e. event is considered to be persistable when
     * resources it's assigned to are not phantom.
     *
     * @param {Sch.model.Range} event
     * @return {Boolean}
     */
    isEventPersistable: function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resources, i, len,
            result = true;
        if (!assignmentStore) {
            resources = event.getResources();
            for (i = 0 , len = resources.length; result && i < len; ++i) {
                result = resources[i].phantom !== true;
            }
        }
        return result;
    }
});

/**
 * This class represents an event recurrence settings.
 */
Ext.define('Sch.model.Recurrence', {
    extend: 'Sch.model.Customizable',
    idProperty: 'Id',
    isRecurrenceModel: true,
    customizableFields: [
        /**
         * @field Id
         * Unique identifier of the recurrence.
         */
        /**
         * @field
         * Field defines the recurrence frequency. Supported values are: "DAILY", "WEEKLY", "MONTHLY", "YEARLY".
         */
        {
            name: 'Frequency',
            defaultValue: "DAILY"
        },
        /**
         * @field
         * Field defines how often the recurrence repeats.
         * For example, if the recurrence is weekly its interval is 2, then the event repeats every two weeks.
         */
        {
            name: 'Interval',
            type: 'int',
            defaultValue: 1
        },
        /**
         * @field
         * End date of the recurrence in ISO 8601 format (see {@link Ext.Date} available formats). Specifies when the recurrence ends.
         * The value is optional, the recurrence can as well be stopped using {@link #Count} field value.
         */
        {
            name: 'EndDate',
            type: 'date'
        },
        /**
         * @field
         * Specifies the number of occurrences after which the recurrence ends.
         * The value includes the associated event itself so values less than 2 make no sense.
         * The field is optional, the recurrence as well can be stopped using {@link #EndDate} field value.
         */
        {
            name: 'Count',
            type: 'int',
            allowNull: true
        },
        /**
         * @field
         * @type {String[]}
         * Specifies days of the week on which the event should occur.
         * An array of string values "SU", "MO", "TU", "WE", "TH", "FR", "SA"
         * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.
         * Each value can also be preceded by a positive (+n) or negative (-n) integer.
         * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.
         *
         * **Not applicable** for daily {@link #Frequency frequency}.
         */
        {
            name: 'Days',
            convert: function(value, record) {
                if (value) {
                    if (Ext.isString(value)) {
                        value = value.split(',');
                    }
                } else {
                    value = null;
                }
                return value;
            },
            isEqual: function(value1, value2) {
                return String(value1) === String(value2);
            }
        },
        /**
         * @field
         * @type {Integer[]}
         * Specifies days of the month on which the event should occur.
         * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).
         * **Applicable only** for monthly {@link #Frequency frequency}.
         */
        {
            name: 'MonthDays',
            convert: function(value, record) {
                if (value) {
                    if (Ext.isString(value)) {
                        value = Ext.Array.map(value.split(','), function(item) {
                            return parseInt(item, 10);
                        });
                    }
                } else {
                    value = null;
                }
                return value;
            },
            isEqual: function(value1, value2) {
                return String(value1) === String(value2);
            }
        },
        /**
         * @field
         * @type {Integer[]}
         * Specifies months of the year on which the event should occur.
         * An array of integer values (1 - 12).
         * **Applicable only** for yearly {@link #Frequency frequency}.
         */
        {
            name: 'Months',
            convert: function(value, record) {
                if (value) {
                    if (Ext.isString(value)) {
                        value = Ext.Array.map(value.split(','), function(item) {
                            return parseInt(item, 10);
                        });
                    }
                } else {
                    value = null;
                }
                return value;
            },
            isEqual: function(value1, value2) {
                return String(value1) === String(value2);
            }
        },
        /**
         * @field
         * @type {Integer}
         * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.
         * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).
         * **Not applicable** for daily {@link #Frequency frequency}.
         */
        {
            name: 'Positions',
            convert: function(value, record) {
                if (value) {
                    if (Ext.isString(value)) {
                        value = Ext.Array.map(value.split(','), function(item) {
                            return parseInt(item, 10);
                        });
                    }
                } else {
                    value = null;
                }
                return value;
            },
            isEqual: function(value1, value2) {
                return String(value1) === String(value2);
            }
        }
    ],
    /**
     * @cfg {String} frequencyField The name of the {@link #Frequency} field.
     */
    frequencyField: 'Frequency',
    /**
     * @cfg {String} intervalField The name of the {@link #Interval} field.
     */
    intervalField: 'Interval',
    /**
     * @cfg {String} endDateField The name of the {@link #EndDate} field.
     */
    endDateField: 'EndDate',
    /**
     * @cfg {String} countField The name of the {@link #Count} field.
     */
    countField: 'Count',
    /**
     * @cfg {String} daysField The name of the {@link #Weekdays} field.
     */
    daysField: 'Days',
    /**
     * @cfg {String} monthDaysField The name of the {@link #MonthDays} field.
     */
    monthDaysField: 'MonthDays',
    /**
     * @cfg {String} monthsField The name of the {@link #Months Months} field.
     */
    monthsField: 'Months',
    /**
     * @cfg {String} positionsField The name of the {@link #Positions} field.
     */
    positionsField: 'Positions',
    inheritableStatics: {
        /**
         * @static
         * Constant for daily {@link #Frequency frequency}.
         */
        DAILY: "DAILY",
        /**
         * @static
         * Constant for weekly {@link #Frequency frequency}.
         */
        WEEKLY: "WEEKLY",
        /**
         * @static
         * Constant for monthly {@link #Frequency frequency}.
         */
        MONTHLY: "MONTHLY",
        /**
         * @static
         * Constant for yearly {@link #Frequency frequency}.
         */
        YEARLY: "YEARLY"
    },
    dateFormat: 'Ymd\\THis\\Z',
    /**
     * @cfg {Sch.model.Event}
     * The event this recurrence is associated with.
     */
    event: null,
    /**
     * @cfg {String}
     * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
     */
    rule: null,
    suspendedEventNotifying: 0,
    constructor: function(cfg) {
        cfg = cfg || {};
        var rule, event;
        if (cfg.event) {
            event = cfg.event;
            delete cfg.event;
        }
        if (cfg.rule) {
            rule = cfg.rule;
            delete cfg.rule;
        }
        this.callParent(arguments);
        this.suspendEventNotifying();
        if (rule) {
            this.setRule(rule);
        }
        this.resumeEventNotifying();
        this.event = event;
    },
    sanitize: function() {
        var me = this,
            frequency = me.getFrequency(),
            event = me.getEvent(),
            eventStartDate = event && event.getStartDate();
        me.sanitizing = true;
        switch (frequency) {
            case 'DAILY':
                me.setPositions(null);
                me.setDays(null);
                me.setMonthDays(null);
                me.setMonths(null);
                break;
            case 'WEEKLY':
                me.setPositions(null);
                me.setMonthDays(null);
                me.setMonths(null);
                var days = me.getDays(),
                    encodeDay = Sch.data.util.recurrence.DayRuleEncoder.encodeDay;
                if (eventStartDate && days && days.length == 1 && days[0] == encodeDay(eventStartDate.getDay())) {
                    me.setDays(null);
                };
                break;
            case 'MONTHLY':
                if (me.getMonthDays() && me.getMonthDays().length) {
                    me.setPositions(null);
                    me.setDays(null);
                };
                me.setMonths(null);
                var monthDays = me.getMonthDays();
                if (eventStartDate && monthDays && monthDays.length == 1 && monthDays[0] == eventStartDate.getDate()) {
                    me.setMonthDays(null);
                };
                break;
            case 'YEARLY':
                me.setMonthDays(null);
                var months = me.getMonths();
                if (eventStartDate && months && months.length == 1 && months[0] == eventStartDate.getMonth() + 1) {
                    me.setMonths(null);
                };
                break;
        }
        me.sanitizing = false;
    },
    copy: function() {
        var result = this.callParent(arguments);
        result.dateFormat = this.dateFormat;
        result.event = this.event;
        return result;
    },
    set: function(field, value) {
        this.callParent(arguments);
        // TODO: handle beginEdit/endEdit to call this block only once
        if (!this.sanitizing) {
            // cleanup data to match the chosen frequency
            this.sanitize();
        }
        var event = this.getEvent();
        if (event && !this.suspendedEventNotifying) {
            event.onRecurrenceChanged();
        }
    },
    suspendEventNotifying: function() {
        this.suspendedEventNotifying++;
    },
    resumeEventNotifying: function() {
        if (this.suspendedEventNotifying)  {
            this.suspendedEventNotifying--;
        }
        
    },
    /**
     * Returns the event associated with this recurrence.
     * @return {Sch.model.Event} Event instance.
     */
    getEvent: function() {
        return this.event;
    },
    /**
     * Sets the event associated with this recurrence.
     * @param {Sch.model.Event} Event instance.
     */
    setEvent: function(event) {
        return this.event = event;
    },
    /**
     * Returns the recurrence rule - a string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
     * @return {String} The recurrence rule.
     */
    getRule: function() {
        var me = this,
            result = [];
        if (me.getFrequency()) {
            result.push('FREQ=' + me.getFrequency());
            if (me.getInterval() > 1) {
                result.push('INTERVAL=' + me.getInterval());
            }
            if (me.getDays() && me.getDays().length) {
                result.push('BYDAY=' + me.getDays().join(','));
            }
            if (me.getMonthDays() && me.getMonthDays().length) {
                result.push('BYMONTHDAY=' + me.getMonthDays().join(','));
            }
            if (me.getMonths() && me.getMonths().length) {
                result.push('BYMONTH=' + me.getMonths().join(','));
            }
            if (me.getCount()) {
                result.push('COUNT=' + me.getCount());
            }
            if (me.getEndDate()) {
                result.push('UNTIL=' + Ext.Date.format(me.getEndDate(), me.dateFormat));
            }
            if (me.getPositions() && me.getPositions().length) {
                result.push('BYSETPOS=' + me.getPositions().join(','));
            }
        }
        return result.join(';');
    },
    /**
     * Sets the recurrence rule - a string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
     * @param {String} The recurrence rule.
     */
    setRule: function(rule) {
        var me = this;
        if (rule) {
            me.beginEdit();
            var parts = rule.split(';');
            for (var i = 0,
                len = parts.length; i < len; i++) {
                var part = parts[i].split('='),
                    value = part[1];
                switch (part[0]) {
                    case 'FREQ':
                        me.setFrequency(value);
                        break;
                    case 'INTERVAL':
                        me.setInterval(value);
                        break;
                    case 'COUNT':
                        me.setCount(value);
                        break;
                    case 'UNTIL':
                        me.setEndDate(Ext.Date.parse(value, me.dateFormat));
                        break;
                    case 'BYDAY':
                        me.setDays(value);
                        break;
                    case 'BYMONTHDAY':
                        me.setMonthDays(value);
                        break;
                    case 'BYMONTH':
                        me.setMonths(value);
                        break;
                    case 'BYSETPOS':
                        me.setPositions(value);
                        break;
                }
            }
            me.endEdit();
        }
    }
});

Ext.define('Sch.data.util.DelayedCalls', {
    singleton: true,
    mixins: [
        'Ext.util.Observable'
    ],
    delayedCallTimeout: 100,
    delayedCalls: null,
    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        Ext.apply(this, config);
    },
    cancel: function() {
        var me = this,
            delayedCalls = me.delayedCalls;
        if (delayedCalls) {
            var ids = arguments.length ? arguments : Ext.Oject.getKeys(delayedCalls);
            for (var i = ids.length - 1; i >= 0; i--) {
                var id = ids[i];
                if (delayedCalls[id] && delayedCalls[id].timer) {
                    clearTimeout(delayedCalls[id].timer);
                    delayedCalls[id].timer = null;
                }
            }
        }
    },
    execute: function(delayedCalls) {
        var scope = delayedCalls.scope,
            args;
        this.fireEvent('delayed-' + delayedCalls.id + '-start', this, delayedCalls);
        delayedCalls.beforeFn && delayedCalls.beforeFn.call(scope, delayedCalls);
        var fn = delayedCalls.fn;
        while ((args = delayedCalls.entries.shift())) {
            fn.apply(scope, args);
        }
        delayedCalls.afterFn && delayedCalls.afterFn.call(scope, delayedCalls);
        this.fireEvent('delayed-' + delayedCalls.id + '-end', this, delayedCalls);
    },
    schedule: function(config) {
        config = config || {};
        var me = this;
        me.delayedCalls = me.delayedCalls || {};
        var id = config.id || me.schedule.caller.$name;
        var args = config.args || [];
        // get this specific group of delayed calls
        if (!me.delayedCalls[id]) {
            me.delayedCalls[id] = Ext.apply({
                scope: this
            }, {
                id: id,
                entries: []
            }, config);
            delete me.delayedCalls[id].args;
        }
        var delayedCalls = me.delayedCalls[id];
        // reset previously set timer (if set)
        me.cancel(id);
        delayedCalls.entries.push(args);
        // Setup timer to delay the call
        delayedCalls.timer = setTimeout(function() {
            me.execute(delayedCalls);
            delete me.delayedCalls[id];
        }, config.timeout || me.delayedCallTimeout);
        return delayedCalls;
    }
});

Ext.define('Sch.data.util.recurrence.AbstractIterator', {
    frequency: 'NONE',
    MAX_OCCURRENCES_COUNT: 1000000,
    /**
     * @private
     * Returns Nth occurrence of a week day in the provided period of time.
     * @param  {Date} startDate Period start date.
     * @param  {Date} endDate   Period end date.
     * @param  {Integer} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
     * @param  {Integer} index  Index to find.
     * @return {Date}           Returns the found date or null if there is no `index`th entry.
     */
    getNthDayInPeriod: function(startDate, endDate, day, index) {
        var result, sign, delta, borderDate;
        if (index) {
            var dayDurationInMs = 86400000,
                weekDurationInMs = 604800000;
            if (index > 0) {
                sign = 1;
                borderDate = startDate;
            } else {
                sign = -1;
                borderDate = endDate;
            }
            // delta between requested day and border day
            delta = day - borderDate.getDay();
            // if the requested day goes after (before, depending on borderDate used (start/end))
            // we adjust index +/-1
            if (sign * delta < 0)  {
                index += sign;
            }
            
            // measure "index" weeks forward (or backward) ..take delta into account
            result = new Date(borderDate.getTime() + (index - sign) * weekDurationInMs + delta * dayDurationInMs);
            // if resulting date is outside of the provided range there is no "index"-th entry
            // of the day
            if (result < startDate || result > endDate)  {
                result = null;
            }
            
        }
        return result;
    },
    buildDate: function(year, month, date) {
        var dt = new Date(year, month, date);
        if (dt.getFullYear() == year && dt.getMonth() == month && dt.getDate() == date) {
            return dt;
        }
    },
    isValidPosition: function(position) {
        return Boolean(position);
    },
    forEachDateAtPositions: function(dates, positions, fn, scope) {
        var datesLength = dates.length,
            processed = {};
        for (var i = 0; i < positions.length; i++) {
            var index = positions[i];
            if (this.isValidPosition(index)) {
                var date = index > 0 ? dates[index - 1] : dates[datesLength + index];
                if (date && !processed[date.getTime()]) {
                    // remember that we've returned the date
                    processed[date.getTime()] = true;
                    // return false if it's time to stop recurring
                    if (fn.call(scope, date) === false)  {
                        return false;
                    }
                    
                }
            }
        }
    }
});

Ext.define('Sch.data.util.recurrence.DailyIterator', {
    extend: 'Sch.data.util.recurrence.AbstractIterator',
    requires: [
        'Sch.util.Date'
    ],
    singleton: true,
    frequency: 'DAILY',
    forEachDate: function(config) {
        var me = this,
            recurrence = config.recurrence,
            event = recurrence.getEvent(),
            eventStart = event.getStartDate(),
            startDate = config.startDate || eventStart,
            until = recurrence.getEndDate(),
            endDate = config.endDate || until,
            fn = config.fn,
            scope = config.scope || me,
            D = Sch.util.Date,
            interval = recurrence.getInterval(),
            count = recurrence.getCount(),
            counter = 0;
        if (until && endDate && endDate > until)  {
            endDate = until;
        }
        
        // iteration should not start before the event starts
        if (eventStart > startDate)  {
            startDate = eventStart;
        }
        
        var delay = startDate - eventStart,
            // recurrence interval duration in ms (86400000 is a single day duration in ms)
            intervalDuration = interval * 86400000,
            delayInIntervals = Math.floor(delay / intervalDuration);
        // TODO: need to make a constant
        if (!endDate && !count)  {
            count = me.MAX_OCCURRENCES_COUNT;
        }
        
        var date = D.add(eventStart, D.DAY, delayInIntervals);
        while (!endDate || date <= endDate) {
            counter++;
            if (date >= startDate) {
                if ((endDate && date > endDate) || fn.call(scope, date, counter) === false || (count && counter >= count))  {
                    break;
                }
                
            }
            // shift to the next day
            date = D.add(date, D.DAY, interval);
        }
    }
});

Ext.define('Sch.data.util.recurrence.DayRuleEncoder', {
    singleton: true,
    dayParseRegExp: /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/,
    decodeDay: function(rawDay) {
        var parsedDay, result;
        if ((parsedDay = this.dayParseRegExp.exec(rawDay))) {
            result = [];
            // parse day name
            switch (parsedDay[2]) {
                case "SU":
                    result.push(0);
                    break;
                case "MO":
                    result.push(1);
                    break;
                case "TU":
                    result.push(2);
                    break;
                case "WE":
                    result.push(3);
                    break;
                case "TH":
                    result.push(4);
                    break;
                case "FR":
                    result.push(5);
                    break;
                case "SA":
                    result.push(6);
                    break;
            }
            // optional position number
            if (result) {
                if (parsedDay[1])  {
                    parsedDay[1] = parseInt(parsedDay[1], 10);
                }
                
                result.push(parsedDay[1]);
            }
        }
        return result;
    },
    encodeDay: function(day) {
        var position;
        // support decodeDay() result format
        if (Ext.isArray(day)) {
            day = day[0];
            position = day[1];
        }
        var result = position ? position.toString() : '';
        switch (day) {
            case 0:
                result += "SU";
                break;
            case 1:
                result += "MO";
                break;
            case 2:
                result += "TU";
                break;
            case 3:
                result += "WE";
                break;
            case 4:
                result += "TH";
                break;
            case 5:
                result += "FR";
                break;
            case 6:
                result += "SA";
                break;
        }
        return result;
    },
    // Turns days values provided as an array of strings (like ["-1MO", "SU", "+3FR"])
    // into an array of [ dayIndex, position ] elements, where:
    //
    // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
    // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))
    decode: function(rawDays) {
        var result = [],
            parsedDay;
        if (rawDays) {
            for (var i = 0; i < rawDays.length; i++) {
                if ((parsedDay = this.decodeDay(rawDays[i]))) {
                    result.push(parsedDay);
                }
            }
        }
        return result;
    },
    encode: function(days) {
        var result = [],
            day;
        if (days) {
            for (var i = 0; i < days.length; i++) {
                if ((day = this.encodeDay(days[i]))) {
                    result.push(day);
                }
            }
        }
        return result;
    }
});

Ext.define('Sch.data.util.recurrence.WeeklyIterator', {
    extend: 'Sch.data.util.recurrence.AbstractIterator',
    requires: [
        'Sch.util.Date',
        'Sch.data.util.recurrence.DayRuleEncoder'
    ],
    singleton: true,
    frequency: 'WEEKLY',
    forEachDate: function(config) {
        var me = this,
            D = Sch.util.Date,
            fn = config.fn,
            scope = config.scope || me,
            recurrence = config.recurrence,
            event = config.event || recurrence && recurrence.getEvent(),
            eventStart = config.eventStartDate || event.getStartDate(),
            startDate = config.startDate || eventStart,
            until = recurrence && recurrence.getEndDate(),
            endDate = config.endDate || until,
            interval = config.interval || recurrence.getInterval(),
            weekDays = Sch.data.util.recurrence.DayRuleEncoder.decode(config.days || recurrence && recurrence.getDays()),
            count = config.count || recurrence && recurrence.getCount(),
            counter = 0,
            weekStartDate, date;
        if (until && endDate && endDate > until)  {
            endDate = until;
        }
        
        // days could be provided in any order so it's important to sort them
        if (weekDays && weekDays.length) {
            weekDays.sort(function(a, b) {
                return a[0] - b[0];
            });
        } else // "Days" might be skipped then we use the event start day
        {
            weekDays = [
                [
                    eventStart.getDay()
                ]
            ];
        }
        // iteration should not start before the event starts
        if (eventStart > startDate) {
            startDate = eventStart;
        }
        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        if (count) {
            weekStartDate = D.getNext(eventStart, D.WEEK, 0, 0);
        } else {
            weekStartDate = D.getNext(startDate, D.WEEK, 0, 0);
        }
        if (!endDate && !count)  {
            count = me.MAX_OCCURRENCES_COUNT;
        }
        
        while (!endDate || weekStartDate <= endDate) {
            for (var i = 0; i < weekDays.length; i++) {
                date = D.copyTimeValues(D.add(weekStartDate, D.DAY, weekDays[i][0]), eventStart);
                if (date >= eventStart) {
                    counter++;
                    if (date >= startDate) {
                        if ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))  {
                            return;
                        }
                        
                    }
                }
            }
            // get next week start
            weekStartDate = D.getNext(weekStartDate, D.WEEK, interval, 0);
        }
    }
});

Ext.define('Sch.data.util.recurrence.MonthlyIterator', {
    extend: 'Sch.data.util.recurrence.AbstractIterator',
    requires: [
        'Sch.util.Date',
        'Sch.data.util.recurrence.DayRuleEncoder'
    ],
    singleton: true,
    frequency: 'MONTHLY',
    getNthDayOfMonth: function(date, dayNum) {
        var result = null,
            daysInMonth = Ext.Date.getDaysInMonth(date);
        if (dayNum && Math.abs(dayNum) <= daysInMonth) {
            result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
        }
        return result;
    },
    isValidPosition: function(position) {
        return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
    },
    forEachDate: function(config) {
        var me = this,
            D = Sch.util.Date,
            fn = config.fn,
            scope = config.scope || me,
            recurrence = config.recurrence,
            event = config.event || recurrence.getEvent(),
            eventStart = config.eventStartDate || event.getStartDate(),
            startDate = config.startDate || eventStart,
            until = recurrence && recurrence.getEndDate(),
            endDate = config.endDate || until,
            interval = config.interval || recurrence.getInterval(),
            rawDays = config.days || recurrence && recurrence.getDays(),
            weekDays = Sch.data.util.recurrence.DayRuleEncoder.decode(rawDays),
            monthDays = config.monthDays || recurrence && recurrence.getMonthDays(),
            count = config.count || recurrence && recurrence.getCount(),
            positions = config.positions || recurrence && recurrence.getPositions(),
            hasPositions = positions && positions.length,
            counter = 0,
            processedDate = {},
            weekDayPosition, monthStartDate, monthEndDate, dates, date, i;
        if (until && endDate && endDate > until)  {
            endDate = until;
        }
        
        // iteration should not start before the event starts
        if (eventStart > startDate)  {
            startDate = eventStart;
        }
        
        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        if (count) {
            monthStartDate = new Date(D.getNext(eventStart, D.MONTH, 0));
        } else {
            monthStartDate = new Date(D.getNext(startDate, D.MONTH, 0));
        }
        monthEndDate = new Date(D.getNext(monthStartDate, D.MONTH, 1) - 1);
        // if no month days nor week days are provided let's use event start date month day
        if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
            monthDays = [
                eventStart.getDate()
            ];
        }
        if (weekDays && weekDays.length) {
            // Collect hash of positions indexed by week days
            Ext.each(weekDays, function(day) {
                if (day[1]) {
                    weekDayPosition = weekDayPosition || {};
                    weekDayPosition[day[0]] = day[1];
                }
            });
        }
        // label to break nested loops
        top: while ((!endDate || endDate >= monthStartDate) && (!count || counter < count)) {
            dates = [];
            if (weekDays && weekDays.length) {
                Ext.each(weekDays, function(day) {
                    var weekDay = day[0],
                        from = 1,
                        till = 53;
                    // if position provided
                    if (day[1]) {
                        from = till = day[1];
                    }
                    for (i = from; i <= till; i++) {
                        if ((date = me.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i))) {
                            date = D.copyTimeValues(date, eventStart);
                            if (!processedDate[date.getTime()]) {
                                // remember we processed the date
                                processedDate[date.getTime()] = true;
                                dates.push(date);
                            }
                        }
                    }
                });
                dates.sort(function(a, b) {
                    return a - b;
                });
                if (!hasPositions) {
                    for (i = 0; i < dates.length; i++) {
                        date = dates[i];
                        if (date >= eventStart) {
                            counter++;
                            if (date >= startDate) {
                                if ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))  {
                                    return false;
                                }
                                
                            }
                        }
                    }
                }
            } else {
                var sortedMonthDates = [];
                for (i = 0; i < monthDays.length; i++) {
                    // check if the date wasn't iterated over yet
                    if ((date = me.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[date.getTime()]) {
                        processedDate[date.getTime()] = true;
                        sortedMonthDates.push(date);
                    }
                }
                // it's important to sort the dates to iterate over them in the proper order
                sortedMonthDates.sort(function(a, b) {
                    return a - b;
                });
                for (i = 0; i < sortedMonthDates.length; i++) {
                    date = D.copyTimeValues(sortedMonthDates[i], eventStart);
                    if (hasPositions) {
                        dates.push(date);
                    } else if (date >= eventStart) {
                        counter++;
                        if (date >= startDate) {
                            if ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))  {
                                break top;
                            }
                            
                        }
                    }
                }
            }
            if (hasPositions && dates.length) {
                me.forEachDateAtPositions(dates, positions, function(date) {
                    if (date >= eventStart) {
                        counter++;
                        // Ignore dates outside of the [startDate, endDate] range
                        if (date >= startDate && (!endDate || date <= endDate)) {
                            // return false if it's time to stop recurring
                            if (fn.call(scope, date, counter) === false || (count && counter >= count))  {
                                return false;
                            }
                            
                        }
                    }
                });
            }
            // get next month start
            monthStartDate = D.getNext(monthStartDate, D.MONTH, interval);
            monthEndDate = new Date(D.getNext(monthStartDate, D.MONTH, 1) - 1);
        }
    }
});

Ext.define('Sch.data.util.recurrence.YearlyIterator', {
    extend: 'Sch.data.util.recurrence.AbstractIterator',
    requires: [
        'Sch.util.Date',
        'Sch.data.util.recurrence.DayRuleEncoder'
    ],
    singleton: true,
    frequency: 'YEARLY',
    forEachDate: function(config) {
        var me = this,
            D = Sch.util.Date,
            fn = config.fn,
            scope = config.scope || me,
            recurrence = config.recurrence,
            event = config.event || recurrence.getEvent(),
            eventStart = config.eventStartDate || event.getStartDate(),
            startDate = config.startDate || eventStart,
            until = recurrence && recurrence.getEndDate(),
            endDate = config.endDate || until,
            interval = config.interval || recurrence.getInterval(),
            rawDays = config.days || recurrence && recurrence.getDays(),
            weekDays = Sch.data.util.recurrence.DayRuleEncoder.decode(rawDays),
            months = config.months || recurrence && recurrence.getMonths(),
            count = config.count || recurrence && recurrence.getCount(),
            positions = config.positions || recurrence && recurrence.getPositions(),
            hasPositions = positions && positions.length,
            counter = 0,
            processedDate = {},
            weekDayPosition, yearStartDate, yearEndDate, dates, date, i;
        if (until && endDate && endDate > until)  {
            endDate = until;
        }
        
        // iteration should not start before the event starts
        if (eventStart > startDate)  {
            startDate = eventStart;
        }
        
        // if the recurrence is limited w/ "Count"
        // we need to 1st count passed occurrences so we always start iteration from the event start date
        if (count) {
            yearStartDate = new Date(D.getNext(eventStart, D.YEAR, 0));
        } else {
            yearStartDate = new Date(D.getNext(startDate, D.YEAR, 0));
        }
        yearEndDate = new Date(D.getNext(yearStartDate, D.YEAR, 1) - 1);
        months && months.sort(function(a, b) {
            return a - b;
        });
        // if no months provided let's use the event month
        if (!(months && months.length) && !(weekDays && weekDays.length)) {
            months = [
                eventStart.getMonth() + 1
            ];
        }
        if (weekDays && weekDays.length) {
            // Collect hash of positions indexed by week days
            Ext.each(weekDays, function(day) {
                if (day[1]) {
                    weekDayPosition = weekDayPosition || {};
                    weekDayPosition[day[0]] = day[1];
                }
            });
        }
        // label to break nested loops
        top: while ((!endDate || endDate >= yearStartDate) && (!count || counter < count)) {
            dates = [];
            if (weekDays && weekDays.length) {
                Ext.each(weekDays, function(day) {
                    var weekDay = day[0],
                        from = 1,
                        till = 53;
                    // if position provided
                    if (day[1]) {
                        from = till = day[1];
                    }
                    for (i = from; i <= till; i++) {
                        if ((date = me.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i))) {
                            date = D.copyTimeValues(date, eventStart);
                            if (!processedDate[date.getTime()]) {
                                // remember we processed the date
                                processedDate[date.getTime()] = true;
                                dates.push(date);
                            }
                        }
                    }
                });
                dates.sort(function(a, b) {
                    return a - b;
                });
                if (!hasPositions) {
                    for (i = 0; i < dates.length; i++) {
                        date = dates[i];
                        if (date >= eventStart) {
                            counter++;
                            if (date >= startDate) {
                                if ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))  {
                                    return false;
                                }
                                
                            }
                        }
                    }
                }
            } else {
                for (i = 0; i < months.length; i++) {
                    if ((date = me.buildDate(yearStartDate.getFullYear(), months[i] - 1, eventStart.getDate()))) {
                        date = D.copyTimeValues(date, eventStart);
                        // check if the date wasn't iterated over yet
                        if (!processedDate[date.getTime()]) {
                            processedDate[date.getTime()] = true;
                            if (hasPositions) {
                                dates.push(date);
                            } else if (date >= eventStart) {
                                counter++;
                                if (date >= startDate) {
                                    if ((endDate && date > endDate) || (fn.call(scope, date, counter) === false) || (count && counter >= count))  {
                                        break top;
                                    }
                                    
                                }
                            }
                        }
                    }
                }
            }
            if (hasPositions && dates.length) {
                me.forEachDateAtPositions(dates, positions, function(date) {
                    if (date >= eventStart) {
                        counter++;
                        // Ignore dates outside of the [startDate, endDate] range
                        if (date >= startDate && (!endDate || date <= endDate)) {
                            // return false if it's time to stop recurring
                            if (fn.call(scope, date, counter) === false || (count && counter >= count))  {
                                return false;
                            }
                            
                        }
                    }
                });
            }
            // get next month start
            yearStartDate = D.getNext(yearStartDate, D.YEAR, interval);
            yearEndDate = new Date(D.getNext(yearStartDate, D.YEAR, 1) - 1);
        }
    }
});

/**
 * This mixin class provides recurring events functionality to the {@link Sch.data.EventStore event store}.
 */
Ext.define('Sch.data.mixin.RecurringEvents', {
    extend: 'Ext.Mixin',
    requires: [
        'Sch.model.Recurrence',
        'Sch.data.util.DelayedCalls',
        'Sch.data.util.recurrence.DailyIterator',
        'Sch.data.util.recurrence.WeeklyIterator',
        'Sch.data.util.recurrence.MonthlyIterator',
        'Sch.data.util.recurrence.YearlyIterator'
    ],
    /**
     * Indicates the store supports recurring events.
     * @property {Boolean}
     */
    isRecurringEventStore: true,
    /**
     * Timeout in milliseconds during which to collect calls for generating occurrences related methods.
     * @type {Number}
     */
    delayedCallTimeout: 100,
    setupRecurringEvents: function() {
        this.recurrenceIterators = this.recurrenceIterators || [];
        this.addRecurrenceIterators(Sch.data.util.recurrence.DailyIterator, Sch.data.util.recurrence.WeeklyIterator, Sch.data.util.recurrence.MonthlyIterator, Sch.data.util.recurrence.YearlyIterator);
        this.relayEvents(Sch.data.util.DelayedCalls, [
            'delayed-regenerate-occurrences-start',
            'delayed-regenerate-occurrences-end',
            'delayed-generate-occurrences-start',
            'delayed-generate-occurrences-end'
        ]);
        this.mon(Sch.data.util.DelayedCalls, {
            'delayed-regenerate-occurrences-end': this.onDelayedRegenerateOccurrencesEnd,
            'delayed-generate-occurrences-end': this.onDelayedGenerateOccurrencesEnd,
            scope: this
        });
        this.on('destroy', this.onEventStoreDestroy, this);
    },
    onEventStoreDestroy: function() {
        Sch.data.util.DelayedCalls.cancel('generate-occurrences', 'regenerate-occurrences');
    },
    addRecurrenceIterators: function() {
        for (var i = 0; i < arguments.length; i++) {
            this.recurrenceIterators[arguments[i].frequency] = arguments[i];
        }
    },
    getRecurrenceIteratorForEvent: function(event) {
        return this.recurrenceIterators[event.getRecurrence().getFrequency()];
    },
    /**
     * @private
     * Builds the provided repeating event occurrences for the provided timespan.
     */
    buildOccurrencesForEvent: function(event, startDate, endDate, skipExisting) {
        var occurrences = [];
        // is recurring
        if (event.isRecurring() && event.getStartDate()) {
            var me = this,
                recurrence = event.getRecurrence(),
                iterator = me.getRecurrenceIteratorForEvent(event);
            Ext.Assert && Ext.Assert.truthy(iterator, "Can't find iterator for " + recurrence.getFrequency() + " frequency");
            var duration = event.getEndDate() - event.getStartDate();
            var exceptionDates = event.getExceptionDates() ? Ext.Array.toMap(event.getExceptionDates(), function(date) {
                    return date - 0;
                }) : {};
            iterator.forEachDate({
                recurrence: recurrence,
                startDate: startDate,
                endDate: endDate,
                fn: function(date) {
                    // when it's told we don't generate occurrences if we already have ones on the calculated dates
                    if (!exceptionDates[date - 0] && (!skipExisting || !event.getOccurrenceByStartDate(date))) {
                        occurrences.push(event.buildOccurrence(date, duration));
                    }
                }
            });
        }
        return occurrences;
    },
    mergeDelayedCallEntries: function(delayedCall) {
        var entries = delayedCall.entries,
            byEventId = {},
            startDate, endDate, events, event, args;
        // first get the largest range for each requested event
        for (var i = 0; i < entries.length; i++) {
            args = entries[i];
            events = args[0];
            startDate = args[1];
            endDate = args[2];
            // Go over the events and merge this call and other ones arguments
            // so start date will be the minimal start date requested
            // and the end date the maximal end date requested
            // TODO: need to handle cases when ranges don't intersect
            for (var j = 0; j < events.length; j++) {
                event = events[j];
                var savedArgs = byEventId[event.getId()];
                if (savedArgs) {
                    if (savedArgs[1] > startDate)  {
                        savedArgs[1] = startDate;
                    }
                    
                    if (savedArgs[2] < endDate)  {
                        savedArgs[2] = endDate;
                    }
                    
                } else {
                    byEventId[event.getId()] = [
                        [
                            event
                        ]
                    ].concat(args.slice(1));
                }
            }
        }
        // ranges are grouped by event id
        entries = Ext.Object.getValues(byEventId);
        // let's try to combine calls having the same ranges
        var combinedEntries = {};
        for (i = 0; i < entries.length; i++) {
            args = entries[i];
            event = args[0];
            startDate = args[1];
            endDate = args[2];
            var key = (startDate ? startDate.getTime() : '') + '-' + (endDate ? endDate.getTime() : '');
            // if this range met already
            if (combinedEntries[key]) {
                // add event to the first argument
                combinedEntries[key][0] = combinedEntries[key][0].concat(event);
            } else // if this range isn't met yet
            // remember we met it using that call arguments
            {
                combinedEntries[key] = args;
            }
        }
        // use combined entries
        delayedCall.entries = Ext.Object.getValues(combinedEntries);
    },
    /**
     * @private
     * Schedules regenerating (removing and building back) the occurrences of the provided recurring events in the provided time interval.
     * The method waits for {@link #delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then invokes {@link #generateOccurrencesForEvents} method and removes the previous occurrences.
     * @param  {Sch.model.Event[]} events                   Events to build occurrences for.
     * @param  {Date}              startDate                Time interval start.
     * @param  {Date}              endDate                  Time interval end.
     * @param  {Boolean}           [preserveExisting=false] `True` to not not generate occurrences if there are already existing ones on the calculated dates.
     */
    regenerateOccurrencesForEventsBuffered: function(events, startDate, endDate) {
        var me = this;
        if (!Ext.isIterable(events)) {
            events = [
                events
            ];
        }
        events = Ext.Array.filter(events, function(event) {
            return event.isRecurring();
        });
        if (events.length) {
            var delayedCall = Sch.data.util.DelayedCalls.schedule({
                    id: 'regenerate-occurrences',
                    timeout: me.delayedCallTimeout,
                    beforeFn: me.mergeDelayedCallEntries,
                    fn: function(events, startDate, endDate) {
                        // Collect old occurrences we'll remove them later by using a single store.remove() call
                        var toRemove = delayedCall.occurrencesToRemove = delayedCall.occurrencesToRemove || [];
                        toRemove.push.apply(toRemove, me.getOccurrencesForEvents(events));
                        // add new occurrences
                        me.generateOccurrencesForEvents(events, startDate, endDate, false);
                    },
                    args: [
                        events,
                        startDate,
                        endDate
                    ],
                    afterFn: function(delayedCall) {
                        // remove previous occurrences (if we have any)
                        delayedCall.occurrencesToRemove.length && me.remove(delayedCall.occurrencesToRemove);
                    },
                    scope: me
                });
        }
    },
    /**
     * @private
     * Schedules generating the occurrences of the provided recurring events in the provided time interval.
     * The method waits for {@link #delayedCallTimeout} milliseconds timeout during which it collects repeating calls.
     * Every further call restarts the timeout. After the timeout the method processes the collected calls trying to merge startDate/endDate ranges
     * to reduce the number of calls and then invokes {@link #generateOccurrencesForEvents} method.
     * @param  {Sch.model.Event[]} events                   Events to build occurrences for.
     * @param  {Date}              startDate                Time interval start.
     * @param  {Date}              endDate                  Time interval end.
     * @param  {Boolean}           [preserveExisting=true]  `False` to generate occurrences even if there is already an existing one on a calculated date.
     */
    generateOccurrencesForEventsBuffered: function(events, startDate, endDate, preserveExisting) {
        var me = this;
        preserveExisting = preserveExisting !== false;
        if (!Ext.isIterable(events)) {
            events = [
                events
            ];
        }
        events = Ext.Array.filter(events, function(event) {
            return event.isRecurring();
        });
        if (events.length) {
            Sch.data.util.DelayedCalls.schedule({
                id: 'generate-occurrences',
                timeout: me.delayedCallTimeout,
                beforeFn: me.mergeDelayedCallEntries,
                fn: me.generateOccurrencesForEvents,
                args: [
                    events,
                    startDate,
                    endDate,
                    preserveExisting
                ],
                scope: me
            });
        }
    },
    /**
     * @private
     * Generates occurrences of the provided recurring events in the provided time interval.
     * @param  {Sch.model.Event[]} events                   Events to build occurrences for.
     * @param  {Date}              startDate                Time interval start.
     * @param  {Date}              endDate                  Time interval end.
     * @param  {Boolean}           [preserveExisting=true] `False` to generate occurrences even if there is already an existing one on a calculated date.
     */
    generateOccurrencesForEvents: function(events, startDate, endDate, preserveExisting) {
        if (events) {
            var me = this,
                occurrences = [],
                allOccurrences = [];
            preserveExisting = preserveExisting !== false;
            if (!Ext.isIterable(events))  {
                events = [
                    events
                ];
            }
            
            if (events.length) {
                me.fireEvent('generate-occurrences-start', me, events, startDate, endDate, preserveExisting);
                for (var i = 0; i < events.length; i++) {
                    var event = events[i],
                        firstOccurrenceStartDate, firstOccurrence, eventStartDate;
                    if ((occurrences = me.buildOccurrencesForEvent(event, startDate, endDate, preserveExisting))) {
                        eventStartDate = event.getStartDate();
                        // If requested timespan starts before or matches the event starts
                        // we treat the first built occurrence as the event itself
                        // and if the occurrence start doesn't match the event start
                        // we move the event accordingly
                        if (startDate <= eventStartDate) {
                            // get 1st occurrence
                            if ((firstOccurrence = occurrences.shift())) {
                                firstOccurrenceStartDate = firstOccurrence.getStartDate();
                                // compare its start date with the event one and shift the event if needed
                                if (firstOccurrenceStartDate - eventStartDate) {
                                    event.setStartEndDate(firstOccurrenceStartDate, firstOccurrence.getEndDate());
                                    // Since we've changed the event start date the recurrence "Days"/"MonthDays"/"Months"
                                    // might get redundant in case the event start date matches the fields values
                                    // Calling recurrence sanitize() will clean the fields in this case.
                                    event.getRecurrence().sanitize();
                                }
                            }
                        }
                        allOccurrences.push.apply(allOccurrences, occurrences);
                    }
                }
                if (allOccurrences.length) {
                    me.add(allOccurrences);
                }
                me.fireEvent('generate-occurrences-end', me, events, allOccurrences, startDate, endDate, preserveExisting);
            }
        }
    },
    /**
     * @private
     * Generates occurrences for all the existing recurring events in the provided time interval.
     * @param  {Date}    startDate                Time interval start.
     * @param  {Date}    endDate                  Time interval end.
     * @param  {Boolean} [preserveExisting=false] `True` to not not generate occurrences if there are already existing ones on the calculated dates.
     */
    generateOccurrencesForAll: function(startDate, endDate, preserveExisting) {
        var me = this,
            events;
        if ((events = me.getRecurringEvents()) && events.length) {
            me.fireEvent('generate-occurrences-all-start', me, events, startDate, endDate, preserveExisting);
            me.generateOccurrencesForEvents(events, startDate, endDate, preserveExisting);
            me.fireEvent('generate-occurrences-all-end', me, events, startDate, endDate, preserveExisting);
        }
    },
    /**
     * Returns all the recurring events.
     * @return {Sch.model.Event[]} Array of recurring events.
     */
    getRecurringEvents: function() {
        var me = this;
        return me.queryBy(function(event) {
            return event.isRecurrableEvent && event.isRecurring();
        }).getRange();
    },
    /**
     * Returns occurrences of the provided recurring events.
     * @param  {Sch.model.Event/Sch.model.Event[]} events Recurring events which occurrences should be retrieved.
     * @return {Sch.model.Event[]} Array of the events occurrences.
     */
    getOccurrencesForEvents: function(events) {
        var result = [];
        if (!Ext.isIterable(events))  {
            events = [
                events
            ];
        }
        
        if (events.length) {
            for (var i = 0; i < events.length; i++) {
                var eventId = events[i].getId();
                // TODO: cache
                result.push.apply(result, this.queryBy(function(event) {
                    return event.isRecurrableEvent && event.getRecurringEventId() == eventId;
                }).getRange());
            }
        }
        return result;
    },
    /**
     * Returns occurrences of all the existing recurring events.
     * @return {Sch.model.Event[]} Array of the occurrences.
     */
    getOccurrencesForAll: function() {
        return this.queryBy(function(event) {
            return event.isRecurrableEvent && event.isOccurrence();
        }).getRange();
    },
    /**
     * Removes occurrences of the provided recurring events.
     * @param  {Sch.model.Event/Sch.model.Event[]} events Recurring events which occurrences should be removed.
     */
    removeOccurrencesForEvents: function(events) {
        return this.remove(this.getOccurrencesForEvents(events));
    },
    /**
     * Removes occurrences of all the existing recurring events.
     */
    removeOccurrencesForAll: function() {
        return this.remove(this.getOccurrencesForAll());
    },
    onDelayedRegenerateOccurrencesEnd: function() {
        /**
         * @event occurrencesready
         * Fires when repeating events occurrences building is done. This happens on:
         *
         * - after panel got rendered;
         * - on event store load/add/update/remove events;
         * - on visible timespan change.
         * @param {Sch.data.EventStore} eventStore Event store.
         */
        this.fireEvent('occurrencesready', this);
    },
    onDelayedGenerateOccurrencesEnd: function() {
        this.fireEvent('occurrencesready', this);
    }
});

/**
 * This mixin class provides recurring events related fields and methods to the {@link Sch.model.Event event model}.
 *
 * The mixin introduces two types of events: __recurring event__ and its __occurrences__.
 * __Recurring event__ is an event having {@link #RecurrenceRule recurrence rule} specified and its __occurrences__ are "fake" dynamically generated events.
 * The occurrences are not persistable (the mixin overrides {@link Sch.model.Event#isPersistable isPersistable} method to take that into account).
 * Their set depends on the scheduler visible timespan and changes upon the timespan change.
 *
 * There are few methods allowing to distinguish a recurring event and an occurrence: {@link #isRecurring}, {@link #isOccurrence}
 * and {@link #getRecurringEvent} (returns the event this record is an occurrence of).
 *
 * The {@link #RecurrenceRule recurrence rule} defined for the event is parsed and
 * represented with {@link Sch.model.Recurrence} class (can be changed with {@link #recurrenceModel} config) instance.
 * See: {@link #getRecurrence}, {@link #setRecurrence} methods.
 */
Ext.define('Sch.model.mixin.RecurrableEvent', {
    extend: 'Ext.Mixin',
    requires: [
        'Sch.model.Recurrence'
    ],
    /**
     * Indicates the model supports event recurrence.
     * @property {Boolean}
     */
    isRecurrableEvent: true,
    /**
     * @cfg {String}
     * {@link #RecurringEvent} field mapping.
     */
    recurringEventIdField: 'RecurringEventId',
    /**
     * @cfg {String}
     * {@link #RecurrenceRule} field mapping.
     */
    recurrenceRuleField: 'RecurrenceRule',
    /**
     * @cfg {String}
     * {@link #ExceptionDates} field mapping.
     */
    exceptionDatesField: 'ExceptionDates',
    customizableFields: [
        /**
         * @field
         * Identifier of the "main" event this model is an occurrence of.
         * **Applicable to occurrences only.**
         */
        {
            name: 'RecurringEventId'
        },
        /**
         * @field
         * The event recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression).
         */
        {
            name: 'RecurrenceRule',
            allowNull: true,
            convert: function(value, record) {
                // undefined, null and zero-length string will be converted to null
                if (Ext.isEmpty(value)) {
                    value = null;
                }
                return value;
            }
        },
        /**
         * @field
         * @type {Date[]}
         * The event exception dates. The dates that must be skipped when generating occurrences for a repeating event.
         * This is used to modify only individual occurrences of the event so the further regenerations
         * won't create another copy of this occurrence again.
         * Use {@link #addExceptionDate} method to add an individual entry to the dates array:
         *
         * ```javascript
         * // let the main event know that this date should be skipped when regenerating the occurrences
         * occurrence.getRecurringEvent().addExceptionDate( occurrence.getStartDate() );
         *
         * // cut the main event cord
         * occurrence.setRecurringEventId(null);
         *
         * // now the occurrence is an individual event that can be changed & persisted freely
         * occurrence.setName("I am detached!");
         * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));
         * ```
         * **Note:** The dates in this field get automatically removed when the event changes its {@link #StartDate start date}.
         */
        {
            name: 'ExceptionDates',
            dateFormat: 'c',
            convert: function(value, record) {
                if (value) {
                    var dateFormat = this.dateFormat,
                        useStrict = this.useStrict;
                    value = Ext.isString(value) ? value.split(',') : value;
                    value = Ext.Array.map(value, function(item) {
                        if (!Ext.isDate(item)) {
                            item = Ext.Date.parse(item, dateFormat, useStrict);
                        }
                        return item;
                    });
                }
                return value;
            }
        }
    ],
    /**
     * Name of the class representing the recurrence model.
     * @cfg {String}
     */
    recurrenceModel: 'Sch.model.Recurrence',
    /**
     * Sets a recurrence for the event with a given frequency, interval, and end.
     * @param {String/Object/Sch.model.Recurrence} frequency The frequency of the recurrence, configuration object or the recurrence model. The frequency can be `DAILY`, `WEEKLY`, `MONTHLY`, or `YEARLY`.
     * ```javascript
     * // let repeat the event every other week till Jan 2 2019
     * event.setRecurrence("WEEKLY", 2, new Date(2019, 0, 2));
     * ```
     * Also a {@link Sch.model.Recurrence recurrence model} can be provided as the only argument for this method:
     *
     * ```javascript
     * var recurrence = new Sch.model.Recurrence({ Frequency : 'DAILY', Interval : 5 });
     *
     * event.setRecurrence(recurrence);
     * ```
     * @param {Integer} [interval] The interval between occurrences (instances of this recurrence). For example, a daily recurrence with an interval of 2 occurs every other day. Must be greater than 0.
     * @param {Integer/Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a maximum count of occurrences (has to greater than 1, since 1 means the event itself).
     */
    setRecurrence: function(frequency, interval, recurrenceEnd) {
        var me = this,
            previousRecurrence, recurrence, value;
        // If this is an occurrence - turn it into an event first
        if (me.isOccurrence()) {
            var recurringEvent = me.getRecurringEvent();
            previousRecurrence = recurringEvent && recurringEvent.getRecurrence();
            me.setRecurringEventId(null);
        }
        // if it's a recurring event we remove its current occurrences
        // me.removeOccurrences();
        if (frequency) {
            // if we set recurrence on an occurrence model
            // we stop previous main recurrence
            previousRecurrence && previousRecurrence.setEndDate(new Date(me.getStartDate() - 1));
            if (frequency.isRecurrenceModel) {
                recurrence = frequency;
            } else if (Ext.isObject(frequency)) {
                recurrence = new this.recurrenceModel(frequency);
            } else {
                recurrence = new this.recurrenceModel();
                recurrence.setFrequency(frequency);
                interval && recurrence.setInterval(interval);
                // if the recurrence is limited
                if (recurrenceEnd) {
                    if (recurrenceEnd instanceof Date) {
                        recurrence.setEndDate(recurrenceEnd);
                    } else {
                        recurrence.setCount(recurrenceEnd);
                    }
                }
            }
            recurrence.setEvent(me);
            value = recurrence.getRule();
        }
        me.recurrence = recurrence;
        me.set(me.recurrenceRuleField, value);
    },
    /**
     * Returns the event recurrence settings.
     * @return {Sch.model.Recurrence} The recurrence model.
     */
    getRecurrence: function() {
        var me = this,
            recurrenceRule = me.getRecurrenceRule();
        if (!me.recurrence && recurrenceRule) {
            me.recurrence = new me.recurrenceModel({
                rule: recurrenceRule,
                event: me
            });
        }
        return me.recurrence;
    },
    /**
     * Indicates if the event is recurring.
     * @return {Boolean} `True` if the event is recurring.
     */
    isRecurring: function() {
        return this.getRecurrence() && !this.isOccurrence();
    },
    /**
     * Indicates if the event is an occurrence of another recurring event.
     * @return {Boolean} `True` if the event is an occurrence.
     */
    isOccurrence: function() {
        return Boolean(this.getRecurringEventId());
    },
    /**
     * Returns the "main" event this model is an occurrence of. For non-occurrences returns `null`-value.
     * @return {Sch.model.Event} The recurring event of this occurrence.
     */
    getRecurringEvent: function() {
        var masterEventId = this.getRecurringEventId(),
            eventStore = this.getEventStore();
        return masterEventId && eventStore && eventStore.getModelById(masterEventId);
    },
    getOccurrenceByStartDate: function(startDate) {
        var result, occurrences;
        if (startDate) {
            occurrences = this.getOccurrences();
            for (var i = 0; i < occurrences.length; i++) {
                if (occurrences[i].getStartDate() - startDate === 0) {
                    result = occurrences[i];
                    break;
                }
            }
        }
        return result;
    },
    /**
     * Returns list of this recurring event occurrences.
     * @return {Sch.model.Event[]} Array of the occurrences.
     */
    getOccurrences: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getOccurrencesForEvents(this);
    },
    /**
     * Removes this recurring event occurrences.
     */
    removeOccurrences: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.removeOccurrencesForEvents(this);
    },
    /**
     * @private
     * The method is triggered when the event recurrence gets changed.
     * It updates the {@link #RecurrenceRule} field in this case.
     */
    onRecurrenceChanged: function() {
        var recurrence = this.getRecurrence();
        this.setRecurrenceRule(recurrence && recurrence.getRule() || null);
    },
    /**
     * @protected
     * Builds this event occurrence by cloning the event data.
     * The method is used internally by the __recurring events__ feature.
     * Override it if you need to customize the generated occurrences.
     * @param  {Date}    startDate  The occurrence start date.
     * @param  {Integer} [duration] The event duration in milliseconds. The value is used to calculate the occurrence end date.
     *                              If omitted the value will be calculated based on the event start/end dates.
     * @return {Sch.model.Event}    The occurrence.
     */
    buildOccurrence: function(startDate, duration) {
        duration = duration || this.getEndDate() - this.getStartDate();
        var copy = this.copy(null);
        copy.beginEdit();
        copy.setStartEndDate(startDate, new Date(startDate.getTime() + duration));
        copy.setRecurringEventId(this.getId());
        copy.endEdit();
        return copy;
    },
    /**
     * Sets a {@link #RecurrenceRule recurrence rule} for the event.
     * Provide empty value to reset the event recurrence.
     * @param {String/null} rule The event recurrence rule (a string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format ("RRULE" expression))
     *                      or null to reset the event recurrence.
     */
    setRecurrenceRule: function(rule) {
        var me = this,
            recurrence;
        if (rule != me.getRecurrenceRule()) {
            if (rule) {
                recurrence = new me.recurrenceModel({
                    rule: rule,
                    event: me
                });
            }
            me.recurrence = recurrence;
            me.set(me.recurrenceRuleField, rule);
        }
    },
    /**
     * Adds an exception date that should be skipped when generating occurrences for the event.
     * The methods adds an entry to the array kept in {@link #ExceptionDates} field.
     * @param {Date} date Exception date.
     */
    addExceptionDate: function(date) {
        var me = this,
            dates = me.getExceptionDates() || [];
        if (date) {
            me.setExceptionDates(dates.concat(date));
        }
    },
    beforeStartDateChange: function() {
        this._startDateValue = this.getStartDate();
    },
    afterStartDateChange: function() {
        if (this._startDateValue - this.getStartDate() && this.getExceptionDates())  {
            this.setExceptionDates();
        }
        
    },
    mixinConfig: {
        before: {
            setStartDate: 'beforeStartDateChange',
            setStartEndDate: 'beforeStartDateChange'
        },
        after: {
            setStartDate: 'afterStartDateChange',
            setStartEndDate: 'afterStartDateChange'
        },
        // This function is called whenever a new "derivedClass" is created
        // that extends a "baseClass" in to which this mixin was mixed.
        extended: function(baseClass, derivedClass, classBody) {
            var recurrenceModel = classBody.recurrenceModel;
            // TODO: check this
            if (typeof recurrenceModel == 'string') {
                Ext.require(recurrenceModel, function() {
                    classBody.recurrenceModel = Ext.data.schema.Schema.lookupEntity(recurrenceModel);
                    Ext.override(derivedClass, {
                        recurrenceModel: Ext.data.schema.Schema.lookupEntity(recurrenceModel)
                    });
                });
            }
        }
    },
    onClassMixedIn: function(targetClass) {
        var recurrenceModel = targetClass.prototype.recurrenceModel || this.prototype.recurrenceModel;
        if (typeof recurrenceModel == 'string') {
            Ext.require(recurrenceModel, function() {
                Ext.override(targetClass, {
                    recurrenceModel: Ext.data.schema.Schema.lookupEntity(recurrenceModel)
                });
            });
        }
        Ext.override(targetClass, {
            // override "isPersistable" method to take into account event type: event/occurrence
            // occurrence are not persistable
            isPersistable: function() {
                var me = this;
                return me.callParent(arguments) && !me.isOccurrence();
            },
            set: function(fieldName, value) {
                // reset cached recurrence link if new recurrence rule is provided to the event
                if (typeof fieldName == 'string' ? fieldName == this.recurrenceRuleField : this.recurrenceRuleField in fieldName) {
                    this.recurrence = null;
                }
                return this.callParent(arguments);
            },
            // merge the mixin and target class "customizableFields" arrays
            customizableFields: (targetClass.prototype.customizableFields || []).concat(this.prototype.customizableFields)
        });
    }
});

/**
 * This class represent a single event in your schedule. Its a subclass of the {@link Sch.model.Range}, which is in turn subclass of {@link Sch.model.Customizable} and {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familiar with the base interface of the task.
 *
 * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,
 * you can do that by subclassing this class (see example below).
 *
 * ## Repeating events
 *
 * The Event model can be **recurring**. To make an event recurring the one should use {@link #setRecurrence} method or
 * specify a {@link #RecurrenceRule recurrence rule} for the event.
 * After doing this the scheduler will populate the event store with the event **occurrences**.
 * The occurrences are "fake" dynamically generated events. They are not persistable and their set depends on the visible timespan.
 *
 * There are few methods allowing to distinguish a recurring event or an occurrence: {@link #isRecurring}, {@link #isOccurrence}
 * and {@link #getRecurringEvent} (returns the event this record is an occurrence of).
 *
 * **Note:** There is a special {@link Sch.model.Recurrence} class representing an event recurrence settings.
 *
 * For more details see related methods: {@link #getRecurrence}, {@link #setRecurrence}, {@link #setRecurrenceRule}, {@link #isRecurring}, {@link #isOccurrence},
 * {@link #getOccurrences}, {@link #removeOccurrences}, {@link #getRecurringEvent}.
 *
 * ## Subclassing the Event model class
 *
 * ```javascript
 *     Ext.define('MyProject.model.Event', {
 *         extend      : 'Sch.model.Event',
 *
 *         fields      : [
 *             // adding new field
 *             { name: 'MyField', type : 'number', defaultValue : 0 }
 *         ],
 *
 *         myCheckMethod : function () {
 *             return this.get('MyField') > 0
 *         },
 *         ...
 *     });
 * ```
 *
 * If you want to use other names for the {@link #StartDate}, {@link #EndDate}, {@link #ResourceId} and {@link #Name} fields you can configure them as seen below:
 *
 * ```javascript
 *     Ext.define('MyProject.model.Event', {
 *         extend      : 'Sch.model.Event',
 *
 *         startDateField  : 'taskStart',
 *         endDateField    : 'taskEnd',
 *
 *         // just rename the fields
 *         resourceIdField : 'userId',
 *         nameField       : 'taskTitle',
 *
 *         fields      : [
 *             // completely change the definition of fields
 *             { name: 'taskStart', type: 'date', dateFormat : 'Y-m-d' },
 *             { name: 'taskEnd', type: 'date', dateFormat : 'Y-m-d' },
 *         ]
 *         ...
 *     });
 * ```
 *
 * Please refer to {@link Sch.model.Customizable} for additional details.
 *
 */
Ext.define('Sch.model.Event', {
    extend: 'Sch.model.Range',
    uses: [
        'Sch.util.Date'
    ],
    idProperty: 'Id',
    mixins: [
        'Sch.model.mixin.RecurrableEvent'
    ],
    isEventModel: true,
    customizableFields: [
        /**
         * @field Id
         * Unique identifier of task.
         */
        /**
         * @field Name
         * Name of the event (task title).
         */
        /**
         * @field StartDate
         * @type {Date}
         * Start date of the task in ISO 8601 format. See {@link Ext.Date} for other format definitions.
         */
        /**
         * @field EndDate
         * @type {Date}
         * End date of the task in ISO 8601 format. See {@link Ext.Date} for other format definitions.
         */
        /**
         * @field Cls
         * A field containing a CSS class to be added to the rendered event element.
         */
        /**
         * @field IconCls
         * A field containing a CSS class to be added as an icon to the event.
         */
        {
            name: 'IconCls'
        },
        /**
         * @field ResourceId
         * The id of the associated resource.
         */
        {
            name: 'ResourceId'
        },
        /**
         * @field Draggable
         * A field allowing you to easily control if an event can be dragged. (true or false)
         */
        {
            name: 'Draggable',
            type: 'boolean',
            persist: false,
            defaultValue: true
        },
        // true or false
        /**
         * @field Resizable
         * A field allowing you to easily control how an event can be resized. Possible values are:
         *
         * - true - resize of both event start and end is allowed,
         * - false - resize of both event start and end is forbidden,
         * - 'start' - event start resize is allowed
         * - 'end' - event end resize is allowed
         */
        {
            name: 'Resizable',
            persist: false,
            defaultValue: true
        },
        // true, false, 'start' or 'end'
        /**
         * @field AllDay
         *
         * A field marking event as all day(s) spanning event
         */
        {
            name: 'AllDay',
            defaultValue: false
        }
    ],
    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an event belongs.
     */
    resourceIdField: 'ResourceId',
    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField: 'Draggable',
    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField: 'Resizable',
    /**
     * @cfg {String}
     * {@link #AllDay} field mapping.
     */
    allDayField: 'AllDay',
    /**
     * @cfg {String} iconClsField The name of the field specifying the icon CSS class for an event.
     */
    iconClsField: 'IconCls',
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * @property isHighlighted Set to true to highligh event on render
     * @private
     */
    isHighlighted: false,
    /**
     * Returns an event store this event is part of. Event must be part
     * of an event store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        var me = this,
            result = me.joined && me.joined[0];
        if (result && !result.isEventStore) {
            // sort stores to avoid extra array walks in future
            Ext.Array.sort(me.joined, function(a, b) {
                return (a.isEventStore || false) > (b.isEventStore || false) && -1 || 1;
            });
            result = me.joined[0];
            // record can be joined to several stores none of which is an event store
            // e.g. if record is in viewmodel. test 025_eventstore
            result = result.isEventStore ? result : null;
        }
        return result;
    },
    /**
     * Returns a resource store this event uses as default resource store. Event must be part
     * of an event store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore}
     */
    getResourceStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },
    /**
     * Returns an assigment store this event uses as default assignment store. Event must be part
     * of an event store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },
    /**
     * Returns all resources assigned to an event.
     *
     * @return {Sch.model.Resource[]}
     */
    getResources: function(eventStore) {
        var me = this;
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getResourcesForEvent(me) || [];
    },
    /**
     * @private
     */
    forEachResource: function(fn, scope) {
        var rs = this.getResources();
        for (var i = 0; i < rs.length; i++) {
            if (fn.call(scope || this, rs[i]) === false) {
                return;
            }
        }
    },
    /**
     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
     * with specified id.
     *
     * @param {String} resourceId (optional)
     * @return {Sch.model.Resource}
     */
    getResource: function(resourceId) {
        var me = this,
            result = null,
            eventStore = me.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        // Allow 0 as a valid resource id
        resourceId = resourceId == null ? me.getResourceId() : resourceId;
        if (eventStore && (resourceId === null || resourceId === undefined)) {
            result = eventStore.getResourcesForEvent(me);
            if (result.length == 1) {
                result = result[0];
            } else if (result.length > 1) {
                Ext.Error.raise("Event::getResource() is not applicable for events with multiple assignments, please use Event::getResources() instead.");
            } else {
                result = null;
            }
        } else if (resourceStore) {
            result = resourceStore.getModelById(resourceId);
        }
        return result;
    },
    /**
     * Sets the resource which the event should belong to.
     *
     * @param {Sch.model.Resource/Mixed} resource The new resource
     */
    setResource: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        eventStore && eventStore.removeAssignmentsForEvent(me);
        me.assign(resource);
    },
    /**
     * Assigns this event to the specified resource.
     *
     * @param {Sch.model.Resource/Mixed/Array} resource A new resource for this event, either as a full Resource record or an id (or an array of such).
     */
    assign: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        if (resource && resource.isResourceModel) {
            resource = resource.getId();
        }
        if (eventStore) {
            eventStore.assignEventToResource(me, resource);
        } else {
            me.setResourceId(resource);
        }
    },
    /**
     * Unassigns this event from the specified resources.
     *
     * @param {Sch.model.Resource/Mixed/Array} [resource] The resource (or list of resource) to unassign from.
     */
    unassign: function(resource) {
        var me = this,
            eventStore = me.getEventStore();
        if (resource && resource.isResourceModel) {
            resource = resource.getId();
        }
        if (eventStore) {
            eventStore.unassignEventFromResource(me, resource);
        } else if (me.getResourceId() == resource) {
            me.setResourceId(null);
        }
    },
    /**
     * Reassigns an event from an old resource to a new one.
     *
     * @param {Sch.model.Resource/Mixed} oldResource Old resource (or resource identifier) to unassign the event from.
     * @param {Sch.model.Resource/Mixed} newResource New resource (or resource identifier) to assign the event to.
     */
    reassign: function(oldResource, newResource) {
        var me = this,
            eventStore = me.getEventStore();
        if (oldResource && oldResource.isResourceModel) {
            oldResource = oldResource.getId();
        }
        if (newResource && newResource.isResourceModel) {
            newResource = newResource.getId();
        }
        if (eventStore) {
            eventStore.reassignEventFromResourceToResource(me, oldResource, newResource);
        } else {
            me.setResourceId(newResource);
        }
    },
    /**
     * @method isAssignedTo
     * Returns true if this event is assigned to a certain resource.
     *
     * @param {Sch.model.Resource/Mixed} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo: function(resource) {
        var me = this,
            eventStore = me.getEventStore(),
            result = false;
        if (resource && resource.isResourceModel) {
            resource = resource.getId();
        }
        if (eventStore) {
            result = eventStore.isEventAssignedToResource(me, resource);
        } else {
            result = me.getResourceId() == resource;
        }
        return result;
    },
    /**
     * Returns all assignments for the event. Event must be part of the store for this method to work.
     *
     * @return {Sch.model.Assignment[]}
     */
    getAssignments: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.getAssignmentsForEvent(me);
    },
    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */
    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable: function() {
        return this.getDraggable();
    },
    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */
    /**
     * @method getResourceId
     *
     * Returns the resource id of the resource that the event belongs to.
     * @return {Mixed} The resource Id
     */
    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable: function() {
        return this.getResizable();
    },
    /**
     * @method setResourceId
     *
     * Sets the new resource id of the resource that the event belongs to.
     * @param {Mixed} resourceId The resource Id
     */
    /**
     * Returns false if a linked resource is a phantom record, i.e. it's not persisted in the database.
     *
     * @return {Boolean} valid
     */
    isPersistable: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isEventPersistable(me);
    },
    /**
     * Returns event start date. If event {@link #AllDay} flag is set then date time part will be cleared
     *
     * @return {Date}
     */
    getStartDate: function() {
        var dt = this.data[this.startDateField];
        if (this.getAllDay()) {
            dt = this.statics().getAllDayStartDate(dt);
        }
        return dt;
    },
    /**
     * Returns event end date. If event {@link #AllDay} flag is set then date time part will be cleared and
     * date will be adjusted to point to the beginning of the next day.
     *
     * @return {Date}
     */
    getEndDate: function() {
        var dt = this.data[this.endDateField];
        if (this.getAllDay()) {
            dt = this.statics().getAllDayEndDate(dt);
        }
        return dt;
    },
    inheritableStatics: {
        getAllDayStartDate: function(dt) {
            if (dt instanceof Sch.model.Event) {
                dt = dt.get(dt.startDateField);
            }
            if (dt) {
                dt = Sch.util.Date.clearTime(dt, true);
            }
            return dt;
        },
        getAllDayEndDate: function(dt) {
            if (dt instanceof Sch.model.Event) {
                dt = dt.get(dt.endDateField);
            }
            if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {
                dt = Sch.util.Date.getNext(dt, 'd', 1);
            }
            return dt;
        },
        getAllDayDisplayStartDate: function(dt) {
            if (dt instanceof Sch.model.Event) {
                dt = dt.get(dt.startDateField);
            }
            return Sch.util.Date.clearTime(dt, true);
        },
        getAllDayDisplayEndDate: function(startDate, endDate) {
            var event = startDate;
            if (startDate instanceof Sch.model.Event) {
                startDate = event.get(event.startDateField);
                endDate = event.get(event.endDateField);
            }
            startDate = Sch.model.Event.getAllDayDisplayStartDate(startDate);
            // If date falls on start of the day - subtract one day to show end date correctly
            // e.g. event starts on 2017-01-01 00:00 and ends on 2017-01-02 00:00, editor should show
            // 2017-01-01 for both start and end
            if (Sch.util.Date.clearTime(endDate, true).valueOf() === endDate.valueOf()) {
                endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
            } else if (startDate.valueOf() !== endDate.valueOf()) {
                endDate = Sch.util.Date.clearTime(endDate, true);
            }
            return endDate;
        }
    }
});

/**
@class Sch.data.EventStore
@extends Ext.data.Store
@mixins Sch.data.mixin.EventStore
@mixins Sch.data.mixin.RecurringEvents

This is a class holding all the {@link Sch.model.Event events} to be rendered into a {@link Sch.SchedulerPanel scheduler panel}.
This class only accepts a model class inheriting from {@link Sch.model.Event}.
*/
Ext.define("Sch.data.EventStore", {
    extend: 'Ext.data.Store',
    alias: 'store.eventstore',
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.EventStore',
        'Robo.data.Store',
        'Sch.data.mixin.RecurringEvents'
    ],
    storeId: 'events',
    model: 'Sch.model.Event',
    config: {
        model: 'Sch.model.Event'
    },
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.resourceStore && me.setResourceStore(me.resourceStore);
        me.assignmentStore && me.setAssignmentStore(me.assignmentStore);
        if (me.getModel() !== Sch.model.Event && !(me.getModel().prototype instanceof Sch.model.Event)) {
            throw 'The model for the EventStore must subclass Sch.model.Event';
        }
        me.setupRecurringEvents();
    },
    /**
     * Appends a new record to the store
     * @param {Sch.model.Event} record The record to append to the store
     */
    append: function(record) {
        this.add(record);
    }
});

/**
 * @class Sch.data.mixin.ResourceStore
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Sch.data.ResourceStore} class ("usual" store) and {@link Sch.data.ResourceTreeStore} - tree store.
 *
 */
Ext.define("Sch.data.mixin.ResourceStore", {
    eventStore: null,
    /**
     * Returns the associated event store instance.
     *
     * @return {Sch.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore;
        if (me.eventStore !== eventStore) {
            oldStore = me.eventStore;
            me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.ResourceStore}   this
             * @param {Sch.data.EventStore|null} newEventStore
             * @param {Sch.data.EventStore|null} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },
    getScheduledEventsInTimeSpan: function(start, end, eventStore) {
        var events = [];
        var DATE = Sch.util.Date;
        eventStore = eventStore || this.getEventStore();
        Ext.Array.each(this.getRange(), function(resource) {
            Ext.Array.each(eventStore.getEventsForResource(resource), function(event) {
                if (event.intersectsRange(start, end)) {
                    events.push(event);
                }
            });
        });
        return events;
    }
});

/**
@class Sch.model.Resource

This class represent a single Resource in the scheduler chart. It's a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of the resource.

A Resource has only 2 mandatory fields - `Id` and `Name`. If you want to add more fields with meta data describing your resources then you should subclass this class:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],

        getCompany : function () {
            return this.get('Company');
        },
        ...
    });

If you want to use other names for the {@link #Id} and {@link #Name} fields you can configure them as seen below:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        nameField   : 'UserName',
        ...
    });

Please refer to {@link Sch.model.Customizable} for details.
*/
Ext.define('Sch.model.Resource', {
    extend: 'Sch.model.Customizable',
    isResourceModel: true,
    idProperty: 'Id',
    config: Ext.versions.touch ? {
        idProperty: 'Id'
    } : null,
    /**
     * @cfg {String} nameField The name of the field that holds the resource name.
     */
    nameField: 'Name',
    customizableFields: [
        /**
         * @field Id
         * A unique identifier of the resource
         */
        /**
         * @method getName
         *
         * Returns the resource name
         *
         * @return {String} The name of the resource
         */
        /**
         * @method setName
         *
         * Sets the resource name
         *
         * @param {String} name The new name of the resource
         */
        /**
         * @field
         * Name of the resource
         */
        {
            name: 'Name',
            type: 'string'
        }
    ],
    getInternalId: function() {
        return this.internalId;
    },
    /**
     * Returns a resource store this resource is part of. Resource must be part
     * of a resource store to be able to retrieve resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore: function() {
        return this.joined && this.joined[0] || this.getTreeStore && this.getTreeStore();
    },
    /**
     * Returns an event store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore: function() {
        var resourceStore = this.getResourceStore();
        return resourceStore && resourceStore.getEventStore() || this.parentNode && this.parentNode.getEventStore();
    },
    /**
     * Returns as assignment store this resources uses as default. Resource must be part
     * of a resource store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore: function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },
    /**
     * Returns an array of events, associated with this resource
     *
     * @param {Sch.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
     * @return {Sch.model.Range[]}
     */
    getEvents: function(eventStore) {
        var me = this;
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getEventsForResource(me) || [];
    },
    /**
     * Returns all assignments for the resource. Resource must be part of the store for this method to work.
     *
     * @return {[Sch.model.Assignment]}
     */
    getAssignments: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.getAssignmentsForResource(me);
    },
    /**
     * Returns true if the Resource can be persisted.
     * In a flat store resource is always considered to be persistable, in a tree store resource is considered to
     * be persitable if it's parent node is persistable.
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable: function() {
        var parent = this.parentNode;
        return !parent || !parent.phantom || (parent.isRoot && parent.isRoot());
    },
    /**
     * Returns true if this resource model is above the passed resource model
     * @param {Sch.model.Resource} otherResource
     * @return {Boolean}
     */
    isAbove: function(otherResource) {
        var me = this,
            store = me.getResourceStore(),
            result = false,
            current, myAncestors, otherAncestors, commonAncestorsLength, lastCommonAncestor;
        Ext.Assert && Ext.Assert.truthy(store, "Resource must be added to a store to be able to check if it above of an other resource");
        if (me == otherResource) {
            result = false;
        } else if (store && store.isTreeStore) {
            // Getting self ancestors this node including
            current = me;
            myAncestors = [];
            while (current) {
                myAncestors.push(current);
                current = current.parentNode;
            }
            // Getting other ancestors other node including
            current = otherResource;
            otherAncestors = [];
            while (current) {
                otherAncestors.push(current);
                current = current.parentNode;
            }
            // Getting common ancestors sequence length
            commonAncestorsLength = 0;
            while (commonAncestorsLength < myAncestors.length - 1 && commonAncestorsLength < otherAncestors.length - 1 && myAncestors[commonAncestorsLength] == otherAncestors[commonAncestorsLength]) {
                ++commonAncestorsLength;
            }
            // Getting last common ancesstor
            lastCommonAncestor = myAncestors[commonAncestorsLength];
            // Here the next ancestor in myAncestors and next ancesstor in otherAncestors are siblings and
            // thus designate which node is above
            me = myAncestors[commonAncestorsLength + 1];
            otherResource = otherAncestors[commonAncestorsLength + 1];
            result = lastCommonAncestor.indexOf(me) < lastCommonAncestor.indexOf(otherResource);
        } else {
            result = store.indexOf(me) < store.indexOf(otherResource);
        }
        return result;
    }
});

/**
@class Sch.data.ResourceStore
@extends Ext.data.Store
@mixins Sch.data.mixin.ResourceStore

This is a class holding the collection the {@link Sch.model.Resource resources} to be rendered into a {@link Sch.panel.SchedulerGrid scheduler panel}.
It is a subclass of {@link Ext.data.Store} - a store with linear data presentation.

*/
Ext.define("Sch.data.ResourceStore", {
    extend: 'Ext.data.Store',
    model: 'Sch.model.Resource',
    config: {
        model: 'Sch.model.Resource'
    },
    alias: 'store.resourcestore',
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore',
        'Robo.data.Store'
    ],
    storeId: 'resources',
    constructor: function() {
        this.callParent(arguments);
        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceStore must subclass Sch.model.Resource';
        }
    }
});

// TreeStore doesn't support rejectChanges very well
// https://www.sencha.com/forum/showthread.php?300339-rejectChanges-doesn-t-work-for-TreeStore-added-removed-records&p=1097116#post1097116
Ext.define('Sch.patches.TreeStore', {
    extend: 'Sch.util.Patch',
    target: 'Ext.data.TreeStore',
    minVersion: '5.1.0',
    overrides: {
        remove: function(node) {
            if (node.isModel) {
                return node.remove();
            } else if (node instanceof Array && node[0].isModel) {
                for (var i = 0; i < node.length; i++) {
                    node[i].remove();
                }
                return node;
            } else {
                return this.callParent(arguments);
            }
        }
    }
});

// byInternalIdMap is removed from 5.1.1 and it is widely used in projection mechanism
Ext.define('Sch.patches.TreeStoreInternalIdMap', {
    extend: 'Sch.util.Patch',
    target: 'Ext.data.TreeStore',
    minVersion: '5.1.1',
    overrides: {
        registerNode: function(node, includeChildren) {
            var me = this;
            if (!me.byInternalIdMap) {
                me.byInternalIdMap = {};
            }
            me.byInternalIdMap[node.internalId] = node;
            me.callParent(arguments);
        },
        unregisterNode: function(node, includeChildren) {
            var me = this;
            if (me.byInternalIdMap) {
                delete me.byInternalIdMap[node.internalId];
            }
            me.callParent(arguments);
        },
        updateRoot: function() {
            this.byInternalIdMap = {};
            this.callParent(arguments);
        }
    }
});

/**
@class Sch.data.mixin.FilterableTreeStore

This is a mixin for the Ext.data.TreeStore providing filtering functionality.

The functionality of this class can be divided into two sections:

Filtering
=========

Filtering of a tree store is different from filtering flat stores. In a flat store, all nodes (items)
are of the same type and on the same hierarchical level. Filtering can hide any nodes that not matching some criteria.

On the other hand, in tree stores some of the nodes represent parent nodes with child nodes
("parent", "folder", "group" etc) and other nodes are "leaves". And usually a "leaf" node can't be
sufficiently identified w/o its parents - i.e. it is important to know all the parents that
a particular leaf node belongs to. So when filtering tree stores, we need to show all parent nodes of the filtered nodes.

Moreover, filtering is usually being used for searching and thus should ignore the "expanded/collapsed"
state of tree nodes (we need to search among all nodes, including collapsed ones).

Filtering can be activated with the {@link #filterTreeBy} method and cleared with {@link #clearTreeFilter}.

Hiding/Showing nodes
====================

Sometimes we want to keep some nodes in the tree, but remove them from the visual presentation and hide them.
This can be done with {@link #hideNodesBy} method and {@link #showAllNodes} can be used to restore the previous state.
When a node is hidden, all its child nodes are hidden too.

"Hidden" nodes will never appear in filtered results - consider them removed from the tree store completely.
They will, however, appear in a data package for a `store.sync()` operation (you can override the the "filterUpdated" method to exclude them from there if needed).

Note, that it is possible to filter a store with hidden nodes, but not the other way around (hide some nodes of a filtered store).

*/
Ext.define("Sch.data.mixin.FilterableTreeStore", {
    isFilteredFlag: false,
    isHiddenFlag: false,
    treeFilter: null,
    // ref to the last filter applied
    lastTreeFilter: null,
    lastTreeHiding: null,
    /**
     * @cfg {Boolean} allowExpandCollapseWhileFiltered When enabled (by default), tree store allows user to expand/collapse nodes while it is
     * filtered with the {@link #filterTreeBy} method. Please set it explicitly to `false` to restore the previous behavior,
     * where collapse/expand operations were disabled.
     */
    allowExpandCollapseWhileFiltered: true,
    /**
     * @cfg {Boolean} keepExpandStateWhileFiltered When enabled, will keep the current expand/collapse state
     * of the nodes during filtering with {@link #filterTreeBy} method. Note, that some filtered in nodes,
     * can remain collapsed after filtering with this option.
     */
    keepExpandStateWhileFiltered: false,
    /**
     * @cfg {Boolean} reApplyFilterOnDataChange When enabled (by default), tree store will update the filtering (both {@link #filterTreeBy}
     * and {@link #hideNodesBy}) after new data is added to the tree or removed from it. Please set it explicitly to `false` to restore the previous behavior,
     * where this feature did not exist.
     * @deprecated Use {@link #reapplyFilterOnDataChange} instead
     */
    reApplyFilterOnDataChange: null,
    /**
     * @cfg {Boolean} reapplyFilterOnDataChange When enabled (by default), tree store will update the filtering (both {@link #filterTreeBy}
     * and {@link #hideNodesBy}) after new data is added to the tree or removed from it. Please set it explicitly to `false` to restore the previous behavior,
     * where this feature did not exist.
     */
    reapplyFilterOnDataChange: true,
    suspendIncrementalFilterRefresh: 0,
    filterGeneration: 0,
    currentFilterGeneration: null,
    dataChangeListeners: null,
    monitoringDataChange: false,
    filterUpdateSuspended: false,
    onClassMixedIn: function(cls) {
        cls.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {});
    },
    // Events (private)
    //    'filter-set',
    //    'filter-clear',
    //    'nodestore-datachange-start',
    //    'nodestore-datachange-end'
    /**
     * Should be called in the constructor of the consuming class, to activate the filtering functionality.
     */
    initTreeFiltering: function() {
        if (this.reApplyFilterOnDataChange != null) {
            this.reapplyFilterOnDataChange = this.reApplyFilterOnDataChange;
        }
        this.treeFilter = new Ext.util.Filter({
            filterFn: this.isNodeFilteredIn,
            scope: this
        });
        this.dataChangeListeners = {
            nodeappend: this.onNeedToUpdateFilter,
            nodeinsert: this.onNeedToUpdateFilter,
            scope: this
        };
        // in Ext 5.1.1 sencha apparently fixed some issue and now each 'endupdate' on filters
        // lead to view refresh. When store is loading, filter is applied to each record and each time view is refreshed.
        // This code suspend filters until 'load' event is fired
        Ext.apply(this.dataChangeListeners, {
            beforeload: this.onStoreBeforeLoad,
            load: this.onStoreLoad
        });
    },
    onStoreBeforeLoad: function() {
        this.filterUpdateSuspended = true;
    },
    onStoreLoad: function() {
        this.filterUpdateSuspended = false;
        this.onNeedToUpdateFilter();
    },
    startDataChangeMonitoring: function() {
        if (this.monitoringDataChange)  {
            return;
        }
        
        this.monitoringDataChange = true;
        this.on(this.dataChangeListeners);
    },
    stopDataChangeMonitoring: function() {
        if (!this.monitoringDataChange)  {
            return;
        }
        
        this.monitoringDataChange = false;
        this.un(this.dataChangeListeners);
    },
    onNeedToUpdateFilter: function() {
        if (this.reapplyFilterOnDataChange && !this.filterUpdateSuspended && !this.suspendIncrementalFilterRefresh)  {
            this.reapplyFilter();
        }
        
    },
    /**
     * Clears the current filter (if any).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    clearTreeFilter: function() {
        if (!this.isTreeFiltered())  {
            return;
        }
        
        this.currentFilterGeneration = null;
        this.isFilteredFlag = false;
        this.lastTreeFilter = null;
        if (!this.isTreeFiltered(true))  {
            this.stopDataChangeMonitoring();
        }
        
        this.refreshNodeStoreContent();
        this.fireEvent('filter-clear', this);
    },
    /**
     * Reapplies the last filter passed
     */
    reapplyFilter: function() {
        // bypass the nodeStore content refresh if store has both hiding and filtering
        if (this.isHiddenFlag)  {
            this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag));
        }
        
        if (this.isFilteredFlag)  {
            this.filterTreeBy(this.lastTreeFilter);
        }
        
    },
    // Leaving it here for BW compatibility
    reApplyFilter: function() {
        this.reapplyFilter();
    },
    refreshNodeStoreContent: function() {
        var me = this,
            filters = me.getFilters();
        if (filters.indexOf(me.treeFilter) < 0) {
            me.addFilter(me.treeFilter);
        } else {
            this.getFilters().fireEvent('endupdate', this.getFilters());
        }
    },
    getIndexInTotalDataset: function(record) {
        var root = this.getRootNode(),
            index = -1;
        var rootVisible = this.rootVisible;
        if (!rootVisible && record == root)  {
            return -1;
        }
        
        var isFiltered = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;
        var collectNodes = function(node) {
                if (isFiltered && node.__filterGen != currentFilterGeneration || node.hidden)  {
                    // stop scanning if record we are looking for is hidden
                    if (node == record)  {
                        return false;
                    }
                    ;
                }
                
                if (rootVisible || node != root)  {
                    index++;
                }
                
                // stop scanning if we found the record
                if (node == record)  {
                    return false;
                }
                
                if (!node.isLeaf() && node.isExpanded()) {
                    var childNodes = node.childNodes,
                        length = childNodes.length;
                    for (var k = 0; k < length; k++) if (collectNodes(childNodes[k]) === false)  {
                        return false;
                    }
                    
                }
            };
        collectNodes(root);
        return index;
    },
    /**
     * Returns true if this store is currently filtered
     *
     * @return {Boolean}
     */
    isTreeFiltered: function(orHasHiddenNodes) {
        return this.isFilteredFlag || orHasHiddenNodes && this.isHiddenFlag;
    },
    markFilteredNodes: function(top, params) {
        var me = this;
        var filterGen = this.currentFilterGeneration;
        var visibleNodes = {};
        var root = this.getRootNode(),
            rootVisible = this.rootVisible;
        var includeParentNodesInResults = function(node) {
                var parent = node.parentNode;
                while (parent && !visibleNodes[parent.internalId]) {
                    visibleNodes[parent.internalId] = true;
                    parent = parent.parentNode;
                }
            };
        var filter = params.filter;
        var scope = params.scope || this;
        var shallowScan = params.shallow;
        var checkParents = params.checkParents || shallowScan;
        var fullMatchingParents = params.fullMatchingParents;
        var onlyParents = params.onlyParents || fullMatchingParents;
        var isNewFilter = !params.isOldFilter;
        //  If this filter is a reapplied filter or a brand new
        if (onlyParents && checkParents)  {
            throw new Error("Can't combine `onlyParents` and `checkParents` options");
        }
        
        if (rootVisible)  {
            visibleNodes[root.internalId] = true;
        }
        
        var collectNodes = function(node) {
                if (node.hidden)  {
                    return;
                }
                
                var nodeMatches, childNodes, length, k;
                // `collectNodes` should not be called for leafs at all
                if (node.isLeaf()) {
                    if (filter.call(scope, node, visibleNodes)) {
                        visibleNodes[node.internalId] = true;
                        includeParentNodesInResults(node);
                    }
                } else {
                    if (onlyParents) {
                        nodeMatches = filter.call(scope, node);
                        childNodes = node.childNodes;
                        length = childNodes.length;
                        if (nodeMatches) {
                            visibleNodes[node.internalId] = true;
                            includeParentNodesInResults(node);
                            // if "fullMatchingParents" option enabled we gather all matched parent's sub-tree
                            if (fullMatchingParents) {
                                node.cascadeBy(function(currentNode) {
                                    visibleNodes[currentNode.internalId] = true;
                                });
                                return;
                            }
                        }
                        // at this point nodeMatches and fullMatchingParents can't be both true
                        for (k = 0; k < length; k++) if (nodeMatches && childNodes[k].isLeaf())  {
                            visibleNodes[childNodes[k].internalId] = true;
                        }
                        else if (!childNodes[k].isLeaf())  {
                            collectNodes(childNodes[k]);
                        }
                        
                    } else {
                        // mark matching nodes to be kept in results
                        if (checkParents) {
                            nodeMatches = filter.call(scope, node, visibleNodes);
                            if (nodeMatches) {
                                visibleNodes[node.internalId] = true;
                                includeParentNodesInResults(node);
                            }
                        }
                        // recurse if
                        // - we don't check parents
                        // - shallow scan is not enabled
                        // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                        if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                            childNodes = node.childNodes;
                            length = childNodes.length;
                            for (k = 0; k < length; k++) collectNodes(childNodes[k]);
                        }
                    }
                }
            };
        collectNodes(top);
        // additional filtering of the result set
        // removes parent nodes which do not match filter themselves and have no matching children
        root.cascadeBy(function(node) {
            if (isNewFilter) {
                node.addedWhileFiltered = false;
            }
            if (visibleNodes[node.internalId]) {
                node.__filterGen = filterGen;
                if (!me.keepExpandStateWhileFiltered && !node.isLeaf())  {
                    node.expand();
                }
                
            }
        });
    },
    /**
     * This method filters the tree store. It accepts an object with the following properties:
     *
     * - `filter` - a function to check if a node should be included in the result. It will be called for each **leaf** node in the tree and will receive the current node as the first argument.
     * It should return `true` if the node should remain visible, `false` otherwise. The result will also contain all parents nodes of all matching leafs. Results will not include
     * parent nodes, which do not have at least one matching child.
     * To call this method for parent nodes too, pass an additional parameter - `checkParents` (see below).
     * - `scope` - a scope to call the filter with (optional)
     * - `checkParents` - when set to `true` will also call the `filter` function for each parent node. If the function returns `false` for some parent node,
     * it could still be included in the filtered result if some of its children match the `filter` (see also "shallow" option below). If the function returns `true` for a parent node, it will be
     * included in the filtering results even if it does not have any matching child nodes.
     * - `shallow` - implies `checkParents`. When set to `true`, it will stop checking child nodes if the `filter` function return `false` for a parent node. The whole sub-tree, starting
     * from a non-matching parent, will be excluded from the result in such case.
     * - `onlyParents` - alternative to `checkParents`. When set to `true` it will only call the provided `filter` function for parent tasks. If
     * the filter returns `true`, the parent and all its direct child leaf nodes will be included in the results. If the `filter` returns `false`, a parent node still can
     * be included in the results (w/o direct children leafs), if some of its child nodes matches the filter.
     * - `fullMatchingParents` - implies `onlyParents`. In this mode, if a parent node matches the filter, then not only its direct children
     * will be included in the results, but the whole sub-tree, starting from the matching node.
     *
     * Repeated calls to this method will clear previous filters.
     *
     * This function can be also called with 2 arguments, which should be the `filter` function and `scope` in such case.
     *
     * For example:

    treeStore.filterTreeBy({
        filter          : function (node) { return node.get('name').match(/some regexp/) },
        checkParents    : true
    })

    // or, if you don't need to set any options:
    treeStore.filterTreeBy(function (node) { return node.get('name').match(/some regexp/) })

     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Object} params
     */
    filterTreeBy: function(params, scope) {
        this.currentFilterGeneration = this.filterGeneration++;
        var filter;
        if (arguments.length == 1 && Ext.isObject(arguments[0])) {
            scope = params.scope;
            filter = params.filter;
        } else {
            filter = params;
            params = {
                filter: filter,
                scope: scope
            };
        }
        this.fireEvent('nodestore-datachange-start', this);
        params = params || {};
        this.markFilteredNodes(this.getRootNode(), params);
        params.isOldFilter = true;
        this.startDataChangeMonitoring();
        this.isFilteredFlag = true;
        this.lastTreeFilter = params;
        //this.fireEvent('clear', this);
        this.fireEvent('nodestore-datachange-end', this);
        this.fireEvent('filter-set', this);
        this.refreshNodeStoreContent();
    },
    isNodeFilteredIn: function(node) {
        var isFiltered = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;
        return this.loading || (// If node was added with active filter, it should always be shown if (reapplyFilterOnDataChange) until
        // the next call to filterTreeBy
        node.addedWhileFiltered && node.isVisible()) || !Boolean(isFiltered && node.__filterGen != currentFilterGeneration || node.hidden);
    },
    hasNativeFilters: function() {
        var me = this,
            filters = me.getFilters(),
            count = filters.getCount();
        return (count && count > 1) || filters.indexOf(me.treeFilter) < 0;
    },
    /**
     * Hide nodes from the visual presentation of tree store (they still remain in the store).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Function} filter - A filtering function. Will be called for each node in the tree store and receive
     * the current node as the 1st argument. Should return `true` to **hide** the node
     * and `false`, to **keep it visible**.
     * @param {Object} scope (optional).
     */
    hideNodesBy: function(filter, scope, skipNodeStoreRefresh) {
        var me = this;
        if (me.isFiltered() && me.hasNativeFilters())  {
            throw new Error("Can't hide nodes of a filtered tree store");
        }
        
        scope = scope || me;
        me.getRootNode().cascadeBy(function(node) {
            node.hidden = Boolean(filter.call(scope, node, me));
        });
        me.startDataChangeMonitoring();
        me.isHiddenFlag = true;
        me.lastTreeHiding = [
            filter,
            scope
        ];
        if (!skipNodeStoreRefresh)  {
            me.refreshNodeStoreContent();
        }
        
    },
    /**
     * Shows all nodes that was previously hidden with {@link #hideNodesBy}
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    showAllNodes: function(skipNodeStoreRefresh) {
        this.getRootNode().cascadeBy(function(node) {
            node.hidden = false;
        });
        this.isHiddenFlag = false;
        this.lastTreeHiding = null;
        if (!this.isTreeFiltered(true))  {
            this.stopDataChangeMonitoring();
        }
        
        if (!skipNodeStoreRefresh)  {
            this.refreshNodeStoreContent();
        }
        
    },
    inheritables: function() {
        return {
            // @OVERRIDE
            onNodeExpand: function(parent) {
                if (this.isTreeFiltered(true) && parent == this.getRoot()) {
                    this.callParent(arguments);
                    // the expand of the root node - most probably its the data loading
                    this.reapplyFilter();
                } else  {
                    return this.callParent(arguments);
                }
                
            },
            // @OVERRIDE
            onNodeCollapse: function(parent, records) {
                var me = this;
                var data = me.data;
                var prevContains = data.contains;
                var isFiltered = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;
                // the default implementation of `onNodeCollapse` only checks if the 1st record from collapsed nodes
                // exists in the node store. Meanwhile, that 1st node can be hidden, so we need to check all of them
                // thats what we do in the `for` loop below
                // then, if we found a node, we want to do actual removing of nodes and we override the original code from NodeStore
                // by always returning `false` from our `data.contains` override
                data.contains = function() {
                    var node, sibling, lastNodeIndexPlus;
                    var collapseIndex = me.indexOf(parent) + 1;
                    var found = false;
                    for (var i = 0; i < records.length; i++) if (!(records[i].hidden || isFiltered && records[i].__filterGen != currentFilterGeneration) && prevContains.call(this, records[i])) {
                        // this is our override for internal part of `onNodeCollapse` method
                        // Calculate the index *one beyond* the last node we are going to remove
                        // Need to loop up the tree to find the nearest view sibling, since it could
                        // exist at some level above the current node.
                        node = parent;
                        while (node.parentNode) {
                            sibling = node;
                            do {
                                sibling = sibling.nextSibling;
                            } while (sibling && (sibling.hidden || isFiltered && sibling.__filterGen != currentFilterGeneration));
                            if (sibling) {
                                found = true;
                                lastNodeIndexPlus = me.indexOf(sibling);
                                break;
                            } else {
                                node = node.parentNode;
                            }
                        }
                        if (!found) {
                            lastNodeIndexPlus = me.getCount();
                        }
                        // Remove the whole collapsed node set.
                        me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
                        break;
                    }
                    // always return `false`, so original NodeStore code won't execute
                    return false;
                };
                this.callParent(arguments);
                // HACK in case no records are deemed visible we need to handle things ourselves
                if (this.isTreeFiltered()) {
                    if (me.needsLocalFilter()) {
                        records = Ext.Array.filter(records, me.filterVisible);
                    }
                    // 'parent' can be filtered out, in such case we don't need to remove anything
                    // covered by 124_tree_filter
                    if (!records.length && me.indexOf(parent) !== -1) {
                        var collapseIndex = me.indexOf(parent) + 1;
                        var lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);
                        me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
                    }
                }
                data.contains = prevContains;
            },
            // @OVERRIDE
            handleNodeExpand: function(parent, records, toAdd) {
                var me = this;
                var visibleRecords = [];
                var isFiltered = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    if (!(isFiltered && record.__filterGen != currentFilterGeneration || record.hidden)) {
                        visibleRecords[visibleRecords.length] = record;
                    }
                }
                return this.callParent([
                    parent,
                    visibleRecords,
                    toAdd
                ]);
            },
            // @OVERRIDE
            onNodeInsert: function(parent, node, index) {
                var me = this,
                    data = node.raw || node.data,
                    // Must use class-specific removedNodes property.
                    // Regular Stores add to the "removed" property on CollectionRemove.
                    // TreeStores are having records removed all the time; node collapse removes.
                    // TreeStores add to the "removedNodes" property onNodeRemove
                    removed = me.removedNodes,
                    storeReader, nodeProxy, nodeReader, reader, dataRoot, storeInsertionPoint,
                    // OVERRIDE: added vars
                    isTreeFiltered = this.isTreeFiltered();
                // OVERRIDE: removed this block
                // if (parent && me.needsLocalFilter()) {
                //     me.doFilter(parent);
                // }
                // OVERRIDE: added this block
                if (me.filterFn) {
                    var isVisible = me.filterFn(node);
                    node.set('visible', isVisible);
                    // If a node which passes the filter is added to a parent node
                    if (isVisible) {
                        parent.set('visible', me.filterFn(parent));
                    }
                }
                // OVERRIDE: added this block
                if (!this.reapplyFilterOnDataChange && isTreeFiltered) {
                    node.addedWhileFiltered = true;
                }
                // OVERRIDE: added registerNode
                // Register node by its IDs
                me.registerNode(node, true);
                me.beginUpdate();
                // Only react to a node append if it is to a node which is expanded.
                // OVERRIDE: added (isTreeFiltered && node.addedWhileFiltered) to the condition
                if (me.isVisible(node) || (isTreeFiltered && node.addedWhileFiltered)) {
                    // Calculate the insertion point into the flat store.
                    // If the new node is the first, then it goes after the parent node.
                    if (index === 0 || !node.previousSibling) {
                        storeInsertionPoint = me.indexOf(parent);
                    } else // Otherwise it has to go after the previous visible node which has
                    // to be calculated. See indexOfPreviousVisibleNode for explanation.
                    {
                        storeInsertionPoint = me.indexOfPreviousVisibleNode(node.previousSibling);
                    }
                    // The reaction to collection add joins the node to this Store
                    me.insert(storeInsertionPoint + 1, node);
                    if (!node.isLeaf() && node.isExpanded()) {
                        if (node.isLoaded()) {
                            // Take a shortcut
                            me.onNodeExpand(node, node.childNodes);
                        } else if (!me.fillCount) {
                            // If the node has been marked as expanded, it means the children
                            // should be provided as part of the raw data. If we're filling the nodes,
                            // the children may not have been loaded yet, so only do this if we're
                            // not in the middle of populating the nodes.
                            node.set('expanded', false);
                            node.expand();
                        }
                    }
                }
                // In case the node was removed and added to the removed nodes list.
                Ext.Array.remove(removed, node);
                // New nodes mean we need a sync if those nodes are phantom or dirty (have client-side only
                // information)
                me.needsSync = me.needsSync || node.phantom || node.dirty;
                if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
                    // With heterogeneous nodes, different levels may require differently configured readers
                    // to extract children. For example a "Disk" node type may configure it's proxy reader
                    // with root: 'folders', while a "Folder" node type might configure its proxy reader
                    // with root: 'files'. Or the root property could be a configured-in accessor.
                    storeReader = me.getProxy().getReader();
                    nodeProxy = node.getProxy();
                    nodeReader = nodeProxy ? nodeProxy.getReader() : null;
                    // If the node's reader was configured with a special root (property name which defines
                    // the children array) use that.
                    reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
                    dataRoot = reader.getRoot(data);
                    if (dataRoot) {
                        // OVERRIDE: replaced fillNode
                        // me.fillNode(node, reader.extractData(dataRoot, {
                        //     model: node.childType,
                        //     recordCreator: me.recordCreator
                        // }));
                        var childType = node.childType;
                        me.fillNode(node, reader.extractData(dataRoot, childType ? {
                            model: childType
                        } : undefined));
                    }
                }
                me.endUpdate();
            },
            isFiltered: function() {
                return this.callParent(arguments) || this.isTreeFiltered();
            },
            afterEdit: function(node, modifiedFieldNames) {
                var me = this;
                // Ext.data.AbstractStore.getFilters autocreates filters collection, if it hasn't been created yet.
                // Call in explicitly to do not rely on needsLocalFilter function.
                me.getFilters();
                // In Ext 6.0.2 sencha decided that tree should be filtered again after data is changed
                // Prior to 6.0.2 they used to apply filter only to new node.
                // Important to check "needsLocalFilter" first to instantiate filters (see #9474),
                // because Sencha does it in treeStore, but in this override we call plain store method,
                // so filters are not instantiated if the first part of the condition is false
                if (me.needsLocalFilter() && me.reapplyFilterOnDataChange) {
                    me.doFilter(node);
                }
                Ext.data.Store.prototype.afterEdit.apply(me, [
                    node,
                    modifiedFieldNames
                ]);
            }
        };
    }
});

/**
 * @class Sch.data.ResourceTreeStore
 * @extends Ext.data.TreeStore
 * @mixins Sch.data.mixin.FilterableTreeStore
 *
 * This is a class holding all the resources to be rendered into a {@link Sch.panel.SchedulerTree}. It is a subclass of "Ext.data.TreeStore" - a store containing hierarchical data.
 *
 * Filtering capabilities are provided by {@link Sch.data.mixin.FilterableTreeStore}, please refer to its documentation for additional information.
 */
Ext.define("Sch.data.ResourceTreeStore", {
    extend: 'Ext.data.TreeStore',
    requires: [
        'Sch.patches.TreeStore',
        'Sch.patches.TreeStoreInternalIdMap'
    ],
    mixins: [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore',
        'Sch.data.mixin.FilterableTreeStore',
        'Robo.data.Store'
    ],
    alias: 'store.resourcetreestore',
    model: 'Sch.model.Resource',
    storeId: 'resources',
    constructor: function() {
        this.callParent(arguments);
        this.initTreeFiltering();
        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceTreeStore must subclass Sch.model.Resource';
        }
    },
    setRootNode: function() {
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        this.isSettingRoot = true;
        var res = this.callParent(arguments);
        this.isSettingRoot = false;
        return res;
    }
});

/*
 * @class Sch.model.TimeAxisTick
 * @extends Sch.model.Range
 *
 * A simple model with a start/end date interval defining a 'tick' on the time axis.
 */
Ext.define('Sch.model.TimeAxisTick', {
    extend: 'Sch.model.Range',
    isTimeAxisTickModel: true,
    startDateField: 'start',
    endDateField: 'end'
});

/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuous mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling {@link #clearFilter} will return you to a full time axis.

*/
Ext.define("Sch.data.TimeAxis", {
    extend: "Ext.data.JsonStore",
    requires: [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],
    model: 'Sch.model.TimeAxisTick',
    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous: true,
    originalContinuous: null,
    /**
     * @cfg {Boolean} autoAdjust
     * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
     * may lead to shifting time/date of ticks.
     */
    autoAdjust: true,
    unit: null,
    increment: null,
    resolutionUnit: null,
    resolutionIncrement: null,
    weekStartDay: null,
    mainUnit: null,
    shiftUnit: null,
    shiftIncrement: 1,
    defaultSpan: 1,
    isConfigured: false,
    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart: null,
    adjustedEnd: null,
    // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
    visibleTickStart: null,
    // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
    visibleTickEnd: null,
    // name of the current preset
    presetName: null,
    /**
     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for weekview we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'week']
     * @private
     */
    mode: 'plain',
    /**
     * @cfg {Number} startTime Start time for weekview mode, used only with day/week presets.
     */
    startTime: 0,
    /**
     * @cfg {Number} endTime End time for weekview mode, used only with day/week presets.
     */
    endTime: 24,
    /**
     * @cfg {Number} timeZone
     * Difference in **minutes** between UTC and expected time zone. Examples:
     *
     * ```
     * 120  : +2 hours from UTC
     * 0    : UTC
     * -180 : -3 hours from UTC
     * ```
     *
     * Default value `null` means current system timeZone is used.
     *
     * **NOTE**: DST transitions are not supported, this config only specifies time zone offset from UTC. If value is
     * 0, UTC time zone is used. UTC time zone has no DST.
     */
    timeZone: null,
    /**
     * @event beforereconfigure
     * @preventable
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */
    /**
     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */
    /**
     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */
    // private
    constructor: function(config) {
        var me = this;
        config = config || {};
        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }
        me.setMode(config.mode || me.mode);
        me.originalContinuous = me.continuous;
        me.callParent(arguments);
        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function() {
            me.fireEvent('reconfigure', me, false);
        });
        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });
        if (config.viewPreset) {
            var preset = Sch.preset.Manager.getPreset(config.viewPreset);
            preset && me.consumeViewPreset(preset);
        }
        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },
    /**
     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
     * @param {Object} config
     * @param {Boolean} [suppressRefresh]
     * @private
     */
    reconfigure: function(config, suppressRefresh) {
        this.isConfigured = true;
        Ext.apply(this, config);
        var adjusted = this.getAdjustedDates(config.start, config.end, true);
        var normalized = this.getAdjustedDates(config.start, config.end);
        var start = normalized.start;
        var end = normalized.end;
        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {
            this._isTickLengthVarying = null;
            this._hasTimeZone = null;
            this.fireEvent('beginreconfigure', this);
            var unit = this.unit;
            var increment = this.increment || 1;
            var ticks = this.generateTicks(start, end, unit, increment);
            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);
            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();
            var DATE = Sch.util.Date;
            var count = ticks.length;
            if (this.isContinuous()) {
                this.adjustedStart = adjusted.start;
                // For timeZone we don't want any extra date skipping
                this.adjustedEnd = this.hasTimeZone() ? adjusted.end : this.getNext(count > 1 ? ticks[count - 1].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart = this.getStart();
                this.adjustedEnd = this.getEnd();
            }
            var tickScale = DATE.getUnitDurationInMs(unit) * increment;
            // Normally time axis expects every tick to be equal in size. If ticks are not equal, it uses visibleTickStart
            // logic to correct for partial ticks.
            // But in case of timezones visibleTickStart approach doesn't work. First and last ticks could be partial, but
            // lookups on them has to be normal. We need property similar to visibleTickStart, but working in a different way
            if (this.hasTimeZone()) {
                this.timezoneTickStart = 1 - (this.first().getEndDate() - this.first().getStartDate()) / tickScale;
                this.timezoneTickEnd = count - 1 + (this.last().getEndDate() - this.last().getStartDate()) / tickScale;
            }
            // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust "adjustedStart" accordingly
            do {
                this.visibleTickStart = (this.getStart() - this.adjustedStart) / tickScale;
                if (this.visibleTickStart >= 1)  {
                    this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment, this.weekStartDay, this.timeZone);
                }
                
            } while (// TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
            this.visibleTickStart >= 1);
            do {
                this.visibleTickEnd = count - (this.adjustedEnd - this.getEnd()) / tickScale;
                if (count - this.visibleTickEnd >= 1)  {
                    this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1, this.weekStartDay, this.timeZone);
                }
                
            } while (count - this.visibleTickEnd >= 1);
            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },
    isWeek: function() {
        return this.mode !== 'plain';
    },
    hasTimeZone: function() {
        if (this._hasTimeZone == null) {
            this._hasTimeZone = this.timeZone != null && Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.unit) >= 0 && (// Do not adjust timeline if local timezone is same as configured
            // Do not run this check for UTC0 which we treat as UTC timezone, not London standard time
            this.timeZone === 0 || (!this.first() || this.first() && this.getStart().getTimezoneOffset() !== -this.timeZone));
        }
        return this._hasTimeZone;
    },
    isUTCTimeZone: function() {
        return this.hasTimeZone() && this.timeZone === 0;
    },
    roundDateInTimeZone: function(value, roundingMethod) {
        var isUTC = this.isUTCTimeZone();
        if (!isUTC) {
            value = this.toTimeZone(value);
        }
        if (roundingMethod) {
            if (isUTC && roundingMethod === 'floor') {
                value = this.floorUTCDate(value);
            } else if (roundingMethod === 'round') {
                var relativeTo = this.getStart();
                if (Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.unit) <= 0) {
                    if (isUTC) {
                        relativeTo = this.floorUTCDate(relativeTo);
                    } else {
                        relativeTo = this.fromTimeZone(relativeTo);
                    }
                }
                value = this.roundDate(value, relativeTo);
            } else {
                value = this[roundingMethod + 'Date'](value);
            }
        }
        return value;
    },
    // In case unit is day ticks may have different length and would require more complex lookup
    isTickLengthVarying: function() {
        if (this._isTickLengthVarying == null) {
            this._isTickLengthVarying = this.hasTimeZone() && (// With timeZone ticks will have different width in case tick unit is day
            this.unit === Sch.util.Date.DAY || // or hour with sub-hour timeZone offset, e.g. UTC+03:30
            this.unit === Sch.util.Date.HOUR && this.timeZone % 60 !== 0);
        }
        return this._isTickLengthVarying;
    },
    setMode: function(mode) {
        this.mode = mode;
        if (this.isWeek()) {
            this.generateTicksValidatorFn = function(start) {
                if (this.startTime > 0 || this.endTime < 24) {
                    return (start.getHours() >= this.startTime && start.getHours() < this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function() {
                return true;
            };
        }
    },
    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} start The new start date
     * @param {Date} end The new end date
     * @param {Number} timeZone (Optional) New timeZone
     */
    setTimeSpan: function(start, end, timeZone) {
        var adjusted = this.getAdjustedDates(start, end);
        start = adjusted.start;
        end = adjusted.end;
        timeZone = timeZone === undefined ? this.timeZone : timeZone;
        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0 || this.timeZone != timeZone) {
            this.reconfigure({
                start: start,
                end: end,
                timeZone: timeZone
            });
        }
    },
    setTimeZone: function(timeZone) {
        if (timeZone != null && timeZone !== this.timeZone) {
            this.setTimeSpan(this.getStart(), this.getEnd(), timeZone);
        }
    },
    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy: function(fn, scope) {
        this.continuous = false;
        scope = scope || this;
        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([
            {
                filterFn: function(t, index) {
                    return fn.call(scope, t.data, index);
                }
            }
        ]);
        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },
    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous: function() {
        var result = this.continuous && !this.isFiltered();
        if (this.isWeek()) {
            result = result && this.startTime === 0 && this.endTime === 24;
        }
        return result;
    },
    /**
     * Clear the current filter of the time axis
     */
    clearFilter: function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },
    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} start The start date of the interval
     * @param {Date} end The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Number} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks: function(start, end, unit, increment) {
        var ticks = [],
            intervalEnd,
            DATE = Sch.util.Date,
            dstDiff = 0;
        unit = unit || this.unit;
        increment = increment || this.increment;
        var adjusted = this.getAdjustedDates(start, end);
        start = adjusted.start;
        end = adjusted.end;
        while (start < end) {
            intervalEnd = this.getNext(start, unit, increment);
            if ((!this.autoAdjust || this.hasTimeZone()) && intervalEnd > end) {
                intervalEnd = end;
            }
            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            // Do not correct for UTC time zone, it should have no DST
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0 && !this.isUTCTimeZone()) {
                var prev = ticks[ticks.length - 1];
                dstDiff = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();
                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }
            this.generateTicksValidatorFn(start) && ticks.push({
                start: start,
                end: intervalEnd
            });
            start = intervalEnd;
        }
        return ticks;
    },
    getVisibleTickTimeSpan: function() {
        var result;
        // Filtered time axis with uneven ticks is not supported yet
        if (this.hasTimeZone() && this.isContinuous()) {
            result = this.timezoneTickEnd - this.timezoneTickStart;
        } else if (this.isContinuous()) {
            result = this.visibleTickEnd - this.visibleTickStart;
        } else {
            result = this.getCount();
        }
        return result;
    },
    // Given that _adjusted_ date will be different date from same time zone - this method is NOT idempotent.
    // For this reason it cannot be embedded into getAdjustedDate call, since that method IS idempotent and called multiple
    // times for same dates.
    // Returns date and time in the requested time zone, if you ignore timeZone offset of the returned value
    toTimeZone: function(date) {
        date = new Date(date);
        if (this.hasTimeZone()) {
            date = Sch.util.Date.toTimeZone(date, this.timeZone);
        }
        return date;
    },
    fromTimeZone: function(date) {
        date = new Date(date);
        if (this.hasTimeZone()) {
            date = Sch.util.Date.fromTimeZone(date, this.timeZone);
        }
        return date;
    },
    getAdjustedDates: function(start, end, forceAdjust) {
        var DATE = Sch.util.Date;
        start = start || this.getStart();
        end = end || DATE.add(start, this.mainUnit, this.defaultSpan);
        if (this.isWeek()) {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit);
                    end = this.ceilDate(end, false, this.mainUnit);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start: start,
                        end: end
                    };
                }
            }
            var adjustedStart, adjustedEnd, clone;
            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            adjustedStart = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart = this.floorDate(adjustedStart, false, this.mainUnit, 1);
            // https://www.assembla.com/spaces/bryntum/tickets/2811
            // Disabled autoAdjust will allow to show any time span
            if (this.autoAdjust) {
                clone = this.getNext(start, this.shiftUnit, 1);
                adjustedEnd = this.ceilDate(clone, false, this.shiftUnit);
                adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
            } else {
                adjustedEnd = this.ceilDate(end, false, this.shiftUnit);
                adjustedEnd = this.ceilDate(adjustedEnd, false, this.mainUnit);
            }
            return {
                start: adjustedStart,
                end: adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start: this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end: this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start: start,
                end: end
            };
        }
    },
    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate: function(date) {
        var ticks = this.data.items;
        var lastTickIndex = ticks.length - 1;
        // quick bailout
        if (date.valueOf() < ticks[0].data.start.valueOf() || date.valueOf() > ticks[lastTickIndex].data.end.valueOf()) {
            return -1;
        }
        var tick, tickStart, tickEnd;
        if (this.isContinuous() && !(this.hasTimeZone() && this.isTickLengthVarying())) {
            if (date - ticks[0].data.start === 0)  {
                return this.visibleTickStart;
            }
            
            if (date - ticks[lastTickIndex].data.end === 0)  {
                return this.visibleTickEnd;
            }
            
            var adjustedStart = this.adjustedStart;
            var adjustedEnd = this.adjustedEnd;
            var tickIndex = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));
            // for the date == adjustedEnd case
            if (tickIndex > lastTickIndex)  {
                tickIndex = lastTickIndex;
            }
            
            tickStart = tickIndex === 0 ? adjustedStart : ticks[tickIndex].data.start;
            tickEnd = tickIndex == lastTickIndex ? adjustedEnd : ticks[tickIndex].data.end;
            tick = tickIndex + (date - tickStart) / (tickEnd - tickStart);
            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // but still
            if (tick < this.visibleTickStart || tick > this.visibleTickEnd)  {
                return -1;
            }
            
            return tick;
        } else {
            for (var i = 0; i <= lastTickIndex; i++) {
                tickEnd = ticks[i].data.end;
                if (date <= tickEnd) {
                    tickStart = ticks[i].data.start;
                    // date < tickStart can occur in filtered case
                    tick = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);
                    return tick;
                }
            }
        }
        return -1;
    },
    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Number} tick the tick "coordinate"
    * @param {String} [roundingMethod] The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick: function(tick, roundingMethod) {
        if (tick === this.visibleTickEnd || (// On a filtered timeaxis check if we received last tick
        !this.isContinuous() && tick === this.getCount())) {
            return this.getEnd();
        }
        var wholeTick = Math.floor(tick),
            fraction = tick - wholeTick,
            t = this.getAt(wholeTick);
        if (!t)  {
            return null;
        }
        
        var tickData = t.data;
        var start = wholeTick === 0 && this.isContinuous() ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end = (wholeTick === this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : tickData.end;
        var date = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));
        if (roundingMethod) {
            date = this[roundingMethod + 'Date'](date);
        }
        return date;
    },
    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks: function() {
        var ticks = [];
        this.each(function(r) {
            ticks.push(r.data);
        });
        return ticks;
    },
    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart: function() {
        var first = this.first();
        if (first) {
            return first.data.start;
        }
        return null;
    },
    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd: function() {
        var last = this.last();
        if (last) {
            return last.data.end;
        }
        return null;
    },
    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate: function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;
        var dt = Ext.Date.clone(date),
            relativeTo = relativeToStart ? this.getStart() : null,
            increment = incr || this.resolutionIncrement,
            unit;
        if (resolutionUnit) {
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }
        var DATE = Sch.util.Date;
        var snap = function(value, increment) {
                return Math.floor(value / increment) * increment;
            };
        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                };
                break;
            case DATE.SECOND:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setUTCMilliseconds(0);
                    dt.setUTCSeconds(snap(dt.getUTCSeconds(), increment));
                };
                break;
            case DATE.MINUTE:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setUTCMinutes(snap(dt.getUTCMinutes(), increment));
                    dt.setUTCSeconds(0);
                    dt.setUTCMilliseconds(0);
                };
                break;
            case DATE.HOUR:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt = this.floorUTCDate(dt, unit, increment);
                };
                break;
            case DATE.DAY:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                };
                break;
            case DATE.WEEK:
                var day = dt.getDay() || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);
                dt = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));
                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay && dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                };
                break;
            case DATE.MONTH:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                };
                break;
            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = DATE.add(dt, DATE.MONTH, -(dt.getMonth() % 3));
                break;
            case DATE.YEAR:
                if (relativeToStart) {
                    dt = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    var fullYear = snap(date.getFullYear() - 1, increment) + 1;
                    // Using setFullYear to handle case when year is in range 0-99 (0-99 are handled as 1900-1999)
                    dt = new Date(0, 0, 1);
                    dt.setFullYear(fullYear);
                };
                break;
        }
        return dt;
    },
    // We need separate method for that, because if we embed this logic into floorDate time axis dates would change when
    // changing timezone. We want those to be intact, so we will use this method for occasional lookups instead.
    floorUTCDate: function(date, unit, incr) {
        var dt = Ext.Date.clone(date),
            increment = incr || this.resolutionIncrement;
        if (!unit) {
            unit = this.resolutionUnit;
        }
        var DATE = Sch.util.Date;
        var snap = function(value, increment) {
                return Math.floor(value / increment) * increment;
            };
        switch (unit) {
            case DATE.HOUR:
                // We need to snap local hours to find difference and then apply it to UTC hours. That way floor would
                // work correct around DST and would return nicely snapped hours
                var diff = snap(dt.getHours(), increment) - dt.getHours();
                dt.setUTCHours(dt.getUTCHours() + diff, 0, 0, 0);
                break;
            case DATE.DAY:
                dt = DATE.clearUTCTime(dt);
                // days are 1-based so need to make additional adjustments
                dt.setUTCDate(snap(dt.getUTCDate() - 1, increment) + 1);
                break;
            default:
                dt = this.floorDate(date, null, unit, incr);
                break;
        }
        return dt;
    },
    /**
     * Rounds the date to nearest unit increment
     * @private
     */
    roundDate: function(date, relativeTo) {
        var dt = Ext.Date.clone(date),
            increment = this.resolutionIncrement;
        relativeTo = relativeTo || this.getStart();
        // Need to find the difference of timeZone offsets between relativeTo and original dates.
        // 0 if timeZone offsets are the same.
        var offsetInMinutes = relativeTo.getTimezoneOffset() - dt.getTimezoneOffset();
        switch (this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt);
                var offsetInMilliseconds = offsetInMinutes * 60 * 1000;
                var snappedMilliseconds = Math.round((milliseconds + offsetInMilliseconds) / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, (snappedMilliseconds - offsetInMilliseconds));
                break;
            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt);
                var offsetInSeconds = offsetInMinutes * 60;
                var snappedSeconds = Math.round((seconds + offsetInSeconds) / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, (snappedSeconds - offsetInSeconds) * 1000);
                break;
            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt);
                var snappedMinutes = Math.round((minutes + offsetInMinutes) / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, (snappedMinutes - offsetInMinutes) * 60);
                break;
            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt);
                // offsetInHours is 0 if timezones are the same
                var offsetInHours = offsetInMinutes / 60;
                // First we need to add the offset to the whole amount of hours, so the divided value will take DST into account
                var snappedHours = Math.round((nbrHours + offsetInHours) / increment) * increment;
                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, (snappedHours - offsetInHours) * 60);
                break;
            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                if (this.hasTimeZone()) {
                    dt = Sch.util.Date.add(dt, Sch.util.Date.MINUTE, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset());
                };
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;
                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                };
                if (Math.round(distanceToWeekStartDay / 7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                };
                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;
            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;
            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }
        return dt;
    },
    // private
    ceilDate: function(date, relativeToStart, resolutionUnit, increment) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;
        increment = increment || (relativeToStart ? this.resolutionIncrement : 1);
        var doCall = false,
            unit;
        if (resolutionUnit) {
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }
        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                };
                break;
            default:
                break;
        }
        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },
    // private
    getNext: function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay, this.hasTimeZone() ? this.timeZone : null);
    },
    // private
    getResolution: function() {
        return {
            unit: this.resolutionUnit,
            increment: this.resolutionIncrement
        };
    },
    // private
    setResolution: function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },
    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function(amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    /**
     * Moves the time axis to a passed start date.
     * @param {Date} startDate
     */
    shiftTo: function(startDate) {
        var timeAxisSpanInMs = this.getEnd() - this.getStart(),
            newEnd = new Date(startDate.getTime() + timeAxisSpanInMs);
        this.setTimeSpan(startDate, newEnd);
    },
    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function(amount) {
        amount = amount || this.getShiftIncrement();
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function(amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },
    getShiftUnit: function() {
        return this.shiftUnit || this.mainUnit;
    },
    // private
    getShiftIncrement: function() {
        return this.shiftIncrement || 1;
    },
    // private
    getUnit: function() {
        return this.unit;
    },
    // private
    getIncrement: function() {
        return this.increment;
    },
    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
    getRowTicks: function() {
        if (this.isWeek()) {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);
            var endIndex = this.findBy(function(record) {
                    return record.getStartDate().getTime() >= end.getTime();
                });
            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }
            return this.getRange(0, endIndex - 1);
        }
    },
    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date, inclusiveEnd) {
        var result = false;
        var axisStart = this.getStart();
        var axisEnd = this.getEnd();
        // Date is between axis start/end and axis is not continuous - need to perform better lookup
        if (this.isContinuous()) {
            result = inclusiveEnd ? Sch.util.Date.betweenLesserEqual(date, axisStart, axisEnd) : Sch.util.Date.betweenLesser(date, axisStart, axisEnd);
        } else {
            var length = this.getCount(),
                tickStart, tickEnd;
            for (var i = 0; i < length; i++) {
                var tick = this.getAt(i);
                tickStart = tick.data.start;
                tickEnd = tick.data.end;
                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {
                    return date >= tickStart;
                }
            }
        }
        return result;
    },
    /**
     * Returns true if the passed timespan is part of the time axis range (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
     * @return {Boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        var axisStart = this.getStart();
        var axisEnd = this.getEnd();
        var duration = end - start;
        if (duration === 0) {
            return this.dateInAxis(start, true);
        }
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, axisStart, axisEnd);
        } else {
            var coversRange = start < axisStart && end > axisEnd;
            if (coversRange)  {
                return true;
            }
            
            var startTick = this.getTickFromDate(start);
            var endTick = this.getTickFromDate(end);
            return (startTick !== endTick && (start < axisEnd && end > axisStart));
        }
    },
    // Accepts a Sch.model.Range model
    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();
        // only consider fully scheduled ranges
        if (!start || !end)  {
            return false;
        }
        
        return this.timeSpanInAxis(start, end);
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachAuxInterval: function(unit, increment, iteratorFn, scope) {
        scope = scope || this;
        var end = this.getEnd(),
            dt = this.getStart(),
            i = 0,
            intervalEnd;
        if (dt > end)  {
            throw new Error('Invalid time axis configuration');
        }
        
        while (dt < end) {
            intervalEnd = Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt = intervalEnd;
            i++;
        }
    },
    consumeViewPreset: function(preset) {
        Ext.apply(this, {
            unit: preset.getBottomHeader().unit,
            increment: preset.getBottomHeader().increment || 1,
            resolutionUnit: preset.timeResolution.unit,
            resolutionIncrement: preset.timeResolution.increment,
            mainUnit: preset.getMainHeader().unit,
            shiftUnit: preset.shiftUnit,
            shiftIncrement: preset.shiftIncrement || 1,
            defaultSpan: preset.defaultSpan || 1,
            presetName: preset.name,
            // Weekview columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig: preset.headerConfig
        });
    }
});

/**
 * Assignment store event->resources cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.AssignmentStoreEventResourcesCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();
            Ext.Array.each(assignments, function(assignment) {
                var resource = resourceStore && resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.add(assignment.getEventId(), resource);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                {
                    me.clear(assignment.getEventId());
                }
            });
        }
        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();
            Ext.Array.each(assignments, function(assignment) {
                var resource = resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.remove(assignment.getEventId(), resource);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                {
                    me.clear(assignment.getEventId());
                }
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField],
                eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore(),
                resource;
            if (resourceIdChanged || eventIdChanged) {
                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId = eventIdChanged ? previousEventId : assignment.getEventId();
                resource = resourceStore.getModelById(previousResourceId);
                if (resource) {
                    me.remove(previousEventId, resource);
                } else {
                    me.clear(previousEventId);
                }
                resource = resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.add(assignment.getEventId(), resource);
                } else {
                    me.clear(assignment.getEventId());
                }
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.clear(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.uncache(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                idchanged: onEventIdChanged,
                remove: onEventRemove,
                clear: onEventStoreClearOrReset,
                cacheresethint: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destory(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                remove: onResourceRemove,
                clear: onResourceStoreClearOrReset,
                cacheresethint: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            clear: onAssignmentStoreClearOrReset,
            cacheresethint: onAssignmentStoreClearOrReset,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForEvent(k, function mapper(assignment) {
                return assignment.getResource();
            }, function filter(resource) {
                return !!resource;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/**
 * Assignment store resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.AssignmentStoreResourceEventsCache', {
    extend: 'Sch.util.Cache',
    requires: [
        'Ext.data.Model'
    ],
    assignmentStore: null,
    assignmentStoreDetacher: null,
    eventStoreDetacher: null,
    resourceStoreDetacher: null,
    constructor: function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();
        me.callParent();
        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();
            Ext.Array.each(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.add(assignment.getResourceId(), event);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                {
                    me.clear(assignment.getResourceId());
                }
            });
        }
        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();
            Ext.Array.each(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.remove(assignment.getResourceId(), event);
                } else // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                {
                    me.clear(assignment.getResourceId());
                }
            });
        }
        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField = assignment.resourceIdField,
                resourceIdChanged = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField = assignment.eventIdField,
                eventIdChanged = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField],
                eventStore = me.assignmentStore.getEventStore(),
                event;
            if (resourceIdChanged || eventIdChanged) {
                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId = eventIdChanged ? previousEventId : assignment.getEventId();
                event = eventStore && eventStore.getModelById(previousEventId);
                if (event) {
                    me.remove(previousResourceId, event);
                } else {
                    me.clear(previousResourceId);
                }
                event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.add(assignment.getResourceId(), event);
                } else {
                    me.clear(assignment.getResourceId());
                }
            }
        }
        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }
        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }
        function onEventRemove(eventStore, events) {
            Ext.Array.each(events, function(event) {
                me.uncache(event);
            });
        }
        function onEventStoreClearOrReset() {
            me.clear();
        }
        function onEventStoreResourceStoreChange(store, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }
        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }
        function onResourceRemove(resourceStore, resources) {
            Ext.Array.each(resources, function(resource) {
                me.clear(resource);
            });
        }
        function onResourceStoreClearOrReset() {
            me.clear();
        }
        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                remove: onEventRemove,
                cacheresethint: onEventStoreClearOrReset,
                clear: onEventStoreClearOrReset,
                rootchange: onEventStoreClearOrReset,
                resourcestorechange: onEventStoreResourceStoreChange,
                priority: 100,
                destroyable: true
            });
        }
        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged: onResourceIdChanged,
                remove: onResourceRemove,
                cacheresethint: onResourceStoreClearOrReset,
                clear: onResourceStoreClearOrReset,
                rootchange: onResourceStoreClearOrReset,
                priority: 100,
                destroyable: true
            });
        }
        me.assignmentStoreDetacher = assignmentStore.on({
            add: onAssignmentAdd,
            remove: onAssignmentRemove,
            update: onAssignmentUpdate,
            cacheresethint: onAssignmentStoreClearOrReset,
            clear: onAssignmentStoreClearOrReset,
            eventstorechange: onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority: 100,
            destroyable: true
        });
        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);
        me.assignmentStore = assignmentStore;
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher', 'eventStoreDetacher', 'resourceStoreDetacher');
        me.assignmentStore = null;
    },
    get: function(k, fn) {
        var me = this;
        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForResource(k, function mapper(assignment) {
                return assignment.getEvent();
            }, function filter(event) {
                return !!event;
            });
        };
        return me.callParent([
            k,
            fn
        ]);
    }
});

/**
 * A singleton class allowing to get a human readable description of the provided recurrence.
 *
 * ```javascript
 * var event = new Sch.model.Event({ StartDate : new Date(2018, 6, 3),  EndDate : new Date(2018, 6, 4) });
 * var recurrence = new Sch.model.Recurrence({ Frequency : 'WEEKLY', Days : ['MO', 'TU', 'WE'] });
 * event.setRecurrence(recurrence);
 * // "Weekly on  Mon, Tue and Wed"
 * Sch.data.util.recurrence.Legend.getLegend(recurrence);
 * ```
 */
Ext.define('Sch.data.util.recurrence.Legend', {
    requires: [
        'Sch.data.util.recurrence.DayRuleEncoder'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    singleton: true,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - ', '                            : ', ',
     * - ' and '                         : ' and ',
     * - 'Daily'                         : 'Daily',
     * - 'Weekly on {1}'                 : 'Weekly on {1}',
     * - 'Monthly on {1}'                : 'Monthly on {1}',
     * - 'Yearly on {1} of {2}'          : 'Yearly on {1} of {2}',
     * - 'Every {0} days'                : 'Every {0} days',
     * - 'Every {0} weeks on {1}'        : 'Every {0} weeks on {1}',
     * - 'Every {0} months on {1}'       : 'Every {0} months on {1}',
     * - 'Every {0} years on {1} of {2}' : 'Every {0} years on {1} of {2}',
     * - 'position1'                     : 'the first',
     * - 'position2'                     : 'the second',
     * - 'position3'                     : 'the third',
     * - 'position4'                     : 'the fourth',
     * - 'position5'                     : 'the fifth',
     * - 'position-1'                    : 'the last',
     * - 'day'                           : 'day',
     * - 'weekday'                       : 'weekday',
     * - 'weekend day'                   : 'weekend day',
     * - 'daysFormat'                    : '{0} {1}'
     */
    allDaysValue: 'SU,MO,TU,WE,TH,FR,SA',
    workingDaysValue: 'MO,TU,WE,TH,FR',
    nonWorkingDaysValue: 'SU,SA',
    /**
     * Returns the provided recurrence description. The recurrence might be not set to an event,
     * in this case the event start date should be provided in the second argument.
     * @param  {Sch.model.Recurrence} recurrence       Recurrence model.
     * @param  {Date}                 [eventStartDate] The event start date. Can be omitted if the recurrence is set to an event (and the event has {@link #StartDate start date} filled).
     *                                                 Then event start date will be retrieved from the event.
     * @return {String}                                The recurrence description.
     */
    getLegend: function(recurrence, eventStartDate) {
        var me = this,
            DayRuleEncoder = Sch.data.util.recurrence.DayRuleEncoder,
            sformat = Ext.String.format,
            event = recurrence.getEvent(),
            startDate = eventStartDate || event.getStartDate(),
            interval = recurrence.getInterval(),
            days = recurrence.getDays(),
            monthDays = recurrence.getMonthDays(),
            months = recurrence.getMonths(),
            positions = recurrence.getPositions(),
            result = '',
            when = '',
            fn;
        switch (recurrence.getFrequency()) {
            case 'DAILY':
                result = interval == 1 ? me.L('Daily') : sformat(me.L('Every {0} days'), interval);
                break;
            case 'WEEKLY':
                if (days && days.length) {
                    when = me.getDaysLegend(days);
                } else if (startDate) {
                    when = Ext.Date.dayNames[startDate.getDay()];
                };
                result = sformat(interval == 1 ? me.L('Weekly on {1}') : me.L('Every {0} weeks on {1}'), interval, when);
                break;
            case 'MONTHLY':
                if (days && days.length && positions && positions.length) {
                    when = me.getDaysLegend(days, positions);
                } else if (monthDays && monthDays.length) {
                    // sort dates to output in a proper order
                    monthDays.sort(function(a, b) {
                        return a - b;
                    });
                    when = me.arrayToText(monthDays);
                } else if (startDate) {
                    when = startDate.getDate();
                };
                result = sformat(interval == 1 ? me.L('Monthly on {1}') : me.L('Every {0} months on {1}'), interval, when);
                break;
            case 'YEARLY':
                var hasDaysNPositions = days && days.length && positions && positions.length,
                    hasMonths = months && months.length,
                    whenMonths, whenDate;
                whenDate = hasDaysNPositions ? me.getDaysLegend(days, positions) : startDate.getDate();
                if (hasMonths) {
                    // sort months to output in a proper order
                    months.sort(function(a, b) {
                        return a - b;
                    });
                    if (months.length > 2) {
                        fn = function(month) {
                            return Ext.Date.getShortMonthName(month - 1);
                        };
                    } else {
                        fn = function(month) {
                            return Ext.Date.monthNames[month - 1];
                        };
                    }
                    whenMonths = me.arrayToText(months, fn);
                } else {
                    whenMonths = Ext.Date.monthNames[startDate.getMonth()];
                };
                result = sformat(interval == 1 ? me.L('Yearly on {1} of {2}') : me.L('Every {0} years on {1} of {2}'), interval, whenDate, whenMonths);
                break;
        }
        return result;
    },
    getDaysLegend: function(days, positions) {
        var me = this,
            DayRuleEncoder = Sch.data.util.recurrence.DayRuleEncoder,
            positionsText = '',
            daysText = '',
            fn;
        if (positions && positions.length) {
            positionsText = me.arrayToText(positions, function(position) {
                // the following lines are added to satisfy the 904_unused localization test
                // to let it know that these locales are used:
                // me.L('position1')
                // me.L('position2')
                // me.L('position3')
                // me.L('position4')
                // me.L('position5')
                // me.L('position-1')
                return me.L('position' + position);
            });
        }
        if (days.length) {
            days.sort(function(a, b) {
                return DayRuleEncoder.decodeDay(a)[0] - DayRuleEncoder.decodeDay(b)[0];
            });
            var daysStringValue = days.join(',');
            switch (daysStringValue) {
                case me.allDaysValue:
                    daysText = me.L('day');
                    break;
                case me.workingDaysValue:
                    daysText = me.L('weekday');
                    break;
                case me.nonWorkingDaysValue:
                    daysText = me.L('weekend day');
                    break;
                default:
                    if (days.length > 2) {
                        fn = function(day) {
                            return Ext.Date.getShortDayName(DayRuleEncoder.decodeDay(day)[0]);
                        };
                    } else {
                        fn = function(day) {
                            return Ext.Date.dayNames[DayRuleEncoder.decodeDay(day)[0]];
                        };
                    };
                    daysText = me.arrayToText(days, fn);
            }
        }
        return Ext.String.format(me.L('daysFormat'), positionsText, daysText);
    },
    // Converts array of items to a human readable list.
    // For example: [1,2,3,4]
    // to: "1, 2, 3 and 4"
    arrayToText: function(array, fn, glue, lastGlue) {
        glue = glue || this.L(', ');
        lastGlue = lastGlue || this.L(' and ');
        var result = '',
            delim = '';
        for (var i = 0,
            l = array.length; i < l; ) {
            result += delim + (fn ? fn(array[i]) : array[i]);
            i++;
            delim = (i == l - 1 ? lastGlue : glue);
        }
        return result;
    }
});

/**
 * Class implementing events layout in a row when using horizontal mode.
 */
Ext.define("Sch.eventlayout.Horizontal", {
    nbrOfBandsByResource: null,
    bandIndexToPxConvertFn: null,
    bandIndexToPxConvertScope: null,
    constructor: function(config) {
        Ext.apply(this, config);
        this.nbrOfBandsByResource = {};
    },
    clearCache: function(resource) {
        if (resource)  {
            delete this.nbrOfBandsByResource[resource.internalId];
        }
        else  {
            this.nbrOfBandsByResource = {};
        }
        
    },
    // Input:
    // 1. Resource record
    // 2. Array of Event models, or a function to call to receive such event records lazily
    getNumberOfBands: function(resource, resourceEventsOrFn) {
        var nbrOfBandsByResource = this.nbrOfBandsByResource;
        if (nbrOfBandsByResource.hasOwnProperty(resource.internalId)) {
            return nbrOfBandsByResource[resource.internalId];
        }
        var resourceEvents = Ext.isFunction(resourceEventsOrFn) ? resourceEventsOrFn() : resourceEventsOrFn;
        var eventsData = Ext.Array.map(resourceEvents, function(event) {
                return {
                    start: event.getStartDate(),
                    end: event.getEndDate(),
                    event: event
                };
            });
        return this.applyLayout(eventsData, resource);
    },
    /**
     * Groups the provided resource events in horizontal bands by
     * calculating their top coordinates.
     * 
     * The method sorts events before grouping them by calling {@link #sortEvents} method.
     * 
     * @param {Object[]} eventsData Array of object representing the event to be positioned.
     * Each entry has the following properties:
     * - `event` - the event record
     * - `start` - start date
     * - `end` - end date.
     * @param {Sch.model.Resource} resource Resource.
     * @returns {Number} Number of collected bands.
     */
    applyLayout: function(events, resource) {
        var rowEvents = events.slice();
        // Sort events by start date, and text properties.
        var me = this;
        rowEvents.sort(function(a, b) {
            return me.sortEvents(a.event, b.event);
        });
        // return a number of bands required
        return this.nbrOfBandsByResource[resource.internalId] = this.layoutEventsInBands(rowEvents);
    },
    /**
     * Sorts events before positioning them.
     * The method by default sorts events by their start dates and then end dates.
     * 
     * Override the method to control in what order events are laid out.
     * 
     * **Please note** the method is overridden by the scheduling view {@link Sch.mixin.SchedulerView#horizontalEventSorterFn} config.
     * 
     * @param  {Sch.model.Event} a First event
     * @param  {Sch.model.Event} b Second event
     * @return {Int} If result is less than zero then `a` will go before `b`.
     * If it's greater than zero then `b` will go before `a`.
     * If the result is zero it will `a` and `b` will keep their positions. 
     */
    sortEvents: function(a, b) {
        var startA = a.getStartDate();
        var startB = b.getStartDate();
        var sameStart = (startA - startB === 0);
        if (sameStart) {
            return a.getEndDate() > b.getEndDate() ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }
    },
    // Input: Array of event layout data
    layoutEventsInBands: function(events) {
        var verticalPosition = 0;
        do {
            var event = events[0];
            while (event) {
                event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);
                Ext.Array.remove(events, event);
                event = this.findClosestSuccessor(event, events);
            }
            verticalPosition++;
        } while (// Apply band height to the event cfg
        // Remove it from the array and continue searching
        events.length > 0);
        // Done!
        return verticalPosition;
    },
    /**
     * The method finds the next closest event that should be rendered on the same band as the
     * provided one.
     * When the method returns no event (null or undefined) the layout starts a new band.
     *
     * @param {Object} eventData Current event to find the successor of.
     * Represented with an object having the following properties:
     * - `event` - the event record
     * - `start` - start date
     * - `end` - end date
     * @param {Object[]} eventsData Array of events to find the closest successor in.
     * Each event is represented with an object hafing the following properties:
     * - `event` - the event record
     * - `start` - start date
     * - `end` - end date
     * @returns {Object} The found successor (an `eventsData` entry) or `undefined` if not found.
     */
    findClosestSuccessor: function(event, events) {
        var minGap = Infinity,
            closest,
            eventEnd = event.end,
            gap,
            isMilestone = event.end - event.start === 0;
        for (var i = 0,
            l = events.length; i < l; i++) {
            gap = events[i].start - eventEnd;
            if (gap >= 0 && gap < minGap && (// Two milestones should not overlap
            gap > 0 || events[i].end - events[i].start > 0 || !isMilestone)) {
                closest = events[i];
                minGap = gap;
            }
        }
        return closest;
    }
});

Ext.define('Sch.eventlayout.Table', {
    extend: 'Sch.eventlayout.Horizontal',
    timeAxisViewModel: null,
    layoutEventsInBands: function(events) {
        var timeAxisViewModel = this.timeAxisViewModel;
        var timeAxis = timeAxisViewModel.timeAxis;
        var verticalPosition = 0;
        do {
            var event = events[0];
            while (event) {
                event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);
                var tick = Math.floor(timeAxis.getTickFromDate(event.start));
                var left = this.timeAxisViewModel.getPositionFromDate(timeAxis.getAt(tick).getStartDate());
                var width = this.timeAxisViewModel.getTickWidth();
                event.left = left;
                event.width = width;
                Ext.Array.remove(events, event);
                event = this.findClosestSuccessor(event, events);
            }
            verticalPosition++;
        } while (// Apply band height to the event cfg
        // Remove it from the array and continue searching
        events.length > 0);
        // Done!
        return verticalPosition;
    },
    findClosestSuccessor: function(event, events) {
        var timeAxis = this.timeAxisViewModel.timeAxis;
        var tickIndex = Math.floor(timeAxis.getTickFromDate(event.start));
        var tick = timeAxis.getAt(tickIndex);
        for (var i = 0,
            l = events.length; i < l; i++) {
            if (events[i].start >= tick.getEndDate()) {
                return events[i];
            }
        }
    }
});

/*
 * @class Sch.eventlayout.Vertical
 * @private
 *
 */
Ext.define("Sch.eventlayout.Vertical", {
    requires: [
        'Sch.util.Date'
    ],
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    // Try to pack the events to consume as little space as possible
    applyLayout: function(events, totalAvailableWidth) {
        if (events.length === 0) {
            return;
        }
        // Sort events by start date, and text properties.
        var me = this;
        events.sort(function(a, b) {
            return me.sortEvents(a.event, b.event);
        });
        var slot, firstInCluster, j;
        for (var i = 0,
            l = events.length; i < l; i++) {
            firstInCluster = events[i];
            slot = this.findStartSlot(events, firstInCluster);
            var cluster = this.getCluster(events, i);
            if (cluster.length > 1) {
                firstInCluster.left = slot.start;
                firstInCluster.width = slot.end - slot.start;
                // If there are multiple slots and events in the cluster have multiple start dates, group all same-start events into first slot
                j = 1;
                while (j < (cluster.length - 1) && cluster[j + 1].start - firstInCluster.start === 0) {
                    j++;
                }
                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot
                var nextSlot = this.findStartSlot(events, cluster[j]);
                if (nextSlot && nextSlot.start < 0.8) {
                    cluster = cluster.slice(0, j);
                }
            }
            var count = cluster.length,
                barWidth = (slot.end - slot.start) / count;
            // Apply fraction values
            for (j = 0; j < count; j++) {
                cluster[j].width = barWidth;
                cluster[j].left = slot.start + (j * barWidth);
            }
            i += count - 1;
        }
        for (i = 0 , l = events.length; i < l; i++) {
            events[i].width = events[i].width * totalAvailableWidth;
            events[i].left = this.view.barMargin + (events[i].left * totalAvailableWidth);
        }
    },
    findStartSlot: function(events, event) {
        var priorOverlappers = this.getPriorOverlappingEvents(events, event),
            i;
        if (priorOverlappers.length === 0) {
            return {
                start: 0,
                end: 1
            };
        }
        for (i = 0; i < priorOverlappers.length; i++) {
            if (i === 0 && priorOverlappers[0].left > 0) {
                return {
                    start: 0,
                    end: priorOverlappers[0].left
                };
            } else if (priorOverlappers[i].left + priorOverlappers[i].width < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1)) {
                return {
                    start: priorOverlappers[i].left + priorOverlappers[i].width,
                    end: i < priorOverlappers.length - 1 ? priorOverlappers[i + 1].left : 1
                };
            }
        }
        return false;
    },
    getPriorOverlappingEvents: function(events, event) {
        var D = Sch.util.Date,
            start = event.start,
            end = event.end,
            overlappers = [];
        for (var i = 0,
            l = Ext.Array.indexOf(events, event); i < l; i++) {
            if (D.intersectSpans(start, end, events[i].start, events[i].end)) {
                overlappers.push(events[i]);
            }
        }
        overlappers.sort(this.sortOverlappers);
        return overlappers;
    },
    sortOverlappers: function(e1, e2) {
        return e1.left < e2.left ? -1 : 1;
    },
    getCluster: function(events, startIndex) {
        if (startIndex >= events.length - 1) {
            return [
                events[startIndex]
            ];
        }
        var evts = [
                events[startIndex]
            ],
            start = events[startIndex].start,
            end = events[startIndex].end,
            l = events.length,
            D = Sch.util.Date,
            i = startIndex + 1;
        while (i < l && D.intersectSpans(start, end, events[i].start, events[i].end)) {
            evts.push(events[i]);
            start = D.max(start, events[i].start);
            end = D.min(events[i].end, end);
            i++;
        }
        return evts;
    },
    sortEvents: function(a, b) {
        var startA = a.getStartDate(),
            endA = a.getEndDate();
        var startB = b.getStartDate(),
            endB = b.getEndDate();
        var sameStart = (startA - startB === 0);
        if (sameStart) {
            return endA > endB ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }
    }
});

/**
@class Sch.feature.AbstractTimeSpan
@extends Ext.AbstractPlugin

Plugin for visualizing "global" time span in the scheduler grid, these can by styled easily using just CSS. This is an abstract class not intended for direct use.

*/
Ext.define("Sch.feature.AbstractTimeSpan", {
    extend: 'Ext.AbstractPlugin',
    mixins: {
        observable: 'Ext.util.Observable'
    },
    lockableScope: 'top',
    schedulerView: null,
    timeAxis: null,
    // If lines/zones should stretch to fill the whole view container element in case the table does not fill it
    expandToFitView: false,
    disabled: false,
    /**
     * @property {String} cls An internal css class which is added to each rendered timespan element
     * @private
     */
    cls: null,
    /**
     * @cfg {String} clsField Name of field
     */
    clsField: 'Cls',
    /**
     * @cfg {Ext.XTemplate} template Template to render the timespan elements
     */
    template: null,
    /**
     * @cfg {Ext.data.Store} store A store with timespan data, or a string identifying a store.
     */
    store: null,
    renderElementsBuffered: false,
    /**
     * @cfg {Number} renderDelay Delay the zones rendering by this amount (in ms) to speed up the default rendering of rows and events.
     */
    renderDelay: 0,
    // true to refresh the sizes of the rendered elements when an item in the bound view changes
    // false to do a full refresh instead
    refreshSizeOnItemUpdate: true,
    _renderTimer: null,
    /**
     * @cfg {Boolean} showHeaderElements Set this to `true` to show indicators in the timeline header area.
     *
     * Header indicators are placed right above the corresponding element of the scheduling view. You can customize the HTML markup
     * for these indicators with the {@link #headerTemplate} config. Note that the indicators are rendered as a regular div element,
     * which will be styled differently in modern vs legacy browsers.
     *
     */
    showHeaderElements: false,
    /**
     * @private
     * @cfg {Ext.XTemplate} headerTemplate Template used to render the header elements
     */
    headerTemplate: null,
    /**
     * @cfg {String/Ext.XTemplate} innerHeaderTpl A template providing additional markup to render into each timespan header element
     */
    innerHeaderTpl: null,
    headerContainerCls: 'sch-header-secondary-canvas',
    headerContainerEl: null,
    // event to be fired, when rendering has completed (only fired when all elements are rendered, not single)
    renderingDoneEvent: null,
    constructor: function(cfg) {
        // unique css class to be able to identify only the zones belonging to this plugin instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        Ext.apply(this, cfg);
        this.mixins.observable.constructor.call(this);
        this.callParent(arguments);
    },
    init: function(scheduler) {
        // TODO COMMENT
        if (Ext.versions.touch && !scheduler.isReady()) {
            scheduler.on('viewready', function() {
                this.init(scheduler);
            }, this);
            return;
        }
        if (typeof this.innerHeaderTpl === 'string') {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        var innerHeaderTpl = this.innerHeaderTpl;
        if (!this.headerTemplate) {
            this.headerTemplate = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" class="{cls}" title="{[values.Name || values.Text || ""]}" style="{side}:{position}px;">' + (innerHeaderTpl ? '{[this.renderInner(values)]}' : '') + '</div>', '</tpl>', {
                renderInner: function(values) {
                    return innerHeaderTpl.apply(values);
                }
            });
        }
        this.schedulerView = scheduler.getSchedulingView();
        this.panel = scheduler;
        this.timeAxis = scheduler.getTimeAxis();
        this.store = Ext.StoreManager.lookup(this.store);
        if (!this.store) {
            Ext.Error.raise("Error: You must define a store for this plugin");
        }
        if (this.showHeaderElements) {
            this.panel.on({
                horizontaltimeaxiscolumnrender: this.renderHeaderElements,
                scope: this
            });
        }
        if (!this.schedulerView.getEl()) {
            this.schedulerView.on({
                viewready: this.onViewReady,
                scope: this
            });
        } else {
            this.onViewReady();
        }
    },
    /**
     * @param {Boolean} disabled Pass `true` to disable the plugin and remove all rendered elements.
     */
    setDisabled: function(disabled) {
        if (disabled) {
            this.removeElements();
        }
        this.disabled = disabled;
    },
    removeElements: function() {
        this.removeBodyElements();
        if (this.showHeaderElements) {
            this.removeHeaderElements();
        }
    },
    //Returns the currently rendered DOM elements of this plugin (if any), as a {@link Ext.CompositeElementLite} collection.
    getBodyElements: function() {
        var el = this.getContainerEl();
        if (el) {
            return el.select('.' + this.uniqueCls);
        }
        return null;
    },
    /**
     * Returns container to render header elements.
     *
     * @return {Ext.dom.Element|null}
     */
    getHeaderContainerEl: function() {
        var containerEl = this.headerContainerEl,
            prefix = Ext.baseCSSPrefix,
            parent;
        if (!containerEl || !containerEl.dom) {
            if (this.schedulerView.isHorizontal()) {
                var timeAxisColumn = this.panel.getHorizontalTimeAxisColumn();
                if (timeAxisColumn.headerView) {
                    // Column must be rendered first
                    parent = timeAxisColumn.headerView.containerEl;
                } else {
                    return null;
                }
            } else {
                parent = this.panel.lockedGrid.getView().el;
            }
            if (parent) {
                containerEl = parent.down('.' + this.headerContainerCls);
                if (!containerEl) {
                    containerEl = parent.appendChild({
                        cls: this.headerContainerCls
                    });
                }
                this.headerContainerEl = containerEl;
            }
        }
        return containerEl;
    },
    getHeaderElements: function() {
        var containerEl = this.getHeaderContainerEl();
        if (containerEl) {
            return containerEl.select('.' + this.uniqueCls);
        }
        return null;
    },
    // private
    removeBodyElements: function() {
        var els = this.getBodyElements();
        if (els) {
            els.each(function(el) {
                el.destroy();
            });
        }
    },
    removeHeaderElements: function() {
        var els = this.getHeaderElements();
        if (els) {
            els.each(function(el) {
                el.destroy();
            });
        }
    },
    /**
     * Returns id of element for data record.
     *
     * @param {Ext.data.Model} record
     *
     * @return {String}
     */
    getElementId: function(record) {
        return this.uniqueCls + '-' + record.internalId;
    },
    /**
     * Returns id of header element for data record.
     *
     * @param {Ext.data.Model} record
     *
     * @return {String}
     */
    getHeaderElementId: function(record) {
        return this.uniqueCls + '-header-' + record.internalId;
    },
    /**
     * Returns data to apply to the HTML template for rendering a timespan element. You can use this to apply custom styling to each rendered timespan.
     *
     * @param {Ext.data.Model} record
     *
     * @return {Object}
     */
    getTemplateData: function(record) {
        return this.prepareTemplateData ? this.prepareTemplateData(record) : record.data;
    },
    /**
     * Return element class for a record.
     *
     * @param {Ext.data.Model} record Data record
     * @param {Object} data Template data
     *
     * @return {String}
     */
    getElementCls: function(record, data) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return this.cls + ' ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    /**
     * Return header element class for data record.
     *
     * @param {Ext.data.Model} record Data record
     * @param {Object} data
     *
     * @return {String}
     */
    getHeaderElementCls: function(record, data) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return 'sch-header-indicator ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    getContainerEl: function() {
        return this.schedulerView.getSecondaryCanvasEl();
    },
    onViewReady: function(scheduler) {
        var view = this.schedulerView;
        this.storeListeners = {
            load: this.renderElements,
            datachanged: this.renderElements,
            clear: this.renderElements,
            update: this.refreshSingle,
            scope: this
        };
        this.store.on(this.storeListeners);
        this.panel.on({
            beforemodechange: this.onTimelinePanelBeforeModeChange,
            modechange: this.onTimelinePanelModeChange,
            scope: this
        });
        this.viewListeners = {
            // In case we cannot guarantee that we control the GridView "empty the view procedure", where the node container it emptied,
            // we'll need this as a fallback. See GridViewCanvas override of the BufferedRenderer instance
            // bufferedrefresh     : function() {
            //     if (!view.isHorizontal() || this.getContainerEl().dom.childNodes.length === 0) {
            //         this.renderElements();
            //     }
            // },
            refresh: this.renderElements,
            scope: this
        };
        this.headerListeners = {
            afterlayout: this.renderElements,
            scope: this
        };
        // Weekview fires refresh before columns are actually laid out, we can safely render elements when columns
        // are sized correctly, which is 'afterlayout' event on header container
        if (view.isWeekView()) {
            view.headerCt.on(this.headerListeners);
        } else {
            view.on(this.viewListeners);
            this.renderElements();
        }
    },
    // Should not react to view refreshes until everything is fully setup in the new mode
    onTimelinePanelBeforeModeChange: function() {
        var view = this.schedulerView;
        if (view.isWeekView()) {
            view.headerCt.un(this.headerListeners);
        } else {
            this.schedulerView.un(this.viewListeners);
        }
    },
    // Re-enable view listeners and force a new render cycle
    onTimelinePanelModeChange: function() {
        var view = this.schedulerView;
        if (view.isWeekView()) {
            view.headerCt.on(this.headerListeners);
        } else {
            view.on(this.viewListeners);
        }
        this.forceNewRenderingTimeout();
    },
    forceNewRenderingTimeout: function() {
        this.renderElementsBuffered = false;
        clearTimeout(this._renderTimer);
        this.renderElements();
    },
    renderElements: function() {
        if (this.renderElementsBuffered || this.disabled)  {
            return;
        }
        
        this.renderElementsBuffered = true;
        clearTimeout(this._renderTimer);
        // Defer to make sure rendering is not delayed by this plugin
        // deferring on 15 because the cascade delay is 10 (cascading will trigger a view refresh)
        this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this);
    },
    /**
     * Sets element X coordinate relative direction (rtl or ltr).
     *
     * @param {Ext.Element} el
     * @param {Number} x
     */
    setElementX: function(el, x) {
        if (this.panel.rtl) {
            el.setRight(x);
        } else {
            el.setLeft(x);
        }
    },
    /**
     * Returns position of header element by date.
     *
     * @param {Date} date
     *
     * @return {Number}
     */
    getHeaderElementPosition: function(date) {
        var viewModel = this.schedulerView.getTimeAxisViewModel();
        return Math.round(viewModel.getPositionFromDate(date));
    },
    renderBodyElementsInternal: function(records) {
        var start = this.timeAxis.getStart(),
            end = this.timeAxis.getEnd(),
            data = this.getElementData(start, end, records);
        if (data) {
            this.template.append(this.getContainerEl(), data);
        }
    },
    getHeaderElementData: function(records, isPrint) {
        throw 'Abstract method call';
    },
    renderHeaderElements: function(records) {
        var containerEl = this.getHeaderContainerEl();
        if (containerEl) {
            var data = this.getHeaderElementData(records);
            this.headerTemplate.append(containerEl, data);
        }
    },
    renderElementsInternal: function() {
        this.renderElementsBuffered = false;
        var view = this.schedulerView;
        // component could be destroyed during the buffering time frame,
        // Skip rendering while main backing store is empty
        if (this.disabled || view.isDestroyed || !this.getContainerEl() || view.store.getCount() === 0)  {
            return;
        }
        
        // In weekview mode this method can be invoked before there're visible columns we need to avoid that
        if (view.isWeekView()) {
            var columns = view.getColumnManager().getColumns();
            if (columns[0] && !columns[0].rendered) {
                return;
            }
        }
        this.removeElements();
        this.renderBodyElementsInternal();
        if (this.showHeaderElements) {
            this.headerContainerEl = null;
            this.renderHeaderElements();
        }
        if (this.renderingDoneEvent)  {
            this.fireEvent(this.renderingDoneEvent, this);
        }
        
    },
    getElementData: function(viewStart, viewEnd, records, isPrint) {
        throw 'Abstract method call';
    },
    updateBodyElement: function(record) {
        var el = Ext.get(this.getElementId(record));
        if (el) {
            var start = this.timeAxis.getStart(),
                end = this.timeAxis.getEnd(),
                data = this.getElementData(start, end, [
                    record
                ])[0];
            if (data) {
                // Reapply CSS classes
                el.dom.className = data.$cls;
                el.setTop(data.top);
                this.setElementX(el, data.left);
                el.setSize(data.width, data.height);
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderBodyElementsInternal` will only add markup for that record
            this.renderBodyElementsInternal([
                record
            ]);
        }
    },
    updateHeaderElement: function(record) {
        var el = Ext.get(this.getHeaderElementId(record));
        if (el) {
            var data = this.getHeaderElementData([
                    record
                ])[0];
            if (data) {
                // Reapply CSS classes
                el.dom.className = data.cls;
                if (this.schedulerView.isHorizontal()) {
                    this.setElementX(el, data.position);
                    el.setWidth(data.size);
                } else {
                    el.setTop(data.position);
                    el.setHeight(data.size);
                }
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderHeaderElements` will only add markup for that record
            this.renderHeaderElements([
                record
            ]);
        }
    },
    destroy: function() {
        clearTimeout(this._renderTimer);
        this.store.un(this.storeListeners);
        if (this.store.autoDestroy) {
            this.store.destroy();
        }
    },
    refreshSingle: function(store, records) {
        records = records instanceof Array ? records : [
            records
        ];
        Ext.Array.each(records, function(record) {
            this.updateBodyElement(record);
            if (this.showHeaderElements) {
                this.updateHeaderElement(record);
            }
        }, this);
    }
});

/**
@class Sch.plugin.Lines
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_lines') for showing "global" time lines in the scheduler grid. It uses a store to populate itself, records in this store should have the following fields:

- `Date` The date of the line. This date is formatted based on what's configured in the {@link Sch.preset.ViewPreset#displayDateFormat} option of the current "viewPreset".
- `Text` The Text to show when hovering over the line (optional)
- `Cls`  A CSS class to add to the line (optional)

To add this plugin to scheduler:

    var dayStore    = new Ext.data.Store({
        fields  : [ 'Date', 'Text', 'Cls' ],

        data    : [
            {
                Date        : new Date(2011, 06, 19),
                Text        : 'Some important day'
            }
        ]
    });


    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Lines', { store : dayStore })
        ]
    });


*/
Ext.define("Sch.plugin.Lines", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: 'plugin.scheduler_lines',
    cls: 'sch-timeline',
    /**
     * @cfg {Boolean} showTip 'true' to include a native browser tooltip when hovering over the line.
     */
    showTip: true,
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    prepareTemplateData: null,
    side: null,
    init: function(scheduler) {
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        this.side = scheduler.rtl ? 'right' : 'left';
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">', '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ' : '') + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;width:{width}px">' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '</div>', '</tpl>', {
                getTipText: function(values) {
                    var view = scheduler.getSchedulingView();
                    return view.getFormattedDate(view.convertDateToTimeZone(values.Date)) + ' ' + (values.Text || "");
                },
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        this.callParent(arguments);
    },
    getElementData: function(viewStart, viewEnd, records) {
        var s = this.store,
            scheduler = this.schedulerView,
            isHorizontal = scheduler.isHorizontal(),
            isWeekView = scheduler.isWeekView(),
            rs = records || s.getRange(),
            data = [],
            height, width, record, date, templateData;
        for (var i = 0,
            l = rs.length; i < l; i++) {
            record = rs[i];
            date = record.get('Date');
            if (date && scheduler.timeAxis.dateInAxis(date)) {
                templateData = Ext.apply({}, this.getTemplateData(record));
                templateData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                templateData.$cls = this.getElementCls(record, templateData);
                if (isWeekView) {
                    var region = scheduler.getTimeSpanRegion(viewStart, null, this.expandToFitView);
                    region = scheduler.getTimeSpanRegion(date, date);
                    templateData.left = region.x;
                    templateData.top = region.y;
                    templateData.width = region.right - region.left;
                } else {
                    var pos = scheduler.getCoordinateFromDate(date);
                    if (isHorizontal) {
                        templateData.left = pos;
                    } else {
                        templateData.top = pos;
                    }
                }
                data.push(templateData);
            }
        }
        return data;
    },
    getHeaderElementData: function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            isHorizontal = this.schedulerView.isHorizontal(),
            data = [],
            record, date, position, templateData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            date = record.get('Date');
            if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
                position = this.getHeaderElementPosition(date);
                templateData = this.getTemplateData(record);
                templateData = Ext.apply({
                    side: isHorizontal ? this.side : 'top',
                    cls: this.getHeaderElementCls(record, templateData),
                    position: position
                }, templateData);
                // Overwrite id manually as it might exist in the record raw data
                templateData.id = this.getHeaderElementId(record);
                data.push(templateData);
            }
        }
        return data;
    }
});

/**
 @class Sch.feature.ColumnLines
 @extends Sch.plugin.Lines

 A simple feature adding column lines to the timeline panel.

 */
Ext.define("Sch.feature.ColumnLines", {
    extend: 'Sch.plugin.Lines',
    requires: [
        'Ext.data.JsonStore'
    ],
    showTip: false,
    cls: 'sch-column-line',
    timeAxisViewModel: null,
    renderingDoneEvent: 'columnlinessynced',
    useLowestHeader: null,
    init: function(panel) {
        this.timeAxis = panel.getTimeAxis();
        this.timeAxisViewModel = panel.timeAxisViewModel;
        this.panel = panel;
        this.store = new Ext.data.JsonStore({
            fields: [
                'Date'
            ]
        });
        this.callParent(arguments);
        panel.on({
            destroy: this.onHostDestroy,
            scope: this
        });
        this.timeAxisViewModel.on('update', this.populate, this);
        this.populate();
    },
    onHostDestroy: function() {
        this.timeAxisViewModel.un('update', this.populate, this);
    },
    populate: function() {
        this.store.setData(this.getData());
    },
    getData: function() {
        var ticks = [];
        var timeAxisViewModel = this.timeAxisViewModel;
        var linesForLevel = this.useLowestHeader ? timeAxisViewModel.getLowestHeader() : timeAxisViewModel.columnLinesFor;
        var hasGenerator = !!(timeAxisViewModel.headerConfig && timeAxisViewModel.headerConfig[linesForLevel].cellGenerator);
        if (hasGenerator) {
            var cells = timeAxisViewModel.getColumnConfig()[linesForLevel];
            for (var i = 1,
                l = cells.length; i < l; i++) {
                ticks.push({
                    Date: cells[i].start
                });
            }
        } else {
            timeAxisViewModel.forEachInterval(linesForLevel, function(start, end, i) {
                if (i > 0) {
                    ticks.push({
                        Date: start,
                        Cls: timeAxisViewModel.isMajorTick(start) ? 'sch-column-line-solid' : ''
                    });
                }
            });
        }
        return ticks;
    }
});

/**
 * @class
 * @static
 * @private
 * Private utility class for dealing with scroll triggering based on various mousemove events in the UI
 */
Ext.define('Sch.util.ScrollManager', {
    singleton: true,
    vthresh: 25,
    hthresh: 25,
    increment: 100,
    frequency: 500,
    animate: true,
    animDuration: 200,
    activeCmp: null,
    activeEl: null,
    scrollElRegion: null,
    scrollProcess: {},
    pt: null,
    // "horizontal", "vertical" or "both"
    direction: 'both',
    constructor: function() {
        this.doScroll = Ext.Function.bind(this.doScroll, this);
    },
    triggerRefresh: function() {
        if (this.activeEl) {
            this.refreshElRegion();
            this.clearScrollInterval();
            this.onMouseMove();
        }
    },
    doScroll: function() {
        var scrollProcess = this.scrollProcess,
            scrollProcessCmp = scrollProcess.cmp,
            // HACK: Ext JS has different behavior for viewport case vs non-viewport case.
            rtlWithoutViewport = scrollProcessCmp.rtl && !scrollProcessCmp.up('[isViewport]'),
            dir = scrollProcess.dir[0],
            increment = this.increment,
            scrollLeft = this.activeCmp.getScrollX(),
            scrollTop = this.activeCmp.getVerticalScroll();
        // Make sure we don't scroll too far
        if (dir === 'r') {
            increment = Math.min(increment, rtlWithoutViewport ? scrollLeft : this.maxPosition.x - scrollLeft);
        } else if (dir === 'd') {
            increment = Math.min(increment, this.maxPosition.y - scrollTop);
        }
        increment = Math.max(increment, 0);
        var deltaX = 0,
            deltaY = 0;
        if (dir === 'r')  {
            deltaX = increment;
        }
        
        if (dir === 'l')  {
            deltaX = -increment;
        }
        
        if (dir === 'u')  {
            deltaY = -increment;
        }
        
        if (dir === 'd')  {
            deltaY = increment;
        }
        
        if (rtlWithoutViewport) {
            deltaX = -deltaX;
        }
        if (deltaX) {
            scrollProcessCmp.scrollHorizontallyBy(deltaX, {
                duration: this.animDuration,
                callback: this.triggerRefresh,
                scope: this
            });
        } else if (deltaY) {
            scrollProcessCmp.scrollVerticallyBy(deltaY, {
                duration: this.animDuration,
                callback: this.triggerRefresh,
                scope: this
            });
        }
    },
    clearScrollInterval: function() {
        var scrollProcess = this.scrollProcess;
        if (scrollProcess.id) {
            clearTimeout(scrollProcess.id);
        }
        scrollProcess.id = 0;
        scrollProcess.cmp = null;
        scrollProcess.dir = "";
    },
    isScrollAllowed: function(dir) {
        switch (this.direction) {
            case 'both':
                return true;
            case 'horizontal':
                return dir === 'right' || dir === 'left';
            case 'vertical':
                return dir === 'up' || dir === 'down';
            default:
                throw new Error('Invalid direction: ' + this.direction);
        }
    },
    startScrollInterval: function(cmp, dir) {
        if (!this.isScrollAllowed(dir)) {
            return;
        }
        this.clearScrollInterval();
        this.scrollProcess.cmp = cmp;
        this.scrollProcess.dir = dir;
        this.scrollProcess.id = setTimeout(this.doScroll, this.frequency);
    },
    onMouseMove: function(e) {
        var pt = e ? {
                x: e.getX(),
                y: e.getY(),
                right: e.getX(),
                bottom: e.getY()
            } : this.pt,
            x = pt.x,
            y = pt.y,
            scrollProcess = this.scrollProcess,
            cmp = this.activeCmp,
            scrollLeft = cmp.getScrollX(),
            scrollTop = cmp.getVerticalScroll(),
            id,
            // HACK: Ext JS has different behavior for viewport case vs non-viewport case.
            rtlWithoutViewport = cmp.rtl && !cmp.up('[isViewport]'),
            el = this.activeEl,
            region = this.scrollElRegion,
            elDom = el.dom,
            me = this,
            // should be scrollable vertically or horizontally
            isScrollable = cmp.up('timelinegrid,timelinetree').getScrollable().getElement().isScrollable() || el.isScrollable();
        this.pt = pt;
        if (region && region.contains(pt) && isScrollable) {
            if (region.bottom - y <= me.vthresh && (scrollTop < this.maxPosition.y)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "down");
                }
                return;
            } else if (region.right - x <= me.hthresh && (rtlWithoutViewport ? scrollLeft > 0 : scrollLeft < this.maxPosition.x)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "right");
                }
                return;
            } else if (y - region.top <= me.vthresh && scrollTop > 0) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "up");
                }
                return;
            } else if (x - region.left <= me.hthresh && (rtlWithoutViewport ? scrollLeft < this.maxPosition.x : scrollLeft > 0)) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(cmp, "left");
                }
                return;
            }
        }
        this.clearScrollInterval();
    },
    refreshElRegion: function() {
        var region = this.activeEl.getRegion();
        this.scrollElRegion = this.activeCmp.getScrollableContainerRegion();
    },
    // Pass an element, and optionally a direction ("horizontal", "vertical" or "both")
    activate: function(cmp, direction) {
        var scrollbarSize = Ext.getScrollbarSize();
        this.direction = direction || 'both';
        this.activeCmp = cmp;
        this.activeEl = cmp.getEl();
        this.maxPosition = cmp.getScrollableMaxPosition();
        this.refreshElRegion();
        this.activeEl.on('mousemove', this.onMouseMove, this);
    },
    deactivate: function() {
        // check active to prevent crash on multiple deactivations
        if (this.activeEl) {
            this.clearScrollInterval();
            this.activeEl.un('mousemove', this.onMouseMove, this);
            this.activeEl = this.activeCmp = this.scrollElRegion = null;
            this.direction = 'both';
        }
    }
});

/**
 * @class Sch.util.DragTracker
 * @private
 *
 * Simple drag tracker with an extra useful getRegion method
 **/
Ext.define('Sch.util.DragTracker', {
    extend: 'Ext.dd.DragTracker',
    requires: [
        'Ext.util.Region'
    ],
    /**
     * @cfg {Number} xStep
     * The number of horizontal pixels to snap to when dragging
     */
    xStep: 1,
    /**
     * @cfg {Number} yStep
     * The number of vertical pixels to snap to when dragging
     */
    yStep: 1,
    initEl: function(el) {
        var me = this,
            elCmp, touchScrollable;
        me.callParent(arguments);
        if (Ext.supports.Touch) {
            // HACK
            // DragTracker adds mousdown listener with option `translate : false`, which on touch desktop doesn't fire
            // mousedown on actual mousedown, only on touch. Reattaching this listener with translate : true
            // Default listeners in DragTracker IE11 will handle touch and click as 'mousedown' with pointerType 'mouse'
            // Beside that, we do not want this code to work in Edge with touch events enabled in flags. If they are enabled,
            // TouchEvent class is present on window.
            // This is also required now in chrome
            if (!Ext.isEdge || !window.TouchEvent) {
                me.mun(me.handle, me.handleListeners);
                me.handleListeners.mousedown.translate = true;
                me.mon(me.handle, me.handleListeners);
            }
        }
    },
    constructor: function() {
        this.callParent(arguments);
        // ScrollManager might trigger a scroll as we are dragging, trigger manual onMouseMove in this case
        this.on('dragstart', this.bindListenersOnDragStart);
    },
    bindListenersOnDragStart: function() {
        var el = this.el;
        el.on(this.getListeners());
        this.on('dragend', this.unbindListenersOnDragEnd, this, {
            single: true
        });
    },
    unbindListenersOnDragEnd: function() {
        this.el && this.el.un(this.getListeners());
    },
    getListeners: function() {
        return {
            scroll: this.onMouseMove,
            // We only care about single touches
            pinchstart: this.onMouseUp,
            scope: this
        };
    },
    destroy: function() {
        clearTimeout(this.deferTimer);
        this.callParent(arguments);
    },
    /**
     * Set the number of horizontal pixels to snap to when dragging
     * @param {Number} step
     */
    setXStep: function(step) {
        this.xStep = step;
    },
    startScroll: null,
    /**
     * Set the number of vertical pixels to snap to when dragging
     * @param {Number} step
     */
    setYStep: function(step) {
        this.yStep = step;
    },
    getCurrentScroll: function() {
        return this.el.getScroll();
    },
    getRegion: function() {
        var startXY = this.startXY,
            currentScroll = this.getCurrentScroll();
        // In IE scroll on element will contain scroll from right-most position
        // All calculations are made with assumption scroll is from left edge
        if (Ext.isIE && this.rtl) {
            currentScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - currentScroll.left;
        }
        var currentXY = this.getXY(),
            currentX = currentXY[0],
            currentY = currentXY[1],
            scrollLeftDelta = currentScroll.left - this.startScroll.left,
            scrollTopDelta = currentScroll.top - this.startScroll.top,
            startX = startXY[0] - scrollLeftDelta,
            startY = startXY[1] - scrollTopDelta,
            minX = Math.min(startX, currentX),
            minY = Math.min(startY, currentY),
            width = Math.abs(startX - currentX),
            height = Math.abs(startY - currentY);
        return new Ext.util.Region(minY, minX + width, minY + height, minX);
    },
    // @OVERRIDE
    onMouseDown: function(e, target) {
        var touches = e.event.touches || [];
        // Ignore multi touches and single touch in IE11
        // Only dragcreate event with mouse action
        if (touches.length > 1 || !(e.type === 'mousedown' && e.pointerType === 'mouse'))  {
            return;
        }
        
        // HACK - Ext calls stopPropagation which prevents global mousedown listeners on the document/body
        // which messes up blur of EventEditor plugin. See event editor tests for reference
        e.stopPropagation = Ext.emptyFn;
        this.startXY = e.getXY();
        this.callParent([
            e,
            target
        ]);
        this.lastXY = this.startXY;
        this.startScroll = this.getCurrentScroll();
        if (Ext.isIE && this.rtl) {
            this.startScroll.left = this.el.dom.scrollWidth - this.el.getWidth() - this.startScroll.left;
        }
    },
    // @OVERRIDE
    // Adds support for snapping to increments while dragging
    onMouseMove: function(e, target) {
        e.preventDefault();
        var xy = e.type === 'scroll' ? this.lastXY : e.getXY(),
            s = this.startXY;
        if (!this.active) {
            if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.tolerance) {
                this.triggerStart(e);
            } else {
                return;
            }
        }
        var x = xy[0],
            y = xy[1];
        // TODO handle if this.el is scrolled
        if (this.xStep > 1) {
            x -= this.startXY[0];
            x = Math.round(x / this.xStep) * this.xStep;
            x += this.startXY[0];
        }
        if (this.yStep > 1) {
            y -= this.startXY[1];
            y = Math.round(y / this.yStep) * this.yStep;
            y += this.startXY[1];
        }
        var snapping = this.xStep > 1 || this.yStep > 1;
        if (!snapping || x !== xy[0] || y !== xy[1]) {
            this.lastXY = [
                x,
                y
            ];
            if (this.fireEvent('mousemove', this, e) === false) {
                this.onMouseUp(e);
            } else {
                this.onDrag(e);
                this.fireEvent('drag', this, e);
            }
        }
    }
});

/**
 * @class Sch.tooltip.ClockTemplate
 * @extends Ext.XTemplate
 * @private
 * A template showing a clock. It accepts an object containing a 'date' and a 'text' property to its apply method.
 * @constructor
 * @param {Object} config The object containing the configuration of this model.
 */
Ext.define('Sch.tooltip.ClockTemplate', {
    extend: 'Ext.XTemplate',
    minuteHeight: 8,
    minuteTop: 2,
    hourHeight: 8,
    hourTop: 2,
    handLeft: 10,
    // Supposed to be either 'hour' for a clock view or 'day' for a calendar view or 'allday' for weekview all day header
    mode: 'hour',
    setMode: function(mode) {
        this.mode = mode;
    },
    getRotateStyle: function(degrees) {
        return "transform:rotate(Ddeg);".replace(/D/g, degrees);
    },
    constructor: function() {
        var me = this;
        me.callParent([
            '<div class="sch-clockwrap sch-supports-border-radius' + ' sch-clock-{[this.mode]}">' + '<div class="sch-clock">' + '<div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ', + ' + this.hourHeight + ')]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div>' + '<div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6,' + this.minuteTop + ', + ' + this.minuteHeight + ')]}">{[values.date.getDate()]}</div>' + '<div class="sch-clock-dot"></div>' + '</div>' + '<span class="sch-clock-text">{text}</span>' + '</div>',
            {
                getMinuteStyle: me.getRotateStyle,
                getHourStyle: me.getRotateStyle
            }
        ]);
    }
});


/**
 @class Sch.tooltip.Tooltip
 @extends Ext.ToolTip
 @private

 Internal plugin showing a tooltip with event start/end information.
 */
Ext.define("Sch.tooltip.Tooltip", {
    extend: "Ext.tip.ToolTip",
    requires: [
        'Ext.XTemplate',
        'Sch.tooltip.ClockTemplate'
    ],
    autoHide: false,
    anchor: 'b',
    padding: '0 3 0 0',
    showDelay: 0,
    hideDelay: 0,
    quickShowInterval: 0,
    dismissDelay: 0,
    trackMouse: false,
    anchorOffset: 5,
    shadow: false,
    frame: false,
    schedulerView: null,
    message: null,
    startDate: null,
    endDate: null,
    template: null,
    valid: true,
    mode: null,
    offsetAdjust: [
        18,
        5
    ],
    clockTpl: null,
    constructor: function(config) {
        var me = this;
        me.clockTpl = new Sch.tooltip.ClockTemplate();
        me.startDate = me.endDate = new Date();
        if (!me.template) {
            me.template = new Ext.XTemplate([
                '<div class="' + Ext.baseCSSPrefix + 'fa sch-tip-{[values.valid ? "ok fa-check" : "notok fa-ban"]} ">' + '{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}' + '{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}' + '<div class="sch-tip-message">{message}</div>' + '</div>',
                {
                    renderClock: function(date, text, cls) {
                        return me.clockTpl.apply({
                            date: date,
                            text: text,
                            cls: cls
                        });
                    }
                }
            ]);
        }
        me.callParent(arguments);
    },
    // set redraw to true if you want to force redraw of the tip
    // required to update drag tip after scroll
    update: function(startDate, endDate, valid, message, allDay) {
        if (this.startDate - startDate !== 0 || this.endDate - endDate !== 0 || this.valid !== valid || this.message !== message || this.allDay != allDay) {
            var timeAxis = this.schedulerView.timeAxis;
            var isUTC = timeAxis.isUTCTimeZone();
            if (!isUTC) {
                startDate = this.schedulerView.convertDateToTimeZone(startDate);
                endDate = this.schedulerView.convertDateToTimeZone(endDate);
            }
            // This will be called a lot so cache the values
            this.startDate = startDate;
            this.endDate = endDate;
            this.valid = valid;
            this.message = message;
            this.allDay = allDay;
            var startText, endText;
            if (isUTC) {
                startText = this.schedulerView.getTimeZoneFormattedDate(startDate);
                endText = this.schedulerView.getTimeZoneFormattedEndDate(endDate);
            } else {
                startText = this.schedulerView.getFormattedDate(startDate);
                endText = this.schedulerView.getFormattedEndDate(endDate, startDate);
            }
            if (allDay) {
                this.mode = 'calendar';
                this.clockTpl.setMode('allday');
            } else {
                this.mode = 'day';
                this.clockTpl.setMode('hour');
            }
            // If resolution is day or greater, and end date is greater then start date
            if (this.mode === 'calendar' && endDate.getHours() === 0 && endDate.getMinutes() === 0 && !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) {
                endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
            }
            this.callParent([
                this.template.apply({
                    valid: valid,
                    startDate: startDate,
                    endDate: endDate,
                    startText: startText,
                    endText: endText,
                    message: message,
                    allDay: allDay
                })
            ]);
        }
        // #3929
        // Realign on every update to keep position in sync
        // covered by 070_dragcreate_tip
        if (this.rendered && this.isVisible()) {
            if (Ext.getVersion().isGreaterThan('6.2.1')) {
                // call new public method in 6.2.1 to align tip and fix anchor
                this.realignToTarget();
            } else {
                this.realign();
            }
        }
    },
    showForElement: function(el, xOffset) {
        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = 'calendar';
            this.addCls('sch-day-resolution');
            this.removeCls('sch-hour-resolution');
        } else {
            this.mode = 'clock';
            this.removeCls('sch-day-resolution');
            this.addCls('sch-hour-resolution');
        }
        // xOffset has to have default value
        // when it's 18 tip is aligned to left border
        xOffset = arguments.length > 1 ? xOffset : this.offsetAdjust[0];
        this.mouseOffsets = [
            xOffset - this.offsetAdjust[0],
            -this.offsetAdjust[1]
        ];
        this.setTarget(el);
        this.show();
        this.realign();
    },
    realign: function() {
        this.alignTo(this.target, 'bl-tl?', this.mouseOffsets);
    },
    afterRender: function() {
        this.callParent(arguments);
        // In slower browsers, the mouse pointer may end up over the tooltip interfering with drag drop etc
        this.el.on('mouseenter', this.realign, this);
    }
});

/**
 * @class Sch.tooltip.HoverTip
 * HoverTip is a class that represents a tooltip with clock and time which updates as the mouse pointer moves over the schedule area.
 */
Ext.define('Sch.tooltip.HoverTip', {
    extend: 'Ext.tip.ToolTip',
    alias: 'widget.scheduler_hovertip',
    requires: [
        'Sch.tooltip.ClockTemplate'
    ],
    trackMouse: true,
    bodyCls: 'sch-hovertip',
    messageTpl: '<div class="sch-hovertip-msg">{message}</div>',
    autoHide: false,
    dismissDelay: 1000,
    showDelay: 0,
    /**
     * @cfg {Sch.mixin.SchedulerView} schedulerView (required) View instance to bind this tooltip to
     */
    schedulerView: null,
    clockTpl: null,
    lastTime: null,
    lastResource: null,
    initComponent: function() {
        var me = this;
        var view = me.schedulerView;
        me.clockTpl = new Sch.tooltip.ClockTemplate();
        me.messageTpl = new Ext.XTemplate(me.messageTpl);
        me.callParent(arguments);
        me.on('beforeshow', me.tipOnBeforeShow, me);
        view.mon(view.el, {
            mouseleave: function() {
                me.hide();
            },
            mousemove: me.handleMouseMove,
            scope: me
        });
        // Force hide on a mouse down, in case the user is having a click listener on the schedule element
        // to show a window popup for example - in that case the hover-tooltip should not interfere
        view.mon(view.el, {
            click: me.onBodyMouseDown,
            scope: me,
            delay: 1
        });
    },
    onBodyMouseDown: function() {
        this.hide();
    },
    handleMouseMove: function(e) {
        var me = this,
            view = me.schedulerView;
        if (me.disabled) {
            return;
        }
        // Hide tooltip in case user touched screen
        if (e.getTarget('.' + view.itemCls, 5) && !e.getTarget(view.eventSelector) && e.pointerType === 'mouse') {
            var time = view.getTimeZoneDateFromDomEvent(e, 'floor');
            if (time) {
                var resourceRecord = view.resolveResource(e.getTarget());
                if (!me.lastTime || time - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
                    me.lastResource = resourceRecord;
                    if (me.hidden) {
                        me.setClockMode();
                        me.show();
                    }
                    me.updateHoverTip(time, e);
                }
            } else {
                me.hide();
            }
        } else {
            me.hide();
        }
    },
    setClockMode: function() {
        var me = this,
            DATE = Sch.util.Date,
            timeRes = me.schedulerView.getTimeResolution();
        if (DATE.compareUnits(timeRes.unit, DATE.DAY) >= 0) {
            me.clockTpl.setMode('day');
        } else {
            me.clockTpl.setMode('hour');
        }
    },
    /**
     * Override this to render custom text to default hover tip
     * @param {Date} date
     * @param {Ext.event.Event} e Browser event
     * @return {String}
     */
    getText: function() {},
    // private
    updateHoverTip: function(date, e) {
        if (date) {
            var view = this.schedulerView,
                timeAxis = view.timeAxis,
                tipDate, text;
            // In case of UTC date is passed here not adjusted to TZ
            if (timeAxis.isUTCTimeZone()) {
                text = Sch.util.Date.format(date, view.getDisplayDateFormat(), 0);
                if (this.clockTpl.mode === 'hour') {
                    tipDate = Sch.util.Date.getUTCTime(date);
                } else {
                    tipDate = Sch.util.Date.getUTCDate(date);
                }
            } else {
                tipDate = date;
                text = view.getFormattedDate(tipDate);
            }
            var clockHtml = this.clockTpl.apply({
                    date: tipDate,
                    text: text
                });
            var messageHtml = this.messageTpl.apply({
                    message: this.getText(date, e)
                });
            this.update(clockHtml + messageHtml);
            this.lastTime = date;
        }
    },
    hide: function() {
        this.callParent(arguments);
        this.lastTime = this.lastResource = null;
    },
    tipOnBeforeShow: function(tip) {
        this.setClockMode();
        return !this.disabled;
    }
});

/**
 * @private
 * @class Sch.feature.DragCreator
 * @constructor
 * An internal class which shows a drag proxy while clicking and dragging.
 * Create a new instance of this plugin
 * @param {Object} config The configuration options
 */
Ext.define("Sch.feature.DragCreator", {
    requires: [
        'Ext.XTemplate',
        'Ext.ToolTip',
        'Sch.util.Date',
        'Sch.util.ScrollManager',
        'Sch.util.DragTracker',
        'Sch.tooltip.Tooltip',
        'Sch.tooltip.HoverTip'
    ],
    /**
     * @cfg {Boolean} disabled true to start disabled
     */
    disabled: false,
    /**
     * @cfg {Boolean} showHoverTip true to show a time tooltip when hovering over the time cells
     */
    showHoverTip: true,
    /**
     * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
     */
    showDragTip: true,
    /**
     * @cfg {Ext.tip.ToolTip/Object} dragTip
     * The tooltip instance to show while dragging to create a new event or a configuration object for the default instance of
     * {@link Sch.tooltip.ToolTip}
     */
    dragTip: null,
    /**
     * @cfg {Number} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
     */
    dragTolerance: 2,
    /**
     * @cfg {Ext.tip.ToolTip/Object} hoverTip
     * The tooltip instance to show when mouse pointer is over scheduling area or a configuration object
     */
    hoverTip: null,
    /**
     * An empty function by default, but provided so that you can perform custom validation on the event being created.
     * Return true if the new event is valid, false to prevent an event being created.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created. Will be null if Scheduler is in `week` mode
     * @param {Date} startDate
     * @param {Date} endDate
     * @return {Boolean} isValid
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    /**
     * @cfg {Object} trackerConfig A custom config object used to create the internal {@link Sch.util.DragTracker} instance
     */
    trackerConfig: null,
    schedulerView: null,
    /**
     * @cfg {Ext.Template/String} template The HTML template shown when dragging to create new items
     */
    template: '<div class="sch-dragcreator-proxy">' + '<div class="sch-event-inner">&#160;</div>' + '</div>',
    constructor: function(config) {
        Ext.apply(this, config || {});
        this.lastTime = new Date();
        if (!(this.template instanceof Ext.Template)) {
            this.template = new Ext.Template(this.template);
        }
        this.schedulerView.on("destroy", this.onSchedulerDestroy, this);
        if (Ext.supports.Touch) {
            this.schedulerView.on('boxready', this.initDragTracker, this);
        } else {
            this.schedulerView.el.on('mousemove', this.initDragTracker, this, {
                single: true
            });
        }
        this.callParent([
            config
        ]);
    },
    /**
     * Enable/disable the plugin
     * @param {Boolean} disabled True to disable this plugin
     */
    setDisabled: function(disabled) {
        this.disabled = disabled;
        if (this.hoverTip && this.hoverTip.setDisabled) {
            this.hoverTip.setDisabled(disabled);
        }
        if (this.dragTip && this.dragTip.setDisabled) {
            this.dragTip.setDisabled(disabled);
        }
    },
    getProxy: function() {
        if (!this.proxy) {
            this.proxy = this.template.append(this.schedulerView.getEl(), {}, true);
            this.proxy.hide = function() {
                this.setStyle({
                    left: 0,
                    right: 0,
                    top: '-10000px'
                });
            };
        }
        return this.proxy;
    },
    // private
    onBeforeDragStart: function(tracker, e) {
        var s = this.schedulerView,
            t = e.getTarget('.' + s.timeCellCls, 5);
        if (t && this.isCreateAllowed(e) && (!e.event.touches || e.event.touches.length === 1)) {
            var internalResource = s.resolveResource(t),
                resourceRecord = s.isWeekView() ? null : internalResource,
                dateTime = s.getDateFromDomEvent(e);
            if (!this.disabled && t && s.fireEvent('beforedragcreate', s, resourceRecord, dateTime, e) !== false) {
                // Save record if the user ends the drag outside the current row
                this.resourceRecord = resourceRecord;
                // Start time of the event to be created
                this.originalStart = dateTime;
                // Constrain the dragging within the current row schedule area
                this.resourceRegion = s.getScheduleRegion(internalResource, this.originalStart);
                // Save date constraints
                this.dateConstraints = s.getDateConstraints(internalResource, this.originalStart);
                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },
    isCreateAllowed: function(e) {
        return !e.getTarget(this.schedulerView.eventSelector);
    },
    disableHoverTip: function() {
        // Check to make sure component is created
        this.hoverTip && this.hoverTip.disable && this.hoverTip.disable();
    },
    // private
    onDragStart: function() {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            proxy = me.getProxy();
        this.dragging = true;
        if (this.hoverTip) {
            // Ext.tip.Tooltip will disable itself on click and reenable after 100ms
            this.hoverTip.on('enable', this.disableHoverTip, this);
            this.hoverTip.disable();
        }
        me.start = me.originalStart;
        me.end = me.start;
        me.originalScroll = view.getScroll();
        if (view.isHorizontal()) {
            me.rowBoundaries = {
                top: me.resourceRegion.top,
                bottom: me.resourceRegion.bottom
            };
        } else {
            me.rowBoundaries = {
                left: me.resourceRegion.left,
                right: me.resourceRegion.right
            };
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        if (view.rtl) {
            // proxy.setBox() is going to calculate relative coordinate
            // if not set to auto - coordinates are messed up
            proxy.setStyle({
                right: 'auto'
            });
        }
        proxy.setBox(dragRegion);
        proxy.show();
        view.fireEvent('dragcreatestart', view, proxy);
        if (me.showDragTip) {
            me.dragTip.enable();
            me.dragTip.update(me.start, me.end, true);
            me.dragTip.showForElement(proxy);
            // for some reason Ext set `visibility` to `hidden` after a couple of `.hide()` calls
            me.dragTip.setStyle('visibility', 'visible');
        }
        Sch.util.ScrollManager.activate(view, view.isHorizontal() ? 'horizontal' : 'vertical');
    },
    // private
    onDrag: function() {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            message = '',
            dates = view.getTimeZoneStartEndDatesFromRegion(dragRegion, 'round');
        if (!dates) {
            return;
        }
        me.start = dates.start || me.start;
        me.end = dates.end || me.end;
        var dc = me.dateConstraints;
        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }
        me.valid = this.validatorFn.call(me.validatorFnScope || me, me.resourceRecord, me.start, me.end);
        if (me.valid && typeof me.valid !== 'boolean') {
            message = me.valid.message;
            me.valid = me.valid.valid;
        }
        // If users returns nothing, that's interpreted as valid
        me.valid = (me.valid !== false);
        if (me.showDragTip) {
            me.dragTip.update(me.start, me.end, me.valid, message);
        }
        Ext.apply(dragRegion, me.rowBoundaries);
        var scroll = view.getScroll();
        var proxy = this.getProxy();
        proxy.setBox(dragRegion);
        if (view.isHorizontal()) {
            proxy.setY(me.resourceRegion.top + me.originalScroll.top - scroll.top);
        }
    },
    eventSwallower: function(e) {
        e.stopPropagation();
        e.preventDefault();
    },
    // private
    onDragEnd: function(tracker, e) {
        var me = this,
            s = me.schedulerView,
            doFinalize = true,
            t = e.getTarget(),
            el = Ext.get(t);
        // When dragging, we don't want a regular scheduleclick to fire - swallow the coming "click" event
        el.on('click', this.eventSwallower);
        me.unbindTimer = setTimeout(function() {
            el.un('click', me.eventSwallower);
        }, 100);
        me.dragging = false;
        if (me.showDragTip) {
            me.dragTip.disable();
        }
        if (!me.start || !me.end || (me.end - me.start <= 0)) {
            me.valid = false;
        }
        var createContext = {
                start: me.start,
                end: me.end,
                resourceRecord: me.resourceRecord,
                e: e,
                valid: me.valid,
                finalize: function(doCreate) {
                    me.finalize(doCreate, createContext);
                }
            };
        if (me.valid) {
            doFinalize = s.fireEvent('beforedragcreatefinalize', s, createContext, e, this.getProxy()) !== false;
        }
        if (doFinalize) {
            me.finalize(me.valid, createContext);
        }
        Sch.util.ScrollManager.deactivate();
    },
    createEvent: function(context) {
        var schedulerView = this.schedulerView,
            eventStore = schedulerView.getEventStore(),
            newEvent = Ext.create(eventStore.getModel()),
            resourceCalendar, resource;
        // if we deal w/ the Gantt task
        if (newEvent.isTaskModel) {
            // make sure the new model is aware of the task store presence
            newEvent.taskStore = eventStore;
            // if resource has a calendar set it temporarily on the task
            resource = context.resourceRecord;
            resourceCalendar = resource && resource.getCalendar && resource.getCalendar(true);
            if (resourceCalendar) {
                newEvent.setCalendar(resourceCalendar);
            }
        }
        newEvent.setStartEndDate(context.start, context.end);
        // Remove temporary calendar
        if (resourceCalendar) {
            newEvent.setCalendar(null);
        }
        return newEvent;
    },
    finalize: function(doCreate, context) {
        var schedulerView = this.schedulerView;
        if (doCreate) {
            schedulerView.fireEvent('dragcreateend', schedulerView, this.createEvent(context), context.resourceRecord, context.e, this.getProxy());
        }
        this.proxy.hide();
        this.schedulerView.fireEvent('afterdragcreate', schedulerView, this.getProxy());
        if (this.hoverTip) {
            this.hoverTip.un('enable', this.disableHoverTip, this);
            this.hoverTip.enable();
        }
    },
    dragging: false,
    // Lazy setup of additional functionality
    initDragTracker: function() {
        var me = this,
            isTouch = Ext.supports.Touch,
            view = me.schedulerView;
        var config = Ext.apply({
                el: view.el,
                rtl: view.rtl,
                tolerance: me.dragTolerance,
                listeners: {
                    mousedown: me.verifyLeftButtonPressed,
                    beforedragstart: me.onBeforeDragStart,
                    dragstart: me.onDragStart,
                    drag: me.onDrag,
                    dragend: me.onDragEnd,
                    scope: me
                }
            }, this.trackerConfig);
        this.bindRightClickPreventer();
        // Tips should be disabled for things like ipad, otherwise dragcreate suffers
        // But for desktop tips should be enabled
        if (isTouch && !Ext.platformTags.windows) {
            this.showDragTip = false;
            this.showHoverTip = false;
            this.dragTip = null;
            this.hoverTip = null;
        } else {
            this.setupTooltips();
        }
        me.tracker = new Sch.util.DragTracker(config);
    },
    // Prevent right clicks when drag creating an event
    bindRightClickPreventer: function() {
        this.schedulerView.el.on('contextmenu', this.stopDragCreateOnRightClick, this, {
            priority: 999
        });
    },
    stopDragCreateOnRightClick: function(e) {
        // https://www.assembla.com/spaces/bryntum/tickets/2113
        // To unify behavior of IE under different OS's (especially for windows 7)
        // we interpret right mouse button down as left mouse button up to stop drag create.
        // NOTE: Cannot be tested in siesta using simulated events
        if (e.button !== 0 && this.dragging) {
            this.tracker.onMouseUp(e);
        }
    },
    setupTooltips: function() {
        var me = this,
            sv = me.schedulerView;
        if (this.showDragTip) {
            var dragTip = this.dragTip;
            if (dragTip instanceof Ext.tip.ToolTip) {
                dragTip.schedulerView = sv;
                dragTip.on('beforeshow', function() {
                    return me.dragging;
                });
            } else {
                this.dragTip = new Sch.tooltip.Tooltip(Ext.apply({
                    cls: 'sch-dragcreate-tip',
                    schedulerView: sv,
                    constrainTo: sv.up('grid').el,
                    listeners: {
                        beforeshow: function() {
                            return me.dragging;
                        }
                    }
                }, dragTip));
            }
        }
        if (me.showHoverTip) {
            var hoverTip = me.hoverTip;
            if (hoverTip instanceof Ext.tip.ToolTip) {
                hoverTip.schedulerView = sv;
            } else {
                me.hoverTip = Ext.ComponentManager.create(Ext.applyIf({
                    renderTo: Ext.getBody(),
                    target: sv.el,
                    schedulerView: sv
                }, hoverTip), 'scheduler_hovertip');
            }
        }
    },
    verifyLeftButtonPressed: function(dragTracker, e) {
        return e.button === 0;
    },
    onSchedulerDestroy: function() {
        // hoverTip might still be a config object if tip hasn't been instantiated/rendered
        if (this.hoverTip && this.hoverTip.destroy) {
            this.hoverTip.destroy();
        }
        // dragTip might still be a config object if tip hasn't been instantiated/rendered
        if (this.dragTip && this.dragTip.destroy) {
            this.dragTip.destroy();
        }
        if (this.tracker) {
            this.tracker.destroy();
        }
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
        clearTimeout(this.unbindTimer);
    }
});

/**
 @class Sch.feature.SchedulerDragZone
 @extends Ext.dd.DragZone

 A custom scheduler dragzone that also acts as the dropzone, and optionally
 constrains the drag to the resource area that contains the dragged element.

 Generally it should not need to be used directly.
 To configure drag and drop use {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig instead.
 */
Ext.define("Sch.feature.SchedulerDragZone", {
    extend: "Ext.dd.DragZone",
    requires: [
        'Ext.dd.StatusProxy',
        'Sch.tooltip.Tooltip'
    ],
    uses: [
        'Sch.model.Event',
        'Sch.model.Assignment',
        'Sch.util.Date',
        'Sch.patches.DragZone'
    ],
    animRepair: false,
    repairHighlight: false,
    repairHighlightColor: 'transparent',
    // this has to be set to `false` because we will manually register the view element in the ScrollManager
    // we don't need to register the dragged element in it
    containerScroll: false,
    checkDraggingFlag: true,
    getConstrainRegion: null,
    /**
     * @cfg {Boolean} showTooltip Specifies whether or not to show tooltip while dragging event
     */
    showTooltip: true,
    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while dragging event or a configuration object
     */
    tip: null,
    // this property is taking part in coordinates calculations in alignElWithMouse
    // these adjustments required for correct positioning of proxy on mouse move after view scroll
    deltaSetXY: null,
    schedulerView: null,
    _onValidDropTimer: null,
    // The last 'good' coordinates received by mousemove events (needed when a scroll event happens, which doesn't contain XY info)
    lastXY: null,
    /**
     * @type {Boolean} showExactDropPosition When enabled, the event being dragged always "snaps" to the exact start date that it will have after drop.
     */
    showExactDropPosition: false,
    /**
     * @cfg {Boolean} enableCopy true to enable copy by pressing modifier key
     * (see {@link #enableCopyKey enableCopyKey}) during drag drop.
     */
    enableCopy: false,
    /**
     *
     * @cfg {String} enableCopyKey
     * Modifier key that should be pressed during drag drop to copy item.
     * Available values are 'CTRL', 'ALT', 'SHIFT'
     */
    enableCopyKey: 'SHIFT',
    /**
     * @cfg {Object} validatorFn
     *
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    validatorFn: function(dragRecords, targetResourceRecord, date, duration, e) {
        return true;
    },
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the {@link #validatorFn}
     */
    validatorFnScope: null,
    copyKeyPressed: false,
    keyListener: null,
    viewScrollListener: null,
    gridScrollListener: null,
    /**
     * @cfg {String} dragDropProxyCls Special CSS class added to drag proxy to perform lookups
     * @required
     * @private
     */
    dragDropProxyCls: 'sch-dd-ref',
    invalidCssClasses: [
        'sch-resizable-handle',
        'sch-terminal'
    ],
    /**
     * @constructor
     * @param {String/HTMLElement/Ext.dom.Element} el The container element or its ID
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor: function(el, config) {
        var proxy = this.proxy = this.proxy || new Ext.dd.StatusProxy({
                shadow: false,
                dropAllowed: this.dropAllowed,
                dropNotAllowed: this.dropNotAllowed,
                // HACK, we want the proxy inside the scheduler, so that when user drags the event
                // out of the scheduler el, the event should be cropped by the scheduler edge
                ensureAttachedToBody: Ext.emptyFn
            });
        this.callParent(arguments);
        this.isTarget = true;
        this.scroll = false;
        this.ignoreSelf = false;
        var schedulerView = this.schedulerView;
        Ext.Array.each(this.invalidCssClasses, this.addInvalidHandleClass, this);
        if (schedulerView.touchScroll) {
            // disable tooltips for touch devices
            this.showTooltip = false;
        }
        this.el.appendChild(proxy.el);
        this.bindRightClickPreventer();
        this.el.highlight = Ext.emptyFn;
        // Not interested in any animated highlight after invalid drop
        proxy.addCls('sch-dragproxy');
        // Activate the auto-scrolling behavior during the drag drop process
        schedulerView.on({
            eventdragstart: function() {
                Sch.util.ScrollManager.activate(schedulerView, schedulerView.constrainDragToResource && schedulerView.getMode());
            },
            aftereventdrop: function() {
                Sch.util.ScrollManager.deactivate();
            },
            scope: this
        });
        if (this.showTooltip) {
            var tip = this.tip;
            if (tip instanceof Ext.tip.ToolTip) {
                tip.schedulerView = schedulerView;
            } else {
                this.tip = new Sch.tooltip.Tooltip(Ext.apply({
                    schedulerView: schedulerView,
                    constrainTo: schedulerView.up('grid').el,
                    // bug in 6.2.1, covered by 122_dragdrop_tip
                    alignOnScroll: false,
                    cls: 'sch-dragdrop-tip'
                }, tip));
            }
        }
    },
    bindRightClickPreventer: function() {
        this.schedulerView.el.on('mousedown', this.preventRightClick, this, {
            priority: 999
        });
    },
    destroy: function() {
        this.tip && this.tip.destroy();
        this.cleanupListeners();
        clearTimeout(this._onValidDropTimer);
        this.callParent(arguments);
    },
    // Prevents right clicking when dragging is in progress
    preventRightClick: function(e) {
        if (this.dragging && e.button !== 0) {
            return false;
        }
    },
    // @OVERRIDE
    autoOffset: function() {
        this.setDelta(0, 0);
    },
    // private
    setupConstraints: function(constrainRegion, elRegion, xOffset, yOffset, isHorizontal, tickSize, constrained) {
        this.clearTicks();
        var xTickSize = isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
        var yTickSize = !isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
        this.resetConstraints();
        this.initPageX = constrainRegion.left + xOffset;
        this.initPageY = constrainRegion.top + yOffset;
        var width = elRegion.right - elRegion.left;
        var height = elRegion.bottom - elRegion.top;
        // if `constrained` is false then we haven't specified getDateConstraint method and should constrain mouse position to scheduling area
        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.
        if (isHorizontal) {
            if (constrained) {
                this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            } else {
                this.setXConstraint(constrainRegion.left, constrainRegion.right, xTickSize);
            }
            this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
        } else {
            this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            if (constrained) {
                this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
            } else {
                this.setYConstraint(constrainRegion.top, constrainRegion.bottom, yTickSize);
            }
        }
    },
    // @OVERRIDE
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = iLeft;
        this.rightConstraint = iRight;
        this.minX = iLeft;
        this.maxX = iRight;
        if (iTickSize) {
            this.setXTicks(this.initPageX, iTickSize);
        }
        this.constrainX = true;
    },
    // @OVERRIDE
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = iUp;
        this.bottomConstraint = iDown;
        this.minY = iUp;
        this.maxY = iDown;
        if (iTickSize) {
            this.setYTicks(this.initPageY, iTickSize);
        }
        this.constrainY = true;
    },
    // These cause exceptions, and are not needed
    onDragEnter: Ext.emptyFn,
    onDragOut: Ext.emptyFn,
    setVisibilityForSourceEvents: function(show) {
        Ext.Array.each(this.dragData.getEventBarElements(), function(el) {
            el && Ext.fly(el)[show ? 'show' : 'hide']();
        });
    },
    // private
    onDragOver: function(e) {
        if (e && e.event.touches && e.event.touches.length > 1) {
            // Force a stop if multi touch is detected
            Ext.dd.DragDropManager.handleMouseUp(e);
            return;
        }
        var xy = e ? e.getXY() : this.lastXY;
        // May have a situation where user grabs an event, drags it outside the view - then when back in the view the first thing
        // that happens is a view scroll
        if (!xy)  {
            return;
        }
        
        var dd = this.dragData;
        if (!dd.originalHidden) {
            // Hide dragged event elements at this time
            this.setVisibilityForSourceEvents(false);
            dd.originalHidden = true;
            if (this.enableCopy) {
                this.onShiftKeyStateChange(e[this.enableCopyKey.toLowerCase() + 'Key']);
            }
        }
        var start = dd.startDate;
        var resource = dd.newResource;
        var view = this.schedulerView;
        this.updateDragContext(e);
        if (this.showExactDropPosition) {
            var timeDiff = view.getDateFromXY(xy) - dd.sourceDate;
            var realStart = new Date(dd.origStart - 0 + timeDiff);
            var offset = view.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);
            if (dd.startDate > view.timeAxis.getStart()) {
                var proxyEl = this.proxy.el;
                if (offset) {
                    if (view.isHorizontal()) {
                        proxyEl.setX(xy[0] + (view.shouldAdjustForRtl() ? -offset : offset));
                    } else {
                        proxyEl.setY(xy[1] + offset);
                    }
                }
            }
        }
        if (dd.startDate - start !== 0 || resource !== dd.newResource) {
            view.fireEvent('eventdrag', view, dd.draggedRecords, dd.startDate, dd.newResource, dd);
        }
        if (this.showTooltip) {
            var event = dd.getEventRecord();
            if (event.getAllDay && event.getAllDay() && !dd.isAllDayDrop) {
                this.tip.update(dd.vAdjustedPointerDate, Sch.util.Date.add(dd.vAdjustedPointerDate, Sch.util.Date.HOUR, 1), dd.valid, dd.message, dd.isAllDayDrop);
            } else if (dd.isAllDayDrop) {
                this.tip.update(Sch.model.Event.getAllDayDisplayStartDate(dd.startDate), Sch.model.Event.getAllDayDisplayEndDate(dd.startDate, dd.endDate), dd.valid, dd.message, dd.isAllDayDrop);
            } else {
                this.tip.update(dd.startDate, dd.endDate, dd.valid, dd.message, dd.isAllDayDrop);
            }
        }
        if (e) {
            this.lastXY = [
                e.browserEvent.clientX + document.body.scrollLeft,
                e.getY()
            ];
        }
    },
    getDragData: function(e) {
        var schedulerView = this.schedulerView,
            eventNode = e.getTarget(schedulerView.eventSelector);
        this.started = false;
        if (!eventNode || e.event.touches && e.event.touches.length > 1)  {
            return;
        }
        
        var eventRecord = schedulerView.resolveEventRecord(eventNode),
            resourceRecord = schedulerView.resolveResource(eventNode),
            assignmentRecord = schedulerView.resolveAssignmentRecord(eventNode),
            // there will be no event record when trying to drag the drag creator proxy for example
            allowDrag = eventRecord && eventRecord.isDraggable() && !schedulerView.isReadOnly();
        if (!allowDrag) {
            return null;
        }
        var xy = e.getXY(),
            eventXY = Ext.fly(eventNode).getXY(),
            offsets = [
                xy[0] - eventXY[0],
                xy[1] - eventXY[1]
            ],
            eventRegion = Ext.fly(eventNode).getRegion();
        this.lastXY = null;
        var isHorizontal = schedulerView.isHorizontal();
        schedulerView.constrainDragToResource && !resourceRecord && Ext.Error.raise('Resource could not be resolved for event: ' + eventRecord.getId());
        var dateConstraints = schedulerView.getDateConstraints(schedulerView.constrainDragToResource ? resourceRecord : null, eventRecord);
        var constrainRegion;
        if (schedulerView.isWeekView()) {
            constrainRegion = this.el.getRegion();
            if (eventRecord.getAllDay()) {
                constrainRegion = constrainRegion.adjust(-10000, 10000, 10000, -10000);
            }
        } else {
            constrainRegion = this.getConstrainRegion ? this.getConstrainRegion() : schedulerView.getScheduleRegion(schedulerView.constrainDragToResource ? resourceRecord : null, eventRecord);
        }
        this.setupConstraints(constrainRegion, eventRegion, offsets[0], offsets[1], isHorizontal, eventRecord.getAllDay && eventRecord.getAllDay() ? 1 : schedulerView.getSnapPixelAmount(), Boolean(dateConstraints));
        var origStart = eventRecord.get(eventRecord.startDateField),
            origEnd = eventRecord.get(eventRecord.endDateField),
            timeAxis = schedulerView.timeAxis,
            relatedRecords = this.getRelatedRecords(assignmentRecord || eventRecord) || [],
            eventBarEls = schedulerView.getElementsFromEventRecord(eventRecord, schedulerView.isWeekView() ? null : resourceRecord, null, true);
        // Collecting additional elements to drag
        Ext.Array.each(relatedRecords, function(r) {
            if (r && r.isAssignmentModel) {
                eventBarEls = eventBarEls.concat(schedulerView.getElementsFromEventRecord(r.getEvent(), r.getResource(), null, true));
            } else {
                eventBarEls = eventBarEls.concat(schedulerView.getElementsFromEventRecord(r, null, null, true));
            }
        });
        eventBarEls = Ext.Array.unique(eventBarEls);
        // I'm not sure if it's required, but this way it seems safer
        var dragData = {
                offsets: offsets,
                repairXY: eventXY,
                triggerEvent: e,
                prevScroll: schedulerView.getScroll(),
                dateConstraints: dateConstraints,
                eventBarEls: eventBarEls,
                // During infinite scroll the scheduling view might be refreshed, due to time axis reconfiguration,
                // thus destroying previously stored DOM elements (and possibly new DOMs rendered),
                // by getting stored event elements via this method we make sure to always get fresh Elements
                // and ignore stale ones.
                getEventBarElements: function() {
                    return dragData.eventBarEls = Ext.Array.map(dragData.eventBarEls, function(el) {
                        return el && document.getElementById(el.id);
                    });
                },
                draggedRecords: [
                    assignmentRecord || eventRecord
                ].concat(relatedRecords),
                getEventRecord: function() {
                    var record = this.draggedRecords[0];
                    if (record instanceof Sch.model.Assignment) {
                        record = record.getEvent();
                    }
                    return record;
                },
                resourceRecord: resourceRecord,
                sourceDate: schedulerView.getTimeZoneDateFromXY(xy),
                origStart: origStart,
                origEnd: origEnd,
                startDate: origStart,
                endDate: origEnd,
                timeDiff: 0,
                startsOutsideView: origStart < timeAxis.getStart(),
                endsOutsideView: origEnd > timeAxis.getEnd(),
                duration: origEnd - origStart
            };
        this.copyKeyPressed = this.enableCopy && e[this.enableCopyKey.toLowerCase() + 'Key'];
        dragData.ddel = this.getDragElement(eventNode, dragData);
        return dragData;
    },
    onStartDrag: function() {
        var schedulerView = this.schedulerView,
            dd = this.dragData;
        // To make sure any elements made visible by hover are not visible when the original element is hidden (using visibility:hidden)
        Ext.Array.each(dd.getEventBarElements(), function(el) {
            Ext.fly(el).removeCls('sch-event-hover');
        });
        schedulerView.fireEvent('eventdragstart', schedulerView, dd.draggedRecords);
        this.viewScrollListener = schedulerView.getScrollable().on({
            scroll: this.onViewScroll,
            destroyable: true,
            scope: this
        });
        this.gridScrollListener = schedulerView.up('timelinetree,timelinegrid').getScrollable().on({
            scroll: this.onViewScroll,
            destroyable: true,
            scope: this
        });
    },
    alignElWithMouse: function(el, iPageX, iPageY) {
        this.callParent(arguments);
        // HACK proxy position calculation is off the first drag action in IE with RTL + viewport
        if (Ext.isIE && this.schedulerView.rtl && this.schedulerView.up('[isViewport]')) {
            this.deltaSetXY = null;
            this.callParent(arguments);
        }
        var oCoord = this.getTargetCoord(iPageX, iPageY),
            fly = el.dom ? el : Ext.fly(el, '_dd');
        // original method limits task position by viewport dimensions
        // our drag proxy is located on secondary canvas and can have height larger than viewport
        // so we have to set position relative to bigger secondary canvas
        this.setLocalXY(fly, oCoord.x + this.deltaSetXY[0], oCoord.y + this.deltaSetXY[1]);
    },
    onViewScroll: function(scrollable) {
        // var proxy              = this.proxy,
        // s                  = this.schedulerView,
        // dd                 = this.dragData,
        // scroll             = s.getScroll(),
        // left               = scroll.left,
        // top                = scroll.top,
        // rtlWithoutViewport = s.rtl && !s.up('[isViewport]'); // Ext JS has different behavior for viewport case vs non-viewport case.
        this.setVisibilityForSourceEvents(false);
        // var xy = proxy.getXY();
        // getScroll works different for RTL case: it will return 0 when view is scrolled max to the right
        // var newXY;
        //
        // if (rtlWithoutViewport) {
        //     newXY = [xy[0] - left + dd.prevScroll.left, xy[1] + top - dd.prevScroll.top];
        // } else {
        //     newXY = [xy[0] + left - dd.prevScroll.left, xy[1] + top - dd.prevScroll.top];
        // }
        // var deltaSetXY = this.deltaSetXY;
        // if (rtlWithoutViewport) {
        //     this.deltaSetXY = [deltaSetXY[0] - left + dd.prevScroll.left, deltaSetXY[1] + top - dd.prevScroll.top];
        // } else {
        //     this.deltaSetXY = [deltaSetXY[0] + left - dd.prevScroll.left, deltaSetXY[1] + top - dd.prevScroll.top];
        // }
        // dd.prevScroll = { left : left, top : top };
        // proxy.setXY(newXY);
        this.onDragOver();
    },
    /**
     * Returns true if the current action is a copy action.
     * @returns {boolean}
     */
    isCopyKeyPressed: function() {
        return this.enableCopy && this.copyKeyPressed;
    },
    onShiftKeyStateChange: function(pressed) {
        var dd = this.dragData;
        if (pressed) {
            dd.refElements.addCls('sch-event-copy');
        } else {
            dd.refElements.removeCls('sch-event-copy');
        }
        this.setVisibilityForSourceEvents(pressed);
        this.copyKeyPressed = pressed;
    },
    onKey: function(e) {
        if (this.enableCopy && e.getKey() === e[this.enableCopyKey]) {
            this.onShiftKeyStateChange(e.type === 'keydown');
        }
        // Simulate abort on ESC key
        if (e.getKey() === e.ESC) {
            this.abortDrag(e);
        }
    },
    abortDrag: function(event) {
        this.dragData.ddCallbackArgs = [
            event.getTarget(),
            event,
            this.id
        ];
        this.finalize(false);
        Ext.dd.DragDropManager.stopDrag(event);
        Ext.dd.DragDropManager.stopEvent(event);
    },
    // HACK, overriding private method, proxy needs to be shown before aligning to it
    startDrag: function() {
        var schedulerView = this.schedulerView,
            dragData = this.dragData;
        if (schedulerView.fireEvent('beforeeventdrag', schedulerView, dragData.draggedRecords[0], dragData.triggerEvent) === false) {
            this.abortDrag(dragData.triggerEvent);
            return;
        }
        var retVal = this.callParent(arguments);
        this.started = true;
        // No sense to use `this.schedulerView.mon` since this.destroy is called on this.schedulerView.destroy and cleans up all listeners
        this.keyListener = Ext.getDoc().on({
            keydown: this.onKey,
            keyup: this.onKey,
            useCapture: true,
            destroyable: true,
            scope: this
        });
        // This is the representation of the original element inside the proxy
        dragData.refElement = this.proxy.el.down('.' + this.dragDropProxyCls);
        dragData.refElements = this.proxy.el.select('.sch-event');
        // The dragged element should not be in hover state
        dragData.refElement.removeCls('sch-event-hover');
        if (this.showTooltip) {
            // Seems required as of Ext 4.1.0, to clear the visibility:hidden style.
            this.tip.setStyle('visibility');
            this.tip.update(dragData.origStart, dragData.origEnd, true);
            this.tip.showForElement(dragData.refElement, dragData.offsets[0]);
        }
        if (this.copyKeyPressed) {
            dragData.refElements.addCls('sch-event-copy');
            dragData.originalHidden = true;
        }
        return retVal;
    },
    endDrag: function() {
        this.cleanupListeners();
        this.callParent(arguments);
    },
    cleanupListeners: function() {
        if (this.viewScrollListener) {
            this.viewScrollListener.destroy();
            this.viewScrollListener = null;
        }
        if (this.gridScrollListener) {
            this.gridScrollListener.destroy();
            this.gridScrollListener = null;
        }
        if (this.keyListener) {
            this.keyListener.destroy();
            this.keyListener = null;
        }
    },
    onMouseUp: function() {
        if (!this.dragging) {
            // Reset drag proxy position on a simple mouse click (which triggers a change in the 'left' position of the proxy el)
            this.afterDragFinalized();
        }
    },
    afterDragFinalized: function() {
        // https://www.assembla.com/spaces/bryntum/tickets/1524#/activity/ticket:
        // If drag is done close to the edge to invoke scrolling, the proxy could be left there and interfere
        // with the view sizing if the columns are shrunk.
        this.proxy.el.dom.style.top = this.proxy.el.dom.style.left = 0;
    },
    updateRecords: function(context) {
        var me = this,
            schedulerView = me.schedulerView,
            eventStore = schedulerView.getEventStore(),
            resourceStore = schedulerView.getResourceStore(),
            assignmentStore = eventStore.getAssignmentStore(),
            newResource = context.newResource,
            draggedRecord = context.draggedRecords[0],
            relatedDraggedRecords = context.draggedRecords.slice(1),
            resourceRecord = context.resourceRecord,
            copyKeyPressed = me.isCopyKeyPressed(),
            startDate = context.startDate,
            vAdjustedPointerDate = context.vAdjustedPointerDate,
            hAdjustedPointerDate = context.hAdjustedPointerDate,
            // Context has a timeDiff which is a difference between pointer's start and finish positions. This time
            // diff is actual difference between initial event start date and final start date. This is used to adjust
            // related events
            timeDiff = startDate - context.origStart,
            isWeekView = schedulerView.isWeekView(),
            addedRecords;
        // Scheduler multiple assignment mode
        if (assignmentStore && eventStore instanceof Sch.data.EventStore) {
            me.updateRecordsMultipleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, assignmentStore, copyKeyPressed, isWeekView, hAdjustedPointerDate, vAdjustedPointerDate);
        }
        // Gantt mode (and task store instead of event store)
        else if (assignmentStore) {
            addedRecords = me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord.getEvent(), Ext.Array.map(relatedDraggedRecords, function(r) {
                return r.getEvent();
            }), resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, isWeekView, hAdjustedPointerDate, vAdjustedPointerDate);
        } else // Scheduler single assignment mode
        {
            addedRecords = me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, isWeekView, hAdjustedPointerDate, vAdjustedPointerDate);
        }
        if (copyKeyPressed) {
            context.copiedRecords = addedRecords;
        }
        // Tell the world there was a successful drop
        schedulerView.fireEvent('eventdrop', schedulerView, context.copiedRecords || context.draggedRecords, copyKeyPressed);
    },
    updateRecordsSingleAssignmentMode: function(startDate, timeDiff, draggedEvent, relatedEvents, fromResource, toResource, eventStore, resourceStore, copy, isWeekView, hPointerDate, vPointerDate) {
        // The code is written to emit as little store events as possible
        var me = this,
            toAdd = [],
            wasAllDay = draggedEvent.getAllDay && draggedEvent.getAllDay(),
            UD = Sch.util.Date,
            newStart;
        if (copy) {
            draggedEvent = draggedEvent.fullCopy(null);
            toAdd.push(draggedEvent);
        }
        // Process original dragged record
        draggedEvent.beginEdit();
        // in weekview resources are just time spans, so we have to skip this part
        if (fromResource && fromResource.isResourceModel && toResource && toResource.isResourceModel && toResource !== fromResource) {
            if (copy) {
                draggedEvent.assign(toResource);
            } else {
                draggedEvent.reassign(fromResource, toResource);
            }
        }
        draggedEvent.setAllDay && draggedEvent.setAllDay(me.dragData.isAllDayDrop);
        if (draggedEvent.getAllDay && draggedEvent.getAllDay()) {
            newStart = UD.copyTimeValues(UD.clearTime(startDate, true), me.dragData.origStart);
            // NOTE: The last parameter here is only if event store is actually a task store
            draggedEvent.setStartEndDate(newStart, UD.add(newStart, UD.MILLI, me.dragData.duration), eventStore.skipWeekendsDuringDragDrop);
        } else if (wasAllDay) {
            // NOTE: The last parameter here is only if event store is actually a task store
            draggedEvent.setStartEndDate(vPointerDate, UD.add(vPointerDate, UD.HOUR, 1), eventStore.skipWeekendsDuringDragDrop);
        } else {
            // NOTE: The last parameter here is only if event store is actually a task store
            draggedEvent.setStartDate(startDate, true, eventStore.skipWeekendsDuringDragDrop);
        }
        draggedEvent.endEdit();
        Ext.Array.each(relatedEvents, function(related) {
            // grabbing resources early, since after ".copy()" the record won't belong to any store
            // and ".getResources()" won't work
            var relatedResources = isWeekView ? null : related.getResources();
            if (copy) {
                related = related.fullCopy(null);
                toAdd.push(related);
            }
            related.beginEdit();
            // calculate new startDate (and round it) based on timeDiff
            related.setStartDate(UD.add(related.getStartDate(), UD.MILLI, timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
            // in weekview drag&drop resource doesn't change
            if (!isWeekView) {
                // Process related records
                var indexDiff = resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource);
                indexDiff !== 0 && relatedResources.length && Ext.Array.each(relatedResources, function(r) {
                    var newIndex = resourceStore.indexOf(r) - indexDiff,
                        newResource;
                    if (newIndex < 0) {
                        newIndex = 0;
                    } else if (newIndex >= resourceStore.getCount()) {
                        newIndex = resourceStore.getCount() - 1;
                    }
                    newResource = resourceStore.getAt(newIndex);
                    related.reassign(r, newResource);
                });
            }
            related.endEdit();
        });
        if (toAdd.length) {
            eventStore.append(toAdd);
        }
        return toAdd;
    },
    updateRecordsMultipleAssignmentMode: function(startDate, timeDiff, draggedAssignment, relatedAssignments, fromResource, toResource, eventStore, resourceStore, assignmentStore, copy, isWeekView, hPointerDate, vPointerDate) {
        var me = this,
            UD = Sch.util.Date;
        // In case multiSelect is true, several assignments to one event may be processed here. We will store
        // ids of processed events here to avoid setting incorrect start date
        var handledEventsMap = {};
        Ext.Array.each([].concat(draggedAssignment, relatedAssignments), function(assignment) {
            var event = assignment.getEvent();
            if (handledEventsMap[event.getId()]) {
                return;
            }
            handledEventsMap[event.getId()] = true;
            event.setStartDate(UD.add(event.getStartDate(), UD.MILLI, timeDiff), true, eventStore.skipWeekendsDuringDragDrop);
            // if we dragged the event to a different resource
            if (!isWeekView && fromResource !== toResource) {
                if (copy) {
                    event.assign(toResource);
                } else if (!event.isAssignedTo(toResource)) {
                    event.reassign(assignment.getResource(), toResource);
                } else {
                    event.unassign(assignment.getResource());
                }
            }
        });
    },
    isValidDrop: function(oldResource, newResource, sourceRecord) {
        // Not allowed to assign an event twice to the same resource -
        // which might happen when we deal with an assignment store
        if (oldResource !== newResource) {
            // if we operate assignments
            if (sourceRecord.isAssignmentModel) {
                return !sourceRecord.getEvent().isAssignedTo(newResource);
            } else {
                return !sourceRecord.isAssignedTo(newResource);
            }
        }
        return true;
    },
    resolveResource: function(xy) {
        var proxyDom = this.proxy.el.dom;
        var bodyScroll = Ext.getBody().getScroll();
        var view = this.schedulerView;
        proxyDom.style.display = 'none';
        var node = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
        proxyDom.style.display = 'block';
        if (!node) {
            return null;
        }
        if (Ext.fly(node).up('.' + Ext.baseCSSPrefix + 'grid-group-hd', 4, true)) {
            return null;
        }
        // If we hover a table row border we will match a row element here.
        // We then need to adjust the Y-pos to get a cell which gives us the correct cell index.
        if (node.className.match(Ext.baseCSSPrefix + 'grid-item')) {
            return this.resolveResource([
                xy[0],
                xy[1] + 3
            ]);
        }
        if (!node.className.match(view.timeCellCls)) {
            var parent = Ext.fly(node).up('.' + view.timeCellCls);
            if (parent) {
                node = parent.dom;
            } else {
                return null;
            }
        }
        return view.resolveResource(node);
    },
    adjustStartDate: function(startDate, timeDiff, schedulerView) {
        var view = schedulerView || this.schedulerView;
        var newStartDate = new Date(startDate - 0 + timeDiff);
        if (view.timeAxis.hasTimeZone() && Sch.util.Date.compareUnits(Sch.util.Date.DAY, view.timeAxis.resolutionUnit) <= 0) {
            return view.roundDateInTimeZone(newStartDate, 'round');
        } else {
            return view.timeAxis.roundDate(newStartDate, view.snapRelativeToEventStartDate ? startDate : false);
        }
    },
    resolveSchedulerView: function(e) {
        var viewEl = e.getTarget('.sch-schedulerview');
        return viewEl && Ext.getCmp(viewEl.id) || this.schedulerView;
    },
    // private
    updateDragContext: function(e) {
        var dd = this.dragData,
            xy = e ? e.getXY() : this.lastXY,
            clientX, rawXY;
        if (e) {
            if (e.browserEvent.touches && e.browserEvent.touches.length > 0) {
                clientX = e.browserEvent.touches[0].clientX;
            } else {
                clientX = e.browserEvent.clientX != null ? e.browserEvent.clientX : e.clientX;
            }
            // Ext JS might convert e.getXY() coordinates to be calculated from right side if Scheduler is in a viewport
            // So for resource lookup we always use the raw browser XY since we rely on document.elementFromPoint
            rawXY = [
                clientX + document.body.scrollLeft,
                e.getY()
            ];
        } else {
            rawXY = this.lastXY;
        }
        if (!dd.refElement) {
            return;
        }
        // In week view mode, first find the responsible scheduler view
        var schedulerView = (e && this.schedulerView.isWeekView() && this.resolveSchedulerView(e)) || this.schedulerView,
            proxyRegion = dd.refElement.getRegion(),
            pointerDate;
        pointerDate = schedulerView.getTimeZoneDateFromXY(xy);
        dd.pointerDate = pointerDate;
        dd.vAdjustedPointerDate = this.adjustStartDate(schedulerView.getDateFromXY([
            xy[0] - dd.offsets[0],
            xy[1]
        ]), 0, schedulerView);
        dd.hAdjustedPointerDate = this.adjustStartDate(schedulerView.getDateFromXY([
            xy[0],
            xy[1] - dd.offsets[1]
        ]), 0, schedulerView);
        dd.isAllDayDrop = Boolean(schedulerView.allDay);
        if (schedulerView.timeAxis.isContinuous()) {
            if ((schedulerView.isHorizontal() && this.minX < xy[0] && xy[0] < this.maxX) || (!schedulerView.isHorizontal() && this.minY < xy[1] && xy[1] < this.maxY)) {
                dd.timeDiff = pointerDate - dd.sourceDate;
                // calculate and round new startDate based on actual dd.timeDiff
                dd.startDate = this.adjustStartDate(dd.origStart, dd.timeDiff);
                dd.endDate = new Date(dd.startDate - 0 + dd.duration);
            }
        } else {
            var range;
            if (schedulerView.isWeekView()) {
                // If we dragdrop in calendar view, we need to modify region to calculate correct date. We need date
                // from the mouse horizontal position and event region top/bottom.
                var calendarRange = {
                        bottom: proxyRegion.bottom,
                        top: proxyRegion.top
                    };
                calendarRange.left = calendarRange.right = proxyRegion.left + dd.offsets[0];
                range = this.resolveStartEndDates(schedulerView, calendarRange);
            } else {
                range = this.resolveStartEndDates(schedulerView, proxyRegion);
            }
            dd.startDate = range.startDate;
            dd.endDate = range.endDate;
            dd.timeDiff = dd.startDate - dd.origStart;
        }
        dd.newResource = schedulerView.constrainDragToResource ? dd.resourceRecord : this.resolveResource(rawXY);
        if (dd.newResource) {
            var result = !e || this.validatorFn.call(this.validatorFnScope || this, dd.draggedRecords, dd.newResource, dd.startDate, dd.duration, e);
            if (!result || typeof result === 'boolean') {
                dd.valid = result !== false;
                dd.message = '';
            } else {
                dd.valid = result.valid !== false;
                dd.message = result.message;
            }
        } else {
            dd.valid = false;
        }
    },
    /**
     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
     * @param {Ext.data.Model} eventRecord The eventRecord about to be dragged
     * @return {[Ext.data.Model]} An array of event records to drag together with the original event
     */
    getRelatedRecords: function(eventRecord) {
        var view = this.schedulerView,
            sm = view.getEventSelectionModel(),
            result = sm.getDraggableSelections();
        return Ext.Array.filter(result, function(selectedRecord) {
            return eventRecord !== selectedRecord;
        });
    },
    /**
     * This function should return a DOM node representing the markup to be dragged. By default it just returns the selected element(s) that are to be dragged.
     * If dragging multiple events, the clone of the original item should be assigned the special CSS class {@link #dragDropProxyCls}
     * @param {Ext.Element/HTMLElement} sourceEl The event element that is the source drag element
     * @param {Object} dragData The drag drop context object
     * @return {HTMLElement} The DOM node to drag
     */
    getDragElement: function(sourceEl, dragData) {
        var eventBarEls = dragData.getEventBarElements();
        var copy;
        var retVal;
        var offsetX = dragData.offsets[0];
        var offsetY = dragData.offsets[1];
        var sourceNode = sourceEl.dom || sourceEl;
        var side = this.schedulerView.rtl ? "right" : "left";
        if (eventBarEls.length > 1) {
            var ctEl = Ext.core.DomHelper.createDom({
                    tag: 'div',
                    cls: 'sch-dd-wrap',
                    style: {
                        overflow: 'visible'
                    }
                });
            Ext.Array.each(eventBarEls, function(node) {
                copy = node.cloneNode(true);
                copy.id = Ext.id();
                if (node === sourceNode) {
                    // Using Ext fly here seems buggy in Ext 5.0.1
                    copy.className += ' ' + this.dragDropProxyCls;
                }
                ctEl.appendChild(copy);
                var elOffsets = Ext.fly(node).getOffsetsTo(sourceNode);
                // Adjust each element offset to the source event element
                copy.style[side] = elOffsets[0] - offsetX + 'px';
                copy.style.top = elOffsets[1] - offsetY + 'px';
            }, this);
            retVal = ctEl;
        } else {
            copy = sourceNode.cloneNode(true);
            copy.id = Ext.id();
            copy.style[side] = -offsetX + 'px';
            copy.style.top = -offsetY + 'px';
            copy.className += ' ' + this.dragDropProxyCls;
            retVal = copy;
        }
        // TODO: fix this, it's written as if we will always have 1 element being dragged.
        // If event rendering is not using px values (could be overridden to % values in CSS) we need to
        // put a height in place for the proxy element to look correctly
        if (!sourceNode.style.height) {
            Ext.fly(retVal).setHeight(Ext.fly(sourceNode).getHeight());
        }
        return retVal;
    },
    onDragDrop: function(e, id) {
        var me = this;
        me.updateDragContext(e);
        var s = me.schedulerView,
            target = me.cachedTarget || Ext.dd.DragDropMgr.getDDById(id),
            dragData = me.dragData,
            datesProvided = dragData.startDate && dragData.endDate,
            doFinalize = true;
        if (me.tip) {
            me.tip.hide();
        }
        var modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;
        var valid = (modified || me.isCopyKeyPressed()) && dragData.valid && datesProvided && me.isValidDrop(dragData.resourceRecord, dragData.newResource, dragData.draggedRecords[0]);
        Ext.apply(dragData, {
            // Used later in finalizeDrop
            ddCallbackArgs: [
                target,
                e,
                id
            ],
            // to have the same keys like doc says and like dragCreate has
            start: dragData.startDate,
            end: dragData.endDate,
            finalize: function() {
                me.finalize.apply(me, arguments);
            }
        });
        // In case Ext JS sets a very high Z-index, lower it temporarily so it doesn't interfere with popups etc
        me.proxy.el.addCls('sch-before-drag-finalized');
        var continueFn = function() {
                me.finalize(true);
            };
        var cancelFn = function() {
                me.finalize(false);
            };
        if (valid) {
            if (s.fireEvent('beforeeventdropfinalize', me.schedulerView, dragData, e, continueFn, cancelFn) !== false) {
                continueFn();
            }
        } else {
            cancelFn();
        }
    },
    finalize: function(updateRecords) {
        var me = this,
            view = me.schedulerView,
            eventStore = view.getEventStore();
        me.proxy.el.removeCls('sch-before-drag-finalized');
        if (updateRecords) {
            // Catch one more edge case, if a taskStore with calendars is used - there is a possible scenario
            // where the UI isn't repainted. In gantt+scheduler demo, move an event in the scheduler a few px
            // and it disappears since Calendar adjusts its start date and scheduler is unaware of this.
            var updated,
                checkerFn = function() {
                    updated = true;
                };
            eventStore.on('update', checkerFn, null, {
                single: true
            });
            me.updateRecords(me.dragData);
            eventStore.un('update', checkerFn, null, {
                single: true
            });
            if (!updated) {
                me.onInvalidDrop.apply(me, me.dragData.ddCallbackArgs);
            } else {
                me.onValidDrop.apply(me, me.dragData.ddCallbackArgs);
                view.fireEvent('aftereventdrop', view, me.dragData.copiedRecords || me.dragData.draggedRecords);
            }
            me.afterDragFinalized();
        } else {
            me.onInvalidDrop.apply(me, me.dragData.ddCallbackArgs);
        }
    },
    // HACK: Override for IE11, if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // https://www.assembla.com/spaces/bryntum/tickets/716
    onInvalidDrop: function(target, e, id) {
        if (!e) {
            e = target;
            target = e.getTarget() || document.body;
        }
        if (this.tip) {
            this.tip.hide();
        }
        this.setVisibilityForSourceEvents(true);
        var schedulerView = this.schedulerView,
            retVal = this.callParent([
                target,
                e,
                id
            ]);
        if (this.started) {
            schedulerView.fireEvent('aftereventdrop', schedulerView, this.dragData.copiedRecords || this.dragData.draggedRecords);
        }
        this.afterDragFinalized();
        return retVal;
    },
    resolveStartEndDates: function(schedulerView, proxyRegion) {
        var dd = this.dragData,
            startEnd,
            start = dd.origStart,
            end = dd.origEnd,
            DATE = Sch.util.Date;
        if (!dd.startsOutsideView) {
            startEnd = schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of
            // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell
            if (startEnd.start) {
                if (!schedulerView.timeAxis.dateInAxis(startEnd.start, false)) {
                    var tick = schedulerView.timeAxis.getTickFromDate(startEnd.start);
                    if (tick) {
                        startEnd.start = schedulerView.timeAxis.getDateFromTick(tick);
                    }
                }
                start = startEnd.start || dd.startDate;
                end = DATE.add(start, DATE.MILLI, dd.duration);
            }
        } else if (!dd.endsOutsideView) {
            startEnd = schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            if (startEnd) {
                end = startEnd.end || dd.endDate;
                start = DATE.add(end, DATE.MILLI, -dd.duration);
            }
        }
        return {
            startDate: start,
            endDate: end
        };
    }
});

/**
 * @class Sch.feature.DragDrop
 * @private
 * Internal class enabling drag and drop for event nodes and creating drag proxy (classic or simplified).
 * Type of proxy can be configured with {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig property.
 */
Ext.define("Sch.feature.DragDrop", {
    requires: [
        'Ext.XTemplate',
        'Sch.feature.SchedulerDragZone'
    ],
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made.
     * Return true if the new position is valid, false to prevent the drag.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean}
     */
    validatorFn: function(dragRecords, targetResourceRecord, date, duration, e) {
        return true;
    },
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    /**
     * @cfg {Object} dragConfig
     *
     * The config object which will be passed to the `Sch.feature.SchedulerDragZone` instance
     */
    dragConfig: null,
    /**
     * @constructor
     * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor: function(schedulerView, config) {
        Ext.apply(this, config);
        this.schedulerView = schedulerView;
        schedulerView.eventDragZone = new Sch.feature.SchedulerDragZone(config.targetEl, Ext.apply({
            ddGroup: schedulerView.id,
            schedulerView: schedulerView,
            validatorFn: this.validatorFn,
            validatorFnScope: this.validatorFnScope
        }, this.dragConfig));
        this.schedulerView.on("destroy", this.cleanUp, this);
        this.callParent([
            config
        ]);
    },
    cleanUp: function() {
        var schedulerView = this.schedulerView;
        if (schedulerView.eventDragZone) {
            schedulerView.eventDragZone.destroy();
        }
    }
});

// https://www.sencha.com/forum/showthread.php?274441
// To get rid of lock/unlock menu options when using grouping feature and a column configured as not lockable
// Covered with tests/basic_grid_features/011_column_menu.t.js
Ext.define('Sch.patches.Grouping', {
    extend: 'Sch.util.Patch',
    maxVersion: '6.5.2',
    target: 'Ext.grid.feature.Grouping',
    overrides: {
        injectGroupingMenu: function() {
            var me = this,
                headerCt = me.view.headerCt;
            headerCt.showMenuBy = Ext.Function.createInterceptor(headerCt.showMenuBy, me.showMenuBy);
            headerCt.getMenuItems = me.getMenuItems();
        },
        showMenuBy: function(clickEvent, t, header) {
            var me = this,
                menu = me.getMenu(),
                groupMenuItem = menu.down('#groupMenuItem'),
                groupMenuMeth = header.groupable === false || !header.dataIndex || me.view.headerCt.getVisibleGridColumns().length < 2 ? 'disable' : 'enable',
                groupToggleMenuItem = menu.down('#groupToggleMenuItem'),
                isGrouped = me.grid.getStore().isGrouped();
            groupMenuItem[groupMenuMeth]();
            if (groupToggleMenuItem) {
                groupToggleMenuItem.setChecked(isGrouped, true);
                groupToggleMenuItem[isGrouped ? 'enable' : 'disable']();
            }
        }
    }
});

/**
 @class Sch.feature.Grouping
 @extends Ext.grid.feature.Grouping

 A feature extending the native Ext JS grouping feature (ftype = 'scheduler_grouping'). This features provides a
 {@link #headerRenderer} hook that you can use to render custom HTML into the group header for
 every time interval in the {@link Sch.data.TimeAxis}. This header will be automatically refreshed when changes happen in the eventStore and
 resourceStore.

 To add this feature to the scheduler:

        var scheduler = Ext.create("Sch.panel.SchedulerGrid", {

            features      : [
                {
                    id                 : 'group',
                    ftype              : 'scheduler_grouping',
                    hideGroupedHeader  : true,
                    enableGroupingMenu : false,

                    headerRenderer : function (intervalStartDate, intervalEndDate, groupResources, meta) {

                        meta.cellStyle = 'background : rgba(255, 0, 0, 0.5)';
                        meta.cellCls   = 'some-css-class';

                        return 'Any text here';
                    }
                }
            ],

            ...
        });
 */
Ext.define('Sch.feature.Grouping', {
    extend: 'Ext.grid.feature.Grouping',
    requires: [
        'Sch.patches.Grouping'
    ],
    alias: 'feature.scheduler_grouping',
    /**
     * This renderer method is called once for each time interval in the {@link Sch.data.TimeAxis time axis} when the scheduler is rendered.
     * Additionally, it is also called when resources and events are updated, added and removed. You can return any
     * arbitrary HTML to be added to each 'cell' of the header.
     *
     * @param {Date} intervalStartDate Start date of the current time interval
     * @param {Date} intervalEndDate End date of the current time interval
     * @param {Sch.model.Resource[]} groupResources The resources in the current group
     * @param {Object} meta A special object containing rendering properties for the current cell
     * @param {Object} meta.cellCls A CSS class to add to the cell DIV
     * @param {Object} meta.cellStyle Any inline styles to add to the cell DIV
     * @return {String}
     */
    headerRenderer: Ext.emptyFn,
    eventStoreDetacher: null,
    assignmentStoreDetacher: null,
    resourceStoreDetacher: null,
    schedulerGroupHeaderTpl: '{[this.renderCells(values)]}',
    headerCellTpl: '<tpl for=".">' + '<div class="sch-grid-group-hd-cell {cellCls}" style="{cellStyle}; width: {width}px;">' + '<span>{value}</span>' + '</div>' + '</tpl>',
    renderCells: function(data) {
        var viewModel = this.view.getTimeAxisViewModel();
        var ticks = viewModel.columnConfig[viewModel.columnLinesFor];
        var tplData = Ext.Array.map(ticks, function(tick) {
                var meta = {};
                var value = this.headerRenderer(tick.start, tick.end, data.children, meta);
                meta.value = Ext.isEmpty(value) ? '&nbsp;' : value;
                meta.width = viewModel.getDistanceBetweenDates(tick.start, tick.end);
                return meta;
            }, this);
        return this.headerCellTpl.apply(tplData);
    },
    disable: function() {
        this.unbindStoreListeners();
        this.callParent(arguments);
    },
    enable: function() {
        this.bindStoreListeners();
        this.callParent(arguments);
    },
    // init works for both normal and locked grids
    init: function() {
        var view = this.view;
        var me = this;
        this.callParent(arguments);
        if (typeof this.headerCellTpl === 'string') {
            this.headerCellTpl = new Ext.XTemplate(this.headerCellTpl);
        }
        // The functionality of this class only applies to the scheduling view section
        if (view.getResourceStore) {
            this.bindStoreListeners();
            this.groupHeaderTpl = new Ext.XTemplate(this.schedulerGroupHeaderTpl, {
                renderCells: Ext.Function.bind(me.renderCells, me)
            });
            view.on({
                resourcestorechange: this.bindStoreListeners,
                eventstorechange: this.bindStoreListeners,
                assignmentstorechange: this.bindStoreListeners,
                scope: this
            });
        }
        // HACK Still relevant for 6.5.3
        // https://www.sencha.com/forum/showthread.php?288604
        Ext.apply(view, {
            getRowNode: function(resourceRecord) {
                return this.retrieveNode(this.getRowId(resourceRecord), true);
            }
        });
        view.groupingFeature = this;
    },
    /**
     * Will bind listeners and leave detachers on normal view
     * @private
     */
    bindStoreListeners: function() {
        var view = this.view;
        if (!view.isLockedView) {
            var eventStore = view.getEventStore();
            var listeners = this.getStoreListeners();
            this.unbindStoreListeners();
            if (eventStore) {
                this.eventStoreDetacher = view.mon(eventStore, listeners.eventStore);
            }
            if (eventStore && eventStore.getAssignmentStore()) {
                this.assignmentStoreDetacher = view.mon(eventStore.getAssignmentStore(), listeners.assignmentStore);
            }
            if (view.getResourceStore()) {
                this.resourceStoreDetacher = view.mon(view.getResourceStore(), listeners.resourceStore);
            }
        }
    },
    unbindStoreListeners: function() {
        if (!this.view.isLockedView) {
            Ext.destroyMembers(this, 'eventStoreDetacher', 'resourceStoreDetacher', 'assignmentStoreDetacher');
        }
    },
    getStoreListeners: function() {
        var view = this.view,
            listeners = {
                resourceStore: {
                    add: this.onResourceAdd,
                    destroyable: true,
                    scope: this
                }
            };
        if (view.getEventStore) {
            listeners.eventStore = {
                add: this.onEventAddOrRemove,
                remove: this.onEventAddOrRemove,
                update: this.onEventUpdate,
                destroyable: true,
                scope: this
            };
            if (view.getEventStore().getAssignmentStore()) {
                listeners.assignmentStore = {
                    add: this.onAssignmentAddOrRemove,
                    update: this.onAssignmentUpdate,
                    remove: this.onAssignmentAddOrRemove,
                    destroyable: true,
                    scope: this
                };
            }
        }
        return listeners;
    },
    /**
     * Will refresh grouping headers for passed resources avoiding duplicate calls
     * @param {Sch.model.Resource[]} resourceRecords
     * @private
     */
    refreshGrouping: function(resourceRecords) {
        if (!this.view.getStore().isGrouped())  {
            return;
        }
        
        var me = this;
        var resourcesToRepaint = {};
        // for each assignment
        Ext.Array.each(resourceRecords, function(resource) {
            if (resource) {
                var groups = me.getRecordGroup(resource);
                if (groups) {
                    // get first member of the resource groups
                    var first = groups.first();
                    var firstId = first.getId();
                    // if we didn't process this group yet
                    if (!resourcesToRepaint[firstId]) {
                        resourcesToRepaint[firstId] = first;
                        me.refreshGroupHeader(first, true);
                    }
                }
            }
        });
    },
    onAssignmentAddOrRemove: function(store, records) {
        if (!this.view.getStore().isGrouped())  {
            return;
        }
        
        var resourceStore = this.view.getResourceStore();
        this.refreshGrouping(Ext.Array.map(records, function(record) {
            // no need to filter records here, we handle it further
            return record.getResource(resourceStore);
        }));
    },
    onAssignmentUpdate: function(store, assignment) {
        if (!this.view.getStore().isGrouped())  {
            return;
        }
        
        var resourceStore = this.view.getResourceStore();
        var resourceRows = [
                assignment.getResource(resourceStore)
            ];
        if (assignment.previous && assignment.previous[assignment.resourceIdField]) {
            resourceRows.push(resourceStore.getById(assignment.previous[assignment.resourceIdField]));
        }
        this.refreshGrouping(resourceRows);
    },
    onEventUpdate: function(store, record) {
        if (!this.view.getStore().isGrouped())  {
            return;
        }
        
        var me = this;
        var assignmentStore = store.getAssignmentStore();
        if (assignmentStore) {
            me.refreshGrouping(record.getResources());
        } else {
            var groupField = store.getResourceStore().getGroupField();
            var rowChanged = record.previous && record.resourceIdField in record.previous;
            var newResource = record.getResource();
            if (rowChanged) {
                var oldResource = store.getResourceStore().getById(record.previous[record.resourceIdField]);
                if (oldResource && (!newResource || oldResource.get(groupField) !== newResource.get(groupField))) {
                    me.refreshGroupHeader(oldResource);
                }
            }
            if (newResource) {
                me.refreshGroupHeader(newResource);
            }
        }
    },
    onEventAddOrRemove: function(store, eventRecords) {
        // HACK avoid reacting to add events happening before a refresh event will be triggered
        // https://app.assembla.com/spaces/bryntum/tickets/4746
        if (!this.view.getStore().isGrouped() || store.ignoreCollectionAdd)  {
            return;
        }
        
        var me = this;
        var view = me.view;
        var eventStore = view.getEventStore();
        // Grab all affected resources
        var resourceRecords = Ext.Array.map(eventRecords, function(event) {
                return eventStore.getResourcesForEvent(event);
            });
        // Flatten first, then remove any duplicates
        resourceRecords = [].concat.apply([], resourceRecords);
        this.refreshGrouping(Ext.Array.unique(resourceRecords));
    },
    onResourceAdd: function(store, records) {
        if (!this.view.getStore().isGrouped())  {
            return;
        }
        
        this.refreshGrouping(records);
    },
    /**
     * Will first record in the same group as this resource and will repaint that node (refresh grouping header).
     * @param {Sch.model.Resource} resource Resource to repaint grouping header for.
     * @param {Boolean} [isHeader] If you know you're passing first resource in group, you can pass true here to skip
     * lookup
     * @private
     */
    refreshGroupHeader: function(resource, isHeader) {
        var me = this,
            view = me.view;
        // feature may be disabled or store might be not grouped
        if (me.disabled || !me.view.getResourceStore().isGrouped())  {
            return;
        }
        
        view.refreshNode(isHeader ? resource : me.getRecordGroup(resource).first());
    }
});

/**
 * A class implementing a special confirmation dialog showing up before modifying a recurring event or some of its occurrences.
 * For recurring events the dialog notifies user that the event change/removal will cause change/removal of dependent events
 * and asks to confirm the action.
 *
 * {@img scheduler/images/recurrence-confirmation1.png 2x}
 *
 * And for occurrences the dialog allows to choose if user wants to affect all further occurrences, this occurrence only or cancel the change.
 *
 * {@img scheduler/images/recurrence-confirmation2.png 2x}
 *
 * For basic usage {@link Sch.widget.RecurrenceConfirmation} singleton instance can be used and
 * to subclass the one should extend {@link Sch.widget.recurrence.ConfirmationDialog} class.
 *
 * Singleton usage example:
 *
 * ```javascript
 * Sch.widget.RecurrenceConfirmation.show({
 *     eventRecord : event,
 *     actionType  : "delete",
 *     changerFn   : function () {
 *         eventStore.remove(event);
 *     }
 * });
 * ```
 */
Ext.define('Sch.widget.recurrence.ConfirmationDialog', {
    extend: 'Ext.window.MessageBox',
    alias: 'widget.recurrenceconfirmationdialog',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    dialogCls: 'sch-recurrenceconfirmation',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'delete-title'              : 'You’re deleting an event',
     * - 'delete-all-message'        : 'Do you want to delete all occurrences of this event?',
     * - 'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',
     * - 'delete-all-btn-text'       : 'Delete All',
     * - 'delete-further-btn-text'   : 'Delete All Future Events',
     * - 'delete-only-this-btn-text' : 'Delete Only This Event',
     * - 'update-title'              : 'You’re changing a repeating event',
     * - 'update-all-message'        : 'Do you want to change all occurrences of this event?',
     * - 'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',
     * - 'update-all-btn-text'       : 'All',
     * - 'update-further-btn-text'   : 'All Future Events',
     * - 'update-only-this-btn-text' : 'Only This Event',
     * - 'Yes'                       : 'Yes',
     * - 'Cancel'                    : 'Cancel'
     */
    /**
     * Displays the confirmation.
     * Example usage:
     *
     * ```javascript
     * Sch.widget.RecurrenceConfirmation.show({
     *     eventRecord : event,
     *     actionType  : "delete",
     *     changerFn   : function () {
     *         eventStore.remove(event);
     *     }
     * });
     * ```
     *
     * @param {Object} cfg The following config options are supported:
     * @param {Sch.model.Event} cfg.eventRecord Event to be modified.
     * @param {String} cfg.actionType Type of modification to be applied to the event. Can be either "update" or "delete".
     * @param {Function} cfg.changerFn
     * A function that should be called to apply the change to the event upon user choice.
     * @param {Function} [cfg.changerFnScope]
     * `changerFn` function scope.
     * @param {Object} [cfg.values] Values to be applied to the event.
     * @param {Function} [cfg.multipleHandler] Function that handles "Further events" button click.
     * @param {Sch.model.Event} cfg.multipleHandler.record Event record.
     * @param {Sch.model.Event} cfg.multipleHandler.values Values to be applied to the event.
     * @param {Sch.model.Event} cfg.multipleHandler.type Change type ("update"/"delete").
     * @param {Sch.model.Event} cfg.multipleHandler.changerFn Function that applies the change.
     * @param {Sch.model.Event} cfg.multipleHandler.scope Function scope.
     * @param {Function} [cfg.singleHandler] Function that handles "Only this event" button click.
     * @param {Sch.model.Event} cfg.singleHandler.record Event record.
     * @param {Sch.model.Event} cfg.singleHandler.values Values to be applied to the event.
     * @param {Sch.model.Event} cfg.singleHandler.type Change type ("update"/"delete").
     * @param {Sch.model.Event} cfg.singleHandler.changerFn Function that applies the change.
     * @param {Sch.model.Event} cfg.singleHandler.scope Function scope.
     * @param {Function} [cfg.cancelHandler] Function that handles "Cancel" button click.
     * @param {Sch.model.Event} cfg.cancelHandler.record Event record.
     * @param {Sch.model.Event} cfg.cancelHandler.values Values to be applied to the event.
     * @param {Sch.model.Event} cfg.cancelHandler.type Change type ("update"/"delete").
     * @param {Sch.model.Event} cfg.cancelHandler.changerFn Function that applies the change.
     * @param {Sch.model.Event} cfg.cancelHandler.scope Function scope.
     * @return {Sch.widget.recurrence.ConfirmationDialog} this
     */
    show: function(cfg) {
        var me = this;
        if (!cfg || !cfg.actionType || !cfg.eventRecord) {
            throw new Error('actionType and eventRecord must be specified for Sch.widget.recurrence.ConfirmationDialog');
        }
        cfg.cls = me.dialogCls + (cfg.cls ? ' ' + cfg.cls : '');
        var isMaster = cfg.eventRecord.isRecurring();
        cfg = Ext.apply({
            // the following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // this.L('delete-title') not found
            // this.L('update-title') not found
            title: me.L(cfg.actionType + '-title'),
            // the following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // this.L('delete-all-message')
            // this.L('delete-further-message')
            // this.L('update-all-message')
            // this.L('update-further-message')
            msg: me.L(cfg.actionType + (isMaster ? '-all-message' : '-further-message')),
            icon: Ext.MessageBox.QUESTION,
            scope: me,
            fn: me.dispatchHandler,
            buttonText: cfg.buttonText || me.getButtonText(cfg)
        }, cfg);
        return me.callParent([
            cfg
        ]);
    },
    getButtonText: function(cfg) {
        var me = this,
            isMaster = cfg.eventRecord.isRecurring();
        var result = {
                // the following lines are added to satisfy the 904_unused localization test
                // to let it know that these locales are used:
                // this.L('delete-all-btn-text')
                // this.L('delete-further-btn-text')
                // this.L('delete-only-this-btn-text')
                // this.L('update-all-btn-text')
                // this.L('update-further-btn-text')
                // this.L('update-only-this-btn-text')
                yes: me.L(cfg.actionType + (isMaster ? '-all-btn-text' : '-further-btn-text')),
                no: me.L(cfg.actionType + '-only-this-btn-text'),
                cancel: me.L('Cancel')
            };
        // TODO: so far we remove 'Only this event' option for a recurring event itself untill this case is supported
        if (isMaster) {
            result.yes = me.L('Yes');
            delete result.no;
        }
        return result;
    },
    getButtonHandler: function(btn, text, config) {
        var fn;
        switch (btn) {
            case 'yes':
                fn = config.multipleHandler || this.multipleHandler;
                break;
            case 'no':
                fn = config.singleHandler || this.singleHandler;
                break;
            case 'cancel':
                fn = config.cancelHandler || this.cancelHandler;
                break;
        }
        return fn;
    },
    dispatchHandler: function(btn, text, config) {
        config = config || {};
        var me = this,
            fn = me.getButtonHandler(btn, text, config),
            scope = config.handlerScope || me,
            changerFn = config.changerFn || Ext.emptyFn;
        fn.call(scope, config.eventRecord, config.values, config.actionType, changerFn, config.changerFnScope || me);
    },
    multipleHandler: function(record, values, type, changerFn, scope) {
        var recurringEvent = record.getRecurringEvent(),
            stopDate = new Date(record.getStartDate() - 1);
        // apply changes to the occurrence
        changerFn.call(scope);
        // reset occurrence linkage to the "master" event
        record.setRecurringEventId(null);
        // stop the previous recurrence
        recurringEvent && recurringEvent.getRecurrence().setEndDate(stopDate);
    },
    singleHandler: function(record, values, type, changerFn, scope) {
        var recurringEvent = record.getRecurringEvent(),
            exceptionDate = record.getStartDate();
        changerFn.call(scope);
        record.beginEdit();
        record.setRecurringEventId(null);
        record.setRecurrence(null);
        record.endEdit();
        recurringEvent.addExceptionDate(exceptionDate);
    },
    cancelHandler: Ext.emptyFn
});

/**
 * @inheritdoc Sch.widget.recurrence.ConfirmationDialog
 */
Ext.define('Sch.widget.RecurrenceConfirmation', {
    extend: 'Sch.widget.recurrence.ConfirmationDialog',
    singleton: true
});

/**
 * @private
 * A class that adds recurring events functionality to a scheduler panel.
 *
 * The main purpose of the class is generating occurrences of the repeating events for the visible timespan.
 * To achieve this it tracks changes on the {@link #getEventStore event store} to apply a repeating event changes
 * to its visible occurrences.
 * The feature also tracks the panel visible timespan changes to make sure the new timespan is populated
 * with corresponding event occurrences.
 *
 * Additionally the class implements displaying of a {@link Sch.widget.RecurrenceConfirmation special confirmation}
 * on user mouse actions (the panel view {@link Sch.mixin.SchedulerView#beforeeventdropfinalize beforeeventdropfinalize},
 * {@link Sch.mixin.SchedulerView#beforeeventresizefinalize beforeeventresizefinalize} events) involving repeating events.

 * You don't need to instantiate this class normally since the scheduler
 * does it automatically (see {@link Sch.mixin.SchedulerPanel#recurringEvents recurringEvents} for details).
 */
Ext.define('Sch.feature.RecurringEvents', {
    alias: 'feature.scheduler_recurring_events',
    requires: [
        'Sch.widget.RecurrenceConfirmation'
    ],
    mixins: [
        'Ext.util.Observable'
    ],
    panelCls: 'sch-recurringevents',
    eventStoreDetacher: null,
    timeAxisDetacher: null,
    panelDetacher: null,
    viewDetacher: null,
    /**
     * Scheduler panel to add the feature to.
     * @cfg {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree}
     */
    panel: null,
    /**
     * Event store to attach the feature to.
     * By default you don't need to provide the config since the store is taken from the {@link #panel}.
     * @cfg {Sch.data.EventStore} [eventStore]
     */
    eventStore: null,
    timeAxis: null,
    trackingSuspended: 0,
    constructor: function(cfg) {
        cfg = cfg || {};
        this.mixins.observable.constructor.call(this);
        if (cfg.panel) {
            this.init(cfg.panel);
        }
    },
    init: function(panel) {
        this.setPanel(panel);
    },
    /**
     * Sets the scheduler panel to add the feature to.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} panel Scheduler panel.
     */
    setPanel: function(panel) {
        var me = this;
        me.panel = panel;
        me.bindPanel(panel);
        me.setEventStore(panel && panel.getEventStore());
    },
    startTracking: function() {
        var me = this,
            panel = me.panel;
        if (panel) {
            me.setView(me.getView(panel));
            me.setTimeAxis(panel.getTimeAxis && panel.getTimeAxis());
            me.refreshOccurrences();
            panel.addCls(me.panelCls);
        } else {
            me.stopTracking();
        }
    },
    stopTracking: function() {
        var me = this,
            panel = me.panel;
        me.setView();
        me.setTimeAxis();
        panel && panel.removeCls(me.panelCls);
    },
    /**
     * Returns the scheduler panel associated with the feature.
     * @return {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} Scheduler panel to add the recurring events functionality to.
     */
    getPanel: function() {
        return this.panel;
    },
    getView: function(panel) {
        panel = panel || this.panel;
        return panel && panel.getSchedulingView();
    },
    setView: function(view) {
        if (view) {
            if (view.viewReady) {
                this.bindView(view);
            } else {
                this.mon(view, {
                    'viewready': this.onViewReady,
                    single: true,
                    scope: this
                });
            }
        } else {
            this.bindView();
        }
    },
    /**
     * @protected
     * Setups event listeners to the provided scheduler panel or destroys existing listeners if no panel provided.
     * The method is called as part of {@link #setPanel} call.
     * Override this to setup custom event listeners to the associated panel.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} [panel] Panel to listen to. Provide `null` or skip the
     * argument to remove the current listeners.
     */
    bindPanel: function(panel) {
        this.panelDetacher && this.panelDetacher.destroy();
        if (panel) {
            this.mon(panel, {
                'eventstorechange': this.onPanelEventStoreChange,
                'destroy': this.onPanelDestroy,
                scope: this
            });
        }
    },
    onPanelDestroy: function() {
        this.setPanel();
    },
    onViewReady: function(view) {
        this.bindView(view);
    },
    bindView: function(view) {
        var me = this;
        me.viewDetacher && me.viewDetacher.destroy();
        if (view) {
            me.viewDetacher = me.mon(view, {
                'beforeeventdropfinalize': me.onBeforeEventDropFinalize,
                'beforeeventresizefinalize': me.onBeforeEventResizeFinalize,
                destroyable: true,
                scope: me,
                priority: -100
            });
        }
    },
    /**
     * Sets the event store associated with the feature. By default the event store is taken from the {@link #panel}
     * (this method is called inside of {@link #setPanel} method).
     * @param {Sch.data.EventStore} eventStore Event store.
     */
    setEventStore: function(eventStore) {
        var me = this,
            isSupported = eventStore && eventStore.isRecurringEventStore;
        // the feature supports only event stores having Sch.data.mixin.RecurringEvents mixed in
        eventStore = isSupported ? eventStore : null;
        me.eventStore = eventStore;
        me.bindEventStore(eventStore);
        me[isSupported ? 'startTracking' : 'stopTracking']();
    },
    /**
     * Returns the event store associated with the feature.
     * @return {Sch.data.EventStore} Event store.
     */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * @protected
     * Setups event listeners to the provided event store or destroys existing listeners if no store provided.
     * The method is called inside of {@link #setEventStore} method
     * (which in turn is called inside of {@link #setPanel} method).
     * Override this to setup custom event listeners to the associated event store.
     * @param {Sch.data.EventStore} [eventStore] Event store to listen to. Provide `null` or skip the
     * argument to remove the current listeners.
     */
    bindEventStore: function(eventStore) {
        this.eventStoreDetacher && this.eventStoreDetacher.destroy();
        if (eventStore) {
            this.eventStoreDetacher = this.mon(eventStore, {
                'load': this.onEventsLoaded,
                'add': this.onEventAdd,
                'update': this.onEventUpdate,
                'remove': this.onEventRemove,
                'generate-occurrences-start': this.onGenerateOccurrencesStart,
                'generate-occurrences-end': this.onGenerateOccurrencesEnd,
                'delayed-regenerate-occurrences-start': this.onDelayedRegenerateOccurrencesStart,
                'delayed-regenerate-occurrences-end': this.onDelayedRegenerateOccurrencesEnd,
                scope: this,
                destroyable: true
            });
        }
    },
    setTimeAxis: function(timeAxis) {
        this.timeAxis = timeAxis;
        this.bindTimeAxis(timeAxis);
    },
    getTimeAxis: function() {
        return this.timeAxis;
    },
    getStartDate: function() {
        return this.getTimeAxis() && this.getTimeAxis().getStart();
    },
    getEndDate: function() {
        return this.getTimeAxis() && this.getTimeAxis().getEnd();
    },
    bindTimeAxis: function(timeAxis) {
        this.timeAxisDetacher && this.timeAxisDetacher.destroy();
        if (timeAxis) {
            this.timeAxisDetacher = this.mon(timeAxis, {
                'reconfigure': this.onTimeAxisReconfigure,
                scope: this,
                destroyable: true
            });
        }
    },
    onDelayedRegenerateOccurrencesStart: function() {
        var view = this.getView();
        if (view && view.getMode() == 'horizontal') {
            // remember "fadeOutRemoval" state
            this._fadeOutRemoval = view.horizontal.fadeOutRemoval;
            // Since we are going to add & remove events massively we disable "fade out" effect
            view.horizontal.fadeOutRemoval = false;
        }
    },
    onDelayedRegenerateOccurrencesEnd: function() {
        var view = this.getView();
        if (view && view.getMode() == 'horizontal') {
            // enable "fade out" effect back
            view.horizontal.fadeOutRemoval = this._fadeOutRemoval;
        }
    },
    onGenerateOccurrencesStart: function(eventStore, events, startDate, endDate) {
        this.suspendTracking();
    },
    onGenerateOccurrencesEnd: function(eventStore, events, occurrences, startDate, endDate) {
        this.resumeTracking();
    },
    refreshOccurrences: function() {
        var eventStore = this.getEventStore(),
            startDate = this.getStartDate(),
            endDate = this.getEndDate();
        if (eventStore && startDate && endDate) {
            // TODO: cleanup previous range (this can be tricky need to know that the range is not used by some other view)?
            eventStore.generateOccurrencesForEventsBuffered(eventStore.getRecurringEvents(), startDate, endDate);
        }
    },
    onPanelEventStoreChange: function(panel, eventStore) {
        this.setEventStore(eventStore);
    },
    onTimeAxisReconfigure: function() {
        if (!this.isTrackingSuspended()) {
            this.refreshOccurrences();
        }
    },
    onEventsLoaded: function(eventStore, events, successful) {
        if (successful && !this.isTrackingSuspended()) {
            events = Ext.Array.filter(events, function(event) {
                return event.isRecurring();
            });
            if (events.length) {
                // schedule event occurrences generation
                eventStore.generateOccurrencesForEventsBuffered(events, this.getStartDate(), this.getEndDate());
            }
        }
    },
    onEventAdd: function(eventStore, events) {
        if (!this.isTrackingSuspended()) {
            events = Ext.Array.filter(events, function(event) {
                return event.isRecurring();
            });
            if (events.length) {
                // schedule event occurrences generation
                eventStore.generateOccurrencesForEventsBuffered(events, this.getStartDate(), this.getEndDate());
            }
        }
    },
    onEventUpdate: function(eventStore, event, operation, modifiedFieldNames) {
        if (operation == 'edit' && !this.isTrackingSuspended() && this.isRecurrenceRelatedFieldChange(event, modifiedFieldNames)) {
            var startDate = this.getStartDate(),
                endDate = this.getEndDate(),
                eventStartDate = event.getStartDate(),
                recurrence = event.getRecurrence();
            // the event is no longer recurring
            if (!recurrence) {
                eventStore.removeOccurrencesForEvents(event);
            }
            // If we have start & end dates and the recurrence intersects the range
            else if (startDate && endDate && eventStartDate && (!recurrence.getEndDate() || (recurrence.getEndDate() >= startDate && eventStartDate <= endDate))) {
                // schedule event occurrences regeneration
                eventStore.regenerateOccurrencesForEventsBuffered(event, startDate, endDate);
            }
        }
    },
    onEventRemove: function(eventStore, events) {
        if (!this.isTrackingSuspended()) {
            events = Ext.Array.filter(events, function(event) {
                return event.isRecurring();
            });
            if (events.length) {
                eventStore.removeOccurrencesForEvents(events);
            }
        }
    },
    /**
     * @protected
     * The method restricts which field modifications should trigger event occurrences rebuilding.
     * By default any field change of a recurring event causes the rebuilding.
     * @param  {Sch.model.Event} event The modified event.
     * @param  {String[]} modifiedFieldNames Array of changed field names.
     * @return {Boolean} `True` if the fields modification should trigger the event occurrences rebuilding.
     */
    isRecurrenceRelatedFieldChange: function(event, modifiedFieldNames) {
        return event.isRecurring() || Ext.Array.contains(modifiedFieldNames, event.recurrenceRuleField);
    },
    isTrackingSuspended: function() {
        return this.trackingSuspended;
    },
    suspendTracking: function() {
        this.trackingSuspended++;
    },
    resumeTracking: function() {
        this.trackingSuspended--;
    },
    onBeforeEventDropFinalize: function(schedulingView, dragContext, e, continueFn, cancelFn) {
        // TODO support multi event draggable case
        var event = dragContext.draggedRecords[0];
        if (event.isRecurrableEvent && (event.isRecurring() || event.isOccurrence())) {
            Sch.widget.RecurrenceConfirmation.show({
                actionType: 'update',
                eventRecord: event,
                changerFn: continueFn,
                cancelHandler: cancelFn
            });
            return false;
        }
    },
    onBeforeEventResizeFinalize: function(view, resizeContext, e, continueFn, cancelFn) {
        var event = resizeContext.eventRecord;
        if (event.isRecurrableEvent && (event.isRecurring() || event.isOccurrence())) {
            Sch.widget.RecurrenceConfirmation.show({
                actionType: 'update',
                eventRecord: event,
                changerFn: continueFn,
                cancelHandler: cancelFn
            });
            return false;
        }
    }
});

/**
 * @class Sch.feature.ResizeZone
 * @extends Ext.util.Observable
 * @private
 * Internal classing enabling resizing of rendered events
 * @constructor
 * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
 * @param {Object} config The object containing the configuration of this model.
 */
Ext.define("Sch.feature.ResizeZone", {
    extend: "Ext.util.Observable",
    requires: [
        'Ext.resizer.Resizer',
        'Sch.tooltip.Tooltip',
        'Sch.util.ScrollManager'
    ],
    /**
      * @cfg {Boolean} showTooltip `false` to not show a tooltip while resizing
      */
    showTooltip: true,
    /**
     * @type {Boolean} showExactResizePosition true to see exact event length during resizing
     */
    showExactResizePosition: false,
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being resized. Return true if the new duration is valid, false to signal that it is not.
     * @param {Sch.model.Resource} resourceRecord the resource to which the event belongs
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.event.Event} e The event object
     * @return {Boolean}
     */
    validatorFn: Ext.emptyFn,
    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope: null,
    schedulerView: null,
    origEl: null,
    handlePos: null,
    eventRec: null,
    mouseDownEvent: null,
    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while resizing an event or a configuration object for the {@link Sch.tooltip.Tooltip}.
     */
    tip: null,
    // cached reference to the created tooltip instance
    tipInstance: null,
    startScroll: null,
    constructor: function(config) {
        Ext.apply(this, config);
        var s = this.schedulerView;
        s.on({
            destroy: this.cleanUp,
            scope: this
        });
        s.el.on({
            mousedown: this.onMouseDown,
            mouseup: this.onMouseUp,
            scope: this,
            delegate: '.sch-resizable-handle'
        });
        this.bindRightClickPreventer();
        this.callParent(arguments);
    },
    bindRightClickPreventer: function() {
        this.schedulerView.el.on('contextmenu', this.preventRightClick, this, {
            priority: 999
        });
    },
    // Prevent right clicks while resizing an event
    preventRightClick: function(e) {
        if (e.button !== 0 && this.resizer) {
            e.stopEvent();
            return false;
        }
    },
    onMouseDown: function(e, t) {
        var s = this.schedulerView;
        var eventRec = this.eventRec = s.resolveEventRecord(t);
        var isResizable = eventRec.isResizable();
        if (e.button !== 0 || (isResizable === false || typeof isResizable === 'string' && !t.className.match(isResizable))) {
            return;
        }
        this.eventRec = eventRec;
        this.handlePos = this.getHandlePosition(t);
        this.origEl = Ext.get(e.getTarget('.sch-event'));
        this.mouseDownEvent = e;
        s.el.on({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        });
    },
    onMouseUp: function(e, t) {
        var s = this.schedulerView;
        s.el.un({
            mousemove: this.onMouseMove,
            scope: this,
            single: true
        });
        this.mouseDownEvent = null;
    },
    getTipInstance: function() {
        if (this.tipInstance)  {
            return this.tipInstance;
        }
        
        var s = this.schedulerView;
        var tip = this.tip;
        if (tip instanceof Ext.tip.ToolTip) {
            tip.schedulerView = s;
        } else {
            tip = new Sch.tooltip.Tooltip(Ext.apply({
                rtl: this.rtl,
                schedulerView: s,
                constrainTo: s.up('grid').el,
                cls: 'sch-resize-tip'
            }, tip));
        }
        return this.tipInstance = tip;
    },
    onMouseMove: function(e, t) {
        var s = this.schedulerView,
            eventRec = this.eventRec,
            handlePos = this.handlePos;
        if (!eventRec || s.fireEvent('beforeeventresize', s, eventRec, e) === false) {
            return;
        }
        delete this.eventRec;
        e.stopEvent();
        this.origEl.addCls('sch-event-resizing');
        this.resizer = this.createResizer(this.origEl, eventRec, handlePos);
        var tracker = this.resizer.resizeTracker;
        // HACK, fake the start of the resizing right away
        tracker.onMouseDown(this.mouseDownEvent, this.resizer[handlePos].dom);
        tracker.onMouseMove(e, this.resizer[handlePos].dom);
        if (this.showTooltip) {
            var tip = this.getTipInstance();
            tip.update(eventRec.getStartDate(), eventRec.getEndDate(), true);
            // update requires target that was removed after previous resize
            tip.showForElement(this.origEl, e.getX() - this.origEl.getX());
        }
        s.fireEvent('eventresizestart', s, eventRec);
        // Handle inifinite scroll case
        s.getScrollable().on('scroll', this.onViewScroll, this);
    },
    getHandlePosition: function(node) {
        var isStart = node.className.match('start');
        if (this.schedulerView.isHorizontal()) {
            if (this.schedulerView.rtl) {
                return isStart ? 'east' : 'west';
            }
            return isStart ? 'west' : 'east';
        } else {
            return isStart ? 'north' : 'south';
        }
    },
    // private
    createResizer: function(eventEl, eventRecord, handlePos) {
        var s = this.schedulerView,
            me = this,
            resourceRecord = s.resolveResource(eventEl),
            increment = s.getSnapPixelAmount(),
            constrainRegion = s.getScheduleRegion(resourceRecord, eventRecord),
            dateConstraints = s.getDateConstraints(resourceRecord, eventRecord),
            height = eventEl.getHeight(),
            isStart = (s.rtl && handlePos[0] === 'e') || (!s.rtl && handlePos[0] === 'w') || handlePos[0] === 'n',
            isVertical = !s.isHorizontal(),
            resizerCfg = {
                otherEdgeX: isStart ? eventEl.getRight() : eventEl.getLeft(),
                otherEdgeY: isStart ? eventEl.getBottom() : eventEl.getTop(),
                target: eventEl,
                isStart: isStart,
                dateConstraints: dateConstraints,
                resourceRecord: resourceRecord,
                eventRecord: eventRecord,
                handles: handlePos[0],
                minHeight: height,
                constrainTo: constrainRegion,
                listeners: {
                    resizedrag: this.partialResize,
                    resize: this.afterResize,
                    scope: this
                }
            };
        // Apply orientation specific configs
        if (isVertical) {
            if (increment > 0) {
                var w = eventEl.getWidth();
                Ext.apply(resizerCfg, {
                    minHeight: increment,
                    // To avoid SHIFT causing a ratio preserve
                    minWidth: w,
                    maxWidth: w,
                    heightIncrement: increment
                });
            }
        } else {
            if (increment > 0) {
                Ext.apply(resizerCfg, {
                    minWidth: increment,
                    // To avoid SHIFT causing a ratio preserve
                    maxHeight: height,
                    widthIncrement: increment
                });
            }
        }
        var resizer = new Ext.resizer.Resizer(resizerCfg);
        if (resizer.resizeTracker) {
            // Force tracker to start tracking even with just 1px movement, defaults to 3.
            resizer.resizeTracker.tolerance = -1;
        }
        // Patched to handle changes in containing scheduler view el scroll position
        // TODO re-enable this again when we support scroll triggering during resize operation which stopped working in Ext JS 5 due to internal Ext JS changes
        //
        // resizer.resizeTracker.resize = function(box) {
        //     var scrollDelta;
        //
        //     if (isVertical) {
        //         scrollDelta = s.getVerticalScroll() - me.startScroll.top;
        //
        //         if (handlePos[0] === 's') {
        //             box.y -= scrollDelta;
        //         }
        //
        //         box.height += Math.abs(scrollDelta);
        //     } else {
        //         scrollDelta = s.getScrollX()- me.startScroll.left;
        //
        //         if (handlePos[0] === 'e') {
        //             box.x -= scrollDelta;
        //         }
        //
        //         box.width += Math.abs(scrollDelta);
        //     }
        //
        //     Ext.resizer.ResizeTracker.prototype.resize.apply(this, arguments);
        // };
        // Make sure the resizing event is on top of other events
        eventEl.setStyle('z-index', parseInt(eventEl.getStyle('z-index'), 10) + 1);
        Sch.util.ScrollManager.activate(s, s.isHorizontal() ? 'horizontal' : 'vertical');
        this.startScroll = s.getScroll();
        return resizer;
    },
    getStartEndDates: function() {
        var r = this.resizer,
            rEl = r.el,
            schedulerView = this.schedulerView,
            isStart = r.isStart,
            start, end, x, xy;
        if (isStart) {
            if (schedulerView.isHorizontal()) {
                x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getRight() : rEl.getLeft() + 1;
                xy = [
                    x,
                    0
                ];
            } else {
                xy = [
                    (rEl.getRight() + rEl.getLeft()) / 2,
                    rEl.getTop()
                ];
            }
            end = r.eventRecord.getEndDate();
            if (schedulerView.snapRelativeToEventStartDate) {
                start = schedulerView.getDateFromXY(xy);
                start = schedulerView.timeAxis.roundDate(start, r.eventRecord.getStartDate());
            } else {
                start = schedulerView.getTimeZoneDateFromXY(xy, 'round');
            }
        } else {
            if (schedulerView.isHorizontal()) {
                x = schedulerView.rtl && schedulerView.shouldAdjustForRtl() ? rEl.getLeft() : rEl.getRight();
                xy = [
                    x,
                    0
                ];
            } else {
                xy = [
                    (rEl.getRight() + rEl.getLeft()) / 2,
                    rEl.getBottom()
                ];
            }
            start = r.eventRecord.getStartDate();
            if (schedulerView.snapRelativeToEventStartDate) {
                end = schedulerView.getDateFromXY(xy);
                end = schedulerView.timeAxis.roundDate(end, r.eventRecord.getEndDate());
            } else {
                end = schedulerView.getTimeZoneDateFromXY(xy, 'round');
            }
        }
        start = start || r.start;
        end = end || r.end;
        if (r.dateConstraints) {
            start = Sch.util.Date.constrain(start, r.dateConstraints.start, r.dateConstraints.end);
            end = Sch.util.Date.constrain(end, r.dateConstraints.start, r.dateConstraints.end);
        }
        return {
            start: start,
            end: end
        };
    },
    // private
    partialResize: function(r, width, height, e) {
        var s = this.schedulerView,
            xy = e ? e.getXY() : this.resizer.resizeTracker.lastXY,
            startEndDates = this.getStartEndDates(xy),
            start = startEndDates.start,
            end = startEndDates.end,
            record = r.eventRecord,
            isHorizontal = s.isHorizontal();
        if (this.showTooltip) {
            var valid = this.validatorFn.call(this.validatorFnScope || this, r.resourceRecord, record, start, end);
            var message = '';
            // Implementer could also return an object { valid : false, message : 'foo' }
            if (valid && typeof valid !== 'boolean') {
                message = valid.message;
                valid = valid.valid;
            }
            this.getTipInstance().update(start, end, valid !== false, message);
        }
        if (this.showExactResizePosition) {
            var target = r.target.el,
                exactWidth, cursorDate, offset;
            if (r.isStart) {
                if (s.isWeekView()) {
                    var column = s.weekview.getEventColumns(record)[0];
                    exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, column.end);
                } else {
                    exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(start, record.getEndDate());
                }
                if (isHorizontal) {
                    cursorDate = s.getDateFromCoordinate(r.otherEdgeX - Math.min(width, r.maxWidth)) || start;
                    offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    if (target.getWidth() !== exactWidth) {
                        target.setWidth(exactWidth);
                        target.setX(target.getX() + offset);
                    }
                } else {
                    cursorDate = s.getDateFromCoordinate(r.otherEdgeY - Math.min(height, r.maxHeight)) || start;
                    offset = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    if (target.getHeight() !== exactWidth) {
                        target.setHeight(exactWidth);
                        target.setY(target.getY() + offset);
                    }
                }
            } else {
                exactWidth = s.timeAxisViewModel.getDistanceBetweenDates(record.getStartDate(), end);
                if (isHorizontal) {
                    target.setWidth(exactWidth);
                } else {
                    target.setHeight(exactWidth);
                }
            }
        } else {
            if (!start || !end || ((r.start - start === 0) && (r.end - end === 0))) {
                return;
            }
        }
        r.end = end;
        r.start = start;
        s.fireEvent('eventpartialresize', s, record, start, end, r.el);
    },
    onViewScroll: function(scrollable, x, y, xDelta) {
        // In FF resizing throws scroll event on first mouse move and when resizing ends
        // Usually it would be stopped by sencha, in TableScroller, but we overriden it to fix another bug.
        // Instead, we change patch to always invoke scroll and we use another patch to throw delta in scroll events
        // scroll event is fired with 3 arguments normally, so 4th one should only come from our patch.
        // Affects only 6.2.1, covered by 062_resize in FF
        if (xDelta !== 0) {
            this.resizer.resizeTracker.onDrag({});
            this.partialResize(this.resizer, 0, 0);
        }
    },
    // private
    afterResize: function(r, w, h, e) {
        var me = this,
            resourceRecord = r.resourceRecord,
            eventRecord = r.eventRecord,
            oldStart = eventRecord.getStartDate(),
            oldEnd = eventRecord.getEndDate(),
            start = r.start || oldStart,
            end = r.end || oldEnd,
            s = me.schedulerView,
            isModified = (start - oldStart) || (end - oldEnd),
            isValid = me.validatorFn.call(me.validatorFnScope || me, resourceRecord, eventRecord, start, end, e);
        Sch.util.ScrollManager.deactivate();
        s.getScrollable().un('scroll', this.onViewScroll, this);
        if (this.showTooltip) {
            this.getTipInstance().hide();
        }
        // Implementer could also return an object { valid : false, message : 'foo' }
        if (Ext.isObject(isValid)) {
            isValid = isValid.valid;
        }
        // If users returns nothing, that's interpreted as valid
        // End date must be later than start date
        isValid = (isValid !== false) && start && end && (end - start > 0);
        var resizeContext = {
                resourceRecord: r.resourceRecord,
                eventRecord: eventRecord,
                start: start,
                end: end,
                valid: isValid,
                modified: isModified,
                finalize: function(updateRecord) {
                    me.finalize(updateRecord, resizeContext);
                }
            };
        var continueFn = function() {
                me.finalize(true, resizeContext);
            };
        var cancelFn = function() {
                me.finalize(false, resizeContext);
            };
        if (isValid && isModified) {
            if (s.fireEvent('beforeeventresizefinalize', s, resizeContext, e, continueFn, cancelFn) !== false) {
                continueFn();
            }
        } else {
            cancelFn();
        }
    },
    finalize: function(updateRecord, context) {
        var s = this.schedulerView;
        var wasChanged = false;
        var checker = function() {
                wasChanged = true;
            };
        s.getEventStore().on('update', checker);
        // Without manually destroying the target, Ext Element cache gets confused
        this.resizer.target.destroy();
        if (updateRecord) {
            if (this.resizer.isStart) {
                context.eventRecord.setStartDate(context.start, false, s.getEventStore().skipWeekendsDuringDragDrop);
            } else {
                context.eventRecord.setEndDate(context.end, false, s.getEventStore().skipWeekendsDuringDragDrop);
            }
            if (!wasChanged)  {
                s.repaintEventsForResource(context.resourceRecord);
            }
            
        } else {
            s.repaintEventsForResource(context.resourceRecord);
        }
        // Destroy resizer
        this.resizer.destroy();
        delete this.resizer;
        s.getEventStore().un('update', checker);
        // first event is to make it non-breaking change
        // second event is to unify names with other drag features
        s.fireEvent('eventresizeend', s, context.eventRecord);
        s.fireEvent('aftereventresize', s, context.eventRecord);
    },
    cleanUp: function() {
        if (this.tipInstance) {
            this.tipInstance.destroy();
        }
        this.mouseDownEvent = null;
    }
});

/**
@class Sch.field.CellEditor
@extend Ext.form.field.Text

This class is used as an input element for {@link Sch.plugin.CellPlugin} plugin. Expect user to type values 
of the following format: {startDate}{divider}{endDate}. Both start and end dates have same format defined by
{@link #dateFormat} property. Divider is also configurable via {@link #divider} property.

NOTE: make sure divider isn't a part of date format. e.g. if dateFormat is set to 'H:i', divider cannot be colon character (:).
Otherwise it will lead to wrong results. 
 */
Ext.define('Sch.field.CellEditor', {
    extend: 'Ext.form.field.Text',
    alias: 'widget.celleditorfield',
    hidden: true,
    enableKeyEvents: true,
    /**
     * @cfg {String} divider Character used for join/split value. e.g. 10-12 will be split to [10,12].
     */
    divider: '-',
    /**
     * @cfg {String/String[]} dateFormat Date {@link Ext.Date.format} for parsing start/end dates from input value. 
     * If array is provided editor will return first successful parsed results.
     */
    dateFormat: 'H',
    /**
     * Special implementation of {@link Ext.form.field.Field#getErrors} method. Checks if input value could be split
     * into two dates according to {@link #divider} and {@link #dateFormat} properties. 
     * @param {String} value
     * @return {String[]}
     */
    getErrors: function(value) {
        var me = this,
            result = me.callParent(arguments);
        if (value == null || value === "")  {
            return result;
        }
        
        var dates = this.getDates(value);
        if (!dates[0]) {
            result.push('Start date is incorrect');
        }
        if (!dates[1]) {
            result.push('End date is incorrect');
        }
        if (dates[1] - dates[0] < 0) {
            result.push('Start date is less then end date');
        }
        return result;
    },
    /**
     * This method parses start/end dates from user input. 
     * @param {String} value
     * @return {Date[]}
     */
    getDates: function(value) {
        var me = this;
        var values = value.split(me.divider);
        var start, end;
        if (Ext.isArray(me.dateFormat)) {
            for (var i = 0; i < me.dateFormat.length; i++) {
                start = start || Ext.Date.parse(values[0], me.dateFormat[i]);
                end = end || Ext.Date.parse(values[1], me.dateFormat[i]);
            }
        } else {
            start = Ext.Date.parse(values[0], me.dateFormat);
            end = Ext.Date.parse(values[1], me.dateFormat);
        }
        if (!start || !end) {
            return [];
        }
        if (me.record) {
            start = Sch.util.Date.mergeDates(me.record.getStartDate(), start, me.bottomUnit);
            end = Sch.util.Date.mergeDates(me.record.getEndDate(), end, me.bottomUnit);
        } else {
            start = Sch.util.Date.mergeDates(me.startDate, start, me.bottomUnit);
            end = Sch.util.Date.mergeDates(me.startDate, end, me.bottomUnit);
        }
        return [
            start,
            end
        ];
    }
});

/**
 * Class implementing a _form field_ looking as a _segmented button_.
 */
Ext.define('Sch.field.SegmentedButton', {
    extend: 'Ext.button.Segmented',
    alias: 'widget.segmentedbuttonfield',
    mixins: [
        'Ext.form.field.Field'
    ],
    segmentedButtonFieldCls: 'sch-segmentedbuttonfield',
    // This layout supports 'columns' and 'vertical' configs:
    // http://docs.sencha.com/extjs/6.5.3/classic/Ext.form.CheckboxGroup.html#cfg-columns
    // http://docs.sencha.com/extjs/6.5.3/classic/Ext.form.CheckboxGroup.html#cfg-vertical
    layout: 'checkboxgroup',
    allowMultiple: true,
    defaults: {
        enableToggle: true,
        border: 0
    },
    // To support borders need to customize checkboxgroup layout
    // if `false`, the last selected value cannot be depressed
    allowBlank: true,
    initComponent: function() {
        var me = this;
        // Init mixin
        me.initField();
        me.initDefaultName();
        me.addCls(me.segmentedButtonFieldCls);
        me.callParent();
        me.on('change', me.onFieldChange, me);
    },
    initDefaultName: function() {
        this.name = this.name || this.getId();
    },
    onFieldChange: function(field, value, oldValue) {
        if (!this.allowBlank && Ext.isEmpty(value)) {
            this.setValue(oldValue);
        }
    }
});

// Locked panel cannot be collapsed, sencha provided override to fix this, but unfortunately it doesn't work nice
// with grids, syncing row height (syncRowHeights: true)
// https://www.sencha.com/forum/showthread.php?310933
// https://fiddle.sencha.com/#fiddle/1ak8
Ext.define('Sch.layout.TableLayout', {
    extend: 'Ext.view.TableLayout',
    alias: 'layout.timeline_tablelayout',
    beginLayout: function(ownerContext) {
        var me = this,
            owner = me.owner,
            ownerGrid = owner.ownerGrid,
            partner = owner.lockingPartner,
            // BUG: need to test whether partner is not collapsed as well as visible.
            // ======================================================================
            partnerVisible = partner && partner.grid.isVisible() && !partner.grid.collapsed,
            context = ownerContext.context;
        // Flag whether we need to do row height synchronization.
        // syncRowHeightOnNextLayout is a one time flag used when some code knows it has changed data height
        // and that the upcoming layout must sync row heights even if the grid is configured not to for
        // general row rendering.
        ownerContext.doSyncRowHeights = partnerVisible && (ownerGrid.syncRowHeight || ownerGrid.syncRowHeightOnNextLayout);
        if (!me.columnFlusherId) {
            me.columnFlusherId = me.id + '-columns';
            me.rowHeightFlusherId = me.id + '-rows';
        }
        if (me.owner.bufferedRenderer) {
            me.owner.bufferedRenderer.beforeTableLayout(ownerContext);
        }
        // We do not want to call method on extended class, otherwise exception will be raised
        me.superclass.superclass.beginLayout.apply(this, [
            ownerContext
        ]);
        // If we are in a twinned grid (locked view) then set up bidirectional links with
        // the other side's layout context. If the locked or normal side is hidden then
        // we should treat it as though we were laying out a single grid, so don't setup the partners.
        // This is typically if a grid is configured with locking but starts with no locked columns.
        if (partnerVisible && partner.componentLayout.isRunning()) {
            // BUG: if partner is not running, don't look at them
            if (!ownerContext.lockingPartnerContext) {
                (ownerContext.lockingPartnerContext = context.getCmp(partner)).lockingPartnerContext = ownerContext;
            }
            if (ownerContext.doSyncRowHeights) {
                ownerContext.rowHeightSynchronizer = me.owner.syncRowHeightBegin();
            }
        }
        // Grab a ContextItem for the header container (and make sure the TableLayout can
        // reach us as well):
        (ownerContext.headerContext = context.getCmp(me.headerCt)).viewContext = ownerContext;
    }
});

/**
Plugin (ptype = 'scheduler_zones') for showing "global" zones in the scheduler grid, these can by styled easily using just CSS.
To populate this plugin you need to pass it a store having `Sch.model.Range` as the model.

{@img scheduler/images/zones.png 2x}

To add this plugin to scheduler:

    var zonesStore = Ext.create('Ext.data.Store', {
        model   : 'Sch.model.Range',
        data    : [
            {
                StartDate   : new Date(2011, 0, 6),
                EndDate     : new Date(2011, 0, 7),
                Cls         : 'myZoneStyle'
            }
        ]
    });

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Zones', { store : zonesStore })
        ]
    });


*/
Ext.define("Sch.plugin.Zones", {
    extend: "Sch.feature.AbstractTimeSpan",
    alias: "plugin.scheduler_zones",
    requires: [
        'Sch.model.Range'
    ],
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    cls: 'sch-zone',
    side: null,
    init: function(scheduler) {
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        this.side = scheduler.rtl ? 'right' : 'left';
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">' + '<div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' + (innerTpl ? '{[this.renderInner(values)]}' : '') + '</div>' + '</tpl>', {
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        if (typeof this.innerHeaderTpl === 'string') {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        this.callParent(arguments);
    },
    getElementData: function(viewStart, viewEnd, records, isPrint) {
        var schedulerView = this.schedulerView,
            data = [];
        var region = schedulerView.getTimeSpanRegion(viewStart, viewEnd, this.expandToFitView);
        var record, spanStart, spanEnd, zoneData, width, templateData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            spanStart = record.getStartDate();
            spanEnd = record.getEndDate();
            templateData = this.getTemplateData(record);
            if (spanStart && spanEnd && Sch.util.Date.intersectSpans(spanStart, spanEnd, viewStart, viewEnd)) {
                zoneData = Ext.apply({}, templateData);
                zoneData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                zoneData.$cls = this.getElementCls(record, templateData);
                if (schedulerView.isWeekView()) {
                    var timeSpanRegion = schedulerView.getTimeSpanRegion(spanStart, spanEnd);
                    zoneData.left = timeSpanRegion.left;
                    zoneData.top = timeSpanRegion.top;
                    zoneData.height = timeSpanRegion.bottom - timeSpanRegion.top;
                    zoneData.width = timeSpanRegion.right - timeSpanRegion.left;
                } else {
                    var startPos = schedulerView.getCoordinateFromDate(Sch.util.Date.max(spanStart, viewStart));
                    var endPos = schedulerView.getCoordinateFromDate(Sch.util.Date.min(spanEnd, viewEnd));
                    if (schedulerView.isHorizontal()) {
                        zoneData.left = startPos;
                        zoneData.top = region.top;
                        zoneData.width = isPrint ? 0 : endPos - startPos;
                        zoneData.style = isPrint ? ('border-left-width:' + (endPos - startPos) + 'px') : "";
                    } else {
                        zoneData.left = region.left;
                        zoneData.top = startPos;
                        zoneData.height = isPrint ? 0 : endPos - startPos;
                        zoneData.style = isPrint ? ('border-top-width:' + (endPos - startPos) + 'px') : "";
                    }
                }
                data.push(zoneData);
            }
        }
        return data;
    },
    getHeaderElementId: function(record, isStart) {
        return this.callParent([
            record
        ]) + (isStart ? '-start' : '-end');
    },
    /**
     * Return header element class for data record.
     *
     * @param {Sch.model.Range} record Data record
     * @param {Object} data
     * @param {Boolean} isStart
     *
     * @return {String}
     */
    getHeaderElementCls: function(record, data, isStart) {
        var clsField = record.clsField || this.clsField;
        if (!data) {
            data = this.getTemplateData(record);
        }
        return 'sch-header-indicator sch-header-indicator-' + (isStart ? 'start ' : 'end ') + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    getZoneHeaderElementData: function(startDate, endDate, record, isStart) {
        var date = isStart ? record.getStartDate() : record.getEndDate(),
            data = null,
            position, isHorizontal, templateData;
        if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
            position = this.getHeaderElementPosition(date);
            isHorizontal = this.schedulerView.isHorizontal();
            templateData = this.getTemplateData(record);
            data = Ext.apply({
                id: this.getHeaderElementId(record, isStart),
                cls: this.getHeaderElementCls(record, templateData, isStart),
                isStart: isStart,
                side: isHorizontal ? this.side : 'top',
                position: position
            }, templateData);
        }
        return data;
    },
    getHeaderElementData: function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            data = [],
            record, startData, endData;
        records = records || this.store.getRange();
        for (var i = 0,
            l = records.length; i < l; i++) {
            record = records[i];
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true);
            if (startData) {
                data.push(startData);
            }
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
            if (endData) {
                data.push(endData);
            }
        }
        return data;
    },
    updateZoneHeaderElement: function(el, data) {
        // Reapply CSS classes
        el.dom.className = data.cls;
        if (this.schedulerView.isHorizontal()) {
            this.setElementX(el, data.position);
        } else {
            el.setTop(data.position);
        }
    },
    updateHeaderElement: function(record) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            startEl = Ext.get(this.getHeaderElementId(record, true)),
            endEl = Ext.get(this.getHeaderElementId(record, false)),
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true),
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
        if (!(startEl && endData) || !(endEl && endData)) {
            Ext.destroy(startEl, endEl);
            this.renderHeaderElements([
                record
            ]);
        } else {
            if (startEl) {
                if (!startData) {
                    Ext.destroy(startEl);
                } else {
                    this.updateZoneHeaderElement(startEl, startData);
                }
            }
            if (endEl) {
                if (!endData) {
                    Ext.destroy(endEl);
                } else {
                    this.updateZoneHeaderElement(endEl, endData);
                }
            }
        }
    }
});

/**
 * @abstract
 * @private
 * A plugin for visualizing row specific meta data, used internally by the Scheduler.
 */
Ext.define("Sch.plugin.RowZones", {
    extend: 'Sch.plugin.Zones',
    requires: [
        'Ext.XTemplate',
        'Sch.util.Date'
    ],
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl: null,
    /**
     * @cfg {Sch.data.EventStore} store (required) The store containing the meta 'events' to be rendered for each row
     */
    store: null,
    init: function(scheduler) {
        this.store = Ext.StoreManager.lookup(this.store);
        // unique css class to be able to identify the elements belonging to this instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        this.scheduler = scheduler;
        scheduler.registerRenderer(this.renderer, this);
        if (typeof this.innerTpl === 'string') {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }
        var innerTpl = this.innerTpl;
        if (!this.template) {
            this.template = new Ext.XTemplate('<tpl for=".">' + '<div id="' + this.uniqueCls + '-{id}" class="' + this.cls + ' ' + this.uniqueCls + ' {Cls}" style="' + (scheduler.rtl ? 'right' : 'left') + ':{start}px;width:{width}px;top:{start}px;height:{width}px;{style}">' + (// Let implementer override the rendering with the innerTpl property, output Name field by default
            innerTpl ? '{[this.renderInner(values)]}' : ('{' + this.store.getModel().prototype.nameField + '}')) + '</div>' + '</tpl>', {
                renderInner: function(values) {
                    return innerTpl.apply(values);
                }
            });
        }
        this.storeListeners = {
            refresh: this.fullRefresh,
            clear: this.fullRefresh,
            add: this.onZoneAdd,
            remove: this.onZoneRemove,
            update: this.onZoneUpdate,
            scope: this
        };
        this.store.on(this.storeListeners);
    },
    destroy: function() {
        this.store.un(this.storeListeners);
        this.callParent(arguments);
    },
    /**
     * @protected
     * Returns the record owning the provided zone.
     * @param  {Sch.model.Event} zone Zone to get owner of.
     * @return {Ext.data.Model} The record owning the provided zone.
     */
    getViewRecordByZone: function(zone) {
        throw 'Abstract method call';
    },
    getZoneContainerEl: function(zone) {
        var view = this.scheduler.getSchedulingView(),
            record = this.getViewRecordByZone(zone),
            node = record && view.getNode(record);
        return node && node.querySelector('.' + Ext.baseCSSPrefix + 'grid-cell-inner');
    },
    onZoneRemove: function(store, zones) {
        Ext.Array.forEach(zones, function(zone) {
            var node = document.getElementById(this.getElementId(zone));
            node && node.parentElement.removeChild(node);
        }, this);
    },
    onZoneAdd: function(store, zones) {
        Ext.Array.forEach(zones, function(zone) {
            var container = this.getZoneContainerEl(zone);
            container && this.appendZoneElement(zone, container);
        }, this);
    },
    fullRefresh: function() {
        var me = this,
            view = this.scheduler.getSchedulingView();
        // if view is rendered
        if (view.el) {
            // remove this plugin instance related zone elements
            view.el.select('.' + this.uniqueCls).remove();
            Ext.Array.forEach(view.getNodes(), function(node) {
                me.renderRecordZones(view.getRecord(node), true);
            });
        }
    },
    renderer: function(val, meta, record, rowIndex) {
        var result = '';
        if (record && (this.scheduler.isHorizontal() || rowIndex === 0)) {
            result = this.renderRecordZones(record);
        }
        return result;
    },
    /**
     * @protected
     * Returns zones for the provided record.
     * @param  {Ext.data.Model} record Record to build zones for.
     * @return {Sch.model.Event[]}     List of the record zones.
     */
    getRecordZones: function(record) {
        throw 'Abstract method call';
    },
    getTemplateData: function(zone) {
        var scheduler = this.scheduler,
            renderData = scheduler.getSchedulingView()[scheduler.getMode()].getEventRenderData(zone),
            start, width;
        if (scheduler.isHorizontal()) {
            start = scheduler.rtl ? renderData.right : renderData.left;
            width = renderData.width;
        } else {
            start = renderData.top;
            width = renderData.height;
        }
        return Ext.apply({
            id: zone.internalId,
            start: start,
            width: width,
            Cls: zone.getCls()
        }, zone.data);
    },
    renderRecordZones: function(record, targetElement) {
        var scheduler = this.scheduler,
            viewStart = scheduler.timeAxis.getStart(),
            viewEnd = scheduler.timeAxis.getEnd(),
            data = [],
            zones = this.getRecordZones(record),
            result = '',
            spanStartDate, spanEndDate, zone;
        for (var i = 0,
            len = zones.length; i < len; i++) {
            zone = zones[i];
            spanStartDate = zone.getStartDate();
            spanEndDate = zone.getEndDate();
            if (spanStartDate && spanEndDate && // Make sure this zone is inside current view
            scheduler.timeAxis.isRangeInAxis(zone)) {
                data.push(this.getTemplateData(zone));
            }
        }
        if (targetElement) {
            if (zone) {
                if (Ext.isBoolean(targetElement)) {
                    targetElement = this.getZoneContainerEl(zone);
                }
                this.template.append(targetElement, data);
            }
        } else {
            result = this.template.apply(data);
        }
        return result;
    },
    appendZoneElement: function(zone) {
        var scheduler = this.scheduler,
            viewStart = scheduler.timeAxis.getStart(),
            viewEnd = scheduler.timeAxis.getEnd(),
            containerEl = this.getZoneContainerEl(zone),
            spanStartDate = zone.getStartDate(),
            spanEndDate = zone.getEndDate();
        if (containerEl && spanStartDate && spanEndDate && // Make sure this zone is inside current view
        Sch.util.Date.intersectSpans(spanStartDate, spanEndDate, viewStart, viewEnd)) {
            this.template.append(containerEl, this.getTemplateData(zone));
        }
    },
    onZoneUpdate: function(store, zone) {
        var node = document.getElementById(this.getElementId(zone));
        if (node) {
            var scheduler = this.scheduler,
                viewStart = scheduler.timeAxis.getStart(),
                viewEnd = scheduler.timeAxis.getEnd();
            var start = Sch.util.Date.max(viewStart, zone.getStartDate()),
                end = Sch.util.Date.min(viewEnd, zone.getEndDate()),
                cls = zone.getCls();
            var startPos = scheduler.getSchedulingView().getCoordinateFromDate(start);
            var width = scheduler.getSchedulingView().getCoordinateFromDate(end) - startPos;
            // Reapply CSS classes
            node.className = this.cls + ' ' + this.uniqueCls + ' ' + (cls || '');
            node.style.left = startPos + 'px';
            node.style.top = startPos + 'px';
            node.style.height = width + 'px';
            node.style.width = width + 'px';
        }
    }
});

/**
 * A plugin (ptype = 'scheduler_resourcezones') for visualizing resource specific meta data such as availability, used internally by the Scheduler.
 * To use this feature, assign an {@link Sch.data.EventStore eventStore} to the {@link Sch.mixin.SchedulerPanel#cfg-resourceZones resourceZones}
 * config on the main Scheduler panel class. Additionally, you can provide the {@link Sch.mixin.SchedulerPanel#cfg-resourceZonesConfig resourceZonesConfig} object
 * with configuration options.
 *
 *
 *     {
 *         xtype           : 'schedulergrid',
 *         region          : 'center',
 *         startDate       : new Date(2013, 0, 1),
 *         endDate         : new Date(2014, 0, 1),
 *         resourceStore   : new Sch.data.ResourceStore(),
 *         // Meta events such as availabilities can be visualized here
 *         resourceZones   : new Sch.data.EventStore(),
 *         resourceZonesConfig : {
 *             innerTpl : '... customized template here ...'
 *         },
 *         eventStore      : new Sch.data.EventStore()  // Regular tasks in this store
 *     }
 *
 * {@img scheduler/images/resource-zones.png 2x}
 *
 * Records in the store should be regular {@link Sch.model.Event events} where you can specify the Resource, StartDate, EndDate and Cls (to set a CSS class on the rendered zone).
 */
Ext.define("Sch.plugin.ResourceZones", {
    extend: 'Sch.plugin.RowZones',
    alias: 'plugin.scheduler_resourcezones',
    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    /**
     * @cfg {Sch.data.EventStore} store (required) The store containing the meta 'events' to be rendered for each resource
     */
    cls: 'sch-resourcezone',
    init: function(scheduler) {
        this.callParent(arguments);
        this.store.setResourceStore(scheduler.getResourceStore());
        scheduler.on('resourcestorechange', this.onResourceStoreChange, this);
    },
    /**
     * @method getTemplateData
     *
     * Returns data to apply to the HTML template for rendering a timespan element. You can use this to apply custom styling to each rendered timespan.
     *
     *      resourceZonesConfig : {
     *          getTemplateData : function (zone) {
     *              var data = Sch.plugin.ResourceZones.prototype.getTemplateData.call(this, zone);
     *
     *               if (zone.getResourceId() === 6) {
     *                   data.style = "background:#ddd";
     *               }
     *               return data;
     *           }
     *      }
     *
     * @param {Ext.data.Model} record
     *
     * @return {Object}
     */
    onResourceStoreChange: function(panel, newStore) {
        this.store.setResourceStore(newStore);
    },
    getRecordZones: function(record) {
        // get list of zones associated w/ the resource from this.store
        return record.getEvents(this.store);
    },
    getViewRecordByZone: function(zone) {
        return zone.getResource();
    },
    getZoneContainerEl: function(zone) {
        var result;
        if (this.scheduler.isHorizontal()) {
            result = this.callParent(arguments);
        } else {
            var view = this.scheduler.getSchedulingView(),
                resourceRecord = zone.getResource();
            if (view.el && resourceRecord) {
                var colIndex = view.resourceStore.indexOf(resourceRecord);
                result = view.getNode(0).querySelector('.' + Ext.baseCSSPrefix + 'grid-cell:nth-child(' + (colIndex + 1) + ') .' + Ext.baseCSSPrefix + 'grid-cell-inner');
            }
        }
        return result;
    },
    fullRefresh: function() {
        var me = this,
            view = this.scheduler.getSchedulingView();
        if (me.scheduler.isHorizontal()) {
            this.callParent(arguments);
        }
        // if view is rendered
        else if (view.el) {
            // remove this plugin instance related zone elements
            view.el.select('.' + this.uniqueCls).remove();
            view.resourceStore.each(function(resource) {
                me.renderRecordZones(resource, true);
            });
        }
    }
});

/**

@class Sch.mixin.AbstractSchedulerPanel
@private

A mixin providing "scheduling" functionality to the consuming "panel".
A consuming class should have already consumed the {@link Sch.mixin.AbstractTimelinePanel} mixin.

This should not be used directly.

*/
Ext.define('Sch.mixin.AbstractSchedulerPanel', {
    requires: [
        'Sch.model.Event',
        'Sch.model.Resource',
        'Sch.data.EventStore',
        'Sch.data.ResourceStore',
        'Sch.util.Date',
        'Sch.plugin.ResourceZones'
    ],
    /**
    * @cfg {String} eventBarIconClsField
    * A field in the Event model whose value will be applied as a CSS class to each event bar to place a 16x16 icon.
    */
    eventBarIconClsField: '',
    /**
    * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
    */
    enableEventDragDrop: true,
    /**
    * @cfg {String} eventBarTextField The field in your data model that will be rendered into each event bar.
    * You can alternatively use the eventBarRenderer to get full control over what gets displayed.
    */
    /**
     * @cfg {String} resourceColumnClass
     * Defines the column class for the resources, override this to use your own custom column class. (Used only in vertical orientation)
     */
    resourceColumnClass: "Sch.column.Resource",
    /**
     * @cfg {Number} resourceColumnWidth
     * Used only in vertical mode. Defines the width of a single column.
     */
    resourceColumnWidth: null,
    /**
    * @cfg {Boolean} allowOverlap Set to false if you don't want to allow events overlapping (defaults to true).
    */
    allowOverlap: true,
    /**
    * @cfg {String} startParamName The name of the start date parameter that will be passed to in every `eventStore` load request.
    */
    startParamName: 'startDate',
    /**
    * @cfg {String} endParamName The name of the end date parameter that will be passed to in every `eventStore` load request.
    */
    endParamName: 'endDate',
    /**
    * @cfg {Boolean} passStartEndParameters true to apply start and end dates of the current view to any `eventStore` load requests.
    */
    passStartEndParameters: false,
    /**
     * @cfg {Number} barMargin
     * Controls how much space to leave between stacked event bars in px
     */
    /**
     * @cfg {Boolean} constrainDragToResource
     * Set to true to only allow dragging events within the same resource. Defaults to false.
     */
    /**
    * @cfg {Function} eventRenderer
    * An empty function by default, but provided so that you can override it. This function is called each time an event
    * is rendered into the schedule to render the contents of the event. It's called with the event, its resource and a tplData object which
    * allows you to populate data placeholders inside the event template.
    * By default, the {@link #eventTpl} includes placeholders for 'cls' and 'style'. The cls property is a CSS class which will be added to the
    * event element. The style property is an inline style declaration for the event element. If you override the default {@link #eventTpl}, you can of course
    * include other placeholder in your template markup. Note: You will still need to keep the original built-in placeholders for the scheduler to work.
    *
    * <pre>
    *  eventRenderer : function (eventRec, resourceRec, templateData) {
    *      templateData.style = 'color:white';                 // You can use inline styles too.
    *      templateData.cls = resourceRec.get('Category');     // Read a property from the resource record, used as a CSS class to style the event
    *
    *      return Ext.Date.format(eventRec.getStartDate(), 'Y-m-d') + ': ' + eventRec.getName();
    *  }
    *</pre>
    * @param {Sch.model.Event} eventRecord The event about to be rendered
    * @param {Sch.model.Resource} resourceRecord The resource row in which the event is being created
    * @param {Object} tplData An object that will be applied to the containing {@link #eventTpl}.
    * @param {Number} row The row index
    * @param {Number} col The column index
    * @param {Sch.data.ResourceStore} ds The resource store
    * @return {String/Object} A simple string, or a custom object which will be applied to the {@link #eventBodyTemplate}, creating the actual HTML
    */
    eventRenderer: null,
    /**
    * @cfg {Object} eventRendererScope The scope to use for the {@link #eventRenderer} function
    */
    eventRendererScope: null,
    /**
     * @cfg {Sch.data.EventStore} eventStore (required) The {@link Ext.data.Store} holding the events to be rendered into the scheduler.
     */
    eventStore: null,
    /**
     * @cfg {Sch.data.ResourceStore} resourceStore (required) The {@link Ext.data.Store} holding the resources to be rendered into the scheduler.
     */
    resourceStore: null,
    /**
     * @method onEventCreated An empty function by default, but provided so that you can override it to supply default record values etc. This function is called after a new event has been created (but
     * before it is inserted to the store). This is for example called after a user dragged a new bar in the scheduler (the DragCreate feature).
     * @param {Sch.model.Event} eventRecord The event that was just created
     * @param {Sch.model.Resource[]} resources The corresponding resources which will be assigned
     */
    onEventCreated: function(newEventRecord, resources) {},
    /**
    * @cfg {Ext.Template} eventTpl The wrapping template used to renderer your events in the scheduler. Normally you should not override this,
    * only do so if you need total control of how the events are rendered/styled. See the {@link #eventBodyTemplate} for more information.
    */
    /**
    * @cfg {String/Ext.Template} eventBodyTemplate The template used to generate the markup of your events in the scheduler. To 'populate' the eventBodyTemplate with data, use the {@link #eventRenderer} method
    */
    /**
    *  @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
    */
    /**
     * @cfg {Object} weekViewTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in weekview mode.
     */
    /**
     * @cfg {Sch.data.EventStore} resourceZones A special store containing data used to highlight the underlying schedule for the resources,
     * using {@link Sch.plugin.ResourceZones}. This can be used to color non-working time or any other meta data associated with a resource.
     * See also {@link #resourceZonesConfig}.
     */
    resourceZones: null,
    /**
     * @cfg {Object} resourceZonesConfig An object with configuration options for {@link Sch.plugin.ResourceZones}. Ignored if no {@link #resourceZones}
     * config is provided.
     */
    resourceZonesConfig: null,
    initStores: function() {
        var resourceStore = this.resourceStore || this.store;
        if (this.crudManager) {
            if (!Sch.crud.AbstractManager) {
                throw new Error('Sch.crud.AbstractManager not loaded, did you forget to require ' + 'crudManager class (e.g. Sch.data.CrudManager)?');
            }
            if (!(this.crudManager instanceof Sch.crud.AbstractManager)) {
                // If xclass wasn't specified - use default one
                this.crudManager = Ext.create(this.crudManager.xclass || 'Sch.data.CrudManager', Ext.clone(this.crudManager));
            }
        }
        if (!resourceStore) {
            if (this.crudManager) {
                resourceStore = this.resourceStore = this.crudManager.getResourceStore();
            }
            if (!resourceStore) {
                if (this.isTree) {
                    resourceStore = new Sch.data.ResourceTreeStore({
                        proxy: 'memory'
                    });
                } else {
                    resourceStore = new Sch.data.ResourceStore();
                }
            }
        }
        if (!this.dependencyStore) {
            if (this.crudManager) {
                this.dependencyStore = this.crudManager.getDependencyStore();
            }
        }
        //this.dependencyStore = this.dependencyStore || new Sch.data.DependencyStore();
        if (!this.eventStore) {
            if (this.crudManager) {
                this.eventStore = this.crudManager.getEventStore();
            }
            this.eventStore = this.eventStore || new Sch.data.EventStore();
        }
        // Set "store" for the grid panel API
        this.store = Ext.StoreManager.lookup(resourceStore);
        this.resourceStore = this.store;
        this.setEventStore(this.eventStore);
        if (!this.eventStore || !this.eventStore.isEventStore) {
            Ext.Error.raise("Your eventStore should be a subclass of Sch.data.EventStore (or consume the EventStore mixin)");
        }
        this.resourceStore.eventStore = this.getEventStore();
    },
    _initializeSchedulerPanel: function() {
        this.initStores();
        if (this.eventBodyTemplate && typeof this.eventBodyTemplate === 'string') {
            this.eventBodyTemplate = new Ext.XTemplate(this.eventBodyTemplate);
        }
        this.on('destroy', function() {
            this.setResourceStore(null);
            this.setEventStore(null);
        });
    },
    /**
    * Returns the resource store instance
    * @return {Sch.data.ResourceStore}
    */
    getResourceStore: function() {
        return this.resourceStore;
    },
    /**
     * Sets the resource store
     * @param {Sch.data.ResourceStore} newResourceStore
     */
    setResourceStore: function(newResourceStore) {
        var oldResourceStore = this.getResourceStore();
        this.resourceStore = newResourceStore = newResourceStore && Ext.StoreManager.lookup(newResourceStore);
        var eventStore = this.getEventStore();
        // If null is passed - do not remove link between stores. Partner panel might be destroyed
        if (eventStore && newResourceStore) {
            eventStore.setResourceStore(newResourceStore);
        }
        var view = this.getSchedulingView();
        view && view.setResourceStore(newResourceStore);
        if (newResourceStore) {
            this.fireEvent('resourcestorechange', this, newResourceStore, oldResourceStore);
            // In case of vertical view the columns are resources, so they have to be recreated
            if (this.isVertical()) {
                this.refreshResourceColumns();
                this.mun(oldResourceStore, this.verticalListeners);
                this.mon(newResourceStore, this.verticalListeners);
            }
            if (this.isWeekView()) {
                this.mun(oldResourceStore, this.calendarResourceStoreListeners);
                this.mon(newResourceStore, this.calendarResourceStoreListeners);
            }
            // if the panel is in horizontal mode (oldResourceStore === panel.store)
            // we use Sencha provided grid.reconfigure()
            if (oldResourceStore === this.store) {
                this.reconfigure(newResourceStore);
            } else {
                this.refreshViews(false);
            }
            if (this.allDayNormalHeader) {
                this.allDayNormalHeader.refreshViews(false);
            }
        }
    },
    /**
    * Returns the event store instance
    * @return {Sch.data.EventStore}
    */
    getEventStore: function() {
        return this.eventStore;
    },
    /**
     * Sets the event store
     * @param {Sch.data.EventStore} newEventStore
     */
    setEventStore: function(newEventStore) {
        var oldEventStore = this.getEventStore();
        newEventStore = newEventStore && Ext.StoreManager.lookup(newEventStore);
        if (this.getEventStore()) {
            this.mun(this.getEventStore(), 'beforeload', this.applyStartEndParameters, this);
        }
        var resourceStore = this.getResourceStore();
        var assignmentStore = this.getAssignmentStore();
        var dependencyStore = this.getDependencyStore();
        this.eventStore = newEventStore;
        // If null is passed - do not remove link between stores. Partner panel might be destroyed
        if (resourceStore && newEventStore) {
            resourceStore.setEventStore(newEventStore);
        }
        if (assignmentStore && newEventStore && !newEventStore.getAssignmentStore()) {
            newEventStore.setAssignmentStore(assignmentStore);
        }
        if (dependencyStore && newEventStore && !newEventStore.getDependencyStore()) {
            newEventStore.setDependencyStore(dependencyStore);
        }
        var view = this.getSchedulingView();
        // resource store will be bound correct under the hood of this method
        view && view.setEventStore(newEventStore);
        if (this.allDayNormalHeader) {
            this.allDayNormalHeader.setEventStore(newEventStore);
        }
        if (newEventStore) {
            this.fireEvent('eventstorechange', this, newEventStore, oldEventStore);
            if (this.passStartEndParameters) {
                this.mon(newEventStore, 'beforeload', this.applyStartEndParameters, this);
            }
            this.refreshViews(false);
        }
    },
    // Applies the start and end date to each event store request
    applyStartEndParameters: function(eventStore, options) {
        var proxy = eventStore.getProxy();
        proxy.setExtraParam(this.startParamName, this.getStart());
        proxy.setExtraParam(this.endParamName, this.getEnd());
    },
    /**
     * Returns the assignment store instance
     * @return {Sch.data.AssignmentStore}
     */
    getAssignmentStore: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isStore && eventStore.getAssignmentStore() || me.assignmentStore;
    },
    /**
     * Sets the assignment store
     * @param {Sch.data.AssignmentStore} newAssignmentStore
     */
    setAssignmentStore: function(newAssignmentStore) {
        var oldStore = this.getAssignmentStore();
        this.getEventStore().setAssignmentStore(newAssignmentStore);
        if (newAssignmentStore) {
            this.fireEvent('assignmentstorechange', this, newAssignmentStore, oldStore);
            this.refreshViews(false);
        }
    },
    /**
     * Returns the assignment store instance
     * @return {Sch.data.DependencyStore}
     */
    getDependencyStore: function() {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isStore && eventStore.getDependencyStore() || me.dependencyStore;
    },
    /**
     * Sets the assignment store
     * @param {Sch.data.DependencyStore} newDependencyStore
     */
    setDependencyStore: function(newDependencyStore) {
        var oldStore = this.getDependencyStore();
        this.getEventStore().setDependencyStore(newDependencyStore);
        if (newDependencyStore) {
            this.fireEvent('dependencystorechange', this, newDependencyStore, oldStore);
            this.refreshViews(false);
        }
    },
    createResourceColumns: function(colWidth) {
        return Ext.Array.map(this.resourceStore.getRange(), function(resource) {
            return {
                xclass: this.resourceColumnClass,
                renderer: this.mainRenderer,
                scope: this,
                width: colWidth || 100,
                text: resource.getName(),
                model: resource
            };
        }, this);
    },
    registerEventEditor: function(editor) {
        this.getSchedulingView().registerEventEditor(editor);
    }
});

/**
 @class Sch.template.Event
 */
Ext.define("Sch.template.Event", {
    extend: 'Ext.XTemplate',
    eventPrefix: null,
    // 'none', 'start', 'end' or 'both'
    resizeHandles: null,
    resizeTpl: '<div class="sch-resizable-handle sch-resizable-handle-DIR"></div>',
    // Array of strings, ['left', 'top'] etc
    terminalSides: null,
    terminalTpl: '<div class="sch-terminal sch-terminal-SIDE"></div>',
    constructor: function(config) {
        var me = this;
        Ext.apply(me, config);
        me.callParent([
            this.getOuterMarkup()
        ]);
    },
    getOuterMarkup: function() {
        var me = this;
        var terminalMarkup = Ext.Array.map(me.terminalSides || [], function(side) {
                return me.terminalTpl.replace(/SIDE/, side);
            }).join('');
        return [
            '<tpl for=".">',
            '<div unselectable="on" tabindex="-1" id="',
            me.eventPrefix,
            '{id}" style="right:{right}px;left:{left}px;top:{top}px;height:{height}px;width:{width}px;{style}" class="sch-event ',
            Ext.baseCSSPrefix,
            'unselectable {internalCls} {cls}">',
            ((me.resizeHandles === 'start' || me.resizeHandles === 'both') ? me.resizeTpl.replace(/DIR/, 'start') : ''),
            '<div unselectable="on" class="sch-event-inner">',
            '<tpl if="iconCls"><i class="sch-event-icon {iconCls}"></i></tpl>',
            this.getInnerMarkup(),
            '</div>',
            ((me.resizeHandles === 'end' || me.resizeHandles === 'both') ? me.resizeTpl.replace(/DIR/, 'end') : ''),
            terminalMarkup,
            '</div>',
            '</tpl>'
        ].join('');
    },
    /**
     * Overriding this method will make {@link Sch.mixin.AbstractSchedulerPanel#eventBodyTemplate} obsolete, unless
     * you use '{body}' placeholder in returned string/template.
     * @returns {Ext.XTemplate/String}
     * @private
     */
    getInnerMarkup: function() {
        return '{body}';
    }
});

/**
 * @class Sch.view.Vertical
 * @private
 *
 * A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation of some methods, specific to vertical mode.
*/
Ext.define("Sch.view.Vertical", {
    requires: [
        'Ext.util.Region',
        'Ext.Element',
        'Ext.Array',
        'Sch.util.Date'
    ],
    // Provided by creator, in the config object
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        var view = this.view,
            query;
        raw = raw || false;
        if (resourceRecord) {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
        } else {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-]';
        }
        return view.getEl().query(query, raw);
    },
    translateToScheduleCoordinate: function(y) {
        var view = this.view;
        return y - view.getViewContainerElementTop() + view.getVerticalScroll();
    },
    // private
    translateToPageCoordinate: function(y) {
        var view = this.view;
        var scroll = view.getVerticalScroll();
        return y + view.getViewContainerElementTop() - scroll;
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy[1];
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event, resource) {
        var M = Math,
            eventStart = event.getStartDate(),
            eventEnd = event.getEndDate(),
            view = this.view,
            viewStart = view.timeAxis.getStart(),
            viewEnd = view.timeAxis.getEnd(),
            startY = M.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart))),
            endY = M.floor(view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd))),
            data = {
                event: event
            };
        data.top = M.max(0, M.min(startY, endY) - view.eventBorderWidth);
        data.height = M.max(1, M.abs(startY - endY));
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region = resourceRecord ? Ext.fly(view.getScheduleCell(view.getNodes()[0], view.getResourceStore().indexOf(resourceRecord))).getRegion() : view.getTableRegion(),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {
                start: taStart,
                end: taEnd
            },
            startY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endY = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),
            left = region.left + view.barMargin,
            right = (resourceRecord ? (region.left + this.getResourceColumnWidth(resourceRecord)) : region.right) - view.barMargin;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    getResourceColumnWidth: function(resource) {
        return this.view.timeAxisViewModel.resourceColumnWidth;
    },
    getResourceColumnLayoutAvailableWidth: function(resourceRecord) {
        var me = this;
        return me.getResourceColumnWidth(resourceRecord) - (2 * me.view.barMargin) - me.view.cellBorderWidth;
    },
    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getResourceColumnWidth(resourceRecord),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left = cellLeft + view.cellBorderWidth,
            right = cellLeft + this.getResourceColumnWidth(resourceRecord) - view.cellBorderWidth;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';
        if (rowIndex === 0) {
            var D = Sch.util.Date,
                ta = view.timeAxis,
                columnEvents, resourceEvents, i, l;
            columnEvents = [];
            resourceEvents = view.getEventStore().getEventsForResource(resourceRecord);
            // Iterate events (belonging to current resource)
            for (i = 0 , l = resourceEvents.length; i < l; i++) {
                var event = resourceEvents[i],
                    start = event.getStartDate(),
                    end = event.getEndDate();
                // Determine if the event should be rendered or not
                if (start && end && ta.timeSpanInAxis(start, end)) {
                    columnEvents.push(view.generateTplData(event, resourceRecord, colIndex));
                }
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getResourceColumnLayoutAvailableWidth(resourceRecord));
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }
        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }
        return retVal;
    },
    // private
    resolveResource: function(node) {
        var me = this,
            view = me.view,
            eventNode,
            index = -1,
            result;
        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        } else {
            node = Ext.fly(node).is(view.timeCellSelector) ? node : Ext.fly(node).up(view.timeCellSelector, null, true);
            if (node) {
                index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
            }
            result = index >= 0 && view.getResourceStore().getAt(index) || null;
        }
        return result;
    },
    // private
    onEventUpdate: function(store, event) {
        var me = this;
        var previous = event.previous || {};
        var view = me.view;
        var timeAxis = view.timeAxis;
        var newStartDate = event.getStartDate();
        var newEndDate = event.getEndDate();
        var startDate = previous[event.startDateField] || newStartDate;
        var endDate = previous[event.endDateField] || newEndDate;
        // event was visible or visible now
        var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
        var resource;
        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (event.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new resource, refresh old resource first
            resource = store.getResourceStore().getById(previous[event.resourceIdField]);
            resource && me.relayoutRenderedEvents(resource);
        }
        // also resource has to be repanted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            me.renderSingle(event);
            Ext.Array.each(event.getResources(), function(resource) {
                me.relayoutRenderedEvents(resource);
                view.getEventSelectionModel().isSelected(event) && view.onEventBarSelect(event, true);
            });
        }
    },
    // private
    onEventAdd: function(store, recs) {
        var me = this,
            view = me.view,
            event, startDate, endDate;
        if (recs.length === 1) {
            event = recs[0];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                me.renderSingle(event);
                // Here one could use event.getResources() as well, I use store.getResourcesForEvent() here
                // for consistency with onEventUpdate only
                Ext.Array.each(store.getResourcesForEvent(event), function(resource) {
                    me.relayoutRenderedEvents(resource);
                });
            }
        } else {
            view.repaintAllEvents();
        }
    },
    // private
    onEventRemove: function(s, events) {
        // a comment from `repaintEventsForResource`
        // For vertical, we always repaint all events (do per-column repaint is not supported)
        // so it seems we can't optimize and repaint only for single resource
        var me = this,
            view = me.view,
            event, startDate, endDate, i, len, gotEventInTimeSpan;
        for (gotEventInTimeSpan = false , i = 0 , len = events.length; !gotEventInTimeSpan && i < len; i++) {
            event = events[i];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            gotEventInTimeSpan = startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate);
            // Event repaint is deffered due to #4607.
            //
            // The issues happened when one loaded records with existing ids into the event store, in this case
            // the old records are replaced with the new ones. But this also leaded to replaced event elements
            // disappearing if event store is filtered.
            //
            // The issue has happened for Vertical mode but hasn't for Horizontal. The one big difference in those
            // modes onEventRemove() methods implementation is that Horizontal mode fades out the removed events'
            // elements and calls repaint code afterwards, i.e. repainting is delayed, whereas in Vertical mode
            // the repainting had happened instanly. After I switched to delayed repainting the issue related test
            // 1000_vertical_4607.t.js became green.
            gotEventInTimeSpan && Ext.asap(function() {
                view.repaintAllEvents();
            });
        }
    },
    getScheduledEventsForResource: function(resourceRecord) {
        var view = this.view;
        return view.getEventStore().filterEventsForResource(resourceRecord, function(event) {
            return view.timeAxis.isRangeInAxis(event) && event.isScheduled();
        });
    },
    relayoutRenderedEvents: function(resource) {
        var data = [],
            view = this.view,
            events = this.getScheduledEventsForResource(resource);
        Ext.Array.each(events, function(event) {
            // In vertical mode there can be only 0 or 1 nodes rendered for each event/resource pair
            var nodes = view.getElementsFromEventRecord(event, resource);
            nodes.length && data.push({
                start: event.getStartDate(),
                end: event.getEndDate(),
                event: event,
                node: nodes[0]
            });
        });
        // Now do a layout pass to get updated dimension / position data for all affected events
        view.eventLayout.vertical.applyLayout(data, this.getResourceColumnLayoutAvailableWidth(resource));
        Ext.Array.each(data, function(event) {
            event.node.setStyle({
                left: event.left + 'px',
                width: event.width + 'px'
            });
            view.fireEvent('eventrepaint', view, event.event, event.node);
        });
    },
    renderSingle: function(event) {
        // Inject moved event into correct cell
        var view = this.view,
            startDate = event.getStartDate(),
            endDate = event.getEndDate();
        // First removing existing event DOM elements, there might be one element per each event/resource pair
        Ext.Array.each(view.getElementsFromEventRecord(event), function(el) {
            el.destroy();
        });
        // If event is within a currently displayed timespan
        if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
            // then render event DOM elements for each event assigned resource
            Ext.Array.each(event.getResources(), function(resource) {
                var rIndex = view.getResourceStore().indexOf(resource),
                    containerCell = Ext.fly(view.getScheduleCell(0, rIndex)),
                    data;
                if (containerCell) {
                    // This check is unclear, I've just left it as is after the method refactoring
                    data = view.generateTplData(event, resource, rIndex);
                    data && view.eventTpl.append(containerCell.first(), [
                        data
                    ]);
                }
            });
        }
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate) {
        var view = this.view,
            startY = view.getCoordinateFromDate(startDate),
            endY = endDate ? view.getCoordinateFromDate(endDate) : startY,
            tableRegion = view.getTableRegion(),
            width = tableRegion ? tableRegion.right - tableRegion.left : view.getEl().dom.clientWidth;
        // fallback in case grid is not rendered (no rows/table)
        return new Ext.util.Region(Math.min(startY, endY), width, Math.max(startY, endY), 0);
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var topDate = this.view.getDateFromCoordinate(region.top, roundingMethod),
            bottomDate = this.view.getDateFromCoordinate(region.bottom, roundingMethod);
        if (topDate && bottomDate) {
            return {
                start: topDate,
                end: bottomDate
            };
        } else {
            return null;
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.resourceColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.rendered) {
            return null;
        }
        var scroll = view.getScroll(),
            height = view.getViewContainerHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();
        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate = view.timeAxis.getStart();
            return {
                startDate: startDate,
                endDate: viewEndDate
            };
        }
        return {
            startDate: view.getDateFromCoordinate(scroll.top, null, true),
            endDate: view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    },
    /**
     * Gets box for displayed item designated by the record. If there're several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan will not be returned.
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @protected
     */
    getItemBox: function(eventRecord) {
        var me = this;
        return Ext.Array.map(eventRecord.getResources(), function(resourceRecord) {
            return me.getResourceEventBox(eventRecord, resourceRecord);
        });
    },
    getResourceEventBox: function(eventRecord, resourceRecord) {
        var SUD = Sch.util.Date,
            me = this,
            result = null,
            view = me.view,
            viewStartDate = view.timeAxis.getStart(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            viewEndDate = view.timeAxis.getEnd(),
            // WARNING: timeaxis is the private property of Sch.mixin.AbstractTimelineView
            eventStartDate = eventRecord.getStartDate(),
            eventEndDate = eventRecord.getEndDate(),
            eventLayout, eventsLayoutData, eventRecordData, resourceColumnLeft, eventEls, eventEl, eventElOffsets, eventElBox;
        // Checking if event record is within current time axis timespan, i.e. if it's rendered
        if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate)) {
            // Managed event sizing means that the view is responsible for event height setting, the oposite case
            // is when event height is controlled by CSS's top and height properties.
            // Fast case: managed event sizing on, querying the view for box position and dimensions
            if (view.managedEventSizing) {
                eventLayout = view.eventLayout.vertical;
                var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
                // Preparing events layout data for event layout instance to process
                eventsLayoutData = Ext.Array.map(resourceEvents, me.getEventRenderData, me);
                // Processing event layout data injecting event horizontal position into them
                eventLayout.applyLayout(eventsLayoutData, me.getResourceColumnLayoutAvailableWidth(resourceRecord));
                // Now we are to find our particular event data inside all events data for the given row record
                eventRecordData = Ext.Array.findBy(eventsLayoutData, function(eventData) {
                    return eventData.event == eventRecord;
                });
                // We must find our event record corresponding layout data object here, but just to make sure
                if (eventRecordData) {
                    // We have event record data with coordinates within the row node, but we need
                    // those coordinates to be translated relative to view's viewport left.
                    resourceColumnLeft = view.getResourceStore().indexOf(resourceRecord) * me.getResourceColumnWidth(resourceRecord);
                    // Finally we have all the data needed to calculated the event record box
                    result = {
                        rendered: true,
                        start: eventRecordData.left + resourceColumnLeft,
                        end: eventRecordData.left + eventRecordData.width + resourceColumnLeft,
                        top: eventRecordData.top,
                        bottom: eventRecordData.top + eventRecordData.height
                    };
                }
            } else // Slow case: managed event sizing off, querying the DOM for box position and dimensions
            {
                eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
                // We must have at one and only one element here, but just to make sure
                if (eventEls.length) {
                    eventEl = eventEls[0];
                    eventElOffsets = eventEl.getOffsetsTo(view.getEl());
                    eventElBox = eventEl.getBox();
                    result = {
                        rendered: true,
                        start: eventElOffsets[0],
                        end: eventElOffsets[0] + eventElBox.width,
                        top: eventElOffsets[1],
                        bottom: eventElOffsets[1] + eventElBox.height
                    };
                }
            }
            // Some boxes might need special adjustments
            if (result) {
                result = me.adjustItemBox(eventRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Sch.model.Event} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(eventRecord, eventRecordBox) {
        return eventRecordBox;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'top';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'bottom';
    }
});

/**

@class Sch.mixin.AbstractSchedulerView
@private

A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
should have already consumed the {@link Sch.mixin.TimelineView} mixin.

Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

*/
Ext.define('Sch.mixin.AbstractSchedulerView', {
    requires: [
        'Sch.template.Event',
        'Sch.eventlayout.Horizontal',
        'Sch.view.Vertical',
        'Sch.eventlayout.Vertical'
    ],
    _cmpCls: 'sch-schedulerview',
    scheduledEventName: 'event',
    /**
     * @cfg {String} eventTemplateClass Name of the template class responsible for rendering events
     * @private
     */
    eventTemplateClass: 'Sch.template.Event',
    // The template instance responsible for rendering the event bars
    eventTpl: null,
    /**
    * @cfg {Number} barMargin
    * Controls how much space to leave between stacked event bars in px
    */
    barMargin: 0,
    /**
    * @cfg {Boolean} constrainDragToResource Set to true to only allow dragging events within the same resource.
    */
    constrainDragToResource: false,
    // Provided by panel
    allowOverlap: null,
    readOnly: null,
    altColCls: 'sch-col-alt',
    /**
     * @cfg {String} highlightedEventCls CSS applied to highlighted event node
     * @private
     */
    highlightedEventCls: 'sch-event-highlighted',
    /**
     * @cfg {Boolean} highlightDirtyEvents Set to true to highlight modified events.
     */
    highlightDirtyEvents: false,
    /**
    * @cfg {Boolean} dynamicRowHeight
    * True to layout events without overlapping, meaning the row height will be dynamically calculated to fit any overlapping events.
    */
    dynamicRowHeight: true,
    /**
    * @cfg {Boolean} managedEventSizing
    * True to size events based on the rowHeight and barMargin settings. Set this to false if you want to control height and top properties via CSS instead.
    */
    managedEventSizing: true,
    /**
    * @cfg {Boolean} eventAnimations
    * True to animate event updates, currently only used in vertical mode in CSS3 enabled browsers.
    */
    eventAnimations: true,
    /**
     * @cfg {String} horizontalLayoutCls
     * The class name responsible for the horizontal event layout process. Override this to take control over the layout process.
     */
    horizontalLayoutCls: 'Sch.eventlayout.Horizontal',
    horizontalEventSorterFn: null,
    /**
     * @cfg {Function} horizontalEventSorterFn
     *
     *  Override this method to provide a custom sort function to sort any overlapping events. By default,
     *  overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     *  Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event a is placed above event b.
     *
     horizontalEventSorterFn : function (a, b) {

            var startA = a.getStartDate(), endA = a.getEndDate();
            var startB = b.getStartDate(), endB = b.getEndDate();

            var sameStart = (startA - startB === 0);

            if (sameStart) {
                return endA > endB ? -1 : 1;
            } else {
                return (startA < startB) ? -1 : 1;
            }
        }
     *
     * @param  {Sch.model.Event} a
     * @param  {Sch.model.Event} b
     * @return {Int}
     */
    /**
     * @cfg {String} verticalLayoutCls
     * The class name responsible for the vertical event layout process. Override this to take control over the layout process.
     */
    verticalLayoutCls: 'Sch.eventlayout.Vertical',
    /**
     * @cfg {Function} verticalEventSorterFn
     * Override this method to provide a custom sort function to sort any overlapping events. By default,
     * overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     * If this function returns -1, then event a is placed above event b.
     * See also {@link #horizontalEventSorterFn} for a description.
     * @param {Sch.model.Event} a
     * @param {Sch.model.Event} b
     * @return {Int}
     */
    verticalEventSorterFn: null,
    eventCls: 'sch-event',
    verticalViewClass: 'Sch.view.Vertical',
    eventStore: null,
    resourceStore: null,
    eventLayout: null,
    terminalSides: null,
    /**
     * @event eventrepaint
     * Fires after an event has been repainted by the view.
     * @param {Sch.mixin.AbstractSchedulerView} view The view instance
     * @param {Sch.model.Event} event
     * @param {HTMLElement} node The updated DOM representation of the event
     */
    _initializeSchedulerView: function() {
        var horLayoutCls = Ext.ClassManager.get(this.horizontalLayoutCls);
        var vertLayoutCls = Ext.ClassManager.get(this.verticalLayoutCls);
        this.eventSelector = '.' + this.eventCls;
        this.eventLayout = {};
        this.eventTpl = this.eventTpl || Ext.create(this.eventTemplateClass, {
            eventPrefix: this.eventPrefix,
            terminalSides: this.terminalSides,
            resizeHandles: this.eventResizeHandles
        });
        if (horLayoutCls) {
            this.eventLayout.horizontal = new horLayoutCls(Ext.apply(// this is required for table layout
            {
                timeAxisViewModel: this.timeAxisViewModel
            }, {
                bandIndexToPxConvertFn: this.horizontal.layoutEventVertically,
                bandIndexToPxConvertScope: this.horizontal
            }, this.horizontalEventSorterFn ? {
                sortEvents: this.horizontalEventSorterFn
            } : {}));
        }
        if (vertLayoutCls) {
            this.eventLayout.vertical = new vertLayoutCls(Ext.apply({
                view: this
            }, this.verticalEventSorterFn ? {
                sortEvents: this.verticalEventSorterFn
            } : {}));
        }
        this.store = this.store || this.resourceStore;
        this.resourceStore = this.resourceStore || this.store;
    },
    generateTplData: function(event, resourceRecord, columnIndex) {
        var renderData = this[this.mode].getEventRenderData(event, resourceRecord, columnIndex),
            start = event.getStartDate(),
            end = event.getEndDate(),
            internalCls = event.getCls() || '';
        internalCls += ' sch-event-resizable-' + event.getResizable();
        if (event.dirty)  {
            internalCls += ' sch-dirty ';
        }
        
        if (renderData.endsOutsideView)  {
            internalCls += ' sch-event-endsoutside ';
        }
        
        if (renderData.startsOutsideView)  {
            internalCls += ' sch-event-startsoutside ';
        }
        
        if (event.isDraggable() === false)  {
            internalCls += ' sch-event-fixed ';
        }
        
        if (end - start === 0)  {
            internalCls += ' sch-event-milestone ';
        }
        
        if (event.dirty)  {
            internalCls += ' sch-dirty ';
        }
        
        if (this.getEventSelectionModel().isSelected(event))  {
            internalCls += ' ' + this.selectedEventCls + ' ';
        }
        
        if (event.isRecurrableEvent) {
            if (event.isRecurring())  {
                internalCls += ' sch-event-recurring ';
            }
            
            if (event.isOccurrence())  {
                internalCls += ' sch-event-occurrence ';
            }
            
        }
        if (event.isHighlighted || (this.highlightDirtyEvents ? event.dirty : false)) {
            internalCls += ' ' + this.highlightedEventCls + ' ';
        }
        // in weekview mode event can be rendered in multiple columns yet it remains the same
        // to distinguish them we append column index to element id
        if (this.isWeekView()) {
            renderData.id = event.internalId + '-calendar-' + columnIndex + '-x';
        } else {
            renderData.id = event.internalId + '-' + resourceRecord.internalId + '-x';
        }
        /* this is important for getElement(s)FromEventRecord() */
        renderData.internalCls = internalCls;
        renderData.start = start;
        renderData.end = end;
        renderData.iconCls = event.data[this.eventBarIconClsField] || (event.getIconCls && event.getIconCls()) || '';
        renderData.event = event;
        if (this.eventRenderer) {
            // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate
            var value = this.eventRenderer.call(this.eventRendererScope || this, event, resourceRecord, renderData, columnIndex);
            if (this.eventBodyTemplate) {
                renderData.body = this.eventBodyTemplate.apply(value);
            } else {
                renderData.body = value;
            }
        } else if (this.eventBodyTemplate) {
            // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.
            renderData.body = this.eventBodyTemplate.apply(event.data);
        } else if (this.eventBarTextField) {
            // User has specified a field in the data model to read from
            renderData.body = Ext.htmlEncode(event.data[this.eventBarTextField]) || '';
        }
        return renderData;
    },
    /**
    * Resolves the resource based on a dom element
    * @param {HTMLElement} node The HTML element
    * @return {Sch.model.Resource} The resource corresponding to the element, or null if not found.
    */
    // TODO Doesn't make any sense for Sch.view.WeekView#resolveResource
    // This function should be moved to abstract level.
    resolveResource: function(node) {
        var me = this;
        return me[me.mode].resolveResource(node);
    },
    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        return this[this.mode].getResourceRegion(resourceRecord, startDate, endDate);
    },
    /**
    * <p>Returns the event record for a DOM element </p>
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Event|Null} The event record
    */
    resolveEventRecord: function(el) {
        // Normalize to DOM node
        el = el.dom ? el.dom : el;
        if (!(Ext.fly(el).is(this.eventSelector))) {
            el = Ext.fly(el).up(this.eventSelector);
        }
        return el && this.getEventRecordFromDomElement(el);
    },
    // TODO: Get rid of this, make it in inline?, move it to mixins/SchedulerView
    resolveEventRecordFromResourceRow: function(el) {
        var me = this,
            sm = me.getEventSelectionModel(),
            resource, event;
        el = el.dom ? el.dom : el;
        resource = me.getRecord(el);
        return sm.getFirstSelectedEventForResource(resource);
    },
    /**
    * Returns an assignment record for a DOM element
    *
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Assignment|Null} The assignment record
    */
    resolveAssignmentRecord: function(el) {
        var me = this,
            assignmentStore = me.getEventStore().getAssignmentStore(),
            assignment = null,
            event, resource;
        if (assignmentStore) {
            event = me.getEventRecordFromDomElement(el);
            resource = me.getResourceRecordFromDomElement(el);
            if (event && resource) {
                assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
            }
        }
        return assignment;
    },
    /**
     * Returns the event record for a DOM id
     * @param {String} id The id of the DOM node
     * @return {Sch.model.Event} The event record
     */
    getEventRecordFromDomId: function(id) {
        id = this.getEventIdFromDomNodeId(id);
        return this.getEventStore().getModelByInternalId(id);
    },
    /**
     * Returns the event record for a DOM element
     * @param {HTMLElement} el The DOM node
     * @return {Sch.model.Event} The event record
     */
    getEventRecordFromDomElement: function(el) {
        return this.getEventRecordFromDomId(el.id);
    },
    /**
     * Returns a resource record for a DOM id
     * @param {String} id An id of an event DOM node
     * @return {Sch.model.Resource} The resource record
     */
    getResourceRecordFromDomId: function(id) {
        id = this.getResourceIdFromDomNodeId(id);
        return this.getResourceStore().getByInternalId(id);
    },
    /**
     * Returns the resource record for a DOM element
     * @param {HTMLElement} el The DOM node
     * @return {Sch.model.Resource} The resource record
     */
    getResourceRecordFromDomElement: function(el) {
        return this.getResourceRecordFromDomId(el.id);
    },
    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function(start, end, excludeEvent, resource) {
        return this.getEventStore().isDateRangeAvailable(start, end, excludeEvent, resource);
    },
    /**
    * Returns events that are (partly or fully) inside the timespan of the current view.
    * @return {Ext.util.MixedCollection} The collection of events
    */
    getEventsInView: function() {
        var viewStart = this.timeAxis.getStart(),
            viewEnd = this.timeAxis.getEnd();
        return this.getEventStore().getEventsInTimeSpan(viewStart, viewEnd);
    },
    /**
    * Returns the current set of rendered event nodes
    * @return {Ext.CompositeElement} The collection of event nodes
    */
    getEventNodes: function() {
        return this.getEl().select(this.eventSelector);
    },
    /**
     * @private
     * @param {Sch.model.Range/Sch.model.Range[]} records Records to highlight
     * @param {Boolean} [highlight] Pass true to highlight events and false to unhighlight them
     */
    triggerHighlightEvents: function(records, highlight) {
        var me = this;
        var elements = [];
        Ext.Array.each([].concat(records), function(ev) {
            elements.push.apply(elements, me.getElementsFromEventRecord(ev, null, null, true));
        });
        var method = highlight !== false ? 'addCls' : 'removeCls';
        Ext.Array.each(records, function(record) {
            record.isHighlighted = highlight;
        });
        Ext.Array.each([].concat(elements), function(el) {
            Ext.fly(el)[method](me.highlightedEventCls);
        });
    },
    /**
     * Highlights one or more events in the current timeline view
     *
     * @param {Sch.model.Range/Sch.model.Range[]} records Event records to highlight
     */
    highlightEvents: function(records) {
        this.triggerHighlightEvents(records, true);
    },
    /**
     * Unhighlights one or more events in the current timeline view
     *
     * @param {Sch.model.Range/Sch.model.Range[]} records Event records to highlight
     */
    unhighlightEvents: function(records) {
        this.triggerHighlightEvents(records, false);
    },
    /**
     * Highlights events in the current timeline view that match the passed filter function
     *
     * @param {Function} fn Function to filter events to hightlight
     * @param {Object} scope Scope for filter function
     */
    highlightEventsBy: function(fn, scope) {
        var events = this.getEventsInView();
        this.highlightEvents(events.filterBy(fn, scope).getRange());
    },
    /**
     * Clears the highlight of all events
     */
    clearHighlightedEvents: function() {
        Ext.Array.each(this.getEventStore().getRange(), function(event) {
            event.isHighlighted = false;
        });
        this.getEl().select('.' + this.highlightedEventCls).removeCls(this.highlightedEventCls);
    },
    onEventCreated: function(newEventRecord, resources) {},
    // Empty but provided so that you can override it to supply default record values etc.
    getEventStore: function() {
        return this.eventStore;
    },
    registerEventEditor: function(editor) {
        var me = this;
        me.eventEditor = editor;
        // relay "beforeeventadd" event from the editor (while the dragcreate "beforeeventadd" is cancelled when using the editor plugin).
        me.mon(editor.editor || editor, {
            'beforeeventadd': function() {
                var newArgs = Ext.Array.toArray(arguments);
                // the 0th argument of the event has to be the scheduler view reference so we replace it
                Ext.Array.splice(newArgs, 0, 1, me);
                return me.fireEventArgs.call(me, 'beforeeventadd', newArgs);
            }
        });
    },
    getEventEditor: function() {
        return this.eventEditor;
    },
    // Call mode specific implementation
    onEventUpdate: function(store, model, operation) {
        this[this.mode].onEventUpdate(store, model, operation);
    },
    // Call mode specific implementation
    onEventAdd: function(s, recs) {
        // TreeStore 'insert' and 'append' events pass a single Model instance, not an array
        if (!Ext.isArray(recs))  {
            recs = [
                recs
            ];
        }
        
        this[this.mode].onEventAdd(s, recs);
    },
    // Call mode specific implementation
    onAssignmentAdd: function(store, assignments) {
        var me = this;
        Ext.Array.each(assignments, function(assignment) {
            var resource = assignment.getResource();
            resource && me.repaintEventsForResource(resource);
        });
    },
    onAssignmentUpdate: function(store, assignment) {
        var me = this,
            oldResourceId = assignment.previous && assignment.previous[assignment.resourceIdField],
            newResourceId = assignment.getResourceId(),
            oldResource, newResource;
        if (oldResourceId) {
            oldResource = me.getResourceStore().getModelById(oldResourceId);
            me.repaintEventsForResource(oldResource);
        }
        if (newResourceId) {
            newResource = me.getResourceStore().getModelById(newResourceId);
            me.repaintEventsForResource(newResource);
        }
    },
    onAssignmentRemove: function(store, assignments) {
        var me = this;
        Ext.Array.each(assignments, function(assignment) {
            var resourceId = assignment.getResourceId();
            var resource = resourceId && me.getResourceStore().getModelById(resourceId);
            resource && me.repaintEventsForResource(resource);
        });
    },
    // Call orientation specific implementation
    onEventRemove: function(s, recs) {
        this[this.mode].onEventRemove(s, recs);
    },
    setEventStore: function(eventStore, initial) {
        var me = this;
        var oldStore = me.getEventStore();
        var listenerCfg = {
                scope: me,
                refresh: me.onEventDataRefresh,
                // Sencha Touch
                addrecords: me.onEventAdd,
                updaterecord: me.onEventUpdate,
                removerecords: me.onEventRemove,
                // Ext JS
                update: me.onEventUpdate,
                // If the eventStore is a TreeStore
                nodeinsert: me.onEventAdd,
                nodeappend: me.onEventAdd
            };
        // If event store is a tree store (typically when used with Gantt) we should not react to 'remove' or 'add' which are UI events fired
        // when collapsing/expanding a parent node
        if (!(eventStore && eventStore.isTreeStore)) {
            listenerCfg.remove = me.onEventRemove;
            listenerCfg.add = me.onEventAdd;
        }
        // In case there is an assigment store used
        var assignmentListenerCfg = {
                scope: me,
                refresh: me.onEventDataRefresh,
                load: me.onEventDataRefresh,
                update: me.onAssignmentUpdate,
                add: me.onAssignmentAdd,
                remove: me.onAssignmentRemove
            };
        // Sencha Touch fires "refresh" when clearing the store. Avoid double repaints
        if (!Ext.versions.touch) {
            listenerCfg.clear = me.onEventDataRefresh;
        }
        if (!initial && me.eventStore) {
            // if we pass actual store, remove link to resource store from previous one
            // if null is passed, we should not remove this link
            if (eventStore) {
                me.eventStore.setResourceStore(null);
            }
            if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
                me.eventStore.destroy();
            } else {
                if (me.mun) {
                    me.mun(me.eventStore, listenerCfg);
                    var oldAssignmentStore = me.eventStore.getAssignmentStore();
                    if (oldAssignmentStore) {
                        me.mun(oldAssignmentStore, assignmentListenerCfg);
                    }
                } else {
                    me.eventStore.un(listenerCfg);
                }
            }
            if (!eventStore) {
                me.eventStore = null;
            }
        }
        if (eventStore) {
            eventStore = Ext.data.StoreManager.lookup(eventStore);
            if (me.mon) {
                me.mon(eventStore, listenerCfg);
            } else {
                eventStore.on(listenerCfg);
            }
            me.eventStore = eventStore;
            eventStore.setResourceStore(me.getResourceStore());
            var assignmentStore = eventStore.getAssignmentStore();
            if (assignmentStore) {
                me.mon(assignmentStore, assignmentListenerCfg);
            }
        }
        if (eventStore && !initial) {
            this.getTimeAxisViewModel().setEventStore(eventStore);
            this.getEventSelectionModel().bindStore(eventStore);
            this.fireEvent('eventstorechange', this, eventStore, oldStore);
            me.refreshView();
        }
    },
    onEventDataRefresh: function() {
        this.refreshKeepingScroll();
    },
    // invoked by the selection model to maintain visual UI cues
    onEventBarSelect: function(record) {
        var me = this,
            event, resource;
        if (record && record.isAssignmentModel) {
            event = record.getEvent();
            resource = record.getResource();
        } else {
            event = record;
            resource = null;
        }
        Ext.Array.each(me.getElementsFromEventRecord(event, resource, null, true), function(el) {
            Ext.fly(el).addCls(me.selectedEventCls);
        });
    },
    // invoked by the selection model to maintain visual UI cues
    onEventBarDeselect: function(record) {
        var me = this,
            event, resource;
        if (record && record.isAssignmentModel) {
            event = record.getEvent();
            resource = record.getResource();
        } else {
            event = record;
            resource = null;
        }
        event && Ext.Array.each(me.getElementsFromEventRecord(event, resource, null, true), function(el) {
            Ext.fly(el).removeCls(me.selectedEventCls);
        });
    },
    refresh: function() {
        throw 'Abstract method call';
    },
    /**
    * Refreshes the events for a single resource
    * @param {Sch.model.Resource} resource
    */
    repaintEventsForResource: function(record) {
        throw 'Abstract method call';
    },
    /**
     * Refreshes all events in the scheduler view
     */
    repaintAllEvents: function() {
        this.refreshKeepingScroll();
    },
    /**
     * Scrolls an event record into the viewport.
     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.
     *
     * @param {Sch.model.Event} eventRec, the event record to scroll into view
     * @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     *
     * This function is not applicable for events with multiple assignments, please use AbstractSchedulerView#scrollResourceEventIntoView instead.
     */
    scrollEventIntoView: function(eventRec, highlight, animate, callback, scope) {
        var me = this,
            resources = eventRec.getResources();
        if (resources.length > 1) {
            Ext.Error.raise("AbstractSchedulerView::scrollEventIntoView() is not applicable for events with multiple assignments, please use AbstractSchedulerView::scrollResourceEventIntoView() instead.");
        }
        resources.length && me.scrollResourceEventIntoView(resources[0], eventRec, null, highlight, animate, callback, scope);
    },
    getResourceStore: function() {
        return this.resourceStore;
    },
    setResourceStore: function(store) {
        var oldStore = this.resourceStore;
        this.resourceStore = store;
        if (store) {
            this.fireEvent('resourcestorechange', this, store, oldStore);
        }
    },
    // Called while rendering the TimeAxis cell in Horizontal mode,
    // and in SchedulerPanel#embedRowHeight to set cell heights in locked grid
    // Defaults to true always, but overrideable to enable having per-row event layout
    rowHasDynamicRowHeight: function(resource) {
        return this.dynamicRowHeight;
    }
});

/**
@class Sch.preset.ViewPreset
Not used directly, but the properties below are rather provided inline as seen in the source of {@link Sch.preset.Manager}. This class is just provided for documentation purposes.

A sample preset looks like:

    hourAndDay : {
        timeColumnWidth         : 60,       // Time column width (used for rowHeight in vertical mode)
        rowHeight               : 24,       // Only used in horizontal orientation
        resourceColumnWidth     : 100,      // Only used in vertical orientation

        displayDateFormat       : 'G:i',    // Controls how dates will be displayed in tooltips etc

        shiftIncrement          : 1,        // Controls how much time to skip when calling shiftNext and shiftPrevious.
        shiftUnit               : 'DAY',    // Valid values are 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'WEEK', 'MONTH', 'QUARTER', 'YEAR'.
        defaultSpan             : 12,       // By default, if no end date is supplied to a view it will show 12 hours

        timeResolution          : {         // Dates will be snapped to this resolution
            unit        : 'MINUTE',         // Valid values are 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'WEEK', 'MONTH', 'QUARTER', 'YEAR'.
            increment   : 15
        },

        headerConfig            : {         // This defines your header, you must include a 'middle' object, and top/bottom are optional.
            middle      : {                 // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'scope'
                unit        : 'HOUR',
                dateFormat  : 'G:i'
            },
            top         : {
                unit        : 'DAY',
                dateFormat  : 'D d/m'
            }
        },

        linesFor                : 'middle'  // Defines header level column lines will be drawn for
    }

See the {@link Sch.preset.Manager} for the list of available presets.

Vertical mode can have multiple columns (one for every level), and you can specify name in header config:

    headerConfig : {
        middle      : {
            unit        : 'HOUR',
            dateFormat  : 'G:i',
            text        : 'second column'
        },
        top         : {
            unit        : 'DAY',
            dateFormat  : 'D d/m',
            text        : 'first column'
        }
    }

## Duration units

There are a number of configs for duration units ({@link #shiftUnit} or `unit` in {@link #timeResolution}, {@link #headerConfig} configs).

When registering a preset using {@link Sch.preset.Manager#registerPreset} method the one can provide their values both using
{@link Sch.util.Date} unit name constant values ({@link Sch.util.Date.DAY}, {@link Sch.util.Date.WEEK} etc.) and using short constants names ('DAY', 'WEEK' etc.):

    Sch.preset.Manager.registerPreset('hour', {
        displayDateFormat : 'G:i',
        shiftIncrement    : 1,
        shiftUnit         : 'DAY',
        timeColumnWidth   : 150,
        timeResolution    : {
            // Here we use Sch.util.Date.MINUTE constant value
            unit      : Sch.util.Date.MINUTE,
            increment : 5
        },
        headerConfig      : {
            middle : {
                // and here we use the last fraction Sch.util.Date.HOUR constant name
                unit       : 'HOUR',
                dateFormat : 'G:i'
            },
            top    : {
                // and here we use the last fraction of Sch.util.Date.DAY constant name
                unit       : 'DAY',
                dateFormat : 'D d/m'
            }
        }
    });

But if the one deals with preset properties on the low level (without calling {@link Sch.preset.Manager#registerPreset} method)
he can use only constant values approach:

    // providing 'MINUTE' won't work, we should use Sch.util.Date.MINUTE constant
    Sch.preset.Manager.get('hour').timeResolution.unit = Sch.util.Date.MINUTE;

*/
Ext.define("Sch.preset.ViewPreset", {
    requires: [
        'Sch.util.Date'
    ],
    /**
     * @cfg {String} name The name of the preset by which it is registered in the Manager
     */
    name: null,
    /**
     * @cfg {Number} rowHeight The height of the row in horizontal orientation
     */
    rowHeight: 24,
    /**
     * @cfg {Number} timeColumnWidth The width of the time tick column in horizontal orientation. Also used as height of time tick row
     * in vertical orientation, unless {@link #timeRowHeight} is provided.
     */
    timeColumnWidth: 50,
    /**
     * @cfg {Number} timeRowHeight The height of the time tick row in vertical orientation. If omitted, a value of {@link #timeColumnWidth}
     * is used.
     */
    timeRowHeight: null,
    /**
     * @cfg {Number} timeAxisColumnWidth The width of the time axis column in the vertical orientation
     */
    timeAxisColumnWidth: null,
    /**
    * @cfg {String} displayDateFormat Defines how dates will be formatted in tooltips etc
    */
    displayDateFormat: 'G:i',
    /**
     * @cfg {String} shiftUnit The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.
     * Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
     */
    shiftUnit: "HOUR",
    /**
     * @cfg {Number} shiftIncrement The amount to shift (in shiftUnits)
     */
    shiftIncrement: 1,
    /**
     * @cfg {Number} defaultSpan The amount of time to show by default in a view (in the unit defined by the middle header)
     */
    defaultSpan: 12,
    /**
     * @cfg {Object} timeResolution An object containing a unit identifier and an increment variable. Example:
     *
        timeResolution : {
            unit        : "HOUR",  //Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 1
        }
     *
     */
    timeResolution: null,
    /**
     * @cfg {Object} headerConfig An object containing one or more {@link Sch.preset.ViewPresetHeaderRow} rows defining how your headers shall be composed.
     * Your 'main' unit should be the middle header unit. This object can contain "bottom", "middle" and "top" header definitions. The 'middle' header is mandatory.
     */
    headerConfig: null,
    /**
     * @cfg {String} columnLinesFor Defines the header level that the column lines will be drawn for. See {@link Sch.mixin.AbstractTimelinePanel#columnLines}
     */
    columnLinesFor: 'middle',
    // internal properties
    headers: null,
    mainHeader: 0,
    /**
     * @cfg {String} ptype The viewPreset to use and extend when the preset is passed as a config object.
     */
    ptype: '',
    constructor: function(cfg) {
        Ext.apply(this, cfg);
        this.normalizeUnits();
    },
    normalizeUnits: function() {
        var headerConfig = this.headerConfig;
        var DATE = Sch.util.Date;
        // Make sure date "unit" constant specified in the preset are resolved
        for (var o in headerConfig) {
            if (headerConfig.hasOwnProperty(o)) {
                if (DATE[headerConfig[o].unit]) {
                    headerConfig[o].unit = DATE[headerConfig[o].unit.toUpperCase()];
                }
                if (DATE[headerConfig[o].splitUnit]) {
                    headerConfig[o].splitUnit = DATE[headerConfig[o].splitUnit.toUpperCase()];
                }
            }
        }
        var timeResolution = this.timeResolution;
        // Resolve date units
        if (timeResolution && DATE[timeResolution.unit]) {
            timeResolution.unit = DATE[timeResolution.unit.toUpperCase()];
        }
        var shiftUnit = this.shiftUnit;
        // Resolve date units
        if (shiftUnit && DATE[shiftUnit]) {
            this.shiftUnit = DATE[shiftUnit.toUpperCase()];
        }
    },
    getHeaders: function() {
        if (this.headers)  {
            return this.headers;
        }
        
        var headerConfig = this.headerConfig;
        this.mainHeader = headerConfig.top ? 1 : 0;
        return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    getMainHeader: function() {
        return this.getHeaders()[this.mainHeader];
    },
    getBottomHeader: function() {
        var headers = this.getHeaders();
        return headers[headers.length - 1];
    },
    clone: function() {
        var config = {};
        var me = this;
        Ext.Array.each([
            'rowHeight',
            'timeColumnWidth',
            'timeRowHeight',
            'timeAxisColumnWidth',
            'displayDateFormat',
            'shiftUnit',
            'shiftIncrement',
            'defaultSpan',
            'timeResolution',
            'headerConfig'
        ], function(name) {
            config[name] = me[name];
        });
        return new this.self(Ext.clone(config));
    },
    isValid: function() {
        var D = Sch.util.Date,
            valid = true,
            validUnits = Sch.util.Date.units,
            ownKeys = {};
        // Make sure all date "unit" constants are valid
        for (var o in this.headerConfig) {
            if (this.headerConfig.hasOwnProperty(o)) {
                ownKeys[o] = true;
                valid = valid && Ext.Array.indexOf(validUnits, this.headerConfig[o].unit) >= 0;
            }
        }
        if (!(this.columnLinesFor in ownKeys)) {
            this.columnLinesFor = 'middle';
        }
        if (this.timeResolution) {
            valid = valid && Ext.Array.indexOf(validUnits, this.timeResolution.unit) >= 0;
        }
        if (this.shiftUnit) {
            valid = valid && Ext.Array.indexOf(validUnits, this.shiftUnit) >= 0;
        }
        return valid;
    }
});

/**
@class Sch.preset.Manager
@singleton

Provides a registry of the possible view presets that any instance of a Panel with {@link Sch.mixin.SchedulerPanel} mixin can use.

See the {@link Sch.preset.ViewPreset} and {@link Sch.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.

Available presets are:

- `secondAndMinute` - creates 2 level header - minute and seconds within it: {@img scheduler/images/secondAndMinute.png}
- `minuteAndHour` - creates 2 level header - hour and minutes within it: {@img scheduler/images/minuteAndHour.png}
- `hourAndDay` - creates 2 level header - day and hours within it: {@img scheduler/images/hourAndDay.png}
- `dayAndWeek` - creates 2 level header - week and days within it: {@img scheduler/images/dayAndWeek.png}
- `weekAndDay` - just like `dayAndWeek` but with different formatting: {@img scheduler/images/weekAndDay.png}
- `weekAndMonth` - creates 2 level header - month and weeks within it: {@img scheduler/images/weekAndMonth.png}

- `monthAndYear` - creates 2 level header - year and months within it: {@img scheduler/images/monthAndYear.png}
- `year` - creates 2 level header - year and quarters within it: {@img scheduler/images/year-preset.png}
- `manyYears` - creates 2 level header - 5-years and year within it: {@img scheduler/images/manyYears.png}
- `weekAndDayLetter` - creates 2 level header - with weeks and day letters within it: {@img scheduler/images/weekAndDayLetter.png}
- `weekDateAndMonth` - creates 2 level header - month and weeks within it (weeks shown by first day only): {@img scheduler/images/weekDateAndMonth.png}

You can register your own preset with the {@link #registerPreset} call or pass a preset configuration in the scheduler panel.

*/
Ext.define('Sch.preset.Manager', {
    extend: 'Ext.util.MixedCollection',
    requires: [
        'Sch.util.Date',
        'Sch.preset.ViewPreset'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    singleton: true,
    defaultPresets: {
        secondAndMinute: {
            timeColumnWidth: 30,
            // Time column width (used for rowHeight in vertical mode)
            rowHeight: 24,
            // Only used in horizontal orientation
            resourceColumnWidth: 100,
            // Only used in vertical orientation
            displayDateFormat: 'G:i:s',
            // Controls how dates will be displayed in tooltips etc
            shiftIncrement: 10,
            // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit: 'MINUTE',
            // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan: 24,
            // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution: {
                // Dates will be snapped to this resolution
                unit: 'SECOND',
                // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment: 5
            },
            headerConfig: {
                // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle: {
                    unit: 'SECOND',
                    increment: 10,
                    align: 'center',
                    dateFormat: 's'
                },
                top: {
                    unit: 'MINUTE',
                    align: 'center',
                    dateFormat: 'D, d g:iA'
                }
            }
        },
        minuteAndHour: {
            timeColumnWidth: 100,
            // Time column width (used for rowHeight in vertical mode)
            rowHeight: 24,
            // Only used in horizontal orientation
            resourceColumnWidth: 100,
            // Only used in vertical orientation
            displayDateFormat: 'G:i',
            // Controls how dates will be displayed in tooltips etc
            shiftIncrement: 1,
            // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit: 'HOUR',
            // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan: 24,
            // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution: {
                // Dates will be snapped to this resolution
                unit: 'MINUTE',
                // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment: 30
            },
            headerConfig: {
                // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle: {
                    unit: 'MINUTE',
                    increment: '30',
                    align: 'center',
                    dateFormat: 'i'
                },
                top: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'D, gA/d'
                }
            }
        },
        hourAndDay: {
            timeColumnWidth: 60,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'DAY',
            defaultSpan: 24,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            headerConfig: {
                middle: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'G:i'
                },
                top: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d/m'
                }
            }
        },
        dayAndWeek: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d G:i',
            shiftUnit: 'DAY',
            shiftIncrement: 1,
            defaultSpan: 5,
            timeResolution: {
                unit: 'HOUR',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d M'
                },
                top: {
                    unit: 'WEEK',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Sch.util.Date.getShortNameOfUnit('WEEK') + '.' + Ext.Date.format(start, 'W M Y');
                    }
                }
            }
        },
        weekAndDay: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: 'DAY',
                    align: 'center',
                    increment: 1,
                    dateFormat: 'd/m'
                },
                middle: {
                    unit: 'WEEK',
                    dateFormat: 'D d M'
                }
            }
        },
        weekAndMonth: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 5,
            defaultSpan: 6,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Ext.Date.format(start, 'd M');
                    }
                },
                top: {
                    unit: 'MONTH',
                    align: 'center',
                    dateFormat: 'M Y'
                }
            }
        },
        monthAndYear: {
            timeColumnWidth: 110,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftIncrement: 3,
            shiftUnit: 'MONTH',
            defaultSpan: 12,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'MONTH',
                    align: 'center',
                    dateFormat: 'M Y'
                },
                top: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y'
                }
            }
        },
        year: {
            timeColumnWidth: 100,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'YEAR',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'MONTH',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'QUARTER',
                    align: 'center',
                    renderer: function(start, end, cfg) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit('QUARTER').toUpperCase() + '{0}', Math.floor(start.getMonth() / 3) + 1);
                    }
                },
                top: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y'
                }
            }
        },
        manyYears: {
            timeColumnWidth: 50,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'YEAR',
            shiftIncrement: 1,
            defaultSpan: 1,
            timeResolution: {
                unit: 'YEAR',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'Y',
                    increment: 5
                },
                // smallest zoom level looked back
                // we have to specify increments here since 'increment' in zoomLevel affects only bottom header
                bottom: {
                    unit: 'YEAR',
                    align: 'center',
                    dateFormat: 'y',
                    increment: 1
                }
            }
        },
        weekAndDayLetter: {
            timeColumnWidth: 20,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                bottom: {
                    unit: 'DAY',
                    align: 'center',
                    renderer: function(start) {
                        return Ext.Date.dayNames[start.getDay()].substring(0, 1);
                    },
                    verticalColumnWidth: 25
                },
                middle: {
                    unit: 'WEEK',
                    dateFormat: 'D d M Y',
                    verticalColumnWidth: 115
                }
            }
        },
        weekDateAndMonth: {
            timeColumnWidth: 30,
            rowHeight: 24,
            resourceColumnWidth: 100,
            displayDateFormat: 'Y-m-d',
            shiftUnit: 'WEEK',
            shiftIncrement: 1,
            defaultSpan: 10,
            timeResolution: {
                unit: 'DAY',
                increment: 1
            },
            headerConfig: {
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    dateFormat: 'd'
                },
                top: {
                    unit: 'MONTH',
                    dateFormat: 'Y F'
                }
            }
        },
        minute: {
            timeRowHeight: 40,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'WEEK',
            defaultSpan: 60,
            timeResolution: {
                unit: 'MINUTE',
                increment: 15
            },
            columnLinesFor: 'bottom',
            headerConfig: {
                bottom: {
                    unit: 'MINUTE',
                    increment: 15,
                    align: 'center',
                    renderer: function(value) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct">' + '<span class="sch-calendarcolumn-hours">{0}</span>' + '<span class="sch-calendarcolumn-minutes {2}">{1}</span>' + '</div>', value.getMinutes() ? '' : Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'), value.getMinutes() ? 'sch-calendarcolumn-minutes-non-zero' : '');
                    }
                },
                middle: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d',
                    splitUnit: 'DAY'
                }
            }
        },
        day: {
            timeRowHeight: 40,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'DAY',
            defaultSpan: 1,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            columnLinesFor: 'bottom',
            headerConfig: {
                bottom: {
                    unit: 'HOUR',
                    align: 'center',
                    renderer: function(value) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span>' + '<span class="sch-calendarcolumn-minutes">{1}</span></div>', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
                    }
                },
                middle: {
                    unit: 'DAY',
                    align: 'center',
                    dateFormat: 'D d/m',
                    splitUnit: 'DAY'
                }
            }
        },
        week: {
            timeRowHeight: 40,
            displayDateFormat: 'G:i',
            shiftIncrement: 1,
            shiftUnit: 'WEEK',
            defaultSpan: 24,
            timeResolution: {
                unit: 'MINUTE',
                increment: 30
            },
            columnLinesFor: 'bottom',
            headerConfig: {
                bottom: {
                    unit: 'HOUR',
                    align: 'center',
                    dateFormat: 'H:i',
                    // will be overridden by renderer
                    renderer: function(value) {
                        return Ext.String.format('<div class="sch-calendarcolumn-ct">' + '<span class="sch-calendarcolumn-hours">{0}</span>' + '<span class="sch-calendarcolumn-minutes">{1}</span>' + '</div>', Ext.Date.format(value, 'H'), Ext.Date.format(value, 'i'));
                    }
                },
                middle: {
                    unit: 'WEEK',
                    align: 'center',
                    dateFormat: 'D d',
                    splitUnit: 'DAY'
                }
            }
        }
    },
    constructor: function() {
        this.callParent(arguments);
        this.registerDefaults();
    },
    onLocalized: function() {
        var me = this;
        this.eachKey(function(name, preset) {
            if (me.l10n[name]) {
                var locale = me.L(name);
                locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
                locale.middleDateFormat && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
                locale.topDateFormat && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
                locale.bottomDateFormat && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
            }
        });
    },
    /**
    * Registers a new view preset to be used by any scheduler grid or tree on the page.
    * @param {String} name The unique name identifying this preset
    * @param {Object} config The configuration properties of the view preset (see {@link Sch.preset.ViewPreset} for more information)
    */
    registerPreset: function(name, cfg) {
        cfg.name = name;
        var preset = new Sch.preset.ViewPreset(cfg);
        if (preset.isValid()) {
            if (this.containsKey(name))  {
                this.removeAtKey(name);
            }
            
            this.add(name, preset);
        } else {
            throw 'Invalid preset, please check your configuration';
        }
    },
    /**
    * Fetches a view preset from the global cache
    * @param {String} name The name of the preset
    * @return {Object} The view preset, see {@link Sch.preset.ViewPreset} for more information
    */
    getPreset: function(name) {
        return this.get(name);
    },
    /**
    * Deletes a view preset
    * @param {String} name The name of the preset
    */
    deletePreset: function(name) {
        this.removeAtKey(name);
    },
    registerDefaults: function() {
        var pm = this,
            vp = this.defaultPresets;
        for (var p in vp) {
            pm.registerPreset(p, vp[p]);
        }
    }
});

/**
 @class Sch.view.model.TimeAxis
 @extends Ext.util.Observable
 @private

 This class is an internal view model class, describing the visual representation of a {@link Sch.data.TimeAxis timeaxis}.
 The config for the header rows is described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
 To calculate the widths of each cell in the time axis, this class requires:

 - availableWidth  - The total width available for the rendering
 - tickWidth     - The fixed width of each cell in the lowest header row. This value is normally read from the
 {@link Sch.preset.ViewPreset viewPreset} but this can also be updated programmatically using {@link #setTickWidth}

 Normally you should not interact with this class directly.

 */
Ext.define("Sch.view.model.TimeAxis", {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.Date',
        'Sch.util.Date',
        'Sch.preset.Manager'
    ],
    /**
     * @cfg {Sch.data.TimeAxis} timeAxis
     * The time axis providing the underlying data to be visualized
     */
    timeAxis: null,
    /**
     * @cfg {Number} availableWidth
     * The available width, this is normally not known by the consuming UI component using this model class until it has been fully rendered.
     * The consumer of this model should call {@link #setAvailableWidth} when its width has changed.
     */
    availableWidth: 0,
    /**
     * @cfg {Number} tickWidth
     * The "tick width" to use for the cells in the bottom most header row.
     * This value is normally read from the {@link Sch.preset.ViewPreset viewPreset}
     */
    tickWidth: 100,
    /**
     * @cfg {Boolean} snapToIncrement
     * true if there is a requirement to be able to snap events to a certain view resolution.
     * This has implications of the {@link #tickWidth} that can be used, since all widths must be in even pixels.
     */
    snapToIncrement: false,
    /**
     * @cfg {Boolean} forceFit
     * true if cells in the bottom-most row should be fitted to the {@link #availableWidth available width}.
     */
    forceFit: false,
    headerConfig: null,
    // cached linear version of `headerConfig` - array of levels, starting from top
    headers: null,
    mainHeader: 0,
    calendar: null,
    // the width of time axis column in vertical
    timeAxisColumnWidth: null,
    // the width of resource column in vertical
    resourceColumnWidth: null,
    // width of the columns in week view
    weekViewColumnWidth: null,
    // array of columns start/end dates, because timeaxis may be filtered
    calendarColumnDates: null,
    headersDatesCache: null,
    // aka tickWidth in horizontal
    timeColumnWidth: null,
    rowHeightHorizontal: null,
    rowHeightVertical: null,
    mode: 'horizontal',
    // or 'vertical', or 'week'
    //used for Exporting. Make sure the tick columns are not recalculated when resizing.
    suppressFit: false,
    // Since this model may be shared by multiple synced timelinePanels, we need to keep count of usage to know when we can destroy the view model.
    refCount: 0,
    // cache of the config currently used.
    columnConfig: {},
    // the view preset name to apply initially
    viewPreset: null,
    // The default header level to draw column lines for
    columnLinesFor: 'middle',
    eventStore: null,
    originalTickWidth: null,
    constructor: function(config) {
        var me = this;
        Ext.apply(this, config);
        me.headersDatesCache = {};
        if (this.viewPreset) {
            if (this.viewPreset instanceof Sch.preset.ViewPreset) {
                this.consumeViewPreset(this.viewPreset);
            } else {
                var preset = Sch.preset.Manager.getPreset(this.viewPreset);
                preset && this.consumeViewPreset(preset);
            }
        }
        /**
         * @event update
         * Fires after the model has been updated.
         * @param {Sch.view.model.TimeAxis} model The model instance
         */
        // When time axis is changed, reconfigure the model
        me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);
        this.callParent(arguments);
    },
    isHorizontal: function() {
        return this.mode === 'horizontal';
    },
    isVertical: function() {
        return this.mode === 'vertical';
    },
    isWeek: function() {
        return this.mode === 'weekview';
    },
    hasTimeZone: function() {
        return this.timeAxis.hasTimeZone();
    },
    toTimeZone: function(date) {
        return this.timeAxis.toTimeZone(date);
    },
    destroy: function() {
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    },
    onTimeAxisReconfigure: function(timeAxis, suppressRefresh) {
        if (!suppressRefresh) {
            this.update();
        }
    },
    reconfigure: function(config) {
        // clear the cached headers
        this.headers = null;
        Ext.apply(this, config);
        var value;
        if (this.isHorizontal()) {
            value = this.timeColumnWidth;
        } else {
            value = this.rowHeightVertical;
        }
        this.setTickWidth(value);
        this.fireEvent('reconfigure', this);
    },
    /**
     *  Returns a model object of the current timeAxis, containing an array representing the cells for each level in the header.
     *  This object will always contain a 'middle' array, and depending on the {@link Sch.preset.ViewPreset#headerConfig} it can also contain a 'top' and 'bottom' property.
     *  @return {Object} The model representing each cell (with start date and end date) in the timeline representation.
     */
    getColumnConfig: function() {
        return this.columnConfig;
    },
    /**
     *  Updates the view model current timeAxis configuration and available width.
     *  @param {Number} [availableWidth] The available width for the rendering of the axis (used in forceFit mode)
     */
    update: function(availableWidth, suppressEvent) {
        var timeAxis = this.timeAxis,
            headerConfig = this.headerConfig;
        this.availableWidth = Math.max(availableWidth || this.availableWidth, 0);
        if (!Ext.isNumber(this.availableWidth)) {
            throw new Error('Invalid available width provided to Sch.view.model.TimeAxis');
        }
        if (this.forceFit && this.availableWidth <= 0) {
            // No point in continuing
            return;
        }
        this.columnConfig = {};
        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
        for (var pos in headerConfig) {
            if (headerConfig[pos].cellGenerator) {
                this.columnConfig[pos] = headerConfig[pos].cellGenerator.call(this, timeAxis.getStart(), timeAxis.getEnd());
            } else {
                this.columnConfig[pos] = this.createHeaderRow(pos, headerConfig[pos]);
            }
        }
        // The "column width" is considered to be the width of each tick in the lowest header row and this width
        // has to be same for all cells in the lowest row.
        var tickWidth = this.calculateTickWidth(this.originalTickWidth);
        if (!Ext.isNumber(tickWidth) || tickWidth <= 0) {
            throw new Error('Invalid column width calculated in Sch.view.model.TimeAxis');
        }
        this.updateTickWidth(tickWidth);
        if (!suppressEvent)  {
            this.fireEvent('update', this);
        }
        
    },
    /**
     * Will update columns start/end dates to perform date/coordinate lookups
     * @param {Object[]} columns Array of column configs including start/end dates
     * @private
     */
    updateCalendarColumnDates: function(columns) {
        this.calendarColumnDates = [];
        for (var i = 0; i < columns.length; i++) {
            var obj = columns[i];
            this.calendarColumnDates.push([
                obj.start,
                obj.end
            ]);
        }
    },
    /**
     * Returns current column start/end dates array
     * @returns {Date[][]}
     * @private
     */
    getCalendarColumnDates: function() {
        return this.calendarColumnDates;
    },
    // private
    createHeaderRow: function(position, headerConfig) {
        var cells = [],
            me = this,
            align = headerConfig.align,
            today = Ext.Date.clearTime(new Date()),
            calendar = this.calendar;
        if (calendar) {
            var clsField = calendar.model.getField(calendar.model.prototype.clsField),
                defaultDayCls = clsField.getDefaultValue().trim();
        }
        me.headersDatesCache[position] = {};
        me.forEachInterval(position, function(start, end, i) {
            var colConfig = {
                    align: align,
                    start: start,
                    end: end,
                    headerCls: ''
                };
            // Convert start/end dates for display purposes
            if (me.hasTimeZone() && !this.timeAxis.isUTCTimeZone()) {
                start = this.toTimeZone(start);
                end = this.toTimeZone(end);
            }
            me.headersDatesCache[position][start.getTime()] = 1;
            if (headerConfig.renderer) {
                colConfig.header = headerConfig.renderer.call(headerConfig.scope || me, start, end, colConfig, i, me.eventStore);
            } else {
                if (this.timeAxis.isUTCTimeZone()) {
                    colConfig.header = Sch.util.Date.format(start, headerConfig.dateFormat, this.timeAxis.timeZone);
                } else {
                    colConfig.header = Ext.Date.format(start, headerConfig.dateFormat);
                }
            }
            // To be able to style individual day cells, weekends or other important days
            if (headerConfig.unit === Sch.util.Date.DAY && (!headerConfig.increment || headerConfig.increment === 1)) {
                colConfig.headerCls += ' sch-dayheadercell-' + start.getDay();
                if (calendar) {
                    if (!calendar.isWorkingDay(start)) {
                        colConfig.headerCls += ' sch-dayheadercell-nonworking';
                    }
                    var calendarDay = calendar.getCalendarDay(start),
                        dayCls = calendarDay.getCls().trim();
                    // historically default value equals to 'sch-nonworkingtime' or 'gnt-holiday', so need to add only manually specified classes, otherwise all days will be marked as non working time
                    if (dayCls != defaultDayCls) {
                        colConfig.headerCls += ' ' + dayCls;
                    }
                }
                if (Ext.Date.clearTime(start, true) - today === 0) {
                    colConfig.headerCls += ' sch-dayheadercell-today';
                }
            }
            cells.push(colConfig);
        });
        return cells;
    },
    /**
     *  Returns the distance for a timespan with the given start and end date.
     *  Returns 0 if one of the start/end dates are filtered out of the timeaxis.
     *  @return {Number} The width of the time span
     */
    getDistanceBetweenDates: function(start, end) {
        return Math.round(this.getPositionFromDate(end, true) - this.getPositionFromDate(start));
    },
    /**
     *  Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
     *  @param {Date} date, the date to query for.
     *  @param {Boolean} [isEnd] true to return bottom coordinate for calendar view
     *  @returns {Number} the coordinate representing the date
     */
    getPositionFromDate: function(date, isEnd) {
        var result = -1;
        if (this.isWeek()) {
            var rowHeight = this.rowHeightVertical;
            var headers = this.getHeaders();
            var startDate = this.timeAxis.getStart();
            var UD = Sch.util.Date;
            // weekview inherits vertical view so this method should only return vertical coordinate
            var verticalDate = UD.copyTimeValues(Ext.Date.clone(startDate), date);
            result = UD.getDurationInUnit(startDate, verticalDate, headers[1].unit, true) / (headers[1].increment || 1) * rowHeight;
            if (result === 0 && isEnd) {
                result = this.calendarRowsAmount * rowHeight;
            }
        } else {
            var tick = this.timeAxis.getTickFromDate(date);
            var tickWidth = this.getTickWidth();
            if (this.hasTimeZone() && this.timeAxis.isTickLengthVarying()) {
                // First and last ticks have different scale from other ticks because they have different width and duration
                // For a scheduler with days preset and tick width 40 and timezone UTC+12 lookups should look like this (tick -> position):
                // 0    -> 0
                // 0.25 -> 5
                // 0.5  -> 10
                // 0.75 -> 15
                // 1    -> 20 // first tick has width 20
                // 1.25 -> 30
                // 1.5  -> 40
                // 1.75 -> 50
                // 2    -> 60 // second tick has full width
                var nbrTicks = this.timeAxis.getCount(),
                    firstTickWidth = tickWidth * (1 - this.timeAxis.timezoneTickStart),
                    lastTickWidth = tickWidth * (1 - nbrTicks + this.timeAxis.timezoneTickEnd);
                if (tick <= 1) {
                    result = tick * firstTickWidth;
                } else if (tick === nbrTicks) {
                    result = this.getTotalWidth();
                } else if (tick > nbrTicks - 1) {
                    result = firstTickWidth + (Math.floor(tick) - 1) * tickWidth + (tick % 1) * lastTickWidth;
                } else {
                    result = firstTickWidth + (tick - 1) * tickWidth;
                }
            } else {
                if (tick >= 0) {
                    result = this.getTickWidth() * (tick - this.timeAxis.visibleTickStart);
                }
            }
        }
        return Math.round(result);
    },
    /**
     * Gets the date for a position on the time axis
     * @param {Number} position The page X or Y coordinate
     * @param {String} [roundingMethod] The rounding method to use
     * @returns {Date} the Date corresponding to the xy coordinate
     */
    getDateFromPosition: function(position, roundingMethod) {
        if (this.isWeek()) {
            var columns = this.getCalendarColumnDates();
            if (!columns) {
                return null;
            }
            // Last column width may differ in 1px, so we need to constrain columnIndex by array length
            var columnIndex = Math.min(Math.floor(Math.max(position[0], 0) / this.weekViewColumnWidth), columns.length - 1),
                horizontalDate = columns[columnIndex][0],
                first = this.timeAxis.first(),
                millisecondsPerPixel = (first.get('end') - first.get('start')) / this.rowHeightVertical,
                UD = Sch.util.Date,
                result = UD.add(horizontalDate, UD.MILLI, Math.round(position[1] * millisecondsPerPixel));
            if (roundingMethod) {
                result = this.timeAxis[roundingMethod + 'Date'](result);
            }
            return result;
        } else {
            var tick;
            var tickWidth = this.getTickWidth();
            var nbrTicks = this.timeAxis.getCount();
            // With time zone time axis ticks may have different size, which makes position <-> tick relation non-linear
            // e.g. if first tick is 20px, which is a half size of the normal tick, this is how lookups would work:
            // position -> tick
            // 0 -> 0
            // 10 -> 0.5
            // 20 -> 1
            // 30 -> 1.25
            // 40 -> 1.5
            // 50 -> 1.75
            // 60 -> 2
            // Same applies to the end.
            if (this.hasTimeZone() && this.timeAxis.isTickLengthVarying()) {
                var firstTickWidth = tickWidth * (1 - this.timeAxis.timezoneTickStart),
                    lastTickWidth = tickWidth * (1 - nbrTicks + this.timeAxis.timezoneTickEnd),
                    middleTicksWidth = this.getTotalWidth() - firstTickWidth - lastTickWidth;
                if (position < firstTickWidth) {
                    tick = position / firstTickWidth;
                } else if (position - firstTickWidth >= middleTicksWidth) {
                    tick = nbrTicks - 1 + (position - firstTickWidth - middleTicksWidth) / lastTickWidth;
                } else {
                    tick = (position - firstTickWidth) / tickWidth + 1;
                }
            } else {
                tick = position / tickWidth + this.timeAxis.visibleTickStart;
            }
            if (tick < 0 || tick > nbrTicks) {
                return null;
            }
            return this.timeAxis.getDateFromTick(tick, roundingMethod);
        }
    },
    /**
     * Returns the amount of pixels for a single unit
     * @private
     * @return {Number} The unit in pixel
     */
    getSingleUnitInPixels: function(unit) {
        return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), unit) * this.getTickWidth() / this.timeAxis.increment;
    },
    /**
     * [Experimental] Returns the pixel increment for the current view resolution.
     * @return {Number} The width increment
     */
    getSnapPixelAmount: function() {
        if (this.snapToIncrement) {
            var resolution = this.timeAxis.getResolution();
            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
        } else {
            return 1;
        }
    },
    /**
     * Returns the current time column width (the width of a cell in the lowest header row)
     * @return {Number} The width
     */
    getTickWidth: function() {
        return this.tickWidth;
    },
    /**
     * Sets a new tick width (the width of a time cell in the bottom-most time axis row)
     * @param {Number} width The width
     */
    setTickWidth: function(width, suppressEvent) {
        this.originalTickWidth = width;
        this.updateTickWidth(width);
        this.update(null, suppressEvent);
    },
    updateTickWidth: function(value) {
        this.tickWidth = value;
        this[this.isHorizontal() ? 'timeColumnWidth' : 'rowHeightVertical'] = value;
    },
    /**
     * Returns the total width of the time axis representation.
     * @return {Number} The width
     */
    getTotalWidth: function() {
        return Math.round(this.getTickWidth() * this.timeAxis.getVisibleTickTimeSpan());
    },
    // Calculates the time column width based on the value defined viewPreset "timeColumnWidth". It also checks for the forceFit view option
    // and the snapToIncrement, both of which impose constraints on the time column width configuration.
    calculateTickWidth: function(proposedWidth) {
        var forceFit = this.forceFit;
        var timeAxis = this.timeAxis;
        var width = 0,
            timelineUnit = timeAxis.getUnit(),
            ratio = Number.MAX_VALUE,
            DATE = Sch.util.Date;
        if (this.snapToIncrement) {
            var resolution = timeAxis.getResolution();
            ratio = DATE.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
        } else {
            var measuringUnit = DATE.getMeasuringUnit(timelineUnit);
            ratio = Math.min(ratio, DATE.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
        }
        if (!this.suppressFit) {
            var ticks = this.isWeek() ? timeAxis.endTime - timeAxis.startTime : timeAxis.getVisibleTickTimeSpan(),
                fittingWidth = Math[forceFit ? 'floor' : 'round'](this.getAvailableWidth() / ticks);
            width = (forceFit || proposedWidth < fittingWidth) ? fittingWidth : proposedWidth;
            if (ratio > 0 && (!forceFit || ratio < 1)) {
                // For touch, make sure we always fill the available space with forceFit (to not show edges of side-time-pickers)
                var method = Ext.versions.touch && forceFit ? 'ceil' : (forceFit ? 'floor' : 'round');
                width = Math.round(Math.max(1, Math[method](ratio * width)) / ratio);
            }
        } else {
            width = proposedWidth;
        }
        return width;
    },
    /**
     * Returns the available width for the time axis representation.
     * @return {Number} The available width
     */
    getAvailableWidth: function() {
        return this.availableWidth;
    },
    /**
     * Sets the available width for the model, which (if changed) will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Number} width The width
     */
    setAvailableWidth: function(width) {
        var oldAvailableWidth = this.availableWidth;
        this.availableWidth = Math.max(0, width);
        var newTickWidth = this.calculateTickWidth(this.originalTickWidth);
        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't
        // occupy the available space - and gets stretched
        var doUpdate = newTickWidth > 0 && ((oldAvailableWidth !== width && this.forceFit) || newTickWidth !== this.getTickWidth());
        if (doUpdate) {
            this.update();
        }
    },
    /**
     * This function fits the time columns into the available space in the time axis column.
     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
     */
    fitToAvailableWidth: function(suppressEvent) {
        var proposedWidth = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());
        this.setTickWidth(proposedWidth, suppressEvent);
    },
    /**
     * Sets the forceFit value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Boolean} value
     */
    setForceFit: function(value) {
        if (value !== this.forceFit) {
            this.forceFit = value;
            this.update();
        }
    },
    /**
     * Sets the snapToIncrement value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
     * @param {Boolean} value
     */
    setSnapToIncrement: function(value) {
        if (value !== this.snapToIncrement) {
            this.snapToIncrement = value;
            this.update();
        }
    },
    getViewRowHeight: function() {
        var val = this.isHorizontal() ? this.rowHeightHorizontal : this.rowHeightVertical;
        // Sanity check
        if (!val)  {
            throw new Error('rowHeight info not available');
        }
        
        return val;
    },
    setViewRowHeight: function(value, suppressEvent) {
        var property = 'rowHeight' + Ext.String.capitalize(this.mode);
        if (this[property] != value) {
            this[property] = value;
            if (this.isHorizontal()) {
                if (!suppressEvent)  {
                    this.fireEvent('update', this);
                }
                
            } else {
                this.setTickWidth(value, suppressEvent);
            }
        }
    },
    setViewColumnWidth: function(value, suppressEvent) {
        if (this.isHorizontal()) {
            this.setTickWidth(value, suppressEvent);
        } else if (this.isVertical()) {
            this.resourceColumnWidth = value;
        } else if (this.isWeek()) {
            this.weekViewColumnWidth = value;
        }
        if (!suppressEvent) {
            this.fireEvent('columnwidthchange', this, value);
        }
    },
    getHeaders: function() {
        if (this.headers)  {
            return this.headers;
        }
        
        var headerConfig = this.headerConfig;
        // main header is always `middle` (which is always requires to present in `headerConfig`)
        // `top` may absent, in this case `middle` will be on 0-th index
        this.mainHeader = headerConfig.top ? 1 : 0;
        return this.headers = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    getMainHeader: function() {
        return this.getHeaders()[this.mainHeader];
    },
    getBottomHeader: function() {
        var headers = this.getHeaders();
        return headers[headers.length - 1];
    },
    getLowestHeader: function() {
        return 'bottom' in this.headerConfig ? 'bottom' : 'middle';
    },
    /**
     * This method is meant to return name of the header which 2nd lowest. It is used for {@link #isMajorTick} method
     * @return {String/null}
     * @private
     */
    getMajorHeaderName: function() {
        var headerConfig = this.headerConfig;
        // If there's a bottom header - return middle one as it's required
        if (headerConfig.bottom) {
            return 'middle';
        }
        // if there is a top header - return that, because middle is required and we do not have bottom for sure
        if (headerConfig.top) {
            return 'top';
        }
        return null;
    },
    /**
     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the
     * upper header level.
     * @param {Date} date
     * @return {Boolean}
     * @private
     */
    isMajorTick: function(date) {
        var nextLevel = this.getMajorHeaderName();
        if (this.hasTimeZone() && !this.timeAxis.isUTCTimeZone()) {
            date = Sch.util.Date.toTimeZone(date, this.timeAxis.timeZone);
        }
        // if forceFit is used headersDatesCache won´t have been generated yet on the first call here,
        // since no width is set yet
        return nextLevel && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @param {String} position 'main' (middle), 'top' or 'bottom'
     * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachInterval: function(position, iteratorFn, scope) {
        scope = scope || this;
        var headerConfig = this.headerConfig;
        if (!headerConfig)  {
            return;
        }
        
        // Not initialized
        if (position === 'top' || (position === 'middle' && headerConfig.bottom)) {
            var header = headerConfig[position];
            this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, scope);
        } else {
            // This is the lowest header row, which should be fed the data in the tickStore
            this.timeAxis.each(function(r, index) {
                return iteratorFn.call(scope, r.data.start, r.data.end, index);
            });
        }
    },
    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * Return false to break the iteration.
     * @protected
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachMainInterval: function(iteratorFn, scope) {
        this.forEachInterval('middle', iteratorFn, scope);
    },
    consumeViewPreset: function(preset) {
        // clear the cached headers
        this.headers = null;
        Ext.apply(this, {
            headerConfig: preset.headerConfig,
            columnLinesFor: preset.columnLinesFor || 'middle',
            rowHeightHorizontal: preset.rowHeight,
            tickWidth: this.isHorizontal() ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeColumnWidth: preset.timeColumnWidth,
            // timeColumnWidth is also used for row height in vertical mode
            rowHeightVertical: preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeAxisColumnWidth: preset.timeAxisColumnWidth,
            resourceColumnWidth: preset.resourceColumnWidth || 100
        });
        this.originalTickWidth = this.getTickWidth();
    },
    setEventStore: function(store) {
        this.eventStore = store;
    },
    setCalendar: function(cal) {
        if (cal !== this.calendar) {
            this.calendar = cal;
            if (cal) {
                this.update();
            }
        }
    }
});

/**
@class Sch.mixin.Zoomable

A mixin for {@link Sch.mixin.TimelinePanel} class, providing "zooming" functionality to the consuming panel.

The zooming feature works by reconfiguring panel's time axis with the current zoom level values selected from the {@link #zoomLevels} array.
Zoom levels can be added and removed from the array to change the amount of available steps. Range of zooming in/out can be also
modified with {@link #maxZoomLevel} / {@link #minZoomLevel} properties.

This mixin adds additional methods to the timeline panel : {@link #setMaxZoomLevel}, {@link #setMinZoomLevel}, {@link #zoomToLevel}, {@link #zoomIn},
{@link #zoomOut}, {@link #zoomInFull}, {@link #zoomOutFull}.

* **Notice**: Zooming is only supported for `horizontal` {@link Sch.mixin.AbstractTimelinePanel#mode}. Zooming doesn't work properly when `forceFit` option is set to true for the panel or for filtered timeaxis.
*/
Ext.define('Sch.mixin.Zoomable', {
    /**
     * @cfg {Boolean} zoomOnMouseWheel If true, you can zoom in and out on the the time axis using CTRL-key + mouse wheel.
     */
    zoomOnMouseWheel: true,
    preventScrollZoom: false,
    /**
     * @cfg {Array} [zoomLevels=[]] Predefined map of zoom levels for each preset in the ascending order. Zoom level is basically a {@link Sch.preset.ViewPreset view preset},
     * which is based on another preset, with some values overriden.
     *
     * Each element is an {Object} with the following parameters :
     *
     * - `preset` (String)      - {@link Sch.preset.ViewPreset} to be used for this zoom level. This must be a valid preset name registered in {@link Sch.preset.Manager preset manager}.
     * - `width` (Int)          - {@link Sch.preset.ViewPreset#timeColumnWidth timeColumnWidth} time column width value from the preset
     * - `increment` (Int)      - {@link Sch.preset.ViewPresetHeaderRow#increment increment} value from the bottom header row of the preset
     * - `resolution` (Int)     - {@link Sch.preset.ViewPreset#timeResolution increment} part of the `timeResolution` object in the preset
     * - `resolutionUnit` (String) (Optional) - {@link Sch.preset.ViewPreset#timeResolution unit} part of the `timeResolution` object in the preset
     *
     *
     *  The `zoomLevels` config can be set in the scheduler like this:
     *

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            resourceStore : resourceStore,
            eventStore    : eventStore,
            viewPreset    : 'hourAndDay',
            zoomLevels: [
                { width: 50,    increment: 4,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 60,    increment: 3,   resolution: 60, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 80,    increment: 2,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
                { width: 100,   increment: 1,   resolution: 15, preset: 'hourAndDay', resolutionUnit: 'MINUTE' }
            ]
        });

     * In the case above:
     *
     * - The `width` specifies the amount of space in pixels for the bottom cell.
     * - The `increment` specifies the number of hours between each bottom cell.
     * - The `resolution` specifies the size of the slots in the bottom cell accordingly to the defined `resolutionUnit`.
     *
     *  In the case above we have four zoomlevel steps within the `hourAndDay` preset. When zooming in we go up in the zoomlevel array, when zooming out we go down in the zoomlevel array.
     *  In this case the zoomlevel with `increment` set to 1 and `width` set to 100 is the most detailed level, the max level. While the first item in the array is the minimal zoomlevel.
     *  In a higher zoomlevel the `resolution` can be set lower to make the granularity of the cell smaller. That means smaller slots for the events to fit in.
     */
    zoomLevels: [
        //YEAR
        {
            width: 40,
            increment: 1,
            resolution: 1,
            preset: 'manyYears',
            resolutionUnit: 'YEAR'
        },
        {
            width: 80,
            increment: 1,
            resolution: 1,
            preset: 'manyYears',
            resolutionUnit: 'YEAR'
        },
        {
            width: 30,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 100,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        {
            width: 200,
            increment: 1,
            resolution: 1,
            preset: 'year',
            resolutionUnit: 'MONTH'
        },
        //MONTH
        {
            width: 100,
            increment: 1,
            resolution: 7,
            preset: 'monthAndYear',
            resolutionUnit: 'DAY'
        },
        {
            width: 30,
            increment: 1,
            resolution: 1,
            preset: 'weekDateAndMonth',
            resolutionUnit: 'DAY'
        },
        //WEEK
        {
            width: 35,
            increment: 1,
            resolution: 1,
            preset: 'weekAndMonth',
            resolutionUnit: 'DAY'
        },
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'weekAndMonth',
            resolutionUnit: 'DAY'
        },
        {
            width: 20,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDayLetter'
        },
        //DAY
        {
            width: 50,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDay',
            resolutionUnit: 'HOUR'
        },
        {
            width: 100,
            increment: 1,
            resolution: 1,
            preset: 'weekAndDay',
            resolutionUnit: 'HOUR'
        },
        //HOUR
        {
            width: 50,
            increment: 6,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 100,
            increment: 6,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 60,
            increment: 2,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        {
            width: 60,
            increment: 1,
            resolution: 30,
            preset: 'hourAndDay',
            resolutionUnit: 'MINUTE'
        },
        //MINUTE
        {
            width: 30,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 60,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 130,
            increment: 15,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 60,
            increment: 5,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 100,
            increment: 5,
            resolution: 5,
            preset: 'minuteAndHour'
        },
        {
            width: 50,
            increment: 2,
            resolution: 1,
            preset: 'minuteAndHour'
        },
        //SECOND
        {
            width: 30,
            increment: 10,
            resolution: 5,
            preset: 'secondAndMinute'
        },
        {
            width: 60,
            increment: 10,
            resolution: 5,
            preset: 'secondAndMinute'
        },
        {
            width: 130,
            increment: 5,
            resolution: 5,
            preset: 'secondAndMinute'
        }
    ],
    /**
     * @cfg {Number} minZoomLevel Minimal zoom level to which {@link #zoomOut} will work.
     */
    minZoomLevel: null,
    /**
     * @cfg {Number} maxZoomLevel Maximal zoom level to which {@link #zoomIn} will work.
     */
    maxZoomLevel: null,
    /**
     * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
     * wider than the timeline area itself. Used in {@link #zoomToSpan} and {@link #zoomToLevel} functions.
     */
    visibleZoomFactor: 5,
    /**
     * @cfg {Boolean} zoomKeepsOriginalTimespan Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
     * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
     * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
     * to be rendered and affect performance. You can use {@link #minZoomLevel} and {@link #maxZoomLevel} config options for that.
     */
    zoomKeepsOriginalTimespan: false,
    initializeZooming: function() {
        //create instance-specific copy of zoomLevels
        this.zoomLevels = this.zoomLevels.slice();
        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);
        this.on('viewready', this.onTimelineReady, this);
    },
    getZoomLevelUnit: function(zoomLevel) {
        return Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
    },
    /*
     * @private
     * Returns number of milliseconds per pixel.
     * @param {Object} level Element from array of {@link #zoomLevels}.
     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.
     * Otherwise density will be calculated for actual tick width.
     * @return {Number} Return number of milliseconds per pixel.
     */
    getMilliSecondsPerPixelForZoomLevel: function(level, ignoreActualWidth) {
        var DATE = Sch.util.Date;
        // trying to convert the unit + increment to a number of milliseconds
        // this number is not fixed (month can be 28, 30 or 31 day), but at least this convertion
        // will be consistent (should be no DST changes at year 1)
        return Math.round((DATE.add(new Date(1, 0, 1), this.getZoomLevelUnit(level), level.increment) - new Date(1, 0, 1)) / (// `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)
        // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`
        ignoreActualWidth ? level.width : level.actualWidth || level.width));
    },
    presetToZoomLevel: function(presetName) {
        var preset = Sch.preset.Manager.getPreset(presetName);
        return {
            preset: presetName,
            increment: preset.getBottomHeader().increment || 1,
            resolution: preset.timeResolution.increment,
            resolutionUnit: preset.timeResolution.unit,
            width: preset.timeColumnWidth
        };
    },
    calculateCurrentZoomLevel: function() {
        var zoomLevel = this.presetToZoomLevel(this.viewPreset),
            min = Number.MAX_VALUE,
            viewModel = this.timeAxisViewModel,
            actualWidth = viewModel.timeColumnWidth;
        zoomLevel.width = actualWidth;
        zoomLevel.increment = viewModel.getBottomHeader().increment || 1;
        // when calculating current zoom level we should use tick width from defined zoomLevels
        // otherwise levels might be skipped
        for (var i = 0,
            l = this.zoomLevels.length; i < l; i++) {
            var curentLevel = this.zoomLevels[i];
            // search for a zoom level having the same preset...
            if (curentLevel.preset !== zoomLevel.preset)  {
                
                continue;
            }
            
            // and the most close column width to the actual one
            var delta = Math.abs(curentLevel.width - actualWidth);
            if (delta < min) {
                min = delta;
                zoomLevel.actualWidth = curentLevel.actualWidth;
                zoomLevel.width = curentLevel.width;
            }
        }
        return zoomLevel;
    },
    getCurrentZoomLevelIndex: function() {
        var currentZoomLevel = this.calculateCurrentZoomLevel();
        var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
        var zoomLevels = this.zoomLevels;
        for (var i = 0; i < zoomLevels.length; i++) {
            var zoomLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i]);
            if (zoomLevelFactor == currentFactor)  {
                return i;
            }
            
            // current zoom level is outside of pre-defined zoom levels
            if (i === 0 && currentFactor > zoomLevelFactor)  {
                return -0.5;
            }
            
            if (i == zoomLevels.length - 1 && currentFactor < zoomLevelFactor)  {
                return zoomLevels.length - 1 + 0.5;
            }
            
            var nextLevelFactor = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[i + 1]);
            if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor)  {
                return i + 0.5;
            }
            
        }
        throw new Error("Can't find current zoom level index");
    },
    /**
    * Sets the {@link #maxZoomLevel} value.
    * @param {Number} level The level to limit zooming in to.
    */
    setMaxZoomLevel: function(level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }
        this.maxZoomLevel = level;
    },
    /**
    * Sets the {@link #minZoomLevel} value.
    * @param {Number} level The level to limit zooming out to.
    */
    setMinZoomLevel: function(level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }
        this.minZoomLevel = level;
    },
    /**
     * Allows zooming to certain level of {@link #zoomLevels} array. Automatically limits zooming between {@link #maxZoomLevel}
     * and {@link #minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Number} level Level to zoom to.
     * @param {Object} span The time frame. Used to set time axis timespan to the supplied start and end dates. If provided, the view
     * will be centered in this time interval
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @param {Object} [options] Object, containing options for this method
     * @param {Number} options.customWidth Lowest tick width. Might be increased automatically
     * @param {Date} options.scrollTo Date that should be scrolled to
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToLevel: function(level, span, options) {
        level = Ext.Number.constrain(level, this.minZoomLevel, this.maxZoomLevel);
        options = options || {};
        var currentZoomLevel = this.calculateCurrentZoomLevel();
        var currentFactor = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);
        var nextZoomLevel = this.zoomLevels[level];
        var nextFactor = this.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);
        if (this.getMode() !== 'horizontal' || (currentFactor == nextFactor && !span)) {
            // already at requested zoom level
            return null;
        }
        var me = this;
        // this event is used to prevent sync suspend during zooming
        me.fireEvent('beforezoomchange', me, level);
        var view = this.getSchedulingView();
        if (!this.rendered) {
            this.on('afterlayout', Ext.Function.bind(this.zoomToLevel, this, [
                level,
                span,
                options
            ]), null, {
                single: true
            });
            return;
        }
        var viewEl = view.getOuterEl();
        var isVertical = this.isVertical();
        var centerDate = options.centerDate || (span ? new Date((span.start.getTime() + span.end.getTime()) / 2) : this.getViewportCenterDateCached());
        var panelSize = isVertical ? view.getViewContainerHeight() : viewEl.getWidth();
        var presetCopy = Sch.preset.Manager.getPreset(nextZoomLevel.preset).clone();
        // clone doesn't copy the preset name
        presetCopy.name = nextZoomLevel.preset;
        var bottomHeader = presetCopy.getBottomHeader();
        span = this.calculateOptimalDateRange(centerDate, panelSize, nextZoomLevel, span);
        presetCopy[isVertical ? 'timeRowHeight' : 'timeColumnWidth'] = options.customWidth || nextZoomLevel.width;
        bottomHeader.increment = nextZoomLevel.increment;
        this.isZooming = true;
        presetCopy.increment = nextZoomLevel.increment;
        presetCopy.timeResolution.unit = Sch.util.Date.getUnitByName(nextZoomLevel.resolutionUnit || presetCopy.timeResolution.unit || bottomHeader.unit);
        presetCopy.timeResolution.increment = nextZoomLevel.resolution;
        this.setViewPreset(presetCopy, span.start || this.getStart(), span.end || this.getEnd(), false, {
            centerDate: centerDate
        });
        // after switching the view preset the `width` config of the zoom level may change, because of adjustments
        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method
        // will return the exact level index after zooming
        nextZoomLevel.actualWidth = this.timeAxisViewModel.getTickWidth();
        me.isZooming = false;
        /**
         * @event zoomchange
         *
         * Fires after zoom level has been changed
         *
         * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline object
         * @param {Number} level The index of the new zoom level
         */
        me.fireEvent('zoomchange', me, level);
        return level;
    },
    /*
     * Alias for {@link #zoomToLevel}
     */
    setZoomLevel: function() {
        this.zoomToLevel.apply(this, arguments);
    },
    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     *
     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis
     * will be extended in the same way as {@link #zoomToLevel} method does, to allow scrolling for user.
     *
     * @param {Object} span The time frame.
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     * @param {Object} options An object with options for the zoom operation
     * @param {Number} options.leftMargin The margin (in px) at the left side.
     * @param {Number} options.rightMargin The margin (in px) at the right side.
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToSpan: function(span, config) {
        var view = this.getSchedulingView();
        config = config || {};
        if (config.leftMargin || config.rightMargin) {
            config.adjustStart = 0;
            config.adjustEnd = 0;
        }
        Ext.applyIf(config, {
            leftMargin: 0,
            rightMargin: 0
        });
        if (!this.rendered) {
            this.on('afterlayout', Ext.Function.bind(this.zoomToSpan, this, [
                span,
                config
            ]), null, {
                single: true
            });
            return;
        }
        if (span.start && span.end) {
            var start = span.start,
                end = span.end,
                // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt
                needToAdjust = config.adjustStart >= 0 && config.adjustEnd >= 0;
            if (needToAdjust) {
                start = Sch.util.Date.add(start, this.timeAxis.mainUnit, -config.adjustStart);
                end = Sch.util.Date.add(end, this.timeAxis.mainUnit, config.adjustEnd);
            }
            if (start <= end) {
                // get scheduling view width
                var availableWidth = view.getTimeAxisViewModel().getAvailableWidth();
                // if potential width of col is less than col width provided by zoom level
                //   - we'll zoom out panel until col width fit into width from zoom level
                // and if width of column is more than width from zoom level
                //   - we'll zoom in until col width fit won't fit into width from zoom level
                var currLevel = Math.floor(this.getCurrentZoomLevelIndex());
                // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
                if (currLevel == -1)  {
                    currLevel = 0;
                }
                
                var zoomLevels = this.zoomLevels;
                var diffMS = end - start || 1,
                    msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[currLevel], true),
                    // increment to get next zoom level:
                    // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,
                    // so that more content will "fit" into 1 px
                    //
                    // +1 mean that given timespan will already fit into available width in the current zoom level, but,
                    // perhaps if we'll zoom in a bit more, the fitting will be better
                    inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableWidth ? -1 : 1,
                    candidateLevel = currLevel + inc;
                var zoomLevel,
                    levelToZoom = null;
                // loop over zoom levels
                while (candidateLevel >= 0 && candidateLevel <= zoomLevels.length - 1) {
                    // get zoom level
                    zoomLevel = zoomLevels[candidateLevel];
                    msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
                    var spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;
                    // if zooming out
                    if (inc == -1) {
                        // if columns fit into available space, then all is fine, we've found appropriate zoom level
                        if (spanWidth <= availableWidth) {
                            levelToZoom = candidateLevel;
                            // stop searching
                            break;
                        }
                    } else // if zooming in
                    {
                        // if columns still fits into available space, we need to remember the candidate zoom level as a potential
                        // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit
                        // into available view
                        if (spanWidth <= availableWidth) {
                            // if it's not currently active level
                            if (currLevel !== candidateLevel - inc) {
                                // remember this level as applicable
                                levelToZoom = candidateLevel;
                            }
                        } else {
                            // Sanity check to find the following case:
                            // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
                            // there is an edge case where we should actually just stop and use the currently selected zoomLevel
                            break;
                        }
                    }
                    candidateLevel += inc;
                }
                // If we didn't find a large/small enough zoom level, use the lowest/highest level
                levelToZoom = levelToZoom !== null ? levelToZoom : candidateLevel - inc;
                zoomLevel = zoomLevels[levelToZoom];
                var unitToZoom = Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
                if (config.leftMargin || config.rightMargin) {
                    // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly
                    start = new Date(start.getTime() - msPerPixel * config.leftMargin);
                    end = new Date(end.getTime() + msPerPixel * config.rightMargin);
                }
                var columnCount = Sch.util.Date.getDurationInUnit(start, end, unitToZoom, true) / zoomLevel.increment;
                if (columnCount === 0) {
                    return;
                }
                var customWidth = Math.floor(availableWidth / columnCount);
                var centerDate = new Date((start.getTime() + end.getTime()) / 2);
                var range;
                if (needToAdjust) {
                    range = {
                        start: start,
                        end: end
                    };
                } else {
                    range = this.calculateOptimalDateRange(centerDate, availableWidth, zoomLevel);
                }
                return this.zoomToLevel(levelToZoom, range, {
                    customWidth: customWidth,
                    centerDate: centerDate
                });
            }
        }
        return null;
    },
    /**
    * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom in
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomIn: function(levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels = levels || 1;
        var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
        if (currentZoomLevelIndex >= this.zoomLevels.length - 1)  {
            return null;
        }
        
        return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    },
    /**
    * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom out
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOut: function(levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels = levels || 1;
        var currentZoomLevelIndex = this.getCurrentZoomLevelIndex();
        if (currentZoomLevelIndex <= 0)  {
            return null;
        }
        
        return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    },
    /**
    * Zooms in the timeline to the {@link #maxZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomInFull: function() {
        return this.zoomToLevel(this.maxZoomLevel);
    },
    /**
    * Zooms out the timeline to the {@link #minZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOutFull: function() {
        return this.zoomToLevel(this.minZoomLevel);
    },
    /*
    * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,
    * as rendering too many columns takes noticeable amount of time so their number is limited.
    */
    calculateOptimalDateRange: function(centerDate, panelSize, zoomLevel, userProvidedSpan) {
        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming
        // (even in case when user has provided own interval)
        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing
        // (inifinte scrolling feature does)
        if (userProvidedSpan)  {
            return userProvidedSpan;
        }
        
        var timeAxis = this.timeAxis;
        if (this.zoomKeepsOriginalTimespan) {
            return {
                start: timeAxis.getStart(),
                end: timeAxis.getEnd()
            };
        }
        var schDate = Sch.util.Date;
        var unit = this.getZoomLevelUnit(zoomLevel);
        var difference = Math.ceil(panelSize / zoomLevel.width * zoomLevel.increment * this.visibleZoomFactor / 2);
        var startDate = schDate.add(centerDate, unit, -difference);
        var endDate = schDate.add(centerDate, unit, difference);
        startDate = timeAxis.floorDate(startDate, false, unit, zoomLevel.increment);
        endDate = timeAxis.ceilDate(endDate, false, unit, zoomLevel.increment);
        if (timeAxis.hasTimeZone()) {
            // Pick better dates with correction for timezone
            startDate = timeAxis.fromTimeZone(startDate);
            endDate = timeAxis.fromTimeZone(endDate);
        }
        return {
            start: startDate,
            end: endDate
        };
    },
    onTimelineReady: function() {
        if (this.zoomOnMouseWheel) {
            this.getSchedulingView().getEl().on('wheel', this.onWheel, this, {
                capture: true
            });
            this.on('destroy', function() {
                clearTimeout(this.scrollWheelBlockTimeout);
            });
        }
    },
    onWheel: function(e) {
        var me = this;
        if (e.ctrlKey) {
            e.preventDefault();
            if (!me.preventScrollZoom) {
                if (e.browserEvent.deltaY > 0) {
                    me.zoomOut();
                } else if (e.browserEvent.deltaY < 0) {
                    me.zoomIn();
                }
                me.preventScrollZoom = true;
                me.scrollWheelBlockTimeout = setTimeout(function() {
                    me.preventScrollZoom = false;
                }, 30);
            }
        }
    }
});

/**

@class Sch.mixin.AbstractTimelinePanel
@private

A base mixin giving the consuming panel "time line" functionality.
This means that the panel will be capable to display a list of "events", along a {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define('Sch.mixin.AbstractTimelinePanel', {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.model.TimeAxis',
        'Sch.feature.ColumnLines',
        'Sch.preset.Manager'
    ],
    mixins: [
        'Sch.mixin.Zoomable'
    ],
    /**
     * @cfg {String} mode An initial mode of the view - can be either `weekview`, `horizontal` or `vertical`.
     * Default value is `horizontal`.
     *
     *
     * Options: ['weekview', 'horizontal', 'vertical']
     */
    /**
     * @cfg {Number} weekStartDay A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.
     * When omitted, the week start day is retrieved from the active locale class.
     */
    /**
     * @cfg {Boolean} snapToIncrement true to snap to resolution increment while interacting with scheduled events.
     */
    snapToIncrement: false,
    /**
     * @cfg {Boolean} readOnly true to disable editing.
     */
    readOnly: false,
    /**
     * @cfg {Boolean} forceFit Set to true to force the time columns to fit to the available horizontal space.
     */
    forceFit: false,
    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use for resizing events. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'both'
     */
    eventResizeHandles: 'both',
    /**
     * @cfg {Number} rowHeight The row height (used in horizontal mode only)
     */
    /**
     * @cfg {Sch.data.TimeAxis} timeAxis The backing store providing the input date data for the timeline panel.
     */
    timeAxis: null,
    /**
     * @cfg {Boolean} autoAdjustTimeAxis The value for the {@link Sch.data.TimeAxis#autoAdjust} config option, which will be used
     * when creating the time axis instance. You can set this option to `false` to make the timeline panel start and end on the exact provided
     * {@link #startDate}/{@link #endDate} w/o adjusting them.
     */
    autoAdjustTimeAxis: true,
    /**
     * @private
     * @cfg {Sch.view.model.TimeAxis/Object} timeAxisViewModel The backing view model for the visual representation of the time axis.
     * Either a real instance or a simple config object.
     */
    timeAxisViewModel: null,
    /**
     * @cfg {Object} validatorFnScope
     * The scope used for the different validator functions.
     */
    /**
     * @cfg {Sch.crud.AbstractManager} crudManager The CRUD manager holding all the project stores.
     */
    crudManager: null,
    /**
     * @cfg {String/Object} viewPreset
     * A string key used to lookup a predefined {@link Sch.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),
     * managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     * Or a config object for a viewPreset.
     *
     * Options: ['secondAndMinute', 'minuteAndHour', 'hourAndDay', 'dayAndWeek', 'weekAndDay', 'weekAndMonth',
     * 'monthAndYear', 'year', 'manyYears', 'weekAndDayLetter', 'weekDateAndMonth', 'day', 'week']
     *
     * If passed as a config object, the settings from the viewPreset with the provided 'name' property will be used along
     * with any overridden values in your object.
     *
     * To override:

    viewPreset       : {
        name                : 'hourAndDay',
        headerConfig        : {
            middle          : {
                unit       : "HOUR",
                increment  : 12,
                renderer   : function(startDate, endDate, headerConfig, cellIdx) {
                    return "";
                }
            }
        }
    }

     * or set a new valid preset config if the preset is not registered in the {@link Sch.preset.Manager}.
     *
     * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not
     * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.
     */
    viewPreset: 'weekAndDay',
    /**
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver: true,
    /**
     * @cfg {Date} startDate The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided {@link Sch.data.TimeAxis} will be used.
     * If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no date information exists in the event data
     * set, it defaults to the current date and time.
     */
    startDate: null,
    /**
     * @cfg {Date} endDate The end date of the timeline. If omitted, it will be calculated based on the {@link #startDate} setting and
     * the 'defaultSpan' property of the current {@link #viewPreset}.
     */
    endDate: null,
    /**
     * @cfg {Number} startTime Start time for weekview mode, used only with day/week presets.
     */
    startTime: 0,
    /**
     * @cfg {Number} endTime End time for weekview mode, used only with day/week presets.
     */
    endTime: 24,
    /**
     * @cfg {Number} timeZone Shows timeline for a specified timezone, where timezone is a difference in **minutes**
     * between UTC and the configured time zone. Examples:
     *
     * ```
     * 120  : +2 hours from UTC
     * 0    : UTC
     * -180 : -3 hours from UTC
     * ```
     *
     * Default value `null` means current system timezone is used.
     *
     * This setting will update the timeline header and tooltips will show dates in the specified timezone.
     * Events data remain intact.
     *
     * For instance, if you are in UTC+04:00 and you want to render UTC+0 timeline
     * with event starting on 00:00 you should set start date correctly:
     *
     * 1. In local timezone: `new Date(2020, 8, 1, 4)` // matches 00:00 in UTC+0
     * 2. Using Date API: `new Date("2020-09-01T00:00Z")` // same time
     *
     *
     * **NOTE**: DST transitions are not supported, this config only specifies time zone offset from UTC. If value is
     * 0, UTC time zone is used. UTC time zone has no DST.
     */
    timeZone: null,
    columnLines: true,
    /**
     * Returns dates that will constrain resize and drag operations. The method will be called with the Resource, and
     * for operations on existing events - the event. For drag create operation, the mousedown date will be passed as the second parameter
     * @return {Object} Constaining object
     * @return {Date} return.start Start date
     * @return {Date} return.end End date
     */
    getDateConstraints: Ext.emptyFn,
    /**
     * @cfg {Boolean} snapRelativeToEventStartDate Affects drag drop and resizing of events when {@link #snapToIncrement} is enabled. If set to `true`, dates will be snapped relative to event start.
     * e.g. for a zoom level with timeResolution = { unit: "s", increment: "20" }, an event that starts at 10:00:03 and is dragged would snap its start date to 10:00:23, 10:00:43 etc.
     * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start) - 10:00:03, 10:00:20, 10:00:40 etc.
     */
    snapRelativeToEventStartDate: false,
    trackMouseOver: false,
    // If user supplied a 'rowHeight' config or a panel subclass with such a value - skip reading this setting
    // from the viewpreset
    readRowHeightFromPreset: true,
    /**
     * @cfg {Number} eventBorderWidth
     * The width of the border of your event, needed to calculate the correct start/end positions
     */
    eventBorderWidth: 1,
    cachedCenterDate: null,
    /**
     * @event beforeviewchange
     * @preventable
     * Fires before the current view changes to a new view type or a new time span. Return false to abort this action.
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     * @param {Sch.preset.ViewPreset} preset The new preset
     */
    /**
     * @event viewchange
     * Fires after current view preset or time span has changed
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     */
    cellBorderWidth: 1,
    // ---row---------------------
    // |  cellTopBorderWidth       // 0
    // |    | barMargin            // 0
    // |    | eventBorderWidth     // 1
    // |    |   | event |          // rowHeight - 2 * barMargin - eventBorderWidth
    // |    | barMargin            // These lines equal to 1 rowHeight value
    // |        | barMargin
    // |        | eventBorderWidth
    // |        |   | event |
    // |        | barMargin
    // |    cellBottomBorderWidth  // 0
    // ---EOF row
    cellTopBorderWidth: 0,
    cellBottomBorderWidth: 0,
    renderers: null,
    /**
    * Returns the mode of this panel, 'horizontal', 'vertical' or 'weekview'
    * @return {String}
    */
    getMode: function() {
        return this.mode;
    },
    isHorizontal: function() {
        return this.getMode() === 'horizontal';
    },
    isVertical: function() {
        return this.getMode() === 'vertical';
    },
    isWeekView: function() {
        return this.getMode() === 'weekview';
    },
    // Must be called during initialization by consuming class
    _initializeTimelinePanel: function() {
        // this is an entry point to this mixin, so we should wrap 'mode' here
        if (this.mode) {
            // Calendar was renamed to weekview, silently fallback to 'weekview' if user passes 'calendar' as a mode
            // #3345
            if (this.mode === 'calendar') {
                this.mode = 'weekview';
            }
        } else {
            this.mode = 'horizontal';
        }
        this.applyViewPreset(this.viewPreset);
        if (this.isWeekView()) {
            // Split unit is a sign that passed view preset can be used for weekview mode, if passed preset cannot
            // be used - we fall back to default 'week' #3345
            if (!this.viewPreset.headerConfig.middle.splitUnit) {
                this._oldViewPresetArgs = [
                    this.viewPreset
                ];
                this.viewPreset = this.calendarViewPreset || 'week';
            }
        }
        this.initializeZooming();
        this.on('viewchange', this.clearCenterDateCache, this);
        this.on('viewready', this.setupClearCenterDateCache, this);
        this.renderers = [];
        // Setting a rowHeight config on the panel should override any rowHeight value in the view presets
        if (this.readRowHeightFromPreset) {
            this.readRowHeightFromPreset = !this.rowHeight;
        }
        if (!(this.timeAxis instanceof Sch.data.TimeAxis)) {
            this.timeAxis = Ext.create(Ext.applyIf(this.timeAxis || {}, {
                xclass: 'Sch.data.TimeAxis',
                autoAdjust: this.autoAdjustTimeAxis,
                mode: this.isWeekView() ? 'week' : 'plain'
            }));
        }
        if (!(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            this.timeAxisViewModel = Ext.create(Ext.applyIf(this.timeAxisViewModel || {}, {
                xclass: 'Sch.view.model.TimeAxis',
                mode: this.mode,
                snapToIncrement: this.snapToIncrement,
                forceFit: this.forceFit,
                timeAxis: this.timeAxis,
                eventStore: this.getEventStore(),
                viewPreset: this.viewPreset
            }));
        }
        if (this.rowHeight) {
            this.setRowHeight(this.rowHeight, true);
            this.rowHeight = null;
        }
        this.timeAxisViewModel.on('update', this.onTimeAxisViewModelUpdate, this);
        this.timeAxisViewModel.refCount++;
        this.on('destroy', this.onPanelDestroyed, this);
        var orientationClasses;
        if (this.isHorizontal()) {
            orientationClasses = [
                'sch-horizontal'
            ];
        } else if (this.isVertical()) {
            orientationClasses = [
                'sch-vertical',
                'sch-vertical-resource'
            ];
        } else if (this.isWeekView()) {
            orientationClasses = [
                'sch-vertical',
                'sch-calendar'
            ];
        }
        this.addCls([].concat.apply([
            'sch-timelinepanel'
        ], orientationClasses));
    },
    // private
    // applies preset config on the manager, only used at initialization time
    applyViewPreset: function(preset) {
        var viewPreset;
        if (Ext.isString(preset)) {
            viewPreset = Sch.preset.Manager.getPreset(preset);
            if (!viewPreset) {
                throw 'You must define a valid view preset object. See Sch.preset.Manager class for reference';
            }
        } else if (Ext.isObject(preset)) {
            var registeredPreset = preset.name && Sch.preset.Manager.getPreset(preset.name);
            if (registeredPreset) {
                viewPreset = new Sch.preset.ViewPreset(Ext.applyIf(preset, registeredPreset));
            } else {
                var name = preset.name || ('preset' + Sch.preset.Manager.getCount());
                Sch.preset.Manager.registerPreset(name, preset);
                viewPreset = Sch.preset.Manager.getPreset(name);
            }
        }
        this.viewPreset = viewPreset;
    },
    onTimeAxisViewModelUpdate: function() {
        var view = this.getSchedulingView();
        if (view && view.viewReady) {
            view.refreshKeepingScroll();
        }
        this.fireEvent('viewchange', this);
    },
    onPanelDestroyed: function() {
        var timeAxisViewModel = this.timeAxisViewModel;
        timeAxisViewModel.un('update', this.onTimeAxisViewModelUpdate, this);
        timeAxisViewModel.refCount--;
        if (timeAxisViewModel.refCount <= 0) {
            timeAxisViewModel.destroy();
        }
    },
    /**
     * @abstract
     *
     * @return {Sch.mixin.AbstractSchedulerView} A view consuming the {@link Sch.mixin.AbstractSchedulerView} mixin
     */
    getSchedulingView: function() {
        throw 'Abstract method call';
    },
    /**
     * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
     */
    setReadOnly: function(readOnly) {
        var me = this;
        me.getSchedulingView().setReadOnly(readOnly);
        if (me.allDayNormalHeader) {
            me.allDayNormalHeader.setReadOnly(readOnly);
        }
    },
    /**
    * Returns true if the panel is currently read only.
    * @return {Boolean} readOnly
    */
    isReadOnly: function() {
        return this.getSchedulingView().isReadOnly();
    },
    setupClearCenterDateCache: function() {
        this.mon(this.getSchedulingView().getScrollable(), 'scroll', this.clearCenterDateCache, this);
    },
    // When switching to a preset we try to stay on the same central date.
    // The date is cleared after any user scroll operation
    /** @ignore */
    getViewportCenterDateCached: function() {
        if (this.cachedCenterDate)  {
            return this.cachedCenterDate;
        }
        
        return this.cachedCenterDate = this.getViewportCenterDate();
    },
    clearCenterDateCache: function(scrollable, left, top) {
        var isHorizontal = this.isHorizontal(),
            activeScroll = this.viewPresetActiveScroll;
        var scrollToIgnore = activeScroll && (isHorizontal ? left === activeScroll.left : top == activeScroll.top);
        if (!scrollToIgnore) {
            this.cachedCenterDate = null;
            this.viewPresetActiveScroll = null;
        }
    },
    /**
     * Alias for {@link setViewPreset}
     */
    switchViewPreset: function() {
        this.setViewPreset.apply(this, arguments);
    },
    /**
     * Sets the current view preset. See the {@link Sch.preset.Manager} class for details.
     * Calling it will first fire a {@link Sch.panel.SchedulerGrid#beforeviewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#beforeviewchange SchedulerTree} beforeviewchange event,
     * followed by a {@link Sch.panel.SchedulerGrid#viewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#viewchange SchedulerTree} viewchange event.
     * Returning `false` from any 'beforeviewchange' listener will cancel the operation.
     *
     * @param {String} preset The id of the new preset (see {@link Sch.preset.Manager} for details)
     * @param {Date} [startDate] A new start date for the time axis
     * @param {Date} [endDate] A new end date for the time axis
     */
    setViewPreset: function(preset, startDate, endDate, initial, options) {
        options = options || {};
        var centerDate = options.centerDate,
            timeAxis = this.timeAxis,
            view = this.getSchedulingView();
        // normalize preset
        if (typeof preset === 'string') {
            preset = Sch.preset.Manager.getPreset(preset);
        }
        if (!preset) {
            throw new Error('View preset not found');
        }
        if (this.fireEvent('beforeviewchange', this, preset, startDate, endDate) !== false) {
            this.viewPreset = preset.name;
            var isHorizontal = this.isHorizontal(),
                isVertical = this.isVertical();
            view.setDisplayDateFormat(preset.displayDateFormat);
            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it
            if (!(initial && timeAxis.isConfigured)) {
                var timeAxisCfg = {
                        // we use either provided "weekStartDay" value or the localized value
                        weekStartDay: this.weekStartDay !== undefined ? this.weekStartDay : (this.L ? this.L('weekStartDay') : 1),
                        startTime: this.startTime,
                        endTime: this.endTime,
                        timeZone: this.timeZone
                    };
                if (initial || !this.rendered) {
                    if (timeAxis.getCount() === 0 || startDate) {
                        timeAxisCfg.start = startDate || new Date();
                        timeAxisCfg.end = endDate;
                    }
                } else {
                    // if startDate is provided we use it and the provided endDate
                    if (startDate) {
                        timeAxisCfg.start = startDate;
                        timeAxisCfg.end = endDate;
                        // if both dates are provided we can calculate centerDate for the viewport
                        if (!centerDate && endDate) {
                            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                centerDate = view.cachedScrollDate;
                            } else {
                                centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);
                            }
                        }
                    } else // when no start/end dates are provided we use the current timespan
                    {
                        timeAxisCfg.start = timeAxis.getStart();
                        timeAxisCfg.end = endDate || timeAxis.getEnd();
                        if (!centerDate) {
                            if (this.infiniteScroll && view.cachedScrollDate && view.cachedScrollDateIsCentered) {
                                centerDate = view.cachedScrollDate;
                            } else {
                                centerDate = this.getViewportCenterDateCached();
                            }
                        }
                    }
                }
                timeAxis.consumeViewPreset(preset);
                timeAxis.reconfigure(timeAxisCfg, true);
                this.timeAxisViewModel.reconfigure({
                    // update preset name in viewmodel to simplify zooming sync for partner panels
                    viewPreset: this.viewPreset,
                    headerConfig: preset.headerConfig,
                    columnLinesFor: preset.columnLinesFor || 'middle',
                    rowHeightHorizontal: this.readRowHeightFromPreset ? preset.rowHeight : this.timeAxisViewModel.getViewRowHeight(),
                    tickWidth: isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeColumnWidth: preset.timeColumnWidth,
                    // timeColumnWidth is also used for row height in vertical mode
                    rowHeightVertical: preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeAxisColumnWidth: preset.timeAxisColumnWidth,
                    resourceColumnWidth: this.resourceColumnWidth || preset.resourceColumnWidth || 100
                });
            }
            if (isVertical) {
                view.setColumnWidth(this.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
            }
            var viewEl = view.getOuterEl();
            // if view is rendered and scroll is not disabled by "notScroll" option
            if (!options.notScroll && viewEl && this.getView().el) {
                // and we have centerDate to scroll to
                if (centerDate) {
                    // remember the central date we scroll to (it gets reset after user scroll)
                    this.cachedCenterDate = centerDate;
                    var x = null,
                        y = null;
                    if (isVertical) {
                        y = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - view.getViewContainerHeight() / 2), 0);
                        this.viewPresetActiveScroll = {
                            top: y
                        };
                        view.scrollVerticallyTo(y);
                    } else {
                        x = Math.max(Math.floor(view.getCoordinateFromDate(centerDate, true) - viewEl.getWidth() / 2), 0);
                        this.viewPresetActiveScroll = {
                            left: x
                        };
                        if (Ext.getVersion().isGreaterThan('6.2.0')) {
                            // In 6.2.1 there's one more partner: scrollbar. Also on afterlayout ext will restore previous
                            // scroll position. That will trigger async method, that will create race condition between us
                            // setting scroll and scrollers, synchronizing position. Normal scrollbar seems to be one
                            // responsible for setting incorrect position. We cannot rely on suspend/resume partner sync,
                            // because it's one more race condition.
                            var normalScroller = view.up('timelinegrid,timelinetree').normalScrollbarScroller;
                            normalScroller && normalScroller.scrollTo(x);
                        }
                        // Sync header scroll and view scroll to make sure the view of the center date is not corrupted
                        view.headerCt.scrollTo(x);
                        view.scrollTo(x);
                    }
                } else // if we don't have a central date to scroll at we reset scroll (this is bw compatible behavior)
                {
                    if (isHorizontal) {
                        view.scrollHorizontallyTo(0);
                    } else {
                        view.scrollVerticallyTo(0);
                    }
                }
            }
        }
    },
    /**
     * Method to get the current view preset of the timeline panel.
     * @return {String} The name of the currently active view preset
     */
    getViewPreset: function() {
        return this.viewPreset;
    },
    /**
     * @inheritdoc #getStartDate
     * @localdoc Alias for {@link #getStartDate} method.
     */
    getStart: function() {
        return this.getStartDate();
    },
    /**
     * Method to get the current start date of the scheduler
     * @return {Date} The start date
     */
    getStartDate: function() {
        return this.timeAxis.getStart();
    },
    /**
     * @inheritdoc #getEndDate
     * @localdoc Alias for {@link #getEndDate} method.
     */
    getEnd: function() {
        return this.getEndDate();
    },
    /**
     * Method to get the current end date of the scheduler
     * @return {Date} The end date
     */
    getEndDate: function() {
        return this.timeAxis.getEnd();
    },
    /**
     * Updates the widths of all the time columns to the supplied value. Only applicable when {@link #forceFit} is set to false.
     * @param {Number} width The new time column width
     */
    setTimeColumnWidth: function(width, preventRefresh) {
        this.timeAxisViewModel.setTickWidth(width, preventRefresh);
    },
    /**
     * @return {Number} width The time column width
     */
    getTimeColumnWidth: function() {
        return this.timeAxisViewModel.getTickWidth();
    },
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight();
    },
    /**
    * Moves the time axis forward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function(amount) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftNext(amount);
        this.suspendLayouts && this.resumeLayouts(true);
    },
    /**
    * Moves the time axis backward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function(amount) {
        this.suspendLayouts && this.suspendLayouts();
        this.timeAxis.shiftPrevious(amount);
        this.suspendLayouts && this.resumeLayouts(true);
    },
    /**
    * Convenience method to go to current date.
    */
    goToNow: function() {
        this.setTimeSpan(new Date());
    },
    getTimezone: function() {
        return this.timeAxis.timeZone;
    },
    /**
     * Changes timezone of the time axis.
     * @param {Number} timeZone New timezone offset in minutes. E.g. for UTC+2 pass 120, for UTC-3 pass -180
     */
    setTimeZone: function(timeZone) {
        this.timeZone = timeZone;
        this.setTimeSpan(this.getStart(), this.getEnd(), timeZone);
    },
    /**
     * Changes the time axis timespan to the supplied start and end dates.
     * @param {Date} start The new start date
     * @param {Date} end (Optional) The new end date. If not supplied, the {@link Sch.preset.ViewPreset#defaultSpan} property of the current view preset will be used to calculate the new end date.
     * @param {Number} timeZone (Optional) New timezone
     */
    setTimeSpan: function(start, end, timeZone) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(start, end, timeZone);
        }
    },
    /**
     * @inheritdoc #setStartDate
     * @localdoc Alias for {@link #setStartDate} method.
     */
    setStart: function(date) {
        this.setStartDate(date);
    },
    /**
     * @inheritdoc #setEndDate
     * @localdoc Alias for {@link #setEndDate} method.
     */
    setEnd: function(date) {
        this.setEndDate(date);
    },
    /**
     * Changes the time axis start date to the supplied date.
     * @param {Date} date The new start date
     */
    setStartDate: function(date) {
        this.setTimeSpan(date);
    },
    /**
     * Changes the time end start date to the supplied date.
     *
     * **Note**: passed date should be greater than current time axis start date.
     * @param {Date} date The new end date
     */
    setEndDate: function(date) {
        this.setTimeSpan(null, date);
    },
    /**
    * Returns the {@link Sch.data.TimeAxis} instance in use.
    * @return {Sch.data.TimeAxis}
    */
    getTimeAxis: function() {
        return this.timeAxis;
    },
    /**
    * Scrolls the time line to the specified `date`.
    * @param {Date} date The date to which to scroll the time line
    */
    scrollToDate: function(date, animate, offset) {
        var view = this.getSchedulingView();
        var coordinate = view.getCoordinateFromDate(date, true);
        this.scrollToCoordinate(coordinate, date, animate, false, offset);
    },
    /**
    * Scrolls the time line so that specified `date` is in the center of the view.
    * @param {Date} date The date to which to scroll the time line
    * @param {Boolean} animate (optional) Whether or not scroll should be animated
    */
    scrollToDateCentered: function(date, animate) {
        var view = this.getSchedulingView();
        var delta = 0;
        if (view.isHorizontal()) {
            delta = view.getBox().width / 2;
        } else {
            delta = view.getBox().height / 2;
        }
        var coordinate = Math.round(view.getCoordinateFromDate(date, true) - delta);
        this.scrollToCoordinate(coordinate, date, animate, true);
    },
    //private
    scrollToCoordinate: function(coordinate, date, animate, centered, offsetFromViewportStart) {
        var view = this.getSchedulingView();
        var me = this;
        offsetFromViewportStart = offsetFromViewportStart || 0;
        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with
        // startTime/endTime config
        if (coordinate < 0 && !view.isWeekView()) {
            if (this.infiniteScroll) {
                // for infinite scroll we have a special formula to calculate adjustment borders
                // shiftToDate() will perform adjustment and then recall scrollToDate() again
                view.shiftToDate(date, centered);
            } else {
                // adjust the timeaxis first
                var halfVisibleSpan = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;
                var newStartDate = new Date(date.getTime() - halfVisibleSpan);
                var newEndDate = new Date(date.getTime() + halfVisibleSpan);
                // We're trying to reconfigure time span to current dates, which means we are as close to center as it
                // could be. Do nothing then.
                // covered by 1102_panel_api
                if (newStartDate - this.getStart() !== 0 && newEndDate - this.getEnd() !== 0) {
                    this.setTimeSpan(newStartDate, newEndDate);
                    if (centered) {
                        me.scrollToDateCentered(date, animate);
                    } else {
                        me.scrollToDate(date, animate, offsetFromViewportStart);
                    }
                }
            }
            return;
        }
        if (this.isHorizontal()) {
            view.scrollHorizontallyTo(coordinate - offsetFromViewportStart, animate);
        } else {
            view.scrollVerticallyTo(coordinate - offsetFromViewportStart, animate);
        }
    },
    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function() {
        return this.getSchedulingView().getViewportCenterDate();
    },
    addCls: function() {
        throw 'Abstract method call';
    },
    removeCls: function() {
        throw 'Abstract method call';
    },
    registerRenderer: function(fn, scope) {
        this.renderers.push({
            fn: fn,
            scope: scope
        });
    },
    deregisterRenderer: function(fn, scope) {
        Ext.each(this.renderers, function(rend, i) {
            if (fn === rend) {
                Ext.Array.removeAt(this.renderers, i);
                return false;
            }
        });
    },
    /**
     * Returns the event store instance
     * @method getEventStore
     * @abstract
     * @return {Ext.data.AbstractStore}
     */
    /**
     * @method
     * @returns {Sch.crud.AbstractManager}
     */
    getCrudManager: function() {
        return this.crudManager;
    },
    setCrudManager: function(cm) {
        this.crudManager = cm;
    }
});

/**
 * @class Sch.view.Horizontal
 * @private
 *
 * An internal view mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView}.
 * This class is consumed by the scheduling view and provides the horizontal implementation of certain methods.
 */
Ext.define("Sch.view.Horizontal", {
    requires: [
        'Ext.util.Region',
        'Ext.Element',
        'Ext.Array',
        'Sch.util.Date'
    ],
    fadeOutRemoval: true,
    // Provided by creator, in the config object
    view: null,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        var view = this.view,
            query;
        raw = raw || false;
        if (resourceRecord) {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
        } else {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-]';
        }
        return view.getEl().query(query, raw);
    },
    translateToScheduleCoordinate: function(x) {
        var view = this.view;
        var pos;
        if (view.shouldAdjustForRtl()) {
            pos = view.getEl().getRight() - x;
        } else {
            pos = x - view.getEl().getX();
        }
        return pos + view.getScroll().left;
    },
    translateToPageCoordinate: function(x) {
        var view = this.view;
        return x + view.getEl().getX() - view.getScroll().left;
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy[0];
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event) {
        var eventStart = event.getStartDate(),
            eventEnd = event.getEndDate() || eventStart,
            // Allow events to be rendered even they are missing an end date
            view = this.view,
            viewStart = view.timeAxis.getStart(),
            viewEnd = view.timeAxis.getEnd(),
            M = Math,
            startX = view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)),
            endX = view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd)),
            data = {
                event: event
            };
        if (this.view.rtl) {
            data.right = M.min(startX, endX);
        } else {
            data.left = M.min(startX, endX);
        }
        data.width = M.max(1, M.abs(endX - startX)) - view.eventBorderWidth;
        if (view.managedEventSizing) {
            data.top = M.max(0, view.barMargin - view.eventBorderWidth + view.cellTopBorderWidth);
            // Event border width is used to calculate top position inside the row and bar height. We only reduce height
            // on one border width value, because we do not want double border spaces between events
            data.height = view.timeAxisViewModel.rowHeightHorizontal - (2 * view.barMargin) - view.eventBorderWidth;
        }
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    /**
    * Gets the Ext.util.Region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to
    * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region;
        if (resourceRecord) {
            var eventEl = eventRecord && view.getElementsFromEventRecord(eventRecord, resourceRecord)[0];
            region = Ext.fly(view.getRowNode(resourceRecord)).getRegion();
            if (eventEl) {
                var eventRegion = eventEl.getRegion();
                region.top = eventRegion.top;
                region.bottom = eventRegion.bottom;
            } else {
                region.top = region.top + view.barMargin;
                region.bottom = region.bottom - view.barMargin - view.eventBorderWidth;
            }
        } else {
            region = view.getTableRegion();
            region.top = region.top + view.barMargin;
            region.bottom = region.bottom - view.barMargin - view.eventBorderWidth;
        }
        var taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || {
                start: taStart,
                end: taEnd
            },
            startX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endX = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),
            top = region.top,
            bottom = region.bottom;
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },
    /**
    * Gets the Ext.util.Region, relative to the scheduling view element, representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            rowNode = view.getRowNode(resourceRecord),
            offsets = Ext.fly(rowNode).getOffsetsTo(view.getEl()),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startX = view.getCoordinateFromDate(start),
            endX = view.getCoordinateFromDate(end),
            top = offsets[1] + view.cellTopBorderWidth,
            bottom = offsets[1] + Ext.fly(rowNode).getHeight() - view.cellBottomBorderWidth;
        if (!Ext.versions.touch) {
            var ctElScroll = view.getScroll();
            top += ctElScroll.top;
            bottom += ctElScroll.top;
        }
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },
    getScheduledEventsForResource: function(resourceRecord) {
        var view = this.view;
        return view.getEventStore().filterEventsForResource(resourceRecord, function(event) {
            return view.timeAxis.isRangeInAxis(event) && event.isScheduled();
        });
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view,
            resourceEvents = this.getScheduledEventsForResource(resourceRecord);
        if (resourceEvents.length === 0) {
            return;
        }
        // Iterate events belonging to current row
        var eventsTplData = resourceEvents.map(function(event) {
                return view.generateTplData(event, resourceRecord, rowIndex);
            });
        // Event data is now gathered, calculate layout properties for each event (if dynamicRowHeight is used)
        if (view.rowHasDynamicRowHeight(resourceRecord)) {
            var layout = view.eventLayout.horizontal;
            var nbrOfBandsRequired = layout.applyLayout(eventsTplData, resourceRecord, this.layoutEventVertically, this);
            meta.rowHeight = (nbrOfBandsRequired * view.timeAxisViewModel.rowHeightHorizontal) - ((nbrOfBandsRequired - 1) * view.barMargin);
        }
        return view.eventTpl.apply(eventsTplData);
    },
    layoutEventVertically: function(bandIndex, eventRecord) {
        var view = this.view;
        var eventTop = bandIndex === 0 ? view.barMargin : (bandIndex * view.timeAxisViewModel.rowHeightHorizontal - (bandIndex - 1) * view.barMargin);
        eventTop += view.cellTopBorderWidth;
        return eventTop;
    },
    // private
    resolveResource: function(node) {
        var me = this,
            view = me.view,
            eventNode, result;
        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);
        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        } else {
            // Not that fast case
            // I'm not sure if it's really needed, the method documentation doesn't state that node must be
            // within event node. If node might be outside of event node then yes, this branch is needed, otherwise
            // it is not.
            node = view.findRowByChild(node);
            result = node && view.getRecordForRowNode(node) || null;
        }
        return result;
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate, useViewSize) {
        var view = this.view,
            startX = view.getCoordinateFromDate(startDate),
            endX = endDate ? view.getCoordinateFromDate(endDate) : startX,
            height, region;
        region = view.getTableRegion();
        if (useViewSize) {
            height = Math.max(region ? region.bottom - region.top : 0, view.getEl().dom.clientHeight);
        } else // fallback in case grid is not rendered (no rows/table)
        {
            height = region ? region.bottom - region.top : 0;
        }
        return new Ext.util.Region(0, Math.max(startX, endX), height, Math.min(startX, endX));
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var view = this.view,
            leftDate = view.getDateFromCoordinate(region.left, roundingMethod),
            rightDate = view.getDateFromCoordinate(region.right, roundingMethod);
        return {
            start: leftDate,
            end: rightDate
        };
    },
    // private
    onEventAdd: function(s, events) {
        var view = this.view,
            affectedResources = {},
            event, startDate, endDate, resources, resource, i, l, j, k;
        for (i = 0 , l = events.length; i < l; i++) {
            event = events[i];
            startDate = event.getStartDate();
            endDate = event.getEndDate();
            // repaint row only if event is in time axis
            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                resources = events[i].getResources(view.getEventStore());
                for (j = 0 , k = resources.length; j < k; j++) {
                    resource = resources[j];
                    affectedResources[resource.getId()] = resource;
                }
            }
        }
        Ext.Object.each(affectedResources, function(id, resource) {
            view.repaintEventsForResource(resource);
        });
    },
    repaintEventsForResources: function(resources) {
        var me = this,
            view = me.view;
        resources.forEach(function(resource) {
            if (view && !view.isDestroyed) {
                view.store.indexOf(resource) >= 0 && view.repaintEventsForResource(resource);
            }
        });
    },
    // private
    onEventRemove: function(store, eventRecords) {
        // fix for tests/features/017_grouping.t.js (issue with loadRawData)
        if (store.ignoreCollectionAdd)  {
            return;
        }
        
        var me = this,
            view = me.view,
            eventStore = view.getEventStore(),
            resources, nodes;
        resources = Ext.Array.unique(Ext.Array.reduce(eventRecords, function(result, r) {
            // It's important to use event store's method here, instead just
            // r.getResources(). r.getResources() will always return empty array here
            // since r is already removed from the event store.
            return result.concat(eventStore.getResourcesForEvent(r));
        }, []));
        nodes = Ext.Array.reduce(eventRecords, function(result, r) {
            return result.concat(view.getElementsFromEventRecord(r, null, null, true));
        }, []);
        nodes = new Ext.CompositeElementLite(nodes);
        if (me.fadeOutRemoval) {
            nodes.fadeOut({
                callback: function() {
                    me.repaintEventsForResources(resources);
                }
            });
        } else {
            nodes.hide();
            me.repaintEventsForResources(resources);
        }
    },
    // private
    onEventUpdate: function(eventStore, model) {
        var previous = model.previous || {};
        var view = this.view;
        var timeAxis = view.timeAxis;
        var newStartDate = model.getStartDate();
        var newEndDate = model.getEndDate();
        var startDate = previous[model.startDateField] || newStartDate;
        var endDate = previous[model.endDateField] || newEndDate;
        // event was visible or visible now
        var eventWasInView = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);
        var resource;
        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (model.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new row, refresh old row first
            resource = eventStore.getResourceStore().getById(previous[model.resourceIdField]);
            resource && view.repaintEventsForResource(resource, true);
        }
        // also resource has to be repainted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            model.getResources().forEach(function(resource) {
                view.repaintEventsForResource(resource, true);
            });
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.getEl()) {
            return null;
        }
        var tableRegion = view.getTableRegion(),
            startDate = view.timeAxis.getStart(),
            endDate = view.timeAxis.getEnd(),
            width = view.getWidth();
        if ((tableRegion.right - tableRegion.left) < width) {
            return {
                startDate: startDate,
                endDate: endDate
            };
        }
        var scroll = view.getScroll();
        var result = {
                startDate: view.getDateFromCoordinate(scroll.left, null, true),
                endDate: view.getDateFromCoordinate(scroll.left + width, null, true) || endDate
            };
        // because of the vertical scrollbar endDate can be resolved to null in the right-most position
        if (!result.endDate) {
            result.endDate = endDate;
        }
        return result;
    },
    /**
     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item
     * then the method returns all of them. Box coordinates are in view coordinate system.
     *
     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)
     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible
     * top row or below currently visible bottom row) will be calculated approximately.
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/null}
     * @return {Boolean} return.rendered Whether the box was calculated for the rendered scheduled record or was
     *                                   approximatelly calculated for the scheduled record outside of the current
     *                                   vertical view area.
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     * @protected
     */
    getItemBox: function(eventRecord) {
        var me = this;
        return eventRecord.getResources().map(function(resourceRecord) {
            return me.getResourceEventBox(eventRecord, resourceRecord);
        });
    },
    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)
    isRowVisible: function(resourceRecord) {
        var hidden = Ext.isFunction(resourceRecord.isVisible) && !resourceRecord.isVisible();
        if (!hidden && this.view.groupingFeature && !this.view.groupingFeature.disabled) {
            var groups = this.view.resourceStore.getGroups();
            if (groups) {
                var group = groups.getByKey(resourceRecord.get(this.view.resourceStore.groupField));
                // HACK Resource belongs to lockingPartner check lockedview
                // while since 6.5.0 #isExpanded on normalView returns wrong results
                hidden = group && !this.view.lockingPartner.groupingFeature.isExpanded(group);
            }
        }
        return !hidden;
    },
    // Checks if the element provided has been rendered and if it's currently displayed.
    // At the state when it's rendered and displayed we can query DOM for element dimensions and offsets
    isElementRenderedAndDisplayed: function(resourceRecordOrRowEl) {
        if (resourceRecordOrRowEl && resourceRecordOrRowEl.isResourceModel) {
            resourceRecordOrRowEl = this.view.getRowNode(resourceRecordOrRowEl);
        }
        return !!(resourceRecordOrRowEl && Ext.fly(resourceRecordOrRowEl).getHeight());
    },
    // This method will calculate result event box, based on render data and row top coordinate
    getResultEventBox: function(renderData, rowTop) {
        return {
            rendered: true,
            start: (renderData.hasOwnProperty('left') ? renderData.left : renderData.right),
            // it depends on view's `rtl` configuration
            end: (renderData.hasOwnProperty('left') ? renderData.left : renderData.right) + renderData.width,
            top: rowTop + renderData.top,
            bottom: rowTop + renderData.top + renderData.height
        };
    },
    getResourceEventBox: function(eventRecord, resourceRecord) {
        var SUD = Sch.util.Date,
            me = this,
            result = null,
            view = me.view,
            viewStartDate = view.timeAxis.getStart(),
            // WARNING: timeaxis is a private property of Sch.mixin.AbstractTimelineView
            viewEndDate = view.timeAxis.getEnd(),
            // WARNING: timeaxis is a private property of Sch.mixin.AbstractTimelineView
            eventStartDate = eventRecord.getStartDate(),
            eventEndDate = eventRecord.getEndDate(),
            eventLayout, rowEventsLayoutData, eventRecordData, rowEl, rowIndex, rowTop, rowHeight, rowNbrOfBands, eventEls, eventEl, eventElOffsets, eventElBox, firstRowIndex, firstRowRecord, lastRowIndex, lastRowRecord, lastRowEl;
        // Checking if event record is within current time axis timespan and is visible, i.e. it's not rendered
        // within a collapsed row (scheduler supports resource tree store as well as flat resource store).
        if (eventStartDate && eventEndDate && SUD.intersectSpans(eventStartDate, eventEndDate, viewStartDate, viewEndDate) && me.isRowVisible(resourceRecord)) {
            rowEl = view.getRowNode(resourceRecord);
            // If resource row is rendered and displayed
            if (rowEl && me.isElementRenderedAndDisplayed(rowEl)) {
                // Managed event sizing means that the view is responsible for event height setting, the oposite case
                // is when event height is controlled by CSS's top and height properties.
                // Fast case: managed event sizing on, querying the view for box position and dimensions
                if (view.managedEventSizing) {
                    eventLayout = view.eventLayout.horizontal;
                    var resourceEvents = view.getEventStore().filterEventsForResource(resourceRecord, view.timeAxis.isRangeInAxis, view.timeAxis);
                    // Preparing events layout data for event layout instance to process
                    rowEventsLayoutData = resourceEvents.map(me.getEventRenderData, me);
                    // Processing event layout data injecting event vertical position into each item of `rowEventsLayoutData`
                    // This layout application takes into account view's `dynamicRowHeight` property
                    eventLayout.applyLayout(rowEventsLayoutData, resourceRecord);
                    // Now we are to find our particular event data inside all events data for the given row record
                    eventRecordData = Ext.Array.findBy(rowEventsLayoutData, function(eventData) {
                        return eventData.event == eventRecord;
                    });
                    // We must find our event record corresponding layout data object here, but just to make sure
                    if (eventRecordData) {
                        // We have event record data with coordinates within the row node, but we need
                        // those coordinates to be translated relative to view's viewport top.
                        rowTop = Ext.fly(rowEl).getOffsetsTo(view.getNodeContainer())[1];
                        // Finally we have all the data needed to calculated the event record box
                        result = this.getResultEventBox(eventRecordData, rowTop);
                    }
                } else // Slow case: managed event sizing off, querying the DOM for box position and dimensions
                {
                    eventEls = view.getElementsFromEventRecord(eventRecord, eventRecord !== resourceRecord && resourceRecord);
                    // We must have at one and only one element here, but just to make sure
                    if (eventEls.length) {
                        eventEl = eventEls[0];
                        eventElOffsets = eventEl.getOffsetsTo(view.getEl());
                        eventElBox = eventEl.getBox();
                        result = {
                            rendered: true,
                            start: eventElOffsets[0],
                            end: eventElOffsets[0] + eventElBox.width,
                            top: eventElOffsets[1],
                            bottom: eventElOffsets[1] + eventElBox.height
                        };
                    }
                }
            } else // Resource row is not rendered, and it's not collapsed. We are to calculate event record box approximately.
            {
                result = {
                    rendered: false,
                    start: view.getCoordinateFromDate(SUD.max(eventStartDate, viewStartDate)),
                    end: view.getCoordinateFromDate(SUD.min(eventEndDate, viewEndDate))
                };
                // top and bottom to go
                // WARNING: view.all is a private property
                firstRowIndex = view.all.startIndex;
                firstRowRecord = view.getRecord(firstRowIndex);
                // WARNING: view.all is a private property
                lastRowIndex = view.all.endIndex;
                lastRowRecord = view.getRecord(lastRowIndex);
                rowHeight = view.getRowHeight();
                // Event row is not rendered and it's above first visible row.
                // Here we provide box coordinates requested to be in the row above the first visible row, this should suffice. The real box coordinates are somewhere above,
                // and it will take way to much effort to calculate them to exact values, so we provide some sufficient surrogate coordinates.
                if (resourceRecord.isAbove(firstRowRecord)) {
                    result.top = -rowHeight;
                    result.bottom = result.top + rowHeight;
                    result.relPos = 'before';
                }
                // Event row is not rendered or displayed and it's inside visible rows range, the case happens when a view or one of it's parents is hidden
                // with 'display:none' rule.
                else if (resourceRecord == lastRowRecord || resourceRecord.isAbove(lastRowRecord)) {
                    rowIndex = view.indexOf(resourceRecord);
                    result.top = rowIndex * rowHeight;
                    result.bottom = result.top + rowHeight;
                } else // Event row is not rendered and it's below last visible row.
                // Here we provide box coordinates requested to be in the row bellow the last visible row, this should suffice. The real box coordniates are somewhere below,
                // and it will take way to much effort to calculate them to exact values, so we provide some sufficient surrogate coordinates.
                {
                    lastRowEl = view.getNode(lastRowIndex);
                    // Rows can be stretched, use last row's real coordinates if offsets are reliable
                    if (me.isElementRenderedAndDisplayed(lastRowEl)) {
                        result.top = Ext.fly(lastRowEl).getOffsetsTo(view.getNodeContainer())[1] + Ext.fly(lastRowEl).getHeight();
                    } else {
                        result.top = (lastRowIndex + 1) * rowHeight;
                    }
                    result.bottom = result.top + rowHeight;
                    result.relPos = 'after';
                }
            }
            // Some boxes might need special adjustments
            if (result) {
                result = me.adjustItemBox(eventRecord, result);
            }
        }
        return result;
    },
    /**
     * Adjusts task record box if needed
     *
     * @param {Sch.model.Event} eventRecord
     * @param {Object} eventRecordBox
     * @return {Number} eventRecordBox.top
     * @return {Number} eventRecordBox.bottom
     * @return {Number} eventRecordBox.start
     * @return {Number} eventRecordBox.end
     * @return {Object}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @protected
     */
    adjustItemBox: function(eventRecord, eventRecordBox) {
        return eventRecordBox;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'left';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'right';
    }
});

/**
@class Sch.mixin.AbstractTimelineView
@private

A base mixin for giving to the consuming view "timeline" functionality.
This means that the view will be capable of displaying a list of "events", ordered on a {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.template.Event',
        'Sch.view.Horizontal'
    ],
    uses: [
        'Ext.dom.Query'
    ],
    /**
     * @cfg {String} selectedEventCls
     * A CSS class to apply to an event in the view on mouseover (defaults to 'sch-event-selected').
     */
    selectedEventCls: 'sch-event-selected',
    showAllDayHeader: false,
    // private
    readOnly: false,
    horizontalViewClass: 'Sch.view.Horizontal',
    //    can not "declare" it here, because will conflict with the default value from SchedulerView
    //    verticalViewClass   : null,
    timeCellCls: 'sch-timetd',
    timeCellSelector: '.sch-timetd',
    eventBorderWidth: 1,
    timeAxis: null,
    timeAxisViewModel: null,
    eventPrefix: null,
    rowHeight: null,
    //    can not "declare" it here, because will conflict with the default value from  SchedulerView
    //    barMargin           : null,
    mode: 'horizontal',
    horizontal: null,
    vertical: null,
    weekview: null,
    horizontalViewCls: [
        'sch-horizontal-view'
    ],
    verticalViewCls: [
        'sch-vertical-view'
    ],
    weekviewViewCls: [
        'sch-calendar-view',
        'sch-vertical-view'
    ],
    panel: null,
    displayDateFormat: null,
    // Accessor to the Ext.Element for this view
    el: null,
    _initializeTimelineView: function() {
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, {
                view: this
            });
        }
        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, {
                view: this
            });
        }
        if (this.weekViewClass) {
            this.weekview = Ext.create(this.weekViewClass, {
                view: this,
                showAllDayHeader: this.showAllDayHeader
            });
        }
        this.eventPrefix = (this.eventPrefix || this.getId()) + '-';
    },
    getTimeAxisViewModel: function() {
        return this.timeAxisViewModel;
    },
    /**
    * Method to get a formatted display date
    * @private
    * @param {Date} date The date
    * @return {String} The formatted date
    */
    getFormattedDate: function(date) {
        return Ext.Date.format(date, this.getDisplayDateFormat());
    },
    getTimeZoneFormattedDate: function(date) {
        return Sch.util.Date.format(date, this.getDisplayDateFormat(), this.timeAxis.timeZone);
    },
    convertDateToTimeZone: function(date) {
        return this.timeAxis.toTimeZone(date);
    },
    convertDateFromTimeZone: function(date) {
        return this.timeAxis.fromTimeZone(date);
    },
    roundDateInTimeZone: function(value, roundingMethod) {
        return this.timeAxis.roundDateInTimeZone(value, roundingMethod);
    },
    /**
    * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
    * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,
    * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).
    * @private
    * @param {Date} endDate The date to format
    * @param {Date} startDate The start date
    * @return {String} The formatted date
    */
    getFormattedEndDate: function(endDate, startDate) {
        var format = this.getDisplayDateFormat();
        if (// If time is midnight,
        endDate.getHours() === 0 && endDate.getMinutes() === 0 && (// and end date is greater then start date
        !startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) && // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
        !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))) {
            // format the date inclusively as 'the whole previous day'.
            endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
        }
        return Ext.Date.format(endDate, format);
    },
    getTimeZoneFormattedEndDate: function(endDate, startDate) {
        var format = this.getDisplayDateFormat();
        if (// If time is midnight,
        endDate.getUTCHours() === 0 && endDate.getUTCMinutes() === 0 && (// and end date is greater then start date
        !startDate || !(endDate.getUTCYear() === startDate.getUTCYear() && endDate.getUTCMonth() === startDate.getUTCMonth() && endDate.getUTCDate() === startDate.getUTCDate())) && // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
        !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))) {
            // format the date inclusively as 'the whole previous day'.
            endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
        }
        return Sch.util.Date.format(endDate, format, this.timeAxis.timeZone);
    },
    // private
    getDisplayDateFormat: function() {
        return this.displayDateFormat;
    },
    // private
    setDisplayDateFormat: function(format) {
        this.displayDateFormat = format;
    },
    /**
    * This function fits the schedule area columns into the available space in the grid.
    * @param {Boolean} preventRefresh `true` to prevent a refresh of view
    */
    fitColumns: function(preventRefresh) {
        // TODO test
        if (this.isHorizontal()) {
            this.getTimeAxisViewModel().fitToAvailableWidth(preventRefresh);
        } else {
            var w = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(w, preventRefresh);
        }
    },
    /**
     * Returns all the Ext.Element(s) representing an event record.
     *
     * @param {Sch.model.Event} eventRecord An event record
     * @param {Sch.model.Resource} [resourceRecord] A resource record
     *
     * @return {Ext.Element[]/HTMLElement[]} The Ext.Element(s) representing the event record
     */
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        // They are private but we still want doc on them
        // @param {Number} [index] Index used to distinguish DOM nodes corresponding to same event/resource but
        // rendered on different columns inside weekview.
        // @param {Boolean [raw=false] Whether to return HTMLElements instead of Ext.Element
        return this[this.mode].getElementsFromEventRecord(eventRecord, resourceRecord, index, raw);
    },
    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        return this[this.mode].getStartEndDatesFromRegion(region, roundingMethod);
    },
    /**
     * Gets the start and end dates for an element Region in the configured time zone
     * @param {Ext.util.Region} region The region to map to start and end dates
     * @param {String} roundingMethod The rounding method to use
     * @returns {Object} an object containing start/end properties
     */
    getTimeZoneStartEndDatesFromRegion: function(region, roundingMethod) {
        // For day resolution we need to round date properly to adjust real resulting dates to the tick bounds
        if (Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.timeAxis.resolutionUnit) <= 0) {
            var value = this[this.mode].getStartEndDatesFromRegion(region, null);
            return {
                start: this.roundDateInTimeZone(value.start, roundingMethod),
                end: this.roundDateInTimeZone(value.end, roundingMethod)
            };
        } else {
            return this[this.mode].getStartEndDatesFromRegion(region, roundingMethod);
        }
    },
    /**
    * Returns the current time resolution object, which contains a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    getTimeResolution: function() {
        return this.timeAxis.getResolution();
    },
    /**
    * Sets the current time resolution, composed by a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    setTimeResolution: function(unit, increment) {
        this.timeAxis.setResolution(unit, increment);
        // View will have to be updated to support snap to increment
        if (this.getTimeAxisViewModel().snapToIncrement) {
            this.refreshKeepingScroll();
        }
    },
    /**
    * <p>Returns the event id for a DOM id </p>
    * @private
    * @param {String} id The id of the DOM node
    * @return {String} An event record (internal) id
    */
    getEventIdFromDomNodeId: function(id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[0];
    },
    /**
     * Returns a resource id for a DOM id
     * @private
     * @param {String} id An id of an event DOM node
     * @return {String} A resource record (internal) id
     */
    getResourceIdFromDomNodeId: function(id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[1];
    },
    /**
    *  Gets the time for a DOM event such as 'mousemove' or 'click'
    *  @param {Ext.event.Event} e, the EventObject instance
    *  @param {String} roundingMethod (optional), 'floor' to floor the value or 'round' to round the value to nearest increment
    *  @returns {Date} The date corresponding to the EventObject x coordinate
    */
    getDateFromDomEvent: function(e, roundingMethod) {
        return this.getDateFromXY(e.getXY(), roundingMethod);
    },
    /**
     *  Gets the time for a DOM event such as 'mousemove' or 'click' converted to the configured time zone
     *  @param {Ext.event.Event} e, the EventObject instance
     *  @param {String} roundingMethod (optional), 'floor' to floor the value or 'round' to round the value to nearest increment
     *  @returns {Date} The date corresponding to the EventObject x coordinate
     */
    getTimeZoneDateFromDomEvent: function(e, roundingMethod) {
        return this.getTimeZoneDateFromXY(e.getXY(), roundingMethod, null, true);
    },
    /**
    * [Experimental] Returns the pixel increment for the current view resolution.
    * @return {Number} The width increment
    */
    getSnapPixelAmount: function() {
        return this.getTimeAxisViewModel().getSnapPixelAmount();
    },
    /**
    * Controls whether the scheduler should snap to the resolution when interacting with it.
    * @param {Boolean} enabled true to enable snapping when interacting with events.
    */
    setSnapEnabled: function(enabled) {
        this.getTimeAxisViewModel().setSnapToIncrement(enabled);
    },
    /**
    * Sets the readonly state which limits the interactivity (resizing, drag and drop etc).
    * @param {Boolean} readOnly The new readOnly state
    */
    setReadOnly: function(readOnly) {
        this.readOnly = readOnly;
        this[readOnly ? 'addCls' : 'removeCls'](this._cmpCls + '-readonly');
    },
    /**
    * Returns true if the view is currently readOnly.
    * @return {Boolean} readOnly
    */
    isReadOnly: function() {
        return this.readOnly;
    },
    /**
    * Sets the current mode.
    * @param {String} mode Either 'horizontal', 'vertical' or 'weekview'
    */
    setMode: function(mode) {
        var me = this;
        me.mode = mode;
        me.timeAxisViewModel.mode = mode;
        me.removeCls(me.verticalViewCls.concat(me.weekviewViewCls).concat(me.horizontalViewCls));
        me.addCls(me[mode + 'ViewCls']);
    },
    /**
    * Returns the current view mode
    * @return {String} The view mode ('horizontal', 'vertical' or 'weekview')
    */
    getMode: function() {
        return this.mode;
    },
    isHorizontal: function() {
        return this.getMode() === 'horizontal';
    },
    isVertical: function() {
        return this.getMode() === 'vertical';
    },
    isWeekView: function() {
        return this.getMode() === 'weekview';
    },
    /**
    * Gets the date for an XY coordinate
    * @param {Array} xy The page X and Y coordinates
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} [local], true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromXY: function(xy, roundingMethod, local) {
        return this[this.mode].getDateFromXY(xy, roundingMethod, local);
    },
    /**
     * Gets the date for an XY coordinate converted to the configured time zone
     * @param {Array} xy The page X and Y coordinates
     * @param {String} roundingMethod The rounding method to use
     * @param {Boolean} [local], true if the coordinate is local to the scheduler view element
     * @returns {Date} the Date corresponding to the xy coordinate
     */
    getTimeZoneDateFromXY: function(xy, roundingMethod, local, force) {
        var value = this[this.mode].getDateFromXY(xy, null, local);
        // When rounding days we need to adjust resolved time to the local TZ to match ticks
        // value can be null sometimes, e.g. when you move pointer on a scaled display
        if (value && (Sch.util.Date.compareUnits(Sch.util.Date.DAY, this.timeAxis.resolutionUnit) <= 0 || force)) {
            return this.roundDateInTimeZone(value, roundingMethod);
        } else {
            return this.getDateFromXY(xy, roundingMethod);
        }
    },
    /**
    * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
    * @param {Number} coordinate The X or Y coordinate
    * @param {String} [roundingMethod] The rounding method to use
    * @param {Boolean} [local], true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromCoordinate: function(coordinate, roundingMethod, local) {
        if (!local) {
            coordinate = this[this.mode].translateToScheduleCoordinate(coordinate);
        }
        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod);
    },
    /**
    * Gets the date for the passed X coordinate.
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} x The X coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the x coordinate
    * @abstract
    */
    getDateFromX: function(x, roundingMethod) {
        return this.getDateFromCoordinate(x, roundingMethod);
    },
    /**
    * Gets the date for the passed Y coordinate
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} y The Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the y coordinate
    * @abstract
    */
    getDateFromY: function(y, roundingMethod) {
        return this.getDateFromCoordinate(y, roundingMethod);
    },
    /**
    *  Gets the x or y coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  If the coordinate is not in the currently rendered view, -1 will be returned.
    *  @param {Date} date the date to query for
    *  @param {Boolean} [local] true to return a coordinate local to the scheduler view element (defaults to true)
    *  @returns {Number} the x or y position representing the date on the time axis
    */
    getCoordinateFromDate: function(date, local) {
        var pos = this.timeAxisViewModel.getPositionFromDate(date);
        if (local === false) {
            pos = this[this.mode].translateToPageCoordinate(pos);
        }
        return pos;
    },
    /**
    *  Returns the distance in pixels the for time span in the view.
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Number} The distance in pixels
    */
    getTimeSpanDistance: function(startDate, endDate) {
        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    },
    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function(startDate, endDate) {
        return this[this.mode].getTimeSpanRegion(startDate, endDate);
    },
    /**
    * Gets the Ext.util.Region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for
    * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function(resourceRecord, eventRecord) {
        return this[this.mode].getScheduleRegion(resourceRecord, eventRecord);
    },
    // Returns the region of the table element containing the rows of the schedule
    getTableRegion: function() {
        throw 'Abstract method call';
    },
    // Returns the table element containing the rows of the schedule
    getRowNode: function(resourceRecord) {
        throw 'Abstract method call';
    },
    getRecordForRowNode: function(node) {
        throw 'Abstract method call';
    },
    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function() {
        return this[this.mode].getVisibleDateRange();
    },
    /**
     * Method to set the new columnWidth. The new width is passed in the case of a horizontal mode as tickWidth,
     * resourceColumnWidth in the case of a vertical mode and as weekViewColumnWidth in the case of a weekview mode.
     * @param {Number} width The new width value
     * @param {Boolean} preventRefresh true to skip refreshing the view
     */
    setColumnWidth: function(width, preventRefresh) {
        this[this.mode].setColumnWidth(width, preventRefresh);
    },
    findRowByChild: function(t) {
        throw 'Abstract method call';
    },
    /**
    * Sets the amount of margin to keep between bars and rows.
    * @param {Number} margin The new margin value
    * @param {Boolean} preventRefresh true to skip refreshing the view
    */
    setBarMargin: function(margin, preventRefresh) {
        this.barMargin = margin;
        if (!preventRefresh) {
            this.refreshKeepingScroll();
        }
    },
    /**
     * Returns the current row height used by the view (only applicable in a horizontal view)
     * @return {Number} The row height
     */
    getRowHeight: function() {
        return this.timeAxisViewModel.getViewRowHeight();
    },
    /**
    * Sets the row height of the timeline
    * @param {Number} height The height to set
    * @param {Boolean} preventRefresh `true` to prevent view refresh
    */
    setRowHeight: function(height, preventRefresh) {
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },
    /**
    * Refreshes the view and maintains the scroll position.
    */
    refreshKeepingScroll: function() {
        throw 'Abstract method call';
    },
    /**
     * Scrolls the view vertically
     * @param {Number} y The Y coordinate to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollVerticallyTo: function(y, animate) {
        throw 'Abstract method call';
    },
    /**
     * Scrolls the view horizontally
     * @param {Number} x The X coordinate to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollHorizontallyTo: function(x, animate) {
        throw 'Abstract method call';
    },
    /**
     * Returns the current vertical scroll value
     */
    getVerticalScroll: function() {
        throw 'Abstract method call';
    },
    /**
     * Returns the current horizontal scroll value
     */
    getHorizontalScroll: function() {
        throw 'Abstract method call';
    },
    // This method should be implemented by the consuming class
    getEl: Ext.emptyFn,
    /**
     * Returns the current viewport scroll position as an object with left/top properties.
     */
    getScroll: function() {
        throw 'Abstract method call';
    },
    getOuterEl: function() {
        return this.getEl();
    },
    getRowContainerEl: function() {
        return this.getEl();
    },
    getScheduleCell: function(row, col) {
        return this.getCellByPosition({
            row: row,
            column: col
        });
    },
    getScrollEventSource: function() {
        return this.getEl();
    },
    getViewportHeight: function() {
        return this.getEl().getHeight();
    },
    getViewportWidth: function() {
        return this.getEl().getWidth();
    },
    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function() {
        var scroll = this.getScroll(),
            xy;
        if (this.isVertical()) {
            xy = [
                0,
                scroll.top + this.getViewportHeight() / 2
            ];
        } else {
            xy = [
                scroll.left + this.getViewportWidth() / 2,
                0
            ];
        }
        return this.getDateFromXY(xy, null, true);
    },
    getDateConstraints: Ext.emptyFn,
    /**
     * Return a box representing the item associated with the event record. If there are several boxes displayed for the given
     * item, the method returns all of them
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered
     * @return {String} return.relPos if the item is not rendered then provides a view relative position one of 'before', 'after'
     */
    getItemBox: function(eventRecord) {
        return this[this.mode].getItemBox(eventRecord);
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return this[this.mode].getConnectorStartSide(eventRecord);
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return this[this.mode].getConnectorEndSide(eventRecord);
    },
    /**
     * Gets view start date
     *
     * @return {Date}
     */
    getViewStartDate: function() {
        return this.timeAxis.getStart();
    },
    /**
     * Gets view end date
     *
     * @return {Date}
     */
    getViewEndDate: function() {
        return this.timeAxis.getEnd();
    }
});
Ext.apply(Sch, {
    VERSION: '6.1.17',
    LICENSE: '%LICENSE%'
});

// !XXX when adding new methods to this mixing need to also update the
// `setupLockableTree` method in the Sch.mixin.Lockable
Ext.define("Sch.mixin.FilterableTreeView", {
    prevBlockRefresh: null,
    initTreeFiltering: function() {
        var doInit = function() {
                var treeStore = this.store;
                this.mon(treeStore, 'nodestore-datachange-start', this.onFilterChangeStart, this);
                this.mon(treeStore, 'nodestore-datachange-end', this.onFilterChangeEnd, this);
                if (!treeStore.allowExpandCollapseWhileFiltered) {
                    this.mon(treeStore, 'filter-clear', this.onFilterCleared, this);
                    this.mon(treeStore, 'filter-set', this.onFilterSet, this);
                }
            };
        if (this.rendered)  {
            doInit.call(this);
        }
        else  {
            this.on('beforerender', doInit, this, {
                single: true
            });
        }
        
    },
    onFilterChangeStart: function() {
        this.prevBlockRefresh = this.blockRefresh;
        // block refresh in filterable tree view, for the cases when this mixin is consumed by non-tree views
        // "blockRefresh" is already true in all tree views, so in the Sch.data.mixin.FilterableTreeStore
        // we use "nodeStore.fireEvent('clear', nodeStore);" hack, which is directly tied to "refresh" method of the view
        // in case when non-tree view consumes this mixin, we need to temporarily block the refresh manually,
        // to avoid double refresh
        this.blockRefresh = true;
        Ext.suspendLayouts();
    },
    onFilterChangeEnd: function() {
        Ext.resumeLayouts(true);
        this.blockRefresh = this.prevBlockRefresh;
    },
    onFilterCleared: function() {
        delete this.toggle;
        var el = this.getEl();
        if (el)  {
            el.removeCls('sch-tree-filtered');
        }
        
    },
    onFilterSet: function() {
        this.toggle = function() {};
        var el = this.getEl();
        if (el)  {
            el.addCls('sch-tree-filtered');
        }
        
    }
});

/**
 * This mixin provides a grid view component with more canvases it can draw onto.
 *
 * There're two kinds of canvases provided:
 *  - secondary canvases which are created once and are outside of a node container
 *  - items canvases which might be deleted by the grid's original view and thus might be constantly recreated when
 *    requested, items canvases are created within node container, i.e. somewhere alongside item corresponding
 *    HTML elements
 *
 * NOTE: regardles of a canvas type a canvas consummer shall not store canvas reference, it shall always re-request
 *       a canvas.
 */
Ext.define('Sch.mixin.GridViewCanvas', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        after: {
            'onRender': 'afterOnRender'
        }
    },
    secondaryCanvasCls: 'sch-secondary-canvas',
    secondaryCanvasLayerCls: 'sch-secondary-canvas-layer',
    itemsCanvasEl: null,
    itemsCanvasCls: 'sch-item-canvas',
    itemsCanvasLayerCls: 'sch-item-canvas-layer',
    /**
     * Returns a sub canvas el - the el to be used for drawing column lines, zones etc
     *
     * @return {Ext.dom.Element}
     */
    getSecondaryCanvasEl: function() {
        var el = null;
        if (this.isItemCanvasAvailable()) {
            el = this.getItemCanvasEl(-1, {
                tag: 'div',
                role: 'presentation',
                cls: this.secondaryCanvasCls
            });
        }
        return el;
    },
    /**
     * Returns true if canvas is available.
     *
     * @param {Number} [layer]  Use this to fine grain the query to the presence of a specific layer
     *
     * @return {Boolean}
     */
    isItemCanvasAvailable: function(layer) {
        var me = this;
        return !!(me.rendered && !me.destroyed && (me.getNodeContainer() || me.itemsCanvasEl && (me.itemsCanvasEl._underMixinControl || !Ext.isGarbage(me.itemsCanvasEl.dom))));
    },
    /**
     * Returns true if canvas is present (in the dom).
     *
     * @param {Number} [layer]  Use this to fine grain the query to the presence of a specific layer
     *
     * @return {Boolean}
     */
    isItemCanvasPresent: function(layer) {
        var me = this;
        return !!(me.rendered && !me.destroyed && me.itemsCanvasEl && (layer === undefined || (me.itemsCanvasEl[layer] && (me.itemsCanvasEl._underMixinControl || !Ext.isGarbage(me.itemsCanvasEl[layer].dom)))));
    },
    /**
     * Returns a sub canvas element or it's child layer. This canvas element is attached to view's node
     * container, the canvas is volatile since node container contents are built using a template which has no
     * information about canvas element attached as node container's child. Thus one shouldn't cache the element instance
     * returned.
     *
     * @param {Number} layer
     * @param {Object|Function|String} layerCreationSpecification
     * @return {Ext.dom.Element}
     */
    getItemCanvasEl: function(layer, layerCreationSpecification) {
        var me = this,
            canvasEl = me.itemsCanvasEl,
            layerEl = canvasEl;
        Ext.Assert && Ext.Assert.truthy(me.isItemCanvasAvailable(), "Can't get sub canvas element, view's node container isn't rendered yet");
        if (!canvasEl || !canvasEl.dom || (!canvasEl._underMixinControl && (Ext.isGarbage(canvasEl.dom)))) {
            layerEl = canvasEl = me.itemsCanvasEl = Ext.fly(me.getNodeContainer()).insertFirst({
                cls: me.itemsCanvasCls
            });
        }
        if (arguments.length > 0) {
            layer = layer || 0;
            layerEl = canvasEl[layer] || Ext.dom.Query.selectNode('[data-sch-secondary-canvas-layer="' + layer + '"]', canvasEl.dom);
            // Make sure the element has not been wiped out of the DOM by the Ext JS buffered rendering
            if (!layerEl || !layerEl.dom || (!canvasEl._underMixinControl && Ext.isGarbage(layerEl.dom))) {
                layerEl = canvasEl.createChild((Ext.isFunction(layerCreationSpecification) ? layerCreationSpecification() : layerCreationSpecification) || {
                    tag: 'div'
                });
                layerEl.set({
                    'data-sch-secondary-canvas-layer': layer
                });
                layerEl.setStyle('zIndex', layer);
                layerEl.addCls(me.itemsCanvasLayerCls);
                canvasEl[layer] = layerEl;
            }
        }
        return layerEl;
    },
    afterOnRender: function() {
        if (this.bufferedRenderer) {
            this.on('viewready', this.onBufferedRendererViewReady, this);
        }
    },
    // Prevent Ext JS from destroying our item canvas element, which would mean we had to re-render its contents
    // constantly when scrolling fast which kills the frame rate
    onBufferedRendererViewReady: function() {
        var me = this,
            targetBufferedPlugin = Ext.getVersion().isGreaterThan('6.5.3') ? this.grid.up('tablepanel').lockedGrid.bufferedRenderer : me.bufferedRenderer,
            oldOnRangeFetched = targetBufferedPlugin.onRangeFetched;
        targetBufferedPlugin.onRangeFetched = function() {
            var itemsCanvas = me.getItemCanvasEl(),
                nodeContainer = me.getNodeContainer(),
                retVal;
            itemsCanvas._underMixinControl = true;
            itemsCanvas.dom.parentNode && itemsCanvas.dom.parentNode.removeChild(itemsCanvas.dom);
            retVal = oldOnRangeFetched.apply(this, arguments);
            nodeContainer.insertBefore(itemsCanvas.dom, nodeContainer.firstChild);
            delete itemsCanvas._underMixinControl;
            return retVal;
        };
    }
});

/**
 Internal class syncing size/state of the locked grid in two Timeline panels.
 */
Ext.define('Sch.mixin.PartnerTimelinePanel', {
    extend: 'Ext.Mixin',
    setupPartnerTimelinePanel: function(panel) {
        // Sync locked grids by listening for splitter resize events of both locked grids.
        var otherPanel = this.partnerTimelinePanel;
        var otherLockedGrid = otherPanel.lockedGrid;
        var ourLockedGrid = this.lockedGrid;
        otherLockedGrid.mon(ourLockedGrid, 'resize', this.onLockedGridResize, otherLockedGrid);
        ourLockedGrid.mon(otherLockedGrid, 'resize', this.onLockedGridResize, ourLockedGrid);
        var lockedWidth = otherPanel.isVisible() ? otherPanel.lockedGrid.getWidth() : otherPanel.lockedGrid.width;
        // Ext doesn't support initially collapsed locked grid, exception will be raised.
        if (otherLockedGrid.getCollapsed()) {
            // after locked grid is initially expanded we can sync width
            this.mon(otherLockedGrid, 'viewready', function(panel) {
                ourLockedGrid.setWidth(panel.getWidth());
            });
        } else {
            ourLockedGrid.setWidth(lockedWidth);
        }
        // if we change collapse state in process of layout update
        // component won't be collapsible/expandable anymore
        this.on('afterlayout', function() {
            if (otherLockedGrid.getCollapsed()) {
                ourLockedGrid.collapse();
            } else {
                ourLockedGrid.expand();
                ourLockedGrid.setWidth(lockedWidth);
            }
        }, this, {
            single: true
        });
        otherLockedGrid.on({
            collapse: this.onPartnerCollapseExpand,
            expand: this.onPartnerCollapseExpand,
            scope: this
        });
        ourLockedGrid.on({
            collapse: this.onPartnerCollapseExpand,
            expand: this.onPartnerCollapseExpand,
            scope: otherPanel
        });
        this.setupScrollSync();
        /* HACK

         Ext.scroll.Scroller is responsible for sharing scroll position between partners. Partnership is a two-way
         binding between two scrollables, who are aware of own scroll and propagate it to another. While scroll on one
         is changing, other is told to stop sharing scroll.
         For example (refer to the picture below): view1 and header1 are partners. When view1 change left scroll it
         tells header1 to suspend, pass it new scroll value and start buffered callback with 100 ms interval. That
         callback will resume header1. When browser scroll event happen on header1 it tries to sync position with
         partner (view1), but it is told not to - here and after EXT-SYNC.

         Our partner panels also share scroll (here and after SCH-SYNC) between views - view1 and view2 on scheme.

         This lead to a following zooming scenario:
         1) view1 is zoomed and start throwing scroll events
         2) view2 is scrolled by SCH-SYNC
         3) header2 is scrolled by EXT-SYNC, because view2 scroll changed.
         4) view1 is scrolled to correct coordinate by zoomable mixin
         5) view2 is scrolled to correct coordinate by SCH-SYNC
         6) view2 tries to sync scroll with header2 - EXT-SYNC - but header2 at some point started scrolling and
         suspended view2 from sharing it's sync. In result header1, view1 and view2 have new, correct scroll and header2
         contain scroll position that was before zoom.
         |------------|   |------------|
         |   header1  |   |   header2  |
         |------------|   |------------|
         |    view1   |   |    view2   |
         |------------|   |------------|

         Idea to fix is simple - avoid suspending partner scroll. Works well for case with 2 partners. We also need this
         hack only with zooming, this is why beforezoomchange event is required.
         */
        otherPanel.mon(this, 'beforezoomchange', this.onBeforeZoomChange, this);
        otherPanel.mon(this, 'viewchange', this.onViewChange, this);
        this.mon(otherPanel, 'beforezoomchange', this.onBeforeZoomChange, this);
        this.mon(otherPanel, 'viewchange', this.onViewChange, this);
    },
    // Scope of 'this' is set to the other panel in the listener
    onLockedGridResize: function(cmp, width) {
        this.setWidth(width);
    },
    onPartnerCollapseExpand: function(panel) {
        if (panel.getCollapsed()) {
            this.lockedGrid.collapse();
        } else {
            this.lockedGrid.expand();
        }
    },
    setupScrollSync: function() {
        // sync scrolling with external timeline panel
        var otherView = this.partnerTimelinePanel.getSchedulingView(),
            otherScrollSource = this.partnerTimelinePanel.getMode() === 'horizontal' ? otherView.getScrollable() : this.partnerTimelinePanel.getScrollable(),
            ownView = this.getSchedulingView(),
            ownScrollSource = this.getMode() === 'horizontal' ? ownView.getScrollable() : this.getScrollable(),
            asapScrolling;
        function onSyncScrollStart(scrollable) {
            var source = scrollable === ownScrollSource ? ownScrollSource : otherScrollSource,
                target = scrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
            if (!asapScrolling) {
                source.component.mun(target, 'scrollstart', onSyncScrollStart);
                target.component.mun(source, 'scrollstart', onSyncScrollStart);
                source.component.mon(source, 'scroll', doScrollSync);
                source.component.mon(source, 'scrollend', onSyncScrollEnd);
            }
        }
        function doScrollSync(syncFromScrollable, x, y) {
            var source = syncFromScrollable === ownScrollSource ? ownScrollSource : otherScrollSource,
                target = syncFromScrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
            // header might be hidden with hideHeaders: true
            var headerScrollable = target.component.headerCt.getScrollable();
            asapScrolling = Ext.asap(function() {
                var delta, position;
                position = target.getPosition();
                if (position && ownView.getMode() === 'horizontal') {
                    delta = Math.abs(position.x - x);
                    if (delta) {
                        headerScrollable && !headerScrollable.destroyed && headerScrollable.scrollTo(x, null);
                        !target.destroyed && target.scrollTo(x);
                        asapScrolling = false;
                    } else {
                        asapScrolling = false;
                    }
                } else if (position) {
                    delta = Math.abs(position.y != y);
                    if (delta) {
                        !target.destroyed && target.scrollTo(null, y);
                    }
                    asapScrolling = false;
                }
            });
        }
        function onSyncScrollEnd(scrollable) {
            var source = scrollable === ownScrollSource ? ownScrollSource : otherScrollSource,
                target = scrollable === ownScrollSource ? otherScrollSource : ownScrollSource;
            source.component.mun(source, 'scroll', doScrollSync);
            source.component.mun(source, 'scrollend', onSyncScrollEnd);
            source.component.mon(target, 'scrollstart', onSyncScrollStart);
            target.component.mon(source, 'scrollstart', onSyncScrollStart);
        }
        function startScrollMonitoring() {
            otherScrollSource.component.mon(ownScrollSource, 'scrollstart', onSyncScrollStart);
            ownScrollSource.component.mon(otherScrollSource, 'scrollstart', onSyncScrollStart);
        }
        function stopScrollMonitoring() {
            otherScrollSource.component.mun(ownScrollSource, 'scrollstart', onSyncScrollStart);
            ownScrollSource.component.mun(otherScrollSource, 'scrollstart', onSyncScrollStart);
        }
        this.partnerTimelinePanel.mon(this, {
            'show': function() {
                doScrollSync(otherScrollSource, otherScrollSource.getPosition().x, otherScrollSource.getPosition().y);
            }
        });
        this.mon(this.partnerTimelinePanel, {
            'show': function() {
                doScrollSync(ownScrollSource, ownScrollSource.getPosition().x, ownScrollSource.getPosition().y);
            }
        });
        startScrollMonitoring();
    },
    // Update the 'viewPreset' property manually since it's a public property of the TimelinePanel.
    onViewChange: function(panel) {
        // Both panels associated with timeaxis viewmodel will fire viewchange event, but partner will do it last. We
        // need to sync viewPreset but we cannot know here which one is correct. Thus we get it from viewmodel which
        // will store value passed to setViewPreset method of panel
        if (panel === this) {
            this.partnerTimelinePanel.viewPreset = this.viewPreset = this.timeAxisViewModel.viewPreset;
        }
    },
    onBeforeZoomChange: function() {
        var otherPanel = this.partnerTimelinePanel;
        var scrollable = otherPanel.getSchedulingView().getScrollable(),
            old = scrollable.suspendPartnerSync;
        scrollable.suspendPartnerSync = Ext.emptyFn;
        scrollable.on('scrollend', function() {
            scrollable.suspendPartnerSync = old;
        }, null, {
            single: true
        });
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/8118-ext-dom-element-addcls-overrides-existing-classes-on-svg-elements
Ext.define('Sch.patches.Element_6_7', {
    extend: 'Sch.util.Patch',
    target: [
        'Ext.dom.Element'
    ],
    minVersion: '6.7.0',
    applyFn: function() {
        Ext.override(Ext.dom.Element, {
            synchronize: function() {
                var result = this.callParent(arguments),
                    me = this,
                    dom = me.dom,
                    hasClassMap = {},
                    className = dom.className,
                    classList, name, i, ln,
                    elementData = me.getData(/* sync= */
                    false);
                if (window.SVGAnimatedString && className instanceof window.SVGAnimatedString) {
                    className = className.animVal;
                    if (className && className.length > 0) {
                        classList = className.split(/[\s]+/);
                        for (i = 0 , ln = classList.length; i < ln; i++) {
                            name = classList[i];
                            hasClassMap[name] = true;
                        }
                    }
                    elementData.classList = classList;
                    elementData.classMap = hasClassMap;
                    elementData.isSynchronized = true;
                }
                return result;
            }
        });
    }
});

// Sencha scrolls cell when clicking in the grid view, unwanted for our timeline view
// https://app.assembla.com/spaces/bryntum/tickets/realtime_list?page=2&ticket=3916
Ext.define('Sch.patches.NavigationModel6_0_2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '6.0.2',
    applyFn: function() {
        Ext.ClassManager.get(this.target).override({
            focusPosition: function(position) {
                var me = this;
                // PATCH Do not scroll into view cells from timeline view (gantt, scheduler, etc.)
                if (position && position.record && position.column && position.view && position.view._initializeTimelineView) {
                    var scroller = position.view.getScrollable();
                    if (scroller && scroller.scrollIntoView) {
                        var old = scroller.ensureVisible;
                        scroller.ensureVisible = Ext.emptyFn;
                        var retVal = this.callParent(arguments);
                        scroller.ensureVisible = old;
                        return retVal;
                    }
                }
                return this.callParent(arguments);
            }
        });
    }
});

//http://www.sencha.com/forum/showthread.php?295892-Ext-JS-5.1-Post-GA-Patches&p=1080371&viewfull=1#post1080371
Ext.define('Sch.patches.View', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.View',
    minVersion: '5.1.0',
    overrides: {
        handleEvent: function(e) {
            var me = this,
                isKeyEvent = me.keyEventRe.test(e.type),
                nm = me.getNavigationModel();
            e.view = me;
            // 1002_tabbing
            if (isKeyEvent) {
                e.item = e.getTarget(me.itemSelector);
                e.record = nm.getRecord(e.item);
            }
            // If the key event was fired programatically, it will not have triggered the focus
            // so the NavigationModel will not have this information.
            if (!e.item) {
                // In Ext6 editor is moved from outside of grid to cell, so now getTarget
                // will resolve item for event, which will trigger view events. Major implications are
                // selection triggered, editor is collapsed when view dragdrop plugin is active.
                // Here we check if target element lies inside active editor, if so - no item should be
                // resolved for event
                // covered by 1017_duration_editor_place
                var editing = me.editingPlugin && me.editingPlugin.getActiveEditor && me.editingPlugin.getActiveEditor();
                if (!(editing && editing.getEl().contains(e.getTarget()))) {
                    e.item = e.getTarget(me.itemSelector);
                }
            }
            if (e.item && !e.record) {
                e.record = me.getRecord(e.item);
            }
            if (me.processUIEvent(e) !== false) {
                me.processSpecialEvent(e);
            }
            // We need to prevent default action on navigation keys
            // that can cause View element scroll unless the event is from an input field.
            // We MUST prevent browser's default action on SPACE which is to focus the event's target element.
            // Focusing causes the browser to attempt to scroll the element into view.
            if (isKeyEvent && !Ext.fly(e.target).isInputField()) {
                if (e.getKey() === e.SPACE || e.isNavKeyPress(true)) {
                    e.preventDefault();
                }
            }
            e.view = null;
        }
    }
});

// ExtJs fires scrollEvent in updateDomScrollPosition in 6.5, while we call getScrollX often we silence the call
Ext.define('Sch.patches.Scroller_6_5', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.Scroller',
    minVersion: '6.5.0',
    maxVersion: '6.5.1.9999',
    overrides: {
        privates: {
            updateDomScrollPosition: function(silent) {
                var me = this,
                    position = me.position,
                    oldX = position.x,
                    oldY = position.y,
                    x, y, xDelta, yDelta;
                me.readPosition(position);
                x = position.x;
                y = position.y;
                me.positionDirty = false;
                if (!silent) {
                    xDelta = x - oldX;
                    yDelta = y - oldY;
                    // If we already know about the position. then we've been coerced there by a partner
                    // and that will have been firing our event sequence synchronously, so they do not
                    // not need to be fire in response to the ensuing scroll event.
                    if (!me.isScrolling) {
                        me.isScrolling = Ext.isScrolling = true;
                        me.fireScrollStart(x, y, xDelta, yDelta);
                    }
                    me.fireScroll(x, y, xDelta, yDelta);
                    me.bufferedOnDomScrollEnd(x, y, xDelta, yDelta);
                }
                return position;
            }
        },
        getPosition: function() {
            var me = this;
            if (me.positionDirty) {
                me.updateDomScrollPosition(true);
            }
            return me.position;
        }
    }
});

// In Ext 7.3.1 BufferedRenderer plugin focuses the view in `onRangeFetched` callback. Which eventually involves
// cell focus and cell position calculation. Problem is that at the point of `onRangeFetched` rows are actually rendered
// to the DOM, but position is not yet updated, so view is trying to scroll to wrong position.
// Covered by 8920_CellEditingPlugin.t
Ext.define('Sch.patches.Scroller_7_3', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.Scroller',
    minVersion: '7.3.1',
    overrides: {
        ensureVisible: function(el, options) {
            var me = this;
            var scroller = me.getLockingScroller && me.getLockingScroller();
            if (scroller && scroller.isScrolling) {
                return null;
            } else {
                return me.callParent(arguments);
            }
        }
    }
});

/**
 * Fixes viewPreset bind in test 40_calendar_basic
 */
Ext.define('Sch.patches.LayoutContext_6_5', {
    extend: 'Sch.util.Patch',
    target: 'Ext.layout.Context',
    minVersion: '6.5.0',
    overrides: {
        callLayout: function(layout, methodName) {
            this.currentLayout = layout;
            if (!layout.destroyed)  {
                layout[methodName](this.getCmp(layout.owner));
            }
            
        }
    }
});

// https://www.sencha.com/forum/showthread.php?310238-Tooltip-should-not-ignore-mouseover-event-on-touch-devices
// tips shouldn't be visible on touch devices at all
Ext.define('Sch.patches.ToolTip', {
    extend: 'Sch.util.Patch',
    target: 'Ext.tip.ToolTip',
    minVersion: '6.0.0',
    applyFn: function() {
        var overrides = {
                setTarget: function(target) {
                    var me = this;
                    if (me.target) {
                        var oldTarget = Ext.get(me.target);
                        // check if old target still exists on the page
                        if (oldTarget) {
                            me.mun(oldTarget, {
                                mouseover: me.onTargetOver,
                                tap: me.onTargetOver,
                                mouseout: me.onTargetOut,
                                mousemove: me.onMouseMove,
                                scope: me
                            });
                        }
                    }
                    me.target = Ext.get(target);
                    // check if new target exists on the page
                    if (me.target) {
                        me.mon(me.target, {
                            mouseover: me.onTargetOver,
                            tap: me.onTargetOver,
                            mouseout: me.onTargetOut,
                            mousemove: me.onMouseMove,
                            scope: me
                        });
                    }
                    if (me.anchor) {
                        me.anchorTarget = me.target;
                    }
                }
            };
        if (Ext.getVersion().isLessThan('6.0.2')) {
            overrides.afterSetPosition = function(x, y) {
                var me = this;
                me.callParent(arguments);
                if (me.anchor) {
                    if (!me.anchorEl.isVisible()) {
                        me.anchorEl.show();
                    }
                    // Sync anchor after it's visible, otherwise it'll be misplaced. Fixed in 6.0.2
                    // 1202_dragcreator
                    me.syncAnchor();
                } else {
                    me.anchorEl.hide();
                }
            };
        }
        Ext.ClassManager.get(this.target).override(overrides);
    }
});

Ext.define('Sch.patches.AbstractView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.AbstractView',
    minVersion: '6.2.0',
    obsoleteTestName: 'patches/002_abstract_view.t.js',
    overrides: {
        // to keep sanity/016_dom_footprint.t.js green
        setItemsDraggable: function(draggable) {
            var me = this,
                result;
            result = me.callParent([
                draggable
            ]);
            if (!draggable && me.viewStyleSheet && me.viewStyleSheet.cssRules.length === 0) {
                me.viewStyleSheet.ownerNode.parentNode.removeChild(me.viewStyleSheet.ownerNode);
                me.viewStyleSheet = Ext.view.AbstractView.prototype.viewStyleSheet = null;
            }
            return result;
        }
    }
});

// https://www.sencha.com/forum/showthread.php?470447-Spreadsheet-selection-is-broken-in-locked-grid-Ext-6-6-0
Ext.define('Sch.patches.SpreadsheetModel', {
    extend: 'Sch.util.Patch',
    // need to specify here to let `sencha app build` add it to the bundle
    requires: [
        'Ext.grid.selection.SpreadsheetModel'
    ],
    target: 'Ext.grid.selection.SpreadsheetModel',
    minVersion: '6.6.0',
    overrides: {
        privates: {
            onMouseMove: function(e, target, opts) {
                var me = this,
                    view = opts.view,
                    cell = e.getTarget(view.cellSelector),
                    header = opts.view.getHeaderByCell(cell),
                    selData = me.selected;
                //region OVERRIDE2
                var schedulingView;
                if (view.getSchedulingView) {
                    schedulingView = view.getSchedulingView();
                } else if (view.ownerGrid.getSchedulingView) {
                    schedulingView = view.ownerGrid.getSchedulingView();
                }
                // if mouse is moving over scheduling view - do nothing
                if (schedulingView && schedulingView._cmpCls && Ext.fly(target).up('.' + schedulingView._cmpCls)) {
                    return;
                }
                //endregion OVERRIDE2
                // when the mousedown happens in a checkcolumn, we need to verify is the mouse pointer has moved out of the initial clicked cell.
                // if it has, then we select the initial row and mark it as the range start, otherwise passing the lastOverRecord and return as
                // we don't want to select the record while moving the pointer around the initial cell.
                if (me.checkCellClicked) {
                    // We are dragging within the check cell...
                    if (cell === me.checkCellClicked) {
                        if (!me.lastOverRecord) {
                            me.lastOverRecord = view.getRecord(cell.parentNode);
                        }
                        return;
                    } else {
                        me.checkCellClicked = null;
                        if (me.lastOverRecord) {
                            me.select(me.lastOverRecord);
                            selData.setRangeStart(me.store.indexOf(me.lastOverRecord));
                        }
                    }
                }
                me.isDragging = true;
                // Disable until a valid new selection is announced in fireSelectionChange
                if (me.extensible) {
                    me.extensible.disable();
                }
                //region OVERRIDE
                if (header) {
                    me.changeSelectionRange(view, cell, header, e);
                } else {
                    // Ext.grid.locking.View doesn't have `body`, so check view.ownerGrid.body.el
                    var el = view.body ? view.body.el : view.ownerGrid.body.el;
                    if (!e.within(el)) {
                        me.scrollTowardsPointer(e, view);
                    }
                }
            }
        }
    }
});
//endregion OVERRIDE

// https://www.sencha.com/forum/showthread.php?471919-Task-name-is-changed-when-editor-is-moved-beyond-the-buffered-zone
// https://app.assembla.com/spaces/bryntum/tickets/8920-extjs-copies-value-from-one-cell-editor-to-another/details
Ext.define('Sch.patches.CellEditingPlugin', {
    extend: 'Sch.util.Patch',
    // need to specify here to let `sencha app build` add it to the bundle
    requires: [
        'Ext.grid.plugin.CellEditing'
    ],
    target: 'Ext.grid.plugin.CellEditing',
    minVersion: '6.7.0',
    maxVersion: '8.0.1',
    overrides: {
        disableBufferedRenderingSupport: true,
        // In 6.7.0 sencha tries to support buffered rendering while editing,
        // so when you scroll out of the active editor and then get back to the same row,
        // the cell editor appears on the screen as if it has never been vanished.
        // The bug appears when you scroll out of the active editor and double click a cell to start a new editing.
        // Then editor plugin restores cached editor with wrong value in it.
        // Attempt to fix the issue and keep the buffered rendering support enabled got failed,
        // because it raised complexity of the override and still had some bugs/side effects.
        // Since this Ext feature is too raw and buggy, we decided to temporary disable the caching
        // and apply `deactivate` method from 6.6.0 to ignore buffered rendering while scrolling.
        deactivate: function() {
            var me = this;
            if (me.disableBufferedRenderingSupport) {
                var context = me.context,
                    editors = me.editors.items,
                    len = editors.length,
                    editor, i;
                for (i = 0; i < len; i++) {
                    editor = editors[i];
                    // if we are deactivating the editor because it was de-rendered by a bufferedRenderer
                    // cycle (scroll while editing), we should cancel this active editing before caching
                    if (context.view.renderingRows) {
                        if (editor.editing) {
                            me.cancelEdit();
                        }
                        editor.cacheElement();
                    }
                }
            } else {
                me.callParent(arguments);
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?333029-Locked-view-is-not-synced-with-header-after-cell-clicked&p=1167293#post1167293
// Also https://www.sencha.com/forum/showthread.php?332451
// Covered by 1209_click_row_scroll
Ext.define('Sch.patches.TableScroller', {
    extend: 'Sch.util.Patch',
    minVersion: '6.2.1',
    maxVersion: '6.5.0',
    target: 'Ext.scroll.TableScroller',
    overrides: {
        privates: {
            onDomScroll: function() {
                var me = this,
                    position = me.position,
                    oldX = position.x,
                    oldY = position.y,
                    x, y, xDelta, yDelta;
                position = me.updateDomScrollPosition();
                if (me.restoreTimer) {
                    clearTimeout(me.onDomScrollEnd.timer);
                    return;
                }
                x = position.x;
                y = position.y;
                xDelta = x - oldX;
                yDelta = y - oldY;
                // If we already know about the position. then we've been coerced there by a partner
                // and that will have been firing our event sequence synchronously, so they do not
                // not need to be fire in response to the ensuing scroll event.
                // HACK removing condition to always fire scroll event
                if (!me.isScrolling) {
                    me.isScrolling = Ext.isScrolling = true;
                    me.fireScrollStart(x, y, xDelta, yDelta);
                }
                me.fireScroll(x, y, xDelta, yDelta);
                me.bufferedOnDomScrollEnd(x, y, xDelta, yDelta);
            },
            // Removing check for truthy value of xDelta/yDelta - we always need to invoke partner
            invokePartners: function(method, x, y, xDelta, yDelta) {
                var me = this,
                    partners = me._partners,
                    partner, id, axes;
                if (!me.suspendSync) {
                    me.invokingPartners = true;
                    for (id in partners) {
                        axes = partners[id].axes;
                        partner = partners[id].scroller;
                        // Only pass the scroll on to partners if we are are configured to pass on the scrolled dimension
                        if (!partner.invokingPartners) {
                            partner[method](me, axes.x ? x : null, axes.y ? y : null, xDelta, yDelta);
                        }
                    }
                    me.invokingPartners = false;
                }
            }
        }
    }
});

/**
 * Special tooltip class which is used to show information from {@link Sch.mixin.TimelineView#tooltipTpl} template
 *
 * Overrides some tooltip methods to properly align and constrain event tooltip within {@link Ext.component.constrainTo}
 * region with respect to {@link Ext.component.constraintInsets}.
 *
 * @private
 */
Ext.define("Sch.tooltip.EventTip", {
    extend: "Ext.tip.ToolTip",
    alias: "widget.scheduler_eventtip",
    uses: [
        'Ext.Number',
        'Ext.util.Format',
        'Ext.util.Region',
        'Ext.util.Point'
    ],
    config: {
        view: null
    },
    componentCls: 'sch-tooltip-eventtip',
    anchor: 't',
    constraintInsets: '7 -7 -7 7',
    allowOver: true,
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        me.on('beforeshow', me.onTipBeforeShow, me);
    },
    /**
     * This is mostly a direct copy {@link Ext.tip.Tooltip::getAlignRegion}.
     *
     * NOTE: please monitor this {@link https://www.sencha.com/forum/showthread.php?332162-Update-Ext-tip-Tooltip-getAlignRegion()-to-respect-constrainTo-and-constraintInsets}
     *       thread, to see when this method might be refactored.
     *
     * @private
     */
    getAlignRegion: function() {
        var me = this,
            anchorEl = me.anchorEl,
            align = me.getAnchorAlign(),
            overlap, alignSpec, target,
            mouseOffset = me.mouseOffset,
            // --- begin changes ---
            // Original ExtJS code:
            // Bryntum's changes:
            constrainTo, constraintInsets;
        // --- end changes ---
        if (!me.anchorSize) {
            anchorEl.addCls(Ext.baseCSSPrefix + 'tip-anchor-top');
            anchorEl.show();
            me.anchorSize = new Ext.util.Offset(anchorEl.getWidth(), anchorEl.getHeight());
            anchorEl.removeCls(Ext.baseCSSPrefix + 'tip-anchor-top');
            anchorEl.hide();
        }
        // Target region from the anchorTarget element unless trackMouse set
        if ((me.anchor || me.align) && me.anchorToTarget && !me.trackMouse) {
            target = me.currentTarget.getRegion();
            // --- begin changes ---
            // Original ExtJS code:
            // Bryntum's changes: (check to make sure element is still in the DOM, easily happens when scroll zooming)
            if (!Ext.isGarbage(me.currentTarget.dom) && me.getView().getMode() === 'horizontal' && me.pointerEvent) {
                target = target.intersect(new Ext.util.Region(target.top, me.pointerEvent.getPoint().x + me.getRegion().width / 2, target.bottom, // we cannot do: me.pointerEvent.getPoint().x - me.getRegion().width / 2
                // since it'll cause false failing of unscoped css rules test ..because minified it
                // looks similar to hardcoded extjs selector
                me.pointerEvent.getPoint().x + (-me.getRegion().width / 2))) || target;
            }
        } else // --- end changes ---
        // Here, we're either trackMouse: true, or we're not anchored to the target
        // element, so we should show offset from the mouse.
        // If we are being shown programatically, use 0, 0
        {
            target = me.pointerEvent ? me.pointerEvent.getPoint().adjust(-Math.abs(mouseOffset[1]), Math.abs(mouseOffset[0]), Math.abs(mouseOffset[1]), -Math.abs(mouseOffset[0])) : new Ext.util.Point();
            if (!me.anchor) {
                overlap = true;
                if (mouseOffset[0] > 0) {
                    if (mouseOffset[1] > 0) {
                        align = 'tl-br';
                    } else {
                        align = 'bl-tr';
                    }
                } else {
                    if (mouseOffset[1] > 0) {
                        align = 'tr-bl';
                    } else {
                        align = 'br-tl';
                    }
                }
            }
        }
        alignSpec = {
            align: me.convertPositionSpec(align),
            axisLock: me.axisLock,
            target: target,
            overlap: overlap,
            offset: me.targetOffset
        };
        // --- begin changes ---
        // Original ExtJS code:
        // inside: me.constrainPosition ? Ext.getBody().getRegion().adjust(5, -5, -5, 5) : null
        // Bryntum's changes:
        // --- end changes ---
        if (me.anchor) {
            alignSpec.anchorSize = me.anchorSize;
        }
        // --- begin changes ---
        // Original ExtJS code:
        // Bryntum's changes:
        if (me.constrainPosition) {
            constrainTo = me.constrainTo || Ext.getBody();
            if (!constrainTo.isRegion) {
                constrainTo = Ext.util.Region.getRegion(constrainTo);
            }
            if (me.constraintInsets) {
                constraintInsets = me.constraintInsets;
                if (!Ext.isObject(constraintInsets)) {
                    constraintInsets = Ext.util.Format.parseBox(constraintInsets);
                }
                constrainTo = constrainTo.copy().adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
            }
            alignSpec.inside = constrainTo;
        }
        // --- end changes ---
        return me.getRegion().alignTo(alignSpec);
    },
    // TODO: refactor this method
    onTipBeforeShow: function(me) {
        if (!me.triggerElement || !me.triggerElement.id) {
            return false;
        }
        var view = me.getView();
        // All visible modal windows on the page.
        var modalVisibleWindows = Ext.all('window[modal=true]{isVisible()}');
        // First modal window that is not a scheduler and doesn't contain scheduler inside.
        var activeModalWindow = Ext.Array.findBy(modalVisibleWindows, function(modalWindow) {
                return view !== modalWindow && !view.isDescendantOf(modalWindow) && Ext.WindowManager.getActive() === modalWindow;
            });
        // Tooltip should not be shown above task editor or other modal windows
        if (activeModalWindow)  {
            return false;
        }
        
        var record = view.resolveEventRecord(me.triggerElement);
        if (!record || view.fireEvent('beforetooltipshow', view, record) === false) {
            return false;
        }
        var dataForMe = view.getDataForTooltipTpl(record, me.triggerElement),
            tooltipString;
        if (!dataForMe)  {
            return false;
        }
        
        tooltipString = view.tooltipTpl.apply(dataForMe);
        if (!tooltipString)  {
            return false;
        }
        
        me.update(tooltipString);
    },
    // @Override to fix Sencha issue where tooltip autohides due to mouse over of its own element if Tooltip doesn't fit on screen
    // https://www.sencha.com/forum/showthread.php?469723-Inifinte-hide-show-loop-if-tooltip-appears-where-cursor-is
    // https://app.assembla.com/spaces/bryntum/tickets/5925-event-tooltip-hides-shows-infinitely-when-it-doesn--39-t-fit-on-the-screen/details#
    onTargetOut: function(e) {
        if (this.rendered && this.allowOver && this.el.contains(e.relatedTarget)) {
            return;
        }
        return this.callParent(arguments);
    }
});

/**
 @class Sch.mixin.TimelineView

 A base mixin for {@link Ext.view.View} classes, giving to the consuming view the "time line" functionality.
 This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

 By itself this mixin is not enough for correct rendering. The class, consuming this mixin, should also consume one of the
 {@link Sch.view.Horizontal}, {@link Sch.view.Vertical} or {@link Sch.view.WeekView} mixins, which provides the implementation of some mode-specfic methods.

 Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

 */
Ext.define("Sch.mixin.TimelineView", {
    extend: 'Sch.mixin.AbstractTimelineView',
    requires: [
        'Ext.tip.ToolTip',
        'Sch.patches.Element_6_7',
        'Sch.patches.NavigationModel6_0_2',
        'Sch.patches.View',
        'Sch.patches.Scroller_6_5',
        'Sch.patches.Scroller_7_3',
        'Sch.patches.LayoutContext_6_5',
        'Sch.patches.ToolTip',
        'Sch.patches.AbstractView',
        'Sch.patches.SpreadsheetModel',
        'Sch.patches.CellEditingPlugin',
        'Sch.patches.TableScroller',
        'Sch.tooltip.EventTip'
    ],
    tip: null,
    /**
     * @cfg {String} overScheduledEventClass
     * A CSS class to apply to each event in the view on mouseover (defaults to 'sch-event-hover').
     */
    overScheduledEventClass: 'sch-event-hover',
    ScheduleBarEvents: [
        "mousedown",
        "mouseup",
        "click",
        "dblclick",
        "longpress",
        "contextmenu"
    ],
    ResourceRowEvents: [
        "keydown",
        "keyup"
    ],
    // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations
    preventOverCls: false,
    // The last hovered over event bar HTML node
    hoveredEventNode: null,
    /**
     * @event beforetooltipshow
     * @preventable
     * Fires before the event tooltip is shown, return false to suppress it.
     * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
     * @param {Sch.model.Event} eventRecord The event record corresponding to the rendered event
     */
    /**
     * @event columnwidthchange
     * @private
     * Fires after the column width has changed
     */
    _initializeTimelineView: function() {
        this.callParent(arguments);
        this.on('destroy', this._onDestroy, this);
        this.on('afterrender', this._onAfterRender, this);
        this.setMode(this.mode);
        this.enableBubble('columnwidthchange');
        this.addCls("sch-timelineview");
        if (this.readOnly) {
            this.addCls(this._cmpCls + '-readonly');
        }
        this.addCls(this._cmpCls);
        if (this.eventAnimations) {
            this.addCls('sch-animations-enabled');
        }
    },
    handleScheduleBarEvent: function(e, eventBarNode) {
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecord(eventBarNode), e);
    },
    handleResourceRowEvent: function(e, resourceRowNode) {
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecordFromResourceRow(resourceRowNode), e);
    },
    // private, clean up
    _onDestroy: function() {
        if (this.tip) {
            this.tip.destroy();
        }
    },
    _onAfterRender: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
        if (this.tooltipTpl) {
            if (typeof this.tooltipTpl === 'string') {
                this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl);
            }
            this.el.on(Ext.supports.Touch ? 'touchstart' : 'mousemove', this.setupTooltip, this, {
                single: true
            });
        }
        this.setupTimeCellEvents();
        var eventBarListeners = {
                delegate: this.eventSelector,
                scope: this
            };
        var resourceRowListeners = {
                delegate: this.rowSelector,
                scope: this
            };
        Ext.Array.each(this.ScheduleBarEvents, function(name) {
            eventBarListeners[name] = this.handleScheduleBarEvent;
        }, this);
        Ext.Array.each(this.ResourceRowEvents, function(name) {
            resourceRowListeners[name] = this.handleResourceRowEvent;
        }, this);
        this.el.on(eventBarListeners);
        this.el.on(resourceRowListeners);
    },
    setMouseOverEnabled: function(enabled) {
        this[enabled ? "mon" : "mun"](this.el, {
            mouseover: this.onEventMouseOver,
            mouseout: this.onEventMouseOut,
            delegate: this.eventSelector,
            scope: this
        });
        if (!enabled) {
            this.getEl().select('.' + this.overScheduledEventClass).removeCls(this.overScheduledEventClass);
        }
    },
    // private
    onEventMouseOver: function(e, t) {
        if (t !== this.hoveredEventNode && !this.preventOverCls) {
            this.hoveredEventNode = t;
            Ext.fly(t).addCls(this.overScheduledEventClass);
            var eventModel = this.resolveEventRecord(t);
            // do not fire this event if model cannot be found
            // this can be the case for "sch-dragcreator-proxy" elements for example
            if (eventModel)  {
                this.fireEvent('eventmouseenter', this, eventModel, e);
            }
            
        }
    },
    // private
    onEventMouseOut: function(e, t) {
        if (this.hoveredEventNode) {
            if (!e.within(this.hoveredEventNode, true, true)) {
                Ext.fly(this.hoveredEventNode).removeCls(this.overScheduledEventClass);
                this.fireEvent('eventmouseleave', this, this.resolveEventRecord(this.hoveredEventNode), e);
                this.hoveredEventNode = null;
            }
        }
    },
    // Overridden since locked grid can try to highlight items in the unlocked grid while it's loading/empty
    highlightItem: function(item) {
        if (item) {
            var me = this;
            me.clearHighlight();
            me.highlightedItem = item;
            Ext.fly(item).addCls(me.overItemCls);
        }
    },
    // private
    setupTooltip: function() {
        var me = this,
            target = me.getEl();
        me.tip = new Sch.tooltip.EventTip(Ext.apply({
            view: me,
            delegate: me.eventSelector,
            target: target,
            showOnTap: true,
            // On hybrid mouse/touch systems, we want to show the tip on touch
            dismissDelay: 0,
            rtl: me.rtl
        }, me.tipCfg));
    },
    getHorizontalTimeAxisColumn: function() {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down('timeaxiscolumn');
            if (this.timeAxisColumn) {
                this.timeAxisColumn.on('destroy', function() {
                    this.timeAxisColumn = null;
                }, this);
            }
        }
        return this.timeAxisColumn;
    },
    /**
     * Template method to allow you to easily provide data for your {@link Sch.mixin.TimelinePanel#tooltipTpl} template.
     * @param {Sch.model.Range} record The event record corresponding to the HTML element that triggered the tooltip to show.
     * @param {HTMLElement} triggerElement The HTML element that triggered the tooltip.
     * @return {Object} The data to be applied to your template, typically any object or array.
     */
    getDataForTooltipTpl: function(record, triggerElement) {
        return Ext.apply({
            _record: record
        }, record.data);
    },
    /**
     * Refreshes the view and maintains the scroll position.
     */
    refreshKeepingScroll: function() {
        Ext.suspendLayouts();
        this.blockRestoringInfiniteScrollDate();
        this.refreshView();
        // we have to resume layouts before scroll in order to let element receive its new width after refresh
        Ext.resumeLayouts(true);
        this.resumeRestoringInfiniteScrollDate();
    },
    setupTimeCellEvents: function() {
        this.mon(this.el, {
            // `handleScheduleEvent` is an abstract method, defined in "SchedulerView" and "GanttView"
            click: this.handleScheduleEvent,
            dblclick: this.handleScheduleEvent,
            contextmenu: this.handleScheduleEvent,
            longpress: this.handleScheduleEvent,
            pinch: this.handleScheduleEvent,
            pinchstart: this.handleScheduleEvent,
            pinchend: this.handleScheduleEvent,
            scope: this
        });
    },
    getTableRegion: function() {
        var tableEl = this.el.down('.' + Ext.baseCSSPrefix + 'grid-item-container');
        // Also handle odd timing cases where the table hasn't yet been inserted into the dom
        return (tableEl || this.el).getRegion();
    },
    // Returns the row element for a given row record
    getRowNode: function(resourceRecord) {
        return this.getNodeByRecord(resourceRecord);
    },
    findRowByChild: function(t) {
        return this.findItemByChild(t);
    },
    getRecordForRowNode: function(node) {
        return this.getRecord(node);
    },
    /**
     * Refreshes the view and maintains the resource axis scroll position.
     */
    refreshKeepingResourceScroll: function() {
        var scroll = this.getScroll();
        this.refreshView();
        if (this.isHorizontal()) {
            this.scrollVerticallyTo(scroll.top);
        } else {
            this.scrollHorizontallyTo(scroll.left);
        }
    },
    scrollHorizontallyTo: function(x, animate) {
        if (this.rendered)  {
            this.scrollTo(x, null, animate);
        }
        
    },
    scrollVerticallyTo: function(y, animate) {
        if (this.rendered)  {
            this.scrollTo(null, y, animate);
        }
        
    },
    getVerticalScroll: function() {
        return this.getScrollY();
    },
    getHorizontalScroll: function() {
        return this.getScrollX();
    },
    getScroll: function() {
        var me = this;
        return {
            top: me.getVerticalScroll(),
            left: me.getHorizontalScroll()
        };
    },
    handleScheduleEvent: function() {},
    disableViewScroller: function(disabled) {
        var scroller = this.getScrollable();
        if (scroller) {
            if (scroller.setDisabled) {
                scroller.setDisabled(disabled);
            } else {
                var verticalScroller = this.up('timelinetree,timelinegrid').getScrollable();
                // Ext 6.2.0+ has vertical/horizontal scrolling implemented on different scrollers
                scroller.setConfig({
                    x: !disabled,
                    y: !disabled
                });
                verticalScroller.setConfig({
                    x: !disabled,
                    y: !disabled
                });
            }
        }
    },
    // Since Ext JS has different internal RTL behavior depending on presence of a Viewport,
    // we use this method to check if we need to adjust for RTL or if it's done internally in Ext
    shouldAdjustForRtl: function() {
        return this.rtl && !Ext.rootInheritedState.rtl;
    },
    // Decides whether to use 'left' or 'right' based on RTL mode
    getHorizontalPositionSide: function() {
        return this.rtl ? 'right' : 'left';
    },
    getViewContainerElementTop: function() {
        var el = this.up('timelinegrid,timelinetree').getView().el;
        return el.getY();
    },
    // Returns the height of the scrollable view area
    // https://www.sencha.com/forum/showthread.php?327418-6-2-Breaking-change-GridView-getHeight-contract-changed&p=1157660#post1157660
    getViewContainerHeight: function() {
        return this.up('timelinegrid,timelinetree').getView().el.getHeight();
    },
    getScrollableMaxPosition: function() {
        return {
            x: this.getScrollable().getMaxPosition().x,
            y: this.getVerticalScrollableMaxHeight()
        };
    },
    getVerticalScroller: function() {
        return this.up('timelinegrid,timelinetree').getScrollable();
    },
    getVerticalScrollableMaxHeight: function() {
        return this.getVerticalScroller().getMaxPosition().y;
    },
    getScrollableContainerRegion: function() {
        var region = this.getEl().getRegion();
        region.top = this.up('timelinegrid, timelinetree').getScrollable().getElement().getY();
        return new Ext.util.Region(region.top, region.right, region.top + this.getViewContainerHeight(), region.left);
    },
    scrollHorizontallyBy: function(deltaX, options) {
        // bug in ext https://support.sencha.com/#ticket-40066
        this.scrollBy(deltaX, null, options);
    },
    scrollVerticallyBy: function(deltaY, options) {
        var scrollable = this.up('timelinegrid, timelinetree').getScrollable();
        scrollable.scrollBy(0, deltaY, options);
    },
    // The code is copied from Ext.dom.Element.doScrollIntoView of Ext 6.2.1 and 6.0.2
    // Modified for including edgeOffset and calling callback function with passed scope
    scrollElementIntoView: function(el, hscroll, animate, highlight, edgeOffset, callback, scope) {
        var me = this,
            dom = el.dom,
            scroll = me.getScroll(),
            scrollX = scroll.left,
            scrollY = scroll.top,
            position = me.getScrollIntoViewXY(el, scrollX, scrollY, edgeOffset),
            newScrollX = position.x,
            newScrollY = position.y,
            x, y;
        x = hscroll !== false ? newScrollX : scrollX;
        y = newScrollY;
        if (x !== scrollX || y !== scrollY) {
            me.on({
                scrollend: {
                    fn: function() {
                        // Element could have been destroyed during scrolling
                        highlight && el.dom && el.highlight();
                        callback && callback.call(scope);
                    },
                    scope: me,
                    single: true
                }
            });
            me.scrollTo(x, y, animate);
        } else {
            // No scrolling needed
            highlight && el.dom && el.highlight();
            callback && callback.call(scope);
        }
        return me;
    },
    getScrollIntoViewXY: function(el, scrollX, scrollY, edgeOffset) {
        edgeOffset = Ext.isEmpty(edgeOffset) ? 20 : edgeOffset;
        // grid element is used to calculate view width and X offset
        // vertical scroll element is used to calculate view height and Y offset
        var gridEl = this.ownerCt.getEl(),
            verticalScrollEl = this.getVerticalScroller().getElement(),
            offsetToGrid = el.getOffsetsTo(gridEl),
            offsetToVerticalScroll = el.getOffsetsTo(verticalScrollEl),
            offsetX = offsetToGrid[0],
            offsetY = offsetToVerticalScroll[1],
            width = el.dom.offsetWidth,
            height = el.dom.offsetHeight,
            left = offsetX + scrollX,
            top = offsetY + scrollY,
            right = left + width,
            bottom = top + height,
            viewWidth = gridEl.getWidth(),
            viewHeight = verticalScrollEl.getHeight(),
            viewLeft = scrollX,
            viewTop = scrollY,
            viewRight = viewLeft + viewWidth,
            viewBottom = viewTop + viewHeight;
        /*
        Scroll direction is taken into account when scroll position is calculated
        so at the end it will look like natural scrolling
        we scroll to the event and stop as soon as we get to the event and leave some offset
        */
        // We scroll from bottom to the top (or if element > available view) and stop as soon as event is visible taking offset into account
        if (height > viewHeight || top < viewTop) {
            // Extract edgeOffset from top
            scrollY = top - edgeOffset;
        }
        // We scroll from top to the bottom and stop as soon as event is visible taking offset into account
        else if (bottom > viewBottom) {
            // Add edgeOffset to bottom
            scrollY = bottom - viewHeight + edgeOffset;
        }
        // We scroll from right to the left (or if element > available view) and stop as soon as event is visible taking offset into account
        if (width > viewWidth || left < viewLeft) {
            // Extract edgeOffset from left
            scrollX = left - edgeOffset;
        }
        // We scroll from left to the right and stop as soon as event is visible taking offset into account
        else if (right > viewRight) {
            // Add edgeOffset to right
            scrollX = right - viewWidth + edgeOffset;
        }
        // scrollX and scrollY positions should be from 0 to MAX, so need to adjust them in case they are less than 0
        scrollX = scrollX < 0 ? 0 : scrollX;
        scrollY = scrollY < 0 ? 0 : scrollY;
        return {
            x: scrollX,
            y: scrollY
        };
    }
});
// End of the copied code

/**

@class Sch.view.TimelineGridView
@extends Ext.grid.View
@mixins Sch.mixin.TimelineView

A grid view class, that consumes the {@link Sch.mixin.TimelineView} mixin. Used internally.

*/
Ext.define('Sch.view.TimelineGridView', {
    extend: 'Ext.grid.View',
    mixins: [
        'Sch.mixin.TimelineView'
    ],
    infiniteScroll: false,
    bufferCoef: 5,
    bufferThreshold: 0.2,
    // the scrolLeft position, as Date (not as pixels offset)
    cachedScrollDate: null,
    boxIsReady: false,
    ignoreNextHorizontalScroll: false,
    constructor: function(config) {
        this.callParent(arguments);
        // setup has to happen in the "afterrender" event, because at that point, the view is not "ready" yet
        // so we can freely change the start/end dates of the timeaxis and no refreshes will happen
        if (this.infiniteScroll) {
            this.on('boxready', this.setupInfiniteScroll, this);
        }
        if (this.timeAxisViewModel) {
            this.relayEvents(this.timeAxisViewModel, [
                'columnwidthchange'
            ]);
        }
    },
    setupInfiniteScroll: function() {
        var planner = this.panel.ownerCt;
        this.cachedScrollDate = planner.startDate || this.timeAxis.getStart();
        // check if it's touch microsoft
        if (Ext.getVersion().isLessThan('6.0.1') && Ext.supports.Touch && Ext.os.is.Windows) {
            var headerScroll = this.panel.headerCt.getScrollable();
            var viewScroll = this.getScrollable();
            // When scroll is done, Ext throws special event called 'idle'
            // Touch scroller handles that event and performs scroll to [0, 0]
            // Our 'scroll' event handler remembers new view start date and keeps it in memory
            // Disabling this handler seemingly doesn't break anything in case of infinite scroll enabled
            headerScroll.onIdle && Ext.GlobalEvents.un('idle', headerScroll.onIdle, headerScroll);
            viewScroll.onIdle && Ext.GlobalEvents.un('idle', viewScroll.onIdle, viewScroll);
        }
        var me = this;
        planner.calculateOptimalDateRange = function(centerDate, panelSize, nextZoomLevel, span) {
            if (span) {
                return span;
            }
            var preset = Sch.preset.Manager.getPreset(nextZoomLevel.preset);
            return me.calculateInfiniteScrollingDateRange(// me.ol.dom.scrollLeft can differ for obvious reasons thus method can return different result for same arguments
            // better user centerDate
            //me.getDateFromCoordinate(me.el.dom.scrollLeft, null, true),
            centerDate, preset.getBottomHeader().unit, nextZoomLevel.increment, nextZoomLevel.width, true);
        };
        // setup scroll/resize listeners
        this.bindInfiniteScrollListeners();
    },
    bindInfiniteScrollListeners: function() {
        this.getScrollable().on('scroll', this.onHorizontalScroll, this);
        this.infiniteScroll = true;
    },
    unbindInfiniteScrollListeners: function() {
        this.getScrollable().un('scroll', this.onHorizontalScroll, this);
        this.infiniteScroll = false;
    },
    onHorizontalScroll: function(scrollable, scrollLeft, scrollTop) {
        if (this.ignoreNextHorizontalScroll || this.cachedScrollDate) {
            this.ignoreNextHorizontalScroll = false;
            return;
        }
        var scrollbarSize = Ext.getScrollbarSize(),
            width = this.getWidth(),
            limit = width * this.bufferThreshold * this.bufferCoef,
            scrollWidth = this.getScrollable().getMaxPosition().x;
        // we cannot do: scrollWidth = this.getScrollable().getMaxPosition().x - scrollbarSize.width;
        // since it'll cause false failing of unscoped css rules test ..because minified it looks similar to
        // hardcoded extjs selector
        scrollWidth -= scrollbarSize.width;
        // if scroll violates limits let's shift timespan
        if ((scrollWidth - scrollLeft < limit) || scrollLeft < limit) {
            this.shiftToDate(this.getDateFromCoordinate(scrollLeft, null, true));
            // Make sure any scrolling which could have been triggered by the Bryntum ScrollManager (drag drop of task),
            // is cancelled
            // https://www.sencha.com/forum/showthread.php?331677-Animation-is-not-stopping&p=1164840#post1164840
            // Animation in 6.2.0 stopped differently
            if (Ext.getVersion().isGreaterThan('6.2.0')) {
                var translatable = this.getScrollable()._translatable || this.getScrollable().translatable;
                translatable && translatable.stopAnimation();
            } else {
                this.el.stopAnimation();
            }
        }
    },
    // TODO: investigate if we need this method now when we use refreshView instead
    refresh: function() {
        this.callParent(arguments);
        // `scrollStateSaved` will mean that refresh happens as part of `refreshKeepingScroll`,
        // which already does `restoreScrollState`, which includes `restoreScrollToCachedDate`
        if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
            this.restoreScrollToCachedDate();
        }
    },
    onResize: function(width, height, oldWidth, oldHeight) {
        this.boxIsReady = true;
        this.callParent(arguments);
        // TODO this should be optimized to not perform any operations as long as view size doesn't increase
        // enough to pass the buffer limits
        if (this.infiniteScroll && width > 0 && width !== oldWidth) {
            // When size increases - we should maintain the left visible date in the component to not confuse the user
            this.shiftToDate(this.cachedScrollDate || this.getVisibleDateRange().startDate, this.cachedScrollDateIsCentered);
        }
    },
    restoreScrollToCachedDate: function() {
        if (this.cachedScrollDate && this.boxIsReady) {
            this.ignoreNextHorizontalScroll = true;
            this.scrollToDate(this.cachedScrollDate);
            this.cachedScrollDate = null;
        }
    },
    scrollToDate: function(toDate) {
        this.cachedScrollDate = toDate;
        if (this.cachedScrollDateIsCentered) {
            this.panel.ownerCt.scrollToDateCentered(toDate);
        } else {
            this.panel.ownerCt.scrollToDate(toDate);
        }
        var scrollLeft = this.getScrollX();
        // the `onRestoreHorzScroll` method in Ext.panel.Table is called during Ext.resumeLayouts(true) (in the `refreshKeepingScroll`)
        // and messes up the scrolling position (in the called `syncHorizontalScroll` method).
        // Overwrite the property `syncHorizontalScroll` is using to read the scroll position, so that no actual change will happen
        this.panel.scrollLeftPos = scrollLeft;
        // the previous line however, breaks the header sync, doing that manually
        this.headerCt.setScrollX(scrollLeft);
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            // 6.2.0 is saving scroll position on updateLayout and restore shortly after. If we want to save
            // scroll position we have to override this saved scroll, or call scrollTo on scheduler grid/tree
            // 01_rendering
            this.up('timelinegrid,timelinetree').lastScrollPos.x = scrollLeft;
        }
    },
    // This method is raising flag to show there's no need to restore scroll in refresh method
    blockRestoringInfiniteScrollDate: function() {
        this.scrollStateSaved = this.boxIsReady;
    },
    resumeRestoringInfiniteScrollDate: function() {
        this.scrollStateSaved = false;
        // if we have scroll date then let's calculate left-coordinate by this date
        // and top-coordinate we'll get from the last saved scroll state
        if (this.infiniteScroll && this.cachedScrollDate) {
            this.restoreScrollToCachedDate();
        }
    },
    // `calculateOptimalDateRange` already exists in Zoomable plugin
    calculateInfiniteScrollingDateRange: function(date, unit, increment, tickWidth, centered) {
        var timeAxis = this.timeAxis,
            viewWidth = this.getWidth(),
            result;
        tickWidth = tickWidth || this.timeAxisViewModel.getTickWidth();
        increment = increment || timeAxis.increment || 1;
        unit = unit || timeAxis.unit;
        var DATE = Sch.util.Date;
        var bufferedTicks = Math.ceil(viewWidth * this.bufferCoef / tickWidth);
        // if provided date is the central point on the timespan
        if (centered) {
            var halfSpan = Math.ceil((viewWidth * (1 + this.bufferCoef)) / (2 * tickWidth)) * increment;
            result = {
                start: timeAxis.floorDate(DATE.add(date, unit, -halfSpan), false, unit, increment),
                end: timeAxis.ceilDate(DATE.add(date, unit, halfSpan), false, unit, increment)
            };
        } else // if provided date is the left coordinate of the visible timespan area
        {
            result = {
                start: timeAxis.floorDate(DATE.add(date, unit, -bufferedTicks * increment), false, unit, increment),
                end: timeAxis.ceilDate(DATE.add(date, unit, Math.ceil((viewWidth / tickWidth + bufferedTicks) * increment)), false, unit, increment)
            };
        }
        return result;
    },
    shiftToDate: function(date, centered) {
        var newRange = this.calculateInfiniteScrollingDateRange(date, null, null, null, centered);
        // we set scroll date here since it will be required during timeAxis.setTimeSpan() call
        this.cachedScrollDate = date;
        this.cachedScrollDateIsCentered = centered;
        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position
        this.timeAxis.setTimeSpan(newRange.start, newRange.end);
    },
    clearViewEl: function() {
        var me = this,
            secondaryCanvas = me.getSecondaryCanvasEl(),
            proxy = secondaryCanvas && secondaryCanvas.dom.querySelector('.' + Ext.baseCSSPrefix + 'dd-drag-proxy');
        proxy && secondaryCanvas.dom.removeChild(proxy);
        this.callParent(arguments);
        if (proxy) {
            me.getSecondaryCanvasEl().dom.appendChild(proxy);
        }
    },
    destroy: function() {
        if (this.infiniteScroll && this.rendered)  {
            this.unbindInfiniteScrollListeners();
        }
        
        this.callParent(arguments);
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/6645
Ext.define('Sch.patches.BoundList', {
    extend: 'Sch.util.Patch',
    requires: [
        'Ext.view.BoundList'
    ],
    target: 'Ext.view.BoundList',
    overrides: {
        // HTML encode combobox items if htmlEncode flag is true
        getInnerTpl: function(displayField) {
            return this.htmlEncode ? '{' + displayField + ':htmlEncode}' : this.callParent(arguments);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?306315-DragDrop-on-touch-monitor-doesn-t-work-when-page-is-scrolled
// Plus additions to support different drop groups on the same dom element
Ext.define('Sch.patches.DragDropManager', {
    extend: 'Sch.util.Patch',
    requires: [
        'Ext.dd.ScrollManager'
    ],
    target: 'Ext.dd.DragDropManager',
    minVersion: '6.0.0',
    applyFn: function() {
        Ext.override(Ext.dd.DragDropManager, {
            handleMouseMove: function(e) {
                var me = this,
                    current = me.dragCurrent,
                    point = e.getXY(),
                    currentX = point[0],
                    currentY = point[1],
                    diffX, diffY;
                me.offsetX = currentX - me.startX;
                me.offsetY = currentY - me.startY;
                me.currentPoint.setPosition(point);
                if (!current) {
                    return true;
                }
                if (!me.dragThreshMet) {
                    diffX = Math.abs(me.offsetX);
                    diffY = Math.abs(me.offsetY);
                    if (diffX > me.clickPixelThresh || diffY > me.clickPixelThresh) {
                        e.claimGesture();
                        me.startDrag(me.startX, me.startY);
                    }
                }
                /* OVERRIDE TO TAKE INTO ACCOUNT THAT DRAG MIGHT HAVE BEEN ABORTED IN startDrag
                * Some Ext DD classes (Ext.panel.DD) overwrites startDrag which breaks setting the dragging property.
                */
                if (me.dragThreshMet && (!current.checkDraggingFlag || current.dragging)) {
                    current.b4Drag(e);
                    current.onDrag(e);
                    if (!current.moveOnly) {
                        me.fireEvents(e, false);
                    }
                }
                me.stopEvent(e);
                return true;
            },
            fireEvents: function(e, isDrop) {
                var me = this,
                    isTouch = Ext.supports.Touch,
                    dragCurrent = me.dragCurrent,
                    mousePoint = me.currentPoint,
                    currentX = mousePoint.x,
                    currentY = mousePoint.y,
                    allTargets = [],
                    oldOvers = [],
                    // cache the previous dragOver array
                    outEvts = [],
                    overEvts = [],
                    dropEvts = [],
                    enterEvts = [],
                    zoom = isTouch ? document.documentElement.clientWidth / window.innerWidth : 1,
                    dragEl, overTarget, overTargetEl, needsSort, i, len, sGroup, overDragEl;
                // If the user did the mouse up outside of the window, we could
                // get here even though we have ended the drag.
                if (!dragCurrent || dragCurrent.isLocked()) {
                    return;
                }
                // Touch's delegated event system means that the mousemove (which will be a touchmove really) target will be the element that the listener was requested for, NOT the actual lowest
                // level target . So we have to use elementFromPoint to find the target which we are currently over.
                // If we need to use the current mousemove target to find the over el,
                // but pointer-events is not supported, AND the delta position does not place the mouse outside of the dragEl,
                // temporarily move the dragEl away, and fake the mousemove target by using document.elementFromPoint
                // while it's out of the way.
                // The pointer events implementation is bugged in Opera, so fallback
                overDragEl = !(dragCurrent.deltaX < 0 || dragCurrent.deltaY < 0);
                if (isTouch || (!me.notifyOccluded && (!Ext.supports.CSSPointerEvents || Ext.isOpera) && overDragEl)) {
                    dragEl = dragCurrent.getDragEl();
                    // Temporarily hide the dragEl instead of moving it off the page.
                    // Moving the el off the page can cause problems when in an iframe with IE8 standards.
                    // See EXTJSIV-11728
                    if (overDragEl) {
                        dragEl.style.visibility = 'hidden';
                    }
                    // PATCH
                    // we need to take vertical scroll into account
                    var bodyScroll = Ext.getBody().getScroll();
                    e.target = document.elementFromPoint(e.clientX - bodyScroll.left / zoom, e.clientY - bodyScroll.top / zoom);
                    if (overDragEl) {
                        dragEl.style.visibility = 'visible';
                    }
                }
                // END PATCH
                // Check to see if the object(s) we were hovering over is no longer
                // being hovered over so we can fire the onDragOut event
                for (i in me.dragOvers) {
                    overTarget = me.dragOvers[i];
                    delete me.dragOvers[i];
                    // Check to make sure that the component hasn't been destroyed in the middle of a drag operation.
                    if (!me.isTypeOfDD(overTarget) || overTarget.destroyed) {
                        
                        continue;
                    }
                    // If notifyOccluded set, we use mouse position
                    if (me.notifyOccluded) {
                        if (!this.isOverTarget(mousePoint, overTarget, me.mode)) {
                            outEvts.push(overTarget);
                        }
                    } else // Otherwise we use event source of the mousemove event
                    {
                        if (!e.within(overTarget.getEl())) {
                            outEvts.push(overTarget);
                        }
                    }
                    oldOvers[i] = true;
                }
                // Collect all targets which are members of the same ddGoups that the dragCurrent is a member of, and which may recieve mouseover and drop notifications.
                // This is preparatory to seeing which one(s) we are currently over
                // Begin by iterating through the ddGroups of which the dragCurrent is a member
                for (sGroup in dragCurrent.groups) {
                    if ("string" !== typeof sGroup) {
                        
                        continue;
                    }
                    // Loop over the registered members of each group, testing each as a potential target
                    for (i in me.ids[sGroup]) {
                        overTarget = me.ids[sGroup][i];
                        // The target is valid if it is a DD type
                        // And it's got a DOM element
                        // And it's configured to be a drop target
                        // And it's not locked
                        // And the DOM element is fully visible with no hidden ancestors
                        // And it's either not the dragCurrent, or, if it is, tha dragCurrent is configured to not ignore itself.
                        if (me.isTypeOfDD(overTarget) && (overTargetEl = overTarget.getEl()) && (overTarget.isTarget) && (!overTarget.isLocked()) && (Ext.fly(overTargetEl).isVisible(true)) && ((overTarget !== dragCurrent) || (dragCurrent.ignoreSelf === false))) {
                            // If notifyOccluded set, we use mouse position
                            if (me.notifyOccluded) {
                                // Only sort by zIndex if there were some which had a floating zIndex value
                                if ((overTarget.zIndex = me.getZIndex(overTargetEl)) !== -1) {
                                    needsSort = true;
                                }
                                allTargets.push(overTarget);
                            } else // Otherwise we use event source of the mousemove event
                            {
                                if (e.within(overTarget.getEl())) {
                                    allTargets.push(overTarget);
                                    break;
                                }
                            }
                        }
                    }
                }
                // If there were floating targets, sort the highest zIndex to the top
                if (needsSort) {
                    Ext.Array.sort(allTargets, me.byZIndex);
                }
                // Loop through possible targets, notifying the one(s) we are over.
                // Usually we only deliver events to the topmost.
                for (i = 0 , len = allTargets.length; i < len; i++) {
                    overTarget = allTargets[i];
                    // If we are over the overTarget, queue it up to recieve an event of whatever type we are handling
                    if (me.isOverTarget(mousePoint, overTarget, me.mode)) {
                        // look for drop interactions
                        if (isDrop) {
                            dropEvts.push(overTarget);
                        } else // look for drag enter and drag over interactions
                        {
                            // initial drag over: dragEnter fires
                            if (!oldOvers[overTarget.id]) {
                                enterEvts.push(overTarget);
                            } else // subsequent drag overs: dragOver fires
                            {
                                overEvts.push(overTarget);
                            }
                            me.dragOvers[overTarget.id] = overTarget;
                        }
                        // Unless this DragDropManager has been explicitly configured to deliver events to multiple targets, then we are done.
                        if (!me.notifyOccluded) {
                            break;
                        }
                    }
                }
                if (me.mode) {
                    if (outEvts.length) {
                        dragCurrent.b4DragOut(e, outEvts);
                        dragCurrent.onDragOut(e, outEvts);
                    }
                    if (enterEvts.length) {
                        dragCurrent.onDragEnter(e, enterEvts);
                    }
                    if (overEvts.length) {
                        dragCurrent.b4DragOver(e, overEvts);
                        dragCurrent.onDragOver(e, overEvts);
                    }
                    if (dropEvts.length) {
                        dragCurrent.b4DragDrop(e, dropEvts);
                        dragCurrent.onDragDrop(e, dropEvts);
                    }
                } else {
                    // fire dragout events
                    for (i = 0 , len = outEvts.length; i < len; ++i) {
                        dragCurrent.b4DragOut(e, outEvts[i].id);
                        dragCurrent.onDragOut(e, outEvts[i].id);
                    }
                    // fire enter events
                    for (i = 0 , len = enterEvts.length; i < len; ++i) {
                        // dc.b4DragEnter(e, oDD.id);
                        //                          To support several drop groups on the same DOM element
                        //                                             vvvvvvv
                        dragCurrent.onDragEnter(e, enterEvts[i].id, enterEvts[i]);
                    }
                    // fire over events
                    for (i = 0 , len = overEvts.length; i < len; ++i) {
                        dragCurrent.b4DragOver(e, overEvts[i].id);
                        dragCurrent.onDragOver(e, overEvts[i].id);
                    }
                    // fire drop events
                    for (i = 0 , len = dropEvts.length; i < len; ++i) {
                        dragCurrent.b4DragDrop(e, dropEvts[i].id);
                        dragCurrent.onDragDrop(e, dropEvts[i].id);
                    }
                }
                // notify about a drop that did not find a target
                if (isDrop && !dropEvts.length) {
                    dragCurrent.onInvalidDrop(e);
                }
            }
        });
        // This code is required to support several drop groups on the same DOM element
        // -------------------------------------------------------------------------------------
        Ext.override(Ext.dd.DragSource, {
            onDragEnter: function(e, id, forceTarget) {
                this.forceCachedTarget = forceTarget;
                return this.callParent([
                    e,
                    id
                ]);
            },
            beforeDragEnter: function(target, e, id) {
                if (this.forceCachedTarget) {
                    target = this.cachedTarget = this.forceCachedTarget;
                    delete this.forceCachedTarget;
                }
                return this.callParent([
                    target,
                    e,
                    id
                ]);
            }
        });
        // -------------------------------------------------------------------------------------
        // We just overrode fireEvents method that is used in createSequence in scroll manager
        // so sequence was dropped and we need to create new. Check constructor in Ext.dd.ScrollManager
        var sm = Ext.dd.ScrollManager;
        var ddm = Ext.dd.DragDropManager;
        ddm.fireEvents = Ext.Function.createSequence(ddm.fireEvents, sm.onFire, sm);
        ddm.stopDrag = Ext.Function.createSequence(ddm.stopDrag, sm.onStop, sm);
    }
});

// We patched grid navigation model to not focus rows in normal view in order to save scroll in IE
// this is why under some conditions keyevent contain wrong view and target. This can break navigation
// 2117_key_navigation
Ext.define('Sch.patches.NavigationModel', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.NavigationModel',
    minVersion: '6.0.0',
    overrides: {
        setPosition: function(recordIndex, columnIndex, keyEvent, suppressEvent, preventNavigation) {
            var me = this;
            // We need to only handle pageup/pagedown keys, because they call setPosition(record, null,...) which trigger
            // special path that leads to error when there's lastFocused property that holds
            // column from normal view and current view is locked
            // #2428
            if (Ext.isIE && keyEvent && (keyEvent.getKey() === keyEvent.PAGE_DOWN || keyEvent.getKey() === keyEvent.PAGE_UP)) {
                var lastFocused = me.lastFocused;
                if (keyEvent.view.isLockedView && lastFocused && keyEvent.view.getVisibleColumnManager().indexOf(lastFocused.column) === -1) {
                    keyEvent.view = keyEvent.view.lockingPartner;
                }
            }
            return me.callParent(arguments);
        },
        // https://app.assembla.com/spaces/bryntum/tickets/4595
        onCellClick: function(view, cell, cellIndex, record, row, recordIndex, clickEvent) {
            this.callParent(arguments);
            if (clickEvent.position.column.cellFocusable === false) {
                if (view.isNormalView) {
                    if (Ext.isIE11m) {
                        view.ownerCt.el.focus();
                    } else {
                        if (!this.lastFocused) {
                            view.el.focus();
                        }
                    }
                }
            }
        }
    }
});

/**
 * @class Sch.view.WeekView
 * @private
 *
 * A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation
 * of some methods, specific to weekview mode.
 */
Ext.define('Sch.view.WeekView', {
    requires: [
        'Ext.util.Region'
    ],
    // Provided by creator, in the config object
    view: null,
    /**
     * @cfg {Boolean} showAllDayHeader Shows an all day header above the main schedule for All Day events.
     */
    showAllDayHeader: false,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        var me = this,
            view = me.view,
            query, result;
        raw = raw || false;
        if (index !== null && index !== undefined) {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-calendar-' + index + '-]';
        } else {
            query = '[id^=' + view.eventPrefix + eventRecord.internalId + '-calendar-]';
        }
        result = view.getEl().query(query, raw);
        // When record changes status to allday it is rendered into allday header before update event is handled by
        // this view. This leads to situation when there are multiple DOM elements for one record: one in allday header
        // and one in weekview. It is easier to return all elements for passed record and filter them later.
        if (me.showAllDayHeader && eventRecord.getAllDay()) {
            [].push.apply(result, me.view.ownerGrid.allDayNormalHeader.getSchedulingView().getElementsFromEventRecord(eventRecord, resourceRecord, index, raw));
        }
        return result;
    },
    // return columns that passes condition
    // if includeIndex is true then column index is also returned
    getColumnsBy: function(conditionFn, includeIndex) {
        var columns = this.view.panel.headerCt.getGridColumns();
        var result = [];
        for (var i = 0; i < columns.length; i++) {
            if (conditionFn.call(this, columns[i])) {
                if (includeIndex !== true) {
                    result.push(columns[i]);
                } else {
                    result.push({
                        column: columns[i],
                        index: i
                    });
                }
            }
        }
        return result;
    },
    getColumnsForDateRange: function(range, includeIndex) {
        return this.getColumnsBy(function(column) {
            return !(range.getEndDate() <= column.start || range.getStartDate() >= column.end);
        }, includeIndex);
    },
    getColumnEvents: function(column) {
        var me = this,
            result = [];
        this.view.getEventStore().each(function(record) {
            if (!(me.showAllDayHeader && record.getAllDay()) && !(record.getEndDate() <= column.start || record.getStartDate() >= column.end)) {
                result.push(record);
            }
        });
        return result;
    },
    getColumnsByResource: function(resource, includeIndex) {
        return this.getColumnsBy(function(column) {
            return column.start == resource.start;
        }, includeIndex)[0];
    },
    translateToScheduleCoordinate: function(coord) {
        var view = this.view;
        if (Ext.isArray(coord)) {
            return [
                coord[0] - view.getEl().getX() + view.getHorizontalScroll(),
                coord[1] - view.getViewContainerElementTop() + view.getVerticalScroll()
            ];
        } else {
            return coord - view.getViewContainerElementTop() + view.getVerticalScroll();
        }
    },
    // private
    translateToPageCoordinate: function(coord) {
        var view = this.view;
        var el = view.getEl();
        if (Ext.isArray(coord)) {
            return [
                coord[0] + el.getX() - view.getHorizontalScroll(),
                coord[1] + view.getViewContainerElementTop() - view.getVerticalScroll()
            ];
        } else {
            return coord + view.getViewContainerElementTop() - view.getVerticalScroll();
        }
    },
    getDateFromXY: function(xy, roundingMethod, local) {
        var coord = xy;
        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },
    getEventRenderData: function(event, resource, resourceIndex) {
        var eventStart = event.getStartDate(),
            eventEnd = event.getEndDate(),
            view = this.view,
            columns = view.panel.headerCt.getGridColumns(),
            viewStart = columns[resourceIndex].start,
            viewEnd = columns[resourceIndex].end,
            M = Math;
        var startY = Math.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)));
        var endY = Math.floor(view.timeAxisViewModel.getPositionFromDate(Sch.util.Date.min(eventEnd, viewEnd), true));
        var data;
        // in weekview we duplicate time for end of column and start of next column
        // if we got 0 that means end is in fact column bottom
        if (endY === 0) {
            endY = view.getStore().getCount() * view.getRowHeight();
        }
        data = {
            top: M.max(0, M.min(startY, endY) - view.eventBorderWidth),
            height: M.max(1, M.abs(startY - endY))
        };
        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;
        return data;
    },
    // we consider resourceRecord to be date
    getScheduleRegion: function(resourceRecord, eventRecord) {
        var view = this.view,
            region = resourceRecord ? this.getColumnsByResource(resourceRecord).getRegion() : view.getTableRegion(),
            startY = this.translateToPageCoordinate(0),
            endY = this.translateToPageCoordinate(view.getStore().getCount() * view.getRowHeight()),
            left = region.left + view.barMargin,
            right = region.right - view.barMargin;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    getWeekViewColumnWidth: function() {
        return this.view.timeAxisViewModel.weekViewColumnWidth;
    },
    /**
     * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
     * @param {Sch.model.Resource} resourceRecord The resource record
     * @param {Date} startDate A start date constraining the region
     * @param {Date} endDate An end date constraining the region
     * @return {Ext.util.Region} The region of the resource
     */
    getResourceRegion: function(resourceRecord, startDate, endDate) {
        var view = this.view,
            cellLeft = view.getResourceStore().indexOf(resourceRecord) * this.getWeekViewColumnWidth(),
            taStart = view.timeAxis.getStart(),
            taEnd = view.timeAxis.getEnd(),
            start = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left = cellLeft + view.cellBorderWidth,
            right = cellLeft + this.getWeekViewColumnWidth() - view.cellBorderWidth;
        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },
    columnRenderer: function(val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';
        if (rowIndex === 0) {
            var columnEvents, dayEvents, i, l;
            columnEvents = [];
            dayEvents = this.getColumnEvents(meta.column);
            // Iterate events (belonging to current resource)
            for (i = 0 , l = dayEvents.length; i < l; i++) {
                var event = dayEvents[i],
                    data = view.generateTplData(event, event.getResources()[0], colIndex);
                // resourceRecord is a timeAxis tick, we should try to get real resource
                data && columnEvents.push(data);
            }
            if (meta.column.rendered && this.getWeekViewColumnWidth() !== meta.column.getWidth()) {
                this.setColumnWidth(meta.column.getWidth(), true);
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getWeekViewColumnWidth() - (2 * view.barMargin) - view.cellBorderWidth);
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }
        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }
        return retVal;
    },
    // private
    // TODO Doesn't make any sense since columns and rows do not represent a resource! Has to return null.
    resolveResource: function(el) {
        var view = this.view;
        el = Ext.fly(el).is(view.timeCellSelector) ? el : Ext.fly(el).up(view.timeCellSelector);
        if (el) {
            var node = el.dom ? el.dom : el;
            var index = 0;
            index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
            if (index >= 0) {
                // TODO: unsafe
                var column = view.panel.headerCt.getGridColumns()[index];
                return {
                    start: column.start,
                    end: column.end
                };
            }
        }
    },
    // private
    onEventUpdate: function(store, model) {
        if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered)  {
            return;
        }
        
        this.renderSingle(model);
        // restore visual event selection
        var view = this.view;
        var sm = view.getEventSelectionModel();
        sm.forEachEventRelatedSelection(model, function(selectedRecord) {
            view.onEventBarSelect(selectedRecord);
        });
    },
    // private
    onEventAdd: function(s, recs) {
        if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered)  {
            return;
        }
        
        var view = this.view;
        if (recs.length === 1) {
            this.renderSingle(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },
    // private
    onEventRemove: function(s, recs) {
        if (!this.view.rendered || !this.view.headerCt.items.get(0).rendered)  {
            return;
        }
        
        var view = this.view;
        if (recs.length === 1) {
            // remove nodes from view
            Ext.Array.each(view.getElementsFromEventRecord(recs[0], undefined, undefined, true), function(el) {
                Ext.fly(el).destroy();
            });
            this.relayoutRenderedEvents(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },
    relayoutRenderedEvents: function(targetEvent) {
        var me = this,
            columns = me.getColumnsForDateRange(targetEvent, true);
        // When event is rendered into multiple columns each part should behave like separate event.
        // For example, event is rendered into two columns. User created new event and dropped it so
        // new one is overlapping with old one in second column. Desired behavior is following:
        // part in the first column is untouched and part of old event in second column takes only half width.
        Ext.Array.each(columns, function(column) {
            me.repaintEventsForColumn(column.column, column.index);
        });
    },
    renderSingle: function(event) {
        var view = this.view;
        // remove rendered event nodes
        Ext.Array.each(this.getElementsFromEventRecord(event, undefined, undefined, true), function(el) {
            // Only remove elements that are inside weekview
            if (view.el.isAncestor(el)) {
                Ext.fly(el).destroy();
            }
        });
        var previous = event.previous || {};
        var UD = Sch.util.Date;
        // relayout all affected columns
        var timeSpan = new Sch.model.Range({
                StartDate: UD.min(previous[event.startDateField] || event.getStartDate(), event.getStartDate()),
                EndDate: UD.max(previous[event.endDateField] || event.getEndDate(), event.getEndDate())
            });
        var columns = this.getColumnsForDateRange(timeSpan);
        Ext.Array.each(columns, function(column) {
            var columnIndex = column.getIndex();
            // gather rendered events data to apply layout and calculate new correct size
            var events = this.getColumnEvents(column);
            var eventRenderData = Ext.Array.map(events, function(record) {
                    if (record === event) {
                        // append new render data for new event
                        return view.generateTplData(event, event.getResources()[0], columnIndex);
                    } else {
                        return {
                            start: record.getStartDate() < column.start ? column.start : record.getStartDate(),
                            end: record.getEndDate() > column.end ? column.end : record.getEndDate(),
                            event: record
                        };
                    }
                });
            view.eventLayout.vertical.applyLayout(eventRenderData, column.getWidth() - (2 * view.barMargin) - view.cellBorderWidth);
            // refresh rendered events
            Ext.Array.each(eventRenderData, function(renderData) {
                if (renderData.event === event) {
                    // render new event
                    var containerCell = view.getScheduleCell(0, columnIndex);
                    // if grid content is not yet rendered, then just do nothing
                    if (containerCell) {
                        if (!Ext.versions.touch) {
                            containerCell = Ext.fly(containerCell).first();
                        }
                        view.eventTpl.append(containerCell, [
                            renderData
                        ]);
                    }
                } else {
                    var eventNode = view.getElementsFromEventRecord(renderData.event, null, columnIndex)[0];
                    // Element could be missing if view is hidden and a store load happened while hidden
                    // since Ext JS blocks view refreshes while view is hidden
                    if (eventNode) {
                        eventNode.setStyle({
                            left: renderData.left + 'px',
                            width: Math.max(renderData.width, 0) + 'px'
                        });
                    }
                }
            });
        }, this);
    },
    repaintEventsForColumn: function(column, index) {
        var me = this;
        var events = me.getColumnEvents(column);
        var view = me.view;
        var data = [],
            i, l, event, node, start, end;
        for (i = 0 , l = events.length; i < l; i++) {
            event = events[i];
            node = view.getElementsFromEventRecord(event, undefined, undefined, true)[0];
            // nothing is rendered yet
            if (!node) {
                return;
            }
            // each event node if weekview has column index in it
            // we need a common id without column index, so we perform split/pop/join
            var commonId = node.id.split('-');
            commonId.pop();
            start = event.getStartDate();
            end = event.getEndDate();
            // simulate one-column events for vertical layout
            data.push({
                start: start < column.start ? column.start : start,
                end: end > column.end ? column.end : end,
                event: event,
                id: commonId.join('-')
            });
        }
        view.eventLayout.vertical.applyLayout(data, column.getWidth() - (2 * view.barMargin) - view.cellBorderWidth);
        // We render events into first row in the table so we need this element to make lookups.
        var rowNode = view.getNode(0);
        for (i = 0; i < data.length; i++) {
            event = data[i];
            // We should only touch events (event's parts) that are rendered into changed column.
            // Since parts of one event share element id we have to look up in certain cell.
            var selector = 'td:nth-child(' + (index + 1) + ') [id^=' + event.id + '-]';
            node = Ext.dom.Query.selectNode(selector, rowNode);
            // for the case when we relayout short event
            node && Ext.fly(node).setStyle({
                left: event.left + 'px',
                width: Math.max(event.width, 0) + 'px'
            });
        }
    },
    /**
     *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
     *  @param {Date} startDate The start date of the span
     *  @param {Date} endDate The end date of the span
     *  @return {Ext.util.Region} The region for the time span
     */
    getTimeSpanRegion: function(startDate, endDate) {
        var view = this.view,
            startY = view.getCoordinateFromDate(startDate),
            endY = endDate ? view.timeAxisViewModel.getPositionFromDate(endDate, true) : startY;
        // We have to use real columns here to get correct horizontal position, if we try to calculate
        // position via cached column dates and column width - zones will be misplaced.
        // E.g. we have 7 columns to fit into 69px wide view, then last column will be 9px wide and others - 10px wide
        // cached column width will be same 9px and if we will draw zone in 6th column it's left position will be
        // 9 * 6 = 54 and while it should be 60
        var startColumn = this.getColumnsBy(function(column) {
                return column.start <= startDate && column.end > startDate;
            })[0];
        var endColumn = this.getColumnsBy(function(column) {
                return column.start < endDate && column.end >= endDate;
            })[0];
        if (!startColumn || !endColumn || !startColumn.rendered || !endColumn.rendered) {
            return new Ext.util.Region(-1, 0, -1, 0);
        }
        var pair1 = this.translateToScheduleCoordinate([
                startColumn.getX(),
                0
            ]);
        var pair2 = this.translateToScheduleCoordinate([
                endColumn ? endColumn.getRegion().right : startColumn.getWidth() + pair1[0],
                0
            ]);
        return new Ext.util.Region(Math.min(startY, endY), pair2[0], Math.max(startY, endY), pair1[0]);
    },
    /**
     * Gets the start and end dates for an element Region
     * @param {Ext.util.Region} region The region to map to start and end dates
     * @param {String} roundingMethod The rounding method to use
     * @returns {Object} an object containing start/end properties
     */
    getStartEndDatesFromRegion: function(region, roundingMethod) {
        var topDate = this.view.getDateFromCoordinate([
                region.left,
                region.top
            ], roundingMethod),
            bottomDate = this.view.getDateFromCoordinate([
                region.left,
                region.bottom
            ], roundingMethod);
        if (topDate && bottomDate) {
            return {
                start: topDate,
                end: bottomDate
            };
        } else {
            return null;
        }
    },
    setColumnWidth: function(width, preventRefresh) {
        var view = this.view;
        view.weekViewColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },
    /**
     * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
     * @return {Object} object with `startDate` and `endDate` properties.
     */
    getVisibleDateRange: function() {
        var view = this.view;
        if (!view.rendered) {
            return null;
        }
        var scroll = view.getScroll(),
            height = view.getViewContainerHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();
        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate = view.timeAxis.getStart();
            return {
                startDate: startDate,
                endDate: viewEndDate
            };
        }
        return {
            startDate: view.getDateFromCoordinate(scroll.top, null, true),
            endDate: view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    },
    /**
     * Gets box for displaying item disgnated by the record. If there're several boxes are displayed for the given
     * item then the method returns all of them
     *
     * @param {Sch.model.Event} eventRecord
     * @return {Object/Object[]/Null}
     * @return {Number} return.top
     * @return {Number} return.bottom
     * @return {Number} return.start
     * @return {Number} return.end
     * @return {Boolean} return.rendered
     */
    getItemBox: function(eventRecord) {
        return null;
    },
    /**
     * Gets displaying item start side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorStartSide: function(eventRecord) {
        return 'top';
    },
    /**
     * Gets displaying item end side
     *
     * @param {Sch.model.Event} eventRecord
     * @return {String} 'left' / 'right' / 'top' / 'bottom'
     */
    getConnectorEndSide: function(eventRecord) {
        return 'bottom';
    }
});

/**

 @class Sch.mixin.SchedulerView

 A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
 should have already consumed the {@link Sch.mixin.TimelineView} mixin.

 Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

 */
Ext.define('Sch.mixin.SchedulerView', {
    extend: 'Sch.mixin.AbstractSchedulerView',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Sch.patches.BoundList',
        'Sch.patches.DragDropManager',
        'Sch.patches.NavigationModel',
        'Sch.patches.NavigationModel6_0_2',
        'Sch.feature.DragCreator',
        'Sch.feature.DragDrop',
        'Sch.feature.ResizeZone',
        'Sch.column.Resource',
        'Sch.column.Day',
        'Sch.view.WeekView',
        'Ext.Factory',
        'Ext.XTemplate'
    ],
    /**
     * @property {Sch.feature.SchedulerDragZone} eventDragZone
     * Accessor to the event dragzone (available only if the drag drop feature is enabled)
     */
    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'end'
     */
    eventResizeHandles: 'end',
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the drop position is valid, else false to prevent a drop. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    dndValidatorFn: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * an item being resized. To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the resize state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    resizeValidatorFn: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    createValidatorFn: Ext.emptyFn,
    // Scheduled events: click events --------------------------
    /**
     * @event eventclick
     * Fires when an event is clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventlongpress
     * Fires when an event is longpressed
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmousedown
     * Fires when a mousedown event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseup
     * Fires when a mouseup event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdblclick
     * Fires when an event is double clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventcontextmenu
     * Fires when contextmenu is activated on an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseenter
     * Fires when the mouse moves over an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventmouseout
     * Fires when the mouse moves out of an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.event.Event} e The event object
     */
    // Resizing events start --------------------------
    /**
     * @event beforeeventresize
     * @preventable
     * Fires before a resize starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record about to be resized
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventresizestart
     * Fires when resize starts
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     */
    /**
     * @event eventpartialresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     * @param {Date} startDate The new start date of the event
     * @param {Date} endDate The new end date of the event
     * @param {Ext.Element} element The proxy element being resized
     */
    /**
     * @event beforeeventresizefinalize
     * @preventable
     * Fires before a successful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} resizeContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventresizeend
     * Fires after a successful resize operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The updated event record
     */
    /**
     * @event aftereventresize
     * Always fires after a resize operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The updated event record
     */
    // Resizing events end --------------------------
    // Dnd events start --------------------------
    /**
     * @event beforeeventdrag
     * @preventable
     * Fires before a dnd operation is initiated, return false to cancel it
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdragstart
     * Fires when a dnd operation starts
     * @param {Sch.mixin.SchedulerView} scheduler The scheduler object
     * @param {Sch.model.Event[]} records The event records being dragged including related records
     */
    /**
     * @event beforeeventdropfinalize
     * @preventable
     * Fires before a successful drop operation is finalized.
     * @param {Sch.mixin.SchedulerView} scheduler The scheduler object
     * @param {Object} dragContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event eventdrop
     * Fires after a successful drag and drop operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event[]} records The affected records (if copies were made, they were inserted into the store)
     * @param {Boolean} isCopy True if the records were copied instead of moved
     */
    /**
     * @event aftereventdrop
     * Fires when after a drag n drop operation, even when drop was performed on an invalid location
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event[]} records The affected records
     */
    // Dnd events end --------------------------
    // Drag create events start --------------------------
    /**
     * @event beforedragcreate
     * @preventable
     * Fires before a drag starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Resource} resource The resource record
     * @param {Date} date The clicked date on the timeaxis
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event dragcreatestart
     * Fires when a drag is starting
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event beforedragcreatefinalize
     * @preventable
     * Fires before a successful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
     * @param {Ext.event.Event} e The event object
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
     * @param {Sch.model.Resource} resource The resource record to which the event belongs
     * @param {Ext.event.Event} e The event object
     * @param {Ext.Element} el The proxy element
     */
    /**
     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */
    // Drag create events end --------------------------
    /**
     * @event beforeeventadd
     * @preventable
     * Fires after a successful drag-create operation, before the new event is added to the store. Return false to prevent the event from being added to the store.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record
     * @param {Sch.model.Resource[]} resources The resources to which the event is assigned
     */
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulelongpress
     * Fires when a longpress on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading events...'
     */
    weekViewClass: 'Sch.view.WeekView',
    lockedGridDependsOnSchedule: null,
    _initializeSchedulerView: function() {
        var me = this;
        me.callParent(arguments);
        if (!me.eventPrefix) {
            throw 'eventPrefix missing';
        }
        me.on({
            destroy: me._destroy,
            afterrender: me._afterRender,
            itemupdate: me.onRowUpdated,
            scope: me
        });
        // https://www.assembla.com/spaces/bryntum/tickets/2567
        // Covered with tests/rendering/092_rowheight.t.js
        // Cache has to be cleared on time span change in order to draw correct row height for empty rows
        me.timeAxis.on('beginreconfigure', me.clearRowHeightCache, me);
        me.on({
            resourcestorechange: me.clearRowHeightCache,
            assignmentstorechange: me.clearRowHeightCache,
            eventstorechange: me.clearRowHeightCache,
            scope: me
        });
    },
    inheritables: function() {
        return {
            // Configuring underlying grid view
            loadingText: this.L('loadingText'),
            overItemCls: '',
            trackOver: false,
            selectedItemCls: '',
            // We don't want row selection visible here
            // EOF: Configuring underlying grid view
            setReadOnly: function(readOnly) {
                var me = this;
                if (me.dragCreator) {
                    me.dragCreator.setDisabled(readOnly);
                }
                me.callParent(arguments);
            },
            repaintEventsForResource: function(resourceRecord, refreshSelections) {
                var me = this,
                    isHorizontal = me.isHorizontal(),
                    // For vertical, we always repaint all events (do per-column repaint is not supported)
                    index = isHorizontal ? me.indexOf(resourceRecord) : 0;
                if (isHorizontal) {
                    me.eventLayout.horizontal.clearCache(resourceRecord);
                }
                if (index >= 0) {
                    // HACK, Ext insists on performing layouts when refreshing a grid row.
                    // Prevent this, "should be" safe.
                    Ext.suspendLayouts();
                    // we operate "resourceRecord" here since "index" might be incorrect when grouping plugin is used
                    if (isHorizontal) {
                        me.refreshNode(resourceRecord);
                        if (me.lockedGridDependsOnSchedule) {
                            me.lockingPartner.refreshNode(resourceRecord);
                        }
                    } else // Use index here to keep vertical view only refreshing first row always
                    {
                        me.refreshNode(index);
                    }
                    Ext.resumeLayouts();
                    if (refreshSelections) {
                        var sm = me.getEventSelectionModel();
                        var events = me.getEventStore().getEventsForResource(resourceRecord);
                        Ext.Array.each(events, function(ev) {
                            sm.forEachEventRelatedSelection(ev, function(selectedRecord) {
                                me.onEventBarSelect(selectedRecord, true);
                            });
                        });
                    }
                }
            },
            repaintAllEvents: function() {
                if (this.isHorizontal()) {
                    this.refreshView();
                } else {
                    // All events are rendered in first row, no need to do a full refresh
                    this.refreshNode(0);
                }
            },
            handleScheduleEvent: function(e) {
                var te = e.getTarget('.' + this.eventCls, 3),
                    t = !te && e.getTarget('.' + this.timeCellCls, 3);
                if (t) {
                    var clickedDate = this.getDateFromDomEvent(e, 'floor');
                    var resourceNode = this.findRowByChild(t);
                    var index = this.indexOf(resourceNode);
                    var resource = null;
                    // All Day Header uses fake resource store
                    if (!this.allDay) {
                        if (this.isHorizontal()) {
                            resource = this.getRecordForRowNode(resourceNode);
                        } else {
                            var cellNode = e.getTarget(this.timeCellSelector, 5);
                            if (cellNode) {
                                var cellIndex = typeof cellNode.cellIndex == 'number' ? cellNode.cellIndex : cellNode.getAttribute('data-cellIndex');
                                var header = this.headerCt.getGridColumns()[cellIndex];
                                resource = header && header.model;
                            }
                        }
                    }
                    if (e.type.indexOf('pinch') >= 0) {
                        this.fireEvent('schedule' + e.type, this, e);
                    } else {
                        this.fireEvent('schedule' + e.type, this, clickedDate, index, resource, e);
                    }
                }
            },
            onEventDataRefresh: function() {
                this.clearRowHeightCache();
                this.callParent(arguments);
            },
            onUnbindStore: function(store) {
                store.un({
                    refresh: this.clearRowHeightCache,
                    clear: this.clearRowHeightCache,
                    load: this.clearRowHeightCache,
                    scope: this
                });
                this.callParent(arguments);
            },
            // our listeners must go before any other listeners, that's why we override the 'bindStore'
            // instead of `onBindStore`
            bindStore: function(store) {
                store && store.on({
                    refresh: this.clearRowHeightCache,
                    clear: this.clearRowHeightCache,
                    load: this.clearRowHeightCache,
                    scope: this
                });
                this.callParent(arguments);
            },
            refreshKeepingScroll: function() {
                if (this.rendered) {
                    this.lockingPartner.refreshView();
                    this.callParent(arguments);
                }
            }
        };
    },
    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel: function() {
        var me = this,
            mode;
        if (me.eventSelModel && me.eventSelModel.isSelectionModel) {
            return me.eventSelModel;
        }
        if (typeof me.eventSelModel === 'string') {
            me.eventSelModel = {
                type: me.eventSelModel
            };
        }
        if (me.simpleSelect) {
            mode = 'SIMPLE';
        } else if (me.multiSelect) {
            mode = 'MULTI';
        } else {
            mode = 'SINGLE';
        }
        me.eventSelModel = Ext.Factory.selection(Ext.apply({
            type: me.eventSelModelType || (me.getEventStore().getAssignmentStore() ? 'assignmentmodel' : 'eventmodel'),
            mode: mode,
            allowDeselect: me.allowDeselect || me.multiSelect,
            locked: me.disableSelection
        }, me.eventSelModel));
        return me.eventSelModel;
    },
    _afterRender: function() {
        this.setEventStore(this.eventStore, true);
        this.getEventSelectionModel().bindToView(this);
        this.setupEventListeners();
        this.configureFunctionality();
        var resizer = this.headerCt.resizer;
        if (resizer) {
            resizer.doResize = Ext.Function.createSequence(resizer.doResize, this.afterHeaderResized, this);
        }
        // Delete the hoveredEventNode (last item we hovered over) so that after a drag drop the UI considers the
        // mouse to be over the current element
        this.on('itemupdate', function() {
            this.hoveredEventNode = null;
        });
    },
    // private, clean up
    _destroy: function() {
        this.setEventStore(null);
    },
    clearRowHeightCache: function() {
        if (this.isHorizontal()) {
            this.eventLayout.horizontal.clearCache();
        }
    },
    configureFunctionality: function() {
        var me = this,
            vfScope = me.validatorFnScope || me;
        if (me.eventResizeHandles !== 'none' && Sch.feature.ResizeZone) {
            me.resizePlug = new Sch.feature.ResizeZone(Ext.applyIf({
                schedulerView: me,
                validatorFn: function(resourceRecord, eventRecord, startDate, endDate) {
                    // For weekview, target resource contains the start/end times - ignore it
                    if (!(resourceRecord instanceof Sch.model.Resource)) {
                        resourceRecord = null;
                    }
                    return (me.allowOverlap || me.isDateRangeAvailable(startDate, endDate, eventRecord, resourceRecord)) && me.resizeValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: me
            }, me.resizeConfig || {}));
        }
        if (me.enableEventDragDrop !== false && Sch.feature.DragDrop) {
            var hasSplitPlugin = this.ownerGrid.findPlugin('scheduler_split');
            me.dragdropPlug = new Sch.feature.DragDrop(me, {
                validatorFn: function(dragRecords, targetResourceRecord, date, duration) {
                    // For weekview, target resource contains the start/end times - ignore it
                    if (!(targetResourceRecord instanceof Sch.model.Resource)) {
                        targetResourceRecord = null;
                    }
                    return (me.allowOverlap || me.isDateRangeAvailable(date, Sch.util.Date.add(date, Sch.util.Date.MILLI, duration), dragRecords[0], targetResourceRecord)) && me.dndValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: me,
                targetEl: hasSplitPlugin ? me.getEl() : me.ownerGrid.el,
                dragConfig: me.dragConfig || {}
            });
        }
        if (me.enableDragCreation !== false) {
            me.dragCreator = Ext.create(Ext.apply({
                xclass: 'Sch.feature.DragCreator'
            }, {
                schedulerView: me,
                disabled: me.readOnly,
                validatorFn: function(resourceRecord, startDate, endDate) {
                    // For weekview, target resource contains the start/end times - ignore it
                    if (!(resourceRecord instanceof Sch.model.Resource)) {
                        resourceRecord = null;
                    }
                    return (me.allowOverlap || me.isDateRangeAvailable(startDate, endDate, null, resourceRecord)) && me.createValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope: me
            }, me.createConfig));
        }
        if (me.createEventOnDblClick !== false) {
            me.on({
                scheduledblclick: me.doCreateEventOnDblClick,
                schedulelongpress: me.doCreateEventOnDblClick,
                scope: me
            });
        }
    },
    // ---------------------------------------
    // Interaction listeners
    doCreateEventOnDblClick: function(view, date, rowIndex, resource) {
        if (this.readOnly)  {
            return;
        }
        
        var me = this,
            mainSchView = view.allDay && view.ownerGrid.mainScheduler.getSchedulingView(),
            editor = mainSchView ? mainSchView.getEventEditor() : me.getEventEditor(),
            eventStore = view.getEventStore(),
            model = eventStore.getModel(),
            data = {};
        // prepare the model data
        data[model.prototype.startDateField] = date;
        data[model.prototype.endDateField] = Sch.util.Date.add(date, view.timeAxis.unit, 1);
        data[model.prototype.allDayField] = Boolean(view.allDay);
        data[model.prototype.resourceIdField] = resource && resource.getId() || null;
        var record = Ext.create(model, data);
        me.onEventCreated(record, resource);
        if (editor) {
            editor.showRecord(record);
        } else {
            eventStore.add(record);
        }
    },
    onDragDropStart: function() {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }
        this.disableViewScroller(true);
        // To be able to refresh last hovered node
        this.hoveredEventNode = null;
    },
    onDragDropEnd: function() {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }
        if (this.tip) {
            this.tip.enable();
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
        this.disableViewScroller(false);
    },
    onBeforeDragCreate: function(s, resourceRecord, date, e) {
        return !this.readOnly && !e.ctrlKey;
    },
    onDragCreateStart: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },
    onDragCreateEnd: function(s, newEventRecord, resourceRecord) {
        // If an event editor is defined, it has to manage how/if/when the event is added to the event store
        if (!this.getEventEditor()) {
            // we may not have any resources if we're in weekview mode
            var resources = resourceRecord ? [
                    resourceRecord
                ] : [];
            if (this.fireEvent('beforeeventadd', this, newEventRecord, resources) !== false) {
                var eventStore = this.getEventStore(),
                    isAutoSyncEnabled = eventStore.getAutoSync();
                if (isAutoSyncEnabled) {
                    eventStore.suspendAutoSync();
                }
                eventStore.append(newEventRecord);
                // In weekview mode both axes are time so resourceRecord is object {start: foo, end: bar}
                // so we do not need assign this resource to event
                if (!this.isWeekView()) {
                    newEventRecord.assign(resourceRecord);
                }
                this.onEventCreated(newEventRecord, resources);
                if (isAutoSyncEnabled) {
                    eventStore.resumeAutoSync(true);
                }
            }
        }
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
    },
    // Empty but provided so that you can override it to supply default record values etc.
    onEventCreated: function(newEventRecord, resources) {},
    onAfterDragCreate: function() {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
        if (this.tip) {
            this.tip.enable();
        }
        this.disableViewScroller(false);
    },
    onBeforeResize: function() {
        return !this.readOnly;
    },
    onResizeStart: function() {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }
        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },
    onResizeEnd: function() {
        if (this.tip) {
            this.tip.enable();
        }
        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }
        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(false);
    },
    // EOF Interaction listeners
    // ---------------------------------------
    setupEventListeners: function() {
        this.on({
            eventdragstart: this.onDragDropStart,
            aftereventdrop: this.onDragDropEnd,
            beforedragcreate: this.onBeforeDragCreate,
            dragcreatestart: this.onDragCreateStart,
            dragcreateend: this.onDragCreateEnd,
            afterdragcreate: this.onAfterDragCreate,
            beforeeventresize: this.onBeforeResize,
            eventresizestart: this.onResizeStart,
            aftereventresize: this.onResizeEnd,
            scope: this
        });
    },
    afterHeaderResized: function() {
        var resizer = this.headerCt.resizer;
        // if we perform resize on panel with forceFit cfg set to true events will be sized incorrectly
        if (resizer && !this.isHorizontal()) {
            // if forceFit is enabled columns cannot be resized
            if (this.panel.forceFit) {
                this.setColumnWidth(resizer.origWidth);
            } else {
                var w = resizer.dragHd.getWidth();
                this.setColumnWidth(w);
            }
        }
    },
    columnRenderer: function(val, meta, record, row, col) {
        return this[this.mode].columnRenderer(val, meta, record, row, col);
    },
    onRowUpdated: function(resourceRecord) {
        var me = this,
            nodes;
        // Only relevant for horizontal mode
        if (me.isHorizontal() && me.hasListener('eventrepaint')) {
            Ext.Array.each(resourceRecord.getEvents(), function(event) {
                nodes = me.getElementsFromEventRecord(event, resourceRecord, null, true);
                Ext.Array.each(nodes, function(node) {
                    me.fireEvent('eventrepaint', me, event, node);
                });
            });
        }
    },
    /**
     * Scrolls a resource event record into the viewport.
     *
     * If the resource store is a tree store, this method will also expand all relevant parent nodes
     * to locate the event.
     *
     * @param {Sch.model.Resource} resourceRec A resource record an event record is assigned to
     * @param {Sch.model.Event} eventRec    An event record to scroll into view
     * @param {Number} index                DOM node index, applicable only for weekview
     * @param {Boolean/Object} highlight    Either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate      Either `true/false` or an animation config object used to scroll the element
     */
    scrollResourceEventIntoView: function(resourceRec, eventRec, index, highlight, animate, callback, scope) {
        // scrollResourceEventIntoView is not supported by All Day header
        if (this.allDay)  {
            return;
        }
        
        var me = this,
            ownerCmp = me.up('timelinegrid,timelinetree'),
            eventStart = eventRec.getStartDate(),
            eventEnd = eventRec.getEndDate(),
            currentTimeSpanRange, el;
        var doScroll = function() {
                // Establishing element to scroll to
                el = me.getElementsFromEventRecord(eventRec, resourceRec, index);
                el = el.length && el[0] || null;
                // In weekview there might be several elements correspond to resource/event pair.
                // it will be null if event is all day and it's placed in all day header only
                if (el) {
                    // Scrolling with view with animation and highlighting if needed
                    me.scrollElementIntoView(el, true, animate, highlight, null, callback, scope);
                }
            };
        var timeAxisToAdjust = me.timeAxis,
            // In case the event is all day and there is all day header, need to check the event within all day header, but change time span of main scheduler
            timeAxisToCheck = eventRec.getAllDay && eventRec.getAllDay() && ownerCmp.allDayNormalHeader ? ownerCmp.allDayNormalHeader.getSchedulingView().timeAxis : timeAxisToAdjust;
        // Make sure event is within current time axis time span, inclusively for end date
        if (!timeAxisToCheck.dateInAxis(eventStart) || !timeAxisToCheck.dateInAxis(eventEnd, true)) {
            currentTimeSpanRange = timeAxisToAdjust.getEnd() - timeAxisToAdjust.getStart();
            timeAxisToAdjust.setTimeSpan(new Date(eventStart.getTime() - currentTimeSpanRange / 2), new Date(eventEnd.getTime() + currentTimeSpanRange / 2));
            // HACK:
            // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
            // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
            me.up('panel').scrollTask.cancel();
        }
        if (this.isHorizontal()) {
            var isTree = ownerCmp.store.isTreeStore;
            // Dealing with buffered rendering, making sure row is rendered
            ownerCmp.ensureVisible(isTree ? resourceRec.getPath() : resourceRec, {
                callback: function() {
                    doScroll();
                }
            });
        } else {
            doScroll();
        }
    }
});

/**

@class Sch.view.SchedulerGridView
@extends Sch.view.TimelineGridView
@mixins Sch.mixin.SchedulerView

Empty class just consuming the Sch.mixin.SchedulerView mixin.

*/
Ext.define("Sch.view.SchedulerGridView", {
    extend: 'Sch.view.TimelineGridView',
    mixins: [
        'Sch.mixin.SchedulerView',
        'Sch.mixin.GridViewCanvas',
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.schedulergridview'
}, function() {
    this.override(Sch.mixin.SchedulerView.prototype.inheritables() || {});
});

/**
@class Sch.selection.EventModel
@extends Ext.selection.Model

This class provides the basic implementation event selection in a grid.

*/
Ext.define("Sch.selection.EventModel", {
    extend: 'Ext.selection.Model',
    alias: 'selection.eventmodel',
    requires: [
        'Ext.util.KeyNav'
    ],
    /**
     * @cfg {Boolean} deselectOnContainerClick `True` to deselect all events when user clicks on the underlying space in scheduler. Defaults to `true`.
     */
    deselectOnContainerClick: true,
    // Stores selected record on mousedown event to avoid
    // unselecting record on click
    selectedOnMouseDown: null,
    /**
     * @event beforedeselect
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event beforeselect
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */
    // Some abstract methods from parent class that require to be implemented
    bindComponent: Ext.emptyFn,
    onEditorKey: Ext.emptyFn,
    onStoreLoad: Ext.emptyFn,
    /**
     */
    bindToView: function(view) {
        var me = this;
        me.view = view;
        me.bindStore(me.getSelectionStore(view));
        view.on({
            eventclick: me.onEventClick,
            eventmousedown: me.onEventMouseDown,
            itemmousedown: me.onItemMouseDown,
            refresh: function() {
                me.refresh();
            },
            destroy: function() {
                me.bindStore(null);
            },
            scope: me
        });
    },
    getSelectionStore: function(view) {
        return view.getEventStore();
    },
    bindStore: function(store) {
        if (this.getStore()) {
            this.mun(this.getStore(), 'load', this.onSelectionStoreLoad, this);
        }
        if (store) {
            this.mon(store, 'load', this.onSelectionStoreLoad, this);
        }
        this.callParent(arguments);
    },
    onSelectionStoreLoad: function() {
        this.deselectAll();
    },
    onEventMouseDown: function(view, record, e) {
        // Reset previously stored records
        this.selectedOnMouseDown = null;
        // Change selection before dragging to avoid moving of unselected events
        if ((!this.ignoreRightMouseSelection || e.button !== 2) && !this.isSelected(record)) {
            this.selectedOnMouseDown = record;
            this.selectWithEvent(record, e);
        }
    },
    onEventClick: function(view, record, e) {
        // Don't change selection if record been already selected on mousedown
        if ((!this.ignoreRightMouseSelection || e.button !== 2) && !this.selectedOnMouseDown) {
            this.selectWithEvent(record, e);
        }
    },
    onItemMouseDown: function(a, b, c, d, eventObj) {
        if (this.deselectOnContainerClick && !eventObj.getTarget(this.view.eventSelector)) {
            this.deselectAll();
        }
    },
    onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
        var me = this,
            view = me.view,
            store = me.store,
            eventName = isSelected ? 'select' : 'deselect',
            i = 0;
        if (view && (suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {
            if (isSelected) {
                view.onEventBarSelect(record, suppressEvent);
            } else {
                view.onEventBarDeselect(record, suppressEvent);
            }
            if (!suppressEvent) {
                me.fireEvent(eventName, me, record);
            }
        }
    },
    // Not supported.
    selectRange: Ext.emptyFn,
    selectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.select(r, keepExisting, suppressEvent);
        }
    },
    deselectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.deselect(r, suppressEvent);
        }
    },
    /**
     * Returns first selected event record for the given resource record or null if the resource has no assigned
     * events which are selected.
     *
     * @param {Sch.model.Resource} resource
     * @return {Sch.model.Event}
     */
    getFirstSelectedEventForResource: function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;
        for (i = 0 , len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.isAssignedTo(resource)) {
                event = r;
            }
        }
        return event;
    },
    getDraggableSelections: function() {
        return Ext.Array.filter(this.getSelection(), function(record) {
            return record.isDraggable();
        });
    },
    forEachEventRelatedSelection: function(eventRecord, fn) {
        this.isSelected(eventRecord) && fn(eventRecord);
    },
    // @OVERRIDE: 6.5.1 introduced a bug/behavior change leading to records not being selected after refresh
    refresh: function() {
        var me = this,
            store = me.store,
            toBeSelected = [],
            toBeReAdded = [],
            oldSelections = me.getSelection(),
            len = oldSelections.length,
            // Will be a Collection in this and DataView classes.
            // Will be an Ext.grid.selection.Rows instance for Spreadsheet (does not callParent for other modes).
            // API used in here, getCount() and add() are common.
            selected = me.getSelected(),
            change, d, storeData, selection, rec, i;
        // Not been bound yet, or we have never selected anything.
        if (!store || !(selected.isCollection || selected.isBag || selected.isRows) || !selected.getCount()) {
            return;
        }
        // We need to look beneath any filtering to see if the selected records are still owned by the store
        storeData = store.getData();
        // Attempt to get the underlying source collection to avoid filtering
        if (storeData.getSource) {
            d = storeData.getSource();
            if (d) {
                storeData = d;
            }
        }
        me.refreshing = true;
        // Inhibit update notifications during refresh of the selected collection.
        selected.beginUpdate();
        me.suspendChanges();
        // Add currently records to the toBeSelected list if present in the Store
        // If they are not present, and pruneRemoved is false, we must still retain the record
        for (i = 0; i < len; i++) {
            selection = oldSelections[i];
            rec = storeData.get(selection.getId());
            if (rec) {
                toBeSelected.push(rec);
            }
            // Selected records no longer represented in Store must be retained
            else if (!me.pruneRemoved) {
                toBeReAdded.push(selection);
            }
            // In single select mode, only one record may be selected
            if (me.mode === 'SINGLE' && toBeReAdded.length) {
                break;
            }
        }
        // there was a change from the old selected and
        // the new selection
        if (selected.getCount() !== (toBeSelected.length + toBeReAdded.length)) {
            change = true;
        }
        me.clearSelections();
        if (toBeSelected.length) {
            // perform the selection again
            me.doSelect(toBeSelected, false, true);
        }
        // If some of the selections were not present in the Store, but pruneRemoved is false, we must add them back
        if (toBeReAdded.length) {
            selected.add(toBeReAdded);
            // No records reselected.
            if (!me.lastSelected) {
                me.lastSelected = toBeReAdded[toBeReAdded.length - 1];
            }
        }
        me.resumeChanges();
        // If the new data caused the selection to change, announce the update using endUpdate,
        // Otherwise, end the update silently.
        // Bindings may be attached to selection - we need to coalesce changes.
        if (change) {
            selected.endUpdate();
        } else {
            selected.updating--;
        }
        me.refreshing = false;
        me.maybeFireSelectionChange(change);
    }
});

/**
 * @class Sch.selection.AssignmentModel
 * @extends Ext.selection.Model
 *
 * This class provides assignment selection model for multiple assignments mode, i.e. when the event store is configured
 * with assignment store and uses it for storing event to resource and resource to event assignment information.
 * In multiple assignment mode there're might be several event bars rendered for each event in the event store, thus
 * an inconsistency appears, to solve the inconsistency we use assignment record as entities being selected since
 * there's direct correspondence between event bar and assignment the bar is rendered for.
 */
Ext.define('Sch.selection.AssignmentModel', {
    extend: 'Sch.selection.EventModel',
    alias: 'selection.assignmentmodel',
    /**
     * @event beforedeselect
     * @preventable
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event beforeselect
     * @preventable
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */
    assignmentStoreDetacher: null,
    getSelectionStore: function(view) {
        return view.getEventStore().assignmentStore;
    },
    onBindStore: function(assignmentStore) {
        this.callParent(arguments);
        if (assignmentStore) {
            var me = this;
            me.assignmentStoreDetacher && me.assignmentStoreDetacher.destroy();
            me.assignmentStoreDetacher = assignmentStore.on({
                remove: me.onAssignmentStoreRemove,
                clear: me.onAssignmentStoreClear,
                refresh: me.onAssignmentStoreRefresh,
                scope: me,
                destroyable: true
            });
        }
    },
    onEventMouseDown: function(view, record, e) {
        // Reset previously stored records
        this.selectedOnMouseDown = null;
        var assignmentRecord = this.resolveAssignmentRecordFromEventNode(e.getTarget());
        // Change selection before dragging to avoid moving of unselected events
        if (assignmentRecord && (!this.ignoreRightMouseSelection || e.button !== 2) && !this.isSelected(assignmentRecord)) {
            this.selectedOnMouseDown = assignmentRecord;
            this.selectWithEvent(assignmentRecord, e);
        }
    },
    onEventClick: function(view, record, e) {
        var assignmentRecord = this.resolveAssignmentRecordFromEventNode(e.getTarget());
        // Don't change selection if record been already selected on mousedown
        if (assignmentRecord && (!this.ignoreRightMouseSelection || e.button !== 2) && !this.selectedOnMouseDown) {
            this.selectWithEvent(assignmentRecord, e);
        }
    },
    resolveAssignmentRecordFromEventNode: function(node) {
        var view = this.view,
            event = view.resolveEventRecord(node),
            resource = view.resolveResource(node);
        if (event && resource) {
            var assignmentStore = view.getEventStore().getAssignmentStore();
            return assignmentStore.getAssignmentForEventAndResource(event, resource);
        }
    },
    selectNode: function(node, keepExisting, suppressEvent) {
        var assignmentRecord = this.resolveAssignmentRecordFromEventNode(node);
        if (assignmentRecord) {
            this.select(assignmentRecord, keepExisting, suppressEvent);
        }
    },
    deselectNode: function(node, keepExisting, suppressEvent) {
        var assignmentRecord = this.resolveAssignmentRecordFromEventNode(node);
        if (assignmentRecord) {
            this.deselect(assignmentRecord, suppressEvent);
        }
    },
    getFirstSelectedEventForResource: function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;
        for (i = 0 , len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.getEvent().isAssignedTo(resource)) {
                event = r;
                break;
            }
        }
        return event;
    },
    getDraggableSelections: function() {
        return Ext.Array.filter(this.getSelection(), function(record) {
            return record.getEvent().isDraggable();
        });
    },
    forEachEventRelatedSelection: function(eventRecord, fn) {
        Ext.Array.each(this.getSelection(), function(selectedRecord) {
            selectedRecord.getEvent() === eventRecord && fn(selectedRecord);
        });
    },
    onAssignmentStoreRemove: function(assignmentStore, removedRecords) {
        this.deselect(removedRecords, true);
    },
    onAssignmentStoreClear: function(assignmentStore) {
        this.clearSelections();
    },
    onAssignmentStoreRefresh: function(assignmentStore) {
        this.clearSelections();
    },
    destroy: function() {
        var me = this;
        Ext.destroyMembers(me, 'assignmentStoreDetacher');
        me.callParent();
    }
});

/**

 @class Sch.mixin.SchedulerPanel
 @extends Sch.mixin.AbstractSchedulerPanel

 A mixin for {@link Ext.panel.Panel} classes, providing "scheduling" functionality to the consuming panel.
 A consuming class should have already consumed the {@link Sch.mixin.TimelinePanel} mixin.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

 */
Ext.define('Sch.mixin.SchedulerPanel', {
    extend: 'Sch.mixin.AbstractSchedulerPanel',
    requires: [
        'Sch.view.SchedulerGridView',
        'Sch.feature.RecurringEvents',
        'Sch.selection.EventModel',
        'Sch.selection.AssignmentModel',
        'Sch.column.Resource',
        'Sch.column.timeAxis.Vertical',
        'Sch.column.ResourceName'
    ],
    uses: [
        'Sch.panel.AllDayHeader'
    ],
    /**
     * @cfg {String} eventSelModelType The xtype of the selection model to be used to events. Should be a {@link Sch.selection.EventModel} or its subclass.
     */
    eventSelModelType: null,
    // 'eventmodel', 'assignmentmodel'
    /**
     * @cfg {Object} eventSelModel The configuration object for the event selection model. See {@link Sch.selection.EventModel} for available configuration options.
     */
    eventSelModel: null,
    /**
     * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
     */
    enableEventDragDrop: true,
    /**
     * @cfg {Boolean} enableDragCreation true to enable creating new events by click and drag, defaults to true
     */
    enableDragCreation: true,
    /**
     * @cfg {Boolean} createEventOnDblClick true to enable creating new events by dblclicking or longpressing scheduling view
     */
    createEventOnDblClick: false,
    /**
     * @cfg {Object} dragConfig Custom config to pass to the {@link Sch.feature.SchedulerDragZone}
     * instance which will be created by {@link Sch.feature.DragDrop}.
     */
    dragConfig: null,
    /**
     * @cfg {String} weekViewColumnClass
     * Defines the column class for the days, override this to use your own custom column class. (Used only in weekview mode)
     */
    weekViewColumnClass: 'Sch.column.Day',
    /**
     * @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
     */
    /**
     * @cfg {Object} weekViewTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in weekview mode.
     */
    /**
     * @cfg {Object} createConfig Custom config to pass to the {@link Sch.feature.DragCreator} instance
     */
    /**
     * @cfg {Object} resizeConfig Custom config to pass to the {@link Sch.feature.ResizeZone} instance
     */
    componentCls: 'sch-schedulerpanel',
    // even that this config "belongs" to the Sch.mixin.TimelinePanel mixin
    // we can't define it there, because of various reasons (extjs mixin system)
    // this is guarded by the 203_buffered_view_1.t.js test in gantt and 092_rowheight.t.js in scheduler
    /**
     * @ignore
     * @cfg {Boolean} lockedGridDependsOnSchedule set this to true if you require the left (locked) grid section to be refreshed when the schedule is updated.
     */
    lockedGridDependsOnSchedule: true,
    /**
     * @cfg {Boolean} showAllDayHeader Shows an all day header above the main schedule for All Day events.
     */
    showAllDayHeader: true,
    /**
     * @cfg {Boolean} [multiSelect=false]
     * True to allow selection of more than one event at a time, false to allow selection of only a single item
     * at a time or no selection at all, depending on the value of {@link #singleSelect}.
     */
    /**
     * @cfg {Boolean} [singleSelect]
     * Allows selection of exactly one event at a time. As this is the default selection mode anyway, this config
     * is completely ignored.
     */
    /**
     * @cfg {Boolean} [simpleSelect=false]
     * True to enable multiselection by clicking on multiple events without requiring the user to hold Shift or Ctrl,
     * false to force the user to hold Ctrl or Shift to select more than on item.
     */
    /**
     * @cfg {Function} dndValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the drop position is valid, else false to prevent a drop.
     * @param {Array} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean}
     */
    /**
     * @cfg {Function} resizeValidatorFn
     * Provide to perform custom validation on an item being resized.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the resize state is valid, else false.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean}
     */
    /**
     * @cfg {Function} createValidatorFn
     * Provide to perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true to signal that the new event is valid, or false prevent it.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} true
     */
    verticalListeners: null,
    /**
      * @event beforemodechange
      * Fires before a mode change
      * @preventable
      * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
      * @param {String/Object}   modeCfg A string like 'horizontal', 'vertical', 'weekview' or an object
      * @param {String}          modeCfg.mode The new mode ('horizontal', 'vertical', 'weekview')
      * @param {String/Object}   [modeCfg.viewPreset] The id of the new preset (see {@link Sch.preset.Manager} for details)
      * @param {Date}            [modeCfg.startDate] A new start date for the time axis
      * @param {Date}            [modeCfg.endDate] A end start date for the time axis
      */
    /**
      * @event modechange
      * Fires after a mode change
      * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
      * @param {String/Object}   modeCfg A string like 'horizontal', 'vertical', 'weekview' or an object
      * @param {String}          modeCfg.mode The new mode ('horizontal', 'vertical', 'weekview')
      * @param {String/Object}   [modeCfg.viewPreset] The id of the new preset (see {@link Sch.preset.Manager} for details)
      * @param {Date}            [modeCfg.startDate] A new start date for the time axis
      * @param {Date}            [modeCfg.endDate] A end start date for the time axis
      */
    // Cached value of locked grid width used when switching mode
    horizontalLockedWidth: null,
    verticalColumns: null,
    calendarColumns: null,
    /**
     * Provide `false` to disable the recurring events feature.
     * By default the feature is enabled and populates the panel view with repeating events visible in the current timespan.
     * @cfg {Boolean}
     */
    recurringEvents: true,
    // weekview and vertical modes are similar, but we have to recognize them individually
    // in order to do that we consider sch-vertical as a main CSS for both,
    // sch-calendar for weekview (previous name was calendar) and sch-vertical-resource for vertical
    horizontalCls: [
        'sch-horizontal'
    ],
    verticalCls: [
        'sch-vertical-resource',
        'sch-vertical'
    ],
    weekviewCls: [
        'sch-calendar',
        'sch-vertical'
    ],
    // Hold previous view preset as arguments to be able pass them to setViewPreset method,
    // if we switched from weekview to horizontal/vertical mode and vice versa
    _oldViewPresetArgs: null,
    /**
     * @cfg {Boolean} splitGrid
     * @inheritdoc Sch.plugin.Split#splitGrid
     * @localdoc Available in horizontal mode when {@link Sch.plugin.Split split plugin} is configured.
     */
    /**
     * @method split
     * @inheritdoc Sch.plugin.Split#split
     * @localdoc Available in horizontal mode when {@link Sch.plugin.Split split plugin} is configured.
     */
    /**
     * @method merge
     * @inheritdoc Sch.plugin.Split#merge
     * @localdoc Available in horizontal mode when {@link Sch.plugin.Split split plugin} is configured.
     */
    /**
     * @method isSplit
     * @inheritdoc Sch.plugin.Split#isSplit
     * @localdoc Available in horizontal mode when {@link Sch.plugin.Split split plugin} is configured.
     */
    relayedViewEvents: [
        /**
         * @event eventclick
         * Fires when an event is clicked
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventclick',
        /**
         * @event eventlongpress
         * Fires when an event is longpressed
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventlongpress',
        /**
         * @event eventmousedown
         * Fires when a mousedown event is detected on a rendered event
         * @param {Mixed} view The scheduler view instance
         * @param {Sch.model.Event} eventRecord The event record
         * @param {Ext.event.Event} e The event object
         */
        'eventmousedown',
        /**
         * @event eventmouseup
         * Fires when a mouseup event is detected on a rendered event
         * @param {Mixed} view The scheduler view instance
         * @param {Sch.model.Event} eventRecord The event record
         * @param {Ext.event.Event} e The event object
         */
        'eventmouseup',
        /**
         * @event eventdblclick
         * Fires when an event is double clicked
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventdblclick',
        /**
         * @event eventcontextmenu
         * Fires when contextmenu is activated on an event
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventcontextmenu',
        /**
         * @event eventmouseenter
         * Fires when the mouse moves over an event
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventmouseenter',
        /**
         * @event eventmouseleave
         * Fires when the mouse moves out of an event
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The event record of the clicked event
         * @param {Ext.event.Event} e The event object
         */
        'eventmouseleave',
        /**
         * @event eventkeydown
         * Fires when a keydown event is detected on an event
         * @param {Mixed} view The scheduler view instance
         * @param {Sch.model.Event} eventRecord The event record
         * @param {Ext.event.Event} e The event object
         */
        'eventkeydown',
        /**
         * @event eventkeyup
         * Fires when a keyup event is detected on an event
         * @param {Mixed} view The scheduler view instance
         * @param {Sch.model.Event} eventRecord The event record
         * @param {Ext.event.Event} e The event object
         */
        'eventkeyup',
        // Resizing events start --------------------------
        /**
         * @event beforeeventresize
         * @preventable
         * Fires before a resize starts, return false to stop the execution
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The record about to be resized
         * @param {Ext.event.Event} e The event object
         */
        'beforeeventresize',
        /**
         * @event eventresizestart
         * Fires when resize starts
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The event record being resized
         */
        'eventresizestart',
        /**
         * @event eventpartialresize
         * Fires during a resize operation and provides information about the current start and end of the resized event
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The event record being resized
         * @param {Date} startDate The new start date of the event
         * @param {Date} endDate The new end date of the event
         * @param {Ext.Element} element The proxy element being resized
         */
        'eventpartialresize',
        /**
         * @event beforeeventresizefinalize
         * @preventable
         * Fires before a successful resize operation is finalized. Return false from a listener function to prevent the finalizing to
         * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
         * To finalize the operation, call the 'finalize' method available on the resizeContext object.
         * @param {Sch.view.SchedulerGridView} view The scheduler view instance
         * @param {Object} resizeContext An object containing 'eventRecord', 'start', 'end' and 'finalize' properties.
         * @param {Ext.event.Event} e The event object
         */
        'beforeeventresizefinalize',
        /**
         * @event eventresizeend
         * Fires after a successful resize operation
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The updated event record
         */
        'eventresizeend',
        /**
         * @event aftereventresize
         * Always fires after a resize operation
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The updated event record
         */
        'aftereventresize',
        // Resizing events end --------------------------
        // Dnd events start --------------------------
        /**
         * @event beforeeventdrag
         * @preventable
         * Fires before a dnd operation is initiated, return false to cancel it
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
         * @param {Ext.event.Event} e The event object
         */
        'beforeeventdrag',
        /**
         * @event eventdragstart
         * Fires when a dnd operation starts
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event[]} records An array with the records being dragged
         */
        'eventdragstart',
        /**
         * @event eventdrag
         * Fires when an event is dragged onto a new resource or time slot
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event[]} records An array with the records being dragged
         * @param {Date} date The new start date of the main event record
         * @param {Sch.model.Resource} resource The new resource for the main event record
         * @param {Object} dragData A custom drag drop context object
         */
        'eventdrag',
        /**
         * @event beforeeventdropfinalize
         * @preventable
         * Fires before a successful drop operation is finalized. Return false to finalize the drop at a later time.
         * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
         * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Object} dragContext An object containing 'eventRecord', 'start', 'end', 'newResource', 'finalize' properties.
         * @param {Ext.event.Event} e The event object
         */
        'beforeeventdropfinalize',
        /**
         * @event eventdrop
         * Fires after a successful drag-drop operation
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event[]} records the affected records (if copies were made, they were inserted into the store)
         * @param {Boolean} isCopy True if the records were copied instead of moved
         */
        'eventdrop',
        /**
         * @event aftereventdrop
         * Fires after a drag-drop operation, even when drop was performed on an invalid location
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event[]} records The affected records
         */
        'aftereventdrop',
        // Dnd events end --------------------------
        // Drag create events start --------------------------
        /**
         * @event beforedragcreate
         * @preventable
         * Fires before a drag starts, return false to stop the execution
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Resource} resource The resource record
         * @param {Date} date The clicked date on the timeaxis
         * @param {Ext.event.Event} e The event object
         */
        'beforedragcreate',
        /**
         * @event dragcreatestart
         * Fires before a drag starts
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Ext.Element} el The proxy element
         */
        'dragcreatestart',
        /**
         * @event beforedragcreatefinalize
         * @preventable
         * Fires before a successful resize operation is finalized. Return false from a listener function to prevent the finalizing to
         * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
         * To finalize the operation, call the 'finalize' method available on the createContext object.
         * @param {Mixed} view The scheduler view instance
         * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
         * @param {Ext.event.Event} e The event object
         * @param {Ext.Element} el The proxy element
         */
        'beforedragcreatefinalize',
        /**
         * @event dragcreateend
         * Fires after a successful drag-create operation
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
         * @param {Sch.model.Resource} resource The resource record to which the event belongs
         * @param {Ext.event.Event} e The event object
         * @param {Ext.Element} el The proxy element
         */
        'dragcreateend',
        /**
         * @event afterdragcreate
         * Always fires after a drag-create operation
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Ext.Element} el The proxy element
         */
        'afterdragcreate',
        // Drag create events end --------------------------
        /**
         * @event beforeeventadd
         * @preventable
         * Fires after a successful drag-create operation, before the new event is added to the store.
         * Return false to prevent the event from being added to the store.
         * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
         * @param {Sch.model.Event} eventRecord The newly created event record
         * @param {Sch.model.Resource[]} resources The resources to which the event is assigned
         */
        'beforeeventadd'
    ],
    inheritables: function() {
        return {
            variableRowHeight: true,
            // private
            initComponent: function() {
                var me = this,
                    viewConfig = me.normalViewConfig = me.normalViewConfig || {},
                    dependencyViewConfig = me.getDependencyViewConfig && me.getDependencyViewConfig() || {};
                me._initializeSchedulerPanel();
                me.verticalListeners = {
                    clear: me.refreshResourceColumns,
                    datachanged: me.refreshResourceColumns,
                    update: me.refreshResourceColumns,
                    // TODO WASTEFUL
                    load: me.refreshResourceColumns,
                    scope: me
                };
                me.calendarListeners = {
                    reconfigure: me.refreshCalendarColumns,
                    priority: 1,
                    scope: me
                };
                me.calendarNormalGridListeners = {
                    columnresize: me.onCalendarColumnResize,
                    scope: me
                };
                me.calendarResourceStoreListeners = {
                    load: me.onCalendarResourceStoreChange,
                    add: me.onCalendarResourceStoreChange,
                    remove: me.onCalendarResourceStoreChange,
                    scope: me
                };
                me.normalViewConfig = me.normalViewConfig || {};
                Ext.apply(me.normalViewConfig, {
                    eventStore: me.eventStore,
                    resourceStore: me.resourceStore,
                    dependencyStore: me.dependencyStore,
                    eventBarTextField: me.eventBarTextField || this.getEventStore().getModel().prototype.nameField
                });
                // Configure event template with extra dependency markup
                if (me.getDependencyStore() && dependencyViewConfig.enableDependencyDragDrop !== false) {
                    viewConfig.terminalSides = dependencyViewConfig.terminalSides || [
                        'left',
                        'right',
                        'top',
                        'bottom'
                    ];
                }
                Ext.copy(me.normalViewConfig, me, [
                    'barMargin',
                    'eventBodyTemplate',
                    'eventTpl',
                    'allowOverlap',
                    'dragConfig',
                    'eventBarIconClsField',
                    'onEventCreated',
                    'constrainDragToResource',
                    'snapRelativeToEventStartDate',
                    'eventSelModelType',
                    'eventSelModel',
                    'simpleSelect',
                    'multiSelect',
                    'allowDeselect',
                    'lockedGridDependsOnSchedule',
                    'showAllDayHeader'
                ], true);
                me.callParent(arguments);
                if (me.recurringEvents !== false && (!me.recurringEvents || !me.recurringEvents.isInstance)) {
                    me.recurringEvents = Ext.create(Ext.apply({
                        xclass: 'Sch.feature.RecurringEvents',
                        panel: me
                    }, me.recurringEvents));
                }
                if (!me.isHorizontal()) {
                    me.setGroupingFeatureDisabled(true);
                }
                // mode is safe to use after callParent where we check for deprecated 'orientation' option
                if (me.isVertical()) {
                    me.mon(me.resourceStore, me.verticalListeners);
                } else if (me.isWeekView() && me.showAllDayHeader) {
                    me.addDockedAllDayHeader();
                }
                var lockedView = me.lockedGrid.getView();
                var normalView = me.getSchedulingView();
                lockedView.on('resize', me.onLockedViewResize, me);
                // normalView.on('resize', me.onNormalViewResize, me);
                me.registerRenderer(normalView.columnRenderer, normalView);
                if (me.resourceZones) {
                    var resourceZoneStore = Ext.StoreManager.lookup(me.resourceZones);
                    me.resourceZonesPlug = new Sch.plugin.ResourceZones(Ext.apply({
                        store: resourceZoneStore
                    }, me.resourceZonesConfig));
                    me.resourceZonesPlug.init(me);
                }
                normalView.on('columnwidthchange', me.onColWidthChange, me);
                // Relaying after parent class has setup the locking grid components
                me.relayEvents(normalView, me.relayedViewEvents);
                // enable our row height injection if the default extjs row height synching mechanism is disabled
                // (it is disabled by default in our Lockable mixin, because it's slow)
                if (!me.syncRowHeight)  {
                    me.enableRowHeightInjection(lockedView, normalView);
                }
                
                if (me.getDependencyStore()) {
                    me.addCls('sch-scheduler-with-dependencies');
                }
            },
            configureColumns: function(columns) {
                var me = this;
                columns = columns || [
                    {
                        xtype: 'scheduler_resourcenamecolumn'
                    }
                ];
                me.callParent(arguments);
                me.verticalColumns = me.verticalColumns || [
                    Ext.apply({
                        xtype: 'verticaltimeaxis'
                    }, me.timeAxisColumnCfg || {})
                ];
                Ext.Array.each(me.verticalColumns, function(col) {
                    Ext.apply(col, {
                        timeAxis: me.timeAxis,
                        timeAxisViewModel: me.timeAxisViewModel,
                        cellTopBorderWidth: me.cellTopBorderWidth,
                        cellBottomBorderWidth: me.cellBottomBorderWidth
                    });
                });
                me.calendarColumns = [
                    Ext.apply({
                        xtype: 'verticaltimeaxis',
                        width: 60,
                        timeAxis: me.timeAxis,
                        timeAxisViewModel: me.timeAxisViewModel,
                        cellTopBorderWidth: me.cellTopBorderWidth,
                        cellBottomBorderWidth: me.cellBottomBorderWidth
                    }, me.calendarTimeAxisCfg || me.weekViewTimeAxisCfg || {})
                ];
                if (me.isVertical()) {
                    me.columns = me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth));
                    me.store = me.timeAxis;
                    if (me.resourceStore.isGrouped()) {
                        me.timeAxis.group(me.resourceStore.groupField);
                        me.bindGroupingFeatureListener();
                    }
                } else if (me.isWeekView()) {
                    // in order to build columns/rows for weekview we need time axis with view preset consumed
                    // but axis is filled only after columns are initialized thus can be changed only via 'reconfigure' method
                    // than requires grid to be rendered.
                    // We provide empty configs for columns and rows in order to make me procedure slightly faster
                    // There is almost no other way until timeaxis is filled before 'callParent' call.
                    me.columns = [];
                    me.store = null;
                    // in 6.2.1 scrollable on normal view is not initialized to 'afterrender' event, move reconfigure
                    // to beforerender to not invoke scrolling throwing exceptions
                    me.on('beforerender', me.refreshCalendarColumns, me);
                }
            },
            applyViewSettings: function(preset, initial) {
                this.callParent(arguments);
                var schedulingView = this.getSchedulingView(),
                    height;
                if (this.orientation === 'vertical') {
                    // timeColumnWidth is used for row height in vertical mode
                    height = preset.timeColumnWidth || 60;
                    schedulingView.setColumnWidth(preset.resourceColumnWidth || 100, true);
                    schedulingView.setRowHeight(height, true);
                }
            },
            onRender: function() {
                // Adjust buffered rendering settings based on mode. See comments at function definition
                if (!this.isHorizontal()) {
                    this.reconfigureBufferedRendering(true);
                }
                this.callParent(arguments);
            },
            afterRender: function() {
                var me = this;
                var schedulingView = this.getSchedulingView();
                this.callParent(arguments);
                if (this.isVertical()) {
                    this.onLockedViewResize(null, null, this.lockedGrid.getView().getHeight());
                } else if (this.isWeekView()) {
                    this.mon(this.timeAxis, this.calendarListeners);
                    this.mon(this.resourceStore, this.calendarResourceStoreListeners);
                    this.normalGrid.on(this.calendarNormalGridListeners);
                }
                if (this.infiniteScroll) {
                    schedulingView.on({
                        eventdragstart: this.doSuspendLayouts,
                        aftereventdrop: this.doResumeLayouts,
                        eventresizestart: this.doSuspendLayouts,
                        aftereventresize: this.doResumeLayouts,
                        scope: this
                    });
                }
                if (this.lockedGridDependsOnSchedule) {
                    schedulingView.on('itemupdate', this.onNormalViewItemUpdate, this);
                }
                this.relayEvents(this.getEventSelectionModel(), [
                    /**
                     * @event eventselectionchange
                     * Fired after a selection change has occurred
                     * @param {Sch.selection.EventModel} this
                     * @param {Sch.model.Event[]} selected The selected events
                     */
                    'selectionchange',
                    /**
                     * @event eventdeselect
                     * Fired after a record is deselected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The deselected event
                     */
                    'deselect',
                    /**
                     * @event eventselect
                     * Fired after a record is selected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The selected event
                     */
                    'select'
                ], 'event');
                this.getView().on('refresh', function() {
                    if (!me.isHorizontal()) {
                        me.reconfigureBufferedRendering();
                    }
                });
                // #7510
                var listeners = {
                        keydown: me.handleTimelineKeyEvent,
                        keypress: me.handleTimelineKeyEvent,
                        keyup: me.handleTimelineKeyEvent,
                        scope: me
                    };
                // normal grid body element can only be focused in IE11
                if (Ext.isIE11) {
                    me.normalGrid.el.on(listeners);
                } else {
                    schedulingView.el.on(listeners);
                }
                schedulingView.on({
                    eventclick: me.handleTimelineEventClick,
                    scope: me
                });
            },
            // We already instantiated calendar columns in the 'beforerender' event listener. If we do it here, we
            // will trigger view refresh -> clearViewEl (it is filtered out if view is not yet rendered) -> viewModel
            // notify which expects view is fully functional. But it is yet not fully functional, because layouts
            // are not yet calculated.
            // 40_calendar_basic 'Viewmodel..' test
            // if (this.isWeekView()) {
            //     this.refreshCalendarColumns();
            // }
            getTimeSpanDefiningStore: function() {
                return this.eventStore;
            },
            destroy: function() {
                var me = this;
                if (me.destroyStores) {
                    me.getDependencyStore() && me.getDependencyStore().destroy();
                    me.getAssignmentStore() && me.getAssignmentStore().destroy();
                    me.getEventStore() && me.getEventStore().destroy();
                    me.getResourceStore() && me.getResourceStore().destroy();
                }
                me.destroyDockedAllDayHeader();
                Ext.destroyMembers(me, 'resourceZonesPlug');
                me.callParent(arguments);
            },
            scrollToDateCentered: function(date, animate) {
                var view = this.getSchedulingView();
                if (view.isWeekView()) {
                    var column = view.weekview.getColumnsBy(function(column) {
                            return column.start <= date && column.end > date;
                        })[0];
                    if (column) {
                        var deltaX = view.getWidth() / 2;
                        var deltaY = view.getViewContainerHeight() / 2;
                        view.scrollHorizontallyTo(Math.max(column.getLocalX() - deltaX, 0));
                        view.scrollVerticallyTo(Math.max(view.getCoordinateFromDate(date, true) - deltaY, 0));
                    }
                } else {
                    return this.callParent(arguments);
                }
            }
        };
    },
    doSuspendLayouts: function() {
        // if infinite scroll is set we want to resume layouts for short timespan when scheduler is being refreshed
        this.timeAxis.on({
            beginreconfigure: this.onBeginReconfigure,
            endreconfigure: this.onEndReconfigure,
            scope: this
        });
        this.lockedGrid.suspendLayouts();
        this.normalGrid.suspendLayouts();
    },
    doResumeLayouts: function() {
        this.timeAxis.un({
            beginreconfigure: this.onBeginReconfigure,
            endreconfigure: this.onEndReconfigure,
            scope: this
        });
        this.lockedGrid.resumeLayouts();
        this.normalGrid.resumeLayouts();
    },
    onBeginReconfigure: function() {
        this.normalGrid.resumeLayouts();
    },
    onEndReconfigure: function() {
        this.normalGrid.suspendLayouts();
    },
    onColWidthChange: function(timeAxisViewModel, width) {
        if (this.isVertical()) {
            this.resourceColumnWidth = width;
            this.refreshResourceColumns();
        } else if (this.isWeekView()) {
            this.weekViewColumnWidth = width;
            this.refreshCalendarColumns();
        }
    },
    enableRowHeightInjection: function(lockedView) {
        var me = this;
        var cellTpl = new Ext.XTemplate('{%', 'this.processCellValues(values);', 'this.nextTpl.applyOut(values, out, parent);', '%}', {
                priority: 1,
                processCellValues: Ext.Function.bind(me.embedRowHeight, me)
            });
        lockedView.addCellTpl(cellTpl);
        // this is a workaround, to force ExtJS grid to use "long" rendering path when doing cell updates
        // which involves the cell templates (which we had overrode)
        // w/o it, grid may use "fast" path and only update the cell content, leaving the row height unsynchronized
        Ext.Array.each(this.columns, function(column) {
            column.hasCustomRenderer = true;
        });
        // Use same workaround for horizontal columns as it's a config for future mode changes
        // ticket #2925
        Ext.Array.each(this.horizontalColumns, function(column) {
            column.hasCustomRenderer = true;
        });
    },
    embedRowHeight: function(cellValues) {
        var me = this,
            schedulingView = me.getSchedulingView();
        if (schedulingView.isHorizontal()) {
            var nbrBands = 1;
            if (schedulingView.rowHasDynamicRowHeight(cellValues.record)) {
                var resource = cellValues.record;
                var layout = schedulingView.eventLayout.horizontal;
                nbrBands = layout.getNumberOfBands(resource, function() {
                    return schedulingView.getEventStore().filterEventsForResource(resource, schedulingView.timeAxis.isRangeInAxis, schedulingView.timeAxis);
                });
            }
            // We should actually increase row height on cellTop/BottomBorder
            var rowHeight = (nbrBands * me.getRowHeight()) - ((nbrBands - 1) * schedulingView.barMargin) + // 1 px for top row border width
                schedulingView.cellTopBorderWidth + schedulingView.cellBottomBorderWidth - 1;
            cellValues.style = (cellValues.style || '') + ';height:' + rowHeight + 'px;';
        }
    },
    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel: function() {
        return this.getSchedulingView().getEventSelectionModel();
    },
    refreshResourceColumns: function() {
        var w = this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth;
        // for vertical mode we only care about one vertical column and generated resource columns
        // this is not customizable
        this.reconfigure(this.verticalColumns.concat(this.createResourceColumns(w)));
    },
    onCalendarColumnResize: function(headerCt, column, width) {
        // Columns are not resizable individually, but we need to track their size to
        // adjust events accordingly in following cases:
        // 1: switching view preset with suspended layouts (e.g. when viewPreset is a binding in a viewmodel, #2641)
        // 2: panel is resized
        // tested by 40_calendar_basic
        if (width !== this.timeAxisViewModel.weekViewColumnWidth) {
            this.timeAxisViewModel.setViewColumnWidth(width, true);
        }
        // this may produce an animation of events resizing, but it's most straightforwad approach
        this.getSchedulingView().weekview.repaintEventsForColumn(column, headerCt.columnManager.indexOf(column));
    },
    onCalendarResourceStoreChange: function() {
        this.getSchedulingView().refreshView();
    },
    refreshCalendarColumns: function() {
        var rows = this.createCalendarRows();
        var columns = this.createCalendarColumns();
        this.reconfigure(rows, this.calendarColumns.concat(columns));
    },
    // This method will disable grouping feature and hide all UI related to groups
    setGroupingFeatureDisabled: function(disabled) {
        var me = this,
            view = me.normalGrid.view;
        // We can only support our scheduler_gropuing feature, which will be stored by this reference
        if (!view.groupingFeature || view.groupingFeature.disabled === disabled) {
            return;
        }
        // Feature is not shared between views, so it has to disabled on each one
        view.groupingFeature[disabled ? 'disable' : 'enable']();
        view = me.lockedGrid.view;
        view.groupingFeature[disabled ? 'disable' : 'enable']();
    },
    refreshGroupingStore: function() {
        var feature = this.normalGrid.view.groupingFeature;
        if (feature) {
            // Let grouping store know that time axis is reconfigured, otherwise view can be empty
            feature.dataSource.processStore(this.timeAxis);
        }
    },
    // When grid is configured with grouping feature, data source for each view will be replaced with grouping store,
    // which is bound to panel store. It will listen to datachanged event on panel store to update groups. But in vertical view
    // store is a time axis which will suspend all events except 'reconfigure'. So we have to listen to that to update
    // grouping store content
    bindGroupingFeatureListener: function() {
        // Set higher priority to refresh grouping store before view is refreshed
        this.mon(this.timeAxis, 'reconfigure', this.refreshGroupingStore, this, {
            priority: 10
        });
    },
    unbindGroupingFeatureListener: function() {
        this.mun(this.timeAxis, 'reconfigure', this.refreshGroupingStore);
    },
    /**
     * Switches the mode of this panel
     *
     * @param {String/Object}   modeCfg A string like 'horizontal', 'vertical', 'weekview' or an object
     * @param {String}          modeCfg.mode The new mode ('horizontal', 'vertical', 'weekview')
     * @param {String/Object}   [modeCfg.viewPreset] The id of the new preset (see {@link Sch.preset.Manager} for details)
     * @param {Date}            [modeCfg.startDate] A new start date for the time axis
     * @param {Date}            [modeCfg.endDate] A end start date for the time axis
     */
    setMode: function(modeCfg, force) {
        var me = this;
        // This could be called too early during initComponent phase (by responsive mechanism in Ext JS)
        if (!me.normalGrid) {
            me.on('afterrender', function() {
                me.setMode(modeCfg, true);
            });
            return;
        }
        var mode = typeof modeCfg === 'string' ? modeCfg : modeCfg.mode;
        if (!mode) {
            throw new Error('Mode is undefined');
        }
        // Due to #3345 - Rename 'calendar' mode in scheduler to weekview
        // silently fallback to 'weekview', if user passes 'calendar' as a mode
        if (mode === 'calendar')  {
            mode = 'weekview';
        }
        
        var viewPresetArgs;
        if (modeCfg.viewPreset) {
            viewPresetArgs = [
                modeCfg.viewPreset,
                modeCfg.startDate || null,
                modeCfg.endDate || null
            ];
        }
        if (mode === me.mode && !force) {
            viewPresetArgs && me.setViewPreset.apply(me, viewPresetArgs);
            return;
        }
        if (me.fireEvent('beforemodechange', me, modeCfg) !== false) {
            me.mode = mode;
            var normalGrid = me.normalGrid,
                schedulingView = me.getSchedulingView(),
                normalHeaderCt = normalGrid.headerCt;
            me.suspendRefresh();
            Ext.suspendLayouts();
            me.destroyDockedAllDayHeader();
            me.unbindGroupingFeatureListener();
            var isWeekView = me.isWeekView();
            var isSchWeekView = schedulingView.isWeekView();
            // if switched from weekview to horizontal/vertical and vice versa
            if ((isSchWeekView && !isWeekView) || (!isSchWeekView && isWeekView)) {
                viewPresetArgs = viewPresetArgs || me._oldViewPresetArgs || [
                    isWeekView ? 'week' : 'weekAndDay'
                ];
                me._oldViewPresetArgs = [
                    me.viewPreset,
                    me.timeAxis.getStart(),
                    me.timeAxis.getEnd()
                ];
            }
            schedulingView.setMode(mode);
            normalHeaderCt.removeAll(true);
            me.reconfigureBufferedRendering();
            switch (mode) {
                case 'horizontal':
                    me.configureHorizontalMode();
                    break;
                case 'vertical':
                    me.configureVerticalMode();
                    break;
                case 'weekview':
                    me.configureWeekViewMode();
                    break;
            }
            viewPresetArgs && me.setViewPreset.apply(me, viewPresetArgs);
            me.resumeRefresh(false);
            var splitter = me.getSplitter();
            if (splitter) {
                splitter.setVisible(mode === 'horizontal');
            }
            me.refreshViews(false);
            Ext.resumeLayouts(true);
            me.fireEvent('modechange', me, modeCfg);
        }
    },
    configureHorizontalMode: function() {
        var me = this;
        var schedulingView = me.getSchedulingView();
        me.timeAxis.setMode('plain');
        me.removeCls(me.verticalCls).removeCls(me.weekviewCls).addCls(me.horizontalCls);
        me.setGroupingFeatureDisabled(false);
        me.mun(me.resourceStore, me.verticalListeners);
        me.mun(me.resourceStore, me.calendarResourceStoreListeners);
        me.normalGrid.un(me.calendarNormalGridListeners);
        schedulingView.setRowHeight(me.getRowHeight(), true);
        me.reconfigure(me.resourceStore, me.horizontalColumns);
        if (me.horizontalLockedWidth !== null) {
            me.lockedGrid.setWidth(me.horizontalLockedWidth);
        }
        var groupField = me.resourceStore.groupField;
        if (groupField) {
            me.store.group(groupField);
        }
        // remove listeners to avoid refreshing weekview columns using wrong presets
        me.mun(me.timeAxis, me.calendarListeners);
    },
    configureVerticalMode: function() {
        var me = this;
        var schedulingView = me.getSchedulingView();
        me.removeCls(me.horizontalCls).removeCls(me.weekviewCls).addCls(me.verticalCls);
        me.setGroupingFeatureDisabled(true);
        me.normalGrid.un(me.calendarNormalGridListeners);
        me.mun(me.resourceStore, me.calendarResourceStoreListeners);
        var lockedWidth = 0;
        if (me.rendered) {
            me.horizontalLockedWidth = me.lockedGrid.getWidth();
        }
        me.mon(me.resourceStore, me.verticalListeners);
        me.bindGroupingFeatureListener();
        me.reconfigure(me.timeAxis, me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth)));
        Ext.Array.each(me.lockedGrid.query('gridcolumn'), function(col) {
            lockedWidth += col.rendered ? col.getWidth() : col.width || 100;
        });
        schedulingView.setColumnWidth(me.timeAxisViewModel.resourceColumnWidth || 100, true);
        me.lockedGrid.setWidth(lockedWidth);
    },
    configureWeekViewMode: function() {
        var me = this;
        var normalGrid = me.normalGrid,
            schedulingView = me.getSchedulingView();
        me.removeCls(me.horizontalCls).removeCls(me.verticalCls).addCls(me.weekviewCls);
        me.setGroupingFeatureDisabled(true);
        me.timeAxis.setMode('week');
        // TODO: we want to save time span of the axis and restore it upon switching back
        me.mun(me.resourceStore, me.verticalListeners);
        me.mon(me.resourceStore, me.calendarResourceStoreListeners);
        me.normalGrid.on(me.calendarNormalGridListeners);
        me.bindGroupingFeatureListener();
        me.refreshCalendarColumns();
        schedulingView.setRowHeight(me.getRowHeight(), true);
        schedulingView.setColumnWidth(me.timeAxisViewModel.weekViewColumnWidth || 100, true);
        me.mon(me.timeAxis, me.calendarListeners);
    },
    addDockedAllDayHeader: function() {
        var me = this;
        if (me.showAllDayHeader) {
            me.allDayLockedHeader = me.lockedGrid.addDocked({
                xtype: 'component',
                dock: 'top',
                cls: [
                    'sch-all-day-locked-header',
                    Ext.baseCSSPrefix + 'unselectable'
                ],
                height: 24,
                weight: 100,
                html: me.L('All day')
            })[0];
            me.allDayNormalHeader = me.normalGrid.addDocked({
                xtype: 'alldayheader',
                height: 24,
                weight: 100,
                lockedHeaderPartner: me.allDayLockedHeader,
                eventSelModel: me.eventSelModel && !me.eventSelModel.isSelectionModel ? me.eventSelModel : null,
                mainScheduler: me
            })[0];
        }
    },
    destroyDockedAllDayHeader: function() {
        var me = this;
        if (me.allDayLockedHeader) {
            me.allDayLockedHeader.destroy();
            me.allDayNormalHeader.destroy();
            me.allDayLockedHeader = me.allDayNormalHeader = null;
        }
    },
    // Disable buffered rendering mechanism for non-horizontal views using the time axis as the row-backing store input
    // https://app.assembla.com/spaces/bryntum/tickets/2956-scroll-not-working-properly-when-time-increment---15/details#
    reconfigureBufferedRendering: function(initial) {
        var me = this;
        if (me.bufferedRenderer && me.rendered) {
            var lockedPlugin = me.lockedGrid.bufferedRenderer,
                normalPlugin = me.normalGrid.bufferedRenderer,
                value;
            if (!me.isHorizontal()) {
                value = me.timeAxis.getCount();
                me.__oldLeadingBufferZone = lockedPlugin.leadingBufferZone;
            } else if (me.__oldLeadingBufferZone) {
                value = me.__oldLeadingBufferZone;
                me.__oldLeadingBufferZone = null;
            }
            if (!initial && lockedPlugin.scroller && lockedPlugin.scroller.getLockedScroller()) {
                // HACK, me cached size property must be cleared when our mode changes or when view size changes
                var height = me.lockedGrid.view.getHeight(),
                    viewSize = Math.ceil(height / lockedPlugin.rowHeight) + lockedPlugin.trailingBufferZone + value;
                // Pass true as a second argument to force new calculated value
                lockedPlugin.setViewSize(viewSize, true);
                normalPlugin.setViewSize(viewSize, true);
            }
            lockedPlugin.leadingBufferZone = normalPlugin.leadingBufferZone = value;
        }
    },
    createCalendarRows: function() {
        var me = this,
            rows = me.timeAxis.getRowTicks();
        // we have to cache weekview rows amount to use it in timeAxisViewModel calculations
        me.timeAxisViewModel.calendarRowsAmount = rows.length;
        return new Ext.data.Store({
            model: 'Sch.model.TimeAxisTick',
            data: rows
        });
    },
    createCalendarColumns: function() {
        var me = this,
            timeAxis = me.timeAxis,
            currentHeader = timeAxis.headerConfig.middle,
            columns = [],
            lastDay;
        var startTime = me.startTime = timeAxis.startTime;
        var endTime = me.endTime = timeAxis.endTime;
        // iterate over ticks to find actual days in axis
        timeAxis.each(function(tick) {
            var start = tick.getStartDate();
            if (lastDay !== start.getDay()) {
                lastDay = start.getDay();
                start.setHours(startTime);
                var end = new Date(start);
                end.setHours(endTime);
                var header = {
                        xclass: me.weekViewColumnClass,
                        renderer: me.mainRenderer,
                        scope: me,
                        start: start,
                        end: end
                    };
                if (currentHeader.renderer) {
                    header.text = currentHeader.renderer.call(currentHeader.scope || me, start, end, header, columns.length, me.getEventStore());
                } else {
                    header.text = Ext.Date.format(start, currentHeader.dateFormat);
                }
                columns.push(header);
            }
        });
        me.timeAxisViewModel.updateCalendarColumnDates(columns);
        return columns;
    },
    onNormalViewItemUpdate: function(record) {
        if (this.lockedGridDependsOnSchedule) {
            var lockedView = this.lockedGrid.getView();
            lockedView.suspendEvents();
            // we cannot trust 'index' argument it may be wrong in case of grouping feature enabled
            lockedView.refreshNode(lockedView.indexOf(record));
            // Locked rowheight not properly updated when syncRowHeights is true and adding an overlapping event
            if (this.syncRowHeight) {
                this.syncRowHeights();
            }
            lockedView.resumeEvents();
        }
    },
    onLockedViewResize: function(cmp, width, height, oldWidth, oldHeight) {
        if (!this.isHorizontal() && height !== oldHeight) {
            // Grab the full height of the view, minus the spacer el height and an extra buffer
            this.timeAxisViewModel.update(height - 21);
        }
    },
    // onNormalViewResize : function (view, width, height, oldWidth, oldHeight) {
    //     if (this.isWeekView() && oldWidth !== width) {
    //         var columns = view.headerCt.getGridColumns(),
    //             colWidth   = Math.floor(width / columns.length) - Ext.getScrollbarSize().width;
    //
    //         this.suspendLayouts();
    //         columns.forEach(function (col) {
    //             col.setWidth(colWidth);
    //         });
    //         this.resumeLayouts(true);
    //     }
    // },
    /**
     * Sets the row height of the timeline panel
     * @param {Number} height The height to set
     * @param {Boolean} preventRefresh `true` to prevent view refresh
     */
    setRowHeight: function(height, preventRefresh) {
        // Prevent any side effects if the panel is not yet done initializing
        preventRefresh = preventRefresh || !this.lockedGrid;
        this.readRowHeightFromPreset = false;
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },
    handleTimelineKeyEvent: function(e) {
        var me = this,
            view = me.getSchedulingView(),
            sm = view.getEventSelectionModel(),
            selection = sm.getSelection();
        // Take last selected event (it would be focused normally) and fire eventkeydown for it
        if (selection.length) {
            view.fireEvent(view.scheduledEventName + e.type, view, selection.pop(), e);
        }
    },
    handleTimelineEventClick: function(view, eventRecord, e) {
        // When event element is clicked, focus normal view. It shouldn't scroll anything and would allow to simulate
        // eventkeydown using event selection (see above)
        if (Ext.isIE11) {
            this.normalGrid.el.focus();
        } else {
            view.getNavigationModel().setPosition(view.getRecord(e.getTarget(view.itemSelector)), 0);
            view.el.focus();
        }
    }
});

/**
@class Sch.plugin.CurrentTimeLine
@extends Sch.plugin.Lines

Plugin (ptype = 'scheduler_currenttimeline') indicating the current date and time as a line in the schedule.

To add this plugin to scheduler:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.CurrentTimeLine', { updateInterval : 30000 })
        ]
    });


*/
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend: "Sch.plugin.Lines",
    alias: 'plugin.scheduler_currenttimeline',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.data.JsonStore'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - tooltipText : 'Current time'
     */
    /**
     * @cfg {Ext.data.Store} store
     * @hide
     */
    /**
     * @cfg {Number} updateInterval This value (in ms) defines how often the timeline shall be refreshed. Defaults to every once every minute.
     */
    updateInterval: 60000,
    showHeaderElements: true,
    /**
     * @cfg {Boolean} autoUpdate true to automatically update the line position over time. Default value is `true`
     */
    autoUpdate: true,
    expandToFitView: true,
    timer: null,
    init: function(cmp) {
        var me = this;
        // touch scheduler does not support header elements
        if (Ext.getVersion('touch'))  {
            me.showHeaderElements = false;
        }
        
        me.store = new Ext.data.JsonStore({
            autoDestroy: true,
            fields: [
                'Date',
                'Cls',
                'Text'
            ],
            data: [
                {
                    Date: new Date(),
                    Cls: 'sch-todayLine',
                    Text: me.L('tooltipText')
                }
            ]
        });
        if (me.autoUpdate) {
            me.timer = setInterval(function() {
                me.updateDate();
            }, me.updateInterval);
        }
        me.updateDate();
        me.callParent(arguments);
    },
    updateDate: function() {
        var me = this,
            record = me.store.first();
        record.set('Date', new Date());
    },
    destroy: function() {
        var me = this;
        clearInterval(me.timer);
        me.timer = null;
        if (me.store.autoDestroy) {
            me.store.destroy();
        }
        me.callParent(arguments);
    }
});

// With card layout scheduler may be rendered skipping layout, this will throw exception
// when reconfiguring such grid
// https://www.sencha.com/forum/showthread.php?333737
Ext.define('Sch.patches.LockingScroller', {
    extend: 'Sch.util.Patch',
    target: 'Ext.scroll.Scroller',
    minVersion: '6.2.0',
    overrides: {
        scrollTo: function() {
            // If there's no normal scroller in timeline panel - do not scroll, otherwise exception will be raised
            if (this.getNormalScroller && !this.getNormalScroller()) {
                if (Sch.panel.TimelineGridPanel && this.component instanceof Sch.panel.TimelineGridPanel || Sch.panel.TimelineTreePanel && this.component instanceof Sch.panel.TimelineTreePanel) {
                    return;
                }
            }
            return this.callParent(arguments);
        }
    }
});

/**
@class Sch.plugin.NonWorkingTime
@extends Sch.plugin.Zones

A simple subclass of the {@link Sch.plugin.Zones} which highlights holidays/weekends on the timeline.
Generally, there's no need to instantiate it manually, it can be activated with the {@link Sch.mixin.TimelinePanel#highlightWeekends} configuration option.

{@img gantt/images/plugin-working-time.png}

Note, that the holidays/weekends will only be shown when the resolution of the time axis is weeks or less.

*/
Ext.define("Sch.plugin.NonWorkingTime", {
    extend: 'Sch.plugin.Zones',
    alias: 'plugin.scheduler_nonworkingtime',
    alternateClassName: 'Gnt.feature.WorkingTime',
    requires: [
        'Ext.data.Store',
        'Sch.model.Range'
    ],
    expandToFitView: true,
    /**
     * @cfg {Sch.data.Calendar} calendar The calendar to extract the holidays from
     */
    calendar: {
        type: 'calendar'
    },
    timeAxis: null,
    init: function(timelinePanel) {
        this.calendar = this.calendar && Ext.StoreMgr.lookup(this.calendar);
        if (!this.calendar) {
            Ext.Error.raise("Required attribute 'calendar' missed during initialization of 'Sch.plugin.NonWorkingTime'");
        }
        this.store = new Ext.data.Store({
            model: 'Sch.model.Range',
            autoDestroy: true
        });
        this.timeAxis = timelinePanel.getTimeAxis();
        this.callParent(arguments);
        if (timelinePanel.isWeekView()) {
            timelinePanel.normalGrid.headerCt.on('afterlayout', this.onViewChange, this);
        } else {
            timelinePanel.on('viewchange', this.onViewChange, this);
        }
        this.bindCalendar(this.calendar);
    },
    bindCalendar: function(calendar) {
        var listeners = {
                datachanged: this.refresh,
                update: this.refresh,
                scope: this,
                delay: 1
            };
        if (this.calendar) {
            this.calendar.un(listeners);
        }
        if (calendar) {
            calendar.on(listeners);
        }
        this.calendar = calendar;
        this.refresh();
    },
    onViewReady: function() {
        this.callParent(arguments);
        if (this.schedulerView.isWeekView()) {
            // unbind extra listeners
            this.onTimelinePanelBeforeModeChange();
            // set listeners to empty object to avoid adding them later
            this.headerListeners = {};
        }
    },
    onViewChange: function() {
        var DATE = Sch.util.Date;
        var disabled = DATE.isUnitGreater(this.timeAxis.unit, DATE.WEEK);
        this.setDisabled(disabled);
        if (!disabled) {
            this.refresh();
        }
    },
    setDisabled: function(disabled) {
        var wasDisabled = this.disabled;
        this.callParent(arguments);
        if (wasDisabled && !disabled) {
            this.refresh();
        }
    },
    refresh: function() {
        if (this.store && !this.store.destroyed) {
            this.store.removeAll(true);
            if (this.calendar) {
                this.store.add(this.calendar.getHolidaysRanges(this.timeAxis.getStart(), this.timeAxis.getEnd(), true, this.timeAxis.timeZone));
            }
        }
    },
    destroy: function() {
        this.bindCalendar(null);
        this.callParent(arguments);
    }
});

/**
 * @class Sch.mixin.TimelinePanel
 * @extends Sch.mixin.AbstractTimelinePanel
 *
 * A base mixin for {@link Ext.panel.Panel} classes,
 * giving to the consuming panel the "time line" functionality.
 * This means that the panel will be capabale to display a list of "events",
 * ordered on the {@link Sch.data.TimeAxis time axis}.
 *
 * Generally, should not be used directly, if you need to subclass the scheduler panel,
 * subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree} instead.
 */
Ext.define('Sch.mixin.TimelinePanel', {
    extend: 'Sch.mixin.AbstractTimelinePanel',
    requires: [
        'Sch.column.timeAxis.Horizontal',
        'Sch.preset.Manager',
        'Sch.data.Calendar',
        'Sch.plugin.CurrentTimeLine',
        'Sch.layout.TableLayout',
        'Sch.patches.LockingScroller',
        'Sch.plugin.NonWorkingTime',
        // for Sencha Cmd in production mode
        'Ext.grid.plugin.BufferedRenderer'
    ],
    uses: [
        'Ext.layout.container.Border',
        'Sch.patches.TablePanel_6_2_1',
        'Sch.patches.TableView',
        'Sch.patches.BufferedRenderer',
        'Sch.patches.BufferedRenderer_6_2_1',
        'Sch.patches.BufferedRendererResize',
        'Sch.patches.CellContext',
        'Sch.patches.TimelineGridView',
        'Sch.patches.TimelineGridViewScroll6_2',
        'Sch.patches.TimelinePanel',
        'Sch.patches.TouchAction',
        'Sch.plugin.NonWorkingTime'
    ],
    mixins: [
        'Sch.mixin.Zoomable',
        'Sch.mixin.PartnerTimelinePanel'
    ],
    /**
     *  @cfg {Boolean} destroyStores True to delete all stores used by this component when it's destroyed (including the global CalendarManager)
     */
    destroyStores: false,
    /**
     * @cfg {Object} lockedGridConfig A custom config object used to initialize the left (locked) grid panel.
     */
    /**
     * @cfg {Object} schedulerConfig A custom config object used to initialize the right (schedule) grid panel.
     */
    /**
     * @cfg {String/Ext.Template} tooltipTpl
     * Template used to show a tooltip over a scheduled item, null by default (meaning no tooltip). The tooltip will be populated with the data in
     * record corresponding to the hovered element. See also {@link #tipCfg} and to provide your own custom data object for this
     * template, please see {@link Sch.mixin.TimelineView#getDataForTooltipTpl}.
     */
    /**
     * @cfg {Sch.mixin.TimelinePanel/String} partnerTimelinePanel A reference to another timeline panel (or a component id) that this panel should be 'partner' with.
     * If this config is supplied, this panel will:
     *
     * - Share and use the {@link Sch.data.TimeAxis} timeAxis from the partner panel.
     * - Synchronize the width of the two locked grid panels (after a drag of the splitter).
     * - Synchronize horizontal scrolling between two panels.
     */
    /**
     * @cfg {Number} bufferCoef
     *
     * This config defines the width of the left and right invisible parts of the timespan when {@link #infiniteScroll} set to `true`.
     *
     * It should be provided as a coefficient, which will be multiplied by the width of the scheduling area.
     *
     * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to
     * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting
     * in 2200px of totally rendered content.
     *
     * The timespan gets recalculated when the scroll position reaches the limits defined by the {@link #bufferThreshold} option.
     *
     */
    bufferCoef: 5,
    /**
     * @cfg {Number} bufferThreshold
     *
     * This config defines the horizontal scroll limit, which, when exceeded will cause a timespan shift.
     * The limit is calculated as the `panelWidth * {@link #bufferCoef} * bufferThreshold`. During scrolling, if the left or right side
     * has less than that of the rendered content - a shift is triggered.
     *
     * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan
     * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.
     */
    bufferThreshold: 0.2,
    /**
     * @cfg {Boolean} infiniteScroll
     *
     * True to automatically adjust the panel timespan during horizontal scrolling, when the scroller comes close to the left/right edges.
     *
     * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based
     * on the {@link #bufferCoef} option. The moment when the timespan shift happens is determined by the {@link #bufferThreshold} value.
     */
    infiniteScroll: false,
    /**
     * @cfg {Boolean} showCrudManagerMask set this to true to display a load mask during CRUD manager server requests. Note: works only if {@link #crudManager} is specified.
     */
    showCrudManagerMask: true,
    /**
     * @cfg {Boolean} highlightWeekends
     * True (default) to highlight weekends and holidays, using the {@link Sch.plugin.NonWorkingTime} plugin.
     */
    highlightWeekends: false,
    /**
     * @cfg {Boolean} zoomOnTimeAxisDoubleClick
     * True to zoom to time span when double clicking a time axis cell.
     */
    zoomOnTimeAxisDoubleClick: true,
    // that's to say a zoom in the week view
    switchToDayViewOnWeekDayHeaderDblClick: true,
    waitingForAutoTimeSpan: false,
    /**
     * @cfg {Boolean} showTodayLine
     * True to show a line indicating current time.
     */
    showTodayLine: false,
    /**
     * @cfg {Sch.data.Calendar} calendar a {@link Sch.data.Calendar calendar} instance for this timeline panel.
     */
    calendar: null,
    /**
     * @cfg {String} horizontalTimeAxisColumnCfg
     *
     * Horizontal time axis column config
     *
     * @private
     */
    horizontalTimeAxisColumnCfg: null,
    columnLinesFeature: null,
    renderWaitListener: null,
    enablePinchZoom: true,
    schedulePinchThreshold: 30,
    pinchStartDistanceX: null,
    pinchStartDistanceY: null,
    pinchDistanceX: null,
    pinchDistanceY: null,
    horizontalColumns: null,
    forceDefineTimeSpanByStore: false,
    workingTimePlugin: null,
    // Split the left / right grid and add a draggable splitter
    split: true,
    /**
     * @property {Number} refreshSuspensionCount Increased on calls to suspendRefresh, decreased on resumeRefresh
     * @private
     */
    refreshSuspensionCount: 0,
    /**
     * @cfg {Object} tipCfg
     * The {@link Ext.Tooltip} config object used to configure a tooltip (only applicable if tooltipTpl is set).
     */
    tipCfg: {
        cls: 'sch-tip',
        showDelay: 400,
        hideDelay: 0,
        constrain: true,
        autoHide: true,
        anchor: 't'
    },
    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulelongpress
     * Fires when a longpress on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinchstart
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinch
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @event schedulepinchend
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The pinched date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.event.Event} e The event object
     */
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading, please wait...'
     - savingText : 'Saving changes, please wait...'
     */
    inheritables: function() {
        return {
            // Configuring underlying table panel
            columnLines: true,
            enableLocking: true,
            lockable: true,
            stateEvents: [
                'viewchange'
            ],
            syncRowHeight: false,
            // Without border layout splitter is hidden in view section and doesn't resize at all
            layout: 'border',
            // private
            initComponent: function() {
                if (this.partnerTimelinePanel) {
                    // Allow a cmp id to be passed in
                    if (typeof this.partnerTimelinePanel === 'string') {
                        this.partnerTimelinePanel = Ext.getCmp(this.partnerTimelinePanel);
                    }
                    this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                    this.timeAxis = this.partnerTimelinePanel.getTimeAxis();
                    this.startDate = this.timeAxis.getStart();
                    this.endDate = this.timeAxis.getEnd();
                }
                this._initializeTimelinePanel();
                this.configureChildGrids();
                // Now the time axis view model is configured using the forceFit setting.
                // We never want the native Ext JS grid implementation of forceFit - disable it
                this.forceFit = false;
                this.configureColumns(this.columns);
                if (Ext.getVersion().equals('6.0.2.437')) {
                    this.viewConfig = Ext.apply(this.viewConfig || {}, {
                        componentLayout: 'timeline_tablelayout'
                    });
                }
                var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
                var id = this.getId();
                // Copy some properties to the view instance
                Ext.apply(this.normalViewConfig, {
                    id: id + '-timelineview',
                    eventPrefix: this.normalViewConfig.eventPrefix || (this.autoGenId ? null : id),
                    timeAxisViewModel: this.timeAxisViewModel,
                    eventBorderWidth: this.eventBorderWidth,
                    timeAxis: this.timeAxis,
                    readOnly: this.readOnly,
                    mode: this.mode,
                    rtl: this.rtl,
                    cellBorderWidth: this.cellBorderWidth,
                    cellTopBorderWidth: this.cellTopBorderWidth,
                    cellBottomBorderWidth: this.cellBottomBorderWidth,
                    infiniteScroll: this.infiniteScroll,
                    bufferCoef: this.bufferCoef,
                    bufferThreshold: this.bufferThreshold
                });
                Ext.copy(viewConfig, this, [
                    "eventRendererScope",
                    "eventRenderer",
                    "dndValidatorFn",
                    "resizeValidatorFn",
                    "createValidatorFn",
                    "tooltipTpl",
                    "validatorFnScope",
                    "eventResizeHandles",
                    "enableEventDragDrop",
                    "enableDragCreation",
                    "createEventOnDblClick",
                    "resizeConfig",
                    "createConfig",
                    "tipCfg",
                    "getDateConstraints"
                ], true);
                this.callParent(arguments);
                this.lockedGrid.view.addCls('sch-lockedview');
                if (this.rtl) {
                    // Locked column in RTL positioned incorrectly by EXT
                    // https://www.sencha.com/forum/showthread.php?299582-RTL-locking-grid-bug
                    // https://www.sencha.com/forum/showthread.php?304826-Locked-column-content-is-misaligned-with-RTL-ext
                    this.lockedGrid.view.addCls('sch-locked-column-fixer');
                    this.addCls('sch-rtl');
                } else {
                    this.addCls('sch-ltr');
                }
                var plugins = this.plugins = [].concat(this.plugins || []);
                if (this.highlightWeekends) {
                    var calendar = this.getCalendar();
                    calendar = calendar && Ext.StoreMgr.lookup(calendar) || new Sch.data.Calendar();
                    this.workingTimePlugin = new Sch.plugin.NonWorkingTime({
                        calendar: calendar
                    });
                    this.timeAxisViewModel.setCalendar(calendar);
                    plugins.push(this.workingTimePlugin);
                    this.addCls('sch-timelinepanel-highlightweekends');
                }
                if (this.showTodayLine) {
                    this.todayLinePlugin = new Sch.plugin.CurrentTimeLine();
                    plugins.push(this.todayLinePlugin);
                }
                this.patchNavigationModel(this);
                if (Ext.supports.Touch) {
                    // During zooming operation header container sometimes cannot be scrolled to required position
                    // because touchscroller on header will return wrong size. Refresh it when header is updated
                    // https://www.assembla.com/spaces/bryntum/tickets/2690
                    // covered by several zooming tests on touch device
                    this.timeAxisViewModel.on('update', this.refreshHeaderContainerScrollable, this);
                }
                this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);
                // if no start/end dates specified let's get them from event store
                if (!this.startDate) {
                    var crud = this.crudManager;
                    // If crud manager is provided, we should listen to it's loading status
                    if (crud && !crud.loaded) {
                        this.bindAutoTimeSpanListeners();
                    } else {
                        var store = this.getTimeSpanDefiningStore();
                        // if events already loaded
                        if (store.isTreeStore ? store.getRoot() && store.getRoot().childNodes.length : store.getCount()) {
                            this.applyStartEndDatesFromStore();
                        }
                        // if timespan defining store is in state of loading
                        // or forceDefineTimeSpanByStore enabled
                        // we wait till the store gets loaded and only then refresh view
                        else if (store.isLoading() || this.forceDefineTimeSpanByStore) {
                            this.bindAutoTimeSpanListeners();
                        }
                    }
                }
                var columnLines = this.columnLines;
                if (columnLines) {
                    this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(columnLines) ? columnLines : undefined);
                    this.columnLinesFeature.init(this);
                    this.columnLines = true;
                }
                this.relayEvents(this.getSchedulingView(), [
                    /**
                 * @event beforetooltipshow
                 * @preventable
                 * Fires before the event tooltip is shown, return false to suppress it.
                 * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
                 * @param {Sch.model.Event} eventRecord The event record of the clicked record
                 */
                    'beforetooltipshow',
                    'scheduleclick',
                    'scheduledblclick',
                    'schedulecontextmenu',
                    'schedulelongpress',
                    'schedulepinch',
                    'schedulepinchstart',
                    'schedulepinchend'
                ]);
                // HACK, required since Ext has an async scroll sync mechanism setup which won't play nice with our "sync scroll" above.
                this.on('zoomchange', function() {
                    // After a zoom, the header is resized and Ext JS TablePanel reacts to the size change.
                    // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                    this.normalGrid.scrollTask.cancel();
                });
                if (this.crudManager) {
                    // if we have CrudManager instance assigned, we should show and hide a load mask
                    // But not with autoSync enabled, since that'll be a terrible user experience
                    if (!this.crudManager.autoSync && this.showCrudManagerMask) {
                        this.mon(this.crudManager, {
                            beforesend: this.beforeCrudOperationStart,
                            responseapplycancelled: this.onCrudOperationComplete,
                            synccanceled: this.onCrudOperationComplete,
                            loadcanceled: this.onCrudOperationComplete,
                            load: this.onCrudOperationComplete,
                            sync: this.onCrudOperationComplete,
                            requestfail: this.onCrudOperationComplete,
                            scope: this
                        });
                        // User might already have triggered a load operation
                        if (this.crudManager.isLoading()) {
                            this.beforeCrudOperationStart(this.crudManager, null, 'load');
                        }
                    }
                    // prevent multiple refreshes on crud manager load
                    // #2494 - View is refreshed twice during crud manager load
                    this.mon(this.crudManager, {
                        beforeloadapply: this.onCrudBeforeLoad,
                        load: this.onCrudLoad,
                        scope: this
                    });
                }
                // Patching header/grid horizontal scroll position synchronization for Mac
                // though it might depend on floating scrollbars (which are mostly used on Mac)
                if (Ext.isMac) {
                    this.patchHeaderScrollSync(this);
                }
                this.afterInitComponent();
            },
            refreshHeaderContainerScrollable: function() {
                var scrollable = this.getSchedulingView().headerCt.getScrollable();
                // If panel is not yet rendered there is no scrollable
                if (!scrollable)  {
                    return;
                }
                
                if (Ext.getVersion().isLessThan('6.0.1')) {
                    var old = scrollable.isConfiguring;
                    // Without this hack view will continuously scroll to 0 and reconfigure until exception is raised
                    scrollable.isConfiguring = true;
                    // Refresh current scrollable size or it will constrain requested scroll
                    scrollable.refresh();
                    // This call will update max position for scrollable, if we don't do that, header won't be
                    // scrollable anymore
                    scrollable.refreshAxes();
                    scrollable.isConfiguring = old;
                } else {
                    scrollable.refresh();
                }
            },
            getState: function() {
                var me = this,
                    state = me.callParent(arguments);
                Ext.apply(state, {
                    viewPreset: me.viewPreset,
                    startDate: me.getStart(),
                    endDate: me.getEnd(),
                    zoomMinLevel: me.zoomMinLevel,
                    zoomMaxLevel: me.zoomMaxLevel,
                    currentZoomLevel: me.currentZoomLevel
                });
                return state;
            },
            applyState: function(state) {
                var me = this;
                me.callParent(arguments);
                if (state && state.viewPreset) {
                    me.setViewPreset(state.viewPreset, state.startDate, state.endDate);
                }
                if (state && state.currentZoomLevel) {
                    me.zoomToLevel(state.currentZoomLevel);
                }
            },
            setTimeSpan: function() {
                this.callParent(arguments);
                if (this.waitingForAutoTimeSpan) {
                    // we pass false to not refresh views inside of unbindAutoTimeSpanListeners()
                    // since we do it manually in the next line
                    this.unbindAutoTimeSpanListeners(false);
                    // If we unbind autotimespan listeners, that means refresh was prevented
                    // and now it's required. Normally it would be called inside 'callParent', but
                    // in 5.1.1 that call produces layout issue. This action seem to be similar
                    this.getView().refresh();
                }
                // if view was not initialized due to our refresh stopper the onTimeAxisViewModelUpdate method will not do a refresh
                // if that happened we do refresh manually
                if (!this.normalGrid.getView().viewReady) {
                    this.getView().refresh();
                }
            },
            onBoxReady: function() {
                var me = this;
                me.callParent(arguments);
                if (me.partnerTimelinePanel) {
                    if (me.partnerTimelinePanel.rendered) {
                        me.setupPartnerTimelinePanel(me.partnerTimelinePanel);
                    } else {
                        me.partnerTimelinePanel.on('boxready', me.setupPartnerTimelinePanel, me);
                    }
                }
                me.normalGrid.on({
                    collapse: me.onNormalGridCollapse,
                    expand: me.onNormalGridExpand,
                    scope: me
                });
                me.normalGrid.headerCt.el.on({
                    click: me.onHeaderClick,
                    dblclick: me.onHeaderClick,
                    contextmenu: me.onHeaderClick,
                    delegate: '.sch-daycolumn-header',
                    scope: me
                });
                me.lockedGrid.on({
                    collapse: me.onLockedGridCollapse,
                    expand: me.onLockedGridExpand,
                    scope: me
                });
                me.lockedGrid.on({
                    itemdblclick: me.onLockedGridItemDblClick,
                    scope: me
                });
                if (me.enablePinchZoom && Ext.supports.Touch) {
                    this.getSchedulingView().on({
                        schedulepinchstart: this.onSchedulePinchStart,
                        schedulepinch: this.onSchedulePinch,
                        schedulepinchend: this.onSchedulePinchEnd,
                        scope: this
                    });
                }
            }
        };
    },
    scrollToDate: function(date, animate) {
        var view = this.getSchedulingView();
        if (view.isWeekView()) {
            var column = view.weekview.getColumnsBy(function(column) {
                    return column.start <= date && column.end > date;
                })[0];
            if (column) {
                view.scrollHorizontallyTo(column.getLocalX());
                view.scrollVerticallyTo(view.getCoordinateFromDate(date, true));
            }
        } else {
            return this.callParent(arguments);
        }
    },
    bindAutoTimeSpanListeners: function() {
        var store = this.getTimeSpanDefiningStore();
        this.waitingForAutoTimeSpan = true;
        // prevent panel refresh till eventStore gets loaded
        //this.suspendViewsRefresh();
        this.suspendRefresh();
        this.mon(store, 'load', this.applyStartEndDatesFromStore, this);
        if (store.isTreeStore) {
            this.mon(store, 'rootchange', this.applyStartEndDatesFromStore, this);
            this.mon(store, 'nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            this.mon(store, 'add', this.applyStartEndDatesFromStore, this);
        }
    },
    getTimeSpanDefiningStore: function() {
        throw "Abstract method called";
    },
    unbindAutoTimeSpanListeners: function(doRefresh) {
        this.waitingForAutoTimeSpan = false;
        var store = this.getTimeSpanDefiningStore();
        // allow panel refresh back
        //this.resumeViewsRefresh(doRefresh);
        this.resumeRefresh(doRefresh);
        // unbind listener
        store.un('load', this.applyStartEndDatesFromStore, this);
        if (store.isTreeStore) {
            store.un('rootchange', this.applyStartEndDatesFromStore, this);
            store.un('nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            store.un('add', this.applyStartEndDatesFromStore, this);
        }
    },
    applyStartEndDatesAfterTreeAppend: function() {
        var store = this.getTimeSpanDefiningStore();
        // Need to block the reading of the total store timespan until the store is done loading
        // With CRUD manager, we need the __loading flag since multiple append events are fired during load
        if (!store.isSettingRoot && !store.__loading) {
            this.applyStartEndDatesFromStore();
        }
    },
    applyStartEndDatesFromStore: function() {
        var store = this.getTimeSpanDefiningStore();
        var span = store.getTotalTimeSpan();
        // If event store contains events without duration, add a 1 mainUnit buffer to each side
        if (span.end && span.start && span.end - span.start === 0) {
            span.start = Sch.util.Date.add(span.start, this.timeAxis.mainUnit, -1);
            span.end = Sch.util.Date.add(span.end, this.timeAxis.mainUnit, 1);
        }
        this.setTimeSpan(span.start || new Date(), span.end);
    },
    onLockedGridItemDblClick: function(grid, record, el, rowIndex, event) {
        if (this.isVertical() && record) {
            this.fireEvent('timeheaderdblclick', this, record.get('start'), record.get('end'), rowIndex, event);
        }
    },
    onHeaderClick: function(event, t) {
        var columnEl = event.getTarget('.' + Ext.baseCSSPrefix + 'column-header');
        var index = [].indexOf.call(columnEl.parentElement.childNodes, columnEl);
        var column = this.normalGrid.getColumns()[index];
        if (Sch.column.Day && column instanceof Sch.column.Day) {
            var start = column.start;
            var end = column.end;
            this.fireEvent('timeheader' + event.type, this, start, end, event);
            if (event.type === 'dblclick' && this.switchToDayViewOnWeekDayHeaderDblClick) {
                this.setViewPreset('day', start);
            }
        }
    },
    /**
     * Returns the view which renders the schedule and time columns. This method should be used instead of the usual `getView`,
     * since `getView` will return an instance of a special "locking" grid view, which has no scheduler-specific features.
     *
     * @return {Sch.mixin.SchedulerView} view A view implementing the {@link Sch.mixin.SchedulerView} mixin
     */
    getSchedulingView: function() {
        return this.normalGrid && this.normalGrid.view;
    },
    getHorizontalTimeAxisColumn: function() {
        var view = this.getSchedulingView();
        return view && view.getHorizontalTimeAxisColumn();
    },
    configureColumns: function(columns) {
        var lockedColumns = [];
        var normalColumns = [];
        columns = columns || [];
        // The 'columns' config can also be a config object for Ext.grid.header.Container
        if (columns.items) {
            // If columns config not specified, this.columns will be taken from prototype and following code will change
            // it. Covered by 1114_memory and 1109_orientation
            this.columns = Ext.apply({}, this.columns);
            // Clone it to make sure we handle the case of a column array object put on the class prototype
            columns = this.columns.items = columns.items.slice();
        } else {
            // Clone it to make sure we handle the case of a column array object put on the class prototype
            columns = this.columns = columns.slice();
        }
        // Split locked and normal columns first
        Ext.Array.each(columns, function(column) {
            if (column.position === 'right' || column.locked === false) {
                if (!Ext.isNumber(column.width)) {
                    Ext.Error.raise('"Right" columns must have a fixed width');
                }
                column.locked = false;
                normalColumns.push(column);
            } else {
                column.locked = true;
                lockedColumns.push(column);
            }
            column.lockable = false;
        });
        // No splitter if there are no locked columns
        if (columns.length === 0) {
            this.split = false;
        }
        Ext.Array.erase(columns, 0, columns.length);
        Ext.Array.insert(columns, 0, lockedColumns.concat(Ext.apply({
            xtype: 'timeaxiscolumn',
            timeAxisViewModel: this.timeAxisViewModel,
            trackHeaderOver: this.trackHeaderOver,
            renderer: this.mainRenderer,
            variableRowHeight: this.variableRowHeight,
            scope: this
        }, this.horizontalTimeAxisColumnCfg || {})).concat(normalColumns));
        // Save reference to original set of columns
        this.horizontalColumns = columns.slice();
    },
    mainRenderer: function(val, meta, rowRecord, rowIndex, colIndex) {
        var renderers = this.renderers,
            resource = this.isVertical() ? this.getResourceStore().getAt(colIndex) : rowRecord,
            retVal = '&nbsp;';
        // To ensure cells always consume correct height
        // Ext doesn't clear the meta object between cells
        meta.rowHeight = null;
        for (var i = 0; i < renderers.length; i++) {
            retVal += renderers[i].fn.call(renderers[i].scope || this, val, meta, resource, rowIndex, colIndex) || '';
        }
        if (this.variableRowHeight) {
            // Set row height
            var view = this.getSchedulingView();
            var rowHeight = meta.rowHeight || this.getRowHeight();
            if (view.isHorizontal()) {
                // 1 px for row top border width
                rowHeight += view.cellTopBorderWidth + view.cellBottomBorderWidth - (view.allDay ? 0 : 1);
            } else {
                // subtract 1px for cell top border, defined in Sch/view/Vertical.scss
                // see Sch.column.timeaxis.Vertical
                rowHeight -= 1;
            }
            meta.style = 'height:' + rowHeight + 'px';
        }
        return retVal;
    },
    onNormalGridCollapse: function() {
        var me = this;
        // Hack for Gantt to prevent creating second expander when normal grid initially collapsed
        if (!me.normalGrid.reExpander) {
            me.normalGrid.reExpander = me.normalGrid.placeholder;
        }
        if (!me.lockedGrid.rendered) {
            me.lockedGrid.on('render', me.onNormalGridCollapse, me, {
                delay: 1
            });
        } else {
            me.lockedGrid.savedWidth = me.lockedGrid.getWidth();
            if (me.lockedGrid.collapsed) {
                me.lockedGrid.expand();
            }
            me.lockedGrid.setWidth(me.getWidth() - me.normalGrid.getPlaceholder().getWidth());
            // Show a vertical scrollbar in locked grid if normal grid is collapsed
            me.addCls('sch-normalgrid-collapsed');
        }
    },
    onNormalGridExpand: function() {
        this.removeCls('sch-normalgrid-collapsed');
    },
    onLockedGridCollapse: function() {
        var me = this;
        if (me.normalGrid.collapsed) {
            me.normalGrid.expand();
        }
    },
    onLockedGridExpand: function() {
        if (this.lockedGrid.savedWidth) {
            this.lockedGrid.setWidth(this.lockedGrid.savedWidth);
        }
    },
    beforeCrudOperationStart: function(manager, params, type) {
        if (this.rendered) {
            this.setLoading({
                msg: type === 'load' ? this.L('loadingText') : this.L('savingText')
            });
        } else {
            Ext.destroy(this.renderWaitListener);
            this.renderWaitListener = this.on('render', Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {
                delay: 1,
                destroyable: true
            });
        }
    },
    onCrudBeforeLoad: function() {
        //this.suspendViewsRefresh();
        this.suspendRefresh();
    },
    onCrudLoad: function() {
        //this.resumeViewsRefresh();
        this.resumeRefresh(true);
    },
    onCrudOperationComplete: function() {
        Ext.destroy(this.renderWaitListener);
        this.setLoading(false);
    },
    onSchedulePinchStart: function(view, e) {
        this.pinchStartDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchStartDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },
    onSchedulePinch: function(view, e) {
        this.pinchDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },
    onSchedulePinchEnd: function(view) {
        var xDistance = this.pinchDistanceX;
        var yDistance = this.pinchDistanceY;
        var isHorizontal = this.isHorizontal();
        if (Math.abs(xDistance - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
            var scaleX = Math.abs(xDistance / this.pinchStartDistanceX);
            if (isHorizontal) {
                scaleX > 1 ? this.zoomIn() : this.zoomOut();
            } else {
                this.timeAxisViewModel.setViewColumnWidth(scaleX * this.timeAxisViewModel.resourceColumnWidth);
            }
        }
        if (Math.abs(yDistance - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
            var scaleY = Math.abs(yDistance / this.pinchStartDistanceY);
            view.setRowHeight(view.getRowHeight() * scaleY);
        }
        this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null;
    },
    // Patches navigation model to skip undesired programmatic row focusing if timeline row is about to be focused.
    // This prevents timeline view scrolling to the top/left when clicking a non-focused timeline view row.
    // https://www.assembla.com/spaces/bryntum/tickets/1795
    // https://app.assembla.com/spaces/bryntum/tickets/5073
    // Test 'View should reset scroll when clicking empty area' in tests/view/2101_view.t.js
    patchNavigationModel: function(me) {
        me.getView().getNavigationModel().focusItem = function(item) {
            var scrollable = this.view.getScrollable();
            // See comment in Sch.patches.Scroller_7_3
            var scroller = scrollable.getLockingScroller && scrollable.getLockingScroller();
            if (scroller && scroller.isScrolling) {
                return null;
            } else {
                item.addCls(this.focusCls);
                if (((Ext.isIE || Ext.isEdge) && !item.hasCls('sch-timetd')) || (// For IE, avoid focus when clicking on any schedule cell
                !(Ext.isIE || Ext.isEdge) && me.isHorizontal())) // For non-IE: in vertical or weekview, skip scroll to top
                {
                    item.focus();
                }
            }
        };
        // https://www.sencha.com/forum/showthread.php?301110
        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();
        lockedView.on('rowclick', function(view, record, tr, rowIndex) {
            if (normalView.lastFocused) {
                normalView.lastFocused.rowIdx = rowIndex;
                normalView.lastFocused.record = record;
            } else if (Ext.isIE) {
                normalView.lastFocused = this.lastFocused;
            }
        });
        normalView.on('rowclick', function(view, record, tr, rowIndex) {
            if (lockedView.lastFocused) {
                lockedView.lastFocused.rowIdx = rowIndex;
                lockedView.lastFocused.record = record;
            } else if (Ext.isIE) {
                lockedView.lastFocused = this.lastFocused;
            }
        });
    },
    patchHeaderScrollSync: function(me) {
        function sync() {
            var targetGrid = (me.normalGrid || me),
                headerCt = targetGrid.getHeaderContainer();
            // Target grid may not have a header if 'hideHeaders' is true.
            // targetGrid.getHeaderContainer() always returns a container, no matter it's visible or not,
            // but in case 'hideHeaders' is true the height of this container is equal to 0 and 'scrollable' is null.
            if (me.rendered && headerCt && headerCt.getScrollable()) {
                headerCt.getScrollable().syncWithPartners();
            }
        }
        function patch() {
            me.patchHeaderScrollSyncDetacher && Ext.destroy(me.patchHeaderScrollSyncDetacher);
            me.patchHeaderScrollSyncDetacher = me.store && me.mon(me.store, {
                'nodeexpand': sync,
                'nodecollapse': sync,
                buffer: 1,
                destroyable: true
            });
        }
        patch();
        me.on('storechange', patch);
    },
    configureChildGrids: function() {
        var me = this;
        // Make local copies of these configs in case someone puts them on the prototype of a subclass.
        me.lockedGridConfig = Ext.apply({}, me.lockedGridConfig || {});
        me.normalGridConfig = Ext.apply({}, me.schedulerConfig || me.normalGridConfig || {});
        var lockedGrid = me.lockedGridConfig,
            normalGrid = me.normalGridConfig;
        if (me.lockedXType) {
            lockedGrid.xtype = me.lockedXType;
        }
        if (me.normalXType) {
            normalGrid.xtype = me.normalXType;
        }
        // Configure the child grids
        Ext.applyIf(lockedGrid, {
            useArrows: true,
            animCollapse: false,
            collapseDirection: 'left',
            trackMouseOver: false
        });
        Ext.applyIf(normalGrid, {
            viewType: me.viewType,
            enableColumnMove: false,
            enableColumnResize: false,
            enableColumnHide: false,
            trackMouseOver: false,
            collapseDirection: 'right',
            collapseMode: 'placeholder',
            animCollapse: false
        });
        if (me.isVertical()) {
            lockedGrid.store = normalGrid.store = me.timeAxis;
        }
        if (lockedGrid.width) {
            // User has specified a fixed width for the locked section, disable the syncLockedWidth method
            me.syncLockedWidth = Ext.emptyFn;
            // Enable scrollbars for locked section
            lockedGrid.scroll = Ext.supports.Touch ? 'both' : 'horizontal';
            lockedGrid.scrollerOwner = true;
        }
    },
    afterInitComponent: function() {
        var me = this;
        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();
        var isTree = me.store && me.store.isTreeStore;
        if (me.normalGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.normalGrid.collapsed = false;
            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            normalView.on('boxready', function() {
                me.normalGrid.collapse();
            }, me, {
                delay: 10
            });
        }
        if (me.lockedGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.lockedGrid.collapsed = false;
            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            lockedView.on('boxready', function() {
                me.lockedGrid.collapse();
            }, me, {
                delay: 10
            });
            if (lockedView.bufferedRenderer)  {
                lockedView.bufferedRenderer.disabled = true;
            }
            
        }
        if (isTree) {
            this.setupLockableFilterableTree();
        }
        var splitter = this.getSplitter();
        if (splitter) {
            splitter.addCls('sch-timelinepanel-splitter');
            splitter.setVisible(this.isHorizontal());
        }
        // In Ext JS 6.2.0+ we manually make sure a click in a time cell selects the containing row
        if (Ext.versions.extjs.isGreaterThan('6.2.0')) {
            this.normalGrid.on('cellclick', this.onNormalGridCellClick, this);
        }
        if (this.zoomOnTimeAxisDoubleClick) {
            this.on('timeheaderdblclick', function(me, tickStart, tickEnd) {
                if (this.isHorizontal()) {
                    this.zoomToSpan({
                        start: tickStart,
                        end: tickEnd
                    });
                }
            });
        }
    },
    // In Ext JS 6.2.0+ we manually make sure a click in a time cell selects the containing row
    onNormalGridCellClick: function(panel, td, cellIndex, record, tr, rowIndex, e) {
        if (td.className.match('sch-timetd')) {
            var selectionModel = this.getSelectionModel();
            var deselect = e.ctrlKey && selectionModel.isSelected(record);
            if (deselect) {
                selectionModel.deselect(record);
            } else {
                selectionModel.select(record, e.ctrlKey);
            }
        }
    },
    getSplitter: function() {
        return this.child('splitter');
    },
    setupLockableFilterableTree: function() {
        var me = this;
        var lockedView = me.lockedGrid.getView();
        // enable filtering support for trees
        var filterableProto = Sch.mixin.FilterableTreeView.prototype;
        lockedView.initTreeFiltering = filterableProto.initTreeFiltering;
        lockedView.onFilterChangeStart = filterableProto.onFilterChangeStart;
        lockedView.onFilterChangeEnd = filterableProto.onFilterChangeEnd;
        lockedView.onFilterCleared = filterableProto.onFilterCleared;
        lockedView.onFilterSet = filterableProto.onFilterSet;
        lockedView.initTreeFiltering();
    },
    showMenuBy: function(t, header) {
        var menu = this.getMenu(),
            unlockItem = menu.down('#unlockItem'),
            lockItem = menu.down('#lockItem'),
            sep = unlockItem.prev();
        sep.hide();
        unlockItem.hide();
        lockItem.hide();
    },
    /**
     * Changes the timeframe of the scheduling chart to fit all the events in it.
     * @param {Object} [options] Options object for the zooming operation.
     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date
     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date
     */
    zoomToFit: function(options) {
        options = Ext.apply({
            adjustStart: 1,
            adjustEnd: 1
        }, options);
        var eventStore = this.getEventStore();
        var span = this.getEventStore().getTotalTimeSpan();
        if (this.zoomToSpan(span, options) === null) {
            // if no zooming was performed - fit columns to view space
            this.getSchedulingView().fitColumns();
        }
    },
    refreshViews: function(keepScrollPosition) {
        if (!this.rendered)  {
            return;
        }
        
        var refreshed = false;
        var schedulingViewListener = function() {
                refreshed = true;
            };
        var schedulingView = this.normalGrid.getView();
        var lockedView = this.lockedGrid.getView(),
            scroll = {
                left: lockedView.getScrollX(),
                top: schedulingView.getVerticalScroll()
            };
        schedulingView.on('refresh', schedulingViewListener);
        lockedView.refreshView();
        // this could trigger a normal view refresh, out of our control
        schedulingView.un('refresh', schedulingViewListener);
        if (keepScrollPosition !== false) {
            !refreshed && this.getSchedulingView().refreshKeepingScroll();
            lockedView.setScrollX(scroll.left);
            lockedView.setScrollY(scroll.top);
        } else if (!refreshed) {
            this.getSchedulingView().refreshView();
        }
    },
    getCalendar: function() {
        return this.calendar;
    },
    /**
     * Toggles the weekend highlighting on or off
     * @param {Boolean} disabled
     */
    disableWeekendHighlighting: function(disabled) {
        this.workingTimePlugin.setDisabled(disabled);
        if (disabled) {
            this.removeCls('sch-timelinepanel-highlightweekends');
        } else {
            this.addCls('sch-timelinepanel-highlightweekends');
        }
    },
    preventRefresh: function() {
        return false;
    },
    /**
     * Prevents the underlying view from being refreshed, until resumeRefresh() is called.
     * Multiple calls of suspendRefresh() requires the same amount of calls of resumeRefresh().
     */
    suspendRefresh: function() {
        var me = this;
        if (me.refreshSuspensionCount++ === 0) {
            // prevent refresh calls
            me.getView().on('beforerefresh', me.preventRefresh, me);
            // prevent low level refreshView calls (e.g. from refreshKeepingScroll)
            me.normalGrid.view.blockRefresh = true;
            me.lockedGrid.view.blockRefresh = true;
        }
    },
    /**
     * Allows the underlying view the be refreshed again, after being suspended with suspendRefresh().
     * @param triggerRefresh true to also call view.refresh()
     */
    resumeRefresh: function(triggerRefresh) {
        var me = this;
        if (me.refreshSuspensionCount && !--me.refreshSuspensionCount) {
            me.getView().un('beforerefresh', me.preventRefresh, me);
            me.normalGrid.view.blockRefresh = false;
            me.lockedGrid.view.blockRefresh = false;
            if (triggerRefresh)  {
                me.refreshViews();
            }
            
        }
    }
}, function() {
    var MIN_EXT_VERSION = '6.0.0';
    Ext.apply(Sch, {
        VERSION: '6.1.17'
    });
    // DELETE THIS CHECK IF YOU WANT TO RUN AGAINST AN OLDER UNSUPPORTED EXT JS VERSION
    if (Ext.versions.extjs.isLessThan(MIN_EXT_VERSION)) {
        var c = console;
        c && c.log('The Ext JS version you are using needs to be updated to at least ' + MIN_EXT_VERSION);
    }
    // In 6.0.2 there's additional check which is failing in gantt due to our refresh blockers. We simply ignore that
    // error for panels with Sch.mixin.TimelinePanel mixed in.
    // covered by 062_reload_store in gantt
    if (Ext.getVersion().isGreaterThan('6.0.2')) {
        Ext.define(null, {
            override: 'Ext.grid.plugin.BufferedRenderer',
            doRefreshView: function() {
                if (this.view.ownerGrid.is('timelinegrid,timelinetree')) {
                    var oldIgnore = Ext.Error.ignore;
                    Ext.Error.ignore = true;
                    this.callParent(arguments);
                    Ext.Error.ignore = oldIgnore;
                } else {
                    this.callParent(arguments);
                }
            }
        });
    }
});

/**

@class Sch.panel.TimelineGridPanel
@extends Ext.grid.Panel
@mixins Sch.mixin.TimelinePanel

Internal class.

*/
Ext.define("Sch.panel.TimelineGridPanel", {
    extend: "Ext.grid.Panel",
    mixins: [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],
    alias: [
        'widget.timelinegrid'
    ],
    subGridXType: 'gridpanel',
    isTimelineGridPanel: true,
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});

// @tag dependencies
/**
 * @class Sch.template.DependencyInfo
 * @protected
 *
 * Template showing details of a link between two tasks.
 * This template is given `dependency`, `fromTask` and `toTask` properties that is used for the display of task texts.
 * If `dependency` is undefined, that is potential dependency info used during dependency creation.
 */
Ext.define('Sch.template.DependencyInfo', {
    extend: 'Ext.XTemplate',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    text: '<dl class="sch-dep-tip">' + '<tpl if="!values.dependency">' + '<div class="' + Ext.baseCSSPrefix + 'fa {[values.valid ? \'fa-check-circle sch-dep-tip-valid\' : \'fa-times-circle sch-dep-tip-invalid\']}"></div>' + '</tpl>' + '<dt class="sch-dep-tip-from-title">__FROM__:</dt>' + '<dd class="sch-dep-tip-from-value">{[Ext.htmlEncode(values.fromTask.getName()) || "&nbsp;"]}</dd>' + '<dt class="sch-dep-tip-to-title">__TO__:</dt>' + '<dd class="sch-dep-tip-to-value">{[values.toTask && Ext.htmlEncode(values.toTask.getName()) || "&nbsp;"]}</dd>' + '</dl>',
    constructor: function() {
        var me = this;
        me.text = me.text.replace(/__FROM__/, me.L('fromText')).replace(/__TO__/, me.L('toText'));
        me.callParent([
            me.text
        ]);
    }
});

/**
 * A tooltip for displaying info about a dependency
 * @private
 */
Ext.define('Sch.view.dependency.Tooltip', {
    extend: 'Ext.tip.ToolTip',
    requires: [
        'Sch.template.DependencyInfo'
    ],
    cls: 'sch-dependency-tip',
    delegate: '.sch-dependency',
    showDelay: 0,
    anchor: 'bottom',
    mouseOffset: [
        15,
        5
    ],
    trackMouse: true,
    dependencyView: null,
    tpl: null,
    initComponent: function() {
        this.target = this.dependencyView.getPrimaryView().getEl();
        this.tpl = this.tpl || new Sch.template.DependencyInfo();
        this.callParent(arguments);
    },
    show: function() {
        this.callParent(arguments);
        var depRecord = this.dependencyView.getDependencyForElement(this.triggerElement);
        this.setData({
            dependency: depRecord,
            fromTask: depRecord.getSourceEvent(),
            toTask: depRecord.getTargetEvent()
        });
    }
});

// @tag dependencies
/**
 * Drag drop functionality between two terminals
 * @private
 */
Ext.define('Sch.view.dependency.DropZone', {
    extend: 'Ext.dd.DropZone',
    mixins: {
        observable: 'Ext.util.Observable'
    },
    terminalSelector: null,
    dependencyStore: null,
    toText: null,
    startText: null,
    endText: null,
    view: null,
    tipTpl: null,
    // the tooltip instance shown when hovering over a target terminal
    tip: null,
    constructor: function(el, config) {
        this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    getTargetFromEvent: function(e) {
        return e.getTarget(this.terminalSelector);
    },
    // On entry into a target node, highlight that node.
    onNodeEnter: function(target, dd, e, data) {
        var me = this,
            targetRecord = me.view.resolveEventRecord(target),
            toSide = target.className.match(/sch-terminal-(\w+)/)[1],
            targetId = targetRecord.getId() || targetRecord.internalId,
            tplData = Ext.apply({
                toTask: targetRecord,
                toSide: toSide
            }, data.tplData);
        if (!me.tip) {
            me.tip = me.createTooltip();
        }
        data.valid = tplData.valid = me.isValidLink(data.fromId, targetId, dd.dragData.fromSide, toSide);
        me.tip.setData(tplData);
        me.tip.showBy(target);
        Ext.fly(target).addCls('sch-terminal-' + (data.valid ? 'valid' : 'invalid') + '-drop');
    },
    createTooltip: function() {
        var me = this;
        return new Ext.tip.ToolTip({
            tpl: me.tipTpl,
            view: me.view,
            cls: 'sch-dependency-tip sch-create-dependency-tip',
            constrain: true,
            anchor: 't',
            trackMouse: false,
            hideDelay: 0,
            dismissDelay: 0,
            delegate: me.terminalSelector,
            target: me.view.getEl(),
            constraintInsets: '7 -7 -7 7'
        });
    },
    // On exit from a target node, unhighlight that node.
    onNodeOut: function(target, dd, e, data) {
        data.valid = false;
        Ext.fly(target).removeCls([
            'sch-terminal-valid-drop',
            'sch-terminal-invalid-drop'
        ]);
    },
    onNodeOver: function(target, dd, e, data) {
        return data.valid ? this.dropAllowed : this.dropNotAllowed;
    },
    onNodeDrop: function(target, dz, e, data) {
        var me = this,
            targetRec = me.view.resolveEventRecord(target),
            toSide = target.className.match(/sch-terminal-(\w+)/)[1],
            targetId = targetRec.getId() || targetRec.internalId,
            valid = data.valid,
            newDependency = me.createDependencyModel(dz.dragData.fromId, targetId, data.fromSide, toSide);
        me.fireEvent('drop', me, newDependency, valid);
        me.fireEvent('afterdrop', me);
        return valid;
    },
    createDependencyModel: function(fromId, toId, fromSide, toSide) {
        var dependencyStore = this.dependencyStore,
            newDependency = new (dependencyStore.getModel())();
        newDependency.setSourceId(fromId);
        newDependency.setTargetId(toId);
        // Gantt uses different model, where sides doesn't need to be stored
        // Would be nicer to make subclasses for scheduler and gantt but too much work at the moment
        newDependency instanceof Sch.model.Dependency && newDependency.setFromSide(fromSide);
        newDependency instanceof Sch.model.Dependency && newDependency.setToSide(toSide);
        newDependency.setType(newDependency.getTypeFromSides(fromSide, toSide, this.view.rtl));
        return newDependency;
    },
    isValidLink: function(fromId, toId, fromSide, toSide) {
        var newDependency = this.createDependencyModel(fromId, toId, fromSide, toSide);
        return this.dependencyStore.isValidDependency(newDependency);
    },
    destroyTip: function() {
        var me = this;
        me.tip && me.tip.destroy();
        me.tip = null;
    },
    destroy: function() {
        var me = this;
        me.destroyTip();
        me.callParent(arguments);
    }
});

// @tag dependencies
/**
 * Drag drop functionality between two terminals
 * @private
 */
Ext.define('Sch.view.dependency.DragZone', {
    extend: 'Ext.dd.DragZone',
    alias: 'schdependencydragzone.default',
    requires: [
        'Sch.template.DependencyInfo',
        'Sch.view.dependency.DropZone',
        'Sch.util.ScrollManager'
    ],
    mixins: {
        factoryable: 'Ext.mixin.Factoryable',
        observable: 'Ext.util.Observable'
    },
    terminalSelector: null,
    view: null,
    fromText: null,
    toText: null,
    startText: null,
    endText: null,
    rtl: false,
    useLineProxy: true,
    dependencyStore: null,
    tipTpl: null,
    animationDuration: 400,
    checkDraggingFlag: true,
    constructor: function(config) {
        var me = this;
        me.mixins.observable.constructor.call(this, config);
        me.callParent([
            config.view.getEl(),
            config
        ]);
        me.tipTpl = me.tipTpl || new Sch.template.DependencyInfo();
        if (!(me.tipTpl instanceof Ext.Template)) {
            me.tipTpl = new Ext.XTemplate(me.tipTpl);
        }
        me.dropZone = me.createDropZone();
        me.relayEvents(me.dropZone, [
            'drop',
            'afterdrop'
        ]);
        // #3434 - ScrollManager is active in IE which result in scrolling bug in rtl example
        me.on({
            dragstart: me.onDependencyDragStart,
            afterdrop: me.onDependencyAfterDrop,
            scope: me
        });
    },
    onDependencyDragStart: function() {
        Sch.util.ScrollManager.activate(this.view);
    },
    onDependencyAfterDrop: function() {
        Sch.util.ScrollManager.deactivate();
        this.dropZone.destroyTip();
    },
    createDropZone: function() {
        return new Sch.view.dependency.DropZone(this.el, this.getDropZoneConfig());
    },
    getDropZoneConfig: function() {
        return {
            rtl: this.rtl,
            terminalSelector: this.terminalSelector,
            ddGroup: this.ddGroup,
            view: this.view,
            dependencyStore: this.dependencyStore,
            tipTpl: this.tipTpl
        };
    },
    initLineProxy: function(sourceNode) {
        var me = this,
            scroll = me.view.getScroll(),
            offsets = Ext.fly(sourceNode).getOffsetsTo(me.view.el),
            halfTerminalSize = Ext.fly(sourceNode).getWidth() / 2,
            posX = offsets[0] + halfTerminalSize,
            posY = offsets[1] + halfTerminalSize,
            side = me.rtl ? 'right' : 'left';
        posX = posX + scroll.left;
        posY = posY;
        me.lineProxyEl = me.el.createChild({
            cls: 'sch-dependency-connector-proxy',
            style: 'top:' + posY + 'px;' + side + ':' + posX + 'px'
        });
        Ext.apply(me, {
            startXY: [
                posX,
                posY
            ],
            startScrollLeft: scroll.left,
            startScrollTop: scroll.top
        });
    },
    updateLineProxy: function(pageXY) {
        var me = this,
            scrollingPageEl = (document.scrollingElement || document.documentElement || document.body),
            scroll = me.view.getScroll(),
            viewElRect = me.view.el.dom.getBoundingClientRect(),
            newLocalX = pageXY[0] - me.view.getX(),
            diffX = (me.rtl ? me.startXY[0] - newLocalX - scroll.left : newLocalX - me.startXY[0] + scroll.left) - scrollingPageEl.scrollLeft,
            diffY = pageXY[1] - viewElRect.top - me.startXY[1] - scrollingPageEl.scrollTop,
            newHeight = Math.max(1, Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) - 2),
            // Calculate new angle relative to start XY
            rad = Math.atan2(diffY, diffX) - (Math.PI / 2);
        me.lineProxyEl.setStyle({
            "height": newHeight + 'px',
            "transform": 'rotate(' + rad + 'rad)'
        });
    },
    // On receipt of a mousedown event, see if it is within a draggable element.
    // Return a drag data object if so. The data object can contain arbitrary application
    // data, but it should also contain a DOM element in the ddel property to provide
    // a proxy to drag.
    getDragData: function(e) {
        var me = this,
            sourceNode = e.getTarget(me.terminalSelector);
        if (e.button === 0 && sourceNode) {
            var sourceTaskRecord = me.view.resolveEventRecord(sourceNode);
            if (me.fireEvent('beforedrag', me, sourceTaskRecord) === false) {
                return null;
            }
            var side = sourceNode.className.match(/sch-terminal-(\w+)/)[1],
                tplData = {
                    fromTask: sourceTaskRecord,
                    fromSide: side
                },
                ddel = document.createElement('div');
            // Force the source terminal to stay visible
            sourceNode.style.display = 'block';
            return {
                fromId: sourceTaskRecord.getId() || sourceTaskRecord.internalId,
                fromSide: side,
                tplData: tplData,
                repairXY: Ext.fly(sourceNode).getXY(),
                ddel: ddel,
                valid: false,
                sourceTerminal: sourceNode
            };
        }
        return false;
    },
    onStartDrag: function(x, y) {
        var me = this,
            dd = me.dragData,
            sourceNode = dd.sourceTerminal,
            sideCls = sourceNode.className.match(/sch-terminal-(\w+)/)[0];
        me.fireEvent('dragstart', me);
        if (me.useLineProxy) {
            me.initLineProxy(sourceNode, dd.isStart);
            me.lineProxyEl.show();
        }
        // Not interested in any Ext drag proxy being visible
        me.proxy.setStyle('display', 'none');
        // Hide other terminals inside the event node
        Ext.fly(dd.sourceTerminal.parentNode).select('.sch-terminal:not(.' + sideCls + ')').addCls('sch-terminal-hidden');
    },
    onDrag: function(e, t) {
        this.useLineProxy && this.updateLineProxy(e.getXY());
    },
    // Override, get rid of weird highlight fx in default implementation
    afterRepair: function() {
        var me = this;
        me.dragging = false;
        if (!me.destroyed) {
            me.fireEvent('afterdrop', me.dropZone);
        }
    },
    onMouseUp: function() {
        var me = this;
        me.el.removeCls('sch-terminals-visible');
        me.dragData.sourceTerminal.style.display = '';
        if (me.lineProxyEl) {
            var el = me.lineProxyEl;
            el.animate({
                to: {
                    height: 0
                },
                duration: me.animationDuration,
                callback: function() {
                    Ext.destroy(el);
                }
            });
            me.lineProxyEl = null;
        }
    },
    // Provide coordinates for the proxy to slide back to on failed drag.
    // This is the original XY coordinates of the draggable element.
    getRepairXY: function() {
        return this.dragData.repairXY;
    },
    destroy: function() {
        var me = this;
        Ext.destroy([
            me.lineProxyEl,
            me.dropZone
        ]);
        me.callParent(arguments);
    }
});

/**
 * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.
 */
Ext.define("Sch.util.RectangularPathFinder", {
    alias: 'schpathfinder.rectangular',
    mixins: [
        'Ext.mixin.Factoryable'
    ],
    uses: [
        'Ext.Array'
    ],
    config: {
        /**
         * @cfg {String|Boolean} startSide
         *
         * Default start connection side: 'left', 'right', 'top', 'bottom'
         */
        startSide: 'right',
        /**
         * @cfg {Number} startArrowSize
         *
         * Default start arrow size in pixels
         */
        startArrowSize: 8,
        /**
         * @cfg {Number} startArrowMargin
         *
         * Default start arrow staff size in pixels
         */
        startArrowMargin: 6,
        /**
         * @cfg {Number} startShift
         *
         * Default starting connection point shift from box's arrow pointing side middle point
         */
        startShift: 0,
        /**
         * @cfg {String|Boolean} endSide
         *
         * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'
         */
        endSide: 'left',
        /**
         * @cfg {Number} endArrowSize
         *
         * Default end arrow size in pixels
         */
        endArrowSize: 8,
        /**
         * @cfg {Number} endArrowMargin
         *
         * Default end arrow staff size in pixels
         */
        endArrowMargin: 6,
        /**
         * @cfg {Number} endShift
         *
         * Default ending connection point shift from box's arrow pointing side middle point
         */
        endShift: 0,
        /**
         * @cfg {Number} verticalMargin
         *
         * Start / End box vertical marging, the amount of pixels from top and bottom line of a box where drawing
         * is prohibited
         */
        verticalMargin: 2,
        /**
         * @cfg {Number} horizontalMargin
         *
         * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing
         * is prohibited
         */
        horizontalMargin: 5,
        /**
         * @cfg {Object[]} otherBoxes
         *
         * Other rectangular areas (obstacles) to search path through
         */
        otherBoxes: null
    },
    constructor: function(config) {
        var me = this;
        me.callParent([
            config
        ]);
        me.initConfig(config);
    },
    /**
     * @method findPath
     * Returns list of horizontal and vertical segments connecting two boxes
     *
     *    |    | |  |    |       |
     *  --+----+----+----*-------*---
     *  --+=>Start  +----*-------*--
     *  --+----+----+----*-------*--
     *    |    | |  |    |       |
     *    |    | |  |    |       |
     *  --*----*-+-------+-------+--
     *  --*----*-+         End <=+--
     *  --*----*-+-------+-------+--
     *    |    | |  |    |       |
     *
     *  Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical
     *  margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds
     *  the shortest path with minimum amount of turns. In short it's mix of "Lee" and "Dijkstra pathfinding"
     *  with turns amount taken into account for distance calculation.
     *
     *  The algorithm is not very performant though, it's O(N^2), where N is amount of
     *  points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since
     *  two box middle points are not permitted) that might be ok for now.
     *
     * @param {Object} lineDef An object containing any of the class configuration option overrides as well
     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,
     *                         `endHorizontalMargin`, `endVerticalMargin` properties
     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties
     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties
     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box
     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box
     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box
     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box
     *
     *
     * @return {Object[]/Boolean} Array of line segments or false if path cannot be found
     * @return {Number} return.x1
     * @return {Number} return.y1
     * @return {Number} return.x2
     * @return {Number} return.y2
     */
    /**
     * @ignore
     * @privateparam {Function[]|Function} noPathFallbackFn
     *      A function or array of functions which will be tried in case a path can't be found
     *      Each function will be given a line definition it might try to adjust somehow and return.
     *      The new line definition returned will be tried to find a path.
     *      If a function returns false, then next function will be called if any.
     */
    findPath: function(lineDef, noPathFallbackFn) {
        var me = this,
            lineDefFull, startBox, endBox, startShift, endShift, startSide, endSide, startArrowSize, endArrowSize, startArrowMargin, endArrowMargin, horizontalMargin, verticalMargin, startHorizontalMargin, startVerticalMargin, endHorizontalMargin, endVerticalMargin, otherBoxes, connStartPoint, connEndPoint, pathStartPoint, pathEndPoint, gridStartPoint, gridEndPoint, startGridBox, endGridBox, grid, path, tryNum;
        if (noPathFallbackFn && !Ext.isArray(noPathFallbackFn)) {
            noPathFallbackFn = [
                noPathFallbackFn
            ];
        }
        for (tryNum = 0; lineDef && !path; ) {
            lineDefFull = Ext.applyIf(lineDef, me.getConfig());
            startBox = lineDefFull.startBox , endBox = lineDefFull.endBox , startShift = lineDefFull.startShift , endShift = lineDefFull.endShift , startSide = lineDefFull.startSide , endSide = lineDefFull.endSide , startArrowSize = lineDefFull.startArrowSize , endArrowSize = lineDefFull.endArrowSize , startArrowMargin = lineDefFull.startArrowMargin , endArrowMargin = lineDefFull.endArrowMargin , horizontalMargin = lineDefFull.horizontalMargin , verticalMargin = lineDefFull.verticalMargin , startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin , startVerticalMargin = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin , endHorizontalMargin = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin , endVerticalMargin = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin , otherBoxes = lineDefFull.otherBoxes;
            startSide = me.normalizeSide(startSide);
            endSide = me.normalizeSide(endSide);
            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);
            connEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);
            startGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide, startArrowSize, startArrowMargin, startHorizontalMargin, startVerticalMargin);
            endGridBox = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide, endArrowSize, endArrowMargin, endHorizontalMargin, endVerticalMargin);
            otherBoxes = otherBoxes && Ext.Array.map(otherBoxes, function(box) {
                return me.calcGridBaseBoxFromBoxAndDrawParams(box, false, 0, 0, horizontalMargin, verticalMargin);
            });
            pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);
            pathEndPoint = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);
            grid = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);
            gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);
            gridEndPoint = me.convertDecartPointToGridPoint(grid, pathEndPoint);
            path = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);
            // Loop if
            // - path is still not found
            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array
            // - have noPathFallBackFn array
            // - current try number is less then noPathFallBackFn array length
            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {
                lineDef = (noPathFallbackFn[tryNum])(lineDefFull);
            }
        }
        if (path) {
            path = me.prependPathWithArrowStaffSegment(path, connStartPoint, startArrowSize, startSide);
            path = me.appendPathWithArrowStaffSegment(path, connEndPoint, endArrowSize, endSide);
            path = me.optimizePath(path);
        }
        return path;
    },
    getConnectionCoordinatesFromBoxSideShift: function(box, side, shift) {
        var coords;
        switch (side) {
            case 'left':
                coords = {
                    x: box.start,
                    y: (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'right':
                coords = {
                    x: box.end,
                    y: (box.top + box.bottom) / 2 + shift
                };
                break;
            case 'top':
                coords = {
                    x: (box.start + box.end) / 2 + shift,
                    y: box.top
                };
                break;
            case 'bottom':
                coords = {
                    x: (box.start + box.end) / 2 + shift,
                    y: box.bottom
                };
                break;
        }
        return coords;
    },
    calcGridBaseBoxFromBoxAndDrawParams: function(box, side, arrowSize, arrowMargin, horizontalMargin, verticalMargin) {
        var gridBox;
        switch (side) {
            case 'left':
                gridBox = {
                    start: box.start - Math.max(arrowSize + arrowMargin, horizontalMargin),
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'right':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + Math.max(arrowSize + arrowMargin, horizontalMargin),
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'top':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - Math.max(arrowSize + arrowMargin, verticalMargin),
                    bottom: box.bottom + verticalMargin
                };
                break;
            case 'bottom':
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + Math.max(arrowSize + arrowMargin, verticalMargin)
                };
                break;
            default:
                gridBox = {
                    start: box.start - horizontalMargin,
                    end: box.end + horizontalMargin,
                    top: box.top - verticalMargin,
                    bottom: box.bottom + verticalMargin
                };
        }
        return gridBox;
    },
    buildPathGrid: function(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {
        var xs, ys, y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point,
            points = {},
            linearPoints = [];
        xs = [
            startGridBox.start,
            (startSide == 'left' || startSide == 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,
            startGridBox.end,
            endGridBox.start,
            (endSide == 'left' || endSide == 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,
            endGridBox.end
        ];
        ys = [
            startGridBox.top,
            (startSide == 'top' || startSide == 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,
            startGridBox.bottom,
            endGridBox.top,
            (endSide == 'top' || endSide == 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,
            endGridBox.bottom
        ];
        if (otherGridBoxes) {
            Ext.Array.forEach(otherGridBoxes, function(box) {
                xs.push(box.start, (box.start + box.end) / 2, box.end);
                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);
            });
        }
        xs = Ext.Array.unique(Ext.Array.sort(xs, Ext.Array.numericSortFn));
        ys = Ext.Array.unique(Ext.Array.sort(ys, Ext.Array.numericSortFn));
        for (iy = 0 , yslen = ys.length; iy < yslen; ++iy) {
            points[iy] = points[iy] || {};
            y = ys[iy];
            for (ix = 0 , xslen = xs.length; ix < xslen; ++ix) {
                x = xs[ix];
                permitted = ((x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) && (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom));
                if (otherGridBoxes) {
                    for (ib = 0 , blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {
                        box = otherGridBoxes[ib];
                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom);
                    }
                }
                point = {
                    distance: Math.pow(2, 53) - 1,
                    // Number.MAX_SAFE_INTEGER (not supported in Opera/IE)
                    permitted: permitted,
                    x: x,
                    y: y,
                    ix: ix,
                    iy: iy
                };
                points[iy][ix] = point;
                linearPoints.push(point);
            }
        }
        return {
            width: xs.length,
            height: ys.length,
            xs: xs,
            ys: ys,
            points: points,
            linearPoints: linearPoints
        };
    },
    convertDecartPointToGridPoint: function(grid, point) {
        var x = Ext.Array.indexOf(grid.xs, point.x),
            y = Ext.Array.indexOf(grid.ys, point.y);
        return grid.points[y][x];
    },
    findPathOnGrid: function(grid, gridStartPoint, gridEndPoint, startSide, endSide) {
        var me = this,
            path = false;
        if (gridStartPoint.permitted && gridEndPoint.permitted) {
            grid = me.waveForward(grid, gridStartPoint, 0);
            path = me.collectPath(grid, gridEndPoint, endSide);
        }
        return path;
    },
    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)
    getGridPointNeighbors: function(grid, gridPoint, predicateFn) {
        var ix = gridPoint.ix,
            iy = gridPoint.iy,
            result = [],
            neighbor;
        // NOTE:
        // It's important to push bottom neighbors first since this method is used
        // in collectPath(), which reversively collects path from end to start node
        // and if bottom neighbors are pushed first in result array then collectPath()
        // will produce a line which is more suitable (pleasant looking) for our purposes.
        if (iy < grid.height - 1) {
            neighbor = grid.points[iy + 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (iy > 0) {
            neighbor = grid.points[iy - 1][ix];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix < grid.width - 1) {
            neighbor = grid.points[iy][ix + 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        if (ix > 0) {
            neighbor = grid.points[iy][ix - 1];
            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);
        }
        return result;
    },
    // This method might lead to stack overflow if there're a lot of other boxes defined for the grid,
    // a lot here means hundreds
    // TODO: refactor the method such it won't use recursion
    waveForward: function(grid, gridStartPoint, distance) {
        var me = this,
            neighbors, i, len, neighbor, neighborDistance, neighborDir, xDiff, yDiff;
        gridStartPoint.distance = distance;
        // Taking all point neigbors which are permitted for path and which distance is higher then
        // it might be if we move through this point. Initially each point has Number.MAX_SAFE_INTEGER (2^53-1) distance.
        neighbors = me.getGridPointNeighbors(grid, gridStartPoint, function(point) {
            return point.permitted && (point.distance > distance + 1);
        });
        // It's important to set neighbor distance first, before waving to a neighbor, otherwise waving might
        // get through a neighbor point setting it's distance to a value more then (distance + 1) whereas we,
        // at this point, already know that it's possibly optimal distance is (distance + 1)
        for (i = 0 , len = neighbors.length; i < len; ++i) {
            neighbor = neighbors[i];
            neighbor.distance = distance + 1;
        }
        for (i = 0 , len = neighbors.length; i < len; ++i) {
            neighbor = neighbors[i];
            me.waveForward(grid, neighbor, distance + 1);
        }
        return grid;
    },
    collectPath: function(grid, gridEndPoint, endSide) {
        var me = this,
            pathFound = true,
            neighbors, lowestDistanceNeighbor, xDiff, yDiff,
            path = [];
        while (pathFound && gridEndPoint.distance) {
            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, function(point) {
                return point.permitted && (point.distance == gridEndPoint.distance - 1);
            });
            pathFound = neighbors.length > 0;
            if (pathFound) {
                // Prefer turnless neighbors first
                neighbors = Ext.Array.sort(neighbors, function(a, b) {
                    var xDiff, yDiff;
                    xDiff = a.ix - gridEndPoint.ix;
                    yDiff = a.iy - gridEndPoint.iy;
                    var result_a = (((endSide == 'left' || endSide == 'right') && yDiff === 0) || ((endSide == 'top' || endSide == 'bottom') && xDiff === 0)) ? -1 : 1;
                    xDiff = b.ix - gridEndPoint.ix;
                    yDiff = b.iy - gridEndPoint.iy;
                    var result_b = (((endSide == 'left' || endSide == 'right') && yDiff === 0) || ((endSide == 'top' || endSide == 'bottom') && xDiff === 0)) ? -1 : 1;
                    if (result_a > result_b) {
                        return 1;
                    } else if (result_a < result_b) {
                        return -1;
                    } else if (result_a == result_b) {
                        // apply additional sorting to be sure to pick bottom path in IE
                        return a.y > b.y ? -1 : 1;
                    }
                });
                lowestDistanceNeighbor = neighbors[0];
                path.push({
                    x1: lowestDistanceNeighbor.x,
                    y1: lowestDistanceNeighbor.y,
                    x2: gridEndPoint.x,
                    y2: gridEndPoint.y
                });
                // Detecting new side, either xDiff or yDiff must be 0 (but not both)
                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;
                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;
                switch (true) {
                    case !yDiff && xDiff > 0:
                        endSide = 'left';
                        break;
                    case !yDiff && xDiff < 0:
                        endSide = 'right';
                        break;
                    case !xDiff && yDiff > 0:
                        endSide = 'top';
                        break;
                    case !xDiff && yDiff < 0:
                        endSide = 'bottom';
                        break;
                }
                gridEndPoint = lowestDistanceNeighbor;
            }
        }
        return pathFound && path.reverse() || false;
    },
    prependPathWithArrowStaffSegment: function(path, connStartPoint, startArrowSize, startSide) {
        var prependSegment, firstSegment;
        if (path.length > 0) {
            firstSegment = path[0];
            prependSegment = {
                x2: firstSegment.x1,
                y2: firstSegment.y1
            };
            switch (startSide) {
                case 'left':
                    prependSegment.x1 = connStartPoint.x - startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'right':
                    prependSegment.x1 = connStartPoint.x + startArrowSize;
                    prependSegment.y1 = firstSegment.y1;
                    break;
                case 'top':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y - startArrowSize;
                    break;
                case 'bottom':
                    prependSegment.x1 = firstSegment.x1;
                    prependSegment.y1 = connStartPoint.y + startArrowSize;
                    break;
            }
            path.unshift(prependSegment);
        }
        return path;
    },
    appendPathWithArrowStaffSegment: function(path, connEndPoint, endArrowSize, endSide) {
        var appendSegment, lastSegment;
        if (path.length > 0) {
            lastSegment = path[path.length - 1];
            appendSegment = {
                x1: lastSegment.x2,
                y1: lastSegment.y2
            };
            switch (endSide) {
                case 'left':
                    appendSegment.x2 = connEndPoint.x - endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'right':
                    appendSegment.x2 = connEndPoint.x + endArrowSize;
                    appendSegment.y2 = lastSegment.y2;
                    break;
                case 'top':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y - endArrowSize;
                    break;
                case 'bottom':
                    appendSegment.x2 = lastSegment.x2;
                    appendSegment.y2 = connEndPoint.y + endArrowSize;
                    break;
            }
            path.push(appendSegment);
        }
        return path;
    },
    optimizePath: function(path) {
        var optPath = [],
            prevSegment, curSegment;
        if (path.length > 0) {
            prevSegment = path.shift();
            optPath.push(prevSegment);
            while (path.length > 0) {
                curSegment = path.shift();
                // both segments are equal
                if (prevSegment.x1 == curSegment.x1 && prevSegment.y1 == curSegment.y1 && prevSegment.x2 == curSegment.x2 && prevSegment.y2 == curSegment.y2) {
                    prevSegment = curSegment;
                }
                // both segments are horizontal
                else if ((prevSegment.y1 - prevSegment.y2 === 0) && (curSegment.y1 - curSegment.y2 === 0)) {
                    prevSegment.x2 = curSegment.x2;
                }
                // both segments are vertical
                else if ((prevSegment.x1 - prevSegment.x2 === 0) && (curSegment.x1 - curSegment.x2 === 0)) {
                    prevSegment.y2 = curSegment.y2;
                } else // segments has different orientation (path turn)
                {
                    optPath.push(curSegment);
                    prevSegment = curSegment;
                }
            }
        }
        return optPath;
    },
    normalizeSide: function(side) {
        return this.self.sideToSide[side] || side;
    },
    statics: {
        sideToSide: {
            'l': 'left',
            'r': 'right',
            't': 'top',
            'b': 'bottom'
        }
    }
});
/*
window.visualizeGrid = function() {
    var grid = window.grid,
        body = Ext.getBody(),
        vpWidth = Ext.dom.Element.getViewportWidth(),
        vpHeight = Ext.dom.Element.getViewportHeight();

    Ext.destroy(window.visGridEls);

    window.visGridEls = [];

    Ext.Array.forEach(grid.ys, function(y) {
        var el = body.appendChild({
            tag : 'div',
            style : {
                position: 'absolute',
                top : y + 'px',
                left : '0px',
                width : vpWidth + 'px',
                height : '1px',
                background : 'green',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });

    Ext.Array.forEach(grid.xs, function(x) {
        var el = body.appendChild({
            tag : 'div',
            style : {
                position: 'absolute',
                top : '0px',
                left : x + 'px',
                width : '1px',
                height : vpHeight + 'px',
                background : 'green',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });

    Ext.Array.forEach(grid.linearPoints, function(point) {
        var el = body.appendChild({
            tag : 'div',
            html : point.permitted && String(point.distance) || '!',
            style : {
                position: 'absolute',
                top : point.y - 15 + 'px',
                left : point.x - 15 + 'px',
                width : '15px',
                height : '15px',
                color: 'red',
                zIndex : 5
            }
        });
        window.visGridEls.push(el);
    });
};
*/

// @tag dependencies
/**
 @class Sch.template.Dependency

 The HTML template used to visualise a line between two tasks.
 */
Ext.define('Sch.template.Dependency', {
    extend: 'Ext.XTemplate',
    disableFormats: true,
    rtl: null,
    text: '<tpl if="startArrow">' + '<div style="__SIDE__:{startArrow.side}px;top:{startArrow.top}px" class="sch-dependency sch-dependency-arrow sch-dependency-start-arrow sch-dependency-arrow-{startArrow.dir} {lineCls} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.highlighted || "" ]}" <tpl if="dependencyId">data-sch-dependency-id="{[values.dependencyId]}"</tpl>></div>' + '</tpl>' + '<tpl for="segments">' + '<div class="sch-dependency sch-dependency-line sch-dependency-line-{dir} {parent.lineCls} {[ parent.highlighted || "" ]} {[ this.getSuffixedCls(parent.cls, "-line") ]}" style="__SIDE__:{side}px;top:{top}px;<tpl if="width !== null && width !== undefined">width:{width}px;</tpl><tpl if="height !== null && height !== undefined">height:{height}px</tpl>" <tpl if="parent.dependencyId">data-sch-dependency-id="{parent.dependencyId}"</tpl>></div>' + '</tpl>' + '<tpl if="endArrow">' + '<div style="__SIDE__:{endArrow.side}px;top:{endArrow.top}px" class="sch-dependency sch-dependency-arrow sch-dependency-end-arrow sch-dependency-arrow-{endArrow.dir} {lineCls} {[ this.getSuffixedCls(values.cls, "-arrow") ]} {[ values.highlighted || "" ]}" <tpl if="dependencyId">data-sch-dependency-id="{dependencyId}"</tpl>></div>' + '</tpl>',
    constructor: function(config) {
        var me = this;
        Ext.apply(me, config);
        me.text = me.text.replace(/__SIDE__/g, me.rtl ? 'right' : 'left');
        me.callParent([
            me.text
        ]);
    },
    getSuffixedCls: function(cls, suffix) {
        var result = '';
        if (cls && cls.indexOf(' ') != -1) {
            result = cls.replace(/^\s*(.*)\s*$/, '$1').split(/\s+/).join(suffix + ' ') + suffix;
        } else if (cls) {
            result = cls + suffix;
        }
        return result;
    }
});

// @tag dependencies
/**
 * This class is handling the drawing of scheduled record dependencies
 */
Ext.define('Sch.view.dependency.Painter', function(thisClass) {
    // These functions will be tried one by one in case a path can't be found
    function resetArrowMargins(lineDef) {
        var adjusted = false;
        if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {
            lineDef.startArrowMargin = lineDef.endArrowMargin = 0;
            adjusted = true;
        }
        return adjusted ? lineDef : adjusted;
    }
    function shrinkStartEndMarginsBy2(lineDef) {
        var adjusted = false;
        if (lineDef.hasOwnProperty('startHorizontalMargin') && lineDef.startHorizontalMargin > 2) {
            lineDef.startHorizontalMargin = Math.round(lineDef.startHorizontalMargin / 2);
            adjusted = true;
        }
        if (lineDef.hasOwnProperty('startVerticalMargin') && lineDef.startVerticalMargin > 2) {
            lineDef.startVerticalMargin = Math.round(lineDef.startVerticalMargin / 2);
            adjusted = true;
        }
        if (lineDef.hasOwnProperty('endHorizontalMargin') && lineDef.endHorizontalMargin > 2) {
            lineDef.endHorizontalMargin = Math.round(lineDef.endHorizontalMargin / 2);
            adjusted = true;
        }
        if (lineDef.hasOwnProperty('endVerticalMargin') && lineDef.endVerticalMargin > 2) {
            lineDef.endVerticalMargin = Math.round(lineDef.endVerticalMargin / 2);
            adjusted = true;
        }
        return adjusted ? lineDef : adjusted;
    }
    function resetArrowSizes(lineDef) {
        var adjusted = false;
        if (lineDef.startArrowSize > 0 || lineDef.endArrowSize > 0) {
            lineDef.startArrowSize = lineDef.endArrowSize = 0;
            adjusted = true;
        }
        return adjusted ? lineDef : adjusted;
    }
    var lineDefAdjusters = [
            resetArrowMargins,
            shrinkStartEndMarginsBy2,
            shrinkStartEndMarginsBy2,
            shrinkStartEndMarginsBy2,
            resetArrowSizes
        ];
    return {
        alias: 'schdependencypainter.default',
        mixins: [
            'Ext.mixin.Factoryable'
        ],
        requires: [
            'Sch.util.RectangularPathFinder',
            'Sch.template.Dependency'
        ],
        uses: [
            'Ext.Array',
            'Ext.XTemplate',
            'Ext.dom.Query',
            'Sch.util.Date',
            'Sch.util.RectangularPathFinder',
            'Sch.template.Dependency'
        ],
        config: {
            /**
             * @cfg {String} cls
             * Line's optional/user defined CSS class
             */
            cls: '',
            /**
             * @cfg {Boolean} rtl
             * Set to `true` if application is running in RTL mode
             */
            rtl: false,
            /**
             * @cfg {String/Array/Ext.XTemplate} lineTpl
             * Line template
             */
            lineTpl: null,
            /**
             * @cfg {String} canvasCls
             * Canvas element CSS class
             */
            canvasCls: null,
            /**
             * @cfg {Object} pathFinderConfig
             * Path finder instance configuration
             */
            pathFinderConfig: null,
            /**
             * @cfg {Number} realLineThickness
             * The real dependency line thickness. Visually it will be always 1px, but actual line element width or height
             * is different to allow proper catching pointer events. By default it's set by CSS rules, but for the testing
             * purposes we might override the CSS rules with exact value.
             * @private
             */
            realLineThickness: null,
            /**
             * Use caching of which rows dependencies intersects to speed up painting, or go without to pain slowly...
             * @private
             */
            useDependencyRowIntersectionCache: true
        },
        // Private
        pathFinder: null,
        // TODO: having this here is an incapsulation leakage, it should be a template class responsibility
        //       to select elements corresponding to a dependency using this attribute
        dependencyIdAttr: 'data-sch-dependency-id',
        constructor: function(config) {
            var me = this;
            me.initConfig(config);
            me.pathFinder = me.createPathFinder(me.getPathFinderConfig());
            if (!me.getLineTpl()) {
                me.setLineTpl(new Sch.template.Dependency({
                    rtl: me.getRtl()
                }));
            }
            me.resetRowIntersectionCache();
        },
        /**
         * Clones this painter
         *
         * @return {Sch.view.dependency.Painter}
         */
        clone: function() {
            var me = this;
            return new me.self(me.getConfig());
        },
        applyLineTpl: function(tpl) {
            return tpl instanceof Ext.XTemplate ? tpl : new Ext.XTemplate(tpl);
        },
        updatePathFinderConfig: function(config) {
            var me = this;
            if (me.pathFinder) {
                // In this case we are to re-create path finder instance since path finder type is changed
                if (config && 'type' in config && config.type !== me.pathFinder.type) {
                    Ext.destroy(me.pathFinder);
                    me.pathFinder = me.createPathFinder(config);
                } else // In this case we just update current painter configuration
                {
                    me.pathFinder.setConfig(config);
                }
            }
        },
        /**
         * Create path finder instance
         *
         * @protected
         */
        createPathFinder: function(config) {
            return Sch.util.RectangularPathFinder.create(config);
        },
        /**
         * Returns painter canvas element {@link Ext.dom.Helper} specification
         *
         * @return {Mixed}
         */
        getCanvasSpecification: function() {
            return {
                tag: 'div',
                role: 'presentation',
                cls: this.getCanvasCls()
            };
        },
        /**
         * Draws dependencies on `el` where `el` is supposed to be a canvas created using {@link #getCanvasSpecification the provided specification}
         * @param {Ext.view.View} primaryView See primary view interface in {@link Sch.view.dependency.View dependency view} description
         * @param {String/HtmlElement/Ext.Element} canvasEl
         * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies
         * @param {Boolean} overwrite
         */
        paint: function(primaryView, canvasEl, dependencies, overwrite) {
            var me = this,
                dependenciesToPaint = me.getUseDependencyRowIntersectionCache() ? me.filterByRowIntersections(primaryView, dependencies) : dependencies,
                markup = me.generatePaintMarkup(primaryView, dependenciesToPaint);
            canvasEl = Ext.fly(canvasEl);
            if (overwrite) {
                var tmp = document.createElement('div');
                tmp.innerHTML = markup;
                canvasEl.syncContent(tmp);
            } else {
                canvasEl.insertHtml('beforeEnd', markup);
            }
        },
        /**
         * Generates paint markup
         *
         * @param {Ext.view.View} primaryView See primary view interface in {Sch.view.dependency.View dependency view} description
         * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies
         * @return {String}
         */
        generatePaintMarkup: function(primaryView, dependencies) {
            var me = this,
                lineDefs = me.getLineDefsForDependencies(primaryView, dependencies);
            if (!Ext.isArray(lineDefs)) {
                lineDefs = [
                    lineDefs
                ];
            }
            return Ext.Array.map(lineDefs, function(lineDef) {
                var tplData;
                lineDef.path = me.findPath(lineDef);
                tplData = lineDef.path && me.getLineTplData(lineDef);
                return tplData && me.getLineTpl().apply(tplData) || '';
            }).join('');
        },
        /**
         * Returns true if element passed is an element visualizing a dependency
         *
         * @param {HTMLElement/Ext.dom.Element/String} el
         * @return {Boolean}
         */
        isDependencyElement: function(el) {
            return Ext.fly(el).is('.sch-dependency');
        },
        /**
         * Retrieves the canvas elements representing a particular dependency or dependencies
         * NOTE: Please avoid direct elements manipulation if possible, these method is subject to change.
         * @param {String/HtmlElement/Ext.Element} canvasEl
         * @param {Sch.model.Dependency/Sch.model.Dependency[]} dependencies Dependency record(s)
         * @return {Ext.dom.CompositeElementLite}
         */
        getElementsForDependency: function(canvasEl, dependencies) {
            var me = this;
            if (dependencies && !Ext.isArray(dependencies)) {
                dependencies = [
                    dependencies
                ];
            }
            return new Ext.dom.CompositeElementLite(Ext.Array.reduce(dependencies || [], function(result, dependency) {
                return result.concat(Ext.dom.Query.select('[' + me.dependencyIdAttr + '="' + dependency.internalId + '"]', Ext.getDom(canvasEl)));
            }, []));
        },
        /**
         * Returns all the elements on the canvas representing the rendered dependencies
         * NOTE: Please avoid direct elements manipulation if possible, these method is subject to change.
         * @param {String/HtmlElement/Ext.Element} canvasEl
         * @return {Ext.CompositeElementLite/Ext.CompositeElement}
         */
        getDependencyElements: function(canvasEl) {
            var canvasDom = Ext.getDom(canvasEl);
            return new Ext.dom.CompositeElementLite(canvasDom && canvasDom.childNodes || []);
        },
        /**
         * If the element passed constitutes a dependency line then returns the dependency record id this element
         * represents, otherwise returns empty string
         *
         * @param {HTMLElement/Ext.dom.Element/String} el
         * @return {String}
         */
        getElementDependencyInternalId: function(el) {
            return Ext.fly(el).getAttribute(this.dependencyIdAttr);
        },
        /**
         * Finds path for given line definition using path finder
         *
         * @param {Object} lineDef
         * @return {Object[]|false}
         */
        findPath: function(lineDef) {
            var path;
            path = this.pathFinder.findPath(lineDef, lineDefAdjusters);
            if (!path) {
                // Postcondition check for Mats' calmness:
                // - line definition shouldn't contain boxes with zero height, that might be one of the reasons why path finder can't find path
                if (lineDef.startBox.bottom - lineDef.startBox.top === 0 || lineDef.endBox.bottom - lineDef.endBox.top === 0) {
                    throw new Error('Zero height dependency line boxes detected');
                }
            }
            return path;
        },
        /**
         * Converts line definition into line data applicable to line template.
         *
         * @param {Object} lineDef
         * @return {Object}
         * @return {String}         return.id
         * @return {[Object]}       return.segments
         * @return {Object|Boolean} return.startArrow
         * @return {Object|Boolean} return.endArrow
         * @protected
         */
        getLineTplData: function(lineDef) {
            var me = this,
                rtl, realLineThickness, firstSegment, lastSegment, result;
            result = lineDef.path;
            // TODO: write a test for the case and codereview it
            // ---
            // Check if we only need to render one vertical line, due to both tasks being outside of view
            if (!lineDef.startBox.rendered && !lineDef.endBox.rendered) {
                for (var i = result.length - 1; i >= 0; i--) {
                    var line = result[i];
                    if (line.x1 === line.x2) {
                        result = [
                            line
                        ];
                        lineDef.startArrowSize = lineDef.endArrowSize = 0;
                        break;
                    }
                }
            }
            // ---
            rtl = me.getRtl();
            realLineThickness = me.getRealLineThickness();
            firstSegment = result.length && result[0];
            lastSegment = result.length && result[result.length - 1];
            result = {
                cls: lineDef.cls || '',
                lineCls: lineDef.lineCls || '',
                dependencyId: lineDef.dependencyId || '',
                highlighted: lineDef.highlighted,
                segments: Ext.Array.map(result, function(segment) {
                    var dir = me.getSegmentDir(segment),
                        result;
                    if (dir == 'horizontal') {
                        result = {
                            width: Math.abs(segment.x1 - segment.x2) + 1,
                            height: realLineThickness,
                            top: Math.min(segment.y1, segment.y2),
                            side: Math.min(segment.x1, segment.x2),
                            dir: dir
                        };
                    } else {
                        result = {
                            height: Math.abs(segment.y1 - segment.y2) + 1,
                            width: realLineThickness,
                            top: Math.min(segment.y1, segment.y2),
                            side: Math.min(segment.x1, segment.x2),
                            dir: dir
                        };
                    }
                    return result;
                }),
                startArrow: lineDef.startArrowSize && {
                    side: firstSegment.x1,
                    top: firstSegment.y1,
                    dir: me.convertSideToDir(lineDef.startSide, rtl)
                },
                endArrow: lineDef.endArrowSize && {
                    side: lastSegment.x2,
                    top: lastSegment.y2,
                    dir: me.convertSideToDir(lineDef.endSide, rtl)
                },
                realLineThickness: me.getRealLineThickness()
            };
            return result;
        },
        // Checks whether a dependency belongs to the provided timespan
        isDependencyInTimeSpan: function(dependency, startDate, endDate) {
            var ddr = dependency.getDateRange();
            return ddr && (!startDate || !endDate || Sch.util.Date.intersectSpans(ddr.start, ddr.end, startDate, endDate));
        },
        /**
         * Adds all dependencies that are not already in row intersection cache to it. Row intersection cache is used to
         * determine which dependencies needs to be considered for drawing, by storing which rows each dependency
         * intersects.
         * @param primaryView
         * @param dependencies
         * @private
         */
        addToRowIntersectionCacheIfNotPresent: function(primaryView, dependencies) {
            var me = this,
                viewStartDate = primaryView.getViewStartDate(),
                viewEndDate = primaryView.getViewEndDate(),
                all = me.dependencyStore.count() === dependencies.length;
            // bail out if all dependencies already in cache
            if (me.allInRowIntersectionCache)  {
                return;
            }
            
            Ext.Array.each(dependencies, function(dependency) {
                // add if adding all or if not already added
                if (all || !me.isInRowIntersectionCache(dependency)) {
                    var source = dependency.getSourceEvent(),
                        target = dependency.getTargetEvent();
                    // if the dependency belongs to the visible timespan
                    if (me.isDependencyInTimeSpan(dependency, viewStartDate, viewEndDate)) {
                        var sourceIndex = me.getIndexForCache(primaryView, source),
                            targetIndex = me.getIndexForCache(primaryView, target),
                            first = Math.min(sourceIndex, targetIndex),
                            last = Math.max(sourceIndex, targetIndex);
                        if (first > -1 && last > -1) {
                            // store using records indexes in groups of ten (to keep map smaller)
                            first = Math.floor(first / 10);
                            last = Math.floor(last / 10);
                            // rowIntersectionCache has an array of dependencies for each "row group" (ten rows), which
                            // contains dependencies that intersects any of those row. hence a dependency might
                            // appear in many places in the cache
                            for (var i = first; i <= last; i++) {
                                // this map is the actual cache
                                if (!me.rowIntersectionCache[i])  {
                                    me.rowIntersectionCache[i] = [];
                                }
                                
                                me.rowIntersectionCache[i].push(dependency);
                                // this map enables lookups to see if dependency is cached
                                me.cachedDependencies[dependency.internalId] = true;
                            }
                        }
                    }
                }
            });
            //else {
            //    debugger;
            //}
            if (!all)  {
                all = Object.keys(me.cachedDependencies).length === me.dependencyStore.count();
            }
            
            if (all)  {
                me.allInRowIntersectionCache = true;
            }
            
        },
        /**
         * Get index to cache for specified event
         * @protected
         */
        getIndexForCache: function(primaryView, event) {
            if ('getResource' in event) {
                var resource = event.getResource();
                if (resource)  {
                    return primaryView.getResourceStore().indexOf(resource);
                }
                
                if (!resource && event.resourceIdField in event.data)  {
                    return -1;
                }
                
                throw new Error('Not implemented for scheduler with multi assignment');
            } else if ('getTaskStore' in event) {
                // TaskStore used with scheduler, event is a task
                return event.getTaskStore().indexOf(event);
            }
        },
        /**
         * Empties row intersection cache
         * @protected
         */
        resetRowIntersectionCache: function(dontClear) {
            this.allInRowIntersectionCache = false;
            if (!dontClear) {
                this.rowIntersectionCache = {};
                this.cachedDependencies = {};
            }
        },
        /**
         * Checks if a dependency is in row intersection cache
         * @private
         * @param {Sch.model.Dependency} dependency
         * @returns {boolean}
         */
        isInRowIntersectionCache: function(dependency) {
            return !!this.cachedDependencies[dependency.internalId];
        },
        /**
         * Returns an filtered array of dependecies containing only those that needs to be considered for painting
         * @private
         * @param primaryView
         * @param {Dependency[]} dependencies
         * @returns {Dependency[]}
         */
        filterByRowIntersections: function(primaryView, dependencies) {
            var me = this;
            if (!Ext.isArray(dependencies)) {
                dependencies = [
                    dependencies
                ];
            }
            // quick bailout when no dependencies
            if (!dependencies.length)  {
                return [];
            }
            
            // since this fn might be called multiple times with partial dependency coverage (depending on
            // renderingstrategy), add to cache if not already there
            me.addToRowIntersectionCacheIfNotPresent(primaryView, dependencies);
            var dependenciesToDraw = [],
                // determine first and last rendered row, observe that primaryView.all is private
                rows = primaryView.getNodes(),
                first = primaryView.indexOf(rows[0]),
                last = primaryView.indexOf(rows[rows.length - 1]),
                fromCache;
            // cache holds row indexes in "groups" of ten (0-9 -> 0, 10-19 -> 1, ...)
            first = Math.floor(first / 10);
            last = Math.floor(last / 10);
            // only dependencies that intersects a rendered row will be drawn
            for (var i = first; i <= last; i++) {
                fromCache = me.rowIntersectionCache[i];
                fromCache && dependenciesToDraw.push.apply(dependenciesToDraw, fromCache);
            }
            // a dependency that intersects multiple "row groups" will be included multiple times, make sure we only
            // have one of each, as well as filter out the ones we do not requested to be re-drawn.
            return Ext.Array.intersect(dependencies, Ext.Array.unique(dependenciesToDraw));
        },
        /**
         * @param {Sch.view.SchedulingView}
         * @param {Sch.model.Dependency[]}
         * @return {Object[]}
         * @protected
         */
        getLineDefsForDependencies: function(primaryView, dependencies) {
            var EA = Ext.Array,
                me = this,
                cache = {},
                viewStartDate = primaryView.getViewStartDate(),
                viewEndDate = primaryView.getViewEndDate(),
                internalId;
            if (!Ext.isArray(dependencies)) {
                dependencies = [
                    dependencies
                ];
            }
            // quick bailout when no dependencies
            if (!dependencies.length)  {
                return [];
            }
            
            // TODO: dont draw deps that starts and ends outside of view
            var result = EA.reduce(dependencies || [], function(result, dependency) {
                    var source = dependency.getSourceEvent(),
                        target = dependency.getTargetEvent(),
                        sourceBoxes, targetBoxes;
                    // if the dependency belongs to the visible timespan
                    if (me.isDependencyInTimeSpan(dependency, viewStartDate, viewEndDate)) {
                        // Getting source boxes
                        internalId = source.internalId;
                        if (!cache[internalId]) {
                            sourceBoxes = me.getItemBox(primaryView, source) || [];
                            if (!Ext.isArray(sourceBoxes)) {
                                sourceBoxes = [
                                    sourceBoxes
                                ];
                            }
                            cache[internalId] = sourceBoxes;
                        } else {
                            sourceBoxes = cache[internalId];
                        }
                        // Getting target boxes
                        internalId = target.internalId;
                        if (!cache[internalId]) {
                            targetBoxes = me.getItemBox(primaryView, target) || [];
                            if (!Ext.isArray(targetBoxes)) {
                                targetBoxes = [
                                    targetBoxes
                                ];
                            }
                            cache[internalId] = targetBoxes;
                        } else {
                            targetBoxes = cache[internalId];
                        }
                        // Create line definitions for each item box cartesian multiplication
                        result = EA.reduce(sourceBoxes, function(result, sourceBox, sourceBoxIdx) {
                            return EA.reduce(targetBoxes, function(result, targetBox, targetBoxIdx) {
                                if (sourceBox && targetBox && (sourceBox.rendered || targetBox.rendered || sourceBox.relPos != targetBox.relPos)) {
                                    result.push(me.createLineDef(primaryView, dependency, source, target, sourceBox, targetBox, null));
                                }
                                return result;
                            }, result);
                        }, result);
                    }
                    return result;
                }, []);
            return result;
        },
        /**
         * Returns all the boxes a painter shall take into account, which corresponds to the given record
         *
         * @param {Ext.data.Model} itemRecord
         * @return {Object/Object[]}
         * @protected
         */
        getItemBox: function(primaryView, itemRecord) {
            return primaryView.getItemBox(itemRecord);
        },
        /**
         * Creates dependency line definition recognized by path finder
         *
         * @param {Ext.view.View} primaryView
         * @param {Sch.model.Dependency} dependency
         * @param {Ext.data.Model} source
         * @param {Ext.data.Model} target
         * @param {Object} sourceBox
         * @param {Object} targetBox
         * @param {Object[]/null} otherBoxes
         * @return {Object}
         * @protected
         */
        createLineDef: function(primaryView, dependency, source, target, sourceBox, targetBox, otherBoxes) {
            var DEP_TYPE = dependency.self.Type,
                me = this,
                type = dependency.getType(),
                horizontalMargin = me.pathFinder.getHorizontalMargin(),
                verticalMargin = me.pathFinder.getVerticalMargin(),
                bidirectional = dependency.getBidirectional(),
                startArrowMargin = bidirectional ? me.pathFinder.getStartArrowMargin() : 0,
                startArrowSize = bidirectional ? me.pathFinder.getStartArrowSize() : 0,
                endArrowMargin = me.pathFinder.getEndArrowMargin(),
                endArrowSize = me.pathFinder.getEndArrowSize(),
                startSide = dependency.getFromSide(),
                endSide = dependency.getToSide();
            // Fallback to view trait if dependency start side is not given
            if (!startSide) {
                switch (true) {
                    case type == DEP_TYPE.StartToEnd:
                        startSide = primaryView.getConnectorStartSide(source);
                        break;
                    case type == DEP_TYPE.StartToStart:
                        startSide = primaryView.getConnectorStartSide(source);
                        break;
                    case type == DEP_TYPE.EndToStart:
                        startSide = primaryView.getConnectorEndSide(source);
                        break;
                    case type == DEP_TYPE.EndToEnd:
                        startSide = primaryView.getConnectorEndSide(source);
                        break;
                    default:
                        throw new Error('Invalid dependency type: ' + dependency.getType());
                }
            }
            // Fallback to view trait if dependency end side is not given
            if (!endSide) {
                switch (true) {
                    case type == DEP_TYPE.StartToEnd:
                        endSide = primaryView.getConnectorEndSide(target);
                        break;
                    case type == DEP_TYPE.StartToStart:
                        endSide = primaryView.getConnectorStartSide(target);
                        break;
                    case type == DEP_TYPE.EndToStart:
                        endSide = primaryView.getConnectorStartSide(target);
                        break;
                    case type == DEP_TYPE.EndToEnd:
                        endSide = primaryView.getConnectorEndSide(target);
                        break;
                    default:
                        throw new Error('Invalid dependency type: ' + dependency.getType());
                }
            }
            // This is for the 018_export_dependencies.t.js to be green
            // TODO: refactor the test and remove this code
            // --------------------------------------------------------
            switch (true) {
                case (startSide == 'left' || startSide == 'right') && (endSide == 'left' || endSide == 'right'):
                    verticalMargin = 2;
                    horizontalMargin = 5;
                    break;
                case (startSide == 'top' || startSide == 'bottom') && (endSide == 'top' || endSide == 'bottom'):
                    verticalMargin = 7;
                    horizontalMargin = 2;
                    break;
            }
            var distance = Number.MAX_VALUE;
            var centerHorizontalPoint = {
                    from: (sourceBox.start + sourceBox.end) / 2,
                    to: (targetBox.start + targetBox.end) / 2
                };
            var centerVerticalPoint = {
                    from: (sourceBox.top + sourceBox.bottom) / 2,
                    to: (targetBox.top + targetBox.bottom) / 2
                };
            // if points are too close to show the arrow(s) they are hidden
            if ((startSide === 'top' && endSide === 'bottom' || startSide === 'bottom' && endSide === 'top') && centerHorizontalPoint.from === centerHorizontalPoint.to) {
                distance = Math.abs(sourceBox[startSide] - targetBox[endSide]);
            } else if ((startSide === 'left' && endSide === 'right' || startSide === 'right' && endSide === 'left') && centerVerticalPoint.from === centerVerticalPoint.to) {
                var sourceSide = startSide === 'left' ? 'start' : 'end';
                var targetSide = endSide === 'left' ? 'start' : 'end';
                if (primaryView.rtl) {
                    sourceSide = sourceSide === 'start' ? 'end' : 'start';
                    targetSide = targetSide === 'start' ? 'end' : 'start';
                }
                var startX = sourceBox[sourceSide];
                var endX = targetBox[targetSide];
                distance = Math.abs(startX - endX);
            }
            if (distance < (endArrowSize * endArrowMargin) * 2) {
                startArrowMargin = endArrowMargin = 0;
                if (distance <= endArrowSize * 2) {
                    startArrowSize = endArrowSize = 0;
                }
            }
            // --------------------------------------------------------
            return Ext.applyIf({
                startBox: sourceBox,
                startSide: startSide,
                startArrowSize: startArrowSize,
                startArrowMargin: startArrowMargin,
                endBox: targetBox,
                endSide: endSide,
                endArrowSize: endArrowSize,
                endArrowMargin: endArrowMargin,
                // OPTIMIZE
                top: Math.min(sourceBox.top, targetBox.top),
                bottom: Math.max(sourceBox.bottom, targetBox.bottom),
                verticalMargin: verticalMargin,
                horizontalMargin: horizontalMargin,
                startVerticalMargin: verticalMargin,
                startHorizontalMargin: horizontalMargin,
                endVerticalMargin: verticalMargin,
                endHorizontalMargin: horizontalMargin,
                otherBoxes: otherBoxes,
                dependency: dependency,
                dependencyId: dependency.internalId,
                lineCls: me.getCls(),
                cls: dependency.getCls(),
                highlighted: dependency.getHighlighted()
            }, me.getConfig());
        },
        convertSideToDir: function(side, rtl) {
            return this.self.sideToDir[side + (rtl && '-rtl' || '')];
        },
        getSegmentDir: function(segment) {
            var dir = 'vertical';
            if (segment.y1 === segment.y2) {
                dir = 'horizontal';
            }
            return dir;
        },
        inheritableStatics: {
            /**
             * @private
             */
            sideToDir: {
                'left': 'right',
                'right': 'left',
                'top': 'down',
                'bottom': 'up',
                'left-rtl': 'left',
                'right-rtl': 'right',
                'top-rtl': 'down',
                'bottom-rtl': 'up'
            }
        }
    };
});

// @tag dependencies
/**
 * Abstract dependency rendering strategy.
 *
 * The strategy is implemented as finite state automata.
 * Please consult [the automata chart](doc-resources/scheduler/images/deps/deps_rendering_strategy.svg)
 */
Ext.define('Sch.view.dependency.renderingstrategy.Abstract', function() {
    function depsToMap(deps) {
        return Ext.Array.reduce(deps, function(result, d) {
            result[d.getId()] = d;
            return result;
        }, {});
    }
    // This is 10 times faster then simple Ext.Array.unique()
    function uniqueDeps(deps) {
        return Ext.Object.getValues(depsToMap(deps));
    }
    // This is also faster the Ext.Array.diff()
    function diffDeps(depsA, depsB) {
        var mapA, mapB,
            result = [];
        mapA = depsToMap(depsA);
        mapB = depsToMap(depsB);
        Ext.Object.each(mapA, function(k, v) {
            mapB.hasOwnProperty(k) || result.push(v);
        });
        return result;
    }
    var methodDenyFn = function() {
            Ext.Error.raise('Method is not allowed to call at this state');
        };
    // Abstract state API
    var stateApi = {
            render: methodDenyFn,
            clear: methodDenyFn,
            scheduledRender: methodDenyFn,
            destroy: methodDenyFn
        };
    var readyState, scheduledRenderingState, destroyedState;
    // Initial state of the strategy rendering automata
    readyState = Ext.applyIf({
        // Event render
        render: function(me, view, deps, all) {
            var promise, resolvePromiseFn, rejectPromiseFn, hiddenParent;
            // Create promise
            promise = new Ext.Promise(function(resolve, reject) {
                resolvePromiseFn = resolve;
                rejectPromiseFn = reject;
            });
            // Can render?
            if (view.canDrawDependencies()) {
                // Store deps
                me._depsToRender = deps;
                me._depsRendered = [];
                Ext.Array.reduce(me._depsToRender, function(result, d) {
                    return result && !!d.store;
                }, true) || Ext.Error.raise('Can\'t render unstorred dependency');
                // Detect hidden parent
                hiddenParent = view.getPrimaryView().up("{isHidden()}");
                // Has hidden parent?
                if (hiddenParent) {
                    // Schedule deferred rendering on show
                    me._scheduledRenderDetacher = hiddenParent.on('show', function() {
                        delete me._scheduledRenderDetacher;
                        me._fsaState.scheduledRender(me, view);
                    }, null, {
                        single: true,
                        destroyable: true
                    });
                } else {
                    // Schedule deferred rendering asap
                    me._scheduledRenderCancelId = Ext.asap(function() {
                        delete me._scheduledRenderCancelId;
                        me._fsaState.scheduledRender(me, view);
                    });
                }
                // Fire start rendering
                /**
                 * @event rendering-start Fires when rendering process is scheduled to start
                 *
                 * @param {Sch.view.dependency.renderingstrategy.Abstract} me
                 *
                 * @member Sch.view.dependency.renderingstrategy.Abstract
                 */
                me.hasListeners['rendering-start'] && me.fireEvent('rendering-start', me);
                // Store promise
                me._renderPromise = promise;
                me._renderPromiseResolve = resolvePromiseFn;
                me._renderPromiseReject = rejectPromiseFn;
                // Ready -> Scheduled rendering state
                me._fsaState = scheduledRenderingState;
            } else {
                // Reject promise w/deps unredered
                rejectPromiseFn(deps);
            }
            return promise;
        },
        // Event clear
        clear: function(me, view, deps, all) {
            // Create promise
            var promise;
            // Can render?
            if (view.canDrawDependencies()) {
                // Has canvas?
                if (view.isDependencyCanvasPresent()) {
                    // Clear dependencies via painter
                    if (all) {
                        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), [], true);
                    } else {
                        Ext.destroy(view.getPainter().getElementsForDependency(view.getDependencyCanvas(), deps));
                    }
                }
                // Resolve promise w/deps cleared
                promise = Ext.Promise.resolve(deps);
            } else {
                // Reject promise w/deps uncleared
                promise = Ext.Promise.reject(deps);
            }
            return promise;
        },
        // Event destroy
        destroy: function(me) {
            // Set destroyed
            me.destroyed = true;
            // Ready -> destroyed state
            me._fsaState = destroyedState;
        }
    }, stateApi);
    // Scheduled rendering state of the strategy rendering automata
    scheduledRenderingState = Ext.applyIf({
        // Event render
        render: function(me, view, deps, all) {
            // Unite deps w/stored deps
            me._depsToRender = all ? deps : uniqueDeps(me._depsToRender.concat(deps));
            Ext.Array.reduce(me._depsToRender, function(result, d) {
                return result && !!d.store;
            }, true) || Ext.Error.raise('Can\'t render unstored dependency');
            return me._renderPromise;
        },
        // Event clear
        clear: function(me, view, deps, all) {
            // Create promise
            var promise;
            // Can render?
            if (view.canDrawDependencies()) {
                // Has canvas?
                if (view.isDependencyCanvasPresent()) {
                    // Clear dependencies via painter
                    if (all) {
                        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), [], true);
                    } else {
                        Ext.destroy(view.getPainter().getElementsForDependency(view.getDependencyCanvas(), deps));
                    }
                }
                // Remove deps from deps to render
                if (all) {
                    me._depsToRender = [];
                } else {
                    me._depsToRender = diffDeps(me._depsToRender, deps);
                }
                // Resolve promise w/deps cleared
                promise = Ext.Promise.resolve(deps);
            } else {
                // Reject promise w/deps uncleared
                promise = Ext.Promise.reject(deps);
            }
            return promise;
        },
        // Scheduled render event
        scheduledRender: function(me, view) {
            var hiddenParent, depsDone;
            // Can render?
            if (view.canDrawDependencies()) {
                // Detect hidden parent
                hiddenParent = view.getPrimaryView().up("{isHidden()}");
                // Has hidden parent?
                if (hiddenParent) {
                    // Schedule deferred rendering on show
                    me._scheduledRenderDetacher = hiddenParent.on('show', function() {
                        delete me._scheduledRenderDetacher;
                        me._fsaState.scheduledRender(me, view);
                    }, null, {
                        single: true,
                        destroyable: true
                    });
                } else {
                    // Has deps to render?
                    if (me._depsToRender.length > 0) {
                        Ext.Array.reduce(me._depsToRender, function(result, d) {
                            return result && !!d.store;
                        }, true) || Ext.Error.raise('Can\'t render unstorred dependency');
                        // Delegate rendering
                        depsDone = me.delegateRendering(view, me._depsToRender, me._depsRendered);
                        Ext.Assert && Ext.Assert.isArray(depsDone, "Delegate rendering result must be an array");
                        Ext.Assert && Ext.Assert.truthy(depsDone.length == 2, "Delegate rendering result array length must be 2");
                        // Unite just rendered w/deps rendered
                        me._depsRendered = uniqueDeps(me._depsRendered.concat(depsDone[0]));
                        // Deps to render = left deps
                        me._depsToRender = depsDone[1];
                        // Fire rendering progress
                        /**
                        * @event rendering-progress Fires upon rendering progress
                        *
                        * @param {Sch.view.dependency.renderingstrategy.Abstract} me
                        * @param {Sch.model.DependencyBase[]} depsToRender
                        * @param {Sch.model.DependencyBase[]} depsRendered
                        *
                        * @member Sch.view.dependency.renderingstrategy.Abstract
                        */
                        me.hasListeners['rendering-progress'] && me.fireEvent('rendering-progress', me, me._depsToRender, me._depsRendered);
                        // Has deps to render left?
                        if (me._depsToRender.length > 0) {
                            // Schedule deferred rendering
                            me._scheduledRenderCancelId = Ext.asap(function() {
                                delete me._scheduledRenderCancelId;
                                me._fsaState.scheduledRender(me, view);
                            });
                        } else {
                            // Fire rendering complete
                            /**
                            * @event rendering-complete Fires upon rendering completion
                            *
                            * @param {Sch.view.dependency.renderingstrategy.Abstract} me
                            * @param {Sch.model.DependencyBase[]} depsRendered
                            *
                            * @member Sch.view.dependency.renderingstrategy.Abstract
                            */
                            me.hasListeners['rendering-complete'] && me.fireEvent('rendering-complete', me, me._depsRendered);
                            // Resolve stored promise w/deps rendered
                            me._renderPromiseResolve(me._depsRendered);
                            // Delete stored promise
                            delete me._renderPromise;
                            delete me._renderPromiseResolve;
                            delete me._renderPromiseReject;
                            // Delete deps to render and rendered deps
                            delete me._depsToRender;
                            delete me._depsRendered;
                            // Scheduled rendering -> Ready state
                            me._fsaState = readyState;
                        }
                    } else {
                        // Fire rendering complete
                        me.hasListeners['rendering-complete'] && me.fireEvent('rendering-complete', me, me._depsRendered);
                        // Resolve stored promise w/deps rendered
                        me._renderPromiseResolve(me._depsRendered);
                        // Delete stored promise
                        delete me._renderPromise;
                        delete me._renderPromiseResolve;
                        delete me._renderPromiseReject;
                        // Delete deps to render and rendered deps
                        delete me._depsToRender;
                        delete me._depsRendered;
                        // Scheduled rendering -> Ready state
                        me._fsaState = readyState;
                    }
                }
            } else {
                // Fire rendering canceled
                /**
                 * @event rendering-canceled Fires upon rendering cancelation
                 *
                 * @param {Sch.view.dependency.renderingstrategy.Abstract} me
                 * @param {Sch.model.DependencyBase[]} depsRendered
                 * @param {Sch.model.DependencyBase[]} depsToRender
                 *
                 * @member Sch.view.dependency.renderingstrategy.Abstract
                 */
                me.hasListeners['rendering-canceled'] && me.fireEvent('rendering-canceled', me, me._depsRendered, me._depsToRender);
                // Reject stored promise w/deps unrendered
                me._renderPromiseReject(me._depsToRender);
                // Delete stored promise
                delete me._renderPromise;
                delete me._renderPromiseResolve;
                delete me._renderPromiseReject;
                // Delete deps to render and rendered deps
                delete me._depsToRender;
                delete me._depsRendered;
                // Scheduled rendering -> Ready state
                me._fsaState = readyState;
            }
        },
        // Event destroy
        destroy: function(me) {
            // Has asap cancel id?
            if (me._scheduledRenderCancelId) {
                // Cancel asap
                Ext.asapCancel(me._scheduledRenderCancelId);
                // Delete cancel id
                delete me._scheduledRenderCancelId;
            }
            // Has show detacher?
            if (me._scheduledRenderDetacher) {
                // Destroy show detacher
                Ext.destroy(me._scheduledRenderDetacher);
                // Delete show detacher
                delete me._scheduledRenderDetacher;
            }
            // Fire rendering canceled
            me.hasListeners['rendering-canceled'] && me.fireEvent('rendering-canceled', me, me._depsRendered, me._depsToRender);
            // Reject stored promise w/deps unrendered
            me._renderPromiseReject(me._depsToRender);
            // Delete stored promise
            delete me._renderPromise;
            delete me._renderPromiseResolve;
            delete me._renderPromiseReject;
            // Delete deps to render and rendered deps
            delete me._depsToRender;
            delete me._depsRendered;
            // Set destroyed
            me.destroyed = true;
            // Scheduled rendering -> destroyed state
            me._fsaState = destroyedState;
        }
    }, stateApi);
    // Destroyed state of the strategy rendering automata
    destroyedState = stateApi;
    return {
        alias: "sch_dependency_rendering_strategy.abstract",
        mixins: [
            'Ext.mixin.Factoryable',
            'Ext.mixin.Observable'
        ],
        _fsaState: readyState,
        constructor: function(config) {
            var me = this;
            me.mixins.observable.constructor.call(me, config);
        },
        destroy: function() {
            var me = this;
            return me._fsaState.destroy(me);
        },
        /**
         * Renders all or just given dependencies.
         *
         * @param {Sch.view.dependency.View} view Dependency view to draw onto.
         *
         * @param {Sch.model.DependencyBase[]|null} [deps=null] Depepndency records to draw. If null given then all dependencies
         *                                                      will be drawn.
         *
         * @return {Ext.Promise.<Sch.model.DependencyBase[], Ext.Promise.<Sch.model.DependencyBase[]>}
         *
         * Returns promise which will be resolved with dependency records rendered, or reject with dependency
         * records unrendered.
         */
        renderDependencies: function(view, deps) {
            var me = this,
                all = !deps;
            return me._fsaState.render(me, view, deps || view.getDependencyStore().getRange(), all);
        },
        /**
         * Clears all or just given dependencies.
         *
         * @param {Sch.view.dependency.View} view Dependency view to draw onto.
         *
         * @param {Sch.model.DependencyBase[]|null} [deps=null] Dependency records to clear. If null given then all dependencies
         *                                                      will be cleared.
         *
         * @return {Ext.Promise.<Sch.model.DependencyBase[], Ext.Promise.<Sch.model.DependencyBase[]>}
         *
         * Returns promise which will be resolved with dependency records cleared, or reject with dependency
         * records uncleared.
         */
        clearDependencies: function(view, deps) {
            var me = this,
                all = !deps;
            return me._fsaState.clear(me, view, deps || view.getDependencyStore().getRange(), all);
        },
        /**
         * Updates all or just given dependencies.
         *
         * @param {Sch.view.dependency.View} view Dependency view to draw onto.
         *
         * @param {Sch.model.DependencyBase[]|null} [deps=null] Dependency records to update. If null given then all dependencies
         *                                                  will be updated.
         *
         * @return {Ext.Promise.<Sch.model.DependencyBase[], Ext.Promise.<Sch.model.DependencyBase[]>}
         *
         * Returns promise which will be resolved with dependency records updated, or reject with dependency
         * records unupdated.
         */
        updateDependencies: function(view, deps) {
            var me = this,
                all = !deps;
            // No deps means all deps
            deps = deps || view.getDependencyStore().getRange();
            return me._fsaState.clear(me, view, deps, all).then(function() {
                // Dependency store dataset might have been changed at this point, since the call is asynchronous
                // so we are to re-query the store if all dependencies should be updated or filter out the one removed
                deps = all ? view.getDependencyStore().getRange() : Ext.Array.reduce(deps, function(deps, d) {
                    // If record has id, it would not be unjoined from store immediately, but it will be present
                    // in array of removed records.
                    // dependencies/222_concurring_dependencies
                    if (d.store && Ext.Array.indexOf(d.store.removed, d) === -1) {
                        deps.push(d);
                    }
                    return deps;
                }, []);
                return !me.destroyed ? me._fsaState.render(me, view, deps, all) : deps;
            });
        },
        /**
         * Actual dependencies rendering template method, must be implemented by inheriting strategy
         *
         * @param {Sch.view.dependency.View} view
         * @param {Sch.model.DependencyBase[]} depsToRender
         * @param {Sch.model.DependencyBase[]} depsRendered
         *
         * @return {Array}
         * @return {Sch.model.DependencyBase[]} return.0 Dependencies rendered during call to the method
         * @return {Sch.model.DependencyBase[]} return.1 Dependencies left to render
         *
         * @protected
         * @template
         */
        delegateRendering: function(view, depsToRender, depsRendered) {
            Ext.Error.raise("Abstract method call");
        },
        inheritableStatics: {
            depsToMap: depsToMap,
            uniqueDeps: uniqueDeps,
            diffDeps: diffDeps
        }
    };
});

// @tag dependencies
/**
 * Combined dependency rendering strategy, maybe render dependencies in a bulk or asynchronously in several steps.
 */
Ext.define('Sch.view.dependency.renderingstrategy.Combined', {
    extend: 'Sch.view.dependency.renderingstrategy.Abstract',
    alias: 'sch_dependency_rendering_strategy.combined',
    config: {
        /**
         * Amount of deps to render between rendering steps
         */
        depsPerStep: 50,
        /**
         * Current working mode
         */
        mode: 'bulk'
    },
    delegateRendering: function(view, depsToRender, depsRendered) {
        var me = this;
        return me.getMode() == 'bulk' ? me.delegateRenderingBulk(view, depsToRender, depsRendered) : me.delegateRenderingAsync(view, depsToRender, depsRendered);
    },
    delegateRenderingBulk: function(view, depsToRender, depsRendered) {
        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), depsToRender, false);
        return [
            depsToRender,
            []
        ];
    },
    delegateRenderingAsync: function(view, depsToRender, depsRendered) {
        var me = this,
            depsPerStep = me.getDepsPerStep(),
            renderedDeps = depsToRender.slice(0, depsPerStep),
            leftDeps = depsToRender.slice(depsPerStep);
        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), renderedDeps, false);
        return [
            renderedDeps,
            leftDeps
        ];
    }
});

// @tag dependencies
/**
 * Dependency view is the utilitary view working alongside the primary `item` view of an Ext.Component, the only
 * requirement for the primary `item` view is to support the following interface:
 *
 *  - getEl() : Ext.dom.Element
 *  - isItemCanvasAvailable([layer : Number]) : Boolean
 *  - isItemCanvasPresent(layer : Number) : Boolean
 *  - getItemCanvasEl(layer : Number, canvasSpec : Object) : Ext.dom.Element
 *  - getItemBox(itemModel) : Object/Object[] {top : Number, bottom : Number, start : Number, end : Number, rendered : Boolean}
 *  - getStartConnectorSide(itemModel) : ['top'/'bottom'/'left'/'right']
 *  - getEndConnectorSide(itemModel) : ['top'/'bottom'/'left'/'right']
 *  - getViewStartDate() : Date|null
 *  - getViewEndDate() : Date|null
 *  - getEventStore() : Sch.data.EventStore
 *  - onDragDropStart() : void - optional
 *  - onDragDropEnd() : void - optional
 */
Ext.define('Sch.view.dependency.View', {
    alias: 'schdependencyview.base',
    mixins: [
        'Ext.mixin.Factoryable',
        'Ext.mixin.Observable'
    ],
    requires: [
        'Sch.view.dependency.Tooltip',
        'Sch.view.dependency.DragZone',
        'Sch.view.dependency.Painter',
        'Sch.view.dependency.renderingstrategy.Combined'
    ],
    uses: [
        'Ext.data.StoreManager',
        'Ext.Array',
        'Ext.dom.CompositeElementLite'
    ],
    config: {
        /**
         * @cfg {Sch.view.SchedulerGridView} primaryView (required)
         * Primary view instance
         */
        primaryView: null,
        /**
         * @cfg {Sch.data.EventStore|String} dependencyStore
         * Dependency store this view will work with, if none given then dependency store will be taken from the primary view.
         */
        dependencyStore: null,
        /**
         * @cfg {Boolean} drawDependencies
         * Set to false to turn dependency drawing off
         * @private
         */
        drawDependencies: true,
        /**
         * @cfg {Number} bulkRenderingDependencyLimit
         * Maximum amount of dependencies until bulk rendering strategy is used, if there're more dependencies in
         * the store then asynchronous rendering strategy will be used
         */
        bulkRenderingDependencyLimit: 100,
        /**
         * @cfg {Number} asyncRenderingDepsPerStep
         * Amount of dependencies to render per one render step if asynchronous rendering strategy is used.
         */
        asyncRenderingDepsPerStep: 50,
        /**
         * @cfg {Object} painterConfig
         * Dependency painter instance config
         */
        painterConfig: {
            canvasCls: 'sch-dependencyview-ct'
        },
        /**
         * @cfg {Number} canvasLayer
         * Dependency canvas layer position (i.e. z-index)
         * @private
         */
        canvasLayer: 0,
        /**
         * @cfg {Boolean} enableDependencyDragDrop
         * True to allow creating new links using drag drop
         */
        enableDependencyDragDrop: true,
        /**
         * @cfg {String[]} terminalSides
         * An array defining which sides to show dependency terminals
         */
        terminalSides: [
            'left',
            'right',
            'top',
            'bottom'
        ],
        /**
         * @cfg {String/Ext.Template} dragTipTpl
         * A template to show when creating a new dependency using drag drop
         */
        dragTipTpl: null,
        /**
         * @cfg {String/Ext.Template} tipTpl
         * A template for the {@link #tip tooltip} to show info about a dependency.
         * See also {@link #tipCfg}
         */
        tipTpl: null,
        /**
         * @cfg {Boolean/Object} showTooltip
         * A flag to show a {@link #tip tooltip} with info about a dependency.
         * Also excepts a config for the {@link #tip tooltip}.
         * Set to `false` or `null` to turn the {@link #tip tooltip} off.
         */
        showTooltip: true,
        /**
         * Additional drag zone config.
         */
        dragZoneConfig: null,
        /**
         * @cfg {String} selectedCls
         * The CSS class to add to a dependency line when dependency is selected
         */
        selectedCls: 'sch-dependency-selected',
        /**
         * @cfg {String} overCls
         * The CSS class to add to a dependency line when hovering over it
         */
        overCls: 'sch-dependency-over'
    },
    // private
    painter: null,
    renderingStrategy: null,
    primaryViewDetacher: null,
    primaryViewLockableDetacher: null,
    primaryViewElDetacher: null,
    dependencyStoreDetacher: null,
    dragZone: null,
    scrolling: false,
    /**
     * @property {Ext.tip.ToolTip} tip
     * @readonly
     * @private
     * A tooltip to show info about a dependency
     */
    tip: null,
    constructor: function(config) {
        var me = this,
            view;
        // Just in case
        me.callParent([
            config
        ]);
        // Initializing observable mixin
        me.mixins.observable.constructor.call(me, config);
        // Since we do not inherit from the Ext.Component the call to `initConfig` is required
        me.initConfig(config);
        Ext.Assert && Ext.Assert.isObject(me.getPrimaryView(), 'Dependency view requires a primary view to be configured in');
        Ext.Assert && Ext.Assert.isFunctionProp(me.getPrimaryView(), 'isItemCanvasAvailable', 'Dependency view requires `Sch.mixin.GridViewCanvas` mixin to be mixed into scheduling view, or the corresponding interface to be implemented');
        Ext.Assert && Ext.Assert.isFunctionProp(me.getPrimaryView(), 'getItemCanvasEl', 'Dependency view requires `Sch.mixin.GridViewCanvas` mixin to be mixed into scheduling view, or the corresponding interface to be implemented');
        me.painter = me.createPainter(Ext.apply({
            rtl: me.getPrimaryView().rtl,
            dependencyStore: me.getDependencyStore()
        }, // TODO: only needed to check if all deps are being rendered, alter renderingstrategies to pass as arg instead?
        me.getPainterConfig()));
        // TODO: write test that verifies that each op resets cache
        if (me.painter.getUseDependencyRowIntersectionCache()) {
            if (me.getPrimaryView().resourceStore) {
                me.getPrimaryView().mon(me.getPrimaryView().resourceStore, {
                    add: me.resetPainterCache,
                    remove: me.resetPainterCache,
                    //load        : me.resetPainterCache,
                    clear: me.resetPainterCache,
                    refresh: me.resetPainterCache,
                    scope: me
                });
            }
            if (me.getDependencyStore()) {
                me.mon(me.getDependencyStore(), {
                    add: me.updatePainterCache,
                    remove: me.resetPainterCache,
                    //load         : me.resetPainterCache,
                    clear: me.resetPainterCache,
                    refresh: me.resetPainterCache,
                    scope: me
                });
            }
            me.mon(me.getPrimaryView().ownerGrid, {
                viewchange: me.resetPainterCache,
                scope: me
            });
        }
        if (me.canDrawDependencies()) {
            me.startDrawDependencies();
        }
        if (me.getEnableDependencyDragDrop()) {
            view = me.getPrimaryView();
            me.dragZone = me.createDragZone(Ext.apply({
                view: view,
                ddGroup: view.getId() + '-dep-dd',
                rtl: view.rtl,
                terminalSelector: '.sch-terminal',
                dependencyStore: me.getDependencyStore(),
                tipTpl: me.getDragTipTpl()
            }, me.getDragZoneConfig() || {}));
            me.dragZone.on({
                dragstart: me.onDragStart,
                drop: me.onDependencyDrop,
                afterdrop: me.onDependencyAfterDrop,
                scope: me
            });
            me.relayEvents(me.dragZone, [
                'beforedrag',
                'dragstart',
                'drop',
                'afterdrop'
            ]);
        }
        var tipCfg = me.getShowTooltip();
        if (tipCfg) {
            me.tip = new Sch.view.dependency.Tooltip(Ext.apply({
                dependencyView: me,
                tpl: me.getTipTpl()
            }, tipCfg));
        }
    },
    destroy: function() {
        var me = this;
        me.stopDrawDependencies();
        me.tip && me.tip.destroy();
        me.dragZone && me.dragZone.destroy();
    },
    destroyDetachers: function() {
        var me = this;
        Ext.destroyMembers(this, 'primaryViewDetacher', 'primaryViewLockableDetacher', 'primaryViewElDetacher', 'dependencyStoreDetacher');
    },
    destroyDependencyCanvas: function() {
        var me = this;
        if (me.isDependencyCanvasPresent()) {
            Ext.destroy(me.getDependencyCanvas());
        }
    },
    destroyRenderingStrategy: function() {
        var me = this;
        Ext.destroy(me.renderingStrategy);
        me.renderingStrategy = null;
    },
    resetPainterCache: function() {
        this.painter.resetRowIntersectionCache();
    },
    updatePainterCache: function() {
        this.painter.resetRowIntersectionCache(true);
    },
    /**
     * Checks if the view is ready to draw dependencies
     *
     * @param {Boolean} ignoreDrawDependencies
     * @param {Boolean} ignoreDependencyCanvas
     * @param {Boolean} ignoreDependencyStore
     *
     * @return {Boolean}
     */
    canDrawDependencies: function(ignoreDrawDependencies, ignoreDependencyCanvas, ignoreDependencyStore) {
        var me = this;
        return !!(me.painter && me.getPrimaryView() && (ignoreDrawDependencies || me.getDrawDependencies()) && (ignoreDependencyCanvas || me.isDependencyCanvasAvailable()) && (ignoreDependencyStore || me.getDependencyStore()));
    },
    startDrawDependencies: function() {
        var me = this,
            primaryView = me.getPrimaryView(),
            dependencyStore = me.getDependencyStore(),
            lockableView;
        if (!me.renderingStrategy) {
            me.renderingStrategy = me.createRenderingStrategy();
            me.primaryViewDetacher = primaryView.on(Ext.applyIf({
                destroyable: true
            }, me.getPrimaryViewListeners()));
            me.primaryViewElDetacher = primaryView.getEl().on(Ext.applyIf({
                destroyable: true
            }, me.getPrimaryViewElListeners()));
            // Primary view is not always a grid view
            // TODO: this requires more thoughts
            if (primaryView.grid) {
                // WARNING: view.grid and view.grid.ownerLockable are private properties
                lockableView = primaryView.grid.ownerLockable && primaryView.grid.ownerLockable.getView();
                if (primaryView != lockableView) {
                    me.primaryViewLockableDetacher = lockableView.on(Ext.applyIf({
                        destroyable: true
                    }, me.getPrimaryViewLockableListeners()));
                }
            }
            me.dependencyStoreDetacher = dependencyStore.on(Ext.applyIf({
                destroyable: true
            }, me.getDependencyStoreListeners()));
        }
        me.renderAllDependencies().then(null, Ext.emptyFn);
    },
    stopDrawDependencies: function() {
        var me = this;
        me.destroyRenderingStrategy();
        me.destroyDetachers();
        me.destroyDependencyCanvas();
    },
    createRenderingStrategy: function() {
        var me = this;
        return Sch.view.dependency.renderingstrategy.Combined.create({
            depsPerStep: me.getAsyncRenderingDepsPerStep()
        });
    },
    maybeSwitchRenderingStrategy: function() {
        var me = this;
        if (me.getDependencyStore().getCount() <= me.getBulkRenderingDependencyLimit()) {
            me.renderingStrategy.setMode('bulk');
        } else {
            me.renderingStrategy.setMode('async');
        }
    },
    updatePrimaryView: function(newView, oldView) {
        var me = this;
        if (oldView) {
            me.stopDrawDependencies();
        }
        if (newView) {
            if (!me.getDependencyStore() && newView.getEventStore()) {
                me.setDependencyStore(newView.getEventStore().getDependencyStore());
            }
            if (me.canDrawDependencies()) {
                me.startDrawDependencies();
            }
        }
    },
    applyDependencyStore: function(store) {
        return store && Ext.StoreMgr.lookup(store);
    },
    updateDependencyStore: function(newStore, oldStore) {
        var me = this;
        if (oldStore) {
            me.stopDrawDependencies();
        }
        if (newStore && me.canDrawDependencies()) {
            me.startDrawDependencies();
        }
    },
    updateDrawDependencies: function(newValue, oldValue) {
        var me = this;
        if (newValue && me.canDrawDependencies(true)) {
            me.startDrawDependencies();
        } else if (!newValue) {
            me.stopDrawDependencies();
        }
    },
    applyPainterConfig: function(config) {
        // Do not share single config instance among several dependency canvas instances
        return Ext.isObject(config) ? Ext.apply({}, config) : config;
    },
    updatePainterConfig: function(config) {
        var me = this;
        if (me.painter) {
            if (config) {
                config = Ext.apply({}, {
                    rtl: me.getPrimaryView().rtl
                }, config);
            }
            // In this case we are to re-create painter instance since painter type is changed
            if (config && 'type' in config && config.type !== me.painter.type) {
                Ext.destroy(me.painter);
                me.painter = me.createPainter(config);
            } else // In this case we just update current painter configuration
            {
                me.painter.setConfig(config);
            }
            // New config might provide as with new canvas specification, thus the current one should be
            // destroyed if any
            me.destroyDependencyCanvas();
            if (me.canDrawDependencies()) {
                me.renderAllDependencies().then(null, Ext.emptyFn);
            }
        }
    },
    updateCanvasLayer: function(layer) {
        var me = this;
        me.destroyDependencyCanvas();
        if (me.canDrawDependencies()) {
            me.renderAllDependencies().then(null, Ext.emptyFn);
        }
    },
    /**
     * Gets scheduling view listeners object
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewListeners: function() {
        var me = this;
        return {
            'itemadd': me.onPrimaryViewItemAdd,
            'itemremove': me.onPrimaryViewItemRemove,
            'itemupdate': me.onPrimaryViewItemUpdate,
            'refresh': me.onPrimaryViewRefresh,
            'bufferedrefresh': me.onPrimaryViewRefresh,
            // Row expander plugin events
            'expandbody': me.onPrimaryViewExpandBody,
            'collapsebody': me.onPrimaryViewCollapseBody,
            // Bryntum custom events
            'eventrepaint': me.onPrimaryViewEventRepaint,
            'baseline-show': me.onPrimaryViewRefresh,
            'baseline-hide': me.onPrimaryViewRefresh,
            scope: me
        };
    },
    /**
     * If scheduling view is part of the lockable grid then gets top level lockable view listeners object
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewLockableListeners: function() {
        var me = this;
        return {
            // Row expander plugin events
            'expandbody': me.onPrimaryViewExpandBody,
            'collapsebody': me.onPrimaryViewCollapseBody,
            scope: me
        };
    },
    /**
     * Get's primary view element listeners
     *
     * @return {Object}
     * @protected
     */
    getPrimaryViewElListeners: function() {
        var me = this;
        return {
            'dblclick': me.onPrimaryViewDependencyElPointerEvent,
            'click': me.onPrimaryViewDependencyElPointerEvent,
            'contextmenu': me.onPrimaryViewDependencyElPointerEvent,
            'mouseover': me.onPrimaryViewDependencyElPointerEvent,
            'mouseout': me.onPrimaryViewDependencyElPointerEvent,
            delegate: '.sch-dependency',
            scope: me
        };
    },
    /**
     * Gets dependency store listeners
     *
     * @return {Object}
     * @protected
     */
    getDependencyStoreListeners: function() {
        var me = this;
        return {
            'add': me.onDependencyStoreAdd,
            'remove': me.onDependencyStoreRemove,
            'update': me.onDependencyStoreUpdate,
            'refresh': me.onDependencyStoreRefresh,
            'clear': me.onDependencyStoreClear,
            scope: me
        };
    },
    /**
     * Creates painter class instance
     *
     * @param {Object} config Painter config
     * @return {Sch.view.dependency.Painter}
     * @protected
     */
    createPainter: function(config) {
        return Sch.view.dependency.Painter.create(config);
    },
    /**
     * Returns currently active painter
     *
     * @return {Sch.view.dependency.Painter}
     */
    getPainter: function() {
        return this.painter;
    },
    /**
     * Clones currently using dependency painter
     *
     * @return {Sch.view.dependency.Painter/Null}
     * @public
     */
    clonePainter: function() {
        var me = this;
        return me.painter && me.painter.clone() || null;
    },
    /**
     * Creates drag zone class instance
     *
     * @param {Object} [config]
     * @return {Sch.view.dependency.DragZone}
     */
    createDragZone: function(config) {
        return Sch.view.dependency.DragZone.create(config);
    },
    /**
     * Checks if dependency canvas is available for drawing
     *
     * @return {Boolean}
     * @protected
     */
    isDependencyCanvasAvailable: function() {
        var primaryView = this.getPrimaryView();
        return primaryView && primaryView.isItemCanvasAvailable();
    },
    /**
     * Checks if dependency canvas is present in the DOM
     *
     * @return {Boolean}
     *
     * @protected
     */
    isDependencyCanvasPresent: function() {
        var me = this,
            primaryView = me.getPrimaryView();
        return primaryView && primaryView.isItemCanvasPresent(me.getCanvasLayer());
    },
    /**
     * Returns dependency canvas element
     *
     * @return {Ext.dom.Element}
     * @protected
     */
    getDependencyCanvas: function() {
        var me = this;
        return me.getPrimaryView().getItemCanvasEl(me.getCanvasLayer(), me.painter.getCanvasSpecification());
    },
    /**
     * Renders all the dependencies for the current view
     */
    renderAllDependencies: function() {
        var me = this,
            promise;
        if (me.canDrawDependencies() && (me.refreshing || me.fireEvent('beforerefresh', me) !== false)) {
            me.refreshing || me.renderingStrategy.on('rendering-complete', function(strategy, rendered) {
                me.refreshing = false;
                me.fireEvent('refresh', me);
            }, null, {
                single: true
            });
            me.refreshing = true;
            promise = me.renderingStrategy.updateDependencies(me);
        } else {
            promise = Ext.Promise.reject(me.getDependencyStore().getRange());
        }
        return promise;
    },
    /**
     * Renders dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     * @param {Boolean} [overwrite=false]
     */
    renderDependencies: function(dependencyRecords, overwrite) {
        var me = this,
            promise;
        if (!Ext.isArray(dependencyRecords)) {
            dependencyRecords = [
                dependencyRecords
            ];
        }
        if (me.canDrawDependencies()) {
            if (overwrite) {
                promise = me.renderingStrategy.clearDependencies(me).then(function() {
                    return !me.renderingStrategy.destroyed ? me.renderingStrategy.renderDependencies(me, dependencyRecords) : dependencyRecords;
                });
            } else {
                promise = me.renderingStrategy.renderDependencies(me, dependencyRecords);
            }
        } else {
            promise = Ext.Promise.reject(dependencyRecords);
        }
        return promise;
    },
    /**
     * Re-renders dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     */
    updateDependencies: function(dependencyRecords) {
        var me = this,
            promise;
        if (!Ext.isArray(dependencyRecords)) {
            dependencyRecords = [
                dependencyRecords
            ];
        }
        if (me.canDrawDependencies()) {
            promise = me.renderingStrategy.updateDependencies(me, dependencyRecords);
        } else {
            promise = Ext.Promise.reject(dependencyRecords);
        }
        return promise;
    },
    /**
     * Clears dependencies for given dependency records
     *
     * @param {Sch.model.Dependency|Sch.model.Dependency[]} dependencyRecords
     */
    clearDependencies: function(dependencyRecords) {
        var me = this,
            promise;
        if (!Ext.isArray(dependencyRecords)) {
            dependencyRecords = [
                dependencyRecords
            ];
        }
        if (me.canDrawDependencies()) {
            promise = me.renderingStrategy.clearDependencies(me, dependencyRecords);
        } else {
            promise = Ext.Promise.reject(dependencyRecords);
        }
        return promise;
    },
    /**
     * Removes all drawn dependencies elements from the canvas
     */
    clearAllDependencies: function() {
        var me = this,
            promise;
        if (me.canDrawDependencies()) {
            promise = me.renderingStrategy.clearDependencies(me);
        } else {
            promise = Ext.Promise.reject();
        }
        return promise;
    },
    /**
     * Returns dependency record corresponding to the given element
     * @param {HTMLElement/Ext.dom.Element/String} el
     * @return {Sch.model.Dependency/Null}
     * @protected
     */
    getDependencyForElement: function(el) {
        var me = this,
            depStore = me.getDependencyStore(),
            dependency = null,
            depInternalId;
        if (depStore) {
            depInternalId = me.painter.getElementDependencyInternalId(el);
            dependency = depStore.getByInternalId(depInternalId);
        }
        return dependency;
    },
    /**
     * Highlight the elements representing a dependency
     *
     * @param {Sch.model.Dependency/Mixed} record Either the id of a record or a record in the dependency store
     * @param {String} [cls] The CSS class to use for highlighting. Defaults to the selected-state CSS class.
     */
    highlightDependency: function(record, cls) {
        var me = this;
        if (!(record && record.isModel)) {
            record = me.getDependencyStore().getById(record);
        }
        record && record.highlight(cls || me.getSelectedCls());
    },
    /**
     * Remove highlight of the elements representing a particular dependency
     *
     * @param {Sch.model.Dependency/Mixed} record Either the id of a record or a record in the dependency store
     * @param {String} [cls] The CSS class to use for highlighting. Defaults to the selected-state CSS class.
     */
    unhighlightDependency: function(record, cls) {
        var me = this;
        if (!(record && record.isModel)) {
            record = me.getDependencyStore().getById(record);
        }
        record && record.unhighlight(cls || me.getSelectedCls());
    },
    /**
     * Gets all dependency records highlighted with the CSS class given
     * @param {String} [cls]
     * @return {Sch.model.Dependency[]}
     */
    getHighlightedDependencies: function(cls) {
        var me = this,
            store = me.getDependencyStore();
        return store && store.getHighlightedDependencies(cls || me.getSelectedCls()) || [];
    },
    onPrimaryViewItemAdd: function(records, index, node, view) {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewItemUpdate: function(eventRecord, index, node, view) {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewItemRemove: function(records, index, node, view) {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewRefresh: function(view) {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewExpandBody: function() {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewCollapseBody: function() {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewEventRepaint: function() {
        this.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onPrimaryViewDependencyElPointerEvent: function(event, elDom, options) {
        var me = this,
            dependencyId = me.painter.getElementDependencyInternalId(elDom),
            dependency = me.getDependencyStore().getByInternalId(dependencyId);
        if (dependency) {
            me.fireEvent('dependency' + event.type, me, dependency, event, elDom);
            var overCls = this.getOverCls(),
                els = me.painter.getElementsForDependency(me.getDependencyCanvas(), dependency);
            if (overCls && event.type === 'mouseover') {
                els.addCls(overCls);
            } else if (overCls && event.type === 'mouseout') {
                els.removeCls(overCls);
            }
        }
    },
    onDependencyStoreAdd: function(store, dependencies) {
        var me = this;
        me.maybeSwitchRenderingStrategy();
        me.renderDependencies(dependencies).then(null, Ext.emptyFn);
    },
    onDependencyStoreRemove: function(store, dependencies) {
        var me = this;
        me.maybeSwitchRenderingStrategy();
        me.clearDependencies(dependencies).then(null, Ext.emptyFn);
    },
    onDependencyStoreUpdate: function(store, dependency) {
        this.updateDependencies(dependency).then(null, Ext.emptyFn);
    },
    onDependencyStoreRefresh: function(store) {
        var me = this;
        me.maybeSwitchRenderingStrategy();
        me.renderAllDependencies().then(null, Ext.emptyFn);
    },
    onDependencyStoreClear: function(store) {
        var me = this;
        me.maybeSwitchRenderingStrategy();
        me.renderAllDependencies().then(null, Ext.emptyFn);
    },
    /* DRAG DROP LISTENERS */
    onDragStart: function() {
        var me = this,
            primaryView = me.getPrimaryView();
        // Disable drag creator, tooltips etc
        primaryView.onDragDropStart && primaryView.onDragDropStart();
        me.tip && me.tip.disable();
        me.getPrimaryView().getEl().addCls('sch-terminals-visible');
    },
    onDependencyDrop: function(dropZone, newDependency, valid) {
        valid && this.getDependencyStore().add(newDependency);
    },
    onDependencyAfterDrop: function() {
        var primaryView = this.getPrimaryView();
        if (!primaryView.destroyed) {
            primaryView.onDragDropEnd && primaryView.onDragDropEnd();
            primaryView.getEl().removeCls('sch-terminals-visible');
            primaryView.getEl().select('.sch-terminal-hidden').removeCls('sch-terminal-hidden');
            this.tip && this.tip.enable();
        }
    }
});
/* EOF DRAG DROP LISTENERS */
/**
     * @event refresh
     *
     * Fires after the view has fully rendered all the dependencies in the underlying store.
     *
     * @param {Sch.view.Dependency} view The dependency view instance
     */
/**
     * @event dependencyclick
     *
     * Fires after clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencycontextmenu
     *
     * Fires after right clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencydblclick
     *
     * Fires after double clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencymouseover
     *
     * Fires when hovering over a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */
/**
     * @event dependencymouseout
     *
     * Fires when leaving a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */

// @tag dependencies
/**
 * This mixin is a helper for Scheduler grid/tree panels. It adds Dependency view instance management methods to
 * those panels.
 */
Ext.define('Sch.view.dependency.Mixin', {
    extend: 'Ext.Mixin',
    requires: [
        'Sch.view.dependency.View'
    ],
    mixinConfig: {
        after: {
            initComponent: 'initComponent',
            destroy: 'destroy'
        }
    },
    /**
     * @cfg {Object} dependencyViewConfig
     *
     * Dependency view config. Use `type` property to create different type of dependency views.
     */
    dependencyViewConfig: null,
    // Private, dependency view instance
    dependencyView: null,
    // Private, dependency view relay detacher
    dependencyViewRelayDetacher: null,
    // Private, dependency drag events relay detacher
    dependencyDragRelayDetacher: null,
    initComponent: function() {
        var me = this;
        // Locked grid relays this event from normal grid which is the grid showing scheduler events, i.e. the one
        // which has scheduling view
        me.on('viewready', function() {
            if (me.getEventStore()) {
                me.setupDependencyView(me.getDependencyViewConfig(), me.getSchedulingView());
            }
        });
    },
    /**
     * Gets current dependency view config
     *
     * @return {Object|Null}
     */
    getDependencyViewConfig: function() {
        return this.dependencyViewConfig;
    },
    /**
     * Sets current dependency view config.
     *
     * If dependency view is already created and config has different view `type` set then the view
     * might be destroyed and re-created as the side-effect of this method call.
     *
     * @param {Object} config
     */
    setDependencyViewConfig: function(config) {
        var me = this;
        if (me.dependencyViewConfig !== config) {
            me.dependencyViewConfig = config;
            if (me.dependencyView) {
                // In this case we are to re-create painter instance since painter type is changed
                if (config && 'type' in config && config.type !== me.dependencyView.type) {
                    me.setupDependencyView(config, me.getSchedulingView());
                } else // In this case we just update current painter configuration
                {
                    me.dependencyView.setConfig(config);
                }
            }
        }
    },
    /**
     * Checks if a component has a dependency view created.
     *
     * @return {Boolean}
     */
    hasDependencyView: function() {
        return !!this.dependencyView;
    },
    /**
     * Returns dependency view instance.
     *
     * @return {Sch.view.Dependency}
     */
    getDependencyView: function() {
        return this.dependencyView;
    },
    /**
     * Create dependency view instance.
     *
     * @protected
     */
    createDependencyView: function(config, primaryView) {
        return Sch.view.dependency.View.create(Ext.applyIf({
            primaryView: primaryView
        }, config));
    },
    /**
     * Destroys dependency view instance. The method is called after component's `destroy` method.
     *
     * @protected
     */
    destroy: function() {
        Ext.destroyMembers(this, 'dependencyViewRelayDetacher', 'dependencyDragRelayDetacher', 'dependencyView');
    },
    /**
     * Creates, stores and setups dependency view
     *
     * @protected
     */
    setupDependencyView: function(config, primaryView) {
        var me = this;
        Ext.destroy(me.dependencyView);
        me.dependencyView = me.createDependencyView(config, primaryView);
        me.setupDependencyViewRelay();
        me.fireEvent('dependencyviewready', me, me.dependencyView);
        if (me.dependencyView.canDrawDependencies()) {
            me.dependencyView.renderAllDependencies().then(null, Ext.emptyFn);
        }
    },
    /**
     * Setups dependency view events relaying
     *
     * @protected
     */
    setupDependencyViewRelay: function() {
        var me = this;
        Ext.destroy(me.dependencyViewRelayDetacher, me.dependencyDragRelayDetacher);
        me.dependencyViewRelayDetacher = me.relayEvents(me.getDependencyView(), [
            'dependencyclick',
            'dependencydblclick',
            'dependencycontextmenu',
            'dependencymouseover',
            'dependencymouseout'
        ]);
        me.dependencyDragRelayDetacher = me.relayEvents(me.getDependencyView(), [
            'beforedrag',
            'dragstart',
            'drop',
            'afterdrop'
        ], 'dependency');
    }
});
/**
     * @event dependencyviewready
     *
     * Fires after dependency view creation
     *
     * @param {Ext.Component} A component instance this mixin is mixed into
     * @param {Sch.view.Dependency} Dependency view instance
     */
/**
     * @event dependencyclick
     *
     * Fires after clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencycontextmenu
     *
     * Fires after right clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencydblclick
     *
     * Fires after double clicking on a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The clicked DOM element
     */
/**
     * @event dependencymouseover
     *
     * Fires when hovering over a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */
/**
     * @event dependencymouseout
     *
     * Fires when leaving a dependency line/arrow
     *
     * @param {Sch.view.dependency.View} view The dependency view instance
     * @param {Sch.model.Dependency} record The dependency record
     * @param {Ext.event.Event} event The event object
     * @param {HTMLElement} target The target DOM element
     */
/**
     * @event dependencybeforedrag
     * @preventable
     *
     * Fires when a create-dependency flow is about to start. Return false from a listener function to prevent the action.
     *
     * @param {Sch.view.dependency.DragZone} event The event object
     * @param {Sch.model.Event} eventRecord The source event record
     */
/**
     * @event dependencydragstart
     *
     * Fires when a dependency drag operation starts
     *
     * @param {Sch.view.dependency.DragZone} dragZone The dragzone object
     */
/**
     * @event dependencydrop
     *
     * Fires when a dependency drag drop operation has completed successfully and a new dependency has been created.
     *
     * @param {Sch.view.dependency.DropZone} event The event object
     * @param {Sch.model.Dependency} newDependency A dependency model representing the newly created link
     * @param {Boolean} valid true if the drop is deemed valid (as determined by the {@link Sch.data.DependencyStore#
     */
/**
     * @event dependencyafterdrop
     *
     * Always fires after a dependency drag-drop operation.
     *
     * @param {Sch.view.dependency.DropZone} dropZone The DropZone
     */

/**

@class Sch.panel.SchedulerGrid
@extends Sch.panel.TimelineGridPanel
@mixins Sch.mixin.SchedulerPanel

@alternateClassName Sch.SchedulerPanel

A scheduler panel based on the {@link Ext.grid.Panel} class which allows you to visualize and manage "resources" and their scheduled "events".

Please refer to the <a href="#!/guide/scheduler_getting_started">getting started guide</a> for a detailed introduction.

{@img scheduler/images/ext-scheduler.png}

*/
Ext.define("Sch.panel.SchedulerGrid", {
    extend: "Sch.panel.TimelineGridPanel",
    mixins: [
        'Sch.mixin.SchedulerPanel',
        /* @cut-if-calendar-> */
        'Sch.view.dependency.Mixin'
    ],
    /* <-@ */
    alias: [
        'widget.schedulergrid',
        'widget.schedulerpanel'
    ],
    alternateClassName: 'Sch.SchedulerPanel',
    viewType: 'schedulergridview',
    isSchedulerGrid: true,
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }
}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});

/**
 * @class Sch.view.AllDayMode
 * @private
 *
 * A special view mode class used by All Day header scheduler in week/agenda views
 */
Ext.define('Sch.view.AllDayMode', {
    extend: 'Sch.view.Horizontal',
    // All events in All Day scheduler are assigned to one and only synthetic view so no arguments are needed,
    // all we need to do is to collect all currently visible all day events
    getScheduledEventsForResource: function() {
        var view = this.view,
            result = [];
        view.getEventStore().each(function(event) {
            if (event.getAllDay() && event.isScheduled() && view.timeAxis.isRangeInAxis(event)) {
                result.push(event);
            }
        });
        return result;
    },
    onEventAdd: function() {
        this.view.refreshView();
    },
    onEventUpdate: function() {
        this.view.refreshView();
    },
    onEventRemove: function() {
        this.view.refreshView();
    }
});

/**
 * @class Sch.view.AllDayMode
 * @private
 *
 * A special view class for all day scheduler header in week/agenda views
 */
Ext.define('Sch.view.AllDay', {
    extend: 'Sch.view.SchedulerGridView',
    requires: [
        'Sch.view.AllDayMode'
    ],
    allDay: true,
    eventAnimations: false,
    horizontalViewClass: 'Sch.view.AllDayMode',
    additionalEventCls: '',
    repaintEventsForResource: function() {
        this.refreshView();
    },
    generateTplData: function(event, resource, columnIndex) {
        var data, color;
        // We can't rely on resource passed as the parameter here.
        // The given resource will be always a synthetic resource created by AllDayHeader
        // So we are to reobtain the real resource from event here.
        // Since AllDay view is used in calendar only there should be no case when event
        // is assigned to multiple resources.
        // NOTE, the resource could be empty - in such case we fall back to using the dummy resource
        resource = event.getResource() || this.resourceStore.first();
        data = this.callParent([
            event,
            resource,
            columnIndex
        ]);
        data.isCalendarContext = true;
        data.internalCls += ' ' + this.additionalEventCls;
        if (resource) {
            if (Ext.isFunction(resource.getCls) && resource.getCls()) {
                data.internalCls += ' ' + resource.getCls();
            }
            if (Ext.isFunction(resource.getColor) && resource.getColor()) {
                data.style = (data.style || '') + ';background-color: ' + resource.getColor() + ';';
            }
        }
        return data;
    },
    // All day header uses fake Resource store. Sch.mixin.AbstractSchedulerView.setEventStore sets
    // this fake resource store to the Event store. However main Scheduler already set the correct
    // Resource store to the Event store. So this override is required to restore the correct
    // Resource store on the Event store.
    setEventStore: function(eventStore, initial) {
        eventStore = eventStore && Ext.StoreManager.lookup(eventStore);
        var me = this,
            oldStore = me.getEventStore(),
            // event store has already correct resource store
            resourceStore = eventStore && eventStore.getResourceStore();
        me.suspendEvents(false);
        me.callParent(arguments);
        me.resumeEvents();
        if (me.eventStore) {
            // restore resourceStore value
            me.eventStore.setResourceStore(resourceStore);
            if (!initial) {
                me.fireEvent('eventstorechange', me, me.eventStore, oldStore);
                me.refreshView();
            }
        }
    }
});

/**
 * @class Sch.panel.AllDayHeader
 * @extends Sch.panel.SchedulerGrid
 */
Ext.define("Sch.panel.AllDayHeader", {
    extend: "Sch.panel.SchedulerGrid",
    requires: [
        'Sch.view.AllDay'
    ],
    xtype: 'alldayheader',
    cls: 'sch-all-day-header',
    columns: [],
    weight: 1000,
    height: 24,
    rowHeight: 24,
    hideHeaders: true,
    reserveScrollbar: false,
    barMargin: 1,
    enableDragCreation: false,
    enablePinchZoom: false,
    // Should be provided via instance config object
    mainScheduler: null,
    // Filled in the constructor
    mainSchedulerView: null,
    mainSchedulerTimeAxis: null,
    storedColumnWidth: null,
    lastTimeTdHeight: 0,
    // snapToIncrement   : true,
    // fake resource store hardcoded to be able to show events in horizontal scheduler
    resourceStore: {
        type: 'resourcestore',
        data: [
            {
                Id: 1
            }
        ]
    },
    relayedConfigs: [
        'readOnly',
        'eventStore',
        'recurringEvents',
        'eventRenderer',
        'eventRendererScope',
        'onEventCreated',
        'tooltipTpl'
    ],
    normalViewConfig: null,
    createConfig: {
        showHoverTip: false,
        showDragTip: false
    },
    enableEventDragDrop: false,
    resizeConfig: {
        showTooltip: false
    },
    viewPreset: {
        name: 'dayAndWeek',
        timeColumnWidth: 25,
        timeResolution: {
            unit: 'd',
            increment: 1
        },
        headerConfig: {
            middle: {
                unit: 'd',
                align: 'center',
                dateFormat: 'G'
            }
        }
    },
    constructor: function(config) {
        var me = this,
            mainScheduler = config.mainScheduler;
        me.relayedConfigs.forEach(function(name) {
            config[name] = mainScheduler[name];
        });
        me.mainSchedulerTimeAxis = mainScheduler.timeAxis;
        me.mainSchedulerView = mainScheduler.getSchedulingView();
        me.resourceStore.model = mainScheduler.resourceStore.model;
        me.normalViewConfig = Ext.apply({
            xclass: 'Sch.view.AllDay',
            eventPrefix: me.mainSchedulerView.id,
            eventBodyTemplate: me.mainSchedulerView.eventBodyTemplate,
            additionalEventCls: me.mainSchedulerView.additionalEventCls || '',
            selectedEventCls: me.mainSchedulerView.selectedEventCls || ''
        }, config.normalViewConfig);
        me.callParent(arguments);
        var alldaySchedulingView = me.getSchedulingView();
        me.mon(me.mainSchedulerTimeAxis, {
            reconfigure: me.onMainTimeAxisReconfigure,
            scope: me
        });
        alldaySchedulingView.on({
            refresh: me.onSchedulingViewUpdate,
            itemupdate: me.onSchedulingViewUpdate,
            scope: me
        });
        me.syncTimeAxisSpan();
        me.syncScroll();
        me.fixEventSelection();
        me.mainSchedulerView.relayEvents(me.getSchedulingView(), me.relayedViewEvents.concat([
            'scheduleclick',
            'scheduledblclick',
            'schedulecontextmenu',
            'schedulelongpress'
        ]));
        // HACK: but otherwise there's no way to make vertical scheduler column lines to have horizontally
        //       synchronized positions with the horizontal scheduler column lines
        me.oldHeaderCtLayout = mainScheduler.normalGrid.headerCt.layout.roundFlex;
        mainScheduler.normalGrid.headerCt.layout.roundFlex = Ext.Function.bind(me.roundFlex, me);
        mainScheduler.normalGrid.on('afterlayout', me.onContainerGridAfterLayout, me);
    },
    // END HACK
    roundFlex: function(flex) {
        var me = this;
        if (!me.storedColumnWidth) {
            me.storedColumnWidth = Math.floor(flex);
        }
        return me.storedColumnWidth;
    },
    resetStoredColumnWidth: function() {
        delete this.storedColumnWidth;
    },
    onContainerGridAfterLayout: function(p) {
        if (this.storedColumnWidth) {
            if (this.timeAxisViewModel.getTickWidth() !== this.storedColumnWidth) {
                this.timeAxisViewModel.suppressFit = true;
                this.timeAxisViewModel.setTickWidth(this.storedColumnWidth);
            }
        } else {
            if (this.timeAxisViewModel.getTickWidth() !== this.mainScheduler.timeAxisViewModel.weekViewColumnWidth) {
                this.timeAxisViewModel.setTickWidth(this.mainScheduler.timeAxisViewModel.weekViewColumnWidth);
            }
        }
        this.resetStoredColumnWidth();
    },
    onMainTimeAxisReconfigure: function() {
        this.syncTimeAxisSpan();
    },
    syncTimeAxisSpan: function() {
        var me = this;
        me.setTimeSpan(me.mainSchedulerTimeAxis.getStart(), me.mainSchedulerTimeAxis.getEnd());
    },
    onResize: function(w, h) {
        var me = this;
        me.callParent(arguments);
        me.syncLockedHeaderComponent();
        return me;
    },
    syncLockedHeaderComponent: function() {
        this.lockedHeaderPartner.setHeight(this.getHeight());
    },
    getDesiredComponentHeight: function() {
        return this.el.down('.sch-timetd').getHeight();
    },
    onSchedulingViewUpdate: function() {
        var me = this,
            fullHeight = me.getDesiredComponentHeight();
        // If view is updated due to event D&D then there's the case we have to consider.
        // During D&D operation calendar view scrollbar is hidden, and if we set height
        // to all day header here instantly then we will run re-layout process when
        // D&D feature hasn't restored the scrollbar yet. This will lead to the situation
        // when calendar view columns will be re-layout without getting scrollbar place into account
        // and they will be wider then all day header time axis columns. So to avoid this
        // we need calendar view scrollbar to be restored and thus we set height on all day header
        // with a delay.
        //
        // https://app.assembla.com/spaces/bryntum/tickets/6588-allday-header-columns-disalign-after-event-drop-from-normal-view-onto-event-/details
        if (fullHeight !== me.lastTimeTdHeight) {
            me.lastTimeTdHeight = fullHeight;
            Ext.asap(function() {
                if (!me.destroyed) {
                    me.setHeight(fullHeight);
                }
            });
        }
    },
    onDestroy: function() {
        // Restore hacked override
        this.mainScheduler.normalGrid.headerCt.layout.roundFlex = this.oldHeaderCtLayout;
        this.callParent();
    },
    syncScroll: function() {
        this.getView().normalView.getScrollable().addPartner(this.mainScheduler.getView().normalView.getScrollable(), 'x');
    },
    fixEventSelection: function() {
        var me = this,
            otherView = me.mainSchedulerView;
        // When mouse is down on event in main view, clear selection in all day header
        otherView.on({
            eventmousedown: me.clearPartnerSelection,
            scope: me
        });
        // When mouse is down on schedule zone in all day header, clear selection in main view
        me.on({
            scheduleclick: me.clearSelection,
            schedulecontextmenu: me.clearSelection,
            schedulelongpress: me.clearSelection,
            scope: me
        });
    },
    clearPartnerSelection: function(view, record, e) {
        var me = this,
            sel = me.getEventSelectionModel(),
            mode = sel.getSelectionMode(),
            // Single mode (default) allows selecting one item at a time, so need to deselect other events
            // Multi mode allows complex selection of multiple items using Ctrl, so need to deselect other events only if ctrl key is not pressed
            // Simple mode allows simple selection of multiple items one-by-one, so no need to deselect other events
            needDeselect = mode === 'SINGLE' || (mode === 'MULTI' && !e.ctrlKey);
        // Need to check the event comes from main scheduler view,
        // because all day header eventclick is relayed to the main scheduler
        // and needDeselect flag is needed to fix #6753
        if (view === me.mainSchedulerView && needDeselect) {
            sel.deselectAll();
        }
    },
    clearSelection: function() {
        this.mainScheduler.getEventSelectionModel().deselectAll();
    }
});

/**

 @class Sch.panel.TimelineTreePanel
 @extends Ext.tree.Panel
 @mixins Sch.mixin.TimelinePanel

 Internal class.

 */
Ext.define("Sch.panel.TimelineTreePanel", {
    extend: "Ext.tree.Panel",
    requires: [
        // need to require grid panel too here, because one of the sub-grids will be a normal grid
        'Ext.grid.Panel',
        'Ext.data.TreeStore',
        // will be used in the `setupLockableTree` of lockable mixin
        'Sch.mixin.FilterableTreeView'
    ],
    mixins: [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],
    alias: [
        'widget.timelinetree'
    ],
    useArrows: true,
    rootVisible: false,
    lockedXType: 'treepanel',
    isTimelineTreePanel: true,
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});

/**

@class Sch.panel.SchedulerTree
@extends Sch.panel.TimelineTreePanel
@mixins Sch.mixin.SchedulerPanel

A complete scheduler panel using a tree view. This class can be used when you have a lot of resources organized in a hierarchical structure.

{@img scheduler/images/scheduler-tree.png}

Please refer to the {@link Sch.panel.SchedulerGrid} for additional documentation, as these classes
are virtually identical. This document will only provide the tree-specific details.

In the scheduler tree case:

- the `resourceStore` is expected to be an instance of the {@link Sch.data.ResourceTreeStore}.
- the scheduler tree does not support vertical orientation.
- in your columns definition, you must include a column which will contain the tree itself (the `treecolumn` xtype):

        var schedulerTree = Ext.create('Sch.panel.SchedulerTree', {
            columns: [
                {
                    xtype       : 'treecolumn',

                    text        : 'Name',
                    width       : 200,
                    sortable    : true,
                    dataIndex   : 'Name'
                }
            ]
        });


*/
Ext.define("Sch.panel.SchedulerTree", {
    extend: "Sch.panel.TimelineTreePanel",
    mixins: [
        'Sch.mixin.SchedulerPanel',
        /* @cut-if-calendar-> */
        'Sch.view.dependency.Mixin'
    ],
    /* <-@ */
    alias: [
        'widget.schedulertree'
    ],
    viewType: 'schedulergridview',
    isSchedulerTree: true,
    setMode: function(mode) {
        if (mode !== 'horizontal') {
            Ext.Error.raise("Sch.panel.SchedulerTree only support horizontal mode");
        }
    },
    initComponent: function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }
}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});

// https://www.bryntum.com/forum/viewtopic.php?f=39&t=9258
// toggling collapse/expand of a tree parent node scrolls view to the top
Ext.define('Sch.patches.BufferedRenderer', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.BufferedRenderer',
    overrides: {
        refreshView: function() {
            var view = this.view,
                otherView = view.lockingPartner;
            // If the other view has refreshed first, use the same startIndex as that.
            if (!arguments.length && otherView && otherView.refreshCounter > view.refreshCounter) {
                this.callParent([
                    otherView.all.startIndex
                ]);
            } else {
                this.callParent(arguments);
            }
        },
        setBodyTop: function(bodyTop, skipStretchView) {
            var view = this.view,
                rows = view.all;
            if (!view.rendered)  {
                return;
            }
            
            var spacerXY = this.grid.ownerCt && this.grid.ownerCt.scrollable && this.grid.ownerCt.scrollable.getSpacerXY();
            // BufferedRenderer#setBodyTop needs to do this.
            // Being at the end of the dataset means we MUST stretch the
            // scroll range. Otherwise we can't get to the end.
            if (rows.endIndex === view.store.getCount() - 1) {
                skipStretchView = false;
            }
            // Also, if we're *not* at the end of the dataset, but the set scrollHeight
            // is less than the real scrollHeight, we need to set the scroll range
            else if (spacerXY && spacerXY.y <= this.scrollHeight - 1) {
                skipStretchView = false;
            }
            var returnValue = this.callParent(arguments);
            view.fireEvent('bufferedrefresh', this);
            return returnValue;
        },
        getScrollHeight: function() {
            var me = this,
                view = me.view,
                rows = view.all,
                store = me.store,
                recCount = store.getCount(),
                rowCount = rows.getCount(),
                row, rowHeight, borderWidth, scrollHeight;
            if (!recCount) {
                return 0;
            }
            if (!me.hasOwnProperty('rowHeight')) {
                if (rowCount) {
                    if (me.variableRowHeight) {
                        me.rowHeight = Math.floor(me.bodyHeight / rowCount);
                    } else {
                        row = rows.first();
                        rowHeight = row.getHeight();
                        // In IE8 we're adding bottom border on all the rows to work around
                        // the lack of :last-child selector, and we compensate that by setting
                        // a negative top margin that equals the border width, so that top and
                        // bottom borders overlap on adjacent rows. Negative margin does not
                        // affect the row's reported height though so we have to compensate
                        // for that effectively invisible additional border width here.
                        if (Ext.isIE8) {
                            borderWidth = row.getBorderWidth('b');
                            if (borderWidth > 0) {
                                rowHeight -= borderWidth;
                            }
                        }
                        me.rowHeight = rowHeight;
                    }
                } else {
                    delete me.rowHeight;
                }
            }
            if (me.variableRowHeight) {
                // If this is the last page, ensure the scroll range is exactly enough
                // to scroll to the end of the rendered block.
                if (rows.endIndex === recCount - 1) {
                    scrollHeight = me.bodyTop + me.bodyHeight - 1;
                } else // Calculate the scroll range based upon measured row height and our scrollPosition.
                {
                    scrollHeight = Math.floor((recCount - rowCount) * me.rowHeight) + me.bodyHeight;
                    // If there's a discrepancy between the body position we have scrolled to,
                    // and the calculated position, account for that in the scroll range
                    // so that we have enough range to scroll all the data into view.
                    //
                    //
                    // THE FIX: must only increment the height, not decrement it
                    scrollHeight += Math.max(me.bodyTop - rows.startIndex * me.rowHeight, 0);
                }
            } else {
                scrollHeight = Math.floor(recCount * me.rowHeight);
            }
            return (me.scrollHeight = scrollHeight);
        }
    }
});

// https://app.assembla.com/spaces/bryntum/tickets/9653-normal-and-locked-rows-get-desynced-when-resizing-scheduler-vertically
// When application is resized theres sa major layout reflow which first handles locked view and then normal. Both times
// Ext is adjusting scroll and updating rows. when Ext is setting view size for the buffered renderer plugin in the
// locked view, first it calls for partner to update its size, i.e. normal view:
// ```
// if (lockingPartner && !fromLockingPartner) {
//     lockingPartner.setViewSize(viewSize, true);
// }
// diff = elCount - viewSize;
// if (diff) {
//     me.scrollTop = me.scroller ? me.scroller.getPosition().y : 0; // Reading position would actually trigger scroll change
//     me.viewSize = viewSize;
// ...
// ```
// as marked in the snippet, after locking partner's view size is updated, we read the scroller position. Scroll got
// dirty after partner call, so Ext triggers scroll event which buffered renderer plugin reacts to and renders new range
// of rows. BUT at this point view size of locked and normal buffered renderers is *different*. So when locked plugin
// wants to communicate with normal one it sends some incorrect data about where to scroll. Normal partner scrolls to
// negative record index which leads to wrong normal view scroll and empty space at the top.
// we can update view size *BEFORE* we read scroll position, but in that case scheduler will scroll to 0. This is done
// on purpose by ExtJS code. Standard ExtJS Grid is trying to preserve scroll position, but it walks a different code path.
// Layout flush in Scheduler works different and just doesn't go the part which is trying to restore the scroll. It
// could be caused by multiple layout suspensions we use in scheduler. There is no point trying to unsuspend them, instead
// we can just fix scroll position in the refresh method. At the same time that helps with original problem.
Ext.define('Sch.patches.BufferedRendererResize', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.BufferedRenderer',
    minVersion: '7.3.1',
    overrides: {
        doRefreshView: function() {
            var scroller = this.scroller;
            if (this.view.ownerGrid.is('timelinegrid,timelinetree') && scroller) {
                var position = this.position;
                var previousTop = this.scrollTop;
                this.callParent(arguments);
                // If scrollTop was changed doVerticalScroll was called. In which case we want to call it again but
                // with old scroll position.
                if (this.scrollTop !== previousTop) {
                    this.doVerticalScroll(scroller, position, true);
                }
            } else {
                this.callParent(arguments);
            }
        }
    }
});

// When changing orientation to vertical reconfigureBufferedRendering is invoked to update view size on plugins,
// which lead to infinite recursion in method getFirstVisibleRowIndex
// Reproducible in older IE11 (less than 11.576) in tests 002_column_width, 040_schedulergrid, 3101_viewsorters
Ext.define('Sch.patches.BufferedRenderer_6_2_1', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.plugin.BufferedRenderer',
    minVersion: '6.2.1',
    applyFn: function() {
        if (Ext.isIE11) {
            Ext.define(null, {
                override: 'Ext.grid.plugin.BufferedRenderer',
                getFirstVisibleRowIndex: function(startRow, endRow, viewportTop, viewportBottom) {
                    var me = this,
                        view = me.view,
                        rows = view.all,
                        elements = rows.elements,
                        clientHeight = me.viewClientHeight,
                        target, targetTop,
                        bodyTop = me.bodyTop;
                    // If variableRowHeight, we have to search for the first row who's bottom edge is within the viewport
                    if (rows.getCount() && me.variableRowHeight) {
                        if (!arguments.length) {
                            startRow = rows.startIndex;
                            endRow = rows.endIndex;
                            viewportTop = me.scrollTop;
                            viewportBottom = viewportTop + clientHeight;
                            // Teleported so that body is outside viewport: Use rowHeight calculation
                            if (bodyTop > viewportBottom || bodyTop + me.bodyHeight < viewportTop) {
                                me.teleported = true;
                                return Math.floor(me.scrollTop / me.rowHeight);
                            }
                            // In first, non-recursive call, begin targeting the most likely first row
                            target = startRow + Math.min(me.numFromEdge + ((me.lastScrollDirection === -1) ? me.leadingBufferZone : me.trailingBufferZone), Math.floor((endRow - startRow) / 2));
                        } else {
                            if (startRow === endRow) {
                                return endRow;
                            }
                            target = startRow + Math.floor((endRow - startRow) / 2);
                        }
                        var targetElement = elements[target];
                        targetTop = bodyTop + targetElement.offsetTop;
                        // If target is entirely above the viewport, chop downwards
                        // PATCH
                        // We add last condition to filter out cases when IE doesn't yet calculated offsetHeight.
                        // In fact, offsetHeight is 0 and clientHeight is properly calculated, which is obviously
                        // shouldn't be possible
                        if (targetTop + targetElement.offsetHeight <= viewportTop && targetElement.offsetHeight) {
                            return me.getFirstVisibleRowIndex(target + 1, endRow, viewportTop, viewportBottom);
                        }
                        // Target is first
                        if (targetTop <= viewportTop) {
                            return target;
                        }
                        // Not narrowed down to 1 yet; chop upwards
                        else if (target !== startRow) {
                            return me.getFirstVisibleRowIndex(startRow, target - 1, viewportTop, viewportBottom);
                        }
                    }
                    return Math.floor(me.scrollTop / me.rowHeight);
                }
            });
        }
    }
});

Ext.define('Sch.patches.CellContext', {
    extend: 'Sch.util.Patch',
    target: 'Ext.grid.CellContext',
    minVersion: '6.0.0',
    maxVersion: '6.6.0',
    applyFn: function() {
        var overrides = {
                setAll: function(view, recordIndex, columnIndex, record, columnHeader) {
                    var me = this;
                    // Since we patched navigation model, nothing is focused in normal view, which means, keyevents have
                    // unexpeted target. This will lead to a situation when we are trying to set position, passing column
                    // from normal view and it's position in locked view (which is -1). In this case we want to perform
                    // new lookup in correct view.
                    // covered in 1000_vertical
                    if (columnHeader && columnIndex == -1 && view !== me.view) {
                        view = me.view;
                        columnIndex = view.getVisibleColumnManager().indexOf(columnHeader);
                    }
                    return this.callParent(arguments);
                }
            };
        if (Ext.getVersion().isGreaterThanOrEqual('6.0.1')) {
            // Scheduler: test 313_single_time_axis_vertical
            // When we switch mode on scheduler grid with locked cell focused (e.g. if setMode is called in itemclick
            // listener) exception is raised. Sencha tries to save focus position and restore it later.
            // In order to optimize performance we suspend refresh before reconfigure. This leads to a situation when
            // view cannot get record and column from existing cell (because grid is already recofigured but view is not
            // yet refreshed) and passing null arguments to the "setPosition" method which doesn't accept it.
            //
            // Gantt: 223_spreadsheet.t.js?Ext=6.0.1
            // Gantt bulk operations suspend events on the taskStore which prevents the cell context of knowing that rows may have been removed
            // In these cases we set row index to 0;
            //
            // Also it's needed for Ext 6.5.3 since in Ext.grid.CellContext setRow/setColumn methods have
            // `if (row !== undefined) {` and `if (column !== undefined) {`
            // and in case row/column is `null` `null !== undefined` returns true and it gets failed few rows later.
            // That is fixed in 6.6.0 by using `!=` operator
            // Covered with tests/view/2119_cellcontext.t.js
            overrides.setPosition = function(row, col) {
                row = row || 0;
                col = col || 0;
                return this.callParent(arguments);
            };
        }
        Ext.override(Ext.grid.CellContext, overrides);
    }
});

// TODO Write test for this
// For now Calendar test tests/ui/calendar/misc.t.js is failed
Ext.define('Sch.patches.DateField', {
    extend: 'Sch.util.Patch',
    target: 'Ext.form.field.Date',
    minVersion: '6.0.2',
    maxVersion: '6.5.1.345',
    overrides: {
        // BRYNTUM: This function is called on Ext.picker.Date select
        onSelect: function(m, d) {
            var me = this;
            me.setValue(d);
            // BRYNTUM: commented
            // rawDate and rawDateText is set by setValue function
            // me.setValue will trigger 'change' event,
            // so if you set another value onChange, d variable will contain wrong value
            // and onBlur the value from me.rawDate will be set back to the field.
            // me.rawDate = d;
            // BRYNTUM: pass me.rawDate instead of d since me.rawDate contains actual value
            me.fireEvent('select', me, me.rawDate);
            // Focus the inputEl first and then collapse. We configure
            // the picker not to revert focus which is a normal thing to do
            // for floaters; in our case when the picker is focusable it will
            // lead to unexpected results on Tab key presses.
            // Note that this focusing might happen synchronously during Tab
            // key handling in the picker, which is the way we want it.
            me.onTabOut(m);
        }
    }
});

// https://www.sencha.com/forum/showthread.php?328470
Ext.define('Sch.patches.DragZone', {
    extend: 'Sch.util.Patch',
    target: 'Ext.dd.DragZone',
    minVersion: '6.2.0',
    overrides: {
        unreg: function() {
            try {
                this.callParent(arguments);
            } catch (e) {}
        }
    }
});

Ext.define('Sch.patches.DragZoneDupIds', {
    extend: 'Sch.util.Patch',
    target: 'Ext.dd.DragZone',
    minVersion: '6.0.2',
    reportUrl: 'https://www.sencha.com/forum/showthread.php?338467-DragZone-duplicates-DOM-ids-which-leads-to-error-if-one-Ext-get()s-duplicated-element',
    obsoleteTestName: 'patches/005_dragzone_dup_ids.t.js',
    description: [
        'Drag zone clones dragged element into drag status proxy without substituting cloned element id, thus we might',
        'hit the case when there are two or more elements with the same id in the DOM. If such original element has been',
        'accessed before via Ext.get(), i.e. it is cached in Ext.dom.Element cache, then accessing the similar element',
        'inside drag proxy with Ext.get() will lead to duplicate ids exception thrown from Ext.get()'
    ].join(' '),
    overrides: {
        onInitDrag: function(x, y) {
            var me = this,
                clone = me.dragData.ddel.cloneNode(true);
            // prevent duplicate ids
            clone.id = Ext.id();
            me.proxy.update(clone);
            me.onStartDrag(x, y);
            return true;
        }
    }
});

// https://www.sencha.com/forum/showthread.php?310237-Old-bug-with-negative-position
Ext.define('Sch.patches.Element', {
    extend: 'Sch.util.Patch',
    target: [
        'Ext.dom.Element'
    ],
    applyFn: function() {
        Ext.override(Ext.dom.Element, {
            // Default pxRe do not understand negative values of pixel offset.
            // This may lead to incorrect drag drop proxy position with RTL ext (covered by 012_dragdrop_rtl)
            // when view is crolled.
            pxRe: /^-?\d+(?:\.\d*)?px$/i,
            getLocalX: function() {
                var me = this,
                    offsetParent,
                    x = me.getStyle('left');
                if (!x || x === 'auto') {
                    x = 0;
                } else if (this.pxRe.test(x)) {
                    x = parseFloat(x);
                } else {
                    x = me.getX();
                    offsetParent = me.dom.offsetParent;
                    if (offsetParent) {
                        x -= Ext.fly(offsetParent).getX();
                    }
                }
                return x;
            }
        });
    }
});

Ext.define('Sch.patches.Element_6_5', {
    extend: 'Sch.util.Patch',
    target: [
        'Ext.dom.Element'
    ],
    minVersion: '6.5.0',
    applyFn: function() {
        if (Ext.isIE11p) {
            Ext.override(Ext.dom.Element, {
                // In case call made to this function when dom-element is detached from document, it will throw an error.
                // This results in failures in multiple tests when the celleditor us used
                // In our tests it looks like:
                // fail 2 - Test  threw an exception
                // Unspecified error. http://local/workspace/BUILDS/20378/Bryntum/extjs-6.5.1/build/ext-all-debug.js 17996
                // fail 3 - Layouts should not be suspended globally by accident
                // Failed assertion `is`
                // Got  : 1
                // Need : 0
                selectText: function() {
                    try {
                        this.callParent(arguments);
                    } catch (e) {}
                }
            });
        }
    }
});

// https://sencha.jira.com/browse/EXTJS-22621
// As of 6.2.0 Sencha does vertical scrolling on the scroller of the top grid panel
// so our view needs to relay 'scrollend' fired by the owner top grid until it's fixed by Sencha
Ext.define('Sch.patches.TablePanelScroll6.2', {
    extend: 'Sch.util.Patch',
    target: 'Ext.panel.Table',
    minVersion: '6.2.0',
    overrides: {
        afterRender: function() {
            this.callParent(arguments);
            if (this.lockedGrid) {
                this.lockedGrid.getView().relayEvents(this.getScrollable(), [
                    'scrollend'
                ]);
                this.normalGrid.getView().relayEvents(this.getScrollable(), [
                    'scrollend'
                ]);
            }
        }
    }
});

// Applying override from sencha, see related thread:
// https://www.sencha.com/forum/showthread.php?332597-Lockable-grid-normal-part-scrolls-horizontally-upon-locked-part-editor-activation
Ext.define('Sch.patches.TablePanel_6_2_1', {
    extend: 'Sch.util.Patch',
    target: 'Ext.panel.Table',
    minVersion: '6.2.1',
    overrides: {
        initComponent: function() {
            var me = this,
                headerScroller;
            me.callParent(arguments);
            // HeaderCt will get layed out, and that causes a scroll event which we do NOT
            // want propagating to partners.
            if (me.headerCt && (headerScroller = me.headerCt.getScrollable())) {
                headerScroller.suspendPartnerSync();
                // We start propagating to partners a little after the first data refresh.
                // MUST be a little after because there may be another grid involved
                // and layouts will resume after they *all* refresh, and we must not
                // do any syncing until after that process finishes.
                me.view.on({
                    refresh: function() {
                        headerScroller.resumePartnerSync();
                        // Force the HeaderCt into sync.
                        headerScroller.getElement().dom.scrollLeft = me.view.getScrollable().getElement().dom.scrollLeft;
                    },
                    single: true,
                    delay: 100
                });
            }
        },
        privates: {
            // The focusable flag is set, but there is no focusable element.
            // Focus is delegated to the view by the focus implementation.
            initFocusableElement: function() {},
            doEnsureVisible: function(record, options) {
                // Handle the case where this is a lockable assembly
                if (this.lockable) {
                    return this.ensureLockedVisible(record, options);
                }
                // Allow them to pass the record id.
                if (typeof record !== 'number' && !record.isEntity) {
                    record = this.store.getById(record);
                }
                var me = this,
                    view = me.getView(),
                    domNode = view.getNode(record),
                    isLocking = me.ownerGrid.lockable,
                    callback, scope, animate, highlight, select, doFocus, verticalScroller, horizontalScroller, column, cell;
                if (options) {
                    callback = options.callback;
                    scope = options.scope;
                    animate = options.animate;
                    highlight = options.highlight;
                    select = options.select;
                    doFocus = options.focus;
                    column = options.column;
                }
                // Always supercede any prior deferred request
                if (me.deferredEnsureVisible) {
                    me.deferredEnsureVisible.destroy();
                }
                // We have not yet run the layout.
                // Add this to the end of the first sizing process.
                // By using the resize event, we will come in AFTER any Component's onResize and onBoxReady handling.
                if (!view.componentLayoutCounter) {
                    me.deferredEnsureVisible = view.on({
                        resize: me.doEnsureVisible,
                        args: Ext.Array.slice(arguments),
                        scope: me,
                        single: true,
                        destroyable: true
                    });
                    return;
                }
                if (typeof column === 'number') {
                    column = me.ownerGrid.getVisibleColumnManager().getColumns()[column];
                }
                // We found the DOM node associated with the record
                if (domNode) {
                    verticalScroller = isLocking ? me.ownerGrid.getScrollable() : view.getScrollable();
                    if (verticalScroller) {
                        if (column) {
                            cell = Ext.fly(domNode).selectNode(column.getCellSelector());
                        }
                        // We're going to need two scrollers if we are locking, and we need to scroll horizontally.
                        // The whole arrangement of side by side views scrolls up and down.
                        // Each view itself scrolls horizontally.
                        if (isLocking && column) {
                            verticalScroller.scrollIntoView(domNode, false);
                            view.getScrollable().scrollIntoView(cell || domNode, true, animate, highlight);
                        } else // No locking, it's simple - we just use the view's scroller
                        {
                            verticalScroller.scrollIntoView(cell || domNode, !!column, animate, highlight);
                        }
                    }
                    if (!record.isEntity) {
                        record = view.getRecord(domNode);
                    }
                    if (select) {
                        view.getSelectionModel().select(record);
                    }
                    if (doFocus) {
                        view.getNavigationModel().setPosition(record, 0);
                    }
                    Ext.callback(callback, scope || me, [
                        true,
                        record,
                        domNode
                    ]);
                }
                // If we didn't find it, it's probably because of buffered rendering
                else if (view.bufferedRenderer) {
                    view.bufferedRenderer.scrollTo(record, {
                        animate: animate,
                        highlight: highlight,
                        select: select,
                        focus: doFocus,
                        column: column,
                        callback: function(recordIdx, record, domNode) {
                            Ext.callback(callback, scope || me, [
                                true,
                                record,
                                domNode
                            ]);
                        }
                    });
                } else {
                    Ext.callback(callback, scope || me, [
                        false,
                        null
                    ]);
                }
            }
        }
    }
});

// Broken buffered renderer, which incorrectly instructs its view to scroll vertically which it can't in locked grid scenario
// This patch routes the vertical scrolling to the owning topmost Grid/Tree
Ext.define('Sch.patches.TableView', {
    extend: 'Sch.util.Patch',
    target: 'Ext.view.Table',
    overrides: {
        scrollBy: function(xDelta, yDelta, anim) {
            if (this.lockingPartner) {
                this.callParent([
                    xDelta || null,
                    null,
                    anim
                ]);
                this.ownerCt.ownerCt.getScrollable().scrollBy(null, yDelta, anim);
            } else {
                this.callParent([
                    xDelta,
                    yDelta,
                    anim
                ]);
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?312033
Ext.define('Sch.patches.TimelineGridView', {
    extend: 'Sch.util.Patch',
    target: 'Sch.view.TimelineGridView',
    // In chrome 53 this also became a problem in 6.0.2
    // covered by 012_dragdrop_rtl
    minVersion: '6.0.1',
    overrides: {
        initComponent: function() {
            this.callParent(arguments);
            if (this.rtl) {
                this.headerCt.on('afterlayout', function(header) {
                    header.scrollTo(this.getScrollX());
                }, this);
            }
        }
    }
});

// https://sencha.jira.com/browse/EXTJS-22621
// As of 6.2.0 Sencha does vertical scrolling on the scroller of the top grid panel
// so our view needs to relay this scrolling to the owner top grid until it's fixed by Sencha
Ext.define('Sch.patches.TimelineGridViewScroll6_2', {
    extend: 'Sch.util.Patch',
    target: 'Sch.view.TimelineGridView',
    minVersion: '6.2.0',
    overrides: {
        scrollVerticallyTo: function(y, animate) {
            this.up('timelinegrid,timelinetree').getScrollable().scrollTo(null, y, animate);
        },
        getVerticalScroll: function() {
            var scrollable = this.up('timelinegrid,timelinetree').getScrollable();
            if (scrollable.getNormalScroller) {
                if (scrollable.getNormalScroller()) {
                    return scrollable.getPosition().y;
                } else {
                    return 0;
                }
            } else {
                return scrollable.getPosition().y;
            }
        }
    }
});

// https://www.sencha.com/forum/showthread.php?324999-Locked-grid-hides-normal-grid-header&p=1154992#post1154992
Ext.define('Sch.patches.TimelinePanel', {
    extend: 'Sch.util.Patch',
    target: 'Sch.mixin.TimelinePanel',
    minVersion: '6.2.0',
    applyFn: function() {
        Sch.panel.TimelineGridPanel && Sch.panel.TimelineGridPanel.override({
            hideHeaders: false
        });
        Sch.panel.TimelineTreePanel && Sch.panel.TimelineTreePanel.override({
            hideHeaders: false
        });
    }
});

// https://app.therootcause.io/#bryntum/ext-scheduler/errors/41d561988474d9f22262c62aa32d3ddfe7f996b7
/*
    Cannot read property 'length' of undefined

    onTouchEnd	@ TouchAction.js:289:31
    constructor.fire	@ Event.js:483:37
    fire	@ Dom.js:459:26
    publish	@ Dom.js:386:27
    publishGestures	@ Gesture.js:346:15
    onTouchEnd	@ Gesture.js:519:15
    publishDelegatedDomEvent	@ Gesture.js:434:32
    doDelegatedEvent	@ Dom.js:490:15
    onDelegatedEvent	@ Dom.js:471:17
*/
Ext.define('Sch.patches.TouchAction', {
    extend: 'Sch.util.Patch',
    // for Sencha Cmd in production mode
    requires: [
        'Ext.dom.TouchAction'
    ],
    target: "Ext.dom.TouchAction",
    applyFn: function() {
        var old = Ext.dom.TouchAction.onTouchEnd;
        /* Ext assunes e.touches exist, crash if property doesn't exist :(

        onTouchEnd: function(e) {
            var me = this,
                dom = e.target,
                touchCount, flags, doubleTapZoom;
            touchCount = e.touches.length;
            if (touchCount === 0) {

        */
        Ext.dom.TouchAction.onTouchEnd = function(e) {
            e.touches = e.touches || [];
            return old.apply(this, arguments);
        };
    }
});

/**

 @class Sch.plugin.CellPlugin
 @extends Ext.plugin.Abstract

 This plugin allow user to navigate through cells using arrow keys or simple clicking, creating/editing events
 and perform selection. Plugin is built on "1 cell - 1 event" logic and tested over that,
 using this plugin under different conditions may lead to unpredictable results.

 NOTES:
 1) supports only horizontal view
 2) Tested mainly for 'table' event layout, 'horizontal' works, but you may experience some glitches

 */
Ext.define('Sch.plugin.CellPlugin', {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.scheduler_cellplugin',
    requires: [
        'Ext.form.field.Base',
        'Sch.field.CellEditor',
        'Sch.util.Date',
        'Sch.eventlayout.Table'
    ],
    mixins: {
        observable: 'Ext.util.Observable'
    },
    /**
     * @cfg {String} frameCls CSS class of the plugin container div.
     */
    frameCls: 'sch-cellplugin-highlighter',
    editingCls: 'sch-cellplugin-highlighter-editing',
    activeCls: 'sch-cellplugin-active',
    /**
     * @cfg {Ext.Template/Ext.XTemplate} frameTemplate A template providing markup for plugin.
     */
    frameTemplate: new Ext.Template([
        '<div class="{cls}" style="width: {width}px; height: {height}px;">',
        '<div class="sch-cellplugin-border sch-cellplugin-border-horizontal sch-cellplugin-border-top"></div>',
        '<div class="sch-cellplugin-border sch-cellplugin-border-horizontal sch-cellplugin-border-bottom"></div>',
        '<div class="sch-cellplugin-border sch-cellplugin-border-vertical sch-cellplugin-border-left"></div>',
        '<div class="sch-cellplugin-border sch-cellplugin-border-vertical sch-cellplugin-border-right"></div>',
        '</div>'
    ]),
    /**
     * @cfg {String/Object/Ext.form.field.Field} editor Configuration for the {@link Sch.field.CellEditor}.
     *
     * Examples:
     *
     *      @example
     *      // Simple string config:
     *      var plugin1 = new Sch.plugin.CellPlugin({
     *          editor  : 'Ext.form.field.Text'
     *      });
     *
     *      // {@link Sch.field.CellEditor} config
     *      var plugin2 = new Sch.plugin.CellPlugin({
     *          editor  : {
     *              dateFormat  : 'H:i',
     *              divider     : ' '
     *          }
     *      });
     *
     *      // Custom field
     *      Ext.define('MyEditor', {
     *          extend  : 'Ext.form.field.Trigger'
     *      });
     *
     *      var plugin3 = new Sch.plugin.CellPlugin({
     *          editor  : new MyEditor()
     *      });
     *
     */
    editor: 'Sch.field.CellEditor',
    /**
     * @cfg {Boolean} singleClickEditing If true editing mode will be set on plugin on a single click in the cell.
     */
    singleClickEditing: true,
    /**
     * @cfg {Number} dblClickTimeout Timeout required to catch cell double click event if {@link #singleClickEditing} is true
     */
    dblClickTimeout: 100,
    editing: false,
    /**
     * @property {Object} context Object containing information about current selection. Isn't used for navigation purposes.
     * @property {Date} context.startDate Start date of selected tick
     * @property {Date} context.endDate End date of selected tick
     * @property {Sch.model.Resource} context.resource Selected resource
     * @private
     */
    context: {},
    position: {},
    /**
     * @property {Object[]} selContext Array of {@link #context} objects for multiple selection. Doesn't contain
     * currently selected cell.
     * @private
     */
    selContext: [],
    /**
     * @event cellclick
     * Fires when cell click performed and not intercepted by double click. Return false to prevent handling.
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Number} tickIndex Current tick
     * @param {Number} resourceIndex Current resource
     */
    /**
     * @event celldblclick
     * Fires when cell double click performed. Return false to prevent handling.
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Number} tickIndex Current tick
     * @param {Number} resourceIndex Current resource
     */
    /**
     * @event beforeselect
     * @preventable
     * Fires before cell is selected. Return false to prevent selection.
     *
     * @param {Sch.view.TimelineGridView} view Scheduling view
     * @param {Sch.model.Resource} resource Currently selected resource
     * @param {Date} startDate Current tick start date
     * @param {Date} endDate Current tick end date
     */
    /**
     * @event select
     * Fires after cell is selected.
     *
     * @param {Sch.view.TimelineGridView} view Scheduling view
     * @param {Sch.model.Resource} resource Currently selected resource
     * @param {Date} startDate Current tick start date
     * @param {Date} endDate Current tick end date
     */
    /**
     * @event selectionchange
     * Fires after {@link #select} event.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event beforecelledit
     * @preventable
     * Fires before cell enters editing mode. Return false to prevent editing.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event begincelledit
     * Fires after {@link #select} event.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event beforecompletecelledit
     * @preventable
     * Fires before cell enters editing mode. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event completecelledit
     * Fires before cell enters editing mode. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event beforecancelcelledit
     * @preventable
     * Fires before cell editing is cancelled. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    /**
     * @event cancelcelledit
     * Fires after cell editing is cancelled.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */
    lockedView: null,
    schedulingView: null,
    timeAxisViewModel: null,
    keyNav: null,
    constructor: function(cfg) {
        this.mixins.observable.constructor.call(this);
        this.callParent(arguments);
        this.context = {};
        this.position = {};
    },
    init: function(scheduler) {
        var me = this;
        me.schedulingView = scheduler.getSchedulingView();
        me.lockedView = scheduler.lockedGrid.getView();
        // HACK still valid for 6.5.3
        // Disable default grid key navigation to handle multiple cell events
        // http://www.sencha.com/forum/showthread.php?296161
        // We don't need navigation model with cellplugin, they will conflict,
        // but key navigation couldn't be disabled using config.
        scheduler.getNavigationModel().disable();
        me.timeAxisViewModel = scheduler.timeAxisViewModel;
        me.keyNav = new Ext.util.KeyNav({
            target: me.lockedView,
            eventName: 'itemkeydown',
            processEvent: function(view, record, node, index, event) {
                event.stopEvent();
                return event;
            },
            ignoreInputFields: true,
            up: me.onKeyUp,
            down: me.onKeyDown,
            right: me.onKeyRight,
            left: me.onKeyLeft,
            tab: me.onKeyTab,
            enter: me.onKeyEnter,
            esc: me.onKeyEsc,
            scope: me
        });
        if (scheduler.bufferedRenderer) {
            me.schedulingView.on('afterrender', function() {
                me.schedulingView.getScrollable().on('scroll', me.onViewScroll, me);
            });
            me.schedulingView.on('itemadd', me.onItemAdd, me);
        }
        me.handleSingleClickTask = new Ext.util.DelayedTask(me.handleCellClick, me);
        scheduler.on({
            headerclick: me.onContainerClick,
            zoomchange: me.destroyHighlighter,
            scope: me
        });
        me.schedulingView.on({
            containerclick: me.onContainerClick,
            scheduleclick: me.onCellClick,
            scheduledblclick: me.onCellDblClick,
            eventclick: me.onEventClick,
            eventdblclick: me.onEventDblClick,
            // in case editor doesn't allow 'keydown' events we listem them on view
            containerkeydown: me.onEditorKeyDown,
            groupcollapse: me.onGroupCollapse,
            groupexpand: me.onGroupExpand,
            scope: me
        });
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            me.schedulingView.on('refresh', me.moveContainerElToSecondaryCanvas, me);
            // We need to fix editor before onViewModelUpdate
            me.mon(me.timeAxisViewModel, 'update', me.moveContainerElToSecondaryCanvas, me);
        }
        me.mon(me.timeAxisViewModel, {
            update: me.onViewModelUpdate,
            scope: me
        });
        me.mon(scheduler.getTimeAxis(), {
            beforereconfigure: me.onBeforeReconfigure,
            scope: me
        });
        me.bindResourceStore(scheduler.getResourceStore());
        me.bindEventStore(scheduler.getEventStore());
        me.lockedView.on({
            cellclick: me.onLockedCellClick,
            beforeitemkeydown: me.onBeforeItemKeyDown,
            scope: me
        });
        scheduler.on('eventstorechange', function(sched, newStore, oldStore) {
            me.bindEventStore(oldStore, true);
            me.bindEventStore(newStore);
        });
        scheduler.on('resourcestorechange', function(sched, newStore, oldStore) {
            me.bindResourceStore(oldStore, true);
            me.bindResourceStore(newStore);
        });
    },
    moveContainerElToSecondaryCanvas: function() {
        if (this.containerEl) {
            this.schedulingView.getSecondaryCanvasEl().appendChild(this.containerEl);
        }
    },
    getNbrOfTicks: function() {
        return this.schedulingView.timeAxis.getCount();
    },
    onEditorKeyDown: function(view, e) {
        // If position doesn't have tick index, we should not try to do anything
        if (!this.getPosition().hasOwnProperty('tickIndex')) {
            return;
        }
        switch (e.getKey()) {
            case e.TAB:
                e.stopEvent();
                if (e.shiftKey) {
                    this.editPrevious(e);
                } else {
                    this.editNext(e);
                };
                break;
            case e.ENTER:
                this.onEditorKeyEnter();
                break;
            case e.ESC:
                this.cancelEdit(e);
                break;
            default:
                break;
        }
    },
    onEditorKeyEnter: function() {
        if (this.completeEdit()) {
            this.beginEditBelow();
        } else {
            this.showEditorInCell(this.getEventOrCell(this.getPosition(), true));
        }
    },
    destroy: function() {
        this.keyNav.destroy();
        this.editor && this.editor.destroy && this.editor.destroy();
        this.destroyHighlighter();
        this.callParent(arguments);
    },
    destroyHighlighter: function() {
        var me = this;
        me.clearSelection();
        if (me.editor && me.editor.el && !me.schedulingView.destroyed) {
            // move editor to secondary canvas so it won't be deleted
            me.schedulingView.getSecondaryCanvasEl().appendChild(me.editor.el);
            me.editor.hide();
        }
        if (me.containerEl) {
            me.containerEl.destroy();
            delete me.containerEl;
        }
        me.context = {};
        me.position = {};
    },
    onGroupCollapse: function() {
        var me = this;
        if (me.getResourceIndex() === -1) {
            me.destroyHighlighter();
        } else {
            me.refreshCell();
        }
    },
    onGroupExpand: function() {
        this.refreshCell();
    },
    onViewScroll: function() {
        var me = this;
        if (me.containerEl) {
            var node = me.schedulingView.getNodeByRecord(me.getPosition().resource);
            if (node) {
                me.containerEl.setY(Ext.fly(node).getY() - 1);
            }
        }
    },
    onItemAdd: function() {
        var me = this,
            resource = me.getPosition().resource;
        if (resource) {
            var node = me.schedulingView.getNodeByRecord(resource);
            // record is rendered to view
            if (node) {
                me.containerEl.show();
            } else {
                me.containerEl.hide();
            }
        }
    },
    getResourceIndex: function(resource) {
        var me = this;
        resource = resource || me.getPosition().resource;
        // dataSource.indexOf will return index of this record in main store
        // we need index of this record in dataSource store, so we add 'data' property
        return me.schedulingView.indexOf(resource);
    },
    getResource: function(resourceIndex) {
        return this.schedulingView.dataSource.getAt(resourceIndex);
    },
    onResourceAdd: function(store, records) {
        this.refreshCell();
    },
    onResourceRemove: function(store, records) {
        var me = this;
        // TODO: also check if selection should be partially removed
        // if all rows are removed we should also remove box
        // or if currently selected row is removed
        if (store.getCount() === 0 || Ext.Array.indexOf(records, me.getPosition().resource) !== -1) {
            me.destroyHighlighter();
        } else {
            me.refreshCell();
        }
    },
    onBeforeReconfigure: function(timeAxis) {
        var position = this.getPosition();
        // save editor position only if it wasn't saved before
        if (!this.startDate && Ext.isNumber(position.tickIndex)) {
            this.startDate = timeAxis.getAt(position.tickIndex).getStartDate();
        }
    },
    onLockedCellClick: function(lockedView, td, cellIndex, record, tr, rowIndex, e) {
        this.showEditorInCell({
            tickIndex: this.getPosition().tickIndex || 0,
            resourceIndex: rowIndex
        }, e);
    },
    // this method is responsible for type-away behavior
    onBeforeItemKeyDown: function(lockedView, record, item, index, e) {
        if (!e.isSpecialKey()) {
            this.beginEdit();
        }
    },
    onViewModelUpdate: function(timeAxisViewModel) {
        var me = this,
            timeAxis = timeAxisViewModel.timeAxis;
        // if selection was active before reconfigure we should try to show editor
        if (me.startDate) {
            var newTick = timeAxis.getTickFromDate(me.startDate);
            if (newTick >= 0) {
                // remove saved editor position
                delete me.startDate;
                me.position.tickIndex = newTick;
                if (!me.containerEl) {
                    me.renderElement();
                }
                me.refreshCell();
            } else {
                me.destroyHighlighter();
            }
        } else {
            me.refreshCell();
        }
    },
    refreshCell: function() {
        var me = this;
        var width = me.timeAxisViewModel.getTickWidth();
        if (me.containerEl) {
            me.containerEl.setWidth(width);
            me.containerEl.setLeft(width);
            me.showEditorInCell({
                tickIndex: me.getPosition().tickIndex,
                resourceIndex: me.getResourceIndex()
            });
        }
        if (me.editor instanceof Ext.form.field.Base) {
            me.editor.setMaxWidth(width);
        }
    },
    clearSelection: function() {
        var me = this;
        if (me.schedulingView.rendered) {
            me.schedulingView.getSecondaryCanvasEl().select('.' + me.frameCls + '.sch-cellplugin-clone').remove();
        }
        me.selContext = [];
    },
    addSelection: function() {
        var me = this;
        // Cloning container element using method `clone` (`me.containerEl.clone(true);`) leads to ID duplication issue
        var clone = me.frameTemplate.apply({
                cls: [
                    me.frameCls,
                    'sch-cellplugin-clone'
                ].join(' '),
                width: me.containerEl.getWidth(),
                height: me.containerEl.getHeight()
            });
        clone = Ext.get(Ext.dom.Helper.append(me.containerEl.parent(), clone));
        clone.setStyle('top', me.containerEl.getStyle('top'));
        clone.setStyle('left', me.containerEl.getStyle('left'));
        me.selContext.push(Ext.apply({}, me.context));
    },
    // Navigation model changed in ext6, now when we hide editor using DISPLAY or VISIBLE
    // it'll trigger focus handling in IE. Focus goes to editor's parent (secondary canvas)
    // and ext tries to resolve position to pass it to setActionableMode method.
    // Resolved position doesn't have required property - column (ext expect focus on cell, but it goes
    // to secondary canvas). Ext doesn't have additional check, for that, so it throws exception in IE.
    // caught in 098_cellplugin_buffered
    applyVisibilityMode: function(el) {
        el.setVisibilityMode(Ext.dom.Element.OFFSETS);
    },
    renderElement: function() {
        var me = this;
        var width = me.timeAxisViewModel.getTickWidth();
        var height = me.timeAxisViewModel.getViewRowHeight();
        var el = me.frameTemplate.apply({
                cls: [
                    me.frameCls,
                    me.activeCls
                ].join(' '),
                width: width,
                height: height
            });
        me.containerEl = Ext.get(Ext.DomHelper.append(me.schedulingView.getSecondaryCanvasEl(), el));
        me.applyVisibilityMode(me.containerEl);
        var defaultCfg = {
                height: height,
                maxHeight: height,
                width: width,
                maxWidth: width,
                listeners: {
                    render: function(editor) {
                        me.applyVisibilityMode(editor.el);
                    }
                },
                renderTo: me.containerEl
            };
        if (Ext.isObject(me.editor) && !(me.editor instanceof Ext.Base)) {
            me.editor = Ext.create(Ext.apply(defaultCfg, me.editor, {
                xclass: 'Sch.field.CellEditor'
            }));
        } else if (typeof me.editor === 'string') {
            me.editor = Ext.create(me.editor, defaultCfg);
        } else {
            // editor is instance of form.field.Base
            me.containerEl.appendChild(me.editor.el);
            me.applyVisibilityMode(me.editor.el);
        }
        // Ext 5 has broken style for text editor in webkit, this action will
        // stetch input element to field height
        me.editor.inputEl.setStyle({
            height: (height - 3) + 'px',
            minHeight: (height - 3) + 'px'
        });
    },
    // for correct work we should always keep focus on elements in locked grid
    onContainerClick: function() {
        var me = this;
        if (me.lockedView.getSelectionModel().getSelection().length > 0) {
            // focus row from locked grid only if one is selected and we are not editing cell
            if (me.editor.isVisible && me.editor.isVisible()) {
                me.editor.focus();
            }
        }
    },
    onCellClick: function() {
        this.handleSingleClickTask.delay(this.dblClickTimeout, null, null, arguments);
    },
    handleCellClick: function(view, date, rowIndex, resource, e) {
        var me = this;
        var colIndex = Math.floor(me.schedulingView.timeAxis.getTickFromDate(date));
        if (me.fireEvent('cellclick', me, colIndex, rowIndex) !== false) {
            me.showEditorInCell({
                tickIndex: colIndex,
                resourceIndex: rowIndex
            }, e);
            if (me.singleClickEditing) {
                me.beginEdit();
            }
        }
    },
    onCellDblClick: function(view, date, rowIndex, resource, e) {
        this.handleSingleClickTask.cancel();
        this.handleCellDblClick(view, date, rowIndex, resource, e);
    },
    handleCellDblClick: function(view, date, rowIndex, resource, e) {
        var me = this;
        var colIndex = Math.floor(me.schedulingView.timeAxis.getTickFromDate(date));
        if (me.fireEvent('celldblclick', me, colIndex, rowIndex) !== false) {
            me.showEditorInCell({
                tickIndex: colIndex,
                resourceIndex: rowIndex
            }, e);
            me.beginEdit();
        }
    },
    onEventClick: function(view, eventRecord, e) {
        var me = this;
        var date = me.schedulingView.getDateFromDomEvent(e);
        var col = Math.floor(me.schedulingView.timeAxis.getTickFromDate(date));
        // in case of grouped view we can't lookup indices in main store
        var row = me.getResourceIndex(eventRecord.getResource());
        me.showEditorInCell({
            tickIndex: col,
            resourceIndex: row,
            eventRecord: eventRecord
        }, e);
    },
    onEventDblClick: function(view, eventRecord, e) {
        var me = this;
        var date = me.schedulingView.getDateFromDomEvent(e);
        var col = Math.floor(me.schedulingView.timeAxis.getTickFromDate(date));
        // in case of grouped view we can't lookup indices in main store
        var row = me.getResourceIndex(eventRecord.getResource());
        me.showEditorInCell({
            tickIndex: col,
            resourceIndex: row,
            eventRecord: eventRecord
        }, e);
        me.beginEdit();
    },
    // resource record is optional param
    showEditorInCell: function(position, e) {
        var me = this;
        if (position.tickIndex === -1 || position.resourceIndex === -1)  {
            return;
        }
        
        if (!position.isCellContext) {
            position = me.getEventOrCell(position);
        }
        var startDate = position.startDate,
            endDate = position.endDate,
            resourceIndex = position.resourceIndex,
            resource = position.resource,
            eventRecord = position.eventRecord;
        // user clicked on locked cell or normal cell (only if event layout is not table)
        if (e && e.type === 'click' && !eventRecord) {
            position.eventRecord = eventRecord = me.getCellEvents(position).getAt(0);
        }
        if (me.fireEvent('beforeselect', me, resource, startDate, endDate, eventRecord) === false) {
            return;
        }
        me.onBeforeSelect(e);
        if (!me.containerEl) {
            me.renderElement();
        } else {
            if (e && e.ctrlKey) {
                me.addSelection();
            } else {
                me.clearSelection();
            }
        }
        me.setPosition(position);
        me.alignEditor();
        me.onAfterSelect(e);
        me.fireEvent('select', me, resource, startDate, endDate);
        // TODO: append check for actual selection change
        me.fireEvent('selectionchange', me, me.getSelection());
    },
    getContextFromPosition: function(position) {
        var context = {
                startDate: position.startDate,
                endDate: position.endDate,
                resource: position.resource
            };
        if (position.eventRecord) {
            context.eventRecord = position.eventRecord;
        }
        return context;
    },
    getPosition: function() {
        return Ext.apply({}, this.position);
    },
    setPosition: function(position) {
        var me = this;
        me.context = me.getContextFromPosition(position);
        Ext.apply(me.position, position);
    },
    // remove all data except tick index and resource index. useful when navigating sideways
    stripPosition: function(position) {
        return {
            tickIndex: position.tickIndex,
            resourceIndex: position.resourceIndex
        };
    },
    alignEditor: function() {
        var position = this.getPosition(),
            eventRecord = position.eventRecord;
        if (eventRecord) {
            this.alignEditorWithRecord(eventRecord, position.resource);
        } else {
            this.alignEditorWithCell();
        }
    },
    alignEditorWithRecord: function(eventRecord, resourceRecord) {
        var me = this;
        // some enhancements to make box visible
        // TODO: use z-index or wrap box around event body
        var els = me.schedulingView.getElementsFromEventRecord(eventRecord, resourceRecord),
            box = els[0].getBox();
        box.y--;
        box.x--;
        me.alignEditorToBox(box);
    },
    alignEditorWithCell: function() {
        var me = this,
            position = me.getPosition();
        // In case of grouping, getNode will return row and group header. We only need row with cells
        var node = Ext.get(me.schedulingView.getRow(position.resource));
        node && me.alignEditorToBox({
            left: me.timeAxisViewModel.getTickWidth() * position.tickIndex,
            // There is 1px top row border, make some adjustments
            y: node.getTop() - 1,
            height: node.getHeight() + 1,
            width: me.timeAxisViewModel.getTickWidth()
        });
    },
    alignEditorToBox: function(box) {
        var me = this;
        me.containerEl.setY(box.y);
        // 'x' key is passed when box is positioned using event element - absolute coordinates
        if ('x' in box) {
            me.containerEl.setX(box.x);
        } else {
            me.containerEl.setLeft(box.left);
        }
        me.containerEl.setWidth(box.width);
        me.containerEl.setHeight(box.height);
        me.containerEl.show();
    },
    getSelection: function() {
        return this.selContext.concat(this.context);
    },
    /**
     * @method getEventRecord
     * Accepts current context (selected cell) and should always return one event record.
     * @param {Object} [context]
     * @param {Sch.model.Resource} context.resource Selected resource
     * @param {Date} context.startDate Current cell start date
     * @param {Date} context.endDate Current cell end date
     * @return {Sch.model.Event}
     */
    getEventRecord: function(context) {
        return (context || this.context).eventRecord;
    },
    /**
     * @method getResourceRecord
     * Accepts current context (selected cell) and should always return one resource record.
     * @param {Object} [context]
     * @param {Sch.model.Resource} context.resource Selected resource
     * @param {Date} context.startDate Current cell start date
     * @param {Date} context.endDate Current cell end date
     * @return {Sch.model.Resource}
     */
    getResourceRecord: function(context) {
        return (context || this.context).resource;
    },
    onKeyUp: function(e) {
        this.moveUp(e);
    },
    onKeyDown: function(e) {
        this.moveDown(e);
    },
    onKeyLeft: function(e) {
        this.moveLeft(e);
    },
    onKeyRight: function(e) {
        this.moveRight(e);
    },
    onKeyTab: function(e) {
        if (e.shiftKey) {
            this.moveLeft(e);
        } else {
            this.moveRight(e);
        }
    },
    onKeyEnter: function() {
        this.beginEdit();
    },
    onKeyEsc: function() {
        this.destroyHighlighter();
    },
    findPreviousIndex: function() {
        var me = this,
            position = me.getPosition();
        var prevRecord = me.schedulingView.walkRecs(position.resource, -1);
        if (prevRecord !== position.resource) {
            return me.getResourceIndex(prevRecord);
        } else {
            return -1;
        }
    },
    findNextIndex: function() {
        var me = this,
            position = me.getPosition();
        var prevRecord = me.schedulingView.walkRecs(position.resource, 1);
        if (prevRecord !== position.resource) {
            return me.getResourceIndex(prevRecord);
        } else {
            return -1;
        }
    },
    getCellEvents: function(position) {
        var me = this,
            view = me.schedulingView;
        position = position || me.getPosition();
        if (position.resourceIndex === -1 || position.tickIndex === -1) {
            return new Ext.util.MixedCollection();
        }
        var events = view.getEventStore().queryBy(function(event) {
                return event.getResourceId() === position.resource.getId() && event.getStartDate() >= position.startDate && event.getStartDate() < position.endDate;
            });
        events.sortBy(function(a, b) {
            var aEl = view.getElementsFromEventRecord(a, position.resource)[0],
                bEl = view.getElementsFromEventRecord(b, position.resource)[0];
            return aEl.getY() < bEl.getY() ? -1 : 1;
        });
        return events;
    },
    getAbove: function(position) {
        var me = this;
        position = position || me.getPosition();
        if (position.eventRecord) {
            var cellEvents = me.getCellEvents(position);
            var eventIndex = cellEvents.indexOf(position.eventRecord);
            // if box is currently on event in cell, check if we can just reduce the index
            if (eventIndex > 0) {
                var newEventIndex = eventIndex - 1;
                return {
                    tickIndex: position.tickIndex,
                    resourceIndex: position.resourceIndex,
                    eventIndexInCell: newEventIndex,
                    eventRecord: cellEvents.getAt(newEventIndex)
                };
            }
        }
        var newResourceIndex = me.findPreviousIndex();
        // last expanded resource, cannot move down
        if (newResourceIndex === -1) {
            // have to return special index to exit routine later
            return {
                resourceIndex: -1
            };
        }
        return me.getEventOrCell({
            tickIndex: position.tickIndex,
            resourceIndex: newResourceIndex
        }, true);
    },
    getBelow: function(position) {
        var me = this;
        position = position || me.getPosition();
        if (position.eventRecord) {
            var cellEvents = me.getCellEvents(position);
            // if event was clicked, we don't know relative index, have to calculate it
            var eventIndex = cellEvents.indexOf(position.eventRecord);
            var newEventIndex = eventIndex + 1;
            if (eventIndex >= 0 && cellEvents.getCount() > newEventIndex) {
                return {
                    tickIndex: position.tickIndex,
                    resourceIndex: position.resourceIndex,
                    eventIndexInCell: newEventIndex,
                    eventRecord: cellEvents.getAt(newEventIndex)
                };
            }
        }
        var newResourceIndex = me.findNextIndex();
        // last expanded resource, cannot move down
        if (newResourceIndex === -1) {
            return {
                resourceIndex: -1
            };
        }
        return me.getEventOrCell({
            resourceIndex: newResourceIndex,
            tickIndex: position.tickIndex
        });
    },
    /**
     * @method getEventOrCell
     * Moving box in horizontal direction should select first event in cell, or whole cell.
     * Method requires not only conventional context for next cell, but also new tickIndex and resourceIndex -
     * to avoid unnesessary lookups.
     * @param {Object} position Current {@link #context} updated with two optional properties:
     * @param {Number} [position.tickIndex] Tick index of new cell. If not provided - current is used.
     * @param {Number} [position.resourceIndex] Resource index of new cell. If not provided - current is used.
     * @param {Boolean} [pickLast=false] Pass true if you want to pick last event of cell
     *
     * @return {Object} Navigation params.
     * @return {Number} return.tickIndex Column index
     * @return {Date} return.startDate Cell start date
     * @return {Date} return.endDate Cell end date
     * @return {Number} return.resourceIndex Row number
     * @return {Sch.model.Resource} return.resource Resource record
     * @return {Sch.model.Event} return.eventRecord Event record to select, if applicable
     * @return {Number} return.eventIndexInCell Index of the event in cell, if applicable
     * @private
     */
    getEventOrCell: function(position, pickLast) {
        var me = this;
        if (position.tickIndex === -1 || position.resourceIndex === -1) {
            return position;
        }
        var view = this.schedulingView,
            tick = view.timeAxis.getAt(position.tickIndex),
            startDate = tick.getStartDate(),
            endDate = tick.getEndDate(),
            resource = view.dataSource.getAt(position.resourceIndex),
            eventRecord = position.eventRecord,
            eventIndexInCell = position.eventIndexInCell;
        var events = me.getCellEvents({
                resource: resource,
                startDate: startDate,
                endDate: endDate
            });
        if (events.getCount()) {
            if (pickLast === true) {
                eventIndexInCell = events.getCount() - 1;
                eventRecord = events.getAt(eventIndexInCell);
            }
            // If record is provided, calculate it's index in cell. This can happen when event is clicked
            else if (eventRecord) {
                eventIndexInCell = Ext.Array.indexOf(events, eventRecord);
            } else {
                eventIndexInCell = 0;
                eventRecord = events.getAt(0);
            }
        }
        return {
            tickIndex: position.tickIndex,
            startDate: startDate,
            endDate: endDate,
            resourceIndex: position.resourceIndex,
            resource: resource,
            eventRecord: eventRecord,
            eventIndexInCell: eventIndexInCell,
            isCellContext: true
        };
    },
    getPrevious: function(position) {
        var me = this;
        position = me.stripPosition(position || me.getPosition());
        if (position.tickIndex > 0) {
            return me.getEventOrCell({
                tickIndex: position.tickIndex - 1,
                resourceIndex: position.resourceIndex
            });
        } else {
            return me.getEventOrCell({
                tickIndex: me.getNbrOfTicks() - 1,
                resourceIndex: me.findPreviousIndex()
            });
        }
    },
    getNext: function(position) {
        var me = this;
        position = me.stripPosition(position || me.getPosition());
        if (position.tickIndex < me.getNbrOfTicks() - 1) {
            return me.getEventOrCell({
                tickIndex: position.tickIndex + 1,
                resourceIndex: position.resourceIndex
            });
        } else {
            return me.getEventOrCell({
                tickIndex: 0,
                resourceIndex: me.findNextIndex()
            });
        }
    },
    moveUp: function(e) {
        var me = this;
        if (!me.containerEl) {
            return;
        }
        me.showEditorInCell(me.getAbove(), e);
    },
    moveDown: function(e) {
        var me = this;
        if (!me.containerEl) {
            return;
        }
        me.showEditorInCell(me.getBelow(), e);
    },
    moveLeft: function(e) {
        var me = this;
        if (!me.containerEl) {
            return;
        }
        me.showEditorInCell(me.getPrevious(), e);
    },
    moveRight: function(e) {
        var me = this;
        if (!me.containerEl) {
            return;
        }
        me.showEditorInCell(me.getNext(), e);
    },
    editNext: function(e) {
        var me = this,
            position = me.getPosition(),
            newPosition = me.getNext(position);
        while (!me.beginEdit(newPosition) && newPosition.resourceIndex !== -1) {
            position = newPosition;
            newPosition = me.getNext(position);
        }
    },
    editPrevious: function(e) {
        var me = this,
            position = me.getPosition(),
            newPosition = me.getPrevious(position);
        while (!me.beginEdit(newPosition) && newPosition.resourceIndex !== -1) {
            position = newPosition;
            newPosition = me.getPrevious(position);
        }
    },
    expandResourceRow: function(resourceNode, box, height) {
        var me = this;
        Ext.fly(resourceNode).setHeight(box.height + height);
        Ext.fly(me.lockedView.getNodeByRecord(me.getPosition().resource)).setHeight(box.height + height);
        me.__oldHeight = box.height;
    },
    getNewBottomEditorCoordinate: function(height) {
        var me = this,
            record = me.getCellEvents().last();
        if (record) {
            var position = me.getPosition(),
                view = me.schedulingView,
                resourceNode = view.getNodeByRecord(position.resource),
                box = Ext.fly(resourceNode).getBox(),
                eventBox = view.getElementsFromEventRecord(record, position.resource)[0].getBox();
            // we should expand row only if we do not have enough room for input
            // Let's forgive 1px - no big difference and at the same time don't expand semmingly sufficient row
            if (Math.abs(eventBox.bottom - box.bottom) < height - 1) {
                me.expandResourceRow(resourceNode, box, height);
                return box.bottom;
            } else {
                return eventBox.bottom;
            }
        }
    },
    collapseResourceRow: function() {
        var me = this;
        if (me.__oldHeight) {
            var position = me.getPosition();
            Ext.fly(me.schedulingView.getNodeByRecord(position.resource)).setHeight(me.__oldHeight);
            Ext.fly(me.lockedView.getNodeByRecord(position.resource)).setHeight(me.__oldHeight);
            delete me.__oldHeight;
        }
    },
    beginEditBelow: function() {
        var me = this;
        if (!me.containerEl) {
            return;
        }
        delete me.context.eventRecord;
        me.beginEdit();
        var height = me.timeAxisViewModel.getViewRowHeight();
        var bottom = me.getNewBottomEditorCoordinate(height);
        me.alignEditorToBox({
            left: me.timeAxisViewModel.getTickWidth() * me.getPosition().tickIndex,
            y: bottom,
            width: me.timeAxisViewModel.getTickWidth(),
            height: height
        });
    },
    beginEdit: function(position) {
        var me = this;
        // When looking for next/previous edit position in editing mode position is passed as argument
        // and when editor reaches first/last cell, position has resourceIndex equal to -1
        if (!me.containerEl || (position && position.resourceIndex === -1)) {
            return false;
        }
        // such event makes sense only if user is provided with selection information
        // e.g. he selected readonly cell
        if (me.fireEvent('beforecelledit', me, position ? [
            me.getContextFromPosition(position)
        ] : me.getSelection()) === false) {
            return false;
        }
        // Sync plugin position with passed position. It will stop editing and place editor correctly
        if (position) {
            me.showEditorInCell(position);
        }
        me.editing = true;
        me.editor.startDate = me.getPosition().startDate;
        me.editor.bottomUnit = Sch.util.Date.getSubUnit(me.timeAxisViewModel.getBottomHeader().unit);
        me.containerEl.select('.sch-cellplugin-border').hide();
        me.containerEl.addCls(me.editingCls);
        var event = me.getEventRecord(),
            resource = me.getResourceRecord();
        if (event) {
            var date = Ext.Date;
            // TODO: this should be implemented in editor, not here
            var format = Ext.isArray(me.editor.dateFormat) ? me.editor.dateFormat[0] : me.editor.dateFormat;
            var startDate = date.format(event.getStartDate(), format);
            var endDate = date.format(event.getEndDate(), format);
            me.editor.record = event;
            me.editor.setValue([
                startDate,
                endDate
            ].join(me.editor.divider));
            me.editor.recordNode = me.schedulingView.getElementsFromEventRecord(event, resource)[0];
            Ext.fly(me.editor.recordNode).hide();
        }
        me.editor.show();
        me.editor.setWidth(me.editor.getMaxWidth());
        me.editor.focus();
        me.fireEvent('begincelledit', me, me.getSelection());
        return me.editing;
    },
    cancelEdit: function() {
        var me = this;
        // If normal view is dblclicked and escape is typed this handler will be invoked. Need to check if editor is
        // present
        // 098_cellplugin
        if (me.editor && me.editor.getValue) {
            var value = me.editor.getValue();
            var selection = me.getSelection();
            if (me.fireEvent('beforecancelcelledit', me, value, selection) === false) {
                return;
            }
            me.stopEditing();
            me.fireEvent('cancelcelledit', me, value, selection);
        }
    },
    completeEdit: function() {
        var me = this,
            addNewLine = false;
        // plugin is not in editing mode
        if (!me.editing || !me.containerEl) {
            return;
        }
        var editor = me.editor,
            value = me.editor.getValue(),
            selection = me.getSelection();
        if (me.fireEvent('beforecompletecelledit', me, value, selection) === false) {
            return;
        }
        if (value && editor.isValid()) {
            var view = me.schedulingView,
                record = editor.record,
                dates = editor.getDates(value),
                startDate = dates[0],
                endDate = dates[1];
            if (record) {
                record.setStartEndDate(startDate, endDate);
                delete editor.record;
            } else {
                var resource = me.context.resource,
                    newRecord = Ext.create(view.getEventStore().getModel(), {
                        StartDate: startDate,
                        EndDate: endDate,
                        ResourceId: resource.getId()
                    });
                view.onEventCreated(newRecord, [
                    resource
                ]);
                view.getEventStore().add(newRecord);
            }
            addNewLine = true;
        }
        me.stopEditing();
        me.fireEvent('completecelledit', me, value, selection);
        return addNewLine;
    },
    // resets value, restores view to state before editing
    stopEditing: function() {
        var me = this,
            editor = me.editor;
        if (editor.recordNode) {
            Ext.fly(editor.recordNode).show();
            delete editor.recordNode;
        }
        me.collapseResourceRow();
        editor.setValue('');
        me.editing = false;
        me.clearSelection();
        me.containerEl.select('.sch-cellplugin-border').show();
        me.containerEl.removeCls(me.editingCls);
        editor.hide();
        // TODO: in IE if locked grid will have more than 1 column this can mess scroll position
        var node = me.lockedView.getRow(me.getPosition().resource);
        node && Ext.fly(node).down(me.lockedView.getCellSelector()).focus();
    },
    onBeforeSelect: function(e) {
        var me = this;
        e && e.isNavKeyPress && e.isNavKeyPress() && me.clearSelection();
        me.completeEdit();
    },
    onAfterSelect: function(e) {
        var me = this,
            resource = me.getPosition().resource;
        me.lockedView.getSelectionModel().select(resource);
        Ext.fly(me.lockedView.getRow(resource)).down(me.lockedView.getCellSelector()).focus();
        me.editor.setValue('');
        // TODO
        me.containerEl.scrollIntoView(me.schedulingView.getEl());
    },
    bindResourceStore: function(store, un) {
        if (store) {
            var me = this;
            me[un ? 'mun' : 'mon'](store, {
                add: me.onResourceAdd,
                remove: me.onResourceRemove,
                clear: me.destroyHighlighter,
                scope: me
            });
        }
    },
    bindEventStore: function(store, un) {
        if (store) {
            var me = this;
            me[un ? 'mun' : 'mon'](store, {
                load: me.destroyHighlighter,
                scope: me
            });
        }
    }
});

/**
@class Sch.plugin.DragSelector
@extends Ext.util.DragTracker

Plugin (ptype = 'scheduler_dragselector') for selecting multiple events by "dragging" an area in the scheduler chart. Currently only enabled **when CTRL is pressed**

{@img scheduler/images/drag-selector.png}

To add this plugin to scheduler:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.DragSelector')
        ]
    });

 */
Ext.define("Sch.plugin.DragSelector", {
    extend: "Sch.util.DragTracker",
    alias: 'plugin.scheduler_dragselector',
    mixins: [
        'Ext.AbstractPlugin'
    ],
    requires: [
        'Sch.util.ScrollManager'
    ],
    lockableScope: 'top',
    schedulerView: null,
    eventBoxes: null,
    sm: null,
    proxy: null,
    bodyRegion: null,
    constructor: function(cfg) {
        cfg = cfg || {};
        Ext.applyIf(cfg, {
            onBeforeStart: this.onBeforeStart,
            onStart: this.onStart,
            onDrag: this.onDrag,
            onEnd: this.onEnd
        });
        this.callParent(arguments);
    },
    bindListenersOnDragStart: function() {
        var el = this.getCmp().getScrollable().getElement();
        el && el.on('scroll', this.onScroll, this);
        this.callParent(arguments);
    },
    unbindListenersOnDragEnd: function() {
        var el = this.getCmp().getScrollable().getElement();
        el && el.un('scroll', this.onScroll, this);
        this.callParent(arguments);
    },
    init: function(scheduler) {
        this.setCmp(scheduler);
        var view = this.schedulerView = scheduler.getSchedulingView();
        view.on({
            afterrender: this.onSchedulingViewRender,
            scope: this
        });
    },
    onScroll: function(event) {
        this.updateEventNodeBoxes();
        this.onMouseMove.apply(this, arguments);
    },
    onBeforeStart: function(e) {
        // Only react when not clicking event nodes and when CTRL is pressed
        return !e.getTarget('.sch-event') && e.ctrlKey;
    },
    onStart: function(e) {
        var schedulerView = this.schedulerView;
        this.proxy.show();
        this.bodyRegion = schedulerView.getScheduleRegion();
        this.eventBoxes = {};
        this.updateEventNodeBoxes();
        this.sm.deselectAll();
        Sch.util.ScrollManager.activate(schedulerView);
        schedulerView.on('bufferedrefresh', this.updateSelection, this);
        this.mon(schedulerView.getScrollable(), 'scroll', this.onSchedulerViewScroll, this);
    },
    onSchedulerViewScroll: function() {
        this.updateEventNodeBoxes();
        this.updateSelection();
    },
    updateEventNodeBoxes: function() {
        var me = this,
            schedulerView = this.schedulerView;
        schedulerView.getEventNodes().each(function(eventElement) {
            var region = eventElement.getRegion();
            me.eventBoxes[eventElement.dom.id] = {
                eventRecord: schedulerView.getEventRecordFromDomElement(eventElement.dom),
                region: region,
                node: eventElement.dom
            };
        });
    },
    onDrag: function() {
        var dragRegion = this.getRegion().constrainTo(this.bodyRegion);
        this.proxy.setBox(dragRegion);
        this.updateSelection();
    },
    getCurrentScroll: function() {
        return this.schedulerView.getScroll();
    },
    updateSelection: function() {
        var sm = this.sm,
            eventBoxes = this.eventBoxes,
            dragRegion = this.getRegion(),
            shouldSelect;
        Ext.Object.getValues(eventBoxes).forEach(function(eventData) {
            var eventRecord = eventData.eventRecord;
            shouldSelect = dragRegion.intersect(eventData.region);
            if (shouldSelect && !sm.isSelected(eventRecord)) {
                sm.selectNode(eventData.node, true);
            } else if (!shouldSelect && sm.isSelected(eventRecord)) {
                sm.deselectNode(eventData.node);
            }
        });
    },
    onEnd: function(e) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);
        }
        this.schedulerView.un('bufferedrefresh', this.updateSelection, this);
        this.mun(this.schedulerView.getScrollable(), 'scroll', this.onSchedulerViewScroll, this);
        Sch.util.ScrollManager.deactivate();
    },
    onSchedulingViewRender: function(view) {
        this.sm = view.getEventSelectionModel();
        this.initEl(this.schedulerView.el);
        // the proxy has to be set up immediately after rendering the view, so it will be included in the
        // "fixedNodes" of the grid view and won't be overwritten after refresh
        this.proxy = view.el.createChild({
            cls: 'sch-drag-selector'
        });
    },
    destroy: function() {
        if (this.proxy)  {
            Ext.destroy(this.proxy);
        }
        
        this.callParent(arguments);
    }
});

/**
 * @class Sch.plugin.mixin.Editor
 * @private
 *
 * A mixin providing floating functionality to the {@link Sch.plugin.EventEditor} which extends {@link Sch.widget.EventEditor}
 * and to the {@link Sch.plugin.EditorWindow} which contains {@link Sch.widget.EventEditor} as a child component.
 */
Ext.define('Sch.plugin.mixin.Editor', {
    extend: 'Ext.Mixin',
    mixinConfig: {
        before: {
            showRecord: 'beforeShowRecord',
            hide: 'beforeEditorHide'
        },
        after: {
            showRecord: 'afterShowRecord'
        }
    },
    /**
     * @cfg {Boolean} hideOnBlur True to hide this panel if a click is detected outside the panel (defaults to true)
     */
    hideOnBlur: true,
    /**
     * @cfg {Boolean} saveAndCloseOnEnter True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.
     */
    saveAndCloseOnEnter: true,
    /**
     * @cfg {String} triggerEvent The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
     */
    triggerEvent: 'eventdblclick',
    record: null,
    dragProxyEl: null,
    ignoreCls: 'sch-event-editor-ignore-click',
    ignoreCheckMaxDepth: 30,
    lockableScope: 'normal',
    width: 400,
    initEditor: function() {
        var me = this;
        var cmp = me.getCmp();
        var editor = me.getEventEditor();
        editor.saveOnEnter = me.saveAndCloseOnEnter;
        editor.allowOverlap = cmp.allowOverlap === undefined ? true : cmp.allowOverlap;
        // In case recurring event fields were explicitly turned off on the event editor,
        // no need to turn them on again
        var editorRecurringEvents = editor.getRecurringEvents && editor.getRecurringEvents();
        editor.setRecurringEvents && editor.setRecurringEvents(editorRecurringEvents !== false && cmp.recurringEvents !== false);
        me.setEventStore(cmp.getEventStore());
        me.setResourceStore(cmp.getResourceStore());
        if (cmp.rendered) {
            me.onCmpAfterRender();
        } else {
            me.mon(cmp, 'afterrender', me.onCmpAfterRender, me);
        }
        me.mon(cmp, {
            dragcreateend: me.onDragCreateEnd,
            eventstorechange: me.onCmpEventStoreChange,
            resourcestorechange: me.onCmpResourceStoreChange,
            scope: me
        });
        me.mon(editor, {
            aftereventadd: me.onAfterEventAdd,
            aftereventsave: me.onAfterEventSave,
            aftereventdelete: me.onAfterEventDelete,
            scope: me
        });
        me.on('hide', me.hideDragProxy, me);
        if (me.triggerEvent) {
            me.mon(cmp, me.triggerEvent, me.onActivateEditor, me);
        }
    },
    /**
     * Before showRecord hook
     * @private
     * @param {Sch.model.Event} record The record to show in the editor panel
     * @param {Object} options Extra options:
     * @param {Ext.dom.Element} options.alignToEl Element to align the editor to (otherwise the editor is centered)
     */
    beforeShowRecord: function(record, options) {
        var me = this;
        me.addRepaintListener();
        me.show();
    },
    // should be overridden for non-scheduler components
    addRepaintListener: function() {
        var me = this;
        var cmp = me.getCmp();
        if (cmp.isSchedulerGrid || cmp.isSchedulerTree) {
            me.eventRepaintListener = me.mon(cmp.getSchedulingView(), 'eventrepaint', me.onEventRepaint, me, {
                destroyable: true
            });
        }
    },
    /**
     * After showRecord hook
     * @private
     * @param {Sch.model.Event} record The record to show in the editor panel
     * @param {Object} options Extra options:
     * @param {Ext.dom.Element} options.alignToEl Element to align the editor to (otherwise the editor is centered)
     */
    afterShowRecord: function(record, options) {
        var me = this;
        var cmp = me.getCmp();
        var readOnly = cmp && cmp.isReadOnly && cmp.isReadOnly();
        var editor = me.getEventEditor();
        me.setRecord(record);
        me.alignEditorToElement(Ext.isObject(options) && options.alignToEl);
        editor.loadRecord(record, readOnly);
    },
    beforeEditorHide: function(record, options) {
        var me = this;
        me.eventRepaintListener && me.eventRepaintListener.destroy();
    },
    setEventStore: function(store) {
        var me = this;
        var editor = me.getEventEditor();
        editor.setEventStore(store);
    },
    setResourceStore: function(store) {
        var me = this;
        var editor = me.getEventEditor();
        editor.setResourceStore(store);
    },
    getEventEditor: function() {
        // this mixin could be mixed in the editor window (Sch.plugin.EditorWindow) and in the editor itself (Sch.plugin.EventEditor)
        return this.isEventEditor ? this : this.editor;
    },
    onAfterEventAdd: function(editor, eventRecord) {
        if (editor.scrollNewEventIntoView && eventRecord.getResources().length < 2) {
            this.scrollEventIntoView(eventRecord);
        }
    },
    onAfterEventSave: function(editor, eventRecord) {
        this.hideEditor();
    },
    scrollEventIntoView: function(eventRecord) {
        this.getCmp().getSchedulingView().scrollEventIntoView(eventRecord);
    },
    onCmpEventStoreChange: function(cmp, store) {
        this.setEventStore(store);
    },
    onCmpResourceStoreChange: function(cmp, store) {
        this.setResourceStore(store);
    },
    onAfterEventDelete: function() {
        this.hideEditor();
    },
    onCmpAfterRender: function() {
        var me = this;
        if (!me.isWindow) {
            me.render(document.body);
        }
        if (me.hideOnBlur) {
            // Hide when clicking outside panel
            me.mon(Ext.getDoc(), 'mousedown', me.mouseDownAction, me);
        }
        me.registerEditorInComponent();
    },
    // should be overridden for non-scheduler components
    registerEditorInComponent: function() {
        var me = this;
        var cmp = me.getCmp();
        // This mixin could be mixed in Sch.plugin.EditorWindow which contains Sch.widget.EventEditor (editor form) as a child item
        // or in Sch.plugin.EventEditor which extends Sch.widget.EventEditor (editor form).
        // In both cases it makes sense to keep link to the top level component instead of a form,
        // so whenever you need to show record there will be `showRecord` function.
        // And if you need to refer to the form you can access it through the top level component.
        cmp.getSchedulingView().registerEventEditor(me);
    },
    onDragCreateEnd: function(s, eventRecord, resourceRecord, e, proxyEl) {
        var me = this;
        var cmp = me.getCmp();
        var editor = me.getEventEditor();
        var resources = [];
        if (resourceRecord && resourceRecord.isResourceModel) {
            editor.resourceRecord = resourceRecord;
            resources = [
                resourceRecord
            ];
        }
        // Call a template method
        if (cmp.onEventCreated) {
            cmp.onEventCreated(eventRecord, resources);
        }
        var target = proxyEl || (e.getTarget && e.getTarget()) || e.target || null;
        me.showRecord(eventRecord, {
            alignToEl: target
        });
        // Clone proxy after showing editor so it's not deleted
        if (proxyEl) {
            var dragProxyEl = proxyEl.dom.cloneNode(true);
            dragProxyEl.id = '';
            proxyEl.dom.parentNode.appendChild(dragProxyEl);
            me.dragProxyEl = Ext.get(dragProxyEl);
        }
    },
    // Set ignore cls automatically on inner form elements
    addIgnoreCls: function() {
        var me = this,
            editor = me.getEventEditor(),
            toIgnore = editor.getFloatingComponents();
        Ext.Array.each(toIgnore, function(cmp) {
            cmp.addCls(me.ignoreCls);
        });
    },
    mouseDownAction: function(e) {
        if (this.isVisible() && !this.isEventWithinComponent(e)) {
            this.hideEditor();
        }
    },
    isEventWithinComponent: function(e) {
        return e.within(this.getEl()) || !!e.getTarget('.' + this.ignoreCls, this.ignoreCheckMaxDepth) || !!e.getTarget('.' + Ext.baseCSSPrefix + 'mask', 1);
    },
    onActivateEditor: function(g, record, e) {
        var me = this;
        var selector = me.getSelectorToAlignEditorBy();
        var target = e.getTarget(selector);
        this.showRecord(record, {
            alignToEl: target
        });
    },
    getSelectorToAlignEditorBy: function() {
        var me = this;
        var cmp = me.getCmp();
        var cls = cmp.getSchedulingView && cmp.getSchedulingView() && cmp.getSchedulingView().eventCls;
        return cls ? '.' + cls : null;
    },
    hideDragProxy: function() {
        var dpEl = this.dragProxyEl;
        if (dpEl && dpEl.dom.parentNode) {
            dpEl.dom.parentNode.removeChild(dpEl.dom);
            delete this.dragProxyEl;
        }
    },
    hideEditor: function() {
        this.hide();
    },
    /**
     * Sets the record being edited.
     * @param {Sch.model.Event} record The record being edited
     */
    setRecord: function(record) {
        this.record = record;
    },
    /**
     * Returns the record being edited.
     * @return {Sch.model.Event} The record being edited
     */
    getRecord: function() {
        return this.record;
    }
});

Ext.define("Sch.widget.mixin.CustomizableRecordForm", {
    extend: 'Ext.Mixin',
    isCustomizableRecordForm: true,
    customizableFieldNames: null,
    mixinConfig: {
        id: 'customizableRecordForm',
        before: {
            loadRecord: 'beforeCustomizableRecordLoad',
            updateRecord: 'beforeCustomizableRecordUpdate'
        },
        after: {
            updateRecord: 'afterCustomizableRecordUpdate'
        }
    },
    updateAllFields: false,
    renameCustomizableFieldNamesOnce: true,
    customizableFieldNamesRenamed: 0,
    autogeneratedFieldsToRemove: null,
    setupCustomizableRecordForm: function(form, model) {
        var me = this;
        me.customizableFieldNames = {};
        if (model) {
            var modelPrototype = model.prototype;
            for (var i in modelPrototype) {
                if (i.match(/Field$/) && typeof modelPrototype[i] == 'string') {
                    me.customizableFieldNames[i] = modelPrototype[i];
                }
            }
        }
    },
    extractCustomizableFieldNames: function(event) {
        var result;
        if (event) {
            result = {};
            for (var i in this.customizableFieldNames) {
                result[i] = event[i];
            }
        }
        return result;
    },
    beforeCustomizableRecordLoad: function(event) {
        if (!this.renameCustomizableFieldNamesOnce || !this.customizableFieldNamesRenamed) {
            this.renameCustomizableFieldNames(event);
        }
    },
    // Renames form fields according to provided model.
    renameCustomizableFieldNames: function(event) {
        var newFields = this.extractCustomizableFieldNames(event);
        if (newFields) {
            this.customizableFieldNamesRenamed++;
            var form = this.getForm(),
                changed = false,
                field;
            for (var i in this.customizableFieldNames) {
                field = form.findField(this.customizableFieldNames[i]);
                // check if field name should be changed
                if (field && newFields[i] && newFields[i] != field.name) {
                    changed = true;
                    field.name = newFields[i];
                }
            }
            // if something has changed store new field names
            if (changed) {
                this.customizableFieldNames = newFields;
            }
        }
    },
    buildMissingCustomizableRecordField: function(fieldName, cfg) {
        return Ext.create(Ext.apply({
            xtype: 'hiddenfield',
            name: fieldName
        }, cfg));
    },
    addMissingCustomizableRecordFields: function() {
        var me = this,
            values = me.getForm().getFieldValues(),
            fieldNames = Ext.Object.getValues(me.customizableFieldNames),
            added = [];
        for (var i = 0; i < fieldNames.length; i++) {
            var fieldName = fieldNames[i];
            if (!values.hasOwnProperty(fieldName)) {
                added.push(me.add(me.buildMissingCustomizableRecordField(fieldName)));
            }
        }
        return added;
    },
    beforeCustomizableRecordUpdate: function() {
        var me = this;
        if (me.updateAllFields) {
            me.autogeneratedFieldsToRemove = me.addMissingCustomizableRecordFields();
        }
    },
    afterCustomizableRecordUpdate: function() {
        var me = this;
        if (me.autogeneratedFieldsToRemove) {
            var toRemove = me.autogeneratedFieldsToRemove;
            for (var i = 0; i < toRemove.length; i++) {
                me.remove(toRemove[i]);
            }
        }
    }
});

/**
 * A combobox field allowing to pick frequency in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.FrequencyComboBox', {
    extend: 'Ext.form.field.ComboBox',
    alias: 'widget.frequencycombo',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    tpl: [
        '<ul class="' + Ext.baseCSSPrefix + 'list-plain">',
        '<tpl for=".">',
        '<li class="' + Ext.baseCSSPrefix + 'boundlist-item {cls}">{text}</li>',
        '</tpl>',
        '</ul>'
    ],
    listConfig: {
        htmlEncode: true
    },
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'Daily'   : 'Daily',
     * - 'Weekly'  : 'Weekly',
     * - 'Monthly' : 'Monthly',
     * - 'Yearly'  : 'Yearly'
     */
    editable: false,
    queryMode: 'local',
    displayField: 'text',
    valueField: 'name',
    initComponent: function() {
        var me = this;
        this.emptyText = me.localizeText(this.emptyText);
        me.store = me.store || {
            fields: [
                'name',
                'text',
                'cls'
            ],
            data: me.buildOptions()
        };
        me.callParent(arguments);
    },
    buildOptions: function() {
        var me = this;
        return [
            [
                'DAILY',
                me.L('Daily')
            ],
            [
                'WEEKLY',
                me.L('Weekly')
            ],
            [
                'MONTHLY',
                me.L('Monthly')
            ],
            [
                'YEARLY',
                me.L('Yearly')
            ]
        ];
    }
});

/**
 * A combobox field displaying the recurrence by either mode: "Daily", "Weekly", "Monthly" or "Yearly" if the recurrence
 * has no other non-default settings, or "Custom..." if the recurrence has custom setting applied.
 */
Ext.define('Sch.widget.recurrence.field.RecurrenceComboBox', {
    extend: 'Sch.widget.recurrence.field.FrequencyComboBox',
    alias: 'widget.recurrencecombo',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'None'      : 'None',
     * - 'Daily'     : 'Daily',
     * - 'Weekly'    : 'Weekly',
     * - 'Monthly'   : 'Monthly',
     * - 'Yearly'    : 'Yearly',
     * - 'Custom...' : 'Custom...'
     */
    allowBlank: false,
    emptyText: 'L{None}',
    customValue: 'custom',
    splitCls: 'sch-recurrencecombo-split',
    listConfig: {
        htmlEncode: true
    },
    buildOptions: function() {
        var me = this,
            options = me.callParent(arguments);
        options.unshift([
            null,
            me.L('None')
        ]);
        options.push([
            me.customValue,
            me.L('Custom...'),
            me.splitCls
        ]);
        return options;
    },
    setRecurrence: function(recurrence) {
        var me = this;
        if (recurrence) {
            me.setValue(me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.getFrequency());
        } else {
            // `null` as a value resets the field to empty value,
            // so need to wrap it in array to select 'None' option
            me.setValue([
                null
            ]);
        }
    },
    isCustomRecurrence: function(recurrence) {
        var interval = recurrence.getInterval(),
            days = recurrence.getDays(),
            monthDays = recurrence.getMonthDays(),
            months = recurrence.getMonths();
        return Boolean(interval != 1 || (days && days.length) || (monthDays && monthDays.length) || (months && months.length));
    }
});

/**
 * Class implementing a button which text displays the associated recurrence info in a human readable form.
 */
Ext.define('Sch.widget.recurrence.LegendButton', {
    extend: 'Ext.button.Button',
    requires: [
        'Sch.data.util.recurrence.Legend'
    ],
    alias: 'widget.recurrencelegendbutton',
    recurrence: null,
    eventStartDate: null,
    initComponent: function() {
        this.callParent(arguments);
        this.setRecurrence(this.recurrence);
    },
    /**
     * Sets the recurrence to display description for.
     * @param {Sch.model.Recurrence} recurrence Recurrence model.
     */
    setRecurrence: function(recurrence) {
        this.recurrence = recurrence;
        this.refreshLegend();
    },
    setEventStartDate: function(eventStartDate) {
        this.eventStartDate = eventStartDate;
        this.refreshLegend();
    },
    refreshLegend: function() {
        var me = this,
            recurrence = me.recurrence;
        me.setText(recurrence ? Sch.data.util.recurrence.Legend.getLegend(recurrence, me.eventStartDate) : '');
    }
});

/**
 * A combobox field allowing to days positions in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.PositionsComboBox', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.StoreManager',
        'Ext.data.ArrayStore'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.positionscombobox',
    tpl: [
        '<ul class="' + Ext.baseCSSPrefix + 'list-plain">',
        '<tpl for=".">',
        '<li class="' + Ext.baseCSSPrefix + 'boundlist-item {cls}">{text}</li>',
        '</tpl>',
        '</ul>'
    ],
    splitCls: 'sch-recurrenceformpositions-split',
    listConfig: {
        htmlEncode: true
    },
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'position1'  : 'first',
     * - 'position2'  : 'second',
     * - 'position3'  : 'third',
     * - 'position4'  : 'fourth',
     * - 'position5'  : 'fifth',
     * - 'position-1' : 'last'
     */
    editable: false,
    queryMode: 'local',
    displayField: 'text',
    valueField: 'name',
    allowBlank: false,
    maxPosition: 5,
    defaultValue: '1',
    initComponent: function() {
        var me = this;
        me.value = me.value || me.defaultValue;
        me.store = me.store && Ext.data.StoreManager.lookup(me.store) || new Ext.data.ArrayStore({
            fields: [
                'name',
                'text',
                'cls'
            ],
            data: me.buildDayNumbers().concat([
                // the following lines are added to satisfy the 904_unused localization test
                // to let it know that these locales are used:
                // this.L('position-1')
                [
                    '-1',
                    me.L('position-1'),
                    me.splitCls
                ]
            ])
        });
        me.callParent(arguments);
    },
    buildDayNumbers: function() {
        var me = this,
            items = [],
            i;
        for (i = 1; i <= me.maxPosition; i++) {
            // the following lines are added to satisfy the 904_unused localization test
            // to let it know that these locales are used:
            // this.L('position1')
            // this.L('position2')
            // this.L('position3')
            // this.L('position4')
            // this.L('position5')
            items.push([
                i + '',
                me.L('position' + i)
            ]);
        }
        return items;
    },
    setValue: function(value) {
        var me = this;
        if (value && Ext.isArray(value)) {
            value = value.join(',');
        }
        // if the value has no matching option in the store we need to use default value
        if (value && this.store.findExact('name', value) !== -1) {
            this.callParent([
                value
            ]);
        } else {
            this.callParent([
                this.defaultValue
            ]);
        }
    },
    getValue: function() {
        var value = this.callParent(arguments);
        return value ? Ext.Array.map(value.split(','), function(item) {
            return parseInt(item, 10);
        }) : [];
    }
});

/**
 * A combobox field allowing to pick days for the "Monthly" and "Yearly" mode in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.DaysComboBox', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.StoreManager',
        'Ext.data.ArrayStore',
        'Ext.Date',
        'Sch.data.util.recurrence.DayRuleEncoder'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.dayscombo',
    tpl: [
        '<ul class="' + Ext.baseCSSPrefix + 'list-plain">',
        '<tpl for=".">',
        '<li class="' + Ext.baseCSSPrefix + 'boundlist-item {cls}">{text}</li>',
        '</tpl>',
        '</ul>'
    ],
    splitCls: 'sch-recurrenceformdays-split',
    listConfig: {
        htmlEncode: true,
        maxHeight: 350
    },
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'day'         : 'day',
     * - 'weekday'     : 'weekday',
     * - 'weekend day' : 'weekend day'
     */
    editable: false,
    queryMode: 'local',
    displayField: 'text',
    valueField: 'name',
    allowBlank: false,
    weekStartDay: 1,
    dayNames: null,
    defaultValue: null,
    allDaysValue: 'SU,MO,TU,WE,TH,FR,SA',
    workingDaysValue: 'MO,TU,WE,TH,FR',
    nonWorkingDaysValue: 'SU,SA',
    initComponent: function() {
        var me = this;
        me.defaultValue = me.defaultValue || me.allDaysValue;
        me.value = me.value || me.defaultValue;
        me.dayNames = me.dayNames || Ext.Date.dayNames.slice(me.weekStartDay).concat(Ext.Date.dayNames.slice(0, me.weekStartDay));
        me.store = me.store && Ext.data.StoreManager.lookup(me.store) || new Ext.data.ArrayStore({
            fields: [
                'name',
                'text',
                'cls'
            ],
            data: me.buildOptions()
        });
        me.callParent(arguments);
    },
    buildOptions: function() {
        var me = this;
        return me.buildWeekDays().concat([
            [
                me.allDaysValue,
                me.L('day'),
                me.splitCls
            ],
            [
                me.workingDaysValue,
                me.L('weekday')
            ],
            [
                me.nonWorkingDaysValue,
                me.L('weekend day')
            ]
        ]);
    },
    buildWeekDays: function() {
        var me = this;
        return Ext.Array.map(me.dayNames, function(item, index) {
            var dayIndex = (index + me.weekStartDay) % me.dayNames.length;
            // Ext.data.field.Field records
            return [
                Sch.data.util.recurrence.DayRuleEncoder.encodeDay(dayIndex),
                item
            ];
        });
    },
    setValue: function(value) {
        var me = this;
        if (value && Ext.isArray(value)) {
            //TODO Use Sch.data.util.recurrence.DayRuleEncoder to sort values
            value = value.join(',');
        }
        // if the value has no matching option in the store we need to use default value
        if (value && this.store.findExact('name', value) !== -1) {
            this.callParent([
                value
            ]);
        } else {
            this.callParent([
                this.defaultValue
            ]);
        }
    },
    getValue: function() {
        var value = this.callParent(arguments);
        return value ? value.split(',') : [];
    }
});

/**
 * A segmented button field allowing to pick days for the "Weekly" mode in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.DaysSegmentedButton', {
    extend: 'Sch.field.SegmentedButton',
    alias: 'widget.dayssegmentedbutton',
    allowBlank: false,
    margin: '0 0 10 0',
    weekStartDay: 0,
    initComponent: function() {
        var me = this;
        me.dayNames = Ext.Date.dayNames.slice(me.weekStartDay).concat(Ext.Date.dayNames.slice(0, me.weekStartDay));
        me.items = me.buildItems();
        me.callParent(arguments);
    },
    buildItems: function() {
        var me = this;
        return Ext.Array.map(me.dayNames, function(item, index) {
            var dayIndex = (index + me.weekStartDay) % me.dayNames.length;
            // Ext.button.Button config
            return {
                text: item.substring(0, 3),
                value: Sch.data.util.recurrence.DayRuleEncoder.encodeDay(dayIndex)
            };
        });
    }
});

/**
 * A segmented button field allowing to pick month days for the "Monthly" mode in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.MonthDaysSegmentedButton', {
    extend: 'Sch.field.SegmentedButton',
    alias: 'widget.monthdayssegmentedbutton',
    allowBlank: false,
    margin: '0 0 10 0',
    columns: 7,
    initComponent: function() {
        var me = this;
        me.items = me.buildItems();
        me.callParent(arguments);
    },
    buildItems: function() {
        var items = [],
            i;
        for (i = 1; i <= Ext.Date.MAX_DAYS_IN_MONTH; i++) {
            // button config
            items.push({
                text: i + '',
                value: i
            });
        }
        return items;
    }
});

/**
 * A segmented button field allowing to pick months for the "Yearly" mode in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.MonthsSegmentedButton', {
    extend: 'Sch.field.SegmentedButton',
    alias: 'widget.monthssegmentedbutton',
    allowBlank: false,
    margin: '0 0 10 0',
    columns: 4,
    initComponent: function() {
        var me = this;
        me.items = me.buildItems();
        me.callParent(arguments);
    },
    buildItems: function() {
        var me = this;
        return Ext.Array.map(Ext.Date.monthNames, function(item, index) {
            // button config
            return {
                text: item.substring(0, 3),
                value: index + 1
            };
        });
    }
});
// 1-based

/**
 * A combobox field allowing to choose stop condition for the recurrence in the {@link Sch.widget.recurrence.Dialog recurrence dialog}.
 */
Ext.define('Sch.widget.recurrence.field.StopConditionComboBox', {
    extend: 'Ext.form.field.ComboBox',
    alias: 'widget.stopconditioncombo',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'Never'   : 'Never',
     * - 'After'   : 'After',
     * - 'On date' : 'On date'
     */
    editable: false,
    queryMode: 'local',
    displayField: 'text',
    valueField: 'name',
    allowBlank: false,
    listConfig: {
        htmlEncode: true
    },
    initComponent: function() {
        var me = this;
        me.store = me.store || {
            fields: [
                'name',
                'text'
            ],
            data: me.buildOptions()
        };
        me.addCls('sch-combo-with-no-value');
        me.callParent(arguments);
    },
    buildOptions: function() {
        var me = this;
        return [
            [
                null,
                me.L('Never')
            ],
            [
                'count',
                me.L('After')
            ],
            [
                'date',
                me.L('On date')
            ]
        ];
    },
    setRecurrence: function(recurrence) {
        var value = null;
        if (recurrence.getEndDate()) {
            value = 'date';
        } else if (recurrence.getCount()) {
            value = 'count';
        }
        // `null` as a value resets the field to empty value,
        // so need to wrap it in array to select 'Never' option
        this.setValue([
            value
        ]);
    }
});

/**
 * A special form panel used to edit {@link Sch.model.Recurrence recurrence model} data.
 * The form is used by {@link Sch.widget.recurrence.Dialog} which includes it.
 *
 * The form dynamically changes its set of visible fields depending on {@link #frequencyField frequency} chosen.
 *
 * It inherits from {@link Ext.form.Panel} so you can define any fields and use any layout you want.
 */
Ext.define('Sch.widget.recurrence.Form', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.layout.container.HBox',
        'Ext.layout.container.VBox',
        'Ext.form.field.Display',
        'Ext.form.field.Number',
        'Ext.form.field.Radio',
        'Sch.model.Recurrence',
        'Sch.widget.recurrence.field.FrequencyComboBox',
        'Sch.widget.recurrence.field.PositionsComboBox',
        'Sch.widget.recurrence.field.DaysComboBox',
        'Sch.widget.recurrence.field.DaysSegmentedButton',
        'Sch.widget.recurrence.field.MonthDaysSegmentedButton',
        'Sch.widget.recurrence.field.MonthsSegmentedButton',
        'Sch.widget.recurrence.field.StopConditionComboBox'
    ],
    mixins: [
        'Sch.widget.mixin.CustomizableRecordForm',
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.recurrenceform',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    trackResetOnLoad: true,
    updateAllFields: true,
    weekStartDay: 1,
    dateFormat: 'Y-m-d',
    radioFieldName: 'radio',
    checkboxFieldName: 'checkbox',
    recurrenceModel: null,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'Frequency'           : 'Frequency',
     * - 'Every'               : 'Every',
     * - 'DAILYintervalUnit'   : 'day(s)',
     * - 'WEEKLYintervalUnit'  : 'week(s) on:',
     * - 'MONTHLYintervalUnit' : 'month(s)',
     * - 'YEARLYintervalUnit'  : 'year(s) in:',
     * - 'Each'                : 'Each',
     * - 'On the'              : 'On the',
     * - 'End repeat'          : 'End repeat',
     * - 'time(s)'             : 'time(s)'
     */
    /**
     * Configuration for {@link #property-frequencyField}.
     * @cfg {Object/Sch.widget.recurrence.field.FrequencyComboBox} frequencyField
     */
    /**
     * A combobox field allowing to pick the {@link Sch.model.Recurrence#Frequency recurrence frequency}.
     * @property {Sch.widget.recurrence.field.FrequencyComboBox}
     */
    frequencyField: null,
    /**
     * Configuration for {@link #property-intervalField}.
     * @cfg {Object/Ext.form.field.Number} intervalField
     */
    /**
     * Number field allowing to edit the {@link Sch.model.Recurrence#Interval recurrence interval}.
     * @property {Ext.form.field.Number}
     */
    intervalField: null,
    intervalUnit: null,
    /**
     * Configuration for {@link #property-daysButtonField}.
     * @cfg {Object/Sch.widget.recurrence.field.DaysSegmentedButton} daysButtonField
     */
    /**
     * Segmented button field allowing to edit the {@link Sch.model.Recurrence#Days recurrence days}.
     * @property {Sch.widget.recurrence.field.DaysSegmentedButton}
     */
    daysButtonField: null,
    /**
     * Configuration for {@link #property-monthdaysButtonField}.
     * @cfg {Object/Sch.widget.recurrence.field.MonthDaysSegmentedButton} monthdaysButtonField
     */
    /**
     * Segmented button field allowing to edit the {@link Sch.model.Recurrence#MonthDays recurrence month days}.
     * @property {Sch.widget.recurrence.field.MonthDaysSegmentedButton}
     */
    monthdaysButtonField: null,
    monthDaysRadioField: null,
    /**
     * Configuration for {@link #property-monthsButtonField}.
     * @cfg {Object/Sch.widget.recurrence.field.MonthsSegmentedButton} monthsButtonField
     */
    /**
     * Segmented button field allowing to edit the {@link Sch.model.Recurrence#MonthDays recurrence months}.
     * @property {Sch.widget.recurrence.field.MonthsSegmentedButton}
     */
    monthsButtonField: null,
    positionAndDayRadioField: null,
    positionAndDayCheckboxField: null,
    stopRecurrenceField: null,
    /**
     * Configuration for {@link #property-countField}.
     * @cfg {Object/Ext.form.field.Number} countField
     */
    /**
     * Number field allowing to edit the {@link Sch.model.Recurrence#Count recurrence count}.
     * @property {Ext.form.field.Number}
     */
    countField: null,
    countUnit: null,
    /**
     * Configuration for {@link #property-endDateField}.
     * @cfg {Object/Ext.form.field.Date} endDateField
     */
    /**
     * Date field allowing to edit the {@link Sch.model.Recurrence#EndDate recurrence end date}.
     * @property {Ext.form.field.Date}
     */
    endDateField: null,
    /**
     * Configuration for {@link #property-positionsCombo}.
     * @cfg {Object/Sch.widget.recurrence.field.PositionsComboBox} positionsCombo
     */
    /**
     * Combobox field allowing to edit the {@link Sch.model.Recurrence#Positions recurrence positions field}.
     * The field is displayed for "Monthly" and "Yearly" frequency values.
     * @property {Sch.widget.recurrence.field.PositionsComboBox}
     */
    positionsCombo: null,
    /**
     * Configuration for {@link #property-daysCombo}.
     * @cfg {Object/Sch.widget.recurrence.field.DaysComboBox} daysCombo
     */
    /**
     * Combobox field allowing to edit the {@link Sch.model.Recurrence#Days recurrence days}.
     * The field is displayed for "Monthly" and "Yearly" frequency values.
     * @property {Sch.widget.recurrence.field.DaysComboBox}
     */
    daysCombo: null,
    intervalContainer: null,
    positionDayContainer: null,
    countFieldContainer: null,
    initComponent: function() {
        var me = this;
        me.recurrenceModel = me.recurrenceModel || Sch.model.Recurrence;
        me.setupCustomizableRecordForm(me, me.recurrenceModel);
        me.items = me.buildItems();
        me.callParent(arguments);
    },
    buildItems: function() {
        var me = this;
        if (!me.frequencyField || !me.frequencyField.isInstance) {
            me.frequencyField = Ext.create(Ext.apply({
                xtype: 'frequencycombo',
                name: me.customizableFieldNames.frequencyField,
                fieldLabel: me.L('Frequency')
            }, me.frequencyField));
            me.mon(me.frequencyField, 'change', me.onFrequencyFieldChange, me);
        }
        if (!me.intervalField || !me.intervalField.isInstance) {
            me.intervalField = Ext.create(Ext.apply({
                xtype: 'numberfield',
                name: me.customizableFieldNames.intervalField,
                minValue: 1,
                width: 85,
                margin: '0 5 0 0',
                allowBlank: false
            }, me.intervalField));
        }
        if (!me.intervalUnit || !me.intervalUnit.isInstance) {
            me.intervalUnit = Ext.create(Ext.apply({
                xtype: 'displayfield',
                submitValue: false
            }, me.intervalUnit));
        }
        if (!me.daysButtonField || !me.daysButtonField.isInstance) {
            me.daysButtonField = Ext.create(Ext.apply({
                xtype: 'dayssegmentedbutton',
                name: me.customizableFieldNames.daysField,
                forFrequency: 'WEEKLY'
            }, me.daysButtonField));
        }
        // the radio button enabling "monthdaysButtonField" in MONTHLY mode
        if (!me.monthDaysRadioField || !me.monthDaysRadioField.isInstance) {
            me.monthDaysRadioField = Ext.create(Ext.apply({
                xtype: 'radiofield',
                name: me.radioFieldName,
                submitValue: false,
                forFrequency: 'MONTHLY',
                boxLabel: this.L('Each'),
                handler: me.togglePositionAndDayFields,
                scope: me
            }, me.monthDaysRadioField));
        }
        if (!me.monthdaysButtonField || !me.monthdaysButtonField.isInstance) {
            me.monthdaysButtonField = Ext.create(Ext.apply({
                xtype: 'monthdayssegmentedbutton',
                name: me.customizableFieldNames.monthDaysField,
                forFrequency: 'MONTHLY'
            }, me.monthdaysButtonField));
        }
        if (!me.monthsButtonField || !me.monthsButtonField.isInstance) {
            me.monthsButtonField = Ext.create(Ext.apply({
                xtype: 'monthssegmentedbutton',
                name: me.customizableFieldNames.monthsField,
                forFrequency: 'YEARLY'
            }, me.monthsButtonField));
        }
        // the radio button enabling positions & days combos in MONTLY mode
        if (!me.positionAndDayRadioField || !me.positionAndDayRadioField.isInstance) {
            me.positionAndDayRadioField = Ext.create(Ext.apply({
                xtype: 'radiofield',
                name: me.radioFieldName,
                submitValue: false,
                forFrequency: 'MONTHLY',
                boxLabel: this.L('On the'),
                handler: me.togglePositionAndDayFields,
                scope: me
            }, me.positionAndDayRadioField));
        }
        // the checkbox enabling positions & days combos in YEARLY mode
        if (!me.positionAndDayCheckboxField || !me.positionAndDayCheckboxField.isInstance) {
            me.positionAndDayCheckboxField = Ext.create(Ext.apply({
                xtype: 'checkbox',
                // Checkboxes and Radio buttons have their initDefaultName functions overridden to Ext.emptyFn,
                // so `name` is required here, otherwise field.getModelData() returns {undefined : true}
                name: me.checkboxFieldName,
                submitValue: false,
                forFrequency: 'YEARLY',
                boxLabel: this.L('On the'),
                handler: me.togglePositionAndDayFields,
                scope: me
            }, me.positionAndDayCheckboxField));
        }
        if (!me.stopRecurrenceField || !me.stopRecurrenceField.isInstance) {
            me.stopRecurrenceField = Ext.create(Ext.apply({
                xtype: 'stopconditioncombo',
                submitValue: false,
                fieldLabel: me.L('End repeat'),
                value: [
                    null
                ]
            }, me.stopRecurrenceField));
            me.mon(me.stopRecurrenceField, 'change', me.onStopRecurrenceFieldChange, me);
        }
        if (!me.countField || !me.countField.isInstance) {
            me.countField = Ext.create(Ext.apply({
                xtype: 'numberfield',
                name: me.customizableFieldNames.countField,
                minValue: 2,
                allowBlank: false,
                flex: 1,
                margin: '0 5 0 0',
                disabled: true
            }, me.countField));
        }
        if (!me.countUnit || !me.countUnit.isInstance) {
            me.countUnit = Ext.create(Ext.apply({
                xtype: 'displayfield',
                value: me.L('time(s)'),
                submitValue: false,
                flex: 1,
                disabled: true
            }, me.countUnit));
        }
        if (!me.countFieldContainer || !me.countFieldContainer.isInstance) {
            me.countFieldContainer = Ext.create(Ext.apply({
                xtype: 'fieldcontainer',
                layout: 'hbox',
                margin: 0,
                hideEmptyLabel: false,
                hidden: true,
                items: [
                    me.countField,
                    me.countUnit
                ]
            }, me.countFieldContainer));
        }
        if (!me.endDateField || !me.endDateField.isInstance) {
            me.endDateField = Ext.create(Ext.apply({
                xtype: 'datefield',
                name: me.customizableFieldNames.endDateField,
                hidden: true,
                disabled: true,
                hideEmptyLabel: false,
                allowBlank: false,
                startDay: me.weekStartDay,
                format: me.dateFormat,
                altFormats: ''
            }, me.endDateField));
        }
        if (!me.intervalContainer || !me.intervalContainer.isInstance) {
            me.intervalContainer = Ext.create(Ext.apply({
                xtype: 'fieldcontainer',
                layout: 'hbox',
                fieldLabel: me.L('Every'),
                margin: 0,
                items: [
                    me.intervalField,
                    me.intervalUnit
                ]
            }, me.intervalContainer));
        }
        if (!me.positionsCombo || !me.positionsCombo.isInstance) {
            me.positionsCombo = Ext.create(Ext.apply({
                xtype: 'positionscombobox',
                name: me.customizableFieldNames.positionsField,
                forFrequency: 'MONTHLY|YEARLY',
                flex: 1,
                margin: '0 5 0 0'
            }, me.positionsCombo));
        }
        if (!me.daysCombo || !me.daysCombo.isInstance) {
            me.daysCombo = Ext.create(Ext.apply({
                xtype: 'dayscombo',
                // Need to set value manually since `name` should be unique within one form
                name: me.customizableFieldNames.daysField,
                forFrequency: 'MONTHLY|YEARLY',
                weekStartDay: me.weekStartDay,
                flex: 1
            }, me.daysCombo));
        }
        if (!me.positionDayContainer || !me.positionDayContainer.isInstance) {
            me.positionDayContainer = Ext.create(Ext.apply({
                xtype: 'fieldcontainer',
                layout: 'hbox',
                items: [
                    me.positionsCombo,
                    me.daysCombo
                ]
            }, me.positionDayContainer));
        }
        return [
            me.frequencyField,
            me.intervalContainer,
            me.daysButtonField,
            me.monthDaysRadioField,
            me.monthdaysButtonField,
            me.monthsButtonField,
            me.positionAndDayRadioField,
            me.positionAndDayCheckboxField,
            me.positionDayContainer,
            me.stopRecurrenceField,
            me.countFieldContainer,
            me.endDateField
        ];
    },
    loadRecord: function(record) {
        var me = this,
            result = this.callParent(arguments),
            event = record.getEvent(),
            startDate = event && event.getStartDate();
        // Set value manually since `name` is not unique within the form
        me.daysCombo.setValue(record.getDays());
        if (startDate) {
            if (!record.getDays() || !record.getDays().length) {
                this.daysButtonField.setValue([
                    Sch.data.util.recurrence.DayRuleEncoder.encodeDay(startDate.getDay())
                ]);
            }
            if (!record.getMonthDays() || !record.getMonthDays().length) {
                this.monthdaysButtonField.setValue(startDate.getDate());
            }
            if (!record.getMonths() || !record.getMonths().length) {
                this.monthsButtonField.setValue(startDate.getMonth() + 1);
            }
        }
        var isDayAndPosition = Boolean(record.getDays() && record.getPositions());
        me.monthDaysRadioField.setValue(!isDayAndPosition);
        me.positionAndDayRadioField.setValue(isDayAndPosition);
        me.positionAndDayCheckboxField.setValue(isDayAndPosition);
        me.stopRecurrenceField.setRecurrence(record);
        return result;
    },
    toggleStopFields: function() {
        var me = this;
        switch (me.stopRecurrenceField.getValue()) {
            case 'count':
                me.countFieldContainer.show();
                me.countField.enable();
                me.countUnit.enable();
                me.endDateField.hide();
                me.endDateField.disable();
                break;
            case 'date':
                me.countFieldContainer.hide();
                me.countField.disable();
                me.countUnit.disable();
                me.endDateField.show();
                me.endDateField.enable();
                break;
            default:
                me.countFieldContainer.hide();
                me.endDateField.hide();
                me.countField.disable();
                me.countUnit.disable();
                me.endDateField.disable();
        }
    },
    togglePositionAndDayFields: function() {
        var me = this,
            frequency = me.frequencyField.getValue(),
            positionAndDayDisabled = frequency == 'MONTHLY' ? !me.positionAndDayRadioField.getValue() : !me.positionAndDayCheckboxField.getValue();
        // toggle day & positions comboboxes
        me.daysCombo.setDisabled(positionAndDayDisabled);
        me.positionsCombo.setDisabled(positionAndDayDisabled);
        // month days buttons should be disabled if days are enabled
        if (frequency == 'MONTHLY') {
            me.monthdaysButtonField.setDisabled(!me.monthDaysRadioField.getValue());
        }
    },
    onFrequencyFieldChange: function(field, frequency) {
        var me = this,
            items = me.query('[forFrequency]');
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (item.forFrequency.indexOf(frequency) > -1) {
                item.show();
                item.enable();
            } else {
                item.hide();
                item.disable();
            }
        }
        // the following lines are added to satisfy the 904_unused localization test
        // to let it know that these locales are used:
        // this.L('DAILYintervalUnit')
        // this.L('WEEKLYintervalUnit')
        // this.L('MONTHLYintervalUnit')
        // this.L('YEARLYintervalUnit')
        me.intervalUnit.setValue(me.L(frequency + 'intervalUnit'));
        me.togglePositionAndDayFields();
        me.toggleStopFields();
    },
    onStopRecurrenceFieldChange: function(field, value) {
        this.toggleStopFields();
    }
});

/**
 * A class implementing dialog window to edit {@link Sch.model.Recurrence Recurrence model}.
 * The dialog contains {@link Sch.widget.recurrence.Form Recurrence form} and Save/Cancel buttons.
 * Before showing the dialog need to call {@link #loadRecord} to set {@link Sch.model.Recurrence Recurrence model} first.
 * The {@link Sch.widget.recurrence.Form form} fields will be loaded and shown accordingly with the model data.
 *
 * {@img scheduler/images/recurrence-dialog1.png 2x}
 *
 * The class extends Ext.window.Window so its normal configs are applicable.
 */
Ext.define('Sch.widget.recurrence.Dialog', {
    extend: 'Ext.window.Window',
    requires: [
        'Ext.button.Button',
        'Sch.model.Recurrence',
        'Sch.widget.recurrence.Form'
    ],
    alias: 'widget.recurrencedialog',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    border: false,
    width: 400,
    resizable: false,
    modal: true,
    recurrenceDialogCls: 'sch-recurrencedialog',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - 'Repeat event' : 'Repeat event',
     * - 'Cancel'       : 'Cancel',
     * - 'Save'         : 'Save'
     */
    weekStartDay: 1,
    dateFormat: 'Y-m-d',
    /**
     * Configuration for {@link #property-form}.
     * @cfg {Object/Sch.widget.recurrence.Form} form
     */
    /**
     * Form panel displaying the loaded {@link Sch.model.Recurrence recurrence} fields.
     * @property {Sch.widget.recurrence.Form}
     */
    form: null,
    recurrenceModel: null,
    /**
     * @cfg {Function}                     saveHandler            Function to call on "Save" button click.
     * @cfg {Sch.widget.recurrence.Dialog} saveHandler.this       The dialog instance.
     * @cfg {Sch.model.Recurrence}         saveHandler.recurrence Recurrence being edited.
     */
    saveHandler: null,
    /**
     * @cfg {Function}                     cancelHandler            Function to call on "Cancel" button click.
     * @cfg {Sch.widget.recurrence.Dialog} cancelHandler.this       The dialog instance.
     * @cfg {Sch.model.Recurrence}         cancelHandler.recurrence Recurrence being edited.
     */
    cancelHandler: null,
    /**
     * Scope for {@link #saveHandler} and {@link #cancelHandler} function call.
     * @cfg {Mixed}
     */
    scope: null,
    title: 'L{Repeat event}',
    initComponent: function() {
        var me = this;
        me.addCls(me.recurrenceDialogCls);
        me.title = me.localizeText(me.title);
        me.recurrenceModel = me.recurrenceModel || Sch.model.Recurrence;
        if (!me.form || !me.form.isInstance) {
            me.form = Ext.create(Ext.apply({
                xtype: 'recurrenceform',
                padding: '10 10 0 10',
                weekStartDay: me.weekStartDay,
                dateFormat: me.dateFormat,
                recurrenceModel: me.recurrenceModel,
                border: false
            }, me.form));
        }
        me.items = [
            me.form
        ];
        me.buttons = me.buttons || [
            {
                xtype: 'button',
                text: me.L('Save'),
                scope: me,
                handler: me.onSaveClick
            },
            {
                xtype: 'button',
                text: me.L('Cancel'),
                scope: me,
                handler: me.onCancelClick
            }
        ];
        me.callParent(arguments);
    },
    onSaveClick: function() {
        var me = this;
        if (me.saveHandler) {
            me.saveHandler.call(me.scope || me, me, me.getRecord());
        } else {
            me.updateRecord();
            me.close();
        }
    },
    onCancelClick: function() {
        var me = this;
        if (me.cancelHandler) {
            me.cancelHandler.call(me.scope || me, me, me.getRecord());
        } else {
            me.close();
        }
    },
    /**
     * Loads a recurrence model to the dialog.
     * @param  {Sch.model.Recurrence} record Recurrence model.
     * @return {Sch.widget.recurrence.Form} The form.
     */
    loadRecord: function(record) {
        return this.form.loadRecord.apply(this.form, arguments);
    },
    /**
     * Updates the provided recurrence model with the contained form data.
     * If recurrence model is not provided updates the last loaded recurrence model.
     * @return {Sch.widget.recurrence.Form} The form.
     */
    updateRecord: function(record) {
        return this.form.updateRecord.apply(this.form, arguments);
    },
    /**
     * Returns the loaded recurrence model.
     * @return  {Sch.model.Recurrence} Loaded recurrence model.
     */
    getRecord: function(record) {
        return this.form.getRecord.apply(this.form, arguments);
    },
    getFloatingComponents: function() {
        var me = this,
            result = [],
            pickerFields = me.query('pickerfield'),
            i;
        // HACK to render all pickers, so the query for floating components will return full result
        for (i = 0; i < pickerFields.length; i++) {
            var pickerField = pickerFields[i];
            pickerField.getPicker();
        }
        var floatingComponents = me.query('[floating]');
        if (Ext.isArray(floatingComponents)) {
            result = result.concat(floatingComponents);
        }
        return result;
    }
});

/**
 * This mixin class provides recurring events functionality to the {@link Sch.widget.EventEditor event editor} component.
 */
Ext.define("Sch.widget.recurrence.EventEditorMixin", {
    extend: 'Ext.Mixin',
    requires: [
        'Ext.form.field.Hidden',
        'Sch.widget.recurrence.field.RecurrenceComboBox',
        'Sch.widget.recurrence.LegendButton',
        'Sch.widget.recurrence.Dialog',
        'Sch.widget.RecurrenceConfirmation'
    ],
    isRecurrableEventEditor: true,
    /**
     * The recurrence rule field. A hidden field mapped to the event {@link Sch.model.Event#RecurrenceRule recurrence rule} field.
     * @property {Ext.form.field.Hidden} recurrenceRule
     */
    /**
     * The {@link #property-recurrenceRule recurrence rule field} configuration object.
     * @cfg {Object}
     */
    recurrenceRule: null,
    /**
     * The recurrence combobox field. The field allows to choose if the event should repeat and if yes - how often (every day, week, month or year).
     * @property {Sch.widget.recurrence.field.RecurrenceComboBox} recurrenceCombo
     */
    /**
     * The {@link #property-recurrenceCombo recurrence combobox field} configuration object.
     * @cfg {Object}
     */
    recurrenceCombo: null,
    /**
     * The recurrence button opening the recurrence dialog. The button text displays the event recurrence settings in a human readable form.
     * @property {Sch.widget.recurrence.LegendButton} recurrenceLegendButton
     */
    /**
     * The {@link #property-recurrenceLegendButton recurrence button} configuration object.
     * @cfg {Object}
     */
    recurrenceLegendButton: null,
    recurrenceDialog: null,
    config: {
        /**
         * Provide `false` to disable recurrence related fields.
         *
         * **Note:** If you want to turn off the recurring events feature completely,
         * please take a look at {@link Sch.panel.SchedulerGrid#recurringEvents Scheduler grid config}
         * @cfg {Boolean}
         */
        recurringEvents: true
    },
    onClassMixedIn: function(targetClass) {
        Ext.override(targetClass, {
            getDefaultFields: function() {
                var result = this.callParent(arguments) || [];
                return result.concat(this.getRecurrableEventDefaultFields());
            },
            getFloatingComponents: function() {
                var result = this.callParent(arguments) || [];
                return result.concat(this.getRecurrableEventFloatingComponents());
            }
        });
    },
    setupRecurrableEventEditorMixin: function(eventEditor) {
        var me = this;
        me.mon(eventEditor, {
            loadevent: me.onRecurrableEventLoad,
            beforeeventdelete: me.onRecurrableEventBeforeDelete,
            beforeeventsave: me.onRecurrableEventBeforeSave,
            destroy: me.onEditorDestroy,
            scope: eventEditor,
            priority: -100
        });
    },
    onEditorDestroy: function() {
        this.recurrenceDialog && this.recurrenceDialog.destroy();
    },
    getRecurrableEventDefaultFields: function() {
        var me = this,
            result = [];
        if (me.recurringEvents !== false) {
            if (!me.recurrenceRule || !me.recurrenceRule.isInstance) {
                me.recurrenceRule = Ext.create(Ext.apply({
                    xtype: 'hiddenfield',
                    name: me.customizableFieldNames.recurrenceRuleField
                }, me.recurrenceRule));
            }
            if (!me.recurrenceCombo || !me.recurrenceCombo.isInstance) {
                me.recurrenceCombo = Ext.create(Ext.apply({
                    xtype: 'recurrencecombo',
                    fieldLabel: me.L('Repeat'),
                    value: [
                        null
                    ]
                }, me.recurrenceCombo));
                me.mon(me.recurrenceCombo, 'change', me.onRecurrenceComboChange, me);
            }
            if (!me.recurrenceLegendButton || !me.recurrenceLegendButton.isInstance) {
                me.recurrenceLegendButton = Ext.create(Ext.apply({
                    xtype: 'recurrencelegendbutton',
                    hideEmptyLabel: false,
                    handler: me.onRecurrenceLegendClick,
                    scope: me
                }, me.recurrenceLegendButton));
            }
            result.push(me.recurrenceRule, me.recurrenceCombo, me.recurrenceLegendButton);
            me.recurrenceDialog = Ext.create({
                xtype: 'recurrencedialog',
                weekStartDay: me.weekStartDay,
                dateFormat: me.dateFormat,
                closeAction: 'hide',
                saveHandler: me.recurrenceDialogSaveHandler,
                cancelHandler: me.recurrenceDialogCancelHandler,
                scope: me
            });
            me.startDateField && me.mon(me.startDateField, 'change', me.onRecurrableEventStartDateChange, me);
        }
        return result;
    },
    updateRecurringEvents: function(enabled) {
        var me = this;
        if (enabled) {
            if (me.recurrenceCombo) {
                me.recurrenceCombo.show();
            }
            if (me.recurrenceLegendButton) {
                me.recurrenceLegendButton.show();
            }
        } else {
            if (me.recurrenceCombo) {
                me.recurrenceCombo.hide();
            }
            if (me.recurrenceLegendButton) {
                me.recurrenceLegendButton.hide();
            }
        }
    },
    onRecurrableEventLoad: function(eventEditor, event, readOnly) {
        var me = this;
        me.recurrence = null;
        if (event.isRecurrableEvent && me.getRecurringEvents()) {
            var recurrence = event.isOccurrence() ? event.getRecurringEvent().getRecurrence() : event.getRecurrence();
            if (!event.getRecurrenceRule()) {
                me.recurrenceRule.setValue(null);
            }
            if (me.recurrenceCombo) {
                me.recurrenceCombo.show();
                me.recurrenceCombo.setRecurrence(recurrence);
            }
            if (me.recurrenceLegendButton) {
                me.recurrenceLegendButton.setRecurrence(recurrence);
                if (recurrence) {
                    me.recurrenceLegendButton.show();
                } else {
                    me.recurrenceLegendButton.hide();
                }
            }
        } else {
            me.recurrenceCombo && me.recurrenceCombo.hide();
            me.recurrenceLegendButton && me.recurrenceLegendButton.hide();
        }
    },
    onRecurrableEventBeforeDelete: function(eventEditor, eventRecord, continueFn) {
        var me = this;
        if (eventRecord.isRecurrableEvent && me.getRecurringEvents() && (eventRecord.isRecurring() || eventRecord.isOccurrence())) {
            Sch.widget.RecurrenceConfirmation.show({
                actionType: 'delete',
                eventRecord: eventRecord,
                changerFn: continueFn
            });
            return false;
        }
    },
    onRecurrableEventBeforeSave: function(eventEditor, eventRecord, values, continueFn) {
        var me = this;
        if (eventRecord.isRecurrableEvent && me.getRecurringEvents() && (eventRecord.isRecurring() || eventRecord.isOccurrence())) {
            Sch.widget.RecurrenceConfirmation.show({
                actionType: 'update',
                eventRecord: eventRecord,
                values: values,
                changerFn: continueFn
            });
            return false;
        }
    },
    getRecurrableEventFloatingComponents: function() {
        var me = this,
            result = [];
        result.push(Sch.widget.RecurrenceConfirmation);
        if (me.recurrenceDialog) {
            result.push(me.recurrenceDialog);
            var recurrenceDialogFloatingComponents = me.recurrenceDialog.getFloatingComponents && me.recurrenceDialog.getFloatingComponents();
            if (Ext.isArray(recurrenceDialogFloatingComponents)) {
                result = result.concat(recurrenceDialogFloatingComponents);
            }
        }
        return result;
    },
    onRecurrenceLegendClick: function() {
        this.showRecurrenceDialog();
    },
    makeRecurrence: function(rule) {
        var event = this.getEventRecord(),
            recurrence = event.getRecurrence(),
            eventCopy = event.copy(null);
        if (!rule && recurrence) {
            recurrence = recurrence.copy(null);
        } else {
            recurrence = new event.recurrenceModel({
                rule: rule
            });
        }
        // bind cloned recurrence to the cloned event
        recurrence.setEvent(eventCopy);
        // update cloned event w/ start date from the UI field
        eventCopy.setStartDate(this.getStartDateValue());
        recurrence.suspendEventNotifying();
        return recurrence;
    },
    showRecurrenceDialog: function() {
        var event = this.eventRecord;
        if (this.recurrenceDialog && event && event.isRecurrableEvent) {
            this.captureRecurrence();
            this.recurrence = this.recurrence || this.makeRecurrence();
            // update the cloned recurrence w/ up to date start date value
            this.recurrence.getEvent().setStartDate(this.getStartDateValue());
            this.recurrenceDialog.loadRecord(this.recurrence);
            this.recurrenceDialog.show();
        }
    },
    captureRecurrence: function() {
        var rule = this.recurrenceRule.getValue();
        this.capturedRecurrence = rule ? this.makeRecurrence(rule) : null;
    },
    getCapturedRecurrence: function() {
        return this.capturedRecurrence;
    },
    onRecurrenceComboChange: function(field, value) {
        // if we are not loading record
        if (!this.loadingRecord) {
            if (value == field.customValue) {
                // if user picked "Custom" - show recurrence dialog (if we are not in the middle of changes applying)
                if (!this.inOnRecurrenceUpdate)  {
                    this.showRecurrenceDialog();
                }
                
            } else {
                this.onRecurrenceUpdate(value && this.makeRecurrence('FREQ=' + value) || null);
            }
        }
    },
    onRecurrenceUpdate: function(recurrence) {
        var me = this;
        if (!me.inOnRecurrenceUpdate) {
            me.inOnRecurrenceUpdate = true;
            // keep recurrence instance
            me.recurrence = recurrence;
            // update recurrence rule field if it's changed as result of user actions
            if (!me.loadingRecord) {
                me.recurrenceRule.setValue(recurrence ? recurrence.getRule() : null);
            }
            // pick corresponding options (frequency/"None" or "Custom") in combobox
            if (me.recurrenceCombo) {
                me.recurrenceCombo.setRecurrence(recurrence);
            }
            // update the recurrence legend
            if (me.recurrenceLegendButton) {
                me.recurrenceLegendButton.setRecurrence(recurrence);
                if (recurrence) {
                    me.recurrenceLegendButton.show();
                } else {
                    me.recurrenceLegendButton.hide();
                }
            }
            me.inOnRecurrenceUpdate = false;
        }
    },
    recurrenceDialogSaveHandler: function(dialog, recurrence) {
        // apply changes to the kept recurrence
        dialog.updateRecord(recurrence);
        // update the recurrence related UI
        this.onRecurrenceUpdate(recurrence);
        dialog.close();
    },
    recurrenceDialogCancelHandler: function(dialog) {
        var recurrence = this.getCapturedRecurrence();
        // update the recurrence related UI
        this.onRecurrenceUpdate(recurrence);
        dialog.close();
    },
    onRecurrableEventStartDateChange: function(field, newValue) {
        if (this.recurrenceLegendButton) {
            if (Ext.isDate(newValue))  {
                this.recurrenceLegendButton.setEventStartDate(newValue);
            }
            
        }
    }
});

/**
 * A widget (ptype = 'scheduler_eventeditorform') used to edit event start/end dates as well as any meta data. It inherits from {@link Ext.form.FormPanel} so you can define any fields and use any layout you want.
 *
 * {@img scheduler/images/event-editor.png 2x}
 *
 * Normally, this widget shows the same form for all events. However you can show different forms for different event types. To do that:
 *
 * - the event type is supposed to be provided as the value of the `EventType` field in the event model.
 * - in the {@link #fieldsPanelConfig} provide a container with a card layout. The children of that container should be the forms which will be used to edit different
 * event types
 * - each such form should contain `EventType` configuration option, matching to the appropriate event type.
 * - the default form containing the start date, start time, end date, end time and name fields is always shared among all forms.
 * - this whole behavior can be disabled with the `dynamicForm : false` option.
 *
 * The overall picture will look like:
 *
 * ```javascript
 * fieldsPanelConfig : {
 *     xtype  : 'container',
 *     layout : 'card',
 *     items  : [
 *         // form for "Meeting" EventType
 *         {
 *             EventType : 'Meeting',
 *             xtype     : 'form',
 *             items     : [
 *                 ...
 *             ]
 *         },
 *         // eof form for "Meeting" EventType
 *
 *         // form for "Appointment" EventType
 *         {
 *             EventType : 'Appointment',
 *             xtype     : 'form',
 *             items     : [
 *                 ...
 *             ]
 *         }
 *         // eof form for "Appointment" EventType
 *     ]
 * }
 * ```
 *
 * Note, that you can customize the start date, start time, end date and end time fields with appropriate configuration options: {@link #startDateConfig}, {@link #startTimeConfig},  {@link #endDateConfig}, {@link #endTimeConfig}
 *
 * ```javascript
 * var eventEditor = Ext.create('Sch.widget.EventEditor', {
 *     ...
 *     startTimeConfig : {
 *         minValue : '08:00',
 *         maxValue : '18:00'
 *     },
 *     ...
 * });
 * ```
 */
Ext.define("Sch.widget.EventEditor", {
    extend: "Ext.form.Panel",
    mixins: [
        'Sch.widget.mixin.CustomizableRecordForm',
        'Sch.widget.recurrence.EventEditorMixin',
        'Sch.mixin.Localizable'
    ],
    alias: [
        'widget.eventeditorform',
        'plugin.scheduler_eventeditorform'
    ],
    isEventEditor: true,
    requires: [
        'Ext.util.Region',
        'Ext.form.Label',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Date',
        'Ext.form.field.Hidden',
        'Ext.form.field.Time',
        'Ext.Button',
        'Sch.model.Event',
        'Sch.util.Date',
        'Sch.patches.DateField'
    ],
    trackResetOnLoad: true,
    isSavingEvent: 0,
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - saveText      : 'Save',
     * - deleteText    : 'Delete',
     * - cancelText    : 'Cancel',
     * - nameText      : 'Name',
     * - allDayText    : 'All day',
     * - startDateText : 'Start',
     * - endDateText   : 'End',
     * - resourceText  : 'Resource',
     * - 'Repeat'      : 'Repeat'
     */
    /**
     * @property {Object} eventStore The event store.
     */
    eventStore: null,
    /**
     * @cfg {Boolean} saveOnEnter True to save the form data and close if ENTER is pressed in one of the input fields inside the panel.
     */
    saveOnEnter: true,
    /**
     * @cfg {Boolean} showDeleteButton True to show a delete button in the form.
     */
    showDeleteButton: true,
    /**
     * The "All day" field.
     * @property {Ext.form.field.Checkbox} allDayField
     */
    allDayField: null,
    /**
     * The start date field.
     * @property {Ext.form.field.Date} startDateField
     */
    startDateField: null,
    /**
     * The start time field.
     * @property {Ext.form.field.Time} startTimeField
     */
    startTimeField: null,
    /**
     * The end date field.
     * @property {Ext.form.field.Date} endDateField
     */
    endDateField: null,
    /**
     * The end time field.
     * @property {Ext.form.field.Time} endTimeField
     */
    endTimeField: null,
    /**
     * The event name field.
     * @property {Ext.form.field.Text} nameField
     */
    nameField: null,
    /**
     * The resource picker field.
     * @property {Ext.form.field.ComboBox} resourceField
     */
    resourceField: null,
    /**
     * @cfg {Object} startTimeConfig Configuration object for the {@link #startTimeField}.
     */
    startTimeConfig: null,
    /**
     * @cfg {Object} startDateConfig Configuration object for the {@link #startDateField}.
     */
    startDateConfig: null,
    /**
     * @cfg {Object} endTimeConfig Configuration object for the {@link #endTimeField}.
     */
    endTimeConfig: null,
    /**
     * @cfg {Object} endDateConfig Configuration object for the {@link #endDateField}.
     */
    endDateConfig: null,
    /**
     * @cfg {Object} resourceFieldConfig Configuration object for the {@link #resourceField}.
     */
    resourceFieldConfig: null,
    /**
     * @cfg {Object} nameFieldConfig Configuration object for the {@link #nameField}.
     */
    nameFieldConfig: null,
    /**
     * @cfg {Object} allDayFieldConfig Configuration object for the {@link #allDayField}.
     */
    allDayFieldConfig: null,
    showResourceField: false,
    /**
     * @cfg {Boolean} scrollNewEventIntoView When set to True (default) the new event is scrolled into view.
     *
     * **Please note** that the config doesn't work for events assigned to multiple resources.
     */
    scrollNewEventIntoView: true,
    border: false,
    bodyPadding: 6,
    /**
     * @cfg {Object} fieldsPanelConfig (required) A panel config representing your fields that are associated with a scheduled event.
     *
     * Example:
     *
     * ```javascript
     * fieldsPanelConfig : {
     *     layout      : 'form',
     *
     *     style       : 'background : #fff',
     *     border      : false,
     *     cls         : 'editorpanel',
     *     labelAlign  : 'top',
     *
     *     defaults    : {
     *         width : 135
     *     },
     *
     *     items       : [
     *         titleField      = new Ext.form.TextField({
     *             name            : 'Title',
     *             fieldLabel      : 'Task'
     *         }),
     *
     *         locationField   = new Ext.form.TextField({
     *             name            : 'Location',
     *             fieldLabel      : 'Location'
     *         })
     *     ]
     * }
     * ```
     */
    fieldsPanelConfig: null,
    /**
     * @cfg {String} dateFormat This config parameter is passed to the {@link #startDateField} and {@link #endDateField} constructor.
     */
    dateFormat: 'Y-m-d',
    /**
     * @cfg {Number} weekStartDay
     * Day index on which the week begins (0-based, where 0 is Sunday).
     * This config parameter is passed to the {@link #startDateField} and {@link #endDateField} constructor.
     */
    weekStartDay: 1,
    /**
     * @cfg {String} timeFormat This config parameter is passed to the {@link #startTimeField} and {@link #endTimeField} constructor.
     */
    timeFormat: 'H:i',
    eventeditorCls: 'sch-eventeditor',
    /**
     * @cfg {Boolean} dynamicForm `True` to use several forms.
     */
    dynamicForm: true,
    /**
     * @property {Sch.model.Event} eventRecord The current {@link Sch.model.Event} record, which is being edited by the event editor.
     */
    eventRecord: null,
    /**
     * @property {Sch.model.Resource} resourceRecord The current {@link Sch.model.Resource} resource to which the event is assigned to.
     */
    resourceRecord: null,
    currentForm: null,
    allowOverlap: true,
    readOnly: false,
    /**
     *  @cfg {String} typeField This field in the model that defines the eventType.
     */
    typeField: 'EventType',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    /**
     * @event beforeeventdelete
     * Fires before an event is deleted
     * @param {Sch.widget.EventEditor} widget The widget instance
     * @param {Sch.model.Event} eventRecord The record about to be deleted
     * @preventable
     */
    /**
     * @event beforeeventadd
     * Fires before an event is added to the store
     * @param {Sch.widget.EventEditor} widget The widget instance
     * @param {Sch.model.Event} eventRecord The record about to be added to the store
     * @param {Sch.model.Resource} resourceRecord A resource record to which the record is assigned
     * @preventable
     */
    /**
     * @private
     * @event aftereventadd
     * Fires after an event is added to the store
     * @param {Sch.widget.EventEditor} widget The widget instance
     * @param {Sch.model.Event} eventRecord The record which has been added to the store
     */
    /**
     * @event beforeeventsave
     * Fires before an event is saved
     * @param {Sch.widget.EventEditor} widget The widget instance
     * @param {Sch.model.Event} eventRecord The record about to be saved
     * @param {Object} values The new values
     * @preventable
     */
    /**
     * @event aftereventsave
     * Fires after an event is successfully saved
     * @param {Sch.widget.EventEditor} widget The widget instance
     * @param {Sch.model.Event} eventRecord The record about to be saved
     */
    initComponent: function() {
        var me = this;
        me.addCls(me.eventeditorCls);
        // customizable fields will be updated on load record
        me.setupCustomizableRecordForm(me, Sch.model.Event);
        me.setupRecurrableEventEditorMixin(me);
        Ext.apply(me, {
            buttons: me.buttons || me.buildButtons(),
            items: [
                {
                    xtype: 'container',
                    itemId: 'defaultFields',
                    margin: '5 5 5 5',
                    defaults: {
                        width: '100%'
                    },
                    border: false,
                    items: me.getDefaultFields()
                },
                Ext.applyIf(me.fieldsPanelConfig, {
                    flex: 1,
                    activeItem: 0
                })
            ]
        });
        me.callParent(arguments);
        me.defaultFields = me.down('#defaultFields');
    },
    afterRender: function() {
        this.callParent(arguments);
        if (this.saveOnEnter) {
            this.el.on({
                'keyup': function(e, t) {
                    if (e.getKey() === e.ENTER && t.tagName.toLowerCase() === 'input') {
                        this.save();
                    }
                },
                scope: this
            });
        }
    },
    onAllDayChange: function(checkbox, isAllDay) {
        var me = this,
            values, startDate, endDate;
        if (!me.loadingRecord) {
            values = this.getValues();
            me.suspendDateFieldsChange();
            if (isAllDay) {
                if (values.startDate) {
                    startDate = Sch.model.Event.getAllDayDisplayStartDate(values.startDate);
                    me.startDateField.setValue(startDate);
                    me.startTimeField.setValue(startDate);
                }
                if (values.startDate && values.endDate) {
                    endDate = Sch.model.Event.getAllDayDisplayEndDate(values.startDate, values.endDate);
                    me.endDateField.setValue(endDate);
                    me.endTimeField.setValue(endDate);
                }
            } else {
                if (values.startDate) {
                    endDate = Sch.util.Date.add(values.startDate, Sch.util.Date.HOUR, 1);
                    me.endDateField.setValue(endDate);
                    me.endTimeField.setValue(endDate);
                }
            }
            me.resumeDateFieldsChange();
            me.toggleAllDayFields();
        }
    },
    onDatesChange: function(field, newValue, oldValue) {
        var DATE = Sch.util.Date;
        var values = this.getValues();
        if (!Ext.isDate(values.startDate) || !Ext.isDate(values.endDate) || (values.startDate.getTime() < values.endDate.getTime()))  {
            return;
        }
        
        this.suspendDateFieldsChange();
        if (!values.allDay && values.startDate.getTime() >= values.endDate.getTime()) {
            if ((field === this.startDateField) || (field === this.startTimeField)) {
                this.endDateField.setValue(DATE.add(values.startDate, DATE.DAY, 1));
            } else {
                this.startDateField.setValue(DATE.add(values.endDate, DATE.DAY, -1));
            }
        } else if (values.allDay && values.startDate.getTime() > values.endDate.getTime()) {
            if ((field === this.startDateField) || (field === this.startTimeField)) {
                this.endDateField.setValue(values.startDate);
            } else {
                this.startDateField.setValue(values.endDate);
            }
        }
        this.resumeDateFieldsChange();
    },
    /**
     * @protected
     * Returns an array of default fields (name, start and end date).
     * @returns {*[]}
     */
    getDefaultFields: function() {
        var result = [];
        this.nameField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-name-field',
            xtype: 'textfield',
            fieldLabel: this.L('nameText'),
            name: this.customizableFieldNames.nameField,
            selectOnFocus: true,
            allowBlank: false
        }, this.nameFieldConfig));
        result.push(this.nameField);
        if (this.showResourceField) {
            this.resourceField = Ext.create(Ext.Object.merge({
                fieldId: this.eventeditorCls + '-resource-field',
                xtype: 'combo',
                listConfig: {
                    htmlEncode: true
                },
                fieldLabel: this.L('resourceText'),
                queryMode: 'local',
                // default values, will be overriden from the resource store model fields
                valueField: 'Id',
                displayField: 'Name',
                allowBlank: false,
                editable: false
            }, this.resourceFieldConfig));
            result.push(this.resourceField);
        }
        this.allDayField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-all-day-field',
            xtype: 'checkboxfield',
            fieldLabel: this.L('allDayText'),
            handler: this.onAllDayChange,
            scope: this
        }, this.allDayFieldConfig));
        result.push(this.allDayField);
        this.startDateField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-start-date-field',
            xtype: 'datefield',
            fieldLabel: this.L('startDateText'),
            allowBlank: false,
            format: this.dateFormat,
            altFormats: '',
            startDay: this.weekStartDay,
            flex: 1,
            listeners: {
                change: this.onDatesChange,
                scope: this
            }
        }, this.startDateConfig));
        this.startTimeField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-start-time-field',
            cls: this.eventeditorCls + '-timefield',
            xtype: 'timefield',
            format: this.timeFormat,
            altFormats: '',
            increment: 30,
            width: 100,
            margin: '0 0 0 10',
            allowBlank: false,
            listeners: {
                change: this.onDatesChange,
                scope: this
            }
        }, this.startTimeConfig));
        this.endDateField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-end-date-field',
            xtype: 'datefield',
            fieldLabel: this.L('endDateText'),
            allowBlank: false,
            format: this.dateFormat,
            altFormats: '',
            startDay: this.weekStartDay,
            flex: 1,
            listeners: {
                change: this.onDatesChange,
                scope: this
            }
        }, this.endDateConfig));
        this.endTimeField = Ext.create(Ext.apply({
            fieldId: this.eventeditorCls + '-end-time-field',
            cls: this.eventeditorCls + '-timefield',
            xtype: 'timefield',
            format: this.timeFormat,
            altFormats: '',
            increment: 30,
            width: 100,
            margin: '0 0 0 10',
            allowBlank: false,
            listeners: {
                change: this.onDatesChange,
                scope: this
            }
        }, this.endTimeConfig));
        result.push({
            xtype: 'container',
            layout: 'hbox',
            margin: '0 0 10 0',
            items: [
                this.startDateField,
                this.startTimeField
            ]
        });
        result.push({
            xtype: 'container',
            layout: 'hbox',
            margin: '0 0 10 0',
            items: [
                this.endDateField,
                this.endTimeField
            ]
        });
        return result;
    },
    setReadOnly: function(readOnly) {
        if (readOnly !== this.readOnly) {
            Ext.Array.each(this.query('field'), function(field) {
                field.setReadOnly(readOnly);
            });
            this.saveButton.setVisible(!readOnly);
            this.deleteButton && this.deleteButton.setVisible(!readOnly);
            this.readOnly = readOnly;
        }
    },
    /**
     * Return an event record which was loaded in the form widget.
     *
     * @return {Sch.model.Event} eventRecord The record about to be edited
     */
    getEventRecord: function() {
        return this.eventRecord;
    },
    suspendDateFieldsChange: function() {
        this.startDateField.suspendCheckChange++;
        this.startTimeField.suspendCheckChange++;
        this.endDateField.suspendCheckChange++;
        this.endTimeField.suspendCheckChange++;
    },
    resumeDateFieldsChange: function() {
        this.startDateField.suspendCheckChange--;
        this.startTimeField.suspendCheckChange--;
        this.endDateField.suspendCheckChange--;
        this.endTimeField.suspendCheckChange--;
    },
    /**
     * Load an event record in the form widget.
     *
     * @param eventRecord {Sch.model.Event}
     */
    loadRecord: function(eventRecord, readOnly) {
        var me = this;
        me.loadingRecord = true;
        // reset form previous
        me.reset();
        me.suspendDateFieldsChange();
        me.setReadOnly(readOnly);
        // Only show delete button if the event belongs to a store
        if (me.deleteButton) {
            me.deleteButton.setVisible(!readOnly && !me.isNewRecord(eventRecord));
        }
        me.eventRecord = eventRecord;
        var startDate = eventRecord.getStartDate();
        var endDate = eventRecord.getEndDate();
        var isAllDay = eventRecord.getAllDay();
        me.startTimeField.setValue(startDate);
        me.endTimeField.setValue(endDate);
        if (!isAllDay) {
            me.startDateField.setValue(startDate);
            me.endDateField.setValue(endDate);
        } else {
            me.startDateField.setValue(Sch.model.Event.getAllDayDisplayStartDate(me.eventRecord));
            me.endDateField.setValue(Sch.model.Event.getAllDayDisplayEndDate(me.eventRecord));
        }
        me.allDayField.setValue(isAllDay);
        me.toggleAllDayFields();
        // we pass "eventStore" to "getResources" since the "eventRecord" might be NOT in the event store yet
        // and in the case "getResources" won't work
        var eventResources = eventRecord.getResources(me.getEventStore());
        if (me.isNewRecord(eventRecord) && !eventResources.length) {
            eventResources = [
                me.resourceRecord
            ];
        }
        me.resourceField && me.setResourcesValue(eventResources);
        me.currentForm = me;
        // load the values to the main form
        me.callParent([
            eventRecord
        ]);
        var eventType = eventRecord.get(me.typeField);
        if (eventType && me.dynamicForm) {
            var fieldsPanel = me.items.getAt(1),
                allForms = fieldsPanel.query('> form[EventType]'),
                form = fieldsPanel.query('> form[EventType=' + eventType + ']')[0];
            if (!form) {
                throw new Error("Can't find form for with EventType equal to " + eventType);
            }
            if (!fieldsPanel.getLayout().setActiveItem) {
                throw new Error("Can't switch active component in the 'fieldsPanel'");
            }
            fieldsPanel.getLayout().setActiveItem(form);
            me.currentForm = form;
            // load the values to additional form
            form.loadRecord(eventRecord);
        }
        me.fireEvent('loadevent', me, eventRecord, readOnly);
        me.nameField.focus();
        me.resumeDateFieldsChange();
        me.loadingRecord = false;
    },
    toggleAllDayFields: function() {
        var me = this;
        if (me.allDayField.isVisible()) {
            var isAllDay = me.allDayField.getValue();
            me.startTimeField.setDisabled(isAllDay);
            me.startTimeField.setHidden(isAllDay);
            me.endTimeField.setDisabled(isAllDay);
            me.endTimeField.setHidden(isAllDay);
        }
    },
    getFloatingComponents: function() {
        var me = this,
            result = [],
            pickerFields = me.query('pickerfield'),
            i;
        // HACK to render all pickers, so the query for floating components will return full result
        for (i = 0; i < pickerFields.length; i++) {
            var pickerField = pickerFields[i],
                picker = pickerField.getPicker();
            // The fieldId is not required. It needs to make checking the field pickers in our tests easier.
            if (pickerField.fieldId) {
                picker.addCls(pickerField.fieldId + '-picker');
            }
        }
        var floatingComponents = me.query('[floating]');
        if (Ext.isArray(floatingComponents)) {
            result = result.concat(floatingComponents);
        }
        return result;
    },
    setEventStore: function(store) {
        this.eventStore = store;
    },
    setResourceStore: function(store) {
        var me = this;
        me.resourceStore = store;
        if (me.resourceField) {
            if (store) {
                me.resourceField.valueField = store && store.getModel().prototype.idProperty;
                me.resourceField.displayField = store && store.getModel().prototype.nameField;
                // need to update the display tpl with new displayField value
                me.resourceField.setDisplayTpl();
            }
            me.resourceField.setStore(store);
        }
    },
    getEventStore: function() {
        return this.eventStore;
    },
    getResourceStore: function() {
        return this.resourceStore;
    },
    isNewRecord: function(eventRecord) {
        var store = this.getEventStore();
        return !store || store.indexOf(eventRecord) === -1;
    },
    onSaveClick: function() {
        this.save();
    },
    /**
     * This method first checks that the form values are valid and then updates the event.
     */
    save: function(eventRecord) {
        var me = this;
        eventRecord = eventRecord || me.eventRecord;
        if (!eventRecord || !me.isValid()) {
            return;
        }
        var eventStore = me.getEventStore(),
            values = me.getValues(),
            resourcesProvided = values.hasOwnProperty('resources');
        // check if resource has no overlapping events (if its prohibited)
        if (!me.allowOverlap && eventStore) {
            var abort = false;
            // we pass "eventStore" to "getResources" since the "eventRecord" might be NOT in the event store yet
            // and in the case "getResources" won't work
            Ext.each(resourcesProvided ? values.resources : eventRecord.getResources(me.getEventStore()), function(resource) {
                return abort = !eventStore.isDateRangeAvailable(values.startDate, values.endDate, eventRecord, resource);
            });
            if (abort) {
                return;
            }
        }
        var continueFn = function() {
                me.doSave(eventRecord, values);
            };
        if (me.fireEvent('beforeeventsave', me, eventRecord, values, continueFn) !== false) {
            continueFn();
        }
        return eventRecord;
    },
    doSave: function(eventRecord, values) {
        var me = this,
            eventStore = me.getEventStore(),
            resourcesProvided = values.hasOwnProperty('resources'),
            isAutoSyncEnabled = eventStore && eventStore.getAutoSync();
        if (isAutoSyncEnabled) {
            eventStore.suspendAutoSync();
        }
        me.isSavingEvent++;
        me.onBeforeSave(eventRecord);
        eventRecord.beginEdit();
        me.updateRecord(eventRecord);
        if (me.currentForm !== me) {
            me.currentForm.updateRecord(eventRecord);
        }
        if (values.allDay) {
            eventRecord.setStartEndDate(values.startDate, Sch.util.Date.getNext(values.endDate, Sch.util.Date.DAY, 1));
        } else {
            eventRecord.setStartEndDate(values.startDate, values.endDate);
        }
        eventRecord.setAllDay(values.allDay);
        eventRecord.endEdit();
        // if resources are provided either by "resourceField" or "resourceRecord" property
        if (resourcesProvided && !me.isNewRecord(eventRecord)) {
            me.assignResourcesToEvent(eventRecord, values.resources);
        }
        // Check if this is a new record
        if (eventStore && me.isNewRecord(eventRecord)) {
            if (me.fireEvent('beforeeventadd', me, eventRecord, values.resources) !== false) {
                if (eventStore.isTreeStore) {
                    eventRecord.set('leaf', true);
                }
                eventStore.append(eventRecord);
                // if resources are provided either by "resourceField" or "resourceRecord" property
                if (resourcesProvided) {
                    me.assignResourcesToEvent(eventRecord, values.resources);
                }
                me.fireEvent('aftereventadd', me, eventRecord);
            }
        }
        me.fireEvent('aftereventsave', me, eventRecord);
        me.onAfterSave(eventRecord);
        me.isSavingEvent--;
        if (isAutoSyncEnabled) {
            eventStore.resumeAutoSync(true);
        }
    },
    /**
     * Set resources as selected to a picker
     * @template
     * @protected
     * @param {Sch.model.Resource[]} resources
     */
    setResourcesValue: function(resources) {
        this.resourceField.setValue(resources);
    },
    /**
     * Returns resources to be applied to the event being edited.
     * @template
     * @protected
     * @return {Sch.model.Resource[]} resources
     */
    getResourcesValue: function() {
        return [
            this.resourceField.getSelection()
        ];
    },
    /**
     * Assign selected resources to the event
     * @template
     * @private
     * @param {Sch.model.Event} eventRecord
     * @param {Sch.model.Resource[]} resources
     */
    assignResourcesToEvent: function(eventRecord, resources) {
        eventRecord.unassign();
        eventRecord.assign(resources);
    },
    isValid: function() {
        var valid = true;
        Ext.each(this.query('[isFormField]:not([excludeForm])'), function(field) {
            // Consider hidden fields are valid by default
            return valid = field.isHidden() || field.isValid();
        });
        return valid;
    },
    combineDateAndTime: function(date, time) {
        var result = null;
        if (Ext.isDate(date) && Ext.isDate(time)) {
            result = Sch.util.Date.copyTimeValues(Ext.Date.clone(date), time);
        }
        return result;
    },
    getStartDateValue: function() {
        return this.combineDateAndTime(this.startDateField.getValue(), this.startTimeField.getValue());
    },
    getEndDateValue: function() {
        return this.combineDateAndTime(this.endDateField.getValue(), this.endTimeField.getValue());
    },
    getValues: function() {
        var me = this,
            values = me.callParent(arguments);
        if (me.resourceField) {
            values.resources = me.getResourcesValue();
        } else if (me.resourceRecord) {
            values.resources = [
                me.resourceRecord
            ];
        }
        return Ext.apply(values, {
            startDate: me.getStartDateValue(),
            endDate: me.getEndDateValue(),
            name: me.nameField.getValue(),
            allDay: me.allDayField.getValue(),
            resource: values.resources && values.resources[0]
        });
    },
    /**
     * Template method, intended to be overridden. Called before the event record has been updated.
     * @param {Sch.model.Event} eventRecord The event record
     * @template
     */
    onBeforeSave: function(eventRecord) {},
    /**
     * Template method, intended to be overridden. Called after the event record has been updated.
     * @param {Sch.model.Event} eventRecord The event record
     * @template
     */
    onAfterSave: function(eventRecord) {},
    onDeleteClick: function() {
        this.deleteEvent();
    },
    deleteEvent: function(eventRecord) {
        var me = this;
        eventRecord = eventRecord || me.eventRecord;
        var continueFn = function() {
                me.doDeleteEvent(eventRecord);
            };
        if (me.fireEvent('beforeeventdelete', me, eventRecord, continueFn) !== false) {
            continueFn();
        }
    },
    doDeleteEvent: function(eventRecord) {
        var me = this,
            eventStore = me.getEventStore();
        eventStore && eventStore.remove(eventRecord);
        me.fireEvent('aftereventdelete', me, eventRecord);
    },
    onCancelClick: Ext.emptyFn,
    buildButtons: function() {
        var buttons = [];
        this.saveButton = new Ext.Button({
            text: this.L('saveText'),
            scope: this,
            handler: this.onSaveClick
        });
        buttons.push(this.saveButton);
        if (this.showDeleteButton) {
            this.deleteButton = new Ext.Button({
                text: this.L('deleteText'),
                scope: this,
                handler: this.onDeleteClick
            });
            buttons.push(this.deleteButton);
        }
        this.cancelButton = new Ext.Button({
            text: this.L('cancelText'),
            scope: this,
            handler: this.onCancelClick
        });
        buttons.push(this.cancelButton);
        return buttons;
    }
});

/**
 * A plugin (ptype = 'scheduler_editorwindow') used to edit event start/end dates as well as any meta data.
 *
 *
 *     var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
 *         resourceStore   : resourceStore,
 *         eventStore      : eventStore,
 *         plugins         : [
 *             { ptype : 'scheduler_editorwindow' }
 *         ]
 *     });
 *
 */
Ext.define('Sch.plugin.EditorWindow', {
    extend: 'Ext.window.Window',
    mixins: [
        'Ext.AbstractPlugin',
        'Sch.plugin.mixin.Editor'
    ],
    requires: [
        'Sch.widget.EventEditor'
    ],
    alias: [
        'widget.scheduler_editorwindow',
        'plugin.scheduler_editorwindow'
    ],
    cls: 'sch-eventeditor-window',
    layout: 'fit',
    closeAction: 'hide',
    constrain: true,
    /**
     * @cfg {Object} editorConfig Config to pass to the {@link Sch.widget.EventEditor} widget.
     */
    editorConfig: null,
    // HACK, prevent Ext JS bug when browser window is resize, this window disappears
    // TODO: Cannot find test for this case and no mentions of `alignOnResize` in Ext or Sch/Gnt sources.
    privates: {
        alignOnResize: function() {}
    },
    initComponent: function() {
        var me = this;
        if (!me.editor) {
            me.editor = Ext.create(Ext.apply({
                xtype: 'eventeditorform',
                saveOnEnter: me.saveAndCloseOnEnter,
                onCancelClick: function() {
                    me.hide();
                }
            }, me.editorConfig));
            me.items = me.editor;
        }
        me.callParent(arguments);
    },
    init: function(grid) {
        this.initEditor(grid);
    },
    afterRender: function() {
        this.callParent(arguments);
        var floatingContainer = this.getCmp().up('[floating=true]');
        if (floatingContainer) {
            this.mon(floatingContainer, {
                activate: this.floatAboveFloatingContainer,
                move: this.floatAboveFloatingContainer,
                scope: this
            });
        }
        this.addIgnoreCls();
    },
    /**
     * Activates the editor for the passed event record.
     * @param {Sch.model.Event} record The record to show in the editor panel
     * @param {Object} options Extra options:
     * @param {Ext.dom.Element} options.alignToEl Element to align the editor to (otherwise the editor is centered)
     */
    showRecord: function(record, options) {
        // beforeShowRecord hook and show()
        this.floatAboveFloatingContainer();
        this.setTitle(record.getName());
    },
    // afterShowRecord hook
    alignEditorToElement: function(el) {
        var me = this;
        if (el) {
            me.alignTo(el, 'tl-tr' + (me.constrain ? '?' : ''));
        } else {
            me.center();
        }
    },
    /**
     * Return an event record which is shown.
     *
     * @return {Sch.model.Event} eventRecord The record about to be edited
     */
    getEventRecord: function() {
        return this.editor.getEventRecord();
    },
    floatAboveFloatingContainer: function() {
        var floatingContainer = this.getCmp().up('[floating=true]');
        if (this.isVisible() && floatingContainer) {
            this.setZIndex(floatingContainer.getEl().getZIndex() + 1);
        }
    },
    // Reposition / update form content if event is moved
    onEventRepaint: function(store, record) {
        if (this.isVisible() && record === this.getEventRecord() && !this.getEventEditor().isSavingEvent) {
            this.showRecord(record);
        }
    }
});

/**
 * @class Sch.plugin.EventEditor
 * @extends Sch.widget.EventEditor
 *
 * A plugin (ptype = 'scheduler_eventeditor') used to edit event start/end dates as well as any meta data. It inherits from {@link Ext.form.FormPanel} so you can define any fields and use any layout you want.
 *
 *     var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
 *         resourceStore   : resourceStore,
 *         eventStore      : eventStore,
 *
 *         plugins         : [
 *             { ptype : 'scheduler_eventeditor' }
 *         ]
 *     });
 *
 */
Ext.define('Sch.plugin.EventEditor', {
    extend: 'Sch.widget.EventEditor',
    mixins: [
        'Ext.AbstractPlugin',
        'Sch.plugin.mixin.Editor'
    ],
    alias: [
        'widget.eventeditor',
        'plugin.scheduler_eventeditor'
    ],
    requires: [
        'Ext.util.Region'
    ],
    border: false,
    shadow: false,
    hidden: true,
    collapsed: true,
    preventHeader: true,
    floating: true,
    hideMode: 'offsets',
    /**
     * @cfg {Boolean} constrain
     * Pass `true` to enable the constraining - i.e. editor panel will not exceed the document edges.
     * This option will disable the animation during the expansion. Default value is `false`.
     */
    constrain: false,
    floatingCls: 'sch-eventeditor-floating-container',
    constructor: function(config) {
        this.callParent(arguments);
        this.addCls(this.floatingCls);
    },
    init: function(grid) {
        // setting the ownerCt helps a possible container of the scheduler (such as a window), to not try to
        // position itself above the editor, since it's in sort of a "child" of the Window component in that case.
        this.ownerCt = grid;
        this.initEditor(grid);
    },
    afterRender: function() {
        this.callParent(arguments);
        this.addIgnoreCls();
    },
    /**
     * Activates the editor for the passed event record.
     * @param {Sch.model.Event} record The record to show in the editor panel
     * @param {Object} options Extra options:
     * @param {Ext.dom.Element} options.alignToEl Element to align the editor to (otherwise the editor is aligned to the event being edited element)
     */
    showRecord: function(record, options) {
        // beforeShowRecord hook and show()
        this.expand(!this.constrain);
    },
    // afterShowRecord hook
    alignEditorToElement: function(el) {
        var me = this;
        var cmp = me.getCmp();
        el = el || (cmp.getElementsFromEventRecord && cmp.getElementsFromEventRecord(me.getRecord())[0]) || null;
        if (el) {
            me.alignTo(el, (cmp.isHorizontal && cmp.isHorizontal() ? 'bl' : 'tl-tr') + (me.constrain ? '?' : ''));
        }
    },
    /**
     * This method first checks that the form values are valid and then updates the event and hides the form.
     */
    onDeleteClick: function() {
        this.callParent(arguments);
        this.hideEditor();
    },
    onCancelClick: function() {
        this.hideEditor();
    },
    /**
     * Hides the editor.
     */
    hideEditor: function() {
        this.collapse(null, true);
    },
    // OVERRIDE: Always hide drag proxy on collapse
    afterCollapse: function() {
        // currently the header is kept even after collapse, so need to hide the form completely
        this.hide();
        this.callParent(arguments);
    },
    // Reposition / update form content if event is moved
    onEventRepaint: function(store, record) {
        if (!this.getCollapsed() && record === this.eventRecord) {
            this.showRecord(record);
        }
    }
});

/**
 * A plugin showing a tools menu with event actions when the mouse hovers over a rendered event in the timeline.
 * Each tool can also define a visibleFn, which is called before the tools menu is shown.
 * This allows you to get control over which actions can be performed on which events.
 *
 * Sample usage:
 *
 * ```javascript
 * plugins : [{
 *     ptype : 'scheduler_eventtools',
 *     items : [
 *         { type : 'details', callback : onToolClick, tooltip : 'Show Event Details' },
 *         { type : 'edit', callback : onToolClick, tooltip : 'Edit Event' },
 *         { type : 'repeat', callback : onToolClick, tooltip : 'Repeat Event' },
 *         {
 *             type      : 'drop', callback : onToolClick, tooltip : 'Remove Event',
 *             visibleFn : function (eventRecord) {
 *                 return !!eventRecord.get('Deletable');
 *             }
 *         }
 *     ]
 * }]
 * ```
*/
Ext.define('Sch.plugin.EventTools', {
    extend: 'Ext.Container',
    mixins: [
        'Ext.AbstractPlugin'
    ],
    lockableScope: 'top',
    alias: 'plugin.scheduler_eventtools',
    /**
    * @cfg {Number} hideDelay The menu will be hidden after this number of ms, when the mouse leaves the tools element.
    */
    hideDelay: 500,
    /**
    * @cfg {String} align The alignment of the tools menu to the event bar
    */
    align: 'b-t',
    /**
    * @cfg {Object} defaults The defaults for each action item in the tools menu
    */
    defaults: {
        xtype: 'tool',
        baseCls: 'sch-tool',
        overCls: 'sch-tool-over',
        width: 24,
        height: 24,
        visibleFn: Ext.emptyFn
    },
    // private
    hideTimer: null,
    // private
    cachedSize: null,
    // private
    layout: 'hbox',
    autoRender: true,
    floating: true,
    shadow: false,
    hideMode: 'offsets',
    hidden: true,
    eventRecord: null,
    resourceRecord: null,
    /**
     * @property {HTMLElement} targetNode
     * The target element that triggered the event tools component to be shown
     */
    targetNode: null,
    /**
     * Returns the event record that this tools menu is currently associated with
     * @return {Sch.model.Event} eventRecord The event record
     */
    getEventRecord: function() {
        return this.eventRecord;
    },
    /**
     * Returns the resource record that this tools menu is currently associated with
     * @return {Sch.model.Resource} resourceRecord The resource record
     */
    getResourceRecord: function() {
        return this.resourceRecord;
    },
    init: function(scheduler) {
        if (!this.items)  {
            throw 'Must define an items property for this plugin to function correctly';
        }
        
        // Let client use 'cls' property
        this.addCls('sch-event-tools');
        this.scheduler = scheduler;
        this.defaultAlign = this.align;
        // 'align' property changed name to 'defaultAlign' since original implementation
        scheduler.on({
            // Suspend during resize
            'eventresizestart': this.onOperationStart,
            'aftereventresize': this.onOperationEnd,
            // Suspend during drag drop
            'eventdragstart': this.onOperationStart,
            'eventdrop': this.onOperationEnd,
            'eventmouseenter': this.onEventMouseEnter,
            'eventmouseleave': this.onContainerMouseLeave,
            scope: this
        });
    },
    onRender: function() {
        this.callParent(arguments);
        this.el.on({
            mouseenter: this.onContainerMouseEnter,
            mouseover: this.onContainerMouseEnter,
            mouseleave: this.onContainerMouseLeave,
            scope: this
        });
    },
    onEventMouseEnter: function(view, eventRecord, e) {
        window.clearTimeout(this.hideTimer);
        var me = this,
            doShow = false,
            visible;
        me.targetNode = e.getTarget(view.eventSelector);
        me.eventRecord = eventRecord;
        me.resourceRecord = view.resolveResource(me.targetNode);
        me.items.each(function(tool) {
            visible = tool.visibleFn(me.eventRecord) !== false;
            tool.setVisible(visible);
            if (visible)  {
                doShow = true;
            }
            
        });
        if (!doShow)  {
            return;
        }
        
        me.showBy(me.targetNode);
    },
    onContainerMouseEnter: function() {
        window.clearTimeout(this.hideTimer);
    },
    onContainerMouseLeave: function() {
        window.clearTimeout(this.hideTimer);
        this.hideTimer = Ext.defer(this.hide, this.hideDelay, this);
    },
    onOperationStart: function() {
        this.scheduler.un('eventmouseenter', this.onEventMouseEnter, this);
        window.clearTimeout(this.hideTimer);
        this.hide();
    },
    onOperationEnd: function() {
        this.scheduler.on('eventmouseenter', this.onEventMouseEnter, this);
    },
    destroy: function() {
        clearTimeout(this.hideTimer);
        this.callParent(arguments);
    }
});

/**
 @class Sch.plugin.exporter.AbstractExporter
 @extends Ext.util.Observable

 This class represents the base implementation of an exporter.
 An exporter extracts the provided component content and packs it into array of pages (based on provided export settings and implemented algorithm).
 The main entry point for an exporter that launches the extraction process is {@link #extractPages} method:

             exporter.extractPages(component, config, function (pages) {

                alert(pages.length + " extracted");

                ...

             }, me);


*/
Ext.define('Sch.plugin.exporter.AbstractExporter', {
    extend: 'Ext.util.Observable',
    requires: [
        'Ext.XTemplate'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    /**
     * @deprecated Use {@link #headerHeight} instead.
     * @cfg {Number}
     * Header height. Amount of space for {@link #headerTpl the page header}.
     */
    pageHeaderHeight: 41,
    /**
     * @cfg {Number}
     * Header height. Amount of space for {@link #headerTpl the page header}.
     */
    headerHeight: 41,
    /**
     * @deprecated Use {@link #footerHeight} instead.
     * @cfg {Number}
     * Footer height. Amount of space for {@link #footerTpl the page footer}.
     */
    pageFooterHeight: 41,
    /**
     * @cfg {Number}
     * Footer height. Amount of space for {@link #footerTpl the page footer}.
     */
    footerHeight: 41,
    bufferedHeightMargin: 25,
    /**
     * @private
     * @property {Boolean} isExporter
     * @readonly
     * `true` in this class to identify an object as an instantiated Exporter, or subclass thereof.
     */
    isExporter: true,
    /**
     * @private
     * @property {Number} paperWidth
     * Paper width. Calculated based on provided page format and DPI resolution.
     */
    paperWidth: 0,
    /**
     * @private
     * @property {Number} paperHeight
     * Paper height. Calculated based on provided page format and DPI resolution.
     */
    paperHeight: 0,
    /**
     * @private
     * @property {Number} printHeight
     * Paper height that can be used for printing rows. Calculated as {@link #paperHeight} minus header heights.
     */
    printHeight: 0,
    lockedRowsHeight: 0,
    normalRowsHeight: 0,
    iterateTimeout: 10,
    /**
     * @private
     * @cfg {String} tableSelector
     * The selector for the row container used for both normalGrid and lockedGrid.
     */
    tableSelector: undefined,
    /**
     * @private
     * @property {Ext.dom.Element} currentPage
     * Current page being extracted.
     */
    currentPage: undefined,
    /**
     * @deprecated
     * @cfg {Function} headerTplDataFn
     * If specified the function result will be applied to {@link #getHeaderTplData} result.
     * To define the scope please use {@link #headerTplDataFnScope}.
     */
    headerTplDataFn: null,
    /**
     * @deprecated
     * @cfg {Function} footerTplDataFn.
     * If specified the function result will be applied to {@link #getFooterTplData} result.
     * To define the scope please use {@link #footerTplDataFnScope}.
     */
    footerTplDataFn: null,
    /**
     * @deprecated
     * @cfg {Object} headerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    headerTplDataFnScope: null,
    /**
     * @deprecated
     * @cfg {Object} footerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    footerTplDataFnScope: null,
    config: {
        /**
         * @deprecated Use {@link #id} instead.
         * @cfg {String} exporterId.
         * Exporter identifier. Has to be unique among other exporters when you register in in {@link Sch.plugin.Export} instance.
         */
        exporterId: 'abstractexporter',
        /**
         * @cfg {String}
         * Exporter identifier. Has to be unique among other exporters when you register in in {@link Sch.plugin.Export} instance.
         */
        id: 'abstractexporter',
        /**
         * @cfg {String}
         * Exporter name. By default will be taken from the class {@link #l10n locale}.
         */
        name: '',
        translateURLsToAbsolute: true,
        expandAllBeforeExport: false,
        /**
         * @cfg {String/Ext.XTemplate} headerTpl
         * Template of an extracted page header.
         */
        headerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        /**
         * @cfg {String/Ext.XTemplate} tpl
         * Template of an extracted page.
         */
        tpl: '<!DOCTYPE html>' + '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' + '<head>' + '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' + '<title>{title}</title>' + '{styles}' + '</head>' + '<body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">' + '{header}' + '<div id="{id}" class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">' + '{HTML}' + '</div>' + '{footer}' + '</body>' + '</html>',
        /**
         * @cfg {String/Ext.XTemplate} footerTpl
         * Template of an extracted page footer.
         */
        footerTpl: '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',
        //  Row visibility detection threshold (0.6 - means that when 60% of a row height is visible we consider it as visible)
        rowVisibilityThreshold: 0.6
    },
    //private placeholder for provided callback functions passed in extractPages
    callbacks: undefined,
    //private String errorMessage, when internally set this message will be displayed in a pop-up message.
    error: undefined,
    /**
     * @private
     * @property {Object[]} extractedPages Collection of extracted pages.
     */
    extractedPages: undefined,
    /**
     * @private
     * @property {Number} numberOfPages Total number of pages extracted.
     */
    numberOfPages: 0,
    // vertical offset of the very first row exported
    firstExportedRowOffset: 0,
    // Vertical offset of the secondary canvas. Initially equals to the negative "firstExportedRowOffset".
    // Though the value might change while pages getting extracted.
    secondaryCanvasOffset: 0,
    eventBoxes: null,
    dependencyPainter: null,
    dependenciesHtml: '',
    depViewBeforeRefreshDetacher: null,
    depView: null,
    collectRowsTimer: null,
    collectRowsTimerTimeout: 1,
    collectRowsStepTimer: null,
    scrollToTimer: null,
    timer1: null,
    timer2: null,
    /**
     * @private
     * @property {String} stylesheets
     * Extracted CSS stylesheets of the component.
     */
    stylesheets: null,
    constructor: function(config) {
        var me = this;
        config = config || {};
        if (config.pageHeaderHeight)  {
            config.headerHeight = config.pageHeaderHeight;
        }
        
        if (config.pageFooterHeight)  {
            config.footerHeight = config.pageFooterHeight;
        }
        
        if (config.exporterId)  {
            config.id = config.exporterId;
        }
        
        me.callParent(arguments);
        // initConfig thinks that we're trying to override methods so we have to delete following
        delete config.getUserHeaderTplData;
        delete config.getUserFooterTplData;
        me.initConfig(config);
        if (!config.tableSelector) {
            me.tableSelector = '.' + Ext.baseCSSPrefix + 'grid-item-container';
        }
        // get the exporter name from locale (if not provided explicitly)
        if (!config.name)  {
            me.setName(me.L('name'));
        }
        
    },
    getExporterId: function() {
        return this.getId();
    },
    destroy: function() {
        clearTimeout(this.collectRowsStepTimer);
        clearTimeout(this.collectRowsTimer);
        clearTimeout(this.scrollToTimer);
        clearTimeout(this.timer1);
        clearTimeout(this.timer2);
        this.callParent(arguments);
    },
    setHeaderTpl: function(tpl) {
        this.headerTpl = this.getTplInstance(tpl);
    },
    getHeaderTpl: function() {
        return this.headerTpl;
    },
    setTpl: function(tpl) {
        this.tpl = this.getTplInstance(tpl);
    },
    getTpl: function() {
        return this.tpl;
    },
    setFooterTpl: function(tpl) {
        this.footerTpl = this.getTplInstance(tpl);
    },
    getFooterTpl: function() {
        return this.footerTpl;
    },
    getTplInstance: function(tpl) {
        return (tpl && !tpl.isTemplate) ? new Ext.XTemplate(tpl, {
            disableFormats: true
        }) : tpl;
    },
    /**
     * @private
     * Returns the CSS classes for BODY element of extracted page. Override this if you need to customize the CSS classes of exported pages.
     * @return {String} CSS classes.
     */
    getBodyClasses: function() {
        var re = new RegExp(Ext.baseCSSPrefix + 'ie\\d?|' + Ext.baseCSSPrefix + 'gecko', 'g'),
            result = document.body.className.replace(re, '');
        if (Ext.isIE) {
            result += ' sch-ie-export';
        }
        return result;
    },
    /**
     * @private
     * Returns the CSS classes for element containing exported component. Override this if you need to customize exported pages CSS classes.
     * @return {String} CSS classes.
     */
    getComponentClasses: function() {
        return this.getComponent().el.dom.className;
    },
    /**
     * @private
     * Sets the component being exported.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     */
    setComponent: function(component) {
        var me = this;
        me.component = component;
        me.view = component.getSchedulingView();
        me.normalGrid = component.normalGrid;
        me.lockedGrid = component.lockedGrid;
        me.normalView = component.normalGrid.getView();
        me.lockedView = component.lockedGrid.getView();
        me.lockedBodySelector = '#' + me.lockedView.getId();
        me.normalBodySelector = '#' + me.normalView.getId();
        me.lockedHeader = me.lockedGrid.headerCt;
        me.normalHeader = me.normalGrid.headerCt;
        me.gridHeaderHeight = me.normalHeader.getHeight();
        // page height w/o component headers
        me.printHeight = Math.floor(me.paperHeight) - me.gridHeaderHeight - (me.exportConfig.showHeader ? me.headerHeight : 0) - (me.exportConfig.showFooter ? me.footerHeight : 0);
        me.saveComponentState(component);
        me.initDependencyPainter(component);
    },
    // The component being exported.
    getComponent: function() {
        return this.component;
    },
    /**
     * @private
     * Applies the selected paper size based on export configuration and {@link #paperSizes} config. Calculates {@link #paperWidth} and {@link #paperHeight} properties.
     */
    setPaperSize: function(pageSize, orientation) {
        var me = this;
        //size of paper we will be printing on. take orientation into account
        if (orientation === 'landscape') {
            me.paperWidth = pageSize.height;
            me.paperHeight = pageSize.width;
        } else {
            me.paperWidth = pageSize.width;
            me.paperHeight = pageSize.height;
        }
    },
    /**
     * @return {String} returns the format of the current export operation.
     */
    getPaperFormat: function() {
        return this.exportConfig.format;
    },
    // Returns whether the component uses buffered rendering.
    isBuffered: function() {
        return !!this.getBufferedRenderer();
    },
    // Returns the normal grid buffered renderer instance (if the component uses buffered rendering).
    getBufferedRenderer: function() {
        return this.view.bufferedRenderer;
    },
    /**
     * @private
     * Applies the passed date range to the component.
     * @param {Object} config Export configuration.
     */
    setComponentRange: function(config) {
        var me = this,
            component = me.getComponent();
        // if we export a part of scheduler
        if (config.range !== 'complete') {
            var view = me.view,
                newStart, newEnd;
            switch (config.range) {
                case 'date':
                    newStart = new Date(config.dateFrom);
                    newEnd = new Date(config.dateTo);
                    // ensure that specified period has at least a day
                    if (Sch.util.Date.getDurationInDays(newStart, newEnd) < 1) {
                        newEnd = Sch.util.Date.add(newEnd, Sch.util.Date.DAY, 1);
                    };
                    break;
                case 'current':
                    var visibleSpan = view.getVisibleDateRange();
                    newStart = visibleSpan.startDate;
                    newEnd = visibleSpan.endDate || view.timeAxis.getEnd();
                    break;
                case 'completedata':
                    var span = component.getEventStore().getTotalTimeSpan();
                    newStart = span.start;
                    newEnd = span.end;
                    break;
            }
            // apply new time frame
            if (newStart && newEnd) {
                component.setTimeSpan(newStart, newEnd);
            }
        }
        me.ticks = component.timeAxis.getTicks();
        // if only currently visible rows have to be extracted
        if (config.rowsRange == 'visible') {
            // find effective currently visible rows range (an array: [startIndex, endIndex])
            config.rowsRange = me.findVisibleRowsRange();
        } else // all rows mode
        {
            config.rowsRange = null;
        }
    },
    /**
     * @private
     * Get links to the stylesheets of current page.
     */
    getStylesheets: function() {
        var translate = this.getTranslateURLsToAbsolute(),
            styleSheetNodes = Ext.select('link[rel="stylesheet"], style', true),
            stylesString = '';
        var host = window.origin;
        styleSheetNodes.each(function(extEl) {
            var node = extEl.dom.cloneNode(true);
            // put absolute URL to node `href` attribute
            if (translate && node.href) {
                node.setAttribute('href', translate === true ? node.href : node.href.replace(host, translate));
            }
            stylesString += node.outerHTML;
            // Empty style tag will be copied in IE, so we need to use cssText
            // http://stackoverflow.com/questions/5227088/creating-style-node-adding-innerhtml-add-to-dom-and-ie-headaches
            if (Ext.isIE && node.styleSheet && /style/i.test(node.tagName)) {
                stylesString += '<style type="text/css">' + extEl.dom.styleSheet.cssText + '</style>';
            }
        });
        return stylesString;
    },
    // Since export is a sync operation for now, all plugins drawing lines & zones need to be temporarily adjusted
    // to draw their content synchronously.
    forEachTimeSpanPlugin: function(component, fn, scope) {
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var me = this;
            var plugins = [].concat(component.plugins, component.normalGrid.plugins, component.columnLinesFeature);
            for (var i = 0,
                l = plugins.length; i < l; i++) {
                var plugin = plugins[i];
                if (plugin instanceof Sch.feature.AbstractTimeSpan) {
                    fn.call(scope || me, plugin);
                }
            }
        }
    },
    setCellSize: function(cellSize) {
        var me = this;
        me.timeColumnWidth = cellSize[0];
        if (me.timeColumnWidth) {
            this.getComponent().setTimeColumnWidth(me.timeColumnWidth);
        }
        // change the row height only if value is provided
        if (cellSize.length > 1) {
            me.view.setRowHeight(cellSize[1]);
        }
    },
    findVisibleRowsRange: function() {
        var me = this,
            nodeCache = me.lockedView.all,
            startIndex = nodeCache.startIndex,
            endIndex = nodeCache.endIndex;
        var metVisibleNode = false,
            firstVisibleRowIndex = -1,
            lastVisibleRowIndex = -1;
        for (var i = startIndex; i <= endIndex; i++) {
            var node = nodeCache.item(i, true);
            if (me.isRowVisible(node, me.lockedBox)) {
                if (!metVisibleNode) {
                    firstVisibleRowIndex = i;
                    metVisibleNode = true;
                }
                lastVisibleRowIndex = i;
            } else if (metVisibleNode) {
                break;
            }
        }
        return [
            firstVisibleRowIndex,
            lastVisibleRowIndex
        ];
    },
    /**
     * @private
     * Prepares the component to export. This includes setting requested time span, time column width etc.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     * @param {Object} config    Export configuration.
     */
    prepareComponent: function(component, config) {
        var me = this;
        component = component || me.getComponent();
        me.suspendInfiniteScroll(component);
        me.forEachTimeSpanPlugin(component, function(plugin) {
            plugin._renderDelay = plugin.renderDelay;
            plugin.renderDelay = 0;
        });
        component.getSchedulingView().timeAxisViewModel.suppressFit = true;
        component.timeAxis.autoAdjust = false;
        //expand grids in case they're collapsed
        component.normalGrid.expand();
        component.lockedGrid.expand();
        // remember view regions (to be able to decide on rows visibility if requested)
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            me.lockedBox = me.lockedGrid.body.getBox();
            me.normalBox = me.normalGrid.body.getBox();
        } else {
            me.lockedBox = me.lockedView.getBox();
            me.normalBox = me.normalView.getBox();
        }
        // change timespan/tick width according to provided settings
        me.setComponentRange(config);
        // if row/column sizes provided
        config.cellSize && me.setCellSize(config.cellSize);
        // launch template method
        config.beforeExport && config.beforeExport(component, me.ticks);
        me.prepareColumns(config.columns);
        // For Tree grid, optionally expand all nodes
        if (me.expandAllBeforeExport && component.expandAll) {
            component.expandAll();
        }
        // resizes the component to fit it into specified paper size (depending on pagination rules)
        me.fitComponentIntoPage(config);
        //bug fix #2284 - MultiPage export does not sync timeaxis on first run
        me.view.timeAxisViewModel.setTickWidth(me.view.timeAxisViewModel.getTickWidth());
        // now when we adjusted the component let get its stylesheets
        me.stylesheets = me.getStylesheets();
    },
    prepareColumns: function(columns) {
        var me = this;
        // If the list of columns to export is provided
        if (columns && columns.length) {
            me.lockedGrid.headerCt.items.each(function(column) {
                // Show only passed columns
                if (Ext.Array.contains(columns, column)) {
                    column.show();
                } else {
                    column.hide();
                }
            });
        }
    },
    restoreComponent: function(component) {
        var me = this;
        component = component || me.getComponent();
        me.forEachTimeSpanPlugin(component, function(plugin) {
            plugin.renderDelay = plugin._renderDelay;
            delete plugin._renderDelay;
        });
        // if we stopped the dependency view refreshing we enable it back
        if (me.depViewBeforeRefreshDetacher) {
            me.depViewBeforeRefreshDetacher.destroy();
            me.depViewBeforeRefreshDetacher = null;
            me.depView.updateCanvasLayer();
        }
        // restore scheduler state
        me.restoreComponentState(component);
        me.restoreInfiniteScroll(component);
        //We need to update TimeAxisModel for layout fix #1334
        // component.getSchedulingView().timeAxisViewModel.update();
        // call template method
        me.exportConfig.afterExport && me.exportConfig.afterExport(component);
    },
    saveComponentState: function(component) {
        component = component || this.getComponent();
        var me = this,
            schedulerView = component.getSchedulingView(),
            normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid;
        var columns = [];
        lockedGrid.headerCt.items.each(function(column) {
            columns.push({
                column: column,
                visible: !column.isHidden()
            });
        });
        var timeAxisViewModel = schedulerView.timeAxisViewModel;
        // Store original tick width for the case described in #1624
        var originalTickWidth = timeAxisViewModel.originalTickWidth;
        // At the same time fix tick width so export would not change it
        var tickWidth = timeAxisViewModel.getTickWidth();
        timeAxisViewModel.setTickWidth(tickWidth, true);
        //values needed to restore original size/dates of component
        me.restoreSettings = {
            width: component.getWidth(),
            height: component.getHeight(),
            rowHeight: timeAxisViewModel.getViewRowHeight(),
            originalTickWidth: originalTickWidth,
            columnWidth: tickWidth,
            startDate: component.getStart(),
            endDate: component.getEnd(),
            normalWidth: normalGrid.getWidth(),
            normalLeft: normalGrid.getEl().getStyle('left'),
            lockedWidth: lockedGrid.getWidth(),
            lockedCollapse: lockedGrid.collapsed,
            normalCollapse: normalGrid.collapsed,
            columns: columns,
            autoAdjust: component.timeAxis.autoAdjust,
            suppressFit: timeAxisViewModel.suppressFit,
            startIndex: schedulerView.all.startIndex,
            lockedScrollX: me.lockedView.getScrollX(),
            normalScrollX: schedulerView.getScrollX(),
            scrollY: schedulerView.getVerticalScroll()
        };
    },
    restoreComponentState: function(component) {
        var me = this;
        component = component || me.getComponent();
        var config = me.restoreSettings,
            view = component.getSchedulingView();
        component.timeAxis.autoAdjust = config.autoAdjust;
        component.normalGrid.show();
        component.setWidth(config.width);
        component.setHeight(config.height);
        component.setTimeSpan(config.startDate, config.endDate);
        component.setTimeColumnWidth(config.columnWidth, true);
        component.setRowHeight(config.rowHeight);
        // resote locked grid columns visibility
        Ext.Array.each(config.columns, function(item) {
            item.column.setVisible(item.visible);
        });
        component.lockedGrid.show();
        component.normalGrid.setWidth(config.normalWidth);
        component.normalGrid.getEl().setStyle('left', config.normalLeft);
        component.lockedGrid.setWidth(config.lockedWidth);
        view.timeAxisViewModel.suppressFit = config.suppressFit;
        view.timeAxisViewModel.setTickWidth(config.columnWidth);
        // restore original tick width value (#1624)
        view.timeAxisViewModel.originalTickWidth = config.originalTickWidth;
        if (config.lockedCollapse) {
            component.lockedGrid.collapse();
        }
        if (config.normalCollapse) {
            component.normalGrid.collapse();
        }
        // restore scroll position
        me.restoreComponentScroll(config);
    },
    restoreComponentScroll: function(restoreSettings) {
        var me = this;
        me.lockedView.setScrollX(restoreSettings.lockedScrollX);
        me.normalView.scrollTo(restoreSettings.normalScrollX, restoreSettings.scrollY);
    },
    /**
     * @private
     * Extracts the component content. On completion calls specified callback function providing an array of extracted pages as an argument.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component Component content of which to be extracted
     * @param {Object} config Configuration object. May contain the following properties:
     * @param {String} config.format Page format
     * @param {String} config.orientation Page orientation (either `portrait` or `landscape`)
     * @param {String} config.range Range of the panel to be exported. Options are `complete`, `current`, `date`. When `date` is specified there also has to be specified next two configs.
     * @param {Date} config.dateFrom Range start date. Used only when `config.range` is `date`
     * @param {Date} config.dateTo Range end date. Used only when `config.range` is `date`
     * @param {Boolean} config.showHeader Flag saying that page numbers header has to be shown
     * @param {Function} callback Function which is called after extraction of pages has completed. The callback will have the following arguments:
     * @param {Function} callback.pages An array with extracted pages
     * @param {Object} [scope] Scope for the callback function
     */
    extractPages: function(component, config, callback, scope) {
        var me = this;
        if (!callback) {
            throw 'Sch.plugin.exporter.AbstractExporter: [extractPages] "callback" has to be provided.';
        }
        // stop garbage collecting
        me.enableGarbageCollector = Ext.enableGarbageCollector;
        Ext.enableGarbageCollector = false;
        Ext.dom.GarbageCollector.pause();
        // keep provided export config
        me.exportConfig = config;
        me.normalRows = [];
        me.lockedRows = [];
        me.extractedPages = [];
        me.numberOfPages = 0;
        me.lockedRowsHeight = 0;
        me.normalRowsHeight = 0;
        me.firstExportedRowOffset = 0;
        me.secondaryCanvasOffset = 0;
        me._abort = false;
        me.stylesheets = null;
        // calculates paper sizes based on provided parameters and DPI
        me.setPaperSize(config.pageSize, config.orientation);
        // stores references to the component, its elements and makes a backup of its pre-export state
        me.setComponent(component, config);
        // prepares component to exporting (applies provided timespan etc.)
        me.prepareComponent(component, config);
        me.callbacks = {
            success: callback,
            scope: scope || me
        };
        // fetch all component rows into temporary arrays
        // and call 'onRowsCollected' to collect them into pages and call 'onPagesExtracted' on completion
        me.collectRowsTimer = setTimeout(function() {
            me.collectRows(me._onRowsCollected, me, config);
        }, me.collectRowsTimerTimeout);
    },
    /**
     * @protected
     * Finishes exporting process. Restores the component to its initial state and returns extracted pages by calling a provided callback.
     * @param  {Object[]} [pages] Extracted pages. If omitted then will take collected pages from {@link #extractedPages} array.
     */
    onPagesExtracted: function(pages) {
        var me = this;
        pages = me.renderPages(pages);
        // restore panel to initial state
        me.restoreComponent();
        // and return results
        me.submitPages(pages);
    },
    submitPages: function(pages) {
        var me = this,
            callbacks = me.callbacks;
        callbacks.success.call(callbacks.scope, pages);
        // resume garbage collecting
        Ext.enableGarbageCollector = me.enableGarbageCollector;
        Ext.dom.GarbageCollector.resume();
    },
    // returns an Ext.Element
    getCurrentPage: function() {
        return this.currentPage;
    },
    // page should be Ext.Element
    setCurrentPage: function(page) {
        this.currentPage = page;
    },
    getExpectedNumberOfPages: function() {
        throw 'Sch.plugin.exporter.AbstractExporter: [getExpectedNumberOfPages] Abstract method called.';
    },
    /**
     * @private
     * Commits a filled page. Pushes the page into {@link #extractedPages resulted set of pages}.
     * Calls {@link #preparePageToCommit} for the final page DOM tweaking.
     * @param [config] An optional configuration object. Will also be passed to {@link #preparePageToCommit} method.
     */
    commitPage: function(config) {
        var me = this;
        me.numberOfPages++;
        var pageBody = me.preparePageToCommit(config);
        me.fireEvent('beforecommitpage', me, pageBody, me.numberOfPages, me.getExpectedNumberOfPages());
        var page = Ext.apply({
                // include outerHTML to fix border style
                html: pageBody.dom.outerHTML,
                number: me.numberOfPages
            }, config);
        me.extractedPages.push(page);
        me.fireEvent('commitpage', me, page, me.numberOfPages, me.getExpectedNumberOfPages());
    },
    /**
     * @private
     * Collects the locked grid row.
     * @param {Element} item The locked grid row
     * @param {Ext.data.Model} recordIndex Index of the record corresponding to the row.
     * @param {Boolean} isLastRow True, when last rendered row is being collected
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectLockedRow: function(item, recordIndex, isLastRow) {
        var el = Ext.get(item),
            height = el.getHeight() - (isLastRow ? el.getBorderWidth('b') : 0);
        this.lockedRowsHeight += height;
        var result = {
                height: height,
                row: item.cloneNode(true),
                record: this.lockedView.getRecord(recordIndex)
            };
        this.lockedRows.push(result);
        return result;
    },
    /**
     * @private
     * Collects the normal grid row.
     * @param {Element} item The normal grid row
     * @param {Number} recordIndex Index of the record corresponding to the row.
     * @param {Boolean} isLastRow True, when last rendered row is being collected
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectNormalRow: function(item, recordIndex, isLastRow) {
        var el = Ext.get(item),
            height = el.getHeight() - (isLastRow ? el.getBorderWidth('b') : 0);
        this.normalRowsHeight += height;
        var result = {
                height: height,
                row: item.cloneNode(true),
                record: this.normalView.getRecord(recordIndex)
            };
        this.normalRows.push(result);
        // if there is a dependency view
        // once row is collected let's remember related events coordinates to be able to render dependencies properly
        if (this.depView && this.depView.getDependencyStore()) {
            this.fillRecordRelatedBoxes(result.record);
        }
        return result;
    },
    _onRowsCollected: function() {
        var me = this,
            depView = me.depView;
        // if there is a dependency view
        if (depView && depView.getDependencyStore()) {
            me.renderDependencies();
        }
        me.onRowsCollected.apply(me, arguments);
    },
    onRowsCollected: function() {
        throw 'Sch.plugin.exporter.AbstractExporter: [onRowsCollected] Abstract method called.';
    },
    _abort: false,
    abort: function() {
        this._abort = function() {
            this.restoreComponent();
        };
    },
    /**
     * @private
     * Iterates by calling provided function asynchronously with a delay.
     * The delay duration is specified by {@link #iterateTimeout} config.
     * @param  {Function} fn    Function implementing a single iteration step.
     * @param  {Function} fn.next Callback function to be called to run the next iteration step.
     * This will cause `fn` function launch. All arguments passed to {@link #fn.next} will be transfered to {@link #fn}.
     * @param  {[type]}   [scope] Scope for the callback function
     */
    iterateAsync: function(fn, scope) {
        var me = this;
        scope = scope || me;
        var next = function() {
                var args = arguments;
                // run iteration step asynchronously w/ delay
                me.timer2 = setTimeout(function() {
                    !me._abort ? fn.apply(scope, [].concat.apply([
                        next
                    ], args)) : me._abort();
                }, me.iterateTimeout);
            };
        next.apply(me, Ext.Array.slice(arguments, 2));
    },
    callAsync: function(fn, scope) {
        scope = scope || this;
        this.timer1 = setTimeout(function() {
            fn.apply(scope, Ext.Array.slice(arguments, 2));
        }, this.iterateTimeout);
    },
    canStartRowsCollecting: function() {
        var cmp = this.getComponent(),
            depView = cmp.getDependencyView();
        // if we have dependency view we need to have its canvas rendered before we start collecting rows
        return !depView || depView.getDependencyCanvas();
    },
    depViewRefreshBlocker: function() {
        return false;
    },
    /**
     * @private
     * Collects rows from the component. Launches the provided callback and passes collected rows as its arguments.
     * @param callback {Function} The callback function when extraction of rows has finished.
     */
    collectRows: function(callback, scope, config) {
        var me = this,
            startIndex = 0;
        // check if we're ready for rows collecting
        if (!me.canStartRowsCollecting()) {
            var args = Ext.Array.slice(arguments, 0);
            me.collectRowsTimer = setTimeout(function() {
                me.collectRows.apply(me, args);
            }, me.collectRowsTimerTimeout);
            return;
        }
        var depView = me.getComponent().getDependencyView();
        // if we have dependency view onboard
        // stop real dependency painter to not interfere, since we're gonna use the copy of it
        if (me.depView) {
            me.depViewBeforeRefreshDetacher = depView.on({
                beforerefresh: me.depViewRefreshBlocker,
                destroyable: true
            });
        }
        var needToScroll = me.isBuffered();
        // if rows to extract range is provided
        if (config.rowsRange) {
            // we know for sure index to start from
            startIndex = config.rowsRange[0];
            // if the range is inside the set of currently rendered rows we don't need to scroll
            needToScroll = !(config.rowsRange[0] >= me.view.all.startIndex && config.rowsRange[1] <= me.view.all.endIndex);
        }
        if (needToScroll) {
            // scroll to start index before rows collecting
            me.scrollToTimer = setTimeout(function() {
                me.scrollTo(startIndex, function() {
                    // fill firstExportedRowOffset value ..used to shift the secondary canvas vertically from page to page
                    startIndex && me.initFirstExportedRowOffset(startIndex);
                    me.iterateAsync(me.collectRowsStep, me, startIndex, callback, scope, config);
                });
            }, 1);
        } else {
            // fill firstExportedRowOffset value ..used to shift the secondary canvas vertically from page to page
            startIndex && me.initFirstExportedRowOffset(startIndex);
            me.collectRowsStepTimer = setTimeout(function() {
                me.collectRowsStep(null, startIndex, callback, scope, config);
            }, 1);
        }
    },
    initFirstExportedRowOffset: function(firstExportedRowIndex) {
        this.firstExportedRowOffset = this.view.el.getScrollTop() - this.view.el.getTop() + Ext.fly(this.view.getNode(firstExportedRowIndex)).getTop();
    },
    isRowVisible: function(rowNode, visibleBox) {
        var nodeEl = Ext.fly(rowNode),
            nodeTop = nodeEl.getTop(),
            nodeHeight = nodeEl.getHeight(),
            nodeBottom = nodeTop + nodeHeight,
            nodeThreshold = (1 - this.getRowVisibilityThreshold()) * nodeHeight;
        return nodeTop + nodeThreshold > visibleBox.top && nodeBottom - nodeThreshold < visibleBox.bottom;
    },
    collectRowsStep: function(next, startIndex, callback, scope, config) {
        var me = this,
            endIndex = me.normalView.all.endIndex,
            count = me.component.store.getCount(),
            rowsRange = config.rowsRange,
            normalRows = me.normalView.all.slice(startIndex),
            lockedRows = me.lockedView.all.slice(startIndex),
            i = 0;
        var lastIndex;
        // If we collect only visible rows
        if (rowsRange) {
            lastIndex = rowsRange[1];
        }
        var collected = false;
        for (var index = startIndex,
            l = normalRows.length; i < l; i++) {
            if (index > lastIndex) {
                collected = true;
                break;
            }
            // All default themes have special style for last row in the view, making bottom border 1px high.
            // When collecting rows, that may lead to dependency view getting placed incorrectly. We normalize
            // collected row height if
            lockedRows[i] && me.collectLockedRow(lockedRows[i], index, i + 1 === l);
            me.collectNormalRow(normalRows[i], index, i + 1 === l);
            index++;
        }
        me.fireEvent('collectrows', me, startIndex, index, count);
        // if we are in the buffered mode (and not collected all the requested rows yet)
        // we need to scroll further
        if (!collected && me.isBuffered()) {
            if (endIndex + 1 < count) {
                me.callAsync(function() {
                    me.scrollTo(endIndex + 1, function() {
                        next(endIndex + 1, callback, scope, config);
                    });
                });
            } else {
                me.callAsync(function() {
                    me.scrollTo(0, function() {
                        callback.call(scope || me, me.lockedRows, me.normalRows);
                    });
                });
            }
        } else // if we already collected all the needed rows - invoke the final step
        {
            callback.call(scope || me, me.lockedRows, me.normalRows);
        }
    },
    /**
     * @private
     * Fills extracted pages `html` property before submitting them.
     * @param  {Array} [pages] Array of pages. By default {@link #extractedPages} is used.
     * @return {Array} Array of pages.
     */
    renderPages: function(pages) {
        var me = this;
        pages = pages || me.extractedPages;
        for (var i = 0,
            l = pages.length; i < l; i++) {
            var page = pages[i];
            page.html = me.applyPageTpl(page);
        }
        return pages;
    },
    /**
     * @private
     * Builds HTML content of the page by applying provided page data to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the page.
     */
    applyPageTpl: function(pageInfo) {
        var me = this;
        return me.getTpl().apply(me.getPageTplData(pageInfo));
    },
    /**
     * @private
     * Builds HTML content of the page header by applying provided page data to the {@link #headerTpl header template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the header.
     */
    applyHeaderTpl: function(pageInfo) {
        var me = this,
            headerTpl = me.getHeaderTpl();
        if (me.exportConfig.showHeader && headerTpl) {
            // if function was provided to alter tpl data
            var fn = me.headerTplDataFn;
            var alterData = fn && fn.call(me.headerTplDataFnScope || me, pageInfo);
            var headerHtml = headerTpl.apply(Ext.apply(me.getHeaderTplData(pageInfo), alterData));
            // Now make sure any header IMG URLs are absolute
            var div = document.createElement('div');
            div.innerHTML = headerHtml;
            Ext.fly(div).select('img').each(function(img) {
                img.dom.setAttribute('src', img.dom.src);
            });
            return div.innerHTML;
        }
        return '';
    },
    /**
     * @private
     * Builds HTML content of the page footer by applying provided page data to the {@link #footerTpl footer template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the footer.
     */
    applyFooterTpl: function(pageInfo) {
        var me = this,
            footerTpl = me.getFooterTpl();
        if (me.exportConfig.showFooter && footerTpl) {
            // if function was provided to alter tpl data
            var fn = me.footerTplDataFn;
            var alterData = fn && fn.call(me.footerTplDataFnScope || me, pageInfo);
            var footerHtml = footerTpl.apply(Ext.apply(me.getFooterTplData(pageInfo), alterData));
            // Now make sure any footer IMG URLs are absolute
            var div = document.createElement('div');
            div.innerHTML = footerHtml;
            Ext.fly(div).select('img').each(function(img) {
                img.dom.setAttribute('src', img.dom.src);
            });
            return div.innerHTML;
        }
        return '';
    },
    /**
     * @protected
     * Function to provide data for the {@link #headerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page header (page width)
     * @return {Number} return.height height of the page header
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getHeaderTplData: function(pageInfo) {
        var me = this;
        return {
            width: me.paperWidth,
            height: me.headerHeight,
            totalPages: me.numberOfPages,
            pageNo: pageInfo.number
        };
    },
    /**
     * @protected
     * Function to provide data for the {@link #footerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page footer (page width)
     * @return {Number} return.height height of the page footer
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getFooterTplData: function(pageInfo) {
        var me = this;
        return {
            width: me.paperWidth,
            height: me.footerHeight,
            totalPages: me.numberOfPages,
            pageNo: pageInfo.number
        };
    },
    /**
     * @private
     * Provides data to be applied to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object}      Data to be applied to the {@link #tpl page template}:
     * @return {String} return.bodyClasses         copied BODY element CSS classes
     * @return {String} return.bodyHeight          height of the HTML content of the extracted page
     * @return {String} return.componentClasses    copied the component element CSS classes
     * @return {String} return.styles              stylesheet links
     * @return {String} return.showHeader          `true` if the header has to be shown
     * @return {String} return.showFooter          `true` if the footer has to be shown
     * @return {String} return.header              the header content
     * @return {String} return.HTML                HTML content of the extracted page
     * @return {String} return.footer              the footer content
     * @return {String} return.totalWidth          the page width
     * @return {String} return.pageNo              the page number
     * @return {String} return.totalPages          total number of pages
     * @return {String} return.title               the page title
     */
    getPageTplData: function(pageInfo) {
        var me = this;
        return {
            id: me.getComponent().id,
            bodyClasses: me.getBodyClasses(),
            bodyHeight: me.printHeight + me.gridHeaderHeight,
            componentClasses: me.getComponentClasses(),
            styles: me.stylesheets,
            showHeader: me.exportConfig.showHeader,
            showFooter: me.exportConfig.showFooter,
            header: me.applyHeaderTpl(pageInfo),
            HTML: pageInfo.html,
            footer: me.applyFooterTpl(pageInfo),
            totalWidth: me.paperWidth,
            pageNo: pageInfo.number,
            totalPages: me.numberOfPages,
            title: pageInfo.number + ' of ' + me.numberOfPages
        };
    },
    /**
     * @private
     * Resizes the component to fit it into specified paper size, export settings etc. (depending on implemented pagination rules).
     */
    fitComponentIntoPage: Ext.emptyFn,
    /**
     * @private
     * Function that retrieves the table body of the locked grid.
     * @param {Ext.dom.Element} [element] The fragment root for the selector. Defaults to current page.
     * @return {HTMLElement} Table body element of the locked grid.
     */
    getLockedGridBody: function(element) {
        element = element || this.getCurrentPage();
        return element.down(this.lockedBodySelector + ' ' + this.tableSelector, true);
    },
    /**
     * @private
     * Retrieves the table body of the normal grid.
     * @param {Ext.dom.Element} [element] The root element to retrieve from. Defaults to current page.
     * @return {HTMLElement} Table body element of the normal grid.
     */
    getNormalGridBody: function(element) {
        element = element || this.getCurrentPage();
        return element.down(this.normalBodySelector + ' ' + this.tableSelector, true);
    },
    emptyLockedGrid: function(element) {
        Ext.fly(this.getLockedGridBody(element)).select(this.lockedView.getItemSelector()).remove();
    },
    fillGrids: function(lockedRows, normalRows, clone, append) {
        var me = this;
        me.fillLockedGrid(lockedRows, clone, append);
        me.fillNormalGrid(normalRows, clone, append);
    },
    fillLockedGrid: function(rows, clone, append) {
        var me = this;
        if (!append)  {
            me.emptyLockedGrid();
        }
        
        me.appendRows(me.getLockedGridBody(), rows || me.lockedRows, clone);
    },
    fillNormalGrid: function(rows, clone, append) {
        var me = this;
        if (!append)  {
            me.emptyNormalGrid();
        }
        
        me.appendRows(me.getNormalGridBody(), rows || me.normalRows, clone);
    },
    appendRows: function(domNode, children, clone) {
        for (var i = 0,
            l = children.length; i < l; i++) {
            domNode.appendChild(clone ? children[i].row.cloneNode(true) : children[i].row);
        }
    },
    emptyNormalGrid: function(element) {
        Ext.fly(this.getNormalGridBody(element)).select(this.normalView.getItemSelector()).remove();
    },
    getRowHeight: function() {
        return this.view.timeAxisViewModel.getViewRowHeight();
    },
    /**
     * @private
     * Returns full width and height of both grids.
     * @return {Object} Object containing `width` and `height` properties.
     */
    getTotalSize: function() {
        return {
            width: this.getTotalWidth(),
            height: this.getTotalHeight()
        };
    },
    /**
     * @private
     * Returns full height of the component.
     * @return {Number} Full height of the component.
     */
    getTotalHeight: function() {
        var me = this,
            viewHeight;
        if (me.isBuffered()) {
            viewHeight = me.bufferedHeightMargin + me.normalRowsHeight;
        } else {
            viewHeight = me.lockedView.getEl().down(me.tableSelector).getHeight();
        }
        return me.headerHeight + viewHeight;
    },
    /**
     * @private
     * Returns full width of the component.
     * @return {Number} Full width of both grids.
     */
    getTotalWidth: function() {
        var splitWidth;
        // https://www.sencha.com/forum/showthread.php?332079-Split-config-is-set-on-locked-part-of-grid-not-owner-grid
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            splitWidth = this.component.lockedGrid.split ? this.component.down('splitter').getWidth() : 0;
        } else {
            splitWidth = this.component.split ? this.component.down('splitter').getWidth() : 0;
        }
        return this.getLockedGridWidth() + splitWidth + this.normalView.getEl().down(this.tableSelector).getWidth();
    },
    getLockedGridWidth: function() {
        var columns = this.exportConfig.columns;
        // #4816
        // If empty column set is exported, 0 should be returned, otherwise empty space will appear
        // in the normal view
        if (columns && columns.length === 0) {
            return 0;
        }
        return this.lockedHeader.getEl().down('.' + Ext.baseCSSPrefix + 'box-inner').getWidth();
    },
    getNormalGridWidth: function() {
        return this.normalHeader.getEl().down('.' + Ext.baseCSSPrefix + 'box-inner').getWidth();
    },
    /**
     * @private
     * Performs last changes to {@link #getCurrentPage the current page} being extracted before it's pushed into {@link #extractedPages} array.
     * @param {Object} [config] Optional configuration object.
     * @return {Ext.dom.Element} element Element holding the page.
     */
    preparePageToCommit: function(config) {
        //create empty div that will temporarily hold our panel current HTML
        var frag = this.getCurrentPage(),
            component = this.component,
            lockedGrid = component.lockedGrid,
            normalGrid = component.normalGrid,
            secondaryCanvas = frag.down('.sch-secondary-canvas', true);
        frag.select('.sch-remove').remove();
        var get = function(id) {
                return frag.down('#' + id, true);
            },
            elapseWidth = function(el) {
                if (el)  {
                    el.style.width = '100%';
                }
                
            },
            elapseHeight = function(el) {
                if (el)  {
                    el.style.height = '100%';
                }
                
            };
        var normalBody = frag.down(this.normalBodySelector, true);
        normalBody.style.top = '0px';
        var lockedBody = frag.down(this.lockedBodySelector, true);
        lockedBody.style.top = '0px';
        // remove transform:translate3d(...) from views item container element
        // otherwise it might mess top coordinate of the exported rows (checked in: 015_export_current_view)
        var lockedItemsContainer = this.getLockedGridBody(),
            normaItemsContainer = this.getNormalGridBody();
        if (lockedItemsContainer)  {
            lockedItemsContainer.style.transform = '';
        }
        
        if (normaItemsContainer)  {
            normaItemsContainer.style.transform = '';
        }
        
        if (secondaryCanvas) {
            secondaryCanvas.style.top = this.secondaryCanvasOffset + 'px';
            Ext.fly(secondaryCanvas).select('.sch-column-line').setHeight(this.normalRowsHeight);
        }
        // we elapse some elements width and/or height
        var lockedElements = [
                get(component.id + '-targetEl'),
                get(component.id + '-innerCt'),
                get(lockedGrid.id),
                get(lockedGrid.body.id),
                get(lockedGrid.view.el.id)
            ];
        // https://www.sencha.com/forum/showthread.php?332055-Hiding-normal-grid-messes-locked-part
        if (Ext.getVersion().isGreaterThan('6.2.0')) {
            var basePrefix = '.' + Ext.baseCSSPrefix;
            var scrollContainer = frag.down(basePrefix + 'grid-scroll-container', true);
            scrollContainer.style.top = this.gridHeaderHeight + 1 + 'px';
            scrollContainer.style.left = 0;
            elapseHeight(scrollContainer);
            elapseWidth(scrollContainer);
            // Set height of scroll body to 100% and hide vertical scrollbar
            // covered by 005_export_rows_horizontal
            var scrollBody = frag.down(basePrefix + 'grid-scroll-body', true);
            elapseHeight(scrollBody);
            scrollBody.style['overflow-y'] = 'hidden';
            // make views to fit container
            Ext.Array.each(frag.query(basePrefix + 'grid-view', true), function(el) {
                elapseHeight(el);
            });
            // remove margin so last row is displayed correctly
            lockedBody.style.margin = normalBody.style.margin = 0;
            // remove spacers, so height could be calculated correctly in test
            Ext.Array.each(frag.query(basePrefix + 'grid-scroll-container ' + basePrefix + 'scroller-spacer', true), function(el) {
                el.parentNode.removeChild(el);
            });
            // https://app.assembla.com/spaces/bryntum/tickets/3648
            // Set zindex to force splitter visibility
            var splitter = frag.down('.' + Ext.baseCSSPrefix + 'splitter', true);
            if (splitter) {
                Ext.fly(splitter).setZIndex(2);
            }
        }
        Ext.Array.each(lockedElements, elapseHeight);
        elapseWidth(lockedElements[0]);
        elapseWidth(lockedElements[1]);
        if (Ext.isIE) {
            var el = get(normalGrid.headerCt.id);
            if (el)  {
                el.style.width = '';
            }
            
        } else {
            elapseWidth(get(normalGrid.headerCt.id));
        }
        Ext.Array.each([
            get(normalGrid.id),
            get(normalGrid.body.id),
            get(normalGrid.getView().id)
        ], function(el) {
            if (el) {
                el.style.height = el.style.width = '100%';
            }
        });
        // adjust body style to fit to content properly
        frag.dom.style.height = '100%';
        frag.dom.style.width = '';
        // remove top position since we are not exporting panel title
        frag.dom.style.top = '';
        return frag;
    },
    /**
     * @private
     * Starts a new page. Initializes {@link #currentPage} with a copy of the component that will
     * be filled with collected rows based on implemented pagination rules.
     * @param  {Ext.dom.Element} [pageEl] Element to make a copy of. This is optional by default will make a copy of {@link #getComponent the component}.
     */
    startPage: function(pageEl) {
        var me = this;
        // make a detached copy of the component body
        var copy = (pageEl || me.getComponent().body).dom.cloneNode(true);
        copy.id = '';
        // and put it into storedFragment
        me.setCurrentPage(Ext.get(copy));
    },
    scrollTo: function(position, callback, scope) {
        var me = this;
        var record = me.component.store.getAt(position);
        if (record) {
            me.component.ensureVisible(record, {
                callback: function() {
                    //https://app.assembla.com/spaces/bryntum/tickets/6629-exporter-collectnormalrow-and-collectlockedrows-throw-exception/details
                    me.component.syncRowHeights();
                    if (callback) {
                        callback.apply(scope || me);
                    }
                },
                select: false,
                focus: false,
                animate: false
            });
        } else {
            callback.apply(scope || me);
        }
    },
    removeNode: function(el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        } else {
            if (el.elements) {
                for (var i = 0; i < el.elements.length; i++) {
                    var elem = el.elements[i];
                    elem.parentNode.removeChild(elem);
                }
            }
        }
    },
    //private
    restoreInfiniteScroll: function(panel) {
        var view = panel.getSchedulingView();
        if (panel.infiniteScroll && view.rendered) {
            // restore saved time span and scroll position
            panel.timeAxis.setTimeSpan(this._oldStart, this._oldEnd);
            view.setScrollX(this._oldScrollX);
            // enable back infiniteScroll mode event listeners
            view.bindInfiniteScrollListeners();
        }
    },
    //private
    suspendInfiniteScroll: function(panel) {
        var view = panel.getSchedulingView();
        // unbind events reacting on scroll specific to infiniteScroll mode
        if (panel.infiniteScroll && view.rendered) {
            view.unbindInfiniteScrollListeners();
            // remember current time span and scroll position
            this._oldStart = panel.timeAxis.getStart();
            this._oldEnd = panel.timeAxis.getEnd();
            this._oldScrollX = view.getScrollX();
            var span = panel.getEventStore().getTotalTimeSpan();
            panel.setTimeSpan(span.start, span.end);
        }
    },
    dependencyPainterMembers: {
        getItemBox: function(primaryView, task) {
            var me = this,
                box = me.exporter.eventBoxes[task.internalId];
            return box || this.callParent(arguments);
        }
    },
    // Cretes a copy of the component dependency painter
    // that we're gonna use instead of the component's one
    initDependencyPainter: function(component) {
        var me = this,
            depView = component.getDependencyView();
        // if there is a dependency view
        if (depView) {
            // clone real painter
            me.dependencyPainter = depView.clonePainter();
            // and override its "exporter" property and "getItemBox" method
            Ext.override(me.dependencyPainter, Ext.apply({}, {
                exporter: me
            }, me.dependencyPainterMembers));
        }
        me.depView = depView;
        me.eventBoxes = {};
    },
    fillRecordRelatedBoxes: function(record) {
        var me = this,
            view = me.normalView,
            painter = me.depView.painter,
            dependencyStore = me.depView.getDependencyStore();
        var events = record.getEvents();
        for (var j = 0; j < events.length; j++) {
            var task = events[j];
            // Ignore events that does not belong to timeaxis
            if (view.timeAxis.isRangeInAxis(task) && dependencyStore.getEventDependencies(task).length) {
                var box = painter.getItemBox(view, task);
                for (var i = 0; i < box.length; i++) {
                    // WARNING view.bufferedRenderer.bodyTop is private
                    // dependency painter doesn't take bufferedRenderer.bodyTop into account
                    // but we need to do it
                    if (view.bufferedRenderer) {
                        box[i].top += view.bufferedRenderer.bodyTop;
                        box[i].bottom += view.bufferedRenderer.bodyTop;
                    }
                    // we want all tasks to be considered as visible
                    box[i].rendered = true;
                }
                me.eventBoxes[task.internalId] = box;
            }
        }
    },
    renderDependencies: function() {
        var me = this,
            depView = me.depView;
        if (depView.getDrawDependencies()) {
            me.dependenciesHtml = me.dependencyPainter.generatePaintMarkup(depView.getPrimaryView(), depView.getDependencyStore().getRange());
        } else {
            me.dependenciesHtml = '';
        }
    }
});

/**
 @class Sch.plugin.exporter.SinglePage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts all scheduler data to fit in a single page.

 The exporter id of this exporter is `singlepage`
 */
Ext.define('Sch.plugin.exporter.SinglePage', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Single page'
     */
    config: {
        id: 'singlepage'
    },
    getExpectedNumberOfPages: function() {
        return 1;
    },
    getPaperFormat: function() {
        var me = this,
            realSize = me.getTotalSize(),
            width = realSize.width,
            height = realSize.height + 110;
        return width + 'px*' + height + 'px';
    },
    onRowsCollected: function() {
        var me = this;
        me.startPage();
        me.fillGrids();
        me.commitPage();
        me.onPagesExtracted();
    },
    getPageTplData: function() {
        var me = this,
            realSize = me.getTotalSize();
        return Ext.apply(me.callParent(arguments), {
            bodyHeight: realSize.height,
            totalWidth: realSize.width
        });
    },
    getHeaderTplData: function(pageInfo) {
        var me = this;
        return Ext.apply(me.callParent(arguments), {
            width: me.getTotalWidth(),
            height: me.headerHeight
        });
    },
    getFooterTplData: function(pageInfo) {
        var me = this;
        return Ext.apply(me.callParent(arguments), {
            width: me.getTotalWidth(),
            height: me.footerHeight
        });
    },
    fitComponentIntoPage: function(config) {
        var me = this,
            lockedGrid = me.lockedGrid;
        // If empty array of columns is passed set locked grid width to 0. Columns cannot be hidden due to sencha bug
        // see #4104
        if (config.columns && !config.columns.length) {
            lockedGrid.setWidth(0);
        } else {
            lockedGrid.setWidth(Ext.fly(lockedGrid.getView().getNodeContainer()).getWidth());
        }
    },
    preparePageToCommit: function() {
        var me = this,
            frag = me.callParent(arguments),
            secondaryCanvas = frag.select('.sch-secondary-canvas').first(),
            zones = secondaryCanvas.select('.sch-zone'),
            lines = secondaryCanvas.select('.sch-column-line'),
            height = me.getTotalHeight();
        secondaryCanvas.setTop(-this.firstExportedRowOffset);
        zones.setHeight(height);
        lines.setHeight(height);
        var depsCt = frag.selectNode('.sch-dependencyview-ct');
        if (depsCt) {
            depsCt.innerHTML = me.dependenciesHtml;
            //move the dependencies div to match the position of the dependency lines
            depsCt.style.top = -this.firstExportedRowOffset + 'px';
            depsCt.style.left = '0px';
            depsCt.style.visibility = 'visible';
        }
        // hiding dependencies
        var normalView = me.normalView,
            tableWidth = normalView.getEl().down(me.tableSelector).getWidth(),
            id = normalView.id,
            el = frag.select('#' + id).first().dom;
        el.style.width = tableWidth + 'px';
        var normalViewEl = frag.selectNode('#' + me.normalView.id);
        //remove scrollbar
        normalViewEl.style.overflow = 'hidden';
        var splitter = frag.selectNode('.' + Ext.baseCSSPrefix + 'splitter');
        if (splitter)  {
            splitter.style.height = '100%';
        }
        
        return frag;
    }
});

/**
 @class Sch.plugin.exporter.MultiPage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts pages in a vertical and horizontal order.

 The exporter id of this exporter is `multipage`
 */
Ext.define('Sch.plugin.exporter.MultiPage', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values
     *
     * - name : 'Multi pages'
     */
    config: {
        id: 'multipage'
    },
    rowPageIndex: 0,
    columnPageIndex: 0,
    pagesPerColumn: 0,
    depsTopOffset: 0,
    onRowsCollected: function(lockedRows, normalRows) {
        var me = this;
        me.depsTopOffset = -me.firstExportedRowOffset;
        // reset row/column page counters
        me.rowPageIndex = 0;
        me.columnPageIndex = 0;
        me.pagesPerColumn = 0;
        // - build page frame (skeleton) for each page column,
        me.buildPageFrames(function() {
            // - build pages by filling grids w/ collected rows
            // - finish exporting by launching `onPagesExtracted`
            me.buildPages(me.onPagesExtracted, me, lockedRows, normalRows);
        });
    },
    /**
     * @private
     * Builds pages using collected rows. Uses {@link #pagesFrames page frames} built by {@link #buildPageFrames} method.
     * Calls provided function on pages building completion.
     * @param  {Function} callback Function to be called on building completion.
     * @param  {Object}   [scope] Scope for the specified function. By default set to this exporter instance.
     */
    buildPages: function(callback, scope, lockedRows, normalRows) {
        var me = this,
            frame = me.pageFrames[0];
        // start new column page based on specified frame
        me.startPage(frame, true);
        // handle each collected row w/ `rowIteratorStep` method
        this.iterateAsync(me.rowIteratorStep, me, {
            rowIndex: 0,
            pageFrame: frame,
            rowsHeight: 0,
            leftHeight: this.printHeight,
            lockeds: [],
            normals: [],
            lockedRows: lockedRows,
            normalRows: normalRows,
            callback: callback,
            scope: scope || me
        });
    },
    /**
     * @private
     * Processes a collected row and decides on its distribution between pages.
     * @param  {Function} next    A callback function to call to proceed w/ a next row.
     * @param  {Object}   context Processing context:
     * @param  {Object}   context.rowIndex Zero based index of the row.
     */
    rowIteratorStep: function(next, context) {
        var me = this,
            rowIndex = context.rowIndex,
            lockedRows = context.lockedRows,
            normalRows = context.normalRows,
            leftHeight = context.leftHeight,
            lockeds = context.lockeds,
            normals = context.normals,
            async = true;
        // if we have rows to handle
        if (rowIndex < normalRows.length) {
            var lockedRow = lockedRows[rowIndex],
                normalRow = normalRows[rowIndex];
            // if row fits into current page
            if (normalRow.height <= leftHeight) {
                // gather rows into temp arrays
                lockeds.push(lockedRow);
                normals.push(normalRow);
                context.leftHeight -= normalRow.height;
                context.rowsHeight += normalRow.height;
                async = false;
            } else // ..if doesn't fit
            {
                // flush temp arrays to fill page with gathered rows
                me.fillGrids(lockeds, normals, context.pageFrame);
                // and start a new page
                me.commitPage({
                    rowsHeight: context.rowsHeight
                });
                me.startPage(context.pageFrame);
                context.lockeds = [
                    lockedRow
                ];
                context.normals = [
                    normalRow
                ];
                context.leftHeight = me.printHeight - normalRow.height;
                context.rowsHeight = normalRow.height;
            }
            context.rowIndex++;
        }
        // if we have more column pages to build
        else if (me.columnPageIndex < me.pageFrames.length) {
            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({
                rowsHeight: context.rowsHeight
            });
            // me.columnPageIndex is 1-based so it points to the neaxt frame in me.pageFrames array
            context.pageFrame = me.pageFrames[me.columnPageIndex];
            // start new column page based on specified frame
            me.startPage(context.pageFrame, true);
            context.leftHeight = me.printHeight;
            context.rowsHeight = 0;
            context.lockeds = [];
            context.normals = [];
            context.rowIndex = 0;
        } else // if we ran out of rows & columns then we finished
        {
            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({
                rowsHeight: context.rowsHeight
            });
            // run specified callback on completion
            context.callback.call(context.scope);
            return;
        }
        // handle next row
        if (async) {
            next(context);
        } else {
            me.rowIteratorStep(next, context);
        }
    },
    fillGrids: function(lockeds, normals, frame) {
        var me = this,
            hasLockedGrid = me.lockedColumnPages[me.columnPageIndex - 1],
            hasNormalGrid = !hasLockedGrid || (hasLockedGrid && hasLockedGrid.leftWidth);
        if (hasLockedGrid) {
            me.fillLockedGrid(lockeds, true);
            me.removeHiddenLockedColumns(hasLockedGrid);
        }
        if (hasNormalGrid) {
            me.fillNormalGrid(normals, true);
            me.removeInvisibleEvents(-frame.normalGridOffset, -frame.normalGridOffset + frame.normalGridWidth);
        }
    },
    /**
     * @private
     * Builds a page frame, a DOM-"skeleton" for a future pages.
     * @param  {Number} colIndex Zero based index of page column to build frame for.
     * @param  {Number} offset   Proper normal grid offset for the page column.
     * @return {Ext.dom.Element} Column page frame.
     */
    buildPageFrame: function(colIndex, offset) {
        var me = this,
            lockedCols = me.lockedColumnPages[colIndex];
        // if this page column has locked grid
        if (lockedCols) {
            me.lockedGrid.setWidth(me.showLockedColumns(lockedCols.start, lockedCols.end) + (lockedCols.startOffset || 0));
            // if there is some room after locked grid let's show normal grid
            if (lockedCols.leftWidth) {
                me.normalGrid.show();
            } else // otherwise we hide normal grid
            {
                // If we hide normal grid here, locked header height will be decreased, as there's nothing stretching it
                // Save it manually
                // https://app.assembla.com/spaces/bryntum/tickets/3646
                var lockedHeaderHeight = me.lockedGrid.headerCt.getHeight();
                me.lockedGrid.getVisibleColumns()[0].setHeight(lockedHeaderHeight);
                me.normalGrid.hide();
            }
        } else // if no locked grid on the page
        {
            me.lockedGrid.setWidth(0);
            me.lockedGrid.hide();
            me.normalGrid.show();
        }
        // now after we set locked columns/grid and normal grid visibility
        // we clone the content of the component
        var copy = me.getComponent().body.dom.cloneNode(true);
        copy.id = '';
        copy = Ext.get(copy);
        copy.normalGridOffset = offset;
        copy.lockedGridOffset = lockedCols && lockedCols.startOffset || 0;
        copy.normalGridWidth = me.normalGrid.getWidth();
        copy.lockedGridWidth = me.lockedGrid.getWidth();
        // do some CSS-tweaks to shift locked grid
        copy.down(me.lockedBodySelector, true).style.position = '';
        copy.down('#' + me.lockedView.id, true).style.overflow = 'visible';
        // if normal grid is visible on this column page
        // do some CSS-tweaks to place normal grid to show only this page content
        if (!me.normalGrid.hidden) {
            var table = copy.select(me.normalBodySelector).first();
            table.dom.style.position = '';
            table.dom.style.top = '0px';
            var body = me.getNormalGridBody(copy);
            var header = copy.down('#' + me.normalView.headerCt.id, true);
            var secondaryCanvas = copy.down('.sch-secondary-canvas', true);
            var view = copy.down('#' + me.normalView.id, true);
            body.style.left = offset + 'px';
            if (!lockedCols)  {
                copy.down('#' + me.normalGrid.id, true).style['border-style'] = 'none';
            }
            
            header.style.left = offset + 'px';
            header.style.overflow = 'visible';
            secondaryCanvas.style.left = offset + 'px';
            view.style.overflow = 'visible';
        }
        return copy;
    },
    /**
     * @private
     * Builds column page frames.
     * @param  {Function} callback A callback function to call on completion
     * @param  {Ext.dom.Element[]} callback.pageFrames An array of page frames built
     * @param  {[type]}   scope    A scope for the specified callback function
     */
    buildPageFrames: function(callback, scope) {
        var me = this;
        scope = scope || me;
        // markup locked columns ranges for page columns
        me.lockedColumnPages = me.calculateLockedColumnPages();
        var columnPagesNum = Math.ceil(me.getTotalWidth() / me.paperWidth),
            pageFrames = me.pageFrames = [];
        me.iterateAsync(function(next, colIndex, offset) {
            // on build completion we call provided function
            if (colIndex >= columnPagesNum) {
                callback.call(scope, pageFrames);
                return;
            }
            pageFrames.push(me.buildPageFrame(colIndex, offset));
            var lockedCols = me.lockedColumnPages[colIndex];
            // adjust normal grid offset for the next page column
            if (lockedCols) {
                offset -= lockedCols.leftWidth || 0;
            } else {
                offset -= me.paperWidth;
            }
            // let's build frame for next page column
            next(colIndex + 1, offset);
        }, me, 0, 0);
    },
    startPage: function(pattern, newColumnPage) {
        var me = this;
        if (newColumnPage) {
            me.depsTopOffset = -me.firstExportedRowOffset;
            // on the very first page commit step we know the exact number of row pages
            // let's keep that value
            if (me.columnPageIndex == 1) {
                me.pagesPerColumn = me.extractedPages.length;
            }
            me.rowPageIndex = 0;
            me.columnPageIndex++;
            me.secondaryCanvasOffset = me.firstExportedRowOffset;
        }
        me.rowPageIndex++;
        me.callParent(arguments);
        me.emptyNormalGrid();
        me.emptyLockedGrid();
    },
    commitPage: function(cfg) {
        var me = this;
        me.callParent([
            Ext.apply({
                row: me.rowPageIndex,
                column: me.columnPageIndex
            }, cfg)
        ]);
        // shift the secondary canvas vertically by the sum of processed rows height
        me.secondaryCanvasOffset -= cfg.rowsHeight;
        // on next page dependencies will be shifted vertically based on this page height
        me.depsTopOffset -= cfg.rowsHeight;
    },
    getExpectedPagesPerColumn: function() {
        return this.pagesPerColumn || Math.ceil((this.normalRowsHeight || this.component.store.count() * this.component.getRowHeight()) / this.printHeight);
    },
    getExpectedColumnsNumber: function() {
        return this.pageFrames ? this.pageFrames.length : Math.ceil((this.lockedGrid.getWidth() + this.ticks.length * this.view.timeAxisViewModel.getTickWidth()) / this.paperWidth);
    },
    getExpectedNumberOfPages: function() {
        return this.getExpectedColumnsNumber() * this.getExpectedPagesPerColumn();
    },
    /**
     * @private
     * Calculates which locked columns belong to which page.
     * @return {Object[]} Array of object
     */
    calculateLockedColumnPages: function() {
        var me = this,
            result = [],
            columns = me.lockedColumns,
            leftWidth = me.paperWidth,
            page;
        for (var i = 0,
            l = columns.length; i < l; i++) {
            var column = columns[i],
                width = column.width;
            page = page || {
                start: i,
                end: i
            };
            leftWidth -= width;
            // if column violated page width
            if (leftWidth < 0) {
                // push page
                result.push(page);
                if (leftWidth) {
                    page = {
                        start: i,
                        end: i
                    };
                }
                leftWidth = me.paperWidth - width + leftWidth;
            } else {
                page.end = i;
            }
        }
        // if we have unpushed column page
        if (page) {
            page.leftWidth = leftWidth;
            result.push(page);
        }
        return result;
    },
    getPageTplData: function(data) {
        return Ext.apply(this.callParent(arguments), {
            title: data.number + ' of ' + this.numberOfPages + ' (column: ' + data.column + ', row: ' + data.row + ')'
        });
    },
    showLockedColumns: function(startColumn, endColumn) {
        var me = this,
            columns = me.lockedColumns,
            width = 0;
        startColumn = startColumn || 0;
        endColumn = endColumn || columns.length - 1;
        for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            if (i >= startColumn && i <= endColumn) {
                column.column.show();
                width += column.width;
            } else {
                column.column.hide();
            }
        }
        return width;
    },
    removeInvisibleEvents: function(leftBorder, rightBorder) {
        var me = this,
            normalBody = me.getNormalGridBody(),
            eventSelector = me.normalView.eventSelector;
        Ext.Array.each(Ext.fly(normalBody).select(eventSelector).elements, function(el) {
            var start = parseInt(el.style.left, 10),
                end = start + parseInt(el.style.width, 10);
            if (end < leftBorder || start > rightBorder) {
                me.removeNode(el);
            }
        });
    },
    removeHiddenLockedColumns: function(lockedGrid) {
        var me = this,
            page = me.getCurrentPage(),
            tableBody = me.getLockedGridBody();
        for (var i = 0; i < me.lockedColumns.length; i++) {
            var column = me.lockedColumns[i].column;
            if (i < lockedGrid.start || i > lockedGrid.end) {
                var headerSelector = '#' + column.getId();
                var header = page.select(headerSelector);
                me.removeNode(header);
                var cellSelector = column.getCellSelector();
                var cells = Ext.fly(tableBody).select(cellSelector);
                me.removeNode(cells);
            }
        }
    },
    fitComponentIntoPage: function() {
        var me = this,
            component = me.getComponent();
        component.setWidth(me.paperWidth);
    },
    prepareComponent: function(component, config) {
        var me = this,
            columns = me.lockedColumns = [];
        me.callParent(arguments);
        // If non-empty array of columns is provided, keep visible locked columns data
        if (!(config.columns && config.columns.length === 0))  {
            me.lockedGrid.headerCt.items.each(function(column) {
                if (!column.hidden) {
                    columns.push({
                        column: column,
                        width: column.getWidth()
                    });
                }
            });
        }
        
    },
    restoreComponentState: function() {
        this.callParent(arguments);
        // restore locked columns visibility
        this.showLockedColumns();
    },
    /**
     * @private
     * Performs last changes to {@link #getCurrentPage the current page} being extracted before it's pushed into {@link #extractedPages} array.
     * This function will add dependencies to the output fragment.
     * @param {Object} [config] Optional configuration object.
     * @return {Ext.dom.Element} element Element holding the page.
     */
    preparePageToCommit: function(config) {
        var me = this,
            frag = me.callParent(arguments),
            splitter = frag.down('.' + Ext.baseCSSPrefix + 'splitter', true),
            depsCt = frag.selectNode('.sch-dependencyview-ct'),
            pageFrame = me.pageFrames[me.columnPageIndex - 1];
        if (splitter) {
            if (pageFrame.lockedHidden) {
                splitter.style.display = 'none';
                // fix normal grid position (it has "left" style equal to the splitter width)
                frag.down('.' + Ext.baseCSSPrefix + 'grid-inner-normal', true).style.left = 0;
            } else {
                Ext.fly(splitter).setHeight('100%');
            }
        }
        if (!pageFrame.normalHidden) {
            if (depsCt) {
                depsCt.innerHTML = me.dependenciesHtml;
                // move the dependencies div to match the position of the dependency lines
                depsCt.style.top = me.depsTopOffset + 'px';
                depsCt.style.visibility = 'visible';
            }
            var normalView = frag.selectNode('#' + me.normalView.id);
            if (normalView) {
                var tableWidth = me.normalView.getEl().down(me.tableSelector).getWidth();
                // hiding dependencies
                normalView.style.width = tableWidth + 'px';
                // remove scrollbars
                normalView.style.overflow = 'hidden';
            }
        }
        if (!pageFrame.lockedHidden) {
            var lockedView = frag.selectNode('#' + me.lockedView.id);
            if (lockedView) {
                // remove scrollbars
                lockedView.style.overflow = 'hidden';
            }
        }
        return frag;
    }
});

/**
 * This class extracts pages in a vertical order. It fits all locked columns and the timeaxis on a single page and will generate
 * new pages vertically down for the rows.
 *
 * The exporter identifier is `multipagevertical`.
*/
Ext.define('Sch.plugin.exporter.MultiPageVertical', {
    extend: 'Sch.plugin.exporter.AbstractExporter',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:
     *
     * - name    : 'Multi pages (vertically)'
     */
    config: {
        id: 'multipagevertical'
    },
    /**
     * @cfg minRowHeight Row heights are calculated based on column width shrink ratio regarding to paper width and height.
     * Minimum row height can be limited by this config.
     */
    minRowHeight: 20,
    minAverageColumnWidth: 100,
    visibleColumns: null,
    visibleColumnsWidth: 0,
    depsTopOffset: 0,
    onRowsCollected: function(lockedRows, normalRows) {
        var me = this;
        me.depsTopOffset = -me.firstExportedRowOffset;
        me.iterateAsync(function(next, rowIndex) {
            if (rowIndex === normalRows.length) {
                me.onPagesExtracted();
                return;
            }
            var index = rowIndex,
                spaceLeft = me.printHeight,
                rowsHeight = 0,
                lockeds = [],
                normals = [],
                newPage = false,
                normal, locked;
            me.startPage();
            while (!newPage && index < normalRows.length) {
                normal = normalRows[index];
                locked = lockedRows[index];
                spaceLeft -= normal.height;
                if (spaceLeft > 0) {
                    rowsHeight += normal.height;
                    locked && lockeds.push(locked);
                    normals.push(normal);
                    index++;
                } else {
                    newPage = true;
                }
            }
            me.fillGrids(lockeds, normals);
            me.commitPage({
                rowIndex: index,
                rowsHeight: rowsHeight
            });
            me.secondaryCanvasOffset -= rowsHeight;
            next(index);
        }, me, 0);
    },
    startPage: function() {
        var me = this;
        me.callParent(arguments);
        var view = me.getCurrentPage().select('#' + me.lockedView.id).first();
        view.dom.style.overflow = 'visible';
    },
    commitPage: function(pageData) {
        var me = this;
        me.callParent(arguments);
        if (me.depView && me.depView.getDependencyStore()) {
            // on next page dependencies will be shifted vertically based on this page height
            me.depsTopOffset -= pageData.rowsHeight;
        }
    },
    getExpectedNumberOfPages: function() {
        return Math.ceil(this.normalRowsHeight / this.printHeight);
    },
    prepareColumns: function(columns) {
        this.callParent(arguments);
        var me = this,
            visibleColumns = me.visibleColumns = [];
        me.visibleColumnsWidth = 0;
        // If no columns passed to exporter, no columns should be visible
        if (columns && columns.length === 0) {
            return;
        }
        me.lockedGrid.headerCt.items.each(function(column) {
            if (!column.hidden) {
                visibleColumns.push({
                    column: column,
                    width: column.getWidth()
                });
                me.visibleColumnsWidth += column.getWidth();
            }
        });
    },
    fitComponentIntoPage: function() {
        var me = this,
            component = me.getComponent(),
            view = component.getSchedulingView(),
            normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid,
            totalWidth = me.getTotalWidth(),
            ticks = me.ticks,
            timeColumnWidth = me.timeColumnWidth || view.timeAxisViewModel.getTickWidth();
        var lockedWidth = Math.floor((me.visibleColumnsWidth / totalWidth) * me.paperWidth);
        //correct lockedcolumn width if it is too small
        var visibleColumnCount = me.visibleColumns.length,
            preferedLockedWidth = visibleColumnCount * me.minAverageColumnWidth;
        //preferred locked width can never take more than half of the page
        preferedLockedWidth = preferedLockedWidth > me.paperWidth / 2 ? Math.floor(me.paperWidth / 2) : preferedLockedWidth;
        //if preferred width is wider than current locked width, then use preferred width
        lockedWidth = preferedLockedWidth > lockedWidth ? preferedLockedWidth : lockedWidth;
        var normalWidth = me.paperWidth - lockedWidth;
        var tickWidth = normalWidth / ticks.length;
        me.setRowHeight((tickWidth / timeColumnWidth) * me.getRowHeight());
        component.setWidth(me.paperWidth);
        normalGrid.setWidth(normalWidth);
        lockedGrid.setWidth(lockedWidth);
        //spread lockedcolums over the available width
        me.fitLockedColumnWidth(lockedWidth);
        component.setTimeColumnWidth(tickWidth);
    },
    setRowHeight: function(rowHeight) {
        var me = this;
        me.component.setRowHeight(rowHeight < me.minRowHeight ? me.minRowHeight : rowHeight);
    },
    /**
     * @private
     * Function that fits locked columns based on the available width.
     *
     * @param {String} totalWidth int indicating the totalWidth available for the locked columns.
     */
    fitLockedColumnWidth: function(totalWidth) {
        var me = this,
            visibleColumns = this.visibleColumns;
        //Keep ratio
        var ratio = totalWidth / me.visibleColumnsWidth;
        if (visibleColumns.length) {
            for (var i = 0; i < visibleColumns.length; i++) {
                var column = visibleColumns[i],
                    currentWidth = column.width,
                    width = Math.floor(currentWidth * ratio);
                column.column.setWidth(width);
            }
            this._restoreColumnWidth = true;
        }
    },
    restoreComponentState: function(component) {
        var me = this;
        component = component || me.getComponent();
        // restore original columns width (since we fit them while exporting)
        if (this._restoreColumnWidth) {
            var visibleColumns = this.visibleColumns;
            for (var i = 0; i < visibleColumns.length; i++) {
                var cWrap = visibleColumns[i];
                cWrap.column.setWidth(cWrap.width);
            }
        }
        this.callParent(arguments);
    },
    preparePageToCommit: function() {
        var me = this,
            frag = me.callParent(arguments),
            depsCt = frag.selectNode('.sch-dependencyview-ct');
        if (depsCt) {
            depsCt.innerHTML = me.dependenciesHtml;
            //move the dependencies div to match the position of the dependency lines
            depsCt.style.top = me.depsTopOffset + 'px';
            depsCt.style.left = '0px';
            depsCt.style.visibility = 'visible';
        }
        // hiding dependencies
        var tableWidth = me.normalView.getEl().down(me.tableSelector).getWidth();
        var normalView = frag.selectNode('#' + me.normalView.id);
        normalView.style.width = tableWidth + 'px';
        //remove scrollbar
        normalView.style.overflow = 'hidden';
        var lockedView = frag.selectNode('#' + me.lockedView.id);
        //remove scrollbar
        lockedView.style.overflow = 'hidden';
        var splitter = frag.selectNode('.' + Ext.baseCSSPrefix + 'splitter');
        if (splitter)  {
            splitter.style.height = '100%';
        }
        
        return frag;
    }
});

/**
@class Sch.widget.ResizePicker
@private
@extends Ext.Panel

Size picker widget for changing column width/rows height.

*/
Ext.define('Sch.widget.ResizePicker', {
    extend: 'Ext.Panel',
    alias: 'widget.dualrangepicker',
    width: 200,
    height: 200,
    border: true,
    collapsible: false,
    bodyStyle: 'position:absolute; margin:5px',
    verticalCfg: {
        height: 120,
        value: 24,
        increment: 2,
        minValue: 20,
        maxValue: 80,
        reverse: true,
        disabled: true
    },
    horizontalCfg: {
        width: 120,
        value: 100,
        minValue: 25,
        increment: 5,
        maxValue: 200,
        disable: true
    },
    initComponent: function() {
        var me = this;
        //me.addEvents('change', 'changecomplete', 'select');
        me.horizontalCfg.value = me.dialogConfig.columnWidth;
        me.verticalCfg.value = me.dialogConfig.rowHeight;
        me.verticalCfg.disabled = me.dialogConfig.scrollerDisabled || false;
        me.dockedItems = [
            me.vertical = new Ext.slider.Single(Ext.apply({
                dock: 'left',
                style: 'margin-top:10px',
                vertical: true,
                stateful: me.dialogConfig.stateful,
                stateId: 'exporter_resize_vertical',
                stateEvents: [
                    'change'
                ],
                listeners: {
                    change: me.onSliderChange,
                    changecomplete: me.onSliderChangeComplete,
                    scope: me
                }
            }, me.verticalCfg)),
            me.horizontal = new Ext.slider.Single(Ext.apply({
                dock: 'top',
                style: 'margin-left:28px',
                stateful: me.dialogConfig.stateful,
                stateId: 'exporter_resize_horizontal',
                stateEvents: [
                    'change'
                ],
                listeners: {
                    change: me.onSliderChange,
                    changecomplete: me.onSliderChangeComplete,
                    scope: me
                }
            }, me.horizontalCfg))
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.addCls('sch-ux-range-picker');
        me.valueHandle = me.body.createChild({
            cls: 'sch-ux-range-value',
            cn: {
                tag: 'span'
            }
        });
        me.valueSpan = me.valueHandle.down('span');
        var dd = new Ext.dd.DD(me.valueHandle);
        Ext.apply(dd, {
            startDrag: function() {
                me.dragging = true;
                this.constrainTo(me.body);
            },
            onDrag: function() {
                me.updateValuesFromHandles();
            },
            endDrag: function() {
                me.updateValuesFromHandles();
                me.dragging = false;
            }
        });
        me.setValues(me.getValues());
        me.callParent(arguments);
        me.body.on('click', me.onBodyClick, me);
    },
    onBodyClick: function(e, t) {
        var xy = [
                e.getXY()[0] - 8 - this.body.getX(),
                e.getXY()[1] - 8 - this.body.getY()
            ];
        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        this.updateValuesFromHandles();
        this.onSliderChangeComplete();
    },
    updateValuesFromHandles: function() {
        this.setValues(this.getValuesFromXY());
    },
    getAvailableWidth: function() {
        return this.body.getWidth() - 18;
    },
    getAvailableHeight: function() {
        return this.body.getHeight() - 18;
    },
    getValuesFromXY: function(xy) {
        xy = xy || [
            this.valueHandle.getLeft(true),
            this.valueHandle.getTop(true)
        ];
        var xFraction = xy[0] / this.getAvailableWidth();
        var yFraction = xy[1] / this.getAvailableHeight();
        var horizontalVal = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * xFraction);
        var verticalVal = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * yFraction) + this.verticalCfg.minValue;
        return [
            horizontalVal + this.horizontalCfg.minValue,
            verticalVal
        ];
    },
    getXYFromValues: function(values) {
        var xRange = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var yRange = this.verticalCfg.maxValue - this.verticalCfg.minValue;
        var x = Math.round((values[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / xRange);
        var verticalVal = values[1] - this.verticalCfg.minValue;
        var y = Math.round(verticalVal * this.getAvailableHeight() / yRange);
        return [
            x,
            y
        ];
    },
    updatePosition: function() {
        var values = this.getValues();
        var xy = this.getXYFromValues(values);
        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled) {
            this.valueHandle.setTop(this.dialogConfig.rowHeight);
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        }
        this.positionValueText();
        this.setValueText(values);
    },
    positionValueText: function() {
        var handleTop = this.valueHandle.getTop(true);
        var handleLeft = this.valueHandle.getLeft(true);
        this.valueSpan.setLeft(handleLeft > 30 ? -30 : 10);
        this.valueSpan.setTop(handleTop > 10 ? -20 : 20);
    },
    setValueText: function(values) {
        if (this.verticalCfg.disabled)  {
            values[1] = this.dialogConfig.rowHeight;
        }
        
        this.valueSpan.update('[' + values.toString() + ']');
    },
    setValues: function(values) {
        this.horizontal.setValue(values[0]);
        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled)  {
                this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - values[1]);
            }
            
        } else {
            if (!this.verticalCfg.disabled)  {
                this.vertical.setValue(values[1]);
            }
            
        }
        if (!this.dragging) {
            this.updatePosition();
        }
        this.positionValueText();
        this.setValueText(values);
    },
    getValues: function() {
        if (!this.verticalCfg.disabled) {
            var verticalVal = this.vertical.getValue();
            if (this.verticalCfg.reverse) {
                verticalVal = this.verticalCfg.maxValue - verticalVal + this.verticalCfg.minValue;
            }
            return [
                this.horizontal.getValue(),
                verticalVal
            ];
        }
        return [
            this.horizontal.getValue()
        ];
    },
    onSliderChange: function() {
        if (!this.rendered)  {
            return;
        }
        
        this.fireEvent('change', this, this.getValues());
        if (!this.dragging) {
            this.updatePosition();
        }
    },
    onSliderChangeComplete: function() {
        this.fireEvent('changecomplete', this, this.getValues());
    },
    afterLayout: function() {
        this.callParent(arguments);
        this.updatePosition();
    }
});

/**
 @class Sch.widget.ColumnPicker
 @private
 @extends Ext.form.field.ComboBox

 Columnpicker widget for picking columns from a panel.
 */
Ext.define('Sch.widget.ColumnPicker', {
    extend: 'Ext.form.field.ComboBox',
    requires: [
        'Ext.data.Store'
    ],
    multiSelect: true,
    valueField: 'id',
    displayField: 'name',
    forceSelection: true,
    editable: false,
    listConfig: {
        htmlEncode: true,
        cls: 'sch-columnpicker-list',
        // Has no effect due to https://www.sencha.com/forum/showthread.php?348390-Not-possible-to-provide-selectedItemCls-to-BoundList-cfg&p=1189906#post1189906
        selectedItemCls: Ext.baseCSSPrefix + 'fa fa-check'
    },
    /**
     * @cfg {Ext.grid.column.Column[]} An array of columns to choose from
     */
    columns: null,
    /**
     * @cfg {String} columnEmptyText Text to show when column text is empty
     */
    columnEmptyText: null,
    columnEmptyRegExp: /^(\s*|&(nbsp|#160);)$/,
    initComponent: function() {
        this.store = new Ext.data.Store({
            proxy: 'memory',
            fields: [
                'id',
                'name',
                'column'
            ],
            data: this.processColumns(this.columns)
        });
        this.callParent(arguments);
    },
    processColumns: function(columns) {
        var me = this,
            value = [],
            data = Ext.Array.map(columns || [], function(column) {
                if (!column.isHidden()) {
                    value.push(column.id);
                }
                return {
                    id: column.id,
                    name: me.getColumnTitle(column),
                    column: column
                };
            });
        this.value = this.value || value;
        return data;
    },
    getColumnTitle: function(column) {
        var me = this;
        return (!Ext.String.trim(column.text) || column.text.match(me.columnEmptyRegExp)) ? me.columnEmptyText : column.text;
    },
    // @OVERRIDE
    // https://www.sencha.com/forum/showthread.php?348390-Not-possible-to-provide-selectedItemCls-to-BoundList-cfg&p=1189906#post1189906
    getPicker: function() {
        var list = this.callParent(arguments);
        list.selectedItemCls += ' ' + Ext.baseCSSPrefix + 'fa fa-check';
        return list;
    },
    getSelectedColumns: function() {
        var me = this,
            value = me.getValue();
        if (!Ext.isArray(value)) {
            value = [
                value
            ];
        }
        return Ext.Array.map(value, function(id) {
            return me.store.getById(id).get('column');
        });
    }
});

/**
 @class Sch.widget.ExportDialogForm
 @private
 @extends Ext.form.Panel

 Form for {@link Sch.widget.ExportDialog}. This is a private class and can be overridden by providing `formPanel` option to
 {@link Sch.plugin.Export#cfg-exportDialogConfig exportDialogConfig}.
 */
Ext.define('Sch.widget.ExportDialogForm', {
    extend: 'Ext.form.Panel',
    requires: [
        'Ext.data.Store',
        'Ext.XTemplate',
        'Ext.form.field.Number',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Date',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Sch.widget.ResizePicker',
        'Sch.widget.ColumnPicker'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: 'widget.export_dialog_form',
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - formatFieldLabel         : 'Paper format',
            - orientationFieldLabel    : 'Orientation',
            - rangeFieldLabel          : 'Schedule range',
            - showHeaderLabel          : 'Show header',
            - showFooterLabel          : 'Show footer',
            - orientationPortraitText  : 'Portrait',
            - orientationLandscapeText : 'Landscape',
            - completeViewText         : 'Complete schedule',
            - currentViewText          : 'Visible schedule',
            - dateRangeText            : 'Date range',
            - dateRangeFromText        : 'Export from',
            - pickerText               : 'Resize column/rows to desired value',
            - dateRangeToText          : 'Export to',
            - exportersFieldLabel      : 'Control pagination',
            - adjustCols               : 'Adjust column width',
            - adjustColsAndRows        : 'Adjust column width and row height',
            - specifyDateRange         : 'Specify date range',
            - columnPickerLabel        : 'Select columns',
            - completeDataText         : 'Complete schedule (for all events)',
            - dpiFieldLabel            : 'DPI (dots per inch)',
            - rowsRangeLabel           : 'Rows range',
            - allRowsLabel             : 'All rows',
            - visibleRowsLabel         : 'Visible rows'
            - columnEmptyText          : '[no title]'
     */
    border: false,
    bodyPadding: '10 10 0 10',
    autoHeight: true,
    stateful: true,
    /**
     * @property {Ext.form.field.ComboBox} rangeField "Export range" field.
     */
    rangeField: null,
    resizerHolder: null,
    /**
     * @property {Sch.widget.ResizePicker} resizePicker "Resize column/rows to desired value" picker.
     */
    resizePicker: null,
    /**
     * @property {Ext.form.field.Date} "Export dateFromFieldfrom" field.
     */
    dateFromField: null,
    /**
     * @property {Ext.form.field.Date} dateToField "Export to" field.
     */
    dateToField: null,
    datesHolder: null,
    /**
     * @property {Sch.widget.ColumnPicker} columnPicker "Select columns for export" field.
     */
    columnPicker: null,
    /**
     * @property {Ext.form.field.ComboBox} rangeField "Rows range" field.
     */
    rowsRangeField: null,
    /**
     * @property {Ext.form.field.ComboBox} exportersField "Manage pagination" field.
     */
    exportersField: null,
    /**
     * @property {Ext.form.field.ComboBox} formatField "Paper format" field.
     */
    formatField: null,
    /**
     * @property {Ext.form.field.ComboBox} orientationField "Orientation" field.
     */
    orientationField: null,
    /**
     * @property {Ext.form.field.Number} dpiField "DPI (dots per inch)" field.
     */
    dpiField: null,
    /**
     * @property {Ext.form.field.Checkbox} showHeaderField "Show header" field.
     */
    showHeaderField: null,
    /**
     * @property {Ext.form.field.Checkbox} showFooterField "Show footer" field.
     */
    showFooterField: null,
    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date range fields ("Export from" and "Export to" fields).
     */
    dateRangeFormat: '',
    /**
     * @cfg {Object} columnPickerConfig Configuration for the "Select columns for export" field.
     */
    columnPickerConfig: null,
    /**
     * @cfg {Object} dpiFieldConfig Configuration for the "DPI (dots per inch)" field
     */
    dpiFieldConfig: null,
    /**
     * @cfg {Boolean} dateRangeRestriction Set to "false" to disable the maximum and minimum allowed value limits for the date range fields ("Export from" and "Export to" fields).
     */
    dateRangeRestriction: true,
    rangeFieldConfig: null,
    rowsRangeFieldConfig: null,
    formatFieldConfig: null,
    orientationFieldConfig: null,
    exportersFieldConfig: null,
    showHeaderFieldConfig: null,
    showFooterFieldConfig: null,
    dateFromFieldConfig: null,
    dateToFieldConfig: null,
    /**
     * @cfg {Boolean} showResizePicker Indicates if "Resize column/rows to desired value" panel should to be shown in the export dialog.
     */
    showResizePicker: false,
    /**
     * @cfg {Boolean} showColumnPicker Indicates if the "Select columns for export" field should to be shown in the export dialog.
     */
    showColumnPicker: true,
    /**
     * @cfg {Boolean} showDPIField Indicates if the "DPI (dots per inch)" field should to be shown in the export dialog.
     */
    showDPIField: true,
    /**
     * @cfg {Boolean} showShowHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     */
    showShowHeaderField: true,
    /**
     * @cfg {Boolean} showShowFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     */
    showShowFooterField: false,
    /**
     * @cfg {Boolean} showRowsRangeField Indicates if the "Rows range" field should be displayed in the export dialog.
     */
    showRowsRangeField: true,
    initComponent: function() {
        var me = this;
        me.fieldDefaults = Ext.apply({
            labelAlign: 'left',
            labelWidth: 120,
            anchor: '99%'
        }, me.fieldDefaults);
        me.items = me.createFields();
        me.callParent(arguments);
        // trigger fields `change` listeners to enable/disable related fields and do other UI cosmetics changes
        me.onRangeChange(me.rangeField, me.rangeField.getValue());
        me.onExporterChange(me.exportersField, me.exportersField.getValue());
    },
    isValid: function() {
        var me = this;
        if (me.rangeField.getValue() == 'date') {
            return me.dateFromField.isValid() && me.dateToField.isValid();
        }
        return true;
    },
    getValues: function(asString, dirtyOnly, includeEmptyText, useDataValues) {
        var result = this.callParent(arguments);
        if (this.showShowHeaderField)  {
            result.showHeader = !!result.showHeader;
        }
        
        if (this.showShowFooterField)  {
            result.showFooter = !!result.showFooter;
        }
        
        result.onlyVisibleRows = !!result.onlyVisibleRows;
        if (this.resizePicker && this.rangeField.getValue() == 'current') {
            var cellSize = this.resizePicker.getValues();
            if (asString) {
                result += '&cellSize[0]=' + cellSize[0] + '&cellSize[1]=' + cellSize[1];
            } else {
                result.cellSize = cellSize;
            }
        }
        if (this.columnPicker) {
            result.columns = this.columnPicker.getSelectedColumns();
        }
        return result;
    },
    createFields: function() {
        var me = this,
            beforeLabelTextTpl = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">',
            afterLabelTextTpl = '<td><div class="sch-fieldcontainer-separator"></div></table>';
        // col/row resizer
        if (me.showResizePicker) {
            me.resizePicker = new Sch.widget.ResizePicker({
                dialogConfig: me,
                margin: '10 20'
            });
            me.resizerHolder = new Ext.form.FieldContainer({
                fieldLabel: me.scrollerDisabled ? me.L('adjustCols') : me.L('adjustColsAndRows'),
                labelAlign: 'top',
                hidden: true,
                labelSeparator: '',
                beforeLabelTextTpl: beforeLabelTextTpl,
                afterLabelTextTpl: afterLabelTextTpl,
                layout: 'vbox',
                defaults: {
                    flex: 1,
                    allowBlank: false
                },
                items: [
                    me.resizePicker
                ]
            });
        }
        // from date
        me.dateFromField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'datefield',
            fieldLabel: me.L('dateRangeFromText'),
            baseBodyCls: 'sch-exportdialogform-date',
            name: 'dateFrom',
            format: me.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank: false,
            maxValue: me.dateRangeRestriction && me.endDate || null,
            minValue: me.dateRangeRestriction && me.startDate || null,
            value: me.startDate
        }), me.dateFromFieldConfig));
        // till date
        me.dateToField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
            xtype: 'datefield',
            fieldLabel: me.L('dateRangeToText'),
            name: 'dateTo',
            format: me.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls: 'sch-exportdialogform-date',
            allowBlank: false,
            maxValue: me.dateRangeRestriction && me.endDate || null,
            minValue: me.dateRangeRestriction && me.startDate || null,
            value: me.endDate
        }), me.dateToFieldConfig));
        // date fields holder
        me.datesHolder = new Ext.form.FieldContainer({
            fieldLabel: me.L('specifyDateRange'),
            labelAlign: 'top',
            hidden: true,
            labelSeparator: '',
            beforeLabelTextTpl: beforeLabelTextTpl,
            afterLabelTextTpl: afterLabelTextTpl,
            layout: 'vbox',
            defaults: {
                flex: 1,
                allowBlank: false
            },
            items: [
                me.dateFromField,
                me.dateToField
            ]
        });
        if (me.showColumnPicker) {
            me.columnPicker = new Sch.widget.ColumnPicker(me.applyStateful(Ext.apply({
                fieldLabel: me.L('columnPickerLabel'),
                columnEmptyText: me.L('columnEmptyText'),
                cls: 'sch-export-dialog-columns'
            }, me.columnPickerConfig)));
        }
        if (me.showDPIField) {
            me.dpiField = Ext.ComponentManager.create(Ext.apply(me.applyStateful({
                xtype: 'numberfield',
                fieldLabel: me.L('dpiFieldLabel'),
                cls: 'sch-export-dialog-dpi',
                minValue: 65,
                name: 'DPI',
                value: me.exportConfig.DPI,
                maxValue: 200
            }), me.dpiFieldConfig));
        }
        if (me.showShowHeaderField) {
            me.showHeaderField = Ext.ComponentManager.create(Ext.apply(me.applyStatefulFull({
                xtype: 'checkbox',
                fieldLabel: me.L('showHeaderLabel'),
                cls: 'sch-export-dialog-header',
                name: 'showHeader',
                checked: !!me.exportConfig.showHeader,
                checkedValue: true,
                uncheckedValue: false
            }), me.showHeaderFieldConfig));
        }
        if (me.showShowFooterField) {
            me.showFooterField = Ext.ComponentManager.create(Ext.apply(me.applyStatefulFull({
                xtype: 'checkbox',
                fieldLabel: me.L('showFooterLabel'),
                cls: 'sch-export-dialog-footer',
                name: 'showFooter',
                checked: !!me.exportConfig.showFooter,
                checkedValue: true,
                uncheckedValue: false
            }), me.showFooterFieldConfig));
        }
        me.formatField = Ext.ComponentManager.create(Ext.Object.merge(me.applyStateful({
            xtype: 'combobox',
            listConfig: {
                htmlEncode: true
            },
            fieldLabel: me.L('formatFieldLabel'),
            value: me.exportConfig.format,
            triggerAction: 'all',
            forceSelection: true,
            editable: false,
            name: 'format',
            queryMode: 'local',
            store: me.pageFormats || [
                "A5",
                "A4",
                "A3",
                "Letter",
                "Legal"
            ]
        }), me.formatFieldConfig));
        me.orientationField = Ext.ComponentManager.create(Ext.Object.merge(me.applyStateful({
            xtype: 'combobox',
            listConfig: {
                htmlEncode: true
            },
            fieldLabel: me.L('orientationFieldLabel'),
            value: me.exportConfig.orientation,
            triggerAction: 'all',
            forceSelection: true,
            editable: false,
            name: 'orientation',
            displayField: 'name',
            valueField: 'value',
            queryMode: 'local',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: [
                    {
                        name: me.L('orientationPortraitText'),
                        value: 'portrait'
                    },
                    {
                        name: me.L('orientationLandscapeText'),
                        value: 'landscape'
                    }
                ]
            }
        }), me.orientationFieldConfig));
        me.rangeField = Ext.ComponentManager.create(Ext.Object.merge(me.applyStateful({
            xtype: 'combobox',
            listConfig: {
                htmlEncode: true
            },
            fieldLabel: me.L('rangeFieldLabel'),
            value: me.exportConfig.range,
            triggerAction: 'all',
            cls: 'sch-export-dialog-range',
            forceSelection: true,
            editable: false,
            name: 'range',
            queryMode: 'local',
            displayField: 'name',
            valueField: 'value',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: [
                    {
                        name: me.L('completeViewText'),
                        value: 'complete'
                    },
                    {
                        name: me.L('completeDataText'),
                        value: 'completedata'
                    },
                    {
                        name: me.L('dateRangeText'),
                        value: 'date'
                    },
                    {
                        name: me.L('currentViewText'),
                        value: 'current'
                    }
                ]
            }
        }), me.rangeFieldConfig));
        me.mon(me.rangeField, 'change', me.onRangeChange, me);
        me.exportersField = Ext.ComponentManager.create(Ext.Object.merge(me.applyStateful({
            xtype: 'combobox',
            listConfig: {
                htmlEncode: true
            },
            fieldLabel: me.L('exportersFieldLabel'),
            value: me.defaultExporter,
            triggerAction: 'all',
            cls: 'sch-export-dialog-exporter',
            forceSelection: true,
            editable: false,
            name: 'id',
            queryMode: 'local',
            displayField: 'name',
            valueField: 'value',
            store: {
                fields: [
                    'name',
                    'value'
                ],
                data: Ext.Array.map(me.exporters, function(exporter) {
                    return {
                        name: exporter.getName(),
                        value: exporter.getId()
                    };
                })
            }
        }), me.exportersFieldConfig));
        me.mon(me.exportersField, 'change', me.onExporterChange, me);
        if (me.showRowsRangeField) {
            me.rowsRangeField = Ext.ComponentManager.create(Ext.Object.merge(me.applyStateful({
                xtype: 'combobox',
                listConfig: {
                    htmlEncode: true
                },
                fieldLabel: me.L('rowsRangeLabel'),
                value: me.exportConfig.rowsRange,
                triggerAction: 'all',
                cls: 'sch-export-dialog-rowsrange',
                forceSelection: true,
                editable: false,
                name: 'rowsRange',
                queryMode: 'local',
                displayField: 'name',
                valueField: 'value',
                store: {
                    fields: [
                        'name',
                        'value'
                    ],
                    data: [
                        {
                            name: me.L('allRowsLabel'),
                            value: 'all'
                        },
                        {
                            name: me.L('visibleRowsLabel'),
                            value: 'visible'
                        }
                    ]
                }
            }), me.rowsRangeFieldConfig));
        }
        var items = [];
        items.push(me.rangeField);
        if (me.resizerHolder) {
            items.push(me.resizerHolder);
        }
        items.push(me.datesHolder);
        if (me.columnPicker) {
            items.push(me.columnPicker);
        }
        if (me.rowsRangeField) {
            items.push(me.rowsRangeField);
        }
        items.push(me.exportersField, me.formatField, me.orientationField);
        if (me.dpiField) {
            items.push(me.dpiField);
        }
        if (me.showHeaderField) {
            items.push(me.showHeaderField);
        }
        if (me.showFooterField) {
            items.push(me.showFooterField);
        }
        return items;
    },
    // Applies configs to enable "stateful" mode for the field ("config" being provided).
    // Should be used for the "textfield" ancestors (numberfield/picker fields etc)
    applyStateful: function(config) {
        if (!this.stateful)  {
            return config;
        }
        
        var me = this,
            prefix = me.stateId || 'exporter';
        return Ext.applyIf(config, {
            stateful: true,
            stateId: prefix + '_' + config.name
        });
    },
    // Applies configs to enable "stateful" mode for the field ("config" being provided).
    // Should be used for the NON-"textfield" ancestors since they require implementing a pair of applyState/getState methods
    applyStatefulFull: function(config) {
        if (!this.stateful)  {
            return config;
        }
        
        var me = this;
        return Ext.apply(me.applyStateful(config), {
            stateEvents: [
                'change'
            ],
            applyState: me.applyFieldState,
            getState: me.getFieldState
        });
    },
    getFieldState: function() {
        return {
            value: this.getValue()
        };
    },
    applyFieldState: function(state) {
        if ('value' in state) {
            this.setValue(state.value);
        }
    },
    onRangeChange: function(field, newValue) {
        switch (newValue) {
            case 'complete':
            case 'completedata':
                this.datesHolder.hide();
                this.resizerHolder && this.resizerHolder.hide();
                break;
            case 'date':
                this.datesHolder.show();
                this.resizerHolder && this.resizerHolder.hide();
                break;
            case 'current':
                this.datesHolder.hide();
                if (this.resizerHolder) {
                    this.resizerHolder.show();
                    this.resizePicker.expand(true);
                };
                break;
        }
    },
    /**
     * @protected
     * This method is called after user selects an export mode in the corresponding field.
     * @param  {Ext.form.field.Field} field Reference to the form field
     * @param  {String} exporterId Selected exporter identifier
     */
    onExporterChange: function(field, id) {
        switch (id) {
            case 'singlepage':
                this.disableFields(true);
                break;
            default:
                this.disableFields(false);
        }
    },
    disableFields: function(value) {
        var me = this;
        me.formatField.setDisabled(value);
        me.orientationField.setDisabled(value);
    }
});

/**
 @class Sch.widget.ExportDialog
 @private
 @extends Ext.window.Window

 Widget for export options.

 */
Ext.define('Sch.widget.ExportDialog', {
    alternateClassName: 'Sch.widget.PdfExportDialog',
    extend: 'Ext.window.Window',
    requires: [
        'Ext.ProgressBar',
        'Sch.widget.ExportDialogForm'
    ],
    mixins: [
        'Sch.mixin.Localizable'
    ],
    alias: "widget.exportdialog",
    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - title            : 'Export Settings',
            - exportButtonText : 'Export',
            - cancelButtonText : 'Cancel',
            - progressBarText  : 'Exporting...'
     */
    width: 450,
    cls: 'sch-exportdialog',
    frame: false,
    layout: 'fit',
    draggable: true,
    constrain: true,
    /**
     * @cfg {Ext.Component} progressBar Progress bar component.
     */
    progressBar: null,
    /**
     * @cfg {Ext.Component/Object/Object[]} buttonsPanel Component with buttons controlling export.
     */
    buttonsPanel: null,
    /**
     * @cfg {Object} buttonsPanelScope
     * The scope for the {@link #buttonsPanel}
     */
    buttonsPanelScope: null,
    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date range fields ("Export from" and "Export to" fields).
     */
    /**
     * @cfg {Boolean} showHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     * @removed This config was renamed since the name was used by another existing property. Please use {@link #showShowHeaderField} instead.
     */
    /**
     * @cfg {Boolean} showShowHeaderField Indicates if the "Show header" checkbox should be displayed in the export dialog.
     */
    /**
     * @cfg {Boolean} showFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     * @removed This config was renamed since the name was used by another existing property. Please use {@link #showShowFooterField} instead.
     */
    /**
     * @cfg {Boolean} showShowFooterField Indicates if the "Show footer" checkbox should be displayed in the export dialog.
     */
    /**
     * @cfg {Boolean} showColumnPicker Indicates if the "Select columns for export" field should to be shown in the export dialog.
     */
    /**
     * @cfg {Object} columnPickerConfig Configuration for the "Select columns for export" field.
     */
    /**
     * @cfg {Boolean} showDPIField Indicates if the "DPI (dots per inch)" field should to be shown in the export dialog.
     */
    /**
     * @cfg {Object} dpiFieldConfig Configuration for the "DPI (dots per inch)" field
     */
    /**
     * @cfg {Boolean} showResizePicker Indicates if "Resize column/rows to desired value" panel should to be shown in the export dialog.
     */
    /**
     * @cfg {Boolean} dateRangeRestriction Set to "false" to disable the maximum and minimum allowed value limits for the date range fields ("Export from" and "Export to" fields).
     */
    /**
     * @cfg {Object} doExportFnScope Set the scope for the doExportFn.
     */
    doExportFnScope: null,
    /**
     * @cfg doExportFn The function to be called by the export buttonhandler. This function will be automatically set when using Sch.plugin.Export plugin.
     *
     * @param exportConfig
     * @param successFn
     * @param failFn
     */
    doExportFn: function(exportConfig, successFn, failFn) {
        throw 'Sch.widget.ExportDialog: doExportFn needs to be set in the config';
    },
    form: null,
    defaultFormXType: 'export_dialog_form',
    exportButtonConfig: null,
    cancelButtonConfig: null,
    formConfigs: 'pageFormats,startDate,endDate,rowHeight,columnWidth,defaultExporter,exporters,' + 'dateRangeFormat,exportConfig,showColumnPicker,columnPickerConfig,showDPIField,dpiFieldConfig,showShowHeaderField,' + 'showShowFooterField,showResizePicker,stateful,stateId,dateRangeRestriction,showRowsRangeField,' + 'rowsRangeFieldConfig,rangeFieldConfig,formatFieldConfig,orientationFieldConfig,exportersFieldConfig',
    constructor: function(config) {
        Ext.apply(this, config);
        this.title = this.title || this.L('title');
        this.callParent(arguments);
    },
    // Some form configs can be provided directly to the dialog.
    // Their names are listed in "formConfigs" property.
    mapFormConfigs: function() {
        this.form = this.form || {};
        var form = this.form;
        var names = this.formConfigs.split(',');
        for (var i = 0,
            n = names.length; i < n; i++) {
            var name = names[i];
            if (this.hasOwnProperty(name) && !form.hasOwnProperty(name)) {
                form[name] = this[name];
            }
        }
        // TODO: backward compatibility
        if (this.hasOwnProperty('showFooterField') && !form.hasOwnProperty('showShowFooterField')) {
            form.showShowFooterField = this.showFooterField;
        }
        // TODO: backward compatibility
        if (this.hasOwnProperty('showHeaderField') && !form.hasOwnProperty('showShowHeaderField')) {
            form.showShowHeaderField = this.showHeaderField;
        }
        //form stateId may not be the same as window stateId, needs prefix
        if (form.stateId) {
            form.stateId = 'form_' + form.stateId;
        }
    },
    initComponent: function() {
        var me = this;
        if (!me.form || !me.form.isForm) {
            me.mapFormConfigs();
            me.form = me.buildForm();
        }
        me.buttonsPanel = me.buttonsPanel || me.buildButtons(me.buttonsPanelScope || me);
        Ext.apply(me, {
            items: {
                items: [
                    me.form,
                    me.progressBar || me.buildProgressBar()
                ]
            },
            fbar: me.buttonsPanel
        });
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        if (me.form.resizePicker) {
            me.relayEvents(me.form.resizePicker, [
                'change',
                'changecomplete',
                'select'
            ]);
        }
        me.callParent(arguments);
    },
    /**
     * Create Dialog's buttons.
     *
     * @param {Object} buttonsScope Scope for the buttons.
     * @return {Object[]} buttons Array containing buttons definition for Exporting/Cancelling export.
     */
    buildButtons: function(buttonsScope) {
        var me = this;
        return [
            Ext.apply({
                xtype: 'button',
                scale: 'medium',
                itemId: 'export',
                text: me.L('exportButtonText'),
                handler: me.onExportButtonPress,
                scope: buttonsScope || me
            }, me.exportButtonConfig),
            Ext.apply({
                xtype: 'button',
                scale: 'medium',
                itemId: 'cancel',
                text: me.L('cancelButtonText'),
                handler: me.onCancelButtonPress,
                scope: buttonsScope || me
            }, me.cancelButtonConfig)
        ];
    },
    onExportButtonPress: function() {
        if (this.form.isValid()) {
            var config = this.form.getValues();
            // disable export button and siaply progress bar
            this.beforeExport();
            // convert strings to dates before passing date range to doExport method
            var dateFormat = this.dateRangeFormat || Ext.Date.defaultFormat;
            if (config.dateFrom && !Ext.isDate(config.dateFrom)) {
                config.dateFrom = Ext.Date.parse(config.dateFrom, dateFormat);
            }
            if (config.dateTo && !Ext.isDate(config.dateTo)) {
                config.dateTo = Ext.Date.parse(config.dateTo, dateFormat);
            }
            this.doExportFn.call(this.doExportFnScope || this, config, this.onExportSuccess, this.onExportFailure);
        }
    },
    afterExport: function() {
        var btn = this.down('#export');
        btn && btn.enable();
        this.progressBar && this.progressBar.hide();
    },
    beforeExport: function() {
        var btn = this.down('#export');
        btn && btn.disable();
        this.progressBar && this.progressBar.show();
    },
    onExportSuccess: function() {
        this.afterExport();
    },
    onExportFailure: function() {
        this.afterExport();
    },
    onCancelButtonPress: function() {
        this.destroy();
    },
    /**
     * Build the {@link Sch.widget.ExportDialogForm} for the dialog window.
     *
     * @param {Object} config Config object for the form, containing field names and values.
     * @return {Sch.widget.ExportDialogForm} form
     */
    buildForm: function(config) {
        this.form = Ext.apply(this.form || {}, config);
        return Ext.ComponentManager.create(this.form, this.defaultFormXType);
    },
    buildProgressBar: function() {
        return this.progressBar = new Ext.ProgressBar({
            text: this.L('progressBarText'),
            animate: true,
            hidden: true,
            margin: '4px 10px 10px 10px'
        });
    }
});

/**
 * A plugin that generates PDF/PNG files out of the Scheduler panel.
 *
 * **NOTE:** This plugin will make an AJAX request to the server, POSTing
 * the HTML fragments to be exported. The {@link #printServer} URL must be configured.
 *
 * ##Configuring/usage
 *
 * To use this plugin, add it to your Scheduler as any other plugins. It's also required to have NodeJS server set and running.
 * The complete process of setting up the backend for the plugin can be found in the corresponding [guide](#!/guide/gantt_scheduler_export).
 *
 * **Note:** The export feature is currently not supported if your store is buffered.
 *
 * ```javascript
 * var panel = Ext.create('Sch.panel.SchedulerGrid', {
 *     plugins       : [
 *         {
 *             ptype       : 'scheduler_export',
 *             printServer : 'http://localhost:8080'
 *         }
 *     ],
 *     ...
 * });
 * ```
 *
 * The Scheduler instance will be extended with two new methods:
 *
 * - {@link #showExportDialog}, which shows export settings dialog
 *
 * ```javascript
 * panel.showExportDialog();
 * ```
 *
 * - {@link #doExport} which actually performs the export operation using {@link #exportConfig} or provided config object :
 *
 * ```javascript
 * panel.doExport({
 *     format      : "A5",
 *     orientation : "landscape",
 *     range       : "complete",
 *     showHeader  : true,
 *     id          : "singlepage"
 * });
 * ```
 *
 * ##Export options
 *
 * In the current state, the plugin gives few options to modify the look and feel of the generated PDF document (or the image) through a dialog window :
 *
 * {@img scheduler/images/export_dialog.png 2x}
 *
 * If no changes are made to the form, the {@link #exportConfig} will be used.
 *
 * ###Schedule range
 *
 * This setting controls the timespan visible on the exported document. The following options are available here :
 *
 * {@img scheduler/images/export_dialog_ranges.png 2x}
 *
 * ####Complete schedule
 *
 * Whole current timespan of the panel will be visible in the exported document.
 *
 * ####Complete schedule (for all events)
 *
 * The timespan will be adjusted to include all the events registered in the event store.
 *
 * ####Date range
 *
 * User can select the start and end dates visible on the exported document.
 *
 * {@img scheduler/images/export_dialog_ranges_date.png 2x}
 *
 * ####Visible schedule
 *
 * Timespan of the exported document/image will be set to the currently visible part of the time axis.
 *
 * ###Select columns
 *
 * This field allows to pick the locked grid columns to be exported:
 *
 * {@img scheduler/images/export_dialog_columns.png 2x}
 *
 * ###Rows range
 *
 * This setting controls rows to be included into the exported document. The following options are available here :
 *
 * {@img scheduler/images/export_dialog_row_ranges.png 2x}
 *
 *
 * ####All rows
 *
 * All the panel rows will be included (default mode).
 *
 * ####Visible rows
 *
 * Only currently visible part of rows will be included into the result document.
 *
 * ##Control pagination
 *
 * This field allows to pick an exporter implementing needed way of pagination. The default exporter is `Multi pages`.
 *
 * {@img scheduler/images/export_modes.png 2x}
 *
 * Options:
 *
 * - `Single page`. Creates an export that fits one single page.
 * - `Multi pages`. Creates an export that creates pages in both vertical and horizontal direction.
 * - `Multi pages (vertically)`. Creates an export that creates pages in vertical direction.
 *
 * ##Paper Format
 *
 * This combo gives control of the size of the generated document/image by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`). Default format is `A4`.
 *
 * {@img scheduler/images/export_dialog_format.png 2x}
 *
 * ###Orientation
 *
 * This setting defines the orientation of the generated document/image.
 *
 * {@img scheduler/images/export_dialog_orientation.png 2x}
 *
 * Default option is the `portrait` (vertical) orientation :
 *
 * {@img scheduler/images/export_dialog_portrait.png 2x}
 *
 * Second option is the `landscape` (horizontal) orientation :
 *
 * {@img scheduler/images/export_dialog_landscape.png 2x}
 *
 * ##DPI (dots per inch)
 *
 * This field controls the DPI value to use for paper format related calculations:
 *
 * {@img scheduler/images/export_dialog_dpi.png 2x}
 *
 * ##Show header
 *
 * This option allows to show a header to a page displaying the page number:
 *
 * {@img scheduler/images/export_show_header.png 2x}
 *
 * ##Custom export styling
 *
 * A special "sch-export" CSS class is added to the body of the exported pages so that you can have special
 * styles in your exported chart.
 *
 * [1]: http://www.phantomjs.org
 * [2]: http://www.imagemagick.org
 * [3]: https://bryntum.com/blog
 *
 */
Ext.define('Sch.plugin.Export', {
    extend: 'Ext.util.Observable',
    alternateClassName: 'Sch.plugin.PdfExport',
    alias: 'plugin.scheduler_export',
    mixins: [
        'Ext.AbstractPlugin',
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.XTemplate',
        'Sch.plugin.exporter.SinglePage',
        'Sch.plugin.exporter.MultiPage',
        'Sch.plugin.exporter.MultiPageVertical',
        'Sch.widget.ExportDialog'
    ],
    lockableScope: 'top',
    /**
     * @cfg {Object} pageSizes
     * Definition of all available paper sizes.
     */
    pageSizes: {
        A5: {
            width: 5.8,
            height: 8.3
        },
        A4: {
            width: 8.3,
            height: 11.7
        },
        A3: {
            width: 11.7,
            height: 16.5
        },
        Letter: {
            width: 8.5,
            height: 11
        },
        Legal: {
            width: 8.5,
            height: 14
        }
    },
    /**
     * @cfg {Boolean}
     * enableWebSocket to use websockets for posting fragments to the export backend.
     */
    enableWebSocket: false,
    /**
     * @cfg {Number} DPI
     * DPI (Dots per inch) resolution.
     */
    DPI: 95,
    /**
     * @cfg {String} printServer (required)
     * URL of the server responsible for running the export steps.
     */
    printServer: undefined,
    /**
     * @cfg {Number}
     * The timeout in milliseconds to be used for print requests to server.
     */
    timeout: 60000,
    /**
     * @cfg headerTpl
     * @inheritdoc Sch.plugin.exporter.AbstractExporter
     * @localdoc See details on default value {@link Sch.plugin.exporter.AbstractExporter#headerTpl here}
     */
    headerTpl: null,
    /**
     * @deprecated
     * @cfg {Function} headerTplDataFn
     * If defined provides data for the {@link #headerTpl}.
     * To define the scope please use {@link #headerTplDataFnScope}.
     * @return {Object} Header template data.
     */
    headerTplDataFn: null,
    /**
     * @deprecated
     * @cfg {Object} headerTplDataFnScope Scope for the {@link #headerTplDataFn} function.
     */
    headerTplDataFnScope: null,
    /**
     * @cfg {String} tpl
     * Template of extracted page.
     */
    tpl: null,
    /**
     * @cfg footerTpl
     * @inheritdoc Sch.plugin.exporter.AbstractExporter
     * @localdoc See details on default value {@link Sch.plugin.exporter.AbstractExporter#footerTpl here}
     */
    footerTpl: null,
    /**
     * @deprecated
     * @cfg {Function} footerTplDataFn
     * If defined provides data for the {@link #footerTpl}.
     * To define the scope please use {@link #footerTplDataFnScope}.
     * @return {Object} Footer template data.
     */
    footerTplDataFn: null,
    /**
     * @deprecated
     * @cfg {Object} footerTplDataFnScope Scope for the {@link #footerTplDataFn} function.
     */
    footerTplDataFnScope: null,
    /**
     * @cfg {String}
     * Class name of the dialog used to change export settings.
     */
    exportDialogClassName: 'Sch.widget.ExportDialog',
    /**
     * @cfg {Object}
     * Config object for the {@link #exportDialogClassName}. Use this to override default values for the export dialog.
     */
    exportDialogConfig: {},
    /**
     * @cfg {Object}
     * Config object to apply to each {@link Sch.plugin.exporter.AbstractExporter exporter} being registered.
     */
    exporterConfig: null,
    /**
     * @cfg {Object}
     * Default export configuration.
     */
    exportConfig: {
        format: 'A4',
        orientation: 'portrait',
        range: 'complete',
        rowsRange: 'all',
        showHeader: true,
        showFooter: false
    },
    /**
     * @cfg {Boolean} expandAllBeforeExport Only applicable for tree views, set to true to do a full expand prior to the export. Defaults to false.
     */
    expandAllBeforeExport: false,
    /**
     * @cfg {Boolean|String} translateURLsToAbsolute `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
     * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.
     *
     * For example: css files pointing to ../../app.css will be translated from current origin to {translateURLsToAbsolute}/app.css
     */
    translateURLsToAbsolute: true,
    /**
     * @cfg {Boolean}
     * If set to true, open new window with the generated document after the operation has finished.
     */
    openAfterExport: true,
    /**
     * @cfg {Boolean}
     * If set to true, a new tab will be opened. This is useful when need to show a preview page instead of downloading the file and keep the original tab opened.
     *
     * **Note:** To show a preview page Server should be configured with inline Content-Disposition header.
     */
    openInNewTab: false,
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the export plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @param {Object[]} ticks The ticks gathered by plugin to export.
     * @template
     * @method beforeExport
     */
    beforeExport: Ext.emptyFn,
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the export plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @template
     * @method afterExport
     */
    afterExport: Ext.emptyFn,
    /**
     * @cfg {String}
     * Format of the exported file, selectable from `pdf` or `png`. By default plugin exports panel contents to PDF
     * but PNG file format is also available.
     */
    fileFormat: 'pdf',
    /**
     * @cfg {String}
     * The identifier of the default exporter to be used.
     * The corresponding export mode will be selected in {@link Sch.widget.ExportDialog export dialog} by default.
     */
    defaultExporter: 'multipage',
    /**
     * @cfg {Sch.plugin.exporter.AbstractExporter[]/Object[]}
     * The list of available exporters.
     * If no value is provided the list will be filled automatically (see {@link #buildExporters}).
     */
    exporters: undefined,
    callbacks: undefined,
    currentAjaxRequest: undefined,
    currentWebSocketRequest: undefined,
    hideExportDialogTimeout: 1000,
    /**
     * @event error
     * Fires to show error in the dialog window.
     * @param {Ext.window.Window} dialog The dialog used to change export settings.
     * @param {String} message Error message to show in the dialog window.
     * @param {Object} response Full server response.
     */
    /**
     * @event progressupdate
     * Fires when a progressbar of the {@link #exportDialogClassName dialog} should update its value.
     * @param {Number} value Value (between 0 and 1) to set on the progressbar.
     */
    /**
     * @event beforeexport
     * @preventable
     * Fires before the exporting is started. Return `false` to cancel exporting.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component A scheduler panel to be exported.
     * @param {Sch.plugin.exporter.AbstractExporter} exporter The selected exporter.
     * @param {Object} config Export configuration.
     */
    /**
     * @event exportstart
     * @private
     * Fires when the exporting is started
     * @param {Sch.plugin.Export} plugin The plugin instance.
     */
    /**
     * @event afterexport
     * Fires when the exporting is done
     * @param {Sch.plugin.Export} plugin The plugin instance.
     * @param {boolean} success Export sucess or fail.
     * @param {string} url URL of resulting file.
     */
    /**
     */
    constructor: function(config) {
        var me = this;
        config = config || {};
        me.exportersIndex = {};
        if (config.exportDialogConfig) {
            Ext.Object.each(this.exportConfig, function(k, v, o) {
                var configK = config.exportDialogConfig[k];
                if (configK) {
                    o[k] = configK;
                }
            });
        }
        if (!("WebSocket" in window)) {
            config.enableWebSocket = false;
        }
        me.callParent([
            config
        ]);
        me.setFileFormat(me.fileFormat);
        // if no exporters specified let's set the list of available by default
        if (!me.exporters) {
            me.exporters = me.buildExporters();
        }
        // instantiate exporters instances in case there were provided just objects w/ xclass
        me.initExporters();
        // listen to exporters events
        me.bindExporters();
    },
    init: function(scheduler) {
        var me = this;
        scheduler.showExportDialog = Ext.Function.bind(me.showExportDialog, me);
        scheduler.doExport = Ext.Function.bind(me.doExport, me);
        me.scheduler = scheduler;
    },
    initExporters: function() {
        var me = this,
            exporters = me.exporters;
        for (var i = 0; i < exporters.length; i++) {
            // instantiate the exporter if needed
            if (!exporters[i].isExporter) {
                exporters[i] = me.createExporter(exporters[i]);
            }
        }
    },
    bindExporters: function() {
        var exporters = this.exporters;
        for (var i = 0; i < exporters.length; i++) {
            this.bindExporter(exporters[i]);
        }
    },
    bindExporter: function(exporter) {
        var me = this;
        me.mon(exporter, {
            commitpage: me.onPageCommit,
            collectrows: me.onRowCollected,
            scope: me
        });
    },
    unbindExporter: function(exporter) {
        var me = this;
        me.mun(exporter, {
            commitpage: me.onPageCommit,
            collectrows: me.onRowCollected,
            scope: me
        });
    },
    /**
     * @protected
     * Provides the list of available exporter instances.
     * This method is used to build the default state of the list when no {@link #exporters} provided.
     * @returns {Sch.plugin.exporter.AbstractExporter[]/String[]} List of exporters.
     */
    buildExporters: function() {
        return [
            'Sch.plugin.exporter.SinglePage',
            'Sch.plugin.exporter.MultiPage',
            'Sch.plugin.exporter.MultiPageVertical'
        ];
    },
    /**
     * @protected
     * Returns config for an exporter being initialized.
     * Override this to provide custom options for exporters being created.
     */
    getExporterConfig: function(className, config) {
        var me = this;
        var result = Ext.apply({
                translateURLsToAbsolute: me.translateURLsToAbsolute,
                expandAllBeforeExport: me.expandAllBeforeExport,
                DPI: me.DPI
            }, me.exporterConfig);
        if (me.headerTpl)  {
            result.headerTpl = me.headerTpl;
        }
        
        if (me.headerTplDataFn) {
            result.headerTplDataFn = me.headerTplDataFn;
            result.headerTplDataFnScope = me.headerTplDataFnScope;
        }
        if (me.tpl)  {
            result.tpl = me.tpl;
        }
        
        if (me.footerTpl)  {
            result.footerTpl = me.footerTpl;
        }
        
        if (me.footerTplDataFn) {
            result.footerTplDataFn = me.footerTplDataFn;
            result.footerTplDataFnScope = me.footerTplDataFnScope;
        }
        return result;
    },
    // @protected
    createExporter: function(className, config) {
        var me = this,
            exporterConfig = me.getExporterConfig(className, config);
        if (Ext.isObject(className)) {
            return Ext.create(Ext.apply(exporterConfig, className));
        } else {
            return Ext.create(className, Ext.apply(exporterConfig, config));
        }
    },
    /**
     * Adds an exporter.
     * @param  {Sch.plugin.exporter.AbstractExporter/String} [exporter] An exporter to add.
     * Might be provided as {@link Sch.plugin.exporter.AbstractExporter} instance or as a class name string plus a configuration object:
     *
     *   plugin.registerExporter('MyExporter', { foo : 'bar' });
     *
     * Can be ommited to use configuration object only:
     *
     *   plugin.registerExporter({ xclass : 'MyExporter', foo : 'bar' });
     *
     * @param  {Object} [config]    A configuration object
     */
    registerExporter: function(exporter, config) {
        if (!(exporter instanceof Sch.plugin.exporter.AbstractExporter)) {
            exporter = this.createExporter.apply(this, arguments);
        }
        this.exporters.push(exporter);
        this.bindExporter(exporter);
    },
    /**
     * Function that returns an exporter by its identifier.
     *
     * @param {String} id string indicating the registered exporter.
     *
     * @return {Sch.plugin.exporter.AbstractExporter} an instance of the exporter.
     */
    getExporter: function(id) {
        if (!id)  {
            return;
        }
        
        var result = this.exportersIndex[id];
        if (result)  {
            return result;
        }
        
        result = this.exportersIndex[id] = Ext.Array.findBy(this.exporters, function(i) {
            return i.getId() == id;
        });
        return result;
    },
    /**
     * Function that returns all registered exporters.
     *
     * @return {Object} an Object containing registered exporters.
     */
    getExporters: function() {
        return this.exporters;
    },
    /**
     * Function for setting the {@link #fileFormat} of exporting panel. Can be either `pdf` or `png`.
     *
     * @param {String} format format of the file to set. Can take either `pdf` or `png`.
     */
    setFileFormat: function(format) {
        this.fileFormat = format;
    },
    /**
     * Instantiates and shows a new {@link #exportDialogClassName} class using {@link #exportDialogConfig} config.
     * This popup allows a user to change the export settings.
     */
    showExportDialog: function() {
        var me = this,
            activeDialog = me.getActiveExportDialog();
        // only one active dialog is allowed
        if (activeDialog) {
            activeDialog.destroy();
        }
        // create export dialog window
        me.setActiveExportDialog(me.buildExportDialog());
        activeDialog = me.getActiveExportDialog();
        activeDialog.on('destroy', me.onExportDialogDestroy, me);
        // if the dialog has a progress bar onboard
        if (activeDialog.progressBar) {
            // let's track the export progress change and update it
            activeDialog.mon(me, {
                progressupdate: me.onExportProgress,
                scope: me
            });
        }
        activeDialog.show();
    },
    buildExportDialog: function() {
        return Ext.create(this.exportDialogClassName, this.buildExportDialogConfig());
    },
    buildExportDialogConfig: function() {
        var me = this,
            view = me.scheduler.getSchedulingView();
        return Ext.Object.merge({
            // on submit button press we launch export
            doExportFn: me.doExport,
            doExportFnScope: me,
            // form related configs
            startDate: Ext.Date.clone(me.scheduler.getStart()),
            endDate: Ext.Date.clone(me.scheduler.getEnd()),
            rowHeight: view.timeAxisViewModel.getViewRowHeight(),
            columnWidth: view.timeAxisViewModel.getTickWidth(),
            defaultExporter: me.defaultExporter,
            // TODO: move "DPI" config to "exportConfig" container and get rid of this Ext.apply()
            exportConfig: Ext.apply(me.exportConfig, {
                DPI: me.DPI
            }),
            exporters: me.exporters,
            pageFormats: me.getPageFormats(),
            columnPickerConfig: {
                // Columns ignored in export should not be available to pick
                columns: me.scheduler.lockedGrid.query('gridcolumn[ignoreInExport!=true]')
            }
        }, me.exportDialogConfig);
    },
    onExportDialogDestroy: function() {
        this.cancelExport();
        this.setActiveExportDialog(null);
    },
    onExportProgress: function(value, description) {
        var activeDialog = this.getActiveExportDialog(),
            progressBar = activeDialog && activeDialog.progressBar;
        if (progressBar) {
            progressBar.updateProgress(value);
            if (typeof description == 'string') {
                progressBar.updateText(description);
            }
        }
    },
    showError: function(error) {
        Ext.Msg.alert('', error || this.L('generalError'));
    },
    getPageFormats: function() {
        var pageSizes = this.pageSizes,
            sizes = [];
        Ext.Object.each(pageSizes, function(key, value) {
            sizes.push({
                width: value.width,
                height: value.height,
                name: key
            });
        });
        // let's sort page sizes by width and return array of names
        return Ext.Array.map(sizes.sort(function(a, b) {
            return a.width - b.width;
        }), function(size) {
            return size.name;
        });
    },
    getExportConfig: function(config) {
        var me = this;
        var result = Ext.apply({
                fileFormat: me.fileFormat,
                id: me.defaultExporter,
                beforeExport: Ext.Function.bind(me.beforeExport, me),
                afterExport: Ext.Function.bind(me.afterExport, me)
            }, config, me.exportConfig);
        // get effective DPI
        result.DPI = result.DPI || me.DPI;
        // get page size for provided paper format
        result.pageSize = Ext.apply({}, me.pageSizes[result.format]);
        // covert page size to pixels
        result.pageSize.width *= result.DPI;
        result.pageSize.height *= result.DPI;
        return result;
    },
    /**
     * Function performing the export operation using provided config. After getting data
     * from the scheduler an XHR request to {@link #printServer} will be made with the following JSON encoded data :
     *
     * * `html`        - array of HTML strings containing data of each page
     * * `format`      - paper size of the exported file
     * * `orientation` - orientation of the exported file
     * * `range`       - range of the exported file
     * * `fileFormat`  - file format of the exported file
     *
     * @param {Object} [conf] Config options for exporting. If not provided, {@link #exportConfig} is used. Possible parameters are :
     * @param {String} [conf.format]            - format of the exported document/image, selectable from the {@link #pageSizes} list.
     * @param {String} [conf.orientation]       - orientation of the exported document/image. Either `portrait` or `landscape`.
     * @param {String} [conf.range]             - range of the panel to be exported. Selectable from `complete`, `current`, `date`.
     * @param {Boolean} [conf.showHeader]       - boolean value defining if exported pages should have row/column numbers added in the headers.
     * @param {String} [conf.id]                - string value defining which exporter to use.
     *
     * @param {Function} [callback] Optional function that will be called after successful response from export backend script.
     * @param {Function} [errback] Optional function that will be called if export backend script returns error.
     */
    doExport: function(conf, callback, errback, scope) {
        var me = this,
            component = me.scheduler,
            config = me.getExportConfig(conf);
        me.callbacks = {
            success: callback,
            failure: errback,
            scope: scope || me
        };
        var exporter = me.exporter = me.getExporter(config.id);
        if (me.fireEvent('beforeexport', component, exporter, config) !== false) {
            me.myBeforeExport();
            me.exporter.extractPages(component, config, function(pages) {
                me.onPagesExtracted(pages, component, exporter, config);
            }, me);
        }
    },
    /**
     * Aborts any ongoing export operation
     */
    cancelExport: function() {
        // if window is destroyed, cancel any ongoing ajax request
        if (this.currentAjaxRequest) {
            Ext.Ajax.abort(this.currentAjaxRequest);
            this.currentAjaxRequest = null;
        } else if (this.currentWebSocketRequest) {
            //close socket here
            this.currentWebSocketRequest.close();
            this.currentWebSocketRequest = null;
        } else {
            if (this.exporter)  {
                this.exporter.abort();
            }
            
        }
        this.scheduler.getEl().unmask();
    },
    onPagesExtracted: function(pages, component, exporter, config) {
        this.fireEvent('progressupdate', 0.8, this.L('requestingPrintServer'));
        if (this.enableWebSocket) {
            this.doSocketRequest(pages, config);
        } else {
            this.doRequest(pages, config);
        }
    },
    onRowCollected: function(exporter, startIndex, endIndex, total) {
        this.fireEvent('progressupdate', 0.2 * (endIndex + 1) / total, Ext.String.format(this.L('fetchingRows'), endIndex, total));
    },
    onPageCommit: function(exporter, page, pageNum, total) {
        total = Math.max(pageNum, total);
        this.fireEvent('progressupdate', 0.2 + 0.6 * pageNum / total, Ext.String.format(this.L('builtPage'), pageNum, total));
    },
    /**
     * @private
     * Method that is called after the server responds successfully.
     * The exported file is shown if {@link #openAfterExport} config is set to `true` (default).
     */
    onExportSuccess: function(result) {
        var me = this,
            activeDialog = me.getActiveExportDialog(),
            callbacks = me.callbacks,
            fn = callbacks && callbacks.success,
            scope = callbacks && callbacks.scope || me;
        //set progress to 100%
        me.fireEvent('progressupdate', 1);
        me.myAfterExport(true, result.url);
        fn && fn.apply(scope, arguments);
        me.hideExportDialogTimer = setTimeout(function() {
            activeDialog && activeDialog.destroy();
        }, me.hideExportDialogTimeout);
        if (me.openAfterExport) {
            if (Ext.isIE) {
                window.open(result.url, 'ExportedPanel');
            } else {
                var link = document.createElement('a');
                link.download = 'export';
                link.href = result.url;
                if (me.openInNewTab) {
                    link.target = '_blank';
                }
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    },
    /**
     * @private
     * Function that is called when the exportserver returned failure. This function will fire the event error.
     * When provided in doExport the callback failure is called.
     *
     * @param {String} message Error message provided with the failure.
     * @param {Object} result object when the failure is a serverside failure.
     */
    onExportFailure: function(message, result) {
        var me = this,
            dialog = this.getActiveExportDialog(),
            callbacks = me.callbacks,
            fn = callbacks && callbacks.failure,
            scope = callbacks && callbacks.scope || me;
        fn && fn.call(scope, message);
        me.fireEvent('error', dialog, message, result);
        me.showError(message);
        me.myAfterExport(false, null);
    },
    /**
     * @private
     * Launches a request to the {@link #printServer print server}.
     * On return {@link #onRequestSuccess} or {@link #onRequestFailure} will be called with the returned response.
     * @param {Array} exportedPages An array of paginated component content.
     * @param {Object} config Export configuration.
     */
    doSocketRequest: function(exportedPages, config) {
        var me = this,
            component = me.scheduler;
        if (me.printServer) {
            var url = this.printServer.replace(/^http(s)?/i, 'ws');
            var request = Ext.encode(Ext.apply({
                    html: exportedPages,
                    startDate: component.getStartDate(),
                    endDate: component.getEndDate(),
                    format: me.exporter.getPaperFormat(),
                    orientation: config.orientation,
                    range: config.range,
                    fileFormat: me.fileFormat
                }, this.getParameters()));
            var ws = new WebSocket(url);
            me.currentWebSocketRequest = ws;
            ws.onopen = function() {
                ws.send(request);
            };
            ws.onmessage = function(evt) {
                var result = Ext.decode(evt.data);
                ws.close();
                me.currentWebSocketRequest = null;
                if (result.success) {
                    result.url = me.printServer + '/' + result.file;
                    me.onExportSuccess(result);
                } else {
                    me.onExportFailure(result.msg, result);
                }
            };
        }
    },
    /**
     * @private
     * Launches a request to the {@link #printServer print server}.
     * On return {@link #onRequestSuccess} or {@link #onRequestFailure} will be called with the returned response.
     * @param {Array} exportedPages An array of paginated component content.
     * @param {Object} config Export configuration.
     */
    doRequest: function(exportedPages, config) {
        var me = this,
            component = me.scheduler;
        if (!me.test && !me.debug) {
            if (me.printServer) {
                var ajaxConfig = {
                        method: 'POST',
                        url: me.printServer,
                        timeout: me.timeout,
                        params: Ext.apply({
                            html: {
                                array: Ext.JSON.encode(exportedPages)
                            },
                            startDate: component.getStartDate(),
                            endDate: component.getEndDate(),
                            format: me.exporter.getPaperFormat(),
                            orientation: config.orientation,
                            range: config.range,
                            fileFormat: me.fileFormat
                        }, this.getParameters()),
                        success: me.onRequestSuccess,
                        failure: me.onRequestFailure,
                        scope: me
                    };
                Ext.apply(ajaxConfig, this.getAjaxConfig(ajaxConfig));
                this.currentAjaxRequest = Ext.Ajax.request(ajaxConfig);
            } else {
                me.onExportFailure('Print server URL is not defined, please specify printServer config');
            }
        } else {
            if (me.debug) {
                var pages = exportedPages || [];
                for (var i = 0,
                    l = pages.length; i < l; i++) {
                    var w = window.open();
                    w.document.write(pages[i].html);
                    w.document.close();
                }
            }
            me.onExportSuccess(me.testResponse || {
                success: true,
                url: 'foo',
                htmlArray: exportedPages
            });
        }
    },
    onRequestSuccess: function(response) {
        this.currentAjaxRequest = null;
        var me = this,
            result;
        try {
            result = Ext.JSON.decode(response.responseText);
        } catch (e) {
            me.onExportFailure('Wrong server response received');
            return;
        }
        if (result.success) {
            me.onExportSuccess(result);
        } else {
            me.onExportFailure(result.msg, result);
        }
    },
    onRequestFailure: function(response) {
        this.currentAjaxRequest = null;
        var me = this,
            msg = response.status === 200 ? response.responseText : response.statusText;
        me.onExportFailure(msg, response);
    },
    /**
     * @template
     * This method can be used to apply additional parameters to the 'params' property of the export {@link Ext.Ajax XHR} request.
     * By default this method returns an empty object.
     * @return {Object}
     */
    getParameters: function() {
        return {};
    },
    /**
     * This method can be used to return any extra configuration properties applied to the {@link Ext.Ajax#request} call.
     * @template
     * @param {Object} config The proposed Ajax configuration settings. You may read any properties from this object, but modify it at your own risk.
     * @return {Object}
     */
    getAjaxConfig: function(config) {
        return {};
    },
    /**
     * Returns the active export dialog window instance.
     * @return {Sch.widget.ExportDialog} Active export dialog window instance.
     */
    getActiveExportDialog: function() {
        return this.win;
    },
    setActiveExportDialog: function(dialog) {
        this.win = dialog;
    },
    // myBeforeExport the body, hiding panel to allow changing it's parameters in the background.
    myBeforeExport: function() {
        this.fireEvent('exportstart', this);
        var mask = this.scheduler.getEl().mask();
        mask.addCls('sch-export-mask');
        var activeDialog = this.getActiveExportDialog(),
            progressBar = activeDialog && activeDialog.progressBar;
        // if export dialog is used and progress bar is there, let's make it visible
        if (progressBar) {
            progressBar.show();
        }
    },
    myAfterExport: function(success, url) {
        this.fireEvent('afterexport', this, success, url);
        this.scheduler.getEl().unmask();
    },
    destroy: function() {
        var dialog = this.getActiveExportDialog();
        dialog && dialog.destroy();
        this.callParent(arguments);
        clearTimeout(this.openAfterExportTimer);
        clearTimeout(this.hideExportDialogTimer);
        if (this.getActiveExportDialog()) {
            this.getActiveExportDialog().destroy();
        }
    }
});

/**
 * A plugin showing a tooltip for cells in the time axis header.
 *
 * Sample usage:
 *
 * ```javascript
 * new Sch.panel.SchedulerGrid({
 *     plugins : ['scheduler_headertooltip'],
 *     ...
 * });
 * ```
 */
Ext.define('Sch.plugin.HeaderTooltip', {
    extend: 'Ext.AbstractPlugin',
    requires: [
        'Ext.tip.ToolTip',
        'Ext.Date',
        'Sch.view.HorizontalTimeAxis'
    ],
    alias: 'plugin.scheduler_headertooltip',
    /**
     * @cfg {String} dateFormat
     * The date format to use. See {@link #getTipContent} for details on how to provide custom content to the tooltip.
     */
    dateFormat: 'M j, Y H:i',
    // "Apr 5, 2018 17:00"
    /**
     * @cfg {Object} tipCfg
     * A config for the tooltip
     */
    tipCfg: null,
    tip: null,
    tipCls: 'sch-header-tooltip',
    delegateCls: 'sch-column-header',
    init: function(grid) {
        grid.getSchedulingView().on('afterrender', this.setupTooltip, this);
    },
    setupTooltip: function() {
        var me = this,
            header = me.getCmp().normalGrid.getHeaderContainer();
        me.tip = Ext.create(Ext.apply({
            xtype: 'tooltip',
            cls: me.tipCls,
            showDelay: 0,
            trackMouse: true,
            target: header.getEl(),
            // Each element triggers separate show and hide events
            delegate: '.' + me.delegateCls
        }, me.tipCfg));
        me.tip.on('beforeshow', me.beforeTipShow, me);
    },
    beforeTipShow: function() {
        var me = this,
            date = Ext.Date.parse(me.tip.triggerElement.dataset.date, Sch.view.HorizontalTimeAxis.encodeDateFormat);
        date = this.getCmp().getSchedulingView().convertDateToTimeZone(date);
        me.tip.update(me.getTipContent(date));
    },
    /**
     * A hook to provide content to the tooltip
     * @protected
     * @template
     * @param {Date} date The date for the time axis ´tick´
     * @return {String} The HTML string display in the tooltip
     */
    getTipContent: function(date) {
        return Ext.Date.format(date, this.dateFormat);
    },
    destroy: function() {
        if (this.tip) {
            this.tip.destroy();
        }
        this.callParent(arguments);
    }
});

/**
@class Sch.plugin.HeaderZoom
@extends Sch.util.DragTracker

This plugin (ptype = 'scheduler_headerzoom') enables zooming to a timespan selected using drag drop in the header area of the timeline panel.

Zooming will be performed to the nearest zooming level that will make all columns to fit in the scheduling view width,
additionally a column width of that zooming level will be slightly adjusted to improve the fit.

After zooming, the selected time span will appear centered in the scheduling view.

**NOTE*: This plugin only supports timeline panels in horizontal orientation.

To add this plugin to the scheduler:

    var s1  = new Sch.panel.SchedulerGrid({
        ...

        plugins     : [
            new Sch.plugin.HeaderZoom(),

            // or lazy style definition
            'scheduler_headerzoom'
        ]
    })

 */
Ext.define("Sch.plugin.HeaderZoom", {
    extend: "Sch.util.DragTracker",
    mixins: [
        'Ext.AbstractPlugin'
    ],
    alias: 'plugin.scheduler_headerzoom',
    lockableScope: 'top',
    scheduler: null,
    proxy: null,
    headerRegion: null,
    /**
     * @event beforeheaderzoom
     * @preventable
     * Fires before the new zoom level is set on the timeline panel.
     * @param {Sch.plugin.HeaderZoom} plugin The plugin instance
     * @param {Sch.mixin.TimelinePanel} panel The timeline panel
     * @param {Date} startDate The new start date
     * @param {Date} endDate The new end date
     */
    init: function(scheduler) {
        this.scheduler = scheduler;
        this.onModeChange();
        scheduler.on('modechange', this.onModeChange, this);
    },
    onOrientationChange: function() {
        return this.onModeChange.apply(this, arguments);
    },
    onModeChange: function() {
        var timeAxisColumn = this.scheduler.down('timeaxiscolumn');
        if (timeAxisColumn) {
            if (timeAxisColumn.rendered) {
                this.onTimeAxisColumnRender(timeAxisColumn);
            } else {
                timeAxisColumn.on({
                    afterrender: this.onTimeAxisColumnRender,
                    scope: this
                });
            }
        }
    },
    onTimeAxisColumnRender: function(column) {
        this.proxy = column.el.createChild({
            cls: 'sch-drag-selector'
        });
        this.initEl(column.el);
    },
    onStart: function(e) {
        this.proxy.show();
        this.headerRegion = this.scheduler.normalGrid.headerCt.getRegion();
    },
    onDrag: function(e) {
        var headerRegion = this.headerRegion;
        var dragRegion = this.getRegion().constrainTo(headerRegion);
        dragRegion.top = headerRegion.top;
        dragRegion.bottom = headerRegion.bottom;
        this.proxy.setBox(dragRegion);
    },
    onEnd: function(e) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);
            var scheduler = this.scheduler;
            var region = this.getRegion();
            var range = scheduler.getSchedulingView().getStartEndDatesFromRegion(region);
            if (range) {
                var timeAxis = scheduler.timeAxis;
                var unit = scheduler.getSchedulingView().timeAxisViewModel.getBottomHeader().unit;
                var start = timeAxis.floorDate(range.start, false, unit, 1);
                var end = timeAxis.ceilDate(range.end, false, unit, 1);
                if (this.fireEvent('beforeheaderzoom', this, scheduler, start, end) !== false) {
                    scheduler.zoomToSpan({
                        start: start,
                        end: end
                    });
                }
            }
        }
    },
    destroy: function() {
        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
        this.callParent(arguments);
    }
});

/**
 * A grid plugin enabling panning by clicking and dragging in a scheduling view.
 *
 * Sample usage:
 *
 * ```javascript
 * new Sch.panel.SchedulerGrid({
 *     plugins : ['scheduler_pan'],
 *     ...
 * });
 * ```
 */
Ext.define("Sch.plugin.Pan", {
    extend: 'Ext.AbstractPlugin',
    alias: 'plugin.scheduler_pan',
    lockableScope: 'top',
    /**
     * @cfg {Boolean} enableVerticalPan
     * Set to `false` to turn vertical panning off
     */
    enableVerticalPan: true,
    statics: {
        /**
         * @property {Number} KEY_SHIFT Constant for shift key
         */
        KEY_SHIFT: 1,
        /**
         * @property {Number} KEY_CTRL Constant for ctrl / meta key
         */
        KEY_CTRL: 2,
        /**
         * @property {Number} KEY_ALT Constant for alt key
         */
        KEY_ALT: 4,
        /**
         * @property {Number} KEY_ALL Constant for all modifier keys (shift, ctrl / meta, alt)
         */
        KEY_ALL: 7
    },
    /**
     * @cfg {Number} disableOnKey Specifies which key should be pressed to disable panning.
     * See {@link #KEY_SHIFT}, {@link #KEY_CTRL}, {@link #KEY_ALT}, {@link #KEY_ALL}.
     * For example to disable panning when shift or ctrl is pressed:
     *
     * ```javascript
     * Ext.create('Sch.plugin.Pan', {
     *     disableOnKey : Sch.plugin.Pan.KEY_SHIFT + Sch.plugin.Pan.KEY_CTRL
     * });
     * ```
     */
    disableOnKey: 0,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    init: function(grid) {
        this.view = grid.getSchedulingView();
        this.view.on('afterrender', this.onRender, this);
    },
    onRender: function() {
        this.view.el.on('mousedown', this.onMouseDown, this);
    },
    onMouseDown: function(e) {
        if ((e.event.touches && e.event.touches.length > 0) || (// ExtJS supports scrolling when using touch out of the box
        !e.event.touches && e.button !== 0))  {
            // Do not react on context menu click
            return;
        }
        
        var self = this.self,
            disableOnKey = this.disableOnKey;
        // Ignore event if #disableOnKey is specified and at least one of the
        // functional keys is pressed
        if ((e.shiftKey && (disableOnKey & self.KEY_SHIFT)) || (e.ctrlKey && (disableOnKey & self.KEY_CTRL)) || (e.altKey && (disableOnKey & self.KEY_ALT))) {
            return;
        }
        // ignore actions on any rendered content on the schedule
        if (e.getTarget(this.view.timeCellSelector, 10) && !e.getTarget(this.view.timeCellSelector + ' > div > *')) {
            this.mouseX = e.getX();
            this.mouseY = e.getY();
            Ext.getBody().on('mousemove', this.onMouseMove, this);
            Ext.getDoc().on('mouseup', this.onMouseUp, this);
            // For IE (and FF if using frames), if you move mouse onto the browser chrome and release mouse button
            // we won't know about it. Next time mouse enters the body, cancel any ongoing pan activity as a fallback.
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on('mouseenter', this.onMouseUp, this);
            }
            // required for some weird chrome bug/behavior, when whole panel was scrolled-out
            e.stopEvent();
        }
    },
    onMouseMove: function(e) {
        if (this.disabled)  {
            return;
        }
        
        e.stopEvent();
        var x = e.getX(),
            y = e.getY(),
            yDelta = 0,
            xDelta = this.mouseX - x;
        if (this.enableVerticalPan) {
            yDelta = this.mouseY - y;
        }
        this.mouseX = x;
        this.mouseY = y;
        var currentScrollPos = this.view.getScroll();
        yDelta && this.view.scrollVerticallyTo(Math.max(0, yDelta + currentScrollPos.top), false);
        xDelta && this.view.scrollHorizontallyTo(Math.max(0, xDelta + currentScrollPos.left), false);
        // scroll header as well to avoid "header-body" scroll bouncing
        var headerScrollable = this.view.headerCt.getScrollable();
        headerScrollable && headerScrollable.scrollBy(xDelta, 0, false);
    },
    onMouseUp: function() {
        Ext.getBody().un('mousemove', this.onMouseMove, this);
        Ext.getDoc().un('mouseup', this.onMouseUp, this);
        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un('mouseenter', this.onMouseUp, this);
        }
    }
});

/**
@class Sch.plugin.Printable
@extends Sch.plugin.Export

Plugin (ptype = 'scheduler_printable') printing an Ext Scheduler instance. To use this plugin, add it to the scheduler as a usual plugin. The plugin will add an additional `print` method to the scheduler.

Please note that this plugin may in some cases not generate a perfect picture for example in Firefox, due to various limitations in the browsers print implementation.
If you require a high quality print in that case, you should use the Export plugin instead and first export to PDF. Chrome, IE10+ will give the best results.

The print plugin will open a print dialog. In the dialog there is a DPI field. The DPI (dots per inch) is a ratio how many browser pixels correspond to a `paper` inch.
The default is set on 72 dots. Depending on the screen resolution, this value can be increased or decreased.
Run some test prints, and adjust the DPI until the generated pages fit the print paper nicely.

* **Note** that the print feature is currently not supported if your store is buffered.

In the browser print settings the `Background Graphics` option should be set to on.

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.Printable', {
                // default values
                docType             : '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">',
                autoPrintAndClose   : true
            })
        ]
    });

    ...

    scheduler.print();

In the opened print window, a special 'sch-print-body' CSS class will be added to the BODY element. You can use this to
further customize the printed contents.

 */
Ext.define('Sch.plugin.Printable', {
    extend: 'Sch.plugin.Export',
    requires: [
        'Ext.XTemplate',
        'Ext.window.Toast'
    ],
    alternateClassName: [
        'Sch.plugin.Print'
    ],
    alias: [
        'plugin.scheduler_printable',
        'plugin.scheduler_print'
    ],
    /**
     * @cfg {String} docType This is the DOCTYPE to use for the print window. It should be the same DOCTYPE as on your application page.
     */
    docType: '<!DOCTYPE HTML>',
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the print plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method beforePrint
     */
    beforePrint: function() {},
    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the print plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method afterPrint
     */
    afterPrint: function() {},
    exportDialogConfig: {
        showDPIField: true
    },
    /**
     * @cfg {Boolean} removeSecondaryCanvas set to true to remove columnlines
     */
    removeSecondaryCanvas: false,
    /**
     * @cfg {Boolean} wrapHeaders set to true to wrap the headers with a sch-print-header-wrap cls class for additional markup.
     */
    wrapHeaders: false,
    /**
     * @cfg {Boolean} autoPrintAndClose True to automatically call print and close the new window after printing. Default value is `true`
     */
    autoPrintAndClose: true,
    // private, the template for the new windowfg
    mainTpl: '{docType}' + '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' + '<head>' + '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' + '<title>{title}</title>' + '{styles}' + '</head>' + '<body class="sch-print-body {bodyClasses}">' + '<div class="sch-print-ct" style="width:{totalWidth}px">' + '<tpl for="pages">{html}</tpl>' + '</div>' + '<script type="text/javascript">' + '{setupScript}' + '</script>' + '</body>' + '</html>',
    pageTpl: '{header}' + '<div id="{id}" class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">{HTML}</div>' + '{footer}' + '<div style="page-break-after:always;"></div>',
    // Script executed in the newly open window, to automatically invoke window.print()
    setupScriptTpl: "window.onload = function(){ " + "document._loaded  = true;" + "if ({autoPrintAndClose}) {" + "window.print();" + "if (!{isChrome}) window.close();" + "}" + '}',
    openAfterExport: false,
    DPI: 72,
    /**
     * @cfg {Boolean} fakeBackgroundColor True to reset background-color of events and enable use of border-width to fake background color (borders print by default in every browser).
     */
    fakeBackgroundColor: false,
    // This method is not used and doesn't make any sense for the print feature so it's overridden with an empty function
    doRequest: function() {},
    constructor: function(config) {
        Ext.apply(this, config);
        if (!this.mainTpl.isTemplate) {
            this.mainTpl = new Ext.XTemplate(this.mainTpl);
        }
        this.callParent(arguments);
        this.exportDialogConfig = Ext.applyIf({
            l10n: {
                title: this.L('dialogTitle'),
                exportButtonText: this.L('exportButtonText')
            }
        }, this.exportDialogConfig);
    },
    init: function(scheduler) {
        var me = this;
        // decorate scheduler with "print" method
        scheduler.print = Ext.Function.bind(me.print, me);
        me.scheduler = scheduler;
    },
    showPopupBlockedMessage: function() {
        Ext.toast(this.getPopupBlockedMessageConfig());
    },
    getPopupBlockedMessageConfig: function() {
        return {
            html: this.L('disablePopupBlocking'),
            title: this.L('popupBlockerDetected'),
            autoCloseDelay: 5000
        };
    },
    getExporterConfig: function(className, config) {
        var me = this,
            result = me.callParent(arguments);
        return Ext.apply(result, {
            tpl: me.pageTpl
        });
    },
    getExportConfig: function(config) {
        var me = this,
            result = me.callParent(arguments);
        return Ext.apply(result, {
            beforeExport: Ext.Function.bind(me.beforePrint, me),
            afterExport: Ext.Function.bind(me.afterPrint, me)
        });
    },
    onPagesExtracted: function(pages, component, exporter, config) {
        this.fireEvent('progressupdate', 0.8, this.L('requestingPrintServer'));
        this.printPages(pages, component, exporter, config);
    },
    /**
     * Instantiates and shows the Print dialog (defined by {@link #exportDialogClassName} class and using the {@link #exportDialogConfig} config).
     * In the dialog allows a user to change the print settings.
     */
    print: function() {
        this.showExportDialog();
    },
    // Adds print cls
    onBeforePageCommit: function(exporter, pageBody, pageNumber, totalNumberOfPages) {
        var component = this.scheduler,
            lockedGrid = component.lockedGrid,
            normalGrid = component.normalGrid,
            get = function(s) {
                return pageBody.select('#' + s).first();
            };
        var normalBody = pageBody.select(exporter.normalBodySelector).first(),
            normalHeader = get(normalGrid.headerCt.id),
            lockedBody = pageBody.select(exporter.lockedBodySelector).first(),
            lockedHeader = get(lockedGrid.headerCt.id);
        normalBody.addCls([
            'sch-print-normal-rows-ct',
            this.fakeBackgroundColor ? 'sch-print-fake-background' : ''
        ]);
        lockedBody.addCls('sch-print-locked-rows-ct');
        if (this.removeSecondaryCanvas) {
            pageBody.select('.sch-secondary-canvas').remove();
        }
        if (this.fakeBackgroundColor) {
            var events = normalBody.select(normalGrid.view.eventSelector);
            events.each(function(item) {
                item.setStyle('border-right-width', item.dom.style.width);
            });
        }
        normalHeader.addCls('sch-print-normalheader');
        lockedHeader.addCls('sch-print-lockedheader');
        if (this.wrapHeaders) {
            normalHeader.wrap('<div class="sch-print-header-wrap"></div>');
            lockedHeader.wrap('<div class="sch-print-header-wrap"></div>');
        }
        // When printing page in IE11 with high DPI (200), it may occur that header is located incorrectly.
        // Fill correct styles to make it behave nicely.
        if (Ext.isIE && normalGrid.bodyWrap) {
            var height = normalGrid.bodyWrap.getHeight();
            // Use fly here to avoid exception from Ext.cache
            Ext.fly(lockedHeader.el.dom.parentNode).setStyle({
                position: 'absolute',
                height: height + 'px'
            });
            Ext.fly(normalHeader.el.dom.parentNode).setStyle({
                position: 'absolute',
                height: height + 'px'
            });
        }
    },
    prepareMainTplData: function(data) {
        return data;
    },
    printPages: function(pages, component, exporter, config) {
        if (!this.mainTpl || !this.mainTpl.isTemplate) {
            this.mainTpl = new Ext.XTemplate(this.mainTpl, {
                compiled: true,
                disableFormats: true
            });
        }
        var styles = exporter.stylesheets,
            body = document.body;
        var html = this.mainTpl.apply(this.prepareMainTplData({
                docType: this.docType,
                htmlClasses: body.parentNode.className,
                bodyClasses: body.className,
                title: component.title || '',
                styles: styles,
                totalWidth: exporter.paperWidth,
                setupScript: this.setupScriptTpl.replace('{autoPrintAndClose}', this.autoPrintAndClose).replace('{isChrome}', Ext.isChrome),
                pages: pages
            }));
        var win = window.open('', 'printgrid');
        // When popup is blocked there is a window but win.document is null
        if (!win || !win.document || win.closed || typeof win.closed === 'undefined') {
            this.showPopupBlockedMessage();
            return false;
        }
        // Assign to this for testability, need a reference to the opened window
        this.printWindow = win;
        win.document.write(html);
        win.document.close();
        this.onExportSuccess({
            success: true,
            url: 'foo',
            htmlArray: [
                html
            ]
        });
    },
    bindExporter: function(exporter) {
        var me = this;
        me.callParent(arguments);
        me.mon(exporter, {
            beforecommitpage: me.onBeforePageCommit,
            scope: me
        });
    },
    unbindExporter: function(exporter) {
        var me = this;
        me.callParent(arguments);
        me.mun(exporter, {
            beforecommitpage: me.onBeforePageCommit,
            scope: me
        });
    }
});

/**
@class Sch.plugin.SimpleEditor
@extends Ext.Editor

A plugin (ptype = 'scheduler_simpleeditor') for basic text editing of an event name.

{@img scheduler/images/simple-editor.png}

To add this plugin to scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                new Sch.plugin.SimpleEditor({ dataIndex : 'Title' })
            ]
        });


*/
Ext.define("Sch.plugin.SimpleEditor", {
    extend: "Ext.Editor",
    alias: 'plugin.scheduler_simpleeditor',
    requires: [
        "Ext.form.TextField"
    ],
    mixins: [
        'Ext.AbstractPlugin',
        'Sch.mixin.Localizable'
    ],
    lockableScope: 'top',
    cls: 'sch-simpleeditor',
    allowBlur: false,
    shadow: false,
    // private
    delegate: '.sch-event-inner',
    /**
     * @cfg {String} dataIndex A field of the {@Sch.model.Event eventModel} containing the task name that will be updated by the editor. Defaults to the value of the {@link Sch.model.Event#nameField}.
     */
    dataIndex: null,
    completeOnEnter: true,
    cancelOnEsc: true,
    dragProxyEl: null,
    eventRecord: null,
    resourceRecord: null,
    //maxWidth        : 200,
    triggerEvent: 'eventdblclick',
    /**
     * @cfg {String} newEventText The text to assign as the name for a newly created Event.
     */
    newEventText: null,
    autoSize: {
        width: 'boundEl'
    },
    // The width will be determined by the width of the boundEl, the height from the editor
    initComponent: function() {
        this.field = this.field || {
            xtype: 'textfield',
            selectOnFocus: true
        };
        this.callParent(arguments);
    },
    init: function(scheduler) {
        this.scheduler = scheduler.getSchedulingView();
        scheduler.on('afterrender', this.onSchedulerRender, this);
        this.scheduler.registerEventEditor(this);
        this.dataIndex = this.dataIndex || this.scheduler.getEventStore().model.prototype.nameField;
    },
    /**
     * Programmatically start editing for a selected Event (and optionally a Resource if using an AssignmentStore)
     *
     * @param {Sch.model.Event} eventRecord The Event record to edit
     * @param {Sch.model.Resource} [resourceRecord] The resource record (only relevant when editing assignment records)
     */
    edit: function(eventRecord, resourceRecord, el) {
        if (!this.rendered) {
            // Editor element should live in scheduler view to be part of scrolling and not overflow locked grid
            this.renderTo = this.scheduler.getEl();
        }
        this.eventEl = el || this.scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];
        this.eventRecord = eventRecord;
        this.resourceRecord = resourceRecord;
        this.startEdit(el.dom.querySelector(this.delegate), this.eventRecord.get(this.dataIndex));
        // workaround http://www.sencha.com/forum/showthread.php?296716
        this.realign();
    },
    onSchedulerRender: function(scheduler) {
        var me = this;
        me.on({
            startedit: me.onStartEdit,
            complete: function(editor, value, original) {
                var eventRecord = me.eventRecord,
                    eventStore = me.scheduler.getEventStore(),
                    isAutoSyncEnabled = eventStore.getAutoSync();
                if (isAutoSyncEnabled) {
                    eventStore.suspendAutoSync();
                }
                eventRecord.set(me.dataIndex, value);
                // Check if this is a new record
                if (eventStore.indexOf(eventRecord) < 0) {
                    if (me.scheduler.fireEvent('beforeeventadd', me.scheduler, eventRecord, [
                        me.resourceRecord
                    ]) !== false) {
                        me.scheduler.onEventCreated(eventRecord, [
                            me.resourceRecord
                        ]);
                        eventStore.append(eventRecord);
                        eventRecord.assign(me.resourceRecord);
                    }
                }
                me.onAfterEdit();
                if (isAutoSyncEnabled) {
                    eventStore.resumeAutoSync(true);
                }
            },
            canceledit: me.onAfterEdit,
            hide: function() {
                var proxyEl = me.dragProxyEl;
                if (proxyEl && proxyEl.dom && proxyEl.dom.parentNode) {
                    proxyEl.destroy();
                }
            },
            scope: me
        });
        scheduler.on('dragcreateend', me.onDragCreateEnd, me);
        scheduler.on(me.triggerEvent, me.onTriggerEvent, me);
    },
    onStartEdit: function() {
        if (!this.allowBlur) {
            // This should be removed when this bug is fixed:
            // http://www.sencha.com/forum/showthread.php?244580-4.1-allowBlur-on-Ext.Editor-not-working
            Ext.getBody().on('mousedown', this.onMouseDown, this, {
                capture: true
            });
        }
    },
    onTriggerEvent: function(view, eventRecord, e) {
        if (!this.scheduler.isReadOnly()) {
            var target = e.getTarget(view.eventSelector);
            var resourceRecord = view.resolveResource(target);
            this.edit(eventRecord, resourceRecord, Ext.get(target));
            this.getEl().setBox(this.getEl().getRegion().constrainTo(this.scheduler.getRegion()));
        }
    },
    /*
            // If editing a wider element than maxWidth, place the editor where the input event happened
            if (view.isHorizontal() && Ext.fly(target).getWidth() > this.maxWidth) {
                var proposedX       = e.getX() - view.getX() + view.getScrollX() - (this.maxWidth / 2);
                var eventLeft       = Ext.fly(target).getLeft(true);
                var constrainedLeft = Math.max(eventLeft, view.getScrollX());

                this.getEl().setLeft(Math.max(proposedX, constrainedLeft));
            }
            */
    onAfterEdit: function() {
        this.eventRecord = null;
        this.resourceRecord = null;
        if (!this.allowBlur) {
            Ext.getBody().un('mousedown', this.onMouseDown, this, {
                capture: true
            });
        }
    },
    onMouseDown: function(e, t) {
        if (this.editing && this.el && !e.within(this.el)) {
            this.completeEdit();
        }
    },
    onDragCreateEnd: function(s, eventRecord, resourceRecord, e, proxyEl) {
        var dragProxyEl = proxyEl.dom.cloneNode(true);
        dragProxyEl.id = '';
        proxyEl.dom.parentNode.appendChild(dragProxyEl);
        this.dragProxyEl = Ext.get(dragProxyEl);
        if (eventRecord.get(this.dataIndex) === '') {
            eventRecord.set(this.dataIndex, this.newEventText || this.L('newEventText'));
        }
        this.edit(eventRecord, resourceRecord, this.dragProxyEl);
    },
    destroy: function() {
        this.cancelEdit();
        this.eventRecord = null;
        this.resourceRecord = null;
        this.callParent(arguments);
    },
    realign: function(autoSize) {
        var me = this,
            result = me.callParent([
                autoSize
            ]),
            box = me.eventEl && me.eventEl.getBox();
        if (box) {
            me.getEl().setBox(box);
            me.getEl().down('input').setBox(box);
        }
        return result;
    }
});

/**
 * A grid plugin adding the Excel-like 'split' feature.
 *
 * **Note:** This plugin is only supported in horizontal Scheduler mode!
 *
 * Sample usage:
 *
 * ```javascript
 * new Sch.panel.SchedulerGrid({
 *     plugins   : ['scheduler_split'],
 *     // To split the grid by default, or you can skip this config and split it manually from context menu.
 *     splitGrid : true
 *     ...
 * });
 * ```
 */
Ext.define('Sch.plugin.Split', {
    extend: 'Ext.AbstractPlugin',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.menu.Menu'
    ],
    alias: 'plugin.scheduler_split',
    /**
     * @cfg {Boolean} splitGrid
     * Set to `true` to split the grid as soon as it's shown
     */
    splitGrid: false,
    /**
     * @cfg {String} triggerEvent
     * An event that shall trigger showing the {@link #menu}.
     * Set to empty string or `null` to disable the action.
     */
    triggerEvent: 'contextmenu',
    /**
     * @cfg {Object} menuConfig
     * A config for the {@link #menu}
     */
    menuConfig: null,
    /**
     * @property {Ext.menu.Menu} menu
     * @readonly
     * A menu component provided UI to split/merge the grid
     */
    menu: null,
    /**
     * @property {Sch.panel.SchedulerGrid} grid
     * @readonly
     * The grid reference
     */
    grid: null,
    /**
     * @property {Sch.panel.SchedulerGrid} gridClone
     * @readonly
     * A clone of the grid
     */
    gridClone: null,
    splitMergeMenuItem: null,
    splitMergeMenuItemId: 'sch-dosplitmerge',
    splitCls: 'sch-grid-split',
    resizeHandleCls: 'sch-grid-split-resize-handle',
    gridCloneCls: 'sch-grid-split-clone',
    staticCloneConfig: {
        __cloned: true,
        splitGrid: false,
        eventPrefix: null,
        dock: 'bottom',
        id: null,
        itemId: null,
        hideHeaders: true,
        header: false,
        tbar: null,
        tools: null,
        bbar: null,
        buttons: null,
        margin: 0,
        padding: 0,
        resizable: {
            pinned: true,
            handles: 'n',
            dynamic: true
        }
    },
    init: function(grid) {
        // Limit to one vertical grid split
        if (!grid.__cloned) {
            grid.on('afterlayout', function() {
                this.setupGrid(grid);
            }, this, {
                single: true
            });
        }
    },
    setupGrid: function(grid) {
        this.grid = grid;
        if (this.triggerEvent) {
            this.createMenu();
            this.addGridListeners();
        }
        // Provide some functions to the grid
        grid.split = Ext.Function.bind(this.split, this);
        grid.merge = Ext.Function.bind(this.merge, this);
        grid.isSplit = Ext.Function.bind(this.isSplit, this);
        this.splitGrid = !Ext.isEmpty(grid.splitGrid) ? grid.splitGrid : this.splitGrid;
        if (this.splitGrid) {
            this.split();
        }
    },
    /**
     * Splits the grid into two parts
     * @param {Number} [position] Vertical position
     */
    split: function(position) {
        if (this.isSplit() || !this.grid.isHorizontal())  {
            return;
        }
        
        this.gridClone = this.cloneGrid(position);
        this.grid.addCls(this.splitCls);
        this.gridClone.addCls(this.gridCloneCls);
        var resizeHandle = this.grid.getEl().down('.' + Ext.baseCSSPrefix + 'docked .' + Ext.baseCSSPrefix + 'resizable-handle-north');
        resizeHandle.addCls(this.resizeHandleCls);
        this.gridClone.mon(resizeHandle, 'dblclick', this.merge, this);
        this.gridClone.mon(this.grid, 'resize', this.onMainGridResize, this);
        this.setupSynchronization();
        this.grid.fireEvent('split', this);
    },
    /**
     * Merges the grids into the one grid
     */
    merge: function() {
        if (!this.isSplit() || !this.grid.isHorizontal())  {
            return;
        }
        
        this.gridClone.destroy();
        this.gridClone = null;
        this.grid.removeCls(this.splitCls);
        this.grid.fireEvent('merge', this);
    },
    /**
     * Checks if the grid is split and the clone exists
     * @return {boolean} isSplit
     */
    isSplit: function() {
        return !!this.gridClone;
    },
    /**
     * A hook to extend the proposed config passed to the grid clone. Returned object will be merged with the proposed config.
     * @template
     * @protected
     * @param {Sch.panel.SchedulerGrid} grid The original grid
     * @param {Object} proposedConfig A config provided to the grid clone by default
     * @return {Object} extendedConfig A config to be merged with the proposed one
     */
    getCloneConfig: function(grid, proposedConfig) {
        return {};
    },
    onMenuTriggerEvent: function(e) {
        if (!this.grid.isHorizontal())  {
            return;
        }
        
        this.menu.showAt(e.getXY());
        if (this.splitMergeMenuItem) {
            this.splitMergeMenuItem.setText(this.isSplit() ? this.L('mergeText') : this.L('splitText'));
            var cell = e.getTarget('.' + Ext.baseCSSPrefix + 'grid-cell');
            if (cell) {
                var viewY = (this.grid.normalGrid || this.grid).getView().getEl().getY();
                this.splitMergeMenuItem.splitPosition = Ext.fly(cell).getBottom() - viewY;
            }
        }
        e.stopEvent();
    },
    createMenu: function() {
        this.menu = Ext.create(Ext.apply({
            xclass: 'Ext.menu.Menu',
            plain: true,
            defaults: {
                // Provide scope to all possible items
                scope: this
            },
            items: [
                {
                    itemId: this.splitMergeMenuItemId,
                    handler: 'onSplitMergeMenuItemClick'
                }
            ]
        }, this.menuConfig));
        this.splitMergeMenuItem = this.menu.down('#' + this.splitMergeMenuItemId);
    },
    addGridListeners: function() {
        this.grid.on('item' + this.triggerEvent, function(grid, item, node, index, e) {
            this.onMenuTriggerEvent(e);
        }, this);
        this.grid.getEl().on(this.triggerEvent, this.onMenuTriggerEvent, this, {
            delegate: '.' + this.resizeHandleCls
        });
        this.grid.on('beforemodechange', this.onBeforeGridModeChange, this);
    },
    onBeforeGridModeChange: function(scheduler, modeCfg) {
        var modeName = Ext.isString(modeCfg) ? modeCfg : modeCfg.mode;
        if (modeName !== 'horizontal' && this.isSplit()) {
            this.merge();
        }
    },
    onSplitMergeMenuItemClick: function(menuItem, e) {
        if (this.isSplit()) {
            this.merge();
        } else {
            this.split(menuItem.splitPosition);
        }
    },
    cloneGrid: function(position) {
        var grid = this.grid,
            columns = Ext.Array.map(grid.headerCt.getGridColumns(), this.cloneColumn, this);
        columns = Ext.Array.filter(columns, function(col) {
            return col.xtype !== 'timeaxiscolumn';
        });
        var config = Ext.apply({
                partnerTimelinePanel: grid,
                xtype: grid.xtype,
                crudManager: grid.crudManager,
                eventStore: grid.eventStore,
                resourceStore: grid.resourceStore,
                dependencyStore: grid.dependencyStore,
                assignmentStore: grid.assignmentStore,
                height: position ? (this.getGridViewHeight() - position) : this.getGridViewHeight() / 2,
                maxHeight: this.getCloneMaxHeight(),
                columns: columns
            }, this.staticCloneConfig);
        config = Ext.applyIf(config, grid.initialConfig);
        config = Ext.apply(config, this.getCloneConfig(grid, config));
        return grid.addDocked(config)[0];
    },
    cloneColumn: function(col) {
        return Ext.applyIf({
            width: col.getWidth(),
            locked: col.locked,
            flex: col.flex
        }, col.initialConfig);
    },
    getGridViewHeight: function() {
        var view = this.grid.lockedGrid ? this.grid.lockedGrid.getView() : this.grid.getView();
        return view.getHeight();
    },
    setupSynchronization: function() {
        var grid = this.grid.normalGrid || this.grid;
        var clone = this.gridClone.normalGrid || this.gridClone;
        this.setupColumnSync(grid.getHeaderContainer(), clone.getHeaderContainer());
        if (this.grid.lockedGrid) {
            this.setupColumnSync(this.grid.lockedGrid.getHeaderContainer(), this.gridClone.lockedGrid.getHeaderContainer());
        }
    },
    setupColumnSync: function(mainHeaderCt, cloneHeaderCt) {
        cloneHeaderCt.mon(mainHeaderCt, {
            columnresize: this.onColumnResize,
            scope: cloneHeaderCt
        });
        // Column lock/unlock etc, too big change to sync, simply trigger a new split
        // will be also triggered on every hide/show/add/remove as columnschanged event is fired after those
        cloneHeaderCt.mon(mainHeaderCt, {
            columnschanged: this.onColumnsChanged,
            scope: this
        });
    },
    onColumnResize: function(mainHeaderCt, col, width) {
        var cloneHeaderCt = this;
        var cloneColumns = cloneHeaderCt.getGridColumns();
        cloneColumns[mainHeaderCt.items.indexOf(col)].setWidth(width);
    },
    onColumnsChanged: function(mainHeaderCt, col, fromIdx, toIdx) {
        var grid = this.grid.normalGrid || this.grid;
        var clone = this.gridClone.normalGrid || this.gridClone;
        clone.getHeaderContainer().removeAll();
        clone.getHeaderContainer().add(Ext.Array.map(grid.getHeaderContainer().getGridColumns(), this.cloneColumn, this));
        if (this.grid.lockedGrid) {
            grid = this.grid.lockedGrid;
            clone = this.gridClone.lockedGrid;
            clone.getHeaderContainer().removeAll();
            clone.getHeaderContainer().add(Ext.Array.map(grid.getHeaderContainer().getGridColumns(), this.cloneColumn, this));
        }
    },
    onMainGridResize: function() {
        var maxHeight = this.getCloneMaxHeight();
        // HACK still relevant in 6.5.3
        // https://www.sencha.com/forum/showthread.php?337699
        this.gridClone.resizer.maxHeight = this.gridClone.resizer.resizeTracker.maxHeight = maxHeight;
        if (this.gridClone.getHeight() > maxHeight) {
            this.gridClone.setHeight(maxHeight);
        }
        this.gridClone.setMaxHeight(maxHeight);
    },
    getCloneMaxHeight: function() {
        var headerHeight = this.grid.down('headercontainer').el.getBottom() - this.grid.el.getTop();
        return this.grid.getHeight() - headerHeight;
    },
    destroy: function() {
        if (this.menu) {
            this.menu.destroy();
        }
        this.callParent(arguments);
    }
});

/**
 * A grid plugin that provides a summary bar.
 *
 * **Note:** The plugin only supported in horizontal mode.
 *
 * Sample usage:
 *
 * ```javascript
 * new Sch.panel.SchedulerGrid({
 *     plugins : [{
 *         ptype    : 'scheduler_summarybar',
 *         renderer : function (events, metaData) {
 *             return events.length || '';
 *         }
 *     }],
 *     ...
 * });
 * ```
 */
Ext.define('Sch.plugin.SummaryBar', {
    extend: 'Ext.AbstractPlugin',
    mixins: [
        'Sch.mixin.Localizable'
    ],
    requires: [
        'Ext.XTemplate'
    ],
    alias: 'plugin.scheduler_summarybar',
    /**
     * @cfg {Function} renderer
     * A renderer function responsible for calculating the value and generating the HTML to put into each summary cell.
     * @param {Sch.model.Event[]} events Events in the time interval
     * @param {Object} metaData A collection of metadata about the current bar. Recognized properties are: `cls`, `style`, `attr`.
     * @return {String} The HTML string to be rendered
     */
    renderer: false,
    /**
     * @cfg {Object} scope
     * This reference for the {@link #renderer} function
     */
    scope: null,
    /**
     * @cfg {Number} height
     * A height of the summary bar
     */
    height: 20,
    titleContainer: null,
    barContainer: null,
    titleContainerCls: 'sch-summaryrow-title',
    barContainerCls: 'sch-summaryrow-view',
    grid: null,
    view: null,
    resourceStore: null,
    eventStore: null,
    tpl: '<table style="width: {totalWidth}px;" cellpadding="0" cellspacing="0">' + '<tr>' + '<tpl for="bars">' + '<td style="width: {width}px;">' + '<div class="sch-summaryrow-bar-wrapper">' + '<div class="sch-summaryrow-bar {cls}" style="{style}" {attr}>' + '<span class="sch-summaryrow-bar-text">{value}</span>' + '</div>' + '</div>' + '</td>' + '</tpl>' + '</tr>' + '</table>',
    init: function(grid) {
        var me = this;
        me.grid = grid;
        me.view = grid.getSchedulingView();
        me.eventStore = grid.getEventStore();
        me.resourceStore = grid.getResourceStore();
        me.tpl = new Ext.XTemplate(me.tpl);
        // Supported only in Horizontal mode
        if (grid.isHorizontal()) {
            me.initBars();
        }
        me.setupListeners();
        me.callParent(arguments);
    },
    initBars: function() {
        var me = this;
        me.titleContainer = me.grid.lockedGrid.addDocked({
            xtype: 'component',
            dock: 'bottom',
            height: me.height,
            cls: me.titleContainerCls,
            html: '<span class="sch-summaryrow-title-text" style="line-height: ' + me.height + 'px;">' + me.L('totalText') + '</span>'
        })[0];
        me.barContainer = me.grid.normalGrid.addDocked({
            xtype: 'component',
            dock: 'bottom',
            height: me.height,
            cls: me.barContainerCls,
            // Instantiate a Scroller, but no scrollbars
            scrollable: {
                x: false,
                y: false
            }
        })[0];
        // Partner the toolbar scroll with the view for X axis
        me.barContainer.getScrollable().addPartner(me.view.getScrollable(), 'x');
    },
    destroyBars: function() {
        var me = this;
        if (me.barContainer) {
            me.barContainer.destroy();
            me.barContainer = null;
        }
        if (me.titleContainer) {
            me.titleContainer.destroy();
            me.titleContainer = null;
        }
    },
    setupListeners: function() {
        var me = this,
            grid = me.grid;
        me.view.on('refresh', me.renderSummaryRow, me);
        var eventListeners = {
                add: me.renderSummaryRow,
                remove: me.renderSummaryRow,
                update: me.renderSummaryRow,
                scope: me
            };
        grid.mon(me.eventStore, eventListeners);
        grid.mon(me.resourceStore, eventListeners);
        if (grid.getAssignmentStore()) {
            grid.mon(grid.getAssignmentStore(), eventListeners);
        }
        me.grid.on('modechange', me.onGridModeChange, me);
    },
    onGridModeChange: function() {
        var me = this;
        if (me.grid.isHorizontal()) {
            me.initBars();
            me.renderSummaryRow();
        } else {
            me.destroyBars();
        }
    },
    renderSummaryRow: function() {
        var me = this;
        if (!me.barContainer)  {
            return;
        }
        
        var newEl = document.createElement('div');
        newEl.innerHTML = me.tpl.apply(me.buildRenderData());
        me.barContainer.el.syncContent(newEl);
    },
    buildRenderData: function() {
        var me = this,
            ticks = me.view.timeAxis.getTicks(),
            tickWidth = me.view.timeAxisViewModel.getTickWidth(),
            totalWidth = tickWidth * ticks.length;
        return {
            totalWidth: totalWidth,
            bars: Ext.Array.map(ticks, function(tick) {
                var events = me.resourceStore.getScheduledEventsInTimeSpan(tick.start, tick.end, me.eventStore),
                    data = {
                        width: tickWidth,
                        cls: '',
                        style: '',
                        attr: ''
                    };
                data.value = me.renderer ? me.renderer.call(me.scope || me, events, data) : '&nbsp;';
                return data;
            })
        };
    }
});

/**
@class Sch.plugin.TimeGap
@extends Sch.plugin.Zones

Plugin (ptype = 'scheduler_timegap') for highlighting unallocated slots of time for all resources. You can use the {@link #getZoneCls} method to customize the CSS class of the "gaps".

{@img scheduler/images/plugin-timegap.png}

To add this plugin to scheduler:


    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.TimeGap', {

                getZoneCls : function (startDate, endDate) {
                    return 'myGapCls'
                }
            })
        ]
    });

*/
Ext.define("Sch.plugin.TimeGap", {
    extend: "Sch.plugin.Zones",
    alias: "plugin.scheduler_timegap",
    requires: [
        'Ext.data.JsonStore',
        'Sch.model.Range'
    ],
    /**
     * @cfg {Ext.data.Store} store
     * @hide
     */
    /**
     * @template
     * An empty function by default, but provided so that you can return a custom CSS class for each unallocated zone area
     * @param {Date} start The start date of the unallocated time slot
     * @param {Date} end The end date of the unallocated time slot
     * @return {String} The CSS class to be applied to the zone element
     */
    getZoneCls: Ext.emptyFn,
    eventStoreListeners: null,
    init: function(scheduler) {
        this.store = new Ext.data.JsonStore({
            autoDestroy: true,
            model: 'Sch.model.Range'
        });
        this.scheduler = scheduler;
        this.setEventStore(scheduler.getEventStore());
        scheduler.on({
            afterrender: this.populateStore,
            eventstorechange: function(sched, newStore) {
                this.setEventStore(newStore);
                this.populateStore();
            },
            scope: this
        });
        this.schedulerView = scheduler.getSchedulingView();
        this.callParent(arguments);
    },
    setEventStore: function(eventStore) {
        this.eventStoreListeners && this.eventStoreListeners.destroy();
        this.eventStoreListeners = this.mon(eventStore, {
            load: this.populateStore,
            update: this.populateStore,
            remove: this.populateStore,
            add: this.populateStore,
            datachanged: this.populateStore,
            destroyable: true,
            scope: this
        });
    },
    populateStore: function(eventStore) {
        var eventsInView = this.schedulerView.getEventsInView(),
            timeGaps = [],
            viewStart = this.scheduler.getStart(),
            viewEnd = this.scheduler.getEnd(),
            l = eventsInView.getCount(),
            cursor = viewStart,
            index = 0,
            eventStart, r;
        // Sort by start time
        eventsInView.sortBy(function(r1, r2) {
            return r1.getStartDate() - r2.getStartDate();
        });
        r = eventsInView.getAt(0);
        while (cursor < viewEnd && index < l) {
            eventStart = r.getStartDate();
            if (!Sch.util.Date.betweenLesser(cursor, eventStart, r.getEndDate()) && cursor < eventStart) {
                timeGaps.push(new this.store.model({
                    StartDate: cursor,
                    EndDate: eventStart,
                    Cls: this.getZoneCls(cursor, eventStart) || ''
                }));
            }
            cursor = Sch.util.Date.max(r.getEndDate(), cursor);
            index++;
            r = eventsInView.getAt(index);
        }
        // Check if there's a gap between last cursor and view end time
        if (cursor < viewEnd) {
            timeGaps.push({
                StartDate: cursor,
                EndDate: viewEnd,
                Cls: this.getZoneCls(cursor, viewEnd) || ''
            });
        }
        // Don't refresh twice, the add will cause the zones to redraw
        this.store.removeAll(timeGaps.length > 0);
        this.store.add(timeGaps);
    }
});

/**
@class Sch.plugin.TreeCellEditing
@extends Ext.grid.plugin.CellEditing

A specialized "cell editing" plugin (ptype = 'scheduler_treecellediting'), purposed to correctly work with trees. Add it to your component (scheduler with tree view or gantt)
as usual grid plugin:

    var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This class allows us to do 'complex data editing', which is not supported by the regular CellEditing plugin or the Ext.grid.CellEditor which
 assumes a column is always tied to a single field existing on the grid store model (which is not the case for Gantt, dependencies, assignments etc).
*/
Ext.define('Sch.plugin.TreeCellEditing', {
    extend: 'Ext.grid.plugin.CellEditing',
    alias: 'plugin.scheduler_treecellediting',
    requires: [
        'Sch.patches.Element_6_5'
    ],
    lockableScope: 'locked',
    editorsStarted: 0,
    init: function() {
        // This is used to prevent editing of readonly cells
        this.on('beforeedit', this.onMyBeforeEdit, this);
        this.callParent(arguments);
    },
    getEditor: function() {
        var editor = this.callParent(arguments);
        // Patch editor to suspend task updates during the editor initialization
        if (editor && !editor._startEdit) {
            var startEdit = editor._startEdit = editor.startEdit;
            editor.startEdit = function() {
                var field = this.field,
                    result;
                // if it's a task field - suspend task updates
                if (field && field.isTaskField) {
                    field.setSuppressTaskUpdate(true);
                }
                // call original method
                result = startEdit.apply(this, arguments);
                // resume task updates back
                if (field && field.isTaskField) {
                    field.setSuppressTaskUpdate(false);
                }
                return result;
            };
        }
        return editor;
    },
    activateCell: function(position) {
        var editing = this.callParent(arguments);
        if (editing) {
            var editor = this.getEditor(position.record, position.column);
            // we override the editor editor.cancelEdit method
            if (!editor._cancelEdit) {
                editor._cancelEdit = editor.cancelEdit;
                editor.cancelEdit = this.myCancelEdit;
            }
            this.fireEvent('editingstart', this, editor);
        }
        return editing;
    },
    // private
    //cacheDeactivatedEditors: function() {
    //    var me = this,
    //        editors = me.editors.items,
    //        len = editors.length,
    //        i, editor,
    //        detachedBody = Ext.getDetachedBody();
    //    for (i = 0; i < len; i++) {
    //        editor = editors[i];
    //        if (!editor.isVisible()) {
    //            detachedBody.dom.appendChild(editor.el.dom);
    //            editor.container = detachedBody;
    //
    //            // Restore default properties to allow this elements to be collected by GC
    //            editor.el.skipGarbageCollection = false;
    //            editor.el.select('*').each(function (node) {
    //                Ext.get(node).skipGarbageCollection = false;
    //            });
    //        }
    //    }
    //},
    /*
     * Checks if the panel is not locked for editing, and prevents cell edits if needed
     */
    checkReadOnly: function() {
        var pnl = this.getCmp();
        if (pnl) {
            if (!pnl.isTimelineTreePanel && !pnl.isTimelineGridPanel) {
                pnl = pnl.up('tablepanel');
            }
            return !pnl.isReadOnly();
        }
    },
    // @OVERRIDE - model set() method, since we need to do more than just a simple update of a Model field in certain editors
    // Check for 'applyChanges' method and call it if exists
    onEditComplete: function(ed, value, startValue) {
        var me = this;
        // if field instance contains applyChanges() method
        // then we delegate saving to it
        // TODO: this should be refactored
        if (ed.field.applyChanges) {
            // for Date values value !== startValue doesn't work
            if ((value instanceof Date && (value - startValue)) || !(value instanceof Date) && value !== startValue) {
                ed.field.applyChanges(ed.field.task || me.context.record);
            }
            // Calling parent with value === startValue makes it not to call record.set() method, we don't need it
            // to be called since changes are already applyed, but leaves all other functionality inplace.
            return me.callParent([
                ed,
                value,
                value
            ]);
        } else {
            return me.callParent([
                ed,
                value,
                startValue
            ]);
        }
    },
    // While canceling editing we force the field to persist "originalValue" back to the task
    // if the field is a TaskField mixed instance
    myCancelEdit: function() {
        var me = this,
            field = me.field;
        if (field && field.applyChanges) {
            var instantUpdate = field.instantUpdate;
            // we force the field to persist "originalValue" back to the task
            field.instantUpdate = true;
            var result = me._cancelEdit.apply(this, arguments);
            field.instantUpdate = instantUpdate;
            return result;
        } else {
            return me._cancelEdit.apply(this, arguments);
        }
    },
    onMyBeforeEdit: function(sender, context) {
        var field = context.column.getEditor();
        // if it's a field mixed with TaskField mixin
        if (field && field.setTask) {
            // then after setTask calling field already has correct value
            field.setTask(context.record);
            // Sencha will force value from record and will negate effect of this method, so we pass value through
            // using special property. see line 210782 in ext-all-debug 6.0.2
            context._valueFromTaskField = field.getValue();
        }
        return this.checkReadOnly();
    },
    // OVERRIDE private method
    setEditingContext: function(context) {
        if (context.hasOwnProperty('_valueFromTaskField')) {
            context.value = context.originalValue = context._valueFromTaskField;
            delete context._valueFromTaskField;
        }
        this.callParent(arguments);
    }
});

/**
@class Sch.preset.ViewPresetHeaderRow

A part of the {@link Sch.preset.ViewPreset} declaration. Not used directly, but the properties below are rather provided 
inline as seen in sources of {@link Sch.preset.Manager}. This class is just provided for documentation purposes.

A sample header configuration will looks like: 

        headerConfig    : {
             bottom     : {
                unit        : "WEEK",
                increment   : 1,
                renderer    : function(start, end, headerConfig, index) {
                    return Ext.Date.format(start, 'd');
                }
            },
            middle : {
                unit        : "MONTH",
                renderer : function(start, end, headerConfig, index) {
                    var month = start.getMonth();
                    // Simple alternating month in bold
                    if (start.getMonth()) % 2) {
                        return '<strong>' + month + '</strong'>';
                    }
                    return month
                },
                align       : 'left'
            }
        }

*/
Ext.define("Sch.preset.ViewPresetHeaderRow", {});
/**
    * @cfg {String} unit The unit of time represented by each cell in this header row. See also increment property. 
    * Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
    */
/**
    * @cfg {Number} increment The number of units each header cell will represent (e.g. 30 together with unit: "MINUTE" for 30 minute cells)
    */
/**
    * @cfg {String} dateFormat Defines how the cell date will be formatted 
    */
/**
    * @cfg {Function} renderer A custom renderer function used to render the cell contents. It should return the text to put in the header cell.
    * The render function is called with the following parameters:
    * 
    * - `startDate` : Date - The start date of the cell.
    * - `endDate` : Date - The end date of the cell
    * - `headerConfig` : Object - An object containing the header config object. You can set 'align' (for text-align) and headerCls (a CSS class added to the cell) properties on it.
    * - `i` : Int - The index of the cell in the row.
    * 
    * Example : 

    function (startDate, endDate, headerConfig, i) {
        headerConfig.align = "left";
        headerConfig.headerCls = "myClass"; // will be added as a CSS class of the header cell DOM element

        return Ext.Date.format(startDate, 'Y-m-d');
    }

    */
/**
    * @cfg {Object} scope The scope to use for the renderer function
    */
/**
    * @cfg {Function} cellGenerator A function that should return an array of objects containing 'start', 'end' and 'header' properties. 
    * Use this if you want full control over how the header rows are generated. This is not applicable for the lowest row in your configuration. 
    */

/**
 * To analyze possible errors in your setup, include this on your HTML page and use Firebug (or any other console application) to execute line below:
 * >
 * > Sch.util.Debug.runDiagnostics();
 * > ...
 */
Ext.define("Sch.util.Debug", {
    singleton: true,
    runDiagnostics: function() {
        var log;
        var me = this;
        var C = window.console;
        if (C && C.log) {
            log = function() {
                C.log.apply(C, arguments);
            };
        } else {
            if (!me.schedulerDebugWin) {
                me.schedulerDebugWin = new Ext.Window({
                    height: 400,
                    width: 500,
                    bodyStyle: 'padding:10px',
                    closeAction: 'hide',
                    autoScroll: true
                });
            }
            me.schedulerDebugWin.show();
            me.schedulerDebugWin.update('');
            log = function(text) {
                me.schedulerDebugWin.update((me.schedulerDebugWin.body.dom.innerHTML || '') + text + '<br/>');
            };
        }
        var els = Ext.select('.sch-schedulerpanel');
        if (els.getCount() === 0)  {
            log('No scheduler component found');
        }
        
        var s = Ext.getCmp(els.elements[0].id),
            resourceStore = s.getResourceStore(),
            eventStore = s.getEventStore();
        if (!eventStore.isEventStore) {
            log("Your event store must be or extend Sch.data.EventStore");
        }
        log('Scheduler view start: ' + s.getStart() + ', end: ' + s.getEnd());
        if (!resourceStore) {
            log('No store configured');
            return;
        }
        if (!eventStore) {
            log('No event store configured');
            return;
        }
        var eventFields = new Ext.util.MixedCollection(),
            resourceFields = new Ext.util.MixedCollection();
        for (var i = 0; i < eventStore.model.prototype.fields.length; i++) {
            eventFields.add(eventStore.model.prototype.fields[i].name, eventStore.model.prototype.fields[i]);
        }
        for (i = 0; i < resourceStore.model.prototype.fields.length; i++) {
            resourceFields.add(resourceStore.model.prototype.fields[i].name, resourceStore.model.prototype.fields[i]);
        }
        log(resourceStore.getCount() + ' records in the resource store');
        log(eventStore.getCount() + ' records in the eventStore');
        var eventIdProp = eventStore.model.prototype.idProperty;
        var resourceIdProp = resourceStore.model.prototype.idProperty;
        var eventIdPropertyFound = eventFields.getByKey(eventIdProp);
        var resourceIdPropertyFound = resourceFields.getByKey(resourceIdProp);
        if (!(new eventStore.model() instanceof Sch.model.Event)) {
            log("Your event model must extend Sch.model.Event");
        }
        if (!(new resourceStore.model() instanceof Sch.model.Resource)) {
            log("Your resource model must extend Sch.model.Resource");
        }
        if (!eventIdPropertyFound) {
            log("idProperty on the event model is incorrectly setup, value: " + eventIdProp);
        }
        if (!resourceIdPropertyFound) {
            log("idProperty on the resource model is incorrectly setup, value: " + resourceIdProp);
        }
        var view = s.getSchedulingView();
        log(view.el.select(view.eventSelector).getCount() + ' events present in the DOM');
        if (eventStore.getCount() > 0) {
            if (!eventStore.first().getStartDate() || !(eventStore.first().getStartDate() instanceof Date)) {
                log('The eventStore reader is misconfigured - The StartDate field is not setup correctly, please investigate');
                log('StartDate is configured with dateFormat: ' + eventFields.getByKey(eventStore.model.prototype.startDateField).dateFormat);
                log('See Ext JS docs for information about different date formats: http://docs.sencha.com/extjs/#!/api/Ext.Date');
            }
            if (!eventStore.first().getEndDate() || !(eventStore.first().getEndDate() instanceof Date)) {
                log('The eventStore reader is misconfigured - The EndDate field is not setup correctly, please investigate');
                log('EndDate is configured with dateFormat: ' + eventFields.getByKey(eventStore.model.prototype.endDateField).dateFormat);
                log('See Ext JS docs for information about different date formats: http://docs.sencha.com/extjs/#!/api/Ext.Date');
            }
            if (eventStore.proxy && eventStore.proxy.reader && eventStore.proxy.reader.jsonData) {
                log('Dumping jsonData to console');
                console && console.dir && console.dir(eventStore.proxy.reader.rawData);
            }
            log('Records in the event store:');
            eventStore.each(function(r, i) {
                log((i + 1) + '. ' + r.startDateField + ':' + r.getStartDate() + ', ' + r.endDateField + ':' + r.getEndDate() + ', ' + r.resourceIdField + ':' + r.getResourceId());
                if (!r.getStartDate()) {
                    log(r.getStartDate());
                }
            });
        } else {
            log('Event store has no data. Has it been loaded properly?');
        }
        if (resourceStore.isTreeStore)  {
            resourceStore = resourceStore.nodeStore;
        }
        
        if (resourceStore.getCount() > 0) {
            log('Records in the resource store:');
            resourceStore.each(function(r, i) {
                log((i + 1) + '. ' + r.idProperty + ':' + r.getId());
                return;
            });
        } else {
            log('Resource store has no data.');
            return;
        }
        log('Everything seems to be setup ok!');
    }
});

// @tag dependencies
/**
 * Async dependency rendering strategy, renders dependencies asynchronously in several steps.
 * @private
 */
Ext.define('Sch.view.dependency.renderingstrategy.Async', {
    extend: 'Sch.view.dependency.renderingstrategy.Abstract',
    alias: 'sch_dependency_rendering_strategy.async',
    config: {
        /**
         * Amount of deps to render between rendering steps
         */
        depsPerStep: 50
    },
    delegateRendering: function(view, depsToRender, depsRendered) {
        var me = this,
            depsPerStep = me.getDepsPerStep(),
            renderedDeps = depsToRender.slice(0, depsPerStep),
            leftDeps = depsToRender.slice(depsPerStep);
        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), renderedDeps, false);
        return [
            renderedDeps,
            leftDeps
        ];
    }
});

// @tag dependencies
/**
 * Bulk dependency rendering strategy, renders all the dependencies scheduled for rendering in one bulk.
 * @private
 */
Ext.define('Sch.view.dependency.renderingstrategy.Bulk', {
    extend: 'Sch.view.dependency.renderingstrategy.Abstract',
    alias: 'sch_dependency_rendering_strategy.bulk',
    delegateRendering: function(view, depsToRender, depsRendered) {
        view.getPainter().paint(view.getPrimaryView(), view.getDependencyCanvas(), depsToRender, false);
        return [
            depsToRender,
            []
        ];
    }
});

/**
@class Sch.widget.PagingToolbar

This class is a specialized paging toolbar that is aware of CRUD manager functionality.
The class uses a CRUD manager data loading if the store is included to CRUD collection.
This Component loads blocks of data into the store by passing parameters used for paging criteria.

        var crudManager     = Ext.create('Sch.data.CrudManager', {
            resourceStore   : resourceStore,
            eventStore      : eventStore
        });

        Ext.create('Sch.panel.SchedulerGrid', {
            eventBarTextField   : 'Name',
            viewPreset          : 'dayAndWeek',
            startDate           : new Date(2012, 8, 10),
            endDate             : new Date(2012, 10, 10),
            width               : 800,
            height              : 350,

            crudManager         : crudManager,

            //define bottom bar with pagination toolbar
            bbar                : {
                xtype           : 'sch_pagingtoolbar',
                store           : resourceStore,
                displayInfo     : true,
                displayMsg      : 'Displaying resources {0} - {1} of {2}',
                emptyMsg        : "No resources to display"
            }
        });

*/
Ext.define('Sch.widget.PagingToolbar', {
    extend: 'Ext.toolbar.Paging',
    alias: 'widget.sch_pagingtoolbar',
    getStoreId: function() {
        if (this.storeId)  {
            return this.storeId;
        }
        
        var storeId = this.store.storeId;
        if (!storeId) {
            var crudManager = this.store.crudManager;
            var store = crudManager && crudManager.getStore(this.store);
            storeId = store && store.storeId;
        }
        this.storeId = storeId;
        return storeId;
    },
    loadPage: function(pageNum) {
        var me = this;
        if (me.store.crudManager) {
            var storeId = me.getStoreId();
            if (storeId) {
                var params = {};
                params[storeId] = {
                    pageSize: me.store.pageSize,
                    page: pageNum
                };
                me.store.crudManager.load(params);
            }
        } else {
            me.store.loadPage(pageNum);
        }
    },
    // @OVERRIDE
    // @private
    onPagingKeyDown: function(field, e) {
        var me = this,
            k = e.getKey(),
            pageData = me.getPageData(),
            increment = e.shiftKey ? 10 : 1,
            pageNum;
        if (k == e.RETURN) {
            e.stopEvent();
            pageNum = me.readPageFromInput(pageData);
            if (pageNum !== false) {
                pageNum = Math.min(Math.max(1, pageNum), pageData.pageCount);
                if (me.fireEvent('beforechange', me, pageNum) !== false) {
                    me.loadPage(pageNum);
                }
            }
        } else if (k == e.HOME || k == e.END) {
            e.stopEvent();
            pageNum = k == e.HOME ? 1 : pageData.pageCount;
            field.setValue(pageNum);
        } else if (k == e.UP || k == e.PAGE_UP || k == e.DOWN || k == e.PAGE_DOWN) {
            e.stopEvent();
            pageNum = me.readPageFromInput(pageData);
            if (pageNum) {
                if (k == e.DOWN || k == e.PAGE_DOWN) {
                    increment *= -1;
                }
                pageNum += increment;
                if (pageNum >= 1 && pageNum <= pageData.pageCount) {
                    field.setValue(pageNum);
                }
            }
        }
    },
    // @OVERRIDE
    /**
     * Move to the first page, has the same effect as clicking the 'first' button.
     */
    moveFirst: function() {
        if (this.fireEvent('beforechange', this, 1) !== false) {
            this.loadPage(1);
        }
    },
    // @OVERRIDE
    /**
     * Move to the previous page, has the same effect as clicking the 'previous' button.
     */
    movePrevious: function() {
        var me = this,
            prev = me.store.currentPage - 1;
        if (prev > 0) {
            if (me.fireEvent('beforechange', me, prev) !== false) {
                me.loadPage(prev);
            }
        }
    },
    // @OVERRIDE
    /**
     * Move to the next page, has the same effect as clicking the 'next' button.
     */
    moveNext: function() {
        var me = this,
            total = me.getPageData().pageCount,
            next = me.store.currentPage + 1;
        if (next <= total) {
            if (me.fireEvent('beforechange', me, next) !== false) {
                me.loadPage(next);
            }
        }
    },
    // @OVERRIDE
    /**
     * Move to the last page, has the same effect as clicking the 'last' button.
     */
    moveLast: function() {
        var me = this,
            last = me.getPageData().pageCount;
        if (me.fireEvent('beforechange', me, last) !== false) {
            me.loadPage(last);
        }
    },
    // @OVERRIDE
    /**
     * Refresh the current page, has the same effect as clicking the 'refresh' button.
     */
    doRefresh: function() {
        var me = this,
            current = me.store.currentPage;
        if (me.fireEvent('beforechange', me, current) !== false) {
            me.loadPage(current);
        }
    }
});

